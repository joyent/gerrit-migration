commit 6e9ebe60f43be27796fef71b63ff97d49c483530 (refs/changes/20/4820/11)
Author: dyep <dyep49@gmail.com>
Date:   2018-11-12T14:52:17-08:00 (11 months ago)
    
    OS-7182 vmadm can create/destroy/rollback bhyve VM snapshots
    Reviewed by: Josh Wilsdon <josh@wilsdon.ca>
    Reviewed by: Mike Gerdts <mike.gerdts@joyent.com>
    Reviewed by: Pedro Palaz√≥n Candel <pedro@joyent.com>

diff --git a/src/vm/man/vmadm.1m.md b/src/vm/man/vmadm.1m.md
index 03ac8d95..a09ad0e1 100644
--- a/src/vm/man/vmadm.1m.md
+++ b/src/vm/man/vmadm.1m.md
@@ -37,8 +37,8 @@ tab-complete UUIDs rather than having to type them out for every command.
 
       create-snapshot <uuid> <snapname>
 
-        Support for snapshots is currently experimental. It only works for OS
-        VMS which also have no additional datasets.
+        Support for snapshots is currently experimental. It only works for bhyve
+        VMs and OS VMs which also have no additional datasets.
 
         The <snapname> parameter specifies the name of the snapshot to take
         of the specified VM. The snapname must be 64 characters or less and
@@ -83,8 +83,8 @@ tab-complete UUIDs rather than having to type them out for every command.
 
       delete-snapshot <uuid> <snapname>
 
-        Support for snapshots is currently experimental. It only works for OS
-        VMS which also have no additional datasets.
+        Support for snapshots is currently experimental. It only works for bhyve
+        VMs and OS VMs which also have no additional datasets.
 
         This command deletes the ZFS snapshot that exists with the name
         <snapname> from the VM with the specified uuid. You cannot undo this
@@ -260,8 +260,8 @@ tab-complete UUIDs rather than having to type them out for every command.
 
       rollback-snapshot <uuid> <snapname>
 
-        Support for snapshots is currently experimental. It only works for OS
-        VMS which also have no additional datasets.
+        Support for snapshots is currently experimental. It only works for bhyve
+        VMs and OS VMs which also have no additional datasets.
 
         This command rolls the dataset backing the the VM with the specified
         uuid back to its state at the point when the snapshot with snapname was
@@ -494,9 +494,9 @@ tab-complete UUIDs rather than having to type them out for every command.
 
 ## SNAPSHOTS
 
-    Snapshots are currently only implemented for OS VMs, and only for those
-    that do not utilize delegated datasets or any other datasets other than
-    the zoneroot dataset.
+    Snapshots are currently only implemented for bhyve VMs and OS VMs, and only
+    for those that do not utilize delegated datasets or any other datasets other
+    than the zoneroot dataset and its dependent datasets.
 
     When you create a snapshot with create-snapshot, it will create a ZFS
     snapshot of that dataset with the name dataset@vmsnap-<snapname> and the
@@ -1835,12 +1835,13 @@ tab-complete UUIDs rather than having to type them out for every command.
 
     snapshots (EXPERIMENTAL):
 
-        For OS VMs, this will display a list of snapshots from which you can
-        restore the root dataset for your VM.  Currently this is only supported
-        when your VM does not have any delegated datasets.
+        For bhyve VMs and OS VMs, this will display a list of snapshots from
+        which you can restore the root dataset and its dependent datasets for
+        your VM.  Currently this is only supported when your VM does not have
+        any delegated datasets.
 
         type: array
-        vmtype: OS
+        vmtype: OS or bhyve
         listable: no
         create: no (but you can use create-snapshot)
         update: no (but you can use rollback-snapshot and delete-snapshot)
diff --git a/src/vm/node_modules/VM.js b/src/vm/node_modules/VM.js
index 710ce962..46ee41bf 100644
--- a/src/vm/node_modules/VM.js
+++ b/src/vm/node_modules/VM.js
@@ -67,7 +67,6 @@
 
 // Ensure we're using the platform's node
 require('/usr/node/node_modules/platform_node_version').assert();
-
 var assert = require('/usr/node/node_modules/assert-plus');
 var async = require('/usr/node/node_modules/async');
 var cp = require('child_process');
@@ -1459,6 +1458,7 @@ function setQuotaBhyve(opts, callback) {
     assert.number(opts.quota, 'opts.quota');
     assert.optionalNumber(opts.flexible_disk_size, 'opts.flexible_disk_size');
 
+
     var cancelFn = opts.cancelFn ? opts.cancelFn : noop;
 
     var log = opts.log;
@@ -1467,6 +1467,7 @@ function setQuotaBhyve(opts, callback) {
     var volsize = 0;
     var volrefres;
 
+
     var maxQuota = Math.max(DEFAULT_BHYVE_QUOTA,
         opts.quota * 1024 * 1024 * 1024);
     // flexible_disk_size is in MiB to match disk.*.size units.
@@ -12752,7 +12753,7 @@ exports.rollback_snapshot = function (uuid, snapname, options, callback)
             return;
         }
 
-        if (vmobj.brand === 'kvm' || vmobj.brand === 'bhyve') {
+        if (vmobj.brand === 'kvm') {
             callback(new Error('snapshots for ' + vmobj.brand
                 + ' VMs currently unsupported'));
             return;
@@ -12773,51 +12774,81 @@ exports.rollback_snapshot = function (uuid, snapname, options, callback)
             return;
         }
 
-        snapshot_list = [vmobj.zfs_filesystem + '@vmsnap-' + snapname];
+        vasync.pipeline({
+            funcs: [
+                function listSnapshots(_, next) {
+                    if (vmobj.brand !== 'bhyve') {
+                        snapshot_list = [vmobj.zfs_filesystem + '@vmsnap-'
+                            + snapname];
+                        next();
+                        return;
+                    }
 
-        if (vmobj.state !== 'stopped') {
-            VM.stop(vmobj.uuid, {'force': true, log: log}, function (stop_err) {
-                if (stop_err) {
-                    log.error(stop_err, 'failed to stop VM ' + vmobj.uuid
-                        + ': ' + stop_err.message);
-                    callback(stop_err);
-                    return;
-                }
-                performSnapshotRollback(snapshot_list, log,
-                    function (rollback_err) {
+                    var args = ['list', '-o', 'name', '-H', '-t',
+                        'snapshot', '-r', 'zones/' + vmobj.uuid ];
+
+                    zfs(args, log, function onList(zfs_err, fds) {
+                        if (zfs_err) {
+                            log.error({err: zfs_err, stdout: fds.stdout,
+                                stderr: fds.stdout}, 'zfs list failed.');
+                            next(zfs_err);
+                            return;
+                        }
+
+                        log.debug({err: zfs_err, stdout: fds.stdout,
+                            stderr: fds.stderr}, 'zfs '
+                            + args.join(' '));
+
+                        snapshot_list = fds.stdout.split('\n').filter(
+                            function matchSnapshot(snapshot) {
+                                return snapshot
+                                    .split('@vmsnap-')[1] === snapname;
+                            }
+                        );
 
-                    if (rollback_err) {
-                        log.error(rollback_err, 'failed to '
-                            + 'performSnapshotRollback');
-                        callback(rollback_err);
+                        next();
+                    });
+                },
+                function stopVm(_, next) {
+                    if (vmobj.state === 'stopped') {
+                        next();
                         return;
                     }
-                    if (options.do_not_start) {
-                        callback();
-                    } else {
-                        VM.start(vmobj.uuid, {}, {log: log}, callback);
-                    }
-                    return;
-                });
-            });
-        } else {
-            performSnapshotRollback(snapshot_list, log,
-                function (rollback_err) {
 
-                if (rollback_err) {
-                    log.error(rollback_err, 'failed to '
-                        + 'performSnapshotRollback');
-                    callback(rollback_err);
-                    return;
-                }
-                if (options.do_not_start) {
-                    callback();
-                } else {
-                    VM.start(vmobj.uuid, {}, {log: log}, callback);
+                    VM.stop(vmobj.uuid, {'force': true, log: log},
+                        function vmStopped(stop_err) {
+                            if (stop_err) {
+                                log.error(stop_err, 'failed to stop VM '
+                                    + vmobj.uuid + ': ' + stop_err.message);
+                                next(stop_err);
+                                return;
+                            }
+
+                            next();
+                        }
+                    );
+                },
+                function performRollback(_, next) {
+                    performSnapshotRollback(snapshot_list, log,
+                        function (rollback_err) {
+                            if (rollback_err) {
+                                log.error(rollback_err, 'failed to '
+                                    + 'performSnapshotRollback');
+                                next(rollback_err);
+                                return;
+                            }
+
+                            if (options.do_not_start) {
+                                next();
+                                return;
+                            }
+
+                            VM.start(vmobj.uuid, {}, {log: log}, next);
+                        }
+                    );
                 }
-                return;
-            });
-        }
+            ]
+        }, callback);
     });
 };
 
@@ -12901,7 +12932,7 @@ exports.delete_snapshot = function (uuid, snapname, options, callback)
         }, function (cb) {
             var snap;
 
-            if (vmobj.brand === 'kvm' || vmobj.brand === 'bhyve') {
+            if (vmobj.brand === 'kvm') {
                 callback(new Error('snapshots for ' + vmobj.brand
                     + ' VMs currently unsupported'));
                 return;
@@ -12941,6 +12972,11 @@ exports.delete_snapshot = function (uuid, snapname, options, callback)
             cb();
         }, function (cb) {
             // umount snapshot
+            if (vmobj.brand === 'bhyve') {
+                cb();
+                return;
+            }
+
             var argv;
             var cmd = '/usr/sbin/umount';
 
@@ -12964,6 +13000,11 @@ exports.delete_snapshot = function (uuid, snapname, options, callback)
                 cb();
             });
         }, function (cb) {
+            if (vmobj.brand === 'bhyve') {
+                cb();
+                return;
+            }
+
             // remove the mountpoint directory
             fs.rmdir(mountpoint, function (e) {
                 if (e) {
@@ -13005,10 +13046,15 @@ exports.delete_snapshot = function (uuid, snapname, options, callback)
                     cancelFn = vs.watchForChanges(obj, changes, opts, cb2);
                 },
                 function (cb2) {
+                    var args;
                     var zfssnapname = util.format('%s@vmsnap-%s',
                         vmobj.zfs_filesystem, snapname);
 
-                    var args = ['destroy', zfssnapname];
+                    if (vmobj.brand === 'bhyve') {
+                        args = ['destroy', '-r', zfssnapname];
+                    } else {
+                        args = ['destroy', zfssnapname];
+                    }
 
                     zfs(args, log, function (e, fds) {
                         if (e) {
@@ -13196,7 +13242,7 @@ exports.create_snapshot = function (uuid, snapname, options, callback)
             var full_snapname;
             var snap;
 
-            if (vmobj.brand === 'kvm' || vmobj.brand === 'bhyve') {
+            if (vmobj.brand === 'kvm') {
                 cb(new Error('snapshots for ' + vmobj.brand
                     + ' VMs currently unsupported'));
                 return;
@@ -13272,7 +13318,13 @@ exports.create_snapshot = function (uuid, snapname, options, callback)
                 },
                 function (cb2) {
                     // take the snapshot
-                    var args = ['snapshot'].concat(snapshot_list);
+                    var args;
+
+                    if (vmobj.brand === 'bhyve') {
+                        args = ['snapshot', '-r'].concat(snapshot_list);
+                    } else {
+                        args = ['snapshot'].concat(snapshot_list);
+                    }
 
                     zfs(args, log, function (zfs_err, fds) {
                         if (zfs_err) {
@@ -13294,6 +13346,12 @@ exports.create_snapshot = function (uuid, snapname, options, callback)
                 cb(err2);
             });
         }, function (cb) {
+            if (vmobj.brand === 'bhyve') {
+                mount_snapshot = false;
+                cb();
+                return;
+            }
+
             if (vmobj.zone_state !== 'running') {
                 log.info('Not mounting snapshot as zone is in state '
                     + vmobj.zone_state + ', must be: running');
diff --git a/src/vm/node_modules/vminfod/client.js b/src/vm/node_modules/vminfod/client.js
index 605cca78..aafcb376 100644
--- a/src/vm/node_modules/vminfod/client.js
+++ b/src/vm/node_modules/vminfod/client.js
@@ -112,8 +112,8 @@
  *    {
  *        path: ['quota'],
  *        action: 'changed',
- *        from: 10,
- *        to: 20
+ *        oldValue: 10,
+ *        newValue: 20
  *    }
  * ];
  * var cancel = vs.watchForChanges(obj, changes, opts, function (err) {
diff --git a/src/vm/tests/test-snapshots.js b/src/vm/tests/test-snapshots.js
index e432942b..4a25639e 100644
--- a/src/vm/tests/test-snapshots.js
+++ b/src/vm/tests/test-snapshots.js
@@ -33,6 +33,7 @@ var path = require('path');
 var VM = require('/usr/vm/node_modules/VM');
 var vasync = require('/usr/vm/node_modules/vasync');
 var vmtest = require('../common/vmtest.js');
+var vminfod = require('/usr/vm/node_modules/vminfod/client');
 
 // this puts test stuff in global, so we need to tell jsl about that:
 /* jsl:import ../node_modules/nodeunit-plus/index.js */
@@ -168,8 +169,8 @@ test('create KVM VM', function (t) {
         } else {
             t.ok(true, 'VM created with uuid ' + obj.uuid);
             VM.load(obj.uuid, function (e, o) {
-                common.ifError(t, err, 'loading VM after create');
-                if (!err) {
+                common.ifError(t, e, 'loading VM after create');
+                if (!e) {
                     t.ok(o.snapshots.length === 0, 'VM has no snapshots');
                     vmobj = o;
                 } else {
@@ -241,7 +242,6 @@ test('delete KVM VM', function (t) {
 //    create 100 snapshots
 //    delete 100 snapshots
 
-
 test('create joyent-minimal VM w/o delegated', function (t) {
     var payload = {
         alias: 'test-snapshots-' + process.pid,
@@ -258,8 +258,8 @@ test('create joyent-minimal VM w/o delegated', function (t) {
         } else {
             t.ok(true, 'VM created with uuid ' + obj.uuid);
             VM.load(obj.uuid, function (e, o) {
-                common.ifError(t, err, 'loading VM after create');
-                if (!err) {
+                common.ifError(t, e, 'loading VM after create');
+                if (!e) {
                     t.ok(o.snapshots.length === 0, 'no snapshots after create');
                     t.ok(o.hasOwnProperty('zfs_filesystem'),
                         'has zfs_filesystem');
@@ -931,8 +931,8 @@ test('create stopped joyent-minimal VM', function (t) {
         } else {
             t.ok(true, 'VM created with uuid ' + obj.uuid);
             VM.load(obj.uuid, function (e, o) {
-                common.ifError(t, err, 'loading VM after create');
-                if (!err) {
+                common.ifError(t, e, 'loading VM after create');
+                if (!e) {
                     t.ok(o.snapshots.length === 0, 'no snapshots after create');
                     t.ok(o.hasOwnProperty('zfs_filesystem'),
                         'has zfs_filesystem');
@@ -1023,8 +1023,8 @@ function (t) {
         } else {
             t.ok(true, 'VM created with uuid ' + obj.uuid);
             VM.load(obj.uuid, function (e, o) {
-                common.ifError(t, err, 'loading VM after create');
-                if (!err) {
+                common.ifError(t, e, 'loading VM after create');
+                if (!e) {
                     t.ok(o.snapshots.length === 0, 'no snapshots after create');
                     t.ok(o.hasOwnProperty('zfs_filesystem'),
                         'has zfs_filesystem');
@@ -1243,3 +1243,359 @@ test('delete VM with garbage snapshot', function (t) {
         vmobj = {};
     });
 });
+
+function waitForUserScript(uuid, callback) {
+    var watchObj = {
+        uuid: uuid
+    };
+
+    var changes = [
+        {
+            path: ['customer_metadata', 'userScriptHasRun'],
+            action: 'changed',
+            oldValue: 'false',
+            newValue: 'true'
+        }
+    ];
+
+    var opts = {
+        timeout: 300 * 1000,
+        teardown: true
+    };
+
+    var vs = new vminfod.VminfodEventStream();
+    vs.watchForChanges(watchObj, changes, opts, callback);
+}
+
+
+// To observe file changes on bhyve disks, we use a user-script to
+// read relevant files and mdata-put their contents, allowing us to
+// observe the files from the global zone.
+test('create bhyve VM', function (t) {
+    var payload = {
+        alias: 'test-snapshots-' + process.pid,
+        brand: 'bhyve',
+        autoboot: true,
+        do_not_inventory: true,
+        ram: 128,
+        flexible_disk_size: 20480,
+        disks: [
+            {
+                boot: true,
+                image_uuid: vmtest.CURRENT_BHYVE_CENTOS_UUID,
+                model: 'virtio'
+            },
+            {
+                size: 2048,
+                model: 'virtio'
+            }
+        ],
+        customer_metadata: {
+            'user-script': [
+                'DISK0_TMP_DIR="/mnt/tmp"',
+                'DISK0_TMP_FILE="/mnt/tmp/snapshot-test.txt"',
+                'DISK1_TMP_FILE="/snapshot-test.txt"',
+                'mdata-put userScriptHasRun "false"',
+                'if [ -f $DISK0_TMP_FILE ]; then',
+                '    echo -n "newString" > $DISK0_TMP_FILE',
+                'else',
+                '    mkdir $DISK0_TMP_DIR',
+                '    echo -n "oldString" > $DISK0_TMP_FILE',
+                'fi;',
+                'if [ -f $DISK1_TMP_FILE ]; then',
+                '   echo -n "newString" > $DISK1_TMP_FILE',
+                'else',
+                '   echo -n "oldString" > $DISK1_TMP_FILE',
+                'fi;',
+                'cat $DISK0_TMP_FILE | mdata-put disk0test',
+                'cat $DISK1_TMP_FILE | mdata-put disk1test',
+                'sync',
+                'mdata-put userScriptHasRun "true"'
+            ].join('\n')
+        }
+    };
+
+    VM.create(payload, function (err, obj) {
+        common.ifError(t, err, 'error creating VM');
+        if (err) {
+            abort = true;
+            t.end();
+            return;
+        }
+
+        t.ok(true, 'VM created with uuid ' + obj.uuid);
+
+        vmobj = obj;
+
+        waitForUserScript(vmobj.uuid, function onUserScript(e) {
+            common.ifError(t, e, 'error waiting for user script');
+            if (e) {
+                abort = true;
+                t.end();
+                return;
+            }
+
+            t.end();
+        });
+    });
+});
+
+test('verify metadata', function (t) {
+    if (abort) {
+        t.ok(false, 'skipping verification as test run is aborted.');
+        t.end();
+        return;
+    }
+
+    VM.load(vmobj.uuid, function onLoaded(err, obj) {
+        common.ifError(t, err, 'loading VM after create');
+
+        if (err) {
+            abort = true;
+            t.end();
+            return;
+        }
+
+        t.ok(obj.snapshots.length === 0, 'VM has no snapshots');
+        t.ok(obj.customer_metadata.disk0test === 'oldString',
+                'File written to disk0');
+        t.ok(obj.customer_metadata.disk1test === 'oldString',
+                'File written to disk1');
+        t.end();
+    });
+});
+
+test('take snapshot', function (t) {
+    if (abort) {
+        t.ok(false, 'skipping snapshot as test run is aborted.');
+        t.end();
+        return;
+    }
+
+    VM.create_snapshot(vmobj.uuid, 'snapshot1', {}, function (err) {
+        common.ifError(t, err, 'creating snapshot of ' + vmobj.uuid);
+
+        VM.load(vmobj.uuid, function (e, o) {
+            common.ifError(t, e, 'loading VM after create snapshot');
+
+            if (e) {
+                abort = true;
+                t.end();
+                return;
+            }
+
+            t.ok(o.snapshots.length === 1,
+                '1 snapshot after create snapshot');
+            t.ok(hasSnapshot(o.snapshots, 'snapshot1'),
+                'snapshot1 after create snapshot');
+            t.end();
+        });
+    });
+});
+
+test('reboot to change file', function (t) {
+    if (abort) {
+        t.ok(false, 'skipping reboot as test run is aborted.');
+        t.end();
+        return;
+    }
+
+    VM.reboot(vmobj.uuid, {}, function (err) {
+        common.ifError(t, err, 'rebooting vm');
+
+        if (err) {
+            abort = true;
+            t.end();
+            return;
+        }
+
+        waitForUserScript(vmobj.uuid, function onUserScript(e) {
+            common.ifError(t, e, 'error waiting for user script');
+
+            if (e) {
+                abort = true;
+            }
+
+            t.end();
+        });
+    });
+});
+
+test('verify updated metadata', function (t) {
+    if (abort) {
+        t.ok(false, 'skipping verification as test run is aborted.');
+        t.end();
+        return;
+    }
+
+    VM.load(vmobj.uuid, function onLoaded(err, obj) {
+        common.ifError(t, err, 'loading vm');
+
+        if (err) {
+            abort = true;
+            t.end();
+            return;
+        }
+
+        t.ok(obj.customer_metadata.disk0test === 'newString',
+            'disk0 file updates');
+        t.ok(obj.customer_metadata.disk1test === 'newString',
+            'disk1 file updates');
+        t.end();
+    });
+});
+
+test('rollback to snapshot1 and verify metadata', function (t) {
+    if (abort) {
+        t.ok(false, 'skipping rollback as test run is aborted.');
+        t.end();
+        return;
+    }
+
+    VM.rollback_snapshot(vmobj.uuid, 'snapshot1', {do_not_start: true},
+        function (err) {
+            common.ifError(t, err, 'error rolling back snapshot');
+
+            VM.load(vmobj.uuid, function (e, o) {
+                common.ifError(t, e, 'loading vm after rollback');
+                if (e) {
+                    abort = true;
+                    t.end();
+                    return;
+                }
+
+                t.ok(o.snapshots.length === 1,
+                    '1 snapshot remains after rollback');
+                t.ok(hasSnapshot(o.snapshots, 'snapshot1'),
+                    'snapshot1 after rollback');
+                // verifies that the zoneroot gets rolled back
+                t.ok(o.customer_metadata.disk0test === 'oldString',
+                    'disk0 metadata gets rolled back');
+                t.ok(o.customer_metadata.disk1test === 'oldString',
+                    'disk1 metadata gets rolled back');
+                t.end();
+            });
+        }
+    );
+});
+
+test('clear metadata keys and change user-script', function (t) {
+    if (abort) {
+        t.ok(false, 'skipping metadata update as test run is aborted.');
+        t.end();
+        return;
+    }
+
+    VM.update(vmobj.uuid, {
+        remove_customer_metadata: ['disk0test', 'disk1test'],
+        set_customer_metadata: {
+            'user-script': 'mdata-put userScriptHasRun "false"; '
+                + 'cat /mnt/tmp/snapshot-test.txt | '
+                + 'mdata-put disk0test; '
+                + 'cat /snapshot-test.txt | mdata-put disk1test; '
+                + 'mdata-put userScriptHasRun "true"'
+        }
+    }, function (err) {
+        common.ifError(t, err, 'error updating customer_metadata');
+
+        VM.load(vmobj.uuid, function onLoaded(e, o) {
+            common.ifError(t, e, 'loading VM after updating metadata');
+            if (e) {
+                abort = true;
+                t.end();
+                return;
+            }
+
+            t.ok(o.customer_metadata.disk0test === undefined,
+                'disk0 metdata was cleared');
+            t.ok(o.customer_metadata.disk1test === undefined,
+                'disk1 metdata was cleared');
+
+            t.end();
+        });
+    });
+});
+
+test('start VM and verify files have been rolled back', function (t) {
+    if (abort) {
+        t.ok(false, 'skipping VM start as test run is aborted.');
+        t.end();
+        return;
+    }
+
+    VM.start(vmobj.uuid, {}, {}, function (err) {
+        if (err) {
+            abort = true;
+            t.end();
+            return;
+        }
+
+        waitForUserScript(vmobj.uuid, function onUserScript(e) {
+            common.ifError(t, e, 'error waiting for user script');
+            if (e) {
+                abort = true;
+                t.end();
+                return;
+            }
+
+            t.end();
+        });
+    });
+});
+
+test('verify rolled back metadata', function (t) {
+    if (abort) {
+        t.ok(false, 'skipping verification as test run is aborted.');
+        t.end();
+        return;
+    }
+
+    VM.load(vmobj.uuid, function onLoaded(err, obj) {
+        common.ifError(t, err, 'loading VM after start');
+
+        if (err) {
+            abort = true;
+            t.end();
+            return;
+        }
+
+        t.ok(obj.customer_metadata.disk0test === 'oldString',
+            'file on disk0 was successfully rolled back');
+        t.ok(obj.customer_metadata.disk1test === 'oldString',
+            'file on disk1 was successfully rolled back');
+        t.end();
+    });
+});
+
+test('delete snapshot1 from bhyve', function (t) {
+    if (abort) {
+        t.ok(false, 'skipping deletion as test run is aborted.');
+        t.end();
+        return;
+    }
+
+    deleteSnapshot(t, vmobj.uuid, 'snapshot1', 0, function (err) {
+        common.ifError(t, err, 'deleting snapshot1 of ' + vmobj.uuid);
+        if (err) {
+            abort = true;
+        }
+        t.end();
+    });
+});
+
+test('delete bhyve VM', function (t) {
+    if (vmobj.uuid) {
+        VM.delete(vmobj.uuid, function (err) {
+            common.ifError(t, err, 'error deleting VM');
+
+            if (!err) {
+                t.ok(true, 'deleted VM: ' + vmobj.uuid);
+            }
+
+            t.end();
+        });
+    } else {
+        t.ok(false, 'no VM to delete');
+        t.end();
+    }
+});
