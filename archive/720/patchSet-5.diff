commit ad4fe3dcd30667c63fb78d65eee555b08552483e (refs/changes/20/720/5)
Author: Marsell Kukuljevic <marsell@joyent.com>
Date:   2016-10-21T13:48:22+13:00 (3 years ago)
    
    PUBAPI-1310: Upgrade Node.js to v4 before 0.10 EOL in Oct 2016
    PUBAPI-1336: Add test for uncaughtexception handler
    PUBAPI-1339: Move haproxy from cloudapi repo to pkgsrc

diff --git a/Makefile b/Makefile
index b26eded..3878729 100644
--- a/Makefile
+++ b/Makefile
@@ -47,9 +47,9 @@ CLEAN_FILES	+= node_modules cscope.files
 
 # The prebuilt sdcnode version we want. See
 # "tools/mk/Makefile.node_prebuilt.targ" for details.
-NODE_PREBUILT_VERSION=v0.10.48
+NODE_PREBUILT_VERSION=v4.6.1
 ifeq ($(shell uname -s),SunOS)
-	NODE_PREBUILT_IMAGE=de411e86-548d-11e4-a4b7-3bb60478632a
+	NODE_PREBUILT_IMAGE=18b094b0-eb01-11e5-80c1-175dac7ddf02
 	NODE_PREBUILT_TAG=zone
 endif
 
@@ -87,7 +87,7 @@ PATH	:= $(NODE_INSTALL)/bin:/opt/local/bin:${PATH}
 all: build sdc-scripts
 
 .PHONY: build
-build: haproxy $(SMF_MANIFESTS) | $(TAP) $(REPO_DEPS)
+build: $(SMF_MANIFESTS) | $(TAP) $(REPO_DEPS)
 	$(NPM) install
 
 $(TAP): | $(NPM_EXEC)
@@ -100,21 +100,6 @@ clean-docs:
 clean:: clean-docs
 
 
-# Build HAProxy when in SunOS
-.PHONY: haproxy
-ifeq ($(shell uname -s),SunOS)
-haproxy:
-	@echo "Building HAproxy"
-	cd deps/haproxy-1.4.21 && /opt/local/bin/gmake TARGET=solaris
-else
-haproxy:
-	@echo "HAproxy building only in SunOS"
-endif
-
-
-CLEAN_FILES += deps/haproxy-1.4.21/haproxy
-
-
 .PHONY: release
 release: check build docs
 	@echo "Building $(RELEASE_TARBALL)"
@@ -124,7 +109,6 @@ release: check build docs
 	@mkdir -p $(RELSTAGEDIR)/root
 	@mkdir -p $(RELSTAGEDIR)/root/opt/smartdc/cloudapi/ssl
 	cp -r	$(ROOT)/bin \
-		$(ROOT)/deps/haproxy-1.4.21 \
 		$(ROOT)/etc \
 		$(ROOT)/lib \
 		$(ROOT)/plugins \
@@ -157,7 +141,7 @@ publish: release
 	mkdir -p $(BITS_DIR)/$(NAME)
 	cp $(ROOT)/$(RELEASE_TARBALL) $(BITS_DIR)/$(NAME)/$(RELEASE_TARBALL)
 
-.PHONY: test no_machines_test auth_test account_test analytics_test datacenters_test datasets_test fabrics_test images_test keys_test networks_test nics_test machines_all_test machines_70_test machines_71_test machines_72_test machines_73_test machines_80_test machines_test packages_test populate_networks_test services_test users_test provision_limits_plugin_test plugins_test
+.PHONY: test no_machines_test auth_test account_test analytics_test datacenters_test datasets_test fabrics_test images_test keys_test networks_test nics_test machines_all_test machines_70_test machines_71_test machines_72_test machines_73_test machines_80_test machines_test packages_test populate_networks_test services_test users_test provision_limits_plugin_test plugins_test tests_test
 
 auth_test: $(TAP)
 	$(NODE_EXEC) $(TAP) test/auth.test.js
@@ -220,12 +204,15 @@ populate_network_test: $(TAP)
 services_test: $(TAP)
 	$(NODE_EXEC) $(TAP) test/services.test.js
 
+tests_test: $(TAP)
+	$(NODE_EXEC) $(TAP) test/tests.test.js
+
 users_test: $(TAP)
 	$(NODE_EXEC) $(TAP) test/users.test.js
 
-test: auth_test account_test analytics_test datacenters_test datasets_test fabrics_test images_test keys_test networks_test packages_test populate_network_test services_test users_test nics_test machines_test
+test: auth_test account_test analytics_test datacenters_test datasets_test fabrics_test images_test keys_test networks_test packages_test populate_network_test services_test tests_test users_test nics_test machines_test
 
-no_machines_test: auth_test account_test analytics_test datacenters_test datasets_test fabrics_test images_test keys_test networks_test packages_test populate_network_test services_test users_test
+no_machines_test: auth_test account_test analytics_test datacenters_test datasets_test fabrics_test images_test keys_test networks_test packages_test populate_network_test services_test tests_test users_test
 
 provision_limits_plugin_test:
 	$(NODE_EXEC) $(TAP) test/provision_limits.test.javascript
diff --git a/boot/setup.sh b/boot/setup.sh
index 365a4fa..c9e2eab 100755
--- a/boot/setup.sh
+++ b/boot/setup.sh
@@ -72,7 +72,7 @@ function setup_cloudapi {
 
     svccfg import $SVC_ROOT/smf/manifests/haproxy.xml || \
         fatal "unable to import haproxy"
-    svcadm enable "cloudapi/haproxy" || fatal "unable to start haproxy"
+    svcadm enable "pkgsrc/haproxy" || fatal "unable to start haproxy"
 
     #cloudapi instances
     local cloudapi_xml_in=$SVC_ROOT/smf/manifests/cloudapi.xml.in
diff --git a/deps/haproxy-1.4.21/.gitignore b/deps/haproxy-1.4.21/.gitignore
deleted file mode 100644
index 38b4111..0000000
--- a/deps/haproxy-1.4.21/.gitignore
+++ /dev/null
@@ -1,15 +0,0 @@
-*.o
-*/.svn
-*~
-.flxdisk*
-.flxpkg
-.flxstatus*
-.svn
-haproxy
-src/*.o
-*.rej
-*.orig
-*.log*
-*.trace*
-make-*
-dlmalloc.c
diff --git a/deps/haproxy-1.4.21/CHANGELOG b/deps/haproxy-1.4.21/CHANGELOG
deleted file mode 100644
index 71b058b..0000000
--- a/deps/haproxy-1.4.21/CHANGELOG
+++ /dev/null
@@ -1,2130 +0,0 @@
-ChangeLog :
-===========
-
-2012/05/21 : 1.4.21
-    - MINOR: patch for minor typo (ressources/resources)
-    - CLEANUP: fix typo in findserver() log message
-    - DOC: cleanup indentation, alignment, columns and chapters
-    - DOC: fix some keywords arguments documentation
-    - MINOR: stats admin: allow unordered parameters in POST requests
-    - MINOR: stats admin: use the backend id instead of its name in the form
-    - BUG/MAJOR: trash must always be the size of a buffer
-    - DOC: fix minor regex example issue and improve doc on stats
-    - BUG/MAJOR: possible crash when using capture headers on TCP frontends
-    - MINOR: config: disable header captures in TCP mode and complain
-    - BUG/MEDIUM: balance source did not properly hash IPv6 addresses
-    - CLEANUP: http: message parser must ignore HTTP_MSG_ERROR
-    - CLEANUP: remove a few warning about unchecked return values in debug code
-    - CLEANUP: http: remove unused http_msg->col
-    - BUG/MINOR: http: error snapshots are wrong if buffer wraps
-    - BUG/MAJOR: checks: don't call set_server_status_* when no LB algo is set
-    - MINOR: proxy: make findproxy() return proxies from numeric IDs too
-    - BUILD: http: stop gcc-4.1.2 from complaining about possibly uninitialized values
-    - BUG/MINOR: stop connect timeout when connect succeeds
-
-2012/03/10 : 1.4.20
-    - BUG/MINOR: fix typo in processing of http-send-name-header
-    - BUG/MEDIUM: correctly disable servers tracking another disabled servers.
-    - BUG/MEDIUM: zero-weight servers must not dequeue requests from the backend
-    - MINOR: halog: add some help on the command line     (cherry picked from commit 615674cdec067066a42f53f5d55628ab7b207e6c)
-    - BUILD: fix build error on FreeBSD
-    - BUG: queue: fix dequeueing sequence on HTTP keep-alive sessions
-    - BUG: http: disable TCP delayed ACKs when forwarding content-length data
-    - BUG: checks: fix server maintenance exit sequence
-    - BUG/MINOR: stream_sock: don't remove BF_EXPECT_MORE and BF_SEND_DONTWAIT on partial writes
-    - DOC: enumerate valid status codes for "observe layer7"
-    - BUILD: make it possible to look for pcre in the default system paths
-
-2012/01/08 : 1.4.19
-    - MEDIUM: http: add support for sending the server's name in the outgoing request
-    - BUG/MINOR: fix options forwardfor if-none when an alternative header name is specified
-    - MINOR: task: new function task_schedule() to schedule a wake up
-    - BUG/MEDIUM: checks: fix slowstart behaviour when server tracking is in use
-    - BUG: tcp: option nolinger does not work on backends
-    - BUG: ebtree: ebst_lookup() could return the wrong entry
-    - BUG: http: re-enable TCP quick-ack upon incomplete HTTP requests
-    - CLEANUP: ebtree: remove a few annoying signedness warnings
-    - CLEANUP: ebtree: remove 4-year old harmless typo in duplicates insertion code
-    - CLEANUP: ebtree: remove another typo, a wrong initialization in insertion code
-    - BUG: proto_tcp: set AF_INET on tproxy for use with recent kernels
-    - MINOR: halog: add support for matching queued requests
-    - BUG: http: tighten the list of allowed characters in a URI
-
-2011/09/16 : 1.4.18
-    - [MINOR] http: *_dom matching header functions now also split on ":"
-    - [MINOR] halog: support backslash-escaped quotes
-    - BUILD/MINOR: fix the source URL in the spec file
-    - DOC: acl is http_first_req, not http_req_first
-    - BUG/MEDIUM: don't trim last spaces from headers consisting only of spaces
-    - MINOR: acl: add new matches for header/path/url length
-    - [MINOR] halog: do not consider byte 0x8A as end of line
-    - [OPTIM] halog: make fgets parse more bytes by blocks
-    - [OPTIM] halog: add assembly version of the field lookup code
-    - [CLEANUP] startup: report only the basename in the usage message
-    - [DOC] update the README file to reflect new naming rules for patches
-    - BUILD: halog: make halog build on solaris
-
-2011/09/05 : 1.4.17
-    - [MINOR] halog: add support for termination code matching (-tcn/-TCN)
-    - [MINOR] halog: make SKIP_CHAR stop on field delimiters
-    - [MINOR] halog: add support for HTTP log matching (-H)
-    - [MINOR] halog: gain back performance before SKIP_CHAR fix
-    - [OPTIM] halog: cache some common fields positions
-    - [OPTIM] halog: check once for correct line format and reuse the pointer
-    - [OPTIM] halog: remove many 'if' by using a function pointer for the filters
-    - [OPTIM] halog: remove support for tab delimiters in input data
-    - [MINOR] halog: add -hs/-HS to filter by HTTP status code range
-    - [CLEANUP] update the year in the copyright banner
-    - [BUG] check: http-check expect + regex would crash in defaults section
-    - [MEDIUM] http: make x-forwarded-for addition conditional
-    - [DOC] fixed a few "sensible" -> "sensitive" errors
-    - [MINOR] stats: display "<NONE>" instead of the frontend name when unknown
-    - [BUG] http: trailing white spaces must also be trimmed after headers
-    - [MINOR] http: take a capture of too large requests and responses
-    - [MINOR] http: take a capture of truncated responses
-    - [MINOR] http: take a capture of bad content-lengths.
-
-2011/08/04 : 1.4.16
-    - [BUG] checks: fix support of Mysqld >= 5.5 for mysql-check
-    - [DOC] Minor spelling fixes and grammatical enhancements
-    - [CLEANUP] Remove assigned but unused variables
-    - [BUG] checks: http-check expect could fail a check on multi-packet responses
-    - [DOC] fix minor typo in the "dispatch" doc
-    - [MINOR] http: make the "HTTP 200" status code configurable.
-    - [MINOR] http: partially revert the chunking optimization for now
-    - [MINOR] stream_sock: always clear BF_EXPECT_MORE upon complete transfer
-    - [CLEANUP] stream_sock: remove unneeded FL_TCP and factor out test
-    - [MEDIUM] http: add support for "http-no-delay"
-    - [OPTIM] http: optimize chunking again in non-interactive mode
-    - [OPTIM] stream_sock: avoid fast-forwarding of partial data
-    - [OPTIM] stream_sock: don't use splice on too small payloads
-    - [BUG] stats: support url-encoded forms
-    - [BUG] halog: correctly handle truncated last line
-    - [DOC] fix typos, "#" is a sharp, not a dash
-
-2011/04/08 : 1.4.15
-    - [CRITICAL] fix risk of crash when dealing with space in response cookies
-
-2011/03/29 : 1.4.14
-    - [MINOR] config: fix endianness of server check port
-    - [BUG] http: fix possible incorrect forwarded wrapping chunk size (take 2)
-    - [MINOR] tools: add two macros MID_RANGE and MAX_RANGE
-    - [BUG] http: fix content-length handling on 32-bit platforms
-    - [OPTIM] buffers: uninline buffer_forward()
-
-2011/03/09 : 1.4.13
-    - [BUG] config: don't crash on empty pattern files.
-
-2011/03/08 : 1.4.12
-    - [MINOR] stats: add support for several packets in stats admin
-    - [BUG] stats: admin commands must check the proxy state
-    - [BUG] stats: admin web interface must check the proxy state
-    - [BUG] http: update the header list's tail when removing the last header
-    - [DOC] fix typos (http-request instead of http-check)     (cherry picked from commit 8f2a1e72bebea700f37add40997b716fdfd86b9c)
-    - [BUG] http: use correct ACL pointer when evaluating authentication
-    - [BUG] cfgparse: correctly count one socket per port in ranges
-    - [BUG] startup: set the rlimits before binding ports, not after.
-    - [BUG] acl: srv_id must return no match when the server is NULL
-    - [BUG] acl: fd leak when reading patterns from file
-    - [DOC] fix minor typo in "usesrc"
-    - [BUG] http: fix possible incorrect forwarded wrapping chunk size
-    - [BUG] http: fix computation of message body length after forwarding has started
-    - [BUG] http: balance url_param did not work with first parameters on POST
-    - [TESTS] update the url_param regression test to test check_post too
-
-2011/02/10 : 1.4.11
-    - [MINOR] cfgparse: Check whether the path given for the stats socket actually fits into the sockaddr_un structure to avoid truncation.
-    - [DOC] fix a minor typo
-    - [DOC] fix ignore-persist documentation
-    - [BUG] http: fix http-pretend-keepalive and httpclose/tunnel mode
-    - [MINOR] add warnings on features not compatible with multi-process mode
-    - [MINOR] acl: add be_id/srv_id to match backend's and server's id
-    - [MINOR] log: add support for passing the forwarded hostname
-    - [MINOR] log: ability to override the syslog tag
-    - [DOC] fix minor typos in the doc
-    - [DOC] fix another typo in the doc
-    - [BUG] http chunking: don't report a parsing error on connection errors
-    - [BUG] stream_interface: truncate buffers when sending error messages
-    - [BUG] http: fix incorrect error reporting during data transfers
-    - [CRITICAL] session: correctly leave turn-around and queue states on abort
-    - [BUG] session: release slot before processing pending connections
-    - [MINOR] stats: report HTTP message state and buffer flags in error dumps
-    - [MINOR] http: support wrapping messages in error captures
-    - [MINOR] http: capture incorrectly chunked message bodies
-    - [MINOR] stats: add global event ID and count
-    - [OPTIM] http: don't send each chunk in a separate packet
-    - [BUG] acl: fix handling of empty lines in pattern files
-    - [BUG] ebtree: fix ebmb_lookup() with len smaller than the tree's keys
-    - [OPTIM] ebtree: ebmb_lookup: reduce stack usage by moving the return code out of the loop
-
-2010/11/29 : 1.4.10
-    - [BUG] debug: report the correct poller list in verbose mode
-    - [BUG] capture: do not capture a cookie if there is no memory left
-    - [BUG] appsession: fix possible double free in case of out of memory
-    - [CRITICAL] cookies: mixing cookies in indirect mode and appsession can crash the process
-    - [BUG] http: correctly update the header list when removing two consecutive headers
-    - [BUILD] add the CPU=native and ARCH=32/64 build options
-    - [BUILD] add -fno-strict-aliasing to fix warnings with gcc >= 4.4
-
-2010/10/29 : 1.4.9
-    - [BUG] stats: session rate limit gets garbaged in the stats
-    - [DOC] fix http-request documentation
-    - [MEDIUM] enable/disable servers from the stats web interface
-    - [MEDIUM] stats: add an admin level
-    - [DOC] stats: document the "stats admin" statement
-    - [MINOR] checks: add support for LDAPv3 health checks
-    - [MINOR] add better support to "mysql-check"
-    - [BUG] Restore info about available active/backup servers
-    - [CONTRIB] Update haproxy.pl
-    - [CONTRIB] Update Cacti Tempates
-    - [CONTRIB] add templates for Cacti.
-    - [MEDIUM] http: forward client's close when abortonclose is set
-    - [BUG] queue: don't dequeue proxy-global requests on disabled servers
-    - [MEDIUM] servers: support address 0.0.0.0 as the original destination address
-    - [BUG] stats: global stats timeout may be specified before stats socket.
-    - [BUG] stream_sock: cleanly disable the listener in case of resource shortage
-    - [BUG] ebtree: string_equal_bits() could return garbage on identical strings
-    - [BUG] stream_sock: try to flush any extra pending request data after a POST
-    - [BUILD] proto_http: eliminate some build warnings with gcc-2.95
-    - [MEDIUM] make it possible to combine http-pretend-keepalived with httpclose
-    - [MEDIUM] tcp-request : don't wait for inspect-delay to expire when the buffer is full
-    - [DOC] bind option is "defer-accept", not "defer_accept"
-    - [MEDIUM] checks: add support for HTTP contents lookup
-    - [TESTS] add test-check-expect to test various http-check methods
-    - [MINOR] global: add "tune.chksize" to change the default check buffer size
-    - [MINOR] startup: release unused structs after forking
-    - [MINOR] startup: don't wait for nothing when no old pid remains
-    - [BUG] http: don't consider commas as a header delimitor within quotes
-    - [DOC] fix typo in the queue() definition (backend, not frontend)
-    - [DOC] fix typo in the avg_queue() and be_conn() definition (backend, not frontend)
-    - [BUG] deinit: unbind listeners before freeing them
-    - [MINOR] halog: add '-tc' to sort by termination codes
-    - [MINOR] halog: skip non-traffic logs for -st and -tc
-    - [DOC] add a summary about cookie incompatibilities between specs and browsers
-    - [DOC] fix description of cookie "insert" and "indirect" modes
-    - [MEDIUM] http: fix space handling in the request cookie parser
-    - [MEDIUM] http: fix space handling in the response cookie parser
-    - [MINOR] cookie: add options "maxidle" and "maxlife"
-    - [MEDIUM] cookie: support client cookies with some contents appended to their value
-    - [MINOR] http: make some room in the transaction flags to extend cookies
-    - [MINOR] cookie: add the expired (E) and old (O) flags for request cookies
-    - [MEDIUM] cookie: reassign set-cookie status flags to store more states
-    - [MINOR] add encode/decode function for 30-bit integers from/to base64
-    - [MEDIUM] cookie: check for maxidle and maxlife for incoming dated cookies
-    - [MEDIUM] cookie: set the date in the cookie if needed
-    - [DOC] document the cookie maxidle and maxlife parameters
-    - [BUG] checks: don't log backend down for all zero-weight servers
-    - [MEDIUM] checks: set server state to one state from failure when leaving maintenance
-    - [BUG] config: report correct keywords for "observe"
-    - [MINOR] checks: ensure that we can inherit binary checks from the defaults section
-    - [MINOR] acl: add the http_req_first match
-    - [DOC] fix typos about bind-process syntax
-    - [BUG] cookie: correctly unset default cookie parameters
-    - [MINOR] cookie: add support for the "preserve" option
-    - [DOC] missing index entry for http-check send-state
-    - [BUG] ebtree: fix duplicate strings insertion
-    - [CONTRIB] halog: report per-url counts, errors and times
-    - [CONTRIB] halog: minor speed improvement in timer parser
-    - [BUG] http: denied requests must not be counted as denied resps in listeners
-    - [BUG] config: report the correct proxy type in tcp-request errors
-    - [BUG] proto_tcp: potential bug on pattern fetch dst and dport
-
-2010/06/16 : 1.4.8
-    - [DOC] mention 'option http-server-close' effect in Tq section
-    - [DOC] summarize and highlight persistent connections behaviour
-    - [DOC] add configuration samples
-    - [BUG] stick_table: the fix for the memory leak caused a regression
-    - [BUG] client: don't add a new session to the list too early
-
-2010/06/07 : 1.4.7
-    - [BUG] http: dispatch and http_proxy modes were broken for a long time
-    - [BUG] http: the transaction must be initialized even in TCP mode
-    - [BUG] tcp: dropped connections must be counted as "denied" not "failed"
-    - [BUG] consistent hash: balance on all servers, not only 2 !
-    - [CONTRIB] halog: report per-server status codes, errors and response times
-    - [BUG] http: the transaction must be initialized even in TCP mode (part 2)
-    - [BUG] stick_table: fix possible memory leak in case of connection error
-    - [BUG] proxy: connection rate limiting was eating lots of CPU
-    - [BUG] frontend: always ensure to zero rep->analysers
-    - [BUG] http: report correct flags in case of client aborts during body
-    - [TESTS] refine non-regression tests and add 4 new tests
-    - [BUG] debug: wrong pointer was used to report a status line
-    - [BUG] debug: correctly report truncated messages
-    - [DOC] document the "dispatch" keyword
-
-2010/05/16 : 1.4.6
-    - [BUILD] ebtree: update to v6.0.1 to remove references to dprintf()
-    - [CLEANUP] acl: make use of eb_is_empty() instead of open coding the tree's emptiness test
-    - [MINOR] acl: add srv_is_up() to check that a specific server is up or not
-    - [DOC] add a few precisions about the use of RDP cookies
-
-2010/05/13 : 1.4.5
-    - [DOC] report minimum kernel version for tproxy in the Makefile
-    - [MINOR] add the "ignore-persist" option to conditionally ignore persistence
-    - [DOC] add the "ignore-persist" option to conditionally ignore persistence
-    - [DOC] fix ignore-persist/force-persist documentation
-    - [BUG] cttproxy: socket fd leakage in check_cttproxy_version
-    - [DOC] doc/configuration.txt: fix typos
-    - [MINOR] option http-pretend-keepalive is both for FEs and BEs
-    - [MINOR] fix possible crash in debug mode with invalid responses
-    - [MINOR] halog: add support for statisticts on status codes
-    - [OPTIM] halog: use a faster zero test in fgets()
-    - [OPTIM] halog: minor speedup by using unlikely()
-    - [OPTIM] halog: speed up fgets2-64 by about 10%
-    - [DOC] refresh the README file and merge the CONTRIB file into it
-    - [MINOR] acl: support loading values from files
-    - [MEDIUM] ebtree: upgrade to version 6.0
-    - [MINOR] acl trees: add flags and union members to store values in trees
-    - [MEDIUM] acl: add ability to insert patterns in trees
-    - [MEDIUM] acl: add tree-based lookups of exact strings
-    - [MEDIUM] acl: add tree-based lookups of networks
-    - [MINOR] acl: ignore empty lines and comments in pattern files
-    - [MINOR] stick-tables: add support for "stick on hdr"
-
-2010/04/07 : 1.4.4
-    - [BUG] appsession should match the whole cookie name
-    - [CLEANUP] proxy: move PR_O_SSL3_CHK to options2 to release one flag
-    - [MEDIUM] backend: move the transparent proxy address selection to backend
-    - [MINOR] add very fast IP parsing functions
-    - [MINOR] add new tproxy flags for dynamic source address binding
-    - [MEDIUM] add ability to connect to a server from an IP found in a header
-    - [BUILD] config: last patch breaks build without CONFIG_HAP_LINUX_TPROXY
-    - [MINOR] http: make it possible to pretend keep-alive when doing close
-    - [MINOR] config: report "default-server" instead of "(null)" in error messages
-
-2010/03/30 : 1.4.3
-    - [CLEANUP] stats: remove printf format warning in stats_dump_full_sess_to_buffer()
-    - [MEDIUM] session: better fix for connection to servers with closed input
-    - [DOC] indicate in the doc how to bind to port ranges
-    - [BUG] backend: L7 hashing must not be performed on incomplete requests
-    - [TESTS] add a simple program to test connection resets
-    - [MINOR] cli: "show errors" should display "backend <NONE>" when backend was not used
-    - [MINOR] config: emit warnings when HTTP-only options are used in TCP mode
-    - [MINOR] config: allow "slowstart 0s"
-    - [BUILD] 'make tags' did not consider files ending in '.c'
-    - [MINOR] checks: add the ability to disable a server in the config
-
-2010/03/17 : 1.4.2
-    - [CLEANUP] product branch update
-    - [DOC] Some more documentation cleanups
-    - [BUG] clf logs segfault when capturing a non existant header
-    - [OPTIM] config: only allocate check buffer when checks are enabled
-    - [MEDIUM] checks: support multi-packet health check responses
-    - [CLEANUP] session: remove duplicate test
-    - [BUG] http: don't wait for response data to leave buffer is client has left
-    - [MINOR] proto_uxst: set accept_date upon accept() to the wall clock time
-    - [MINOR] stats: don't send empty lines in "show errors"
-    - [MINOR] stats: make the data dump function reusable for other purposes
-    - [MINOR] stats socket: add show sess <id> to dump details about a session
-    - [BUG] stats: connection reset counters must be plain ascii, not HTML
-    - [BUG] url_param hash may return a down server
-    - [MINOR] force null-termination of hostname
-    - [MEDIUM] connect to servers even when the input has already been closed
-    - [BUG] don't merge anonymous ACLs !
-    - [BUG] config: fix endless loop when parsing "on-error"
-    - [MINOR] http: don't mark a server as failed when it returns 501/505
-    - [OPTIM] checks: try to detect the end of response without polling again
-    - [BUG] checks: don't report an error when recv() returns an error after data
-    - [BUG] checks: don't abort when second poll returns an error
-    - [MINOR] checks: make shutdown() silently fail
-    - [BUG] http: fix truncated responses on chunk encoding when size divides buffer size
-    - [BUG] init: unconditionally catch SIGPIPE
-    - [BUG] checks: don't wait for a close to start parsing the response
-
-2010/03/04 : 1.4.1
-    - [BUG] Clear-cookie path issue
-    - [DOC] fix typo on stickiness rules
-    - [BUILD] fix BSD and OSX makefiles for missing files
-    - [BUILD] includes order breaks OpenBSD build
-    - [BUILD] fix some build warnings on Solaris with is* macros
-    - [BUG] logs: don't report "last data" when we have just closed after an error
-    - [BUG] logs: don't report "proxy request" when server closes early
-    - [BUILD] fix platform-dependant build issues related to crypt()
-    - [STATS] count transfer aborts caused by client and by server
-    - [STATS] frontend requests were not accounted for failed requests
-    - [MINOR] report total number of processed connections when stopping a proxy
-    - [DOC] be more clear about the limitation to one single monitor-net entry
-
-2010/02/26 : 1.4.0
-    - [MINOR] stats: report maint state for tracking servers too
-    - [DOC] fix summary to add pattern extraction
-    - [DOC] Documentation cleanups
-    - [BUG] cfgparse memory leak and missing free calls in deinit()
-    - [BUG] pxid/puid/luid: don't shift IDs when some of them are forced
-    - [EXAMPLES] add auth.cfg
-    - [BUG] uri_auth: ST_SHLGNDS should be 0x00000008 not 0x0000008
-    - [BUG] uri_auth: do not attemp to convert uri_auth -> http-request more than once
-    - [BUILD] auth: don't use unnamed unions
-    - [BUG] config: report unresolvable host names as errors
-    - [BUILD] fix build breakage with DEBUG_FULL
-    - [DOC] fix a typo about timeout check and clarify the explanation.
-    - [MEDIUM] http: don't use trash to realign large buffers
-    - [STATS] report HTTP requests (total and rate) in frontends
-    - [STATS] separate frontend and backend HTTP stats
-    - [MEDIUM] http: revert to use a swap buffer for realignment
-    - [MINOR] stats: report the request rate in frontends as cell titles
-    - [MINOR] stats: mark areas with an underline when tooltips are available
-    - [DOC] reorder some entries to maintain the alphabetical order
-    - [DOC] cleanup of the keyword matrix
-
-2010/02/02 : 1.4-rc1
-    - [MEDIUM] add a maintenance mode to servers
-    - [MINOR] http-auth: last fix was wrong
-    - [CONTRIB] add base64rev-gen.c that was used to generate the base64rev table.
-    - [MINOR] Base64 decode
-    - [MINOR] generic auth support with groups and encrypted passwords
-    - [MINOR] add ACL_TEST_F_NULL_MATCH
-    - [MINOR] http-request: allow/deny/auth support for frontend/backend/listen
-    - [MINOR] acl: add http_auth and http_auth_group
-    - [MAJOR] use the new auth framework for http stats
-    - [DOC] add info about userlists, http-request and http_auth/http_auth_group acls
-    - [STATS] make it possible to change a CLI connection timeout
-    - [BUG] patterns: copy-paste typo in type conversion arguments
-    - [MINOR] pattern: make the converter more flexible by supporting void* and int args
-    - [MINOR] standard: str2mask: string to netmask converter
-    - [MINOR] pattern: add support for argument parsers for converters
-    - [MINOR] pattern: add the "ipmask()" converting function
-    - [MINOR] config: off-by-one in "stick-table" after list of converters
-    - [CLEANUP] acl, patterns: make use of my_strndup() instead of malloc+memcpy
-    - [BUG] restore accidentely removed line in last patch !
-    - [MINOR] checks: make the HTTP check code add the CRLF itself
-    - [MINOR] checks: add the server's status in the checks
-    - [BUILD] halog: make without arch-specific optimizations
-    - [BUG] halog: fix segfault in case of empty log in PCT mode (cherry picked from commit fe362fe4762151d209b9656639ee1651bc2b329d)
-    - [MINOR] http: disable keep-alive when process is going down
-    - [MINOR] acl: add build_acl_cond() to make it easier to add ACLs in config
-    - [CLEANUP] config: use build_acl_cond() instead of parse_acl_cond()
-    - [CLEANUP] config: use warnif_cond_requires_resp() to check for bad ACLs
-    - [MINOR] prepare req_*/rsp_* to receive a condition
-    - [CLEANUP] config: specify correct const char types to warnif_* functions
-    - [MEDIUM] config: factor out the parsing of 20 req*/rsp* keywords
-    - [MEDIUM] http: make the request filter loop check for optional conditions
-    - [MEDIUM] http: add support for conditional request filter execution
-    - [DOC] add some build info about the AIX platform (cherry picked from commit e41914c77edbc40aebf827b37542d37d758e371e)
-    - [MEDIUM] http: add support for conditional request header addition
-    - [MEDIUM] http: add support for conditional response header rewriting
-    - [DOC] add some missing ACLs about response header matching
-    - [MEDIUM] http: add support for proxy authentication
-    - [MINOR] http-auth: make the 'unless' keyword work as expected
-    - [CLEANUP] config: use build_acl_cond() to simplify http-request ACL parsing
-    - [MEDIUM] add support for anonymous ACLs
-    - [MEDIUM] http: switch to tunnel mode after status 101 responses
-    - [MEDIUM] http: stricter processing of the CONNECT method
-    - [BUG] config: reset check request to avoid double free when switching to ssl/sql
-    - [MINOR] config: fix too large ssl-hello-check message.
-    - [BUG] fix error response in case of server error
-
-2010/01/25 : 1.4-dev8
-    - [CLEANUP] Keep in sync "defaults" support between documentation and code
-    - [MEDIUM] http: add support for Proxy-Connection header
-    - [CRITICAL] buffers: buffer_insert_line2 must not change the ->w entry
-    - [MINOR] http: remove a copy-paste typo in transaction cleaning
-    - [BUG] http: trim any excess buffer data when recycling a connection
-
-2010/01/25 : 1.4-dev7
-    - [BUG] appsession: possible memory leak in case of out of memory condition
-    - [MINOR] config: don't accept 'appsession' in defaults section
-    - [MINOR] Add function to parse a size in configuration
-    - [MEDIUM] Add stick table (persistence) management functions and types
-    - [MEDIUM] Add pattern fetch management types and functions
-    - [MEDIUM] Add src dst and dport pattern fetches.
-    - [MEDIUM] Add stick table configuration and init.
-    - [MEDIUM] Add stick and store rules analysers.
-    - [MINOR] add option "mysql-check" to use MySQL health checks
-    - [BUG] health checks: fix requeued message
-    - [OPTIM] remove SSP_O_VIA and SSP_O_STATUS
-    - [BUG] checks: fix newline termination
-    - [MINOR] acl: add fe_id/so_id to match frontend's and socket's id
-    - [BUG] appsession's sessid must be reset at end of transaction
-    - [BUILD] appsession did not build anymore under gcc-2.95
-    - [BUG] server redirection used an uninitialized string.
-    - [MEDIUM] http: fix handling of message pointers
-    - [MINOR] http: fix double slash prefix with server redirect
-    - [MINOR] http redirect: add the ability to append a '/' to the URL
-    - [BUG] stream_interface: fix retnclose and remove cond_close
-    - [MINOR] http redirect: don't explicitly state keep-alive on 1.1
-    - [MINOR] http: move appsession 'sessid' from session to http_txn
-    - [OPTIM] reorder http_txn to optimize cache lines placement
-    - [MINOR] http: differentiate waiting for new request and waiting for a complete requst
-    - [MINOR] http: add a separate "http-keep-alive" timeout
-    - [MINOR] config: remove undocumented and buggy 'timeout appsession'
-    - [DOC] fix various too large lines
-    - [DOC] remove several trailing spaces
-    - [DOC] add the doc about stickiness
-    - [BUILD] remove a warning in standard.h on AIX
-    - [BUG] checks: chars are unsigned on AIX, check was always true
-    - [CLEANUP] stream_sock: MSG_NOSIGNAL is only for send(), not recv()
-    - [BUG] check: we must not check for error before reading a response
-    - [BUG] buffers: remove remains of wrong obsolete length check
-    - [OPTIM] stream_sock: don't shutdown(write) when the socket is in error
-    - [BUG] http: don't count req errors on client resets or t/o during keep-alive
-    - [MEDIUM] http: don't switch to tunnel mode upon close
-    - [DOC] add documentation about connection header processing
-    - [MINOR] http: add http_remove_header2() to remove a header value.
-    - [MINOR] tools: add a "word_match()" function to match words and ignore spaces
-    - [MAJOR] http: rework request Connection header handling
-    - [MAJOR] http: rework response Connection header handling
-    - [MINOR] add the ability to force kernel socket buffer size.
-    - [BUG] http_server_error() must not purge a previous pending response
-    - [OPTIM] http: don't delay response if next request is incomplete
-    - [MINOR] add the "force-persist" statement to force persistence on down servers
-    - [MINOR] http: logs must report persistent connections to down servers
-    - [BUG] buffer_replace2 must never change the ->w entry
-
-2010/01/08 : 1.4-dev6
-    - [BUILD] warning in stream_interface.h
-    - [BUILD] warning ultoa_r returns char *
-    - [MINOR] hana: only report stats if it is enabled
-    - [MINOR] stats: add "a link" & "a href" for sockets
-    - [MINOR]: stats: add show-legends to report additional informations
-    - [MEDIUM] default-server support
-    - [BUG]: add 'observer', 'on-error', 'error-limit' to supported options list
-    - [MINOR] stats: add href to tracked server
-    - [BUG] stats: show UP/DOWN status also in tracking servers
-    - [DOC] Restore ability to search a keyword at the beginning of a line
-    - [BUG] stats: cookie should be reported under backend not under proxy
-    - [BUG] cfgparser/stats: fix error message
-    - [BUG] http: disable auto-closing during chunk analysis
-    - [BUG] http: fix hopefully last closing issue on data forwarding
-    - [DEBUG] add an http_silent_debug function to debug HTTP states
-    - [MAJOR] http: fix again the forward analysers
-    - [BUG] http_process_res_common() must not skip the forward analyser
-    - [BUG] http: some possible missed close remain in the forward chain
-    - [BUG] http: redirect needed to be updated after recent changes
-    - [BUG] http: don't set no-linger on response in case of forced close
-    - [MEDIUM] http: restore the original behaviour of option httpclose
-    - [TESTS] add a file to test various connection modes
-    - [BUG] http: check options before the connection header
-    - [MAJOR] session: fix the order by which the analysers are run
-    - [MEDIUM] session: also consider request analysers added during response
-    - [MEDIUM] http: make safer use of the DONT_READ and AUTO_CLOSE flags
-    - [BUG] http: memory leak with captures when using keep-alive
-    - [BUG] http: fix for capture memory leak was incorrect
-    - [MINOR] http redirect: use proper call to return last response
-    - [MEDIUM] http: wait for some flush of the response buffer before a new request
-    - [MEDIUM] session: limit the number of analyser loops
-
-2010/01/03 : 1.4-dev5
-    - [MINOR] server tracking: don't care about the tracked server's mode
-    - [MEDIUM] appsession: add "len", "prefix" and "mode" options
-    - [MEDIUM] appsession: add the "request-learn" option
-    - [BUG] Configuration parser bug when escaping characters
-    - [MINOR] CSS & HTML fun
-    - [MINOR] Collect & provide http response codes received from servers
-    - [BUG] Fix silly typo: hspr_other -> hrsp_other
-    - [MINOR] Add "a name" to stats page
-    - [MINOR] add additional "a href"s to stats page
-    - [MINOR] Collect & provide http response codes for frontends, fix backends
-    - [DOC] some small spell fixes and unifications
-    - [MEDIUM] Decrease server health based on http responses / events, version 3
-    - [BUG] format '%d' expects type 'int', but argument 5 has type 'long int'
-    - [BUG] config: fix erroneous check on cookie domain names, again
-    - [BUG] Healthchecks: get a proper error code if connection cannot be completed immediately
-    - [DOC] trivial fix for man page
-    - [MINOR] config: report all supported options for the "bind" keyword
-    - [MINOR] tcp: add support for the defer_accept bind option
-    - [MINOR] unix socket: report the socket path in case of bind error
-    - [CONTRIB] halog: support searching by response time
-    - [DOC] add a reminder about obsolete documents
-    - [DOC] point to 1.4 doc, not 1.3
-    - [DOC] option tcp-smart-connect was missing from index
-    - [MINOR] http: detect connection: close earlier
-    - [CLEANUP] sepoll: clean up the fd_clr/fd_set functions
-    - [OPTIM] move some rarely used fields out of fdtab
-    - [MEDIUM] fd: merge fd_list into fdtab
-    - [MAJOR] buffer: flag BF_DONT_READ to disable reads when not required
-    - [MINOR] http: add new transaction flags for keep-alive and content-length
-    - [MEDIUM] http request: parse connection, content-length and transfer-encoding
-    - [MINOR] http request: update the TX_SRV_CONN_KA flag on rewrite
-    - [MINOR] http request: simplify the test of no-data
-    - [MEDIUM] http request: simplify POST length detection
-    - [MEDIUM] http request: make use of pre-parsed transfer-encoding header
-    - [MAJOR] http: create the analyser which waits for a response
-    - [MINOR] http: pre-set the persistent flags in the transaction
-    - [MEDIUM] http response: check body length and set transaction flags
-    - [MINOR] http response: update the TX_CLI_CONN_KA flag on rewrite
-    - [MINOR] http: remove the last call to stream_int_return
-    - [IMPORT] import ebtree v5.0 into directory ebtree/
-    - [MEDIUM] build: switch ebtree users to use new ebtree version
-    - [CLEANUP] ebtree: remove old unused files
-    - [BUG] definitely fix regparm issues between haproxy core and ebtree
-    - [CLEANUP] ebtree: cast to char * to get rid of gcc warning
-    - [BUILD] missing #ifndef in ebmbtree.h
-    - [BUILD] missing #ifndef in ebsttree.h
-    - [MINOR] tools: add hex2i() function to convert hex char to int
-    - [MINOR] http: create new MSG_BODY sub-states
-    - [BUG] stream_sock: BUF_INFINITE_FORWARD broke splice on 64-bit platforms
-    - [DOC] option is "defer-accept", not "defer_accept"
-    - [MINOR] http: keep pointer to beginning of data
-    - [BUG] x-original-to: name was not set in default instance
-    - [MINOR] http: detect tunnel mode and set it in the session
-    - [BUG] config: fix error message when config file is not found
-    - [BUG] config: fix wrong handling of too large argument count
-    - [BUG] config: disable 'option httplog' on TCP proxies
-    - [BUG] config: fix erroneous check on cookie domain names
-    - [BUG] config: cookie domain was ignored in defaults sections
-    - [MINOR] config: support passing multiple "domain" statements to cookies
-    - [MINOR] ebtree: add functions to lookup non-null terminated strings
-    - [MINOR] config: don't report error on all subsequent files on failure
-    - [BUG] second fix for the printf format warning
-    - [BUG] check_post: limit analysis to the buffer length
-    - [MEDIUM] http: process request body in a specific analyser
-    - [MEDIUM] backend: remove HTTP POST parsing from get_server_ph_post()
-    - [MAJOR] http: completely process the "connection" header
-    - [MINOR] http: only consider chunk encoding with HTTP/1.1
-    - [MAJOR] buffers: automatically compute the maximum buffer length
-    - [MINOR] http: move the http transaction init/cleanup code to proto_http
-    - [MINOR] http: move 1xx handling earlier to eliminate a lot of ifs
-    - [MINOR] http: introduce a new synchronisation state : HTTP_MSG_DONE
-    - [MEDIUM] http: rework chunk-size parser
-    - [MEDIUM] http: add a new transaction flags indicating if we know the transfer length
-    - [MINOR] buffers: add buffer_ignore() to skip some bytes
-    - [BUG] http: offsets are relative to the buffer, not to ->som
-    - [MEDIUM] http: automatically re-aling request buffer
-    - [BUG] http: body parsing must consider the start of message
-    - [MINOR] new function stream_int_cond_close()
-    - [MAJOR] http: implement body parser
-    - [BUG] http: typos on several unlikely() around header insertion
-    - [BUG] stream_sock: wrong max computation on recv
-    - [MEDIUM] http: rework the buffer alignment logic
-    - [BUG] buffers: wrong size calculation for displaced data
-    - [MINOR] stream_sock: prepare for closing when all pending data are sent
-    - [MEDIUM] http: add two more states for the closing period
-    - [MEDIUM] http: properly handle "option forceclose"
-    - [MINOR] stream_sock: add SI_FL_NOLINGER for faster close
-    - [MEDIUM] http: make forceclose use SI_FL_NOLINGER
-    - [MEDIUM] session: set SI_FL_NOLINGER when aborting on write timeouts
-    - [MEDIUM] http: add some SI_FL_NOLINGER around server errors
-    - [MINOR] config: option forceclose is valid in frontends too
-    - [BUILD] halog: insufficient include path in makefile
-    - [MEDIUM] http: make the analyser not rely on msg being initialized anymore
-    - [MEDIUM] http: make the parsers able to wait for a buffer flush
-    - [MAJOR] http: add support for option http-server-close
-    - [BUG] http: ensure we abort data transfer on write error
-    - [BUG] last fix was overzealous and disabled server-close
-    - [BUG] http: fix erroneous trailers size computation
-    - [MINOR] stream_sock: enable MSG_MORE when forwarding finite amount of data
-    - [OPTIM] http: set MSG_MORE on response when a pipelined request is pending
-    - [BUG] http: redirects were broken by chunk changes
-    - [BUG] http: the request URI pointer is relative to the buffer
-    - [OPTIM] http: don't immediately enable reading on request
-    - [MINOR] http: move redirect messages to HTTP/1.1 with a content-length
-    - [BUG] http: take care of errors, timeouts and aborts during the data phase
-    - [MINOR] http: don't wait for sending requests to the server
-    - [MINOR] http: make the conditional redirect support keep-alive
-    - [BUG] http: fix cookie parser to support spaces and commas in values
-    - [MINOR] config: some options were missing for "redirect"
-    - [MINOR] redirect: add support for unconditional rules
-    - [MINOR] config: centralize proxy struct initialization
-    - [MEDIUM] config: remove the limitation of 10 reqadd/rspadd statements
-    - [MEDIUM] config: remove the limitation of 10 config files
-    - [CLEANUP] http: remove a remaining impossible condition
-    - [OPTIM] http: optimize a bit the construct of the forward loops
-
-2009/10/12 : 1.4-dev4
-    - [DOC] add missing rate_lim and rate_max
-    - [MAJOR] struct chunk rework
-    - [MEDIUM] Health check reporting code rework + health logging, v3
-    - [BUG] check if rise/fall has an argument and it is > 0
-    - [MINOR] health checks logging unification
-    - [MINOR] add "description", "node" and show-node"/"show-desc", remove "node-name", v2
-    - [MINOR] Allow dots in show-node & add "white-space: nowrap" in th.pxname.
-    - [DOC] Add information about http://haproxy.1wt.eu/contrib.html
-    - [MINOR] Introduce include/types/counters.h
-    - [CLEANUP] Move counters to dedicated structures
-    - [MINOR] Add "clear counters" to clear statistics counters
-    - [MEDIUM] Collect & provide separate statistics for sockets, v2
-    - [BUG] Fix NULL pointer dereference in stats_check_uri_auth(), v2
-    - [MINOR] acl: don't report valid acls as potential mistakes
-    - [MINOR] Add cut_crlf(), ltrim(), rtrim() and alltrim()
-    - [MINOR] Add chunk_htmlencode and chunk_asciiencode
-    - [MINOR] Capture & display more data from health checks, v2
-    - [BUG] task.c: don't assing last_timer to node-less entries
-    - [BUG] http stats: large outputs sometimes got some parts chopped off
-    - [MINOR] backend: export some functions to recount servers
-    - [MINOR] backend: uninline some LB functions
-    - [MINOR] include time.h from freq_ctr.h as is uses "now".
-    - [CLEANUP] backend: move LB algos to individual files
-    - [MINOR] lb_map: reorder code in order to ease integration of new hash functions
-    - [CLEANUP] proxy: move last lb-specific bits to their respective files
-    - [MINOR] backend: separate declarations of LB algos from their lookup method
-    - [MINOR] backend: reorganize the LB algorithm selection
-    - [MEDIUM] backend: introduce the "static-rr" LB algorithm
-    - [MINOR] report list of supported pollers with -vv
-    - [DOC] log-health-checks is an option, not a directive
-    - [MEDIUM] new option "independant-streams" to stop updating read timeout on writes
-    - [BUG] stats: don't call buffer_shutw(), but ->shutw() instead
-    - [MINOR] stats: strip CR and LF from the input command line
-    - [BUG] don't refresh timeouts late after detected activity
-    - [MINOR] stats_dump_errors_to_buffer: use buffer_feed_chunk()
-    - [MINOR] stats_dump_sess_to_buffer: use buffer_feed_chunk()
-    - [MINOR] stats: make stats_dump_raw_to_buffer() use buffer_feed_chunk
-    - [MEDIUM] stats: don't use s->ana_state anymore
-    - [MINOR] remove now obsolete ana_state from the session struct
-    - [MEDIUM] stats: make HTTP stats use an I/O handler
-    - [MEDIUM] stream_int: adjust WAIT_ROOM handling
-    - [BUG] config: look for ID conflicts in all sockets, not only last ones.
-    - [MINOR] config: reference file and line with any listener/proxy/server declaration
-    - [MINOR] config: report places of duplicate names or IDs
-    - [MINOR] config: add pointer to file name in block/redirect/use_backend/monitor rules
-    - [MINOR] tools: add a new get_next_id() function
-    - [MEDIUM] config: automatically find unused IDs for proxies, servers and listeners
-    - [OPTIM] counters: move some max numbers to the counters struct
-    - [BUG] counters: fix segfault on missing counters for a listener
-    - [MEDIUM] backend: implement consistent hashing variation
-    - [MINOR] acl: add fe_conn, be_conn, queue, avg_queue
-    - [MINOR] stats: use 'clear counters all' to clear all values
-    - [MEDIUM] add access restrictions to the stats socket
-    - [MINOR] buffers: add buffer_feed2() and make buffer_feed() measure string length
-    - [MINOR] proxy: provide function to retrieve backend/server pointers
-    - [MINOR] add the "initial weight" to the server struct.
-    - [MEDIUM] stats: add the "get weight" command to report a server's weight
-    - [MEDIUM] stats: add the "set weight" command
-    - [BUILD] add a 'make tags' target
-    - [MINOR] stats: add support for numeric IDs in set weight/get weight
-    - [MINOR] stats: use a dedicated state to output static data
-    - [OPTIM] stats: check free space before trying to print
-
-2009/09/24 : 1.4-dev3
-    - [BUILD] compilation of haproxy-1.4-dev2 on FreeBSD
-    - [MEDIUM] Collect & show information about last health check, v3
-    - [MINOR] export the hostname variable so that all the code can access it
-    - [MINOR] stats: add a new node-name setting
-    - [MEDIUM] remove old experimental tcpsplice option
-    - [BUILD] fix build for systems without SOL_TCP
-    - [MEDIUM] move connection establishment from backend to the SI.
-    - [MEDIUM] make the global stats socket part of a frontend
-    - [MEDIUM] session: account per-listener connections
-    - [MINOR] session: switch to established state if no connect function
-    - [MEDIUM] make the unix stats sockets use the generic session handler
-    - [CLEANUP] unix: remove uxst_process_session()
-    - [CLEANUP] move remaining stats sockets code to dumpstats
-    - [MINOR] move the initial task's nice value to the listener
-    - [MINOR] cleanup set_session_backend by using pre-computed analysers
-    - [MINOR] set s->srv_error according to the analysers
-    - [MEDIUM] set rep->analysers from fe and be analysers
-    - [MEDIUM] replace BUFSIZE with buf->size in computations
-    - [MEDIUM] make it possible to change the buffer size in the configuration
-    - [MEDIUM] report error on buffer writes larger than buffer size
-    - [MEDIUM] stream_interface: add and use ->update function to resync
-    - [CLEANUP] remove ifdef MSG_NOSIGNAL and define it instead
-    - [MEDIUM] remove TCP_CORK and make use of MSG_MORE instead
-    - [BUG] tarpit did not work anymore
-    - [MINOR] acl: add support for hdr_ip to match IP addresses in headers
-    - [MAJOR] buffers: fix misuse of the BF_SHUTW_NOW flag
-    - [MINOR] buffers: provide more functions to handle buffer data
-    - [MEDIUM] buffers: provide new buffer_feed*() function
-    - [MINOR] buffers: add peekchar and peekline functions for stream interfaces
-    - [MINOR] buffers: provide buffer_si_putchar() to send a char from a stream interface
-    - [BUG] buffer_forward() would not correctly consider data already scheduled
-    - [MINOR] buffers: add buffer_cut_tail() to cut only unsent data
-    - [MEDIUM] stream_interface: make use of buffer_cut_tail() to report errors
-    - [MAJOR] http: add support for HTTP 1xx informational responses
-    - [MINOR] buffers: inline buffer_si_putchar()
-    - [MAJOR] buffers: split BF_WRITE_ENA into BF_AUTO_CONNECT and BF_AUTO_CLOSE
-    - [MAJOR] buffers: fix the BF_EMPTY flag's meaning
-    - [BUG] stream_interface: SI_ST_CLO must have buffers SHUT
-    - [MINOR] stream_sock: don't set SI_FL_WAIT_DATA if BF_SHUTW_NOW is set
-    - [MEDIUM] add support for infinite forwarding
-    - [BUILD] stream_interface: fix conflicting declaration
-    - [BUG] buffers: buffer_forward() must not always clear BF_OUT_EMPTY
-    - [BUG] variable buffer size ignored at initialization time
-    - [MINOR] ensure that buffer_feed() and buffer_skip() set BF_*_PARTIAL
-    - [BUG] fix buffer_skip() and buffer_si_getline() to correctly handle wrap-arounds
-    - [MINOR] stream_interface: add SI_FL_DONT_WAKE flag
-    - [MINOR] stream_interface: add iohandler callback
-    - [MINOR] stream_interface: add functions to support running as internal/external tasks
-    - [MEDIUM] session: call iohandler for embedded tasks (applets)
-    - [MINOR] add a ->private member to the stream_interface
-    - [MEDIUM] stats: prepare the connection for closing before dumping
-    - [MEDIUM] stats: replace the stats socket analyser with an SI applet
-
-2009/08/09 : 1.4-dev2
-    - [BUG] task: fix possible crash when some timeouts are not configured
-    - [BUG] log: option tcplog would log to global if no logger was defined
-
-2009/07/29 : 1.4-dev1
-    - [MINOR] acl: add support for matching of RDP cookies
-    - [MEDIUM] add support for RDP cookie load-balancing
-    - [MEDIUM] add support for RDP cookie persistence
-    - [MINOR] add a new CLF log format
-    - [MINOR] startup: don't imply -q with -D
-    - [BUG] ensure that we correctly re-start old process in case of error
-    - [MEDIUM] add support for binding to source port ranges during connect
-    - [MINOR] config: track "no option"/"option" changes
-    - [MINOR] config: support resetting options do default values
-    - [MEDIUM] implement option tcp-smart-accept at the frontend
-    - [MEDIUM] stream_sock: implement tcp-cork for use during shutdowns on Linux
-    - [MEDIUM] implement tcp-smart-connect option at the backend
-    - [MEDIUM] add support for TCP MSS adjustment for listeners
-    - [MEDIUM] support setting a server weight to zero
-    - [MINOR] make DEFAULT_MAXCONN user-configurable at build time
-    - [MAJOR] session: don't clear buffer status flags anymore
-    - [MAJOR] session: only check for timeouts when they have just occurred.
-    - [MAJOR] session: simplify buffer error handling
-    - [MEDIUM] config: split parser and checker in two functions
-    - [MEDIUM] config: support loading multiple configuration files
-    - [MEDIUM] stream_sock: don't close prematurely when nolinger is set
-    - [MEDIUM] session: rework buffer analysis to permit permanent analysers
-    - [MEDIUM] splice: set the capability on each stream_interface
-    - [BUG] http: redirect rules were processed too early
-    - [CLEANUP] remove unused DEBUG_PARSE_NO_SPEEDUP define
-    - [MEDIUM] http: split request waiter from request processor
-    - [MEDIUM] session: tell analysers what bit they were called for
-    - [MAJOR] http: complete splitting of the remaining stages
-    - [MINOR] report in the proxies the requirements for ACLs
-    - [MINOR] http: rely on proxy->acl_requires to allocate hdr_idx
-    - [MINOR] acl: add HTTP protocol detection (req_proto_http)
-    - [MINOR] prepare callers of session_set_backend to handle errors
-    - [BUG] default ACLs did not properly set the ->requires flag
-    - [MEDIUM] allow a TCP frontend to switch to an HTTP backend
-    - [MINOR] ensure we can jump from swiching rules to http without data
-    - [MINOR] http: take http request timeout from the backend
-    - [MINOR] allow TCP inspection rules to make use of HTTP ACLs
-    - [BUILD] report commit date and not author's date as build date
-    - [MINOR] acl: don't complain anymore when using L7 acls in TCP
-    - [BUG] stream_sock: always shutdown(SHUT_WR) before closing
-    - [BUG] stream_sock: don't stop reading when the poller reports an error
-    - [BUG] config: tcp-request content only accepts "if" or "unless"
-    - [BUG] task: fix possible timer drift after update
-    - [MINOR] apply tcp-smart-connect option for the checks too
-    - [MINOR] stats: better displaying in MSIE
-    - [MINOR] config: improve error reporting in global section
-    - [MINOR] config: improve error reporting in listen sections
-    - [MINOR] config: the "capture" keyword is not allowed in backends
-    - [MINOR] config: improve error reporting when checking configuration
-    - [BUILD] fix a minor build warning on AIX
-    - [BUILD] use "git cmd" instead of "git-cmd"
-    - [CLEANUP] report 2009 not 2008 in the copyright banner.
-    - [MINOR] print usage on the stats sockets upon invalid commands
-    - [MINOR] acl: detect and report potential mistakes in ACLs
-    - [BUILD] fix incorrect printf arg count with tcp_splice
-    - [BUG] fix random pauses on last segment of a series
-    - [BUILD] add support for build under Cygwin
-
-2009/06/09 : 1.4-dev0
-    - exact copy of 1.3.18
-
-2009/05/10 : 1.3.18
-    - [MEDIUM] add support for "balance hdr(name)"
-    - [CLEANUP] give a little bit more information in error message
-    - [MINOR] add X-Original-To: header
-    - [BUG] x-original-to: fix missing initialization to default value
-    - [BUILD] spec file: fix broken pipe during rpmbuild and add man file
-    - [MINOR] improve reporting of misplaced acl/reqxxx rules
-    - [MEDIUM] http: add options to ignore invalid header names
-    - [MEDIUM] http: capture invalid requests/responses even if accepted
-    - [BUILD] add format(printf) to printf-like functions
-    - [MINOR] fix several printf formats and missing arguments
-    - [BUG] stats: total and lbtot are unsigned
-    - [MINOR] fix a few remaining printf-like formats on 64-bit platforms
-    - [CLEANUP] remove unused make option from haproxy.spec
-    - [BUILD] make it possible to pass alternative arch at build time
-    - [MINOR] switch all stat counters to 64-bit
-    - [MEDIUM] ensure we don't recursively call pool_gc2()
-    - [CRITICAL] uninitialized response field can sometimes cause crashes
-    - [BUG] fix wrong pointer arithmetics in HTTP message captures
-    - [MINOR] rhel init script : support the reload operation
-    - [MINOR] add basic signal handling functions
-    - [BUILD] add signal.o to all makefiles
-    - [MEDIUM] call signal_process_queue from run_poll_loop
-    - [MEDIUM] pollers: don't wait if a signal is pending
-    - [MEDIUM] convert all signals to asynchronous signals
-    - [BUG] O(1) pollers should check their FD before closing it
-    - [MINOR] don't close stdio fds twice
-    - [MINOR] add options dontlog-normal and log-separate-errors
-    - [DOC] minor fixes and rearrangements
-    - [BUG] fix parser crash on unconditional tcp content rules
-    - [DOC] rearrange the configuration manual and add a summary
-    - [MINOR] standard: provide a new 'my_strndup' function
-    - [MINOR] implement per-logger log level limitation
-    - [MINOR] compute the max of sessions/s on fe/be/srv
-    - [MINOR] stats: report max sessions/s and limit in CSV export
-    - [MINOR] stats: report max sessions/s and limit in HTML stats
-    - [MINOR] stats/html: use the arial font before helvetica
-
-2009/03/29 : 1.3.17
-    - Update specfile to build for v2.6 kernel.
-    - [BUG] reset the stream_interface connect timeout upon connect or error
-    - [BUG] reject unix accepts when connection limit is reached
-    - [MINOR] show sess: report number of calls to each task
-    - [BUG] don't call epoll_ctl() on closed sockets
-    - [BUG] stream_sock: disable I/O on fds reporting an error
-    - [MINOR] sepoll: don't count two events on the same FD.
-    - [MINOR] show sess: report a lot more information about sessions
-    - [BUG] stream_sock: check for shut{r,w} before refreshing some timeouts
-    - [BUG] don't set an expiration date directly from now_ms
-    - [MINOR] implement ulltoh() to write HTML-formatted numbers
-    - [MINOR] stats/html: group digits by 3 to clarify numbers
-    - [BUILD] remove haproxy-small.spec
-    - [BUILD] makefile: remove unused references to linux24eold and EPOLL_CTL_WORKAROUND
-
-2009/03/22 : 1.3.16
-    - [BUILD] Fixed Makefile for linking pcre
-    - [CONTRIB] selinux policy for haproxy
-    - [MINOR] show errors: encode backslash as well as non-ascii characters
-    - [MINOR] cfgparse: some cleanups in the consistency checks
-    - [MINOR] cfgparse: set backends to "balance roundrobin" by default
-    - [MINOR] tcp-inspect: permit the use of no-delay inspection
-    - [MEDIUM] reverse internal proxy declaration order to match configuration
-    - [CLEANUP] config: catch and report some possibly wrong rule ordering
-    - [BUG] connect timeout is in the stream interface, not the buffer
-    - [BUG] session: errors were not reported in termination flags in TCP mode
-    - [MINOR] tcp_request: let the caller take care of errors and timeouts
-    - [CLEANUP] http: remove some commented out obsolete code in process_response
-    - [MINOR] update ebtree to version 4.1
-    - [MEDIUM] scheduler: get rid of the 4 trees thanks and use ebtree v4.1
-    - [BUG] sched: don't leave 3 lasts tasks unprocessed when niced tasks are present
-    - [BUG] scheduler: fix improper handling of duplicates __task_queue()
-    - [MINOR] sched: permit a task to stay up between calls
-    - [MINOR] task: keep a task count and clean up task creators
-    - [MINOR] stats: report number of tasks (active and running)
-    - [BUG] server check intervals must not be null
-    - [OPTIM] stream_sock: don't retry to read after a large read
-    - [OPTIM] buffer: new BF_READ_DONTWAIT flag reduces EAGAIN rates
-    - [MEDIUM] session: don't resync FSMs on non-interesting changes
-    - [BUG] check for global.maxconn before doing accept()
-    - [OPTIM] sepoll: do not re-check whole list upon accepts
-
-2009/03/09 : 1.3.16-rc2
-    - [BUG] stream_sock: write timeout must be updated when forwarding !
-
-2009/03/09 : 1.3.16-rc1
-    - appsessions: cleanup DEBUG_HASH and initialize request_counter
-    - [MINOR] acl: add new keyword "connslots"
-    - [MINOR] cfgparse: fix off-by 2 in error message size
-    - [BUILD] fix build with gcc 4.3
-    - [BUILD] fix MANDIR default location to match documentation
-    - [TESTS] add a debug patch to help trigger the stats bug
-    - [BUG] Flush buffers also where there are exactly 0 bytes left
-    - [MINOR] Allow to specify a domain for a cookie
-    - [BUG/CLEANUP] cookiedomain -> cookie_domain rename + free(p->cookie_domain)
-    - [MEDIUM] Fix memory freeing at exit
-    - [MEDIUM] Fix memory freeing at exit, part 2
-    - [BUG] Fix listen & more of 2 couples <ip>:<port>
-    - [DOC] remove buggy comment for use_backend
-    - [CRITICAL] fix server state tracking: it was O(n!) instead of O(n)
-    - [MEDIUM] add support for URI hash depth and length limits
-    - [MINOR] permit renaming of x-forwarded-for header
-    - [BUILD] fix Makefile.bsd and Makefile.osx for stream_interface
-    - [BUILD] Haproxy won't compile if DEBUG_FULL is defined
-    - [MEDIUM] upgrade to ebtree v4.0
-    - [DOC] update the README file with new build options
-    - [MEDIUM] reduce risk of event starvation in ev_sepoll
-    - [MEDIUM] detect streaming buffers and tag them as such
-    - [MEDIUM] add support for conditional HTTP redirection
-    - [BUILD] make install should depend on haproxy not "all"
-    - [DEBUG] add a TRACE macro to facilitate runtime data extraction
-    - [BUG] event pollers must not wait if a task exists in the run queue
-    - [BUG] queue management: wake oldest request in queues
-    - [BUG] log: reported queue position was offed-by-one
-    - [BUG] fix the dequeuing logic to ensure that all requests get served
-    - [DOC] documentation for the "retries" parameter was missing.
-    - [MEDIUM] implement a monotonic internal clock
-    - [MEDIUM] further improve monotonic clock by check forward jumps
-    - [OPTIM] add branch prediction hints in list manipulations
-    - [MAJOR] replace ultree with ebtree in wait-queues
-    - [BUG] we could segfault during exit while freeing uri_auths
-    - [BUG] wqueue: perform proper timeout comparisons with wrapping values
-    - [MINOR] introduce now_ms, the current date in milliseconds
-    - [BUG] disable buffer read timeout when reading stats
-    - [MEDIUM] rework the wait queue mechanism
-    - [BUILD] change declaration of base64tab to fix build with Intel C++
-    - [OPTIM] shrink wake_expired_tasks() by using task_wakeup()
-    - [MAJOR] use an ebtree instead of a list for the run queue
-    - [MEDIUM] introduce task->nice and boot access to statistics
-    - [OPTIM] task_queue: assume most consecutive timers are equal
-    - [BUILD] silent a warning in unlikely() with gcc 4.x
-    - [MAJOR] convert all expiration timers from timeval to ticks
-    - [BUG] use_backend would not correctly consider "unless"
-    - [TESTS] added test-acl.cfg to test some ACL combinations
-    - [MEDIUM] add support for configuration keyword registration
-    - [MEDIUM] modularize the global "stats" keyword configuration parser
-    - [MINOR] cfgparse: add support for warnings in external functions
-    - [MEDIUM] modularize the "timeout" keyword configuration parser
-    - [MAJOR] implement tcp request content inspection
-    - [MINOR] acl: add a new parsing function: parse_dotted_ver
-    - [MINOR] acl: add req_ssl_ver in TCP, to match an SSL version
-    - [CLEANUP] remove unused include/types/client.h
-    - [CLEANUP] remove many #include <types/xxx> from C files
-    - [CLEANUP] remove dependency on obsolete INTBITS macro
-    - [DOC] document the new "tcp-request" keyword and associated ACLs
-    - [MINOR] acl: add REQ_CONTENT to the list of default acls
-    - [MEDIUM] acl: permit fetch() functions to set the result themselves
-    - [MEDIUM] acl: get rid of dummy values in always_true/always_false
-    - [MINOR] acl: add the "wait_end" acl verb
-    - [MEDIUM] acl: enforce ACL type checking
-    - [MEDIUM] acl: set types on all currently known ACL verbs
-    - [MEDIUM] acl: when possible, report the name and requirements of ACLs in warnings
-    - [CLEANUP] remove 65 useless NULL checks before free
-    - [MEDIUM] memory: update pool_free2() to support NULL pointers
-    - [MEDIUM] buffers: ensure buffer_shut* are properly called upon shutdowns
-    - [MEDIUM] process_srv: rely on buffer flags for client shutdown
-    - [MEDIUM] process_srv: don't rely at all on client state
-    - [MEDIUM] process_cli: don't rely at all on server state
-    - [BUG] fix segfault with url_param + check_post
-    - [BUG] server timeout was not considered in some circumstances
-    - [BUG] client timeout incorrectly rearmed while waiting for server
-    - [MAJOR] kill CL_STINSPECT and CL_STHEADERS (step 1)
-    - [MAJOR] get rid of SV_STANALYZE (step 2)
-    - [MEDIUM] simplify and centralize request timeout cancellation and request forwarding
-    - [MAJOR] completely separate HTTP and TCP states on the request path
-    - [BUG] fix recently introduced loop when client closes early
-    - [MAJOR] get rid of the SV_STHEADERS state
-    - [MAJOR] better separation of response processing and server state
-    - [MAJOR] clearly separate HTTP response processing from TCP server state
-    - [MEDIUM] remove unused references to {CL|SV}_STSHUT*
-    - [MINOR] term_trace: add better instrumentations to trace the code
-    - [BUG] ev_sepoll: closed file descriptors could persist in the spec list
-    - [BUG] process_response must not enable the read FD
-    - [BUG] buffers: remove BF_MAY_CONNECT and fix forwarding issue
-    - [BUG] process_response: do not touch srv_state
-    - [BUG] maintain_proxies must not disable backends
-    - [CLEANUP] get rid of BF_SHUT*_PENDING
-    - [MEDIUM] buffers: add BF_EMPTY and BF_FULL to remove dependency on req/rep->l
-    - [MAJOR] process_session: rely only on buffer flags
-    - [MEDIUM] use buffer->wex instead of buffer->cex for connect timeout
-    - [MEDIUM] centralize buffer timeout checks at the top of process_session
-    - [MINOR] ensure the termination flags are set by process_xxx
-    - [MEDIUM] session: move the analysis bit field to the buffer
-    - [OPTIM] process_cli/process_srv:  reduce the number of tests
-    - [BUG] regparm is broken on gcc < 3
-    - [BUILD] fix warning in proto_tcp.c with gcc >= 4
-    - [MEDIUM] merge inspect_exp and txn->exp into request buffer
-    - [BUG] process_cli/process_srv: don't call shutdown when already done
-    - [BUG] process_request: HTTP body analysis must return zero if missing data
-    - [TESTS] test-fsm: 22 regression tests for state machines
-    - [BUG] Fix empty X-Forwarded-For header name when set in defaults section
-    - [BUG] fix harmless but wrong fd insertion sequence
-    - [MEDIUM] make it possible for analysers to follow the whole session
-    - [MAJOR] rework of the server FSM
-    - [OPTIM] remove useless fd_set(read) upon shutdown(write)
-    - [MEDIUM] massive cleanup of process_srv()
-    - [MEDIUM] second level of code cleanup for process_srv_data
-    - [MEDIUM] third cleanup and optimization of process_srv_data()
-    - [MEDIUM] process_srv_data: ensure that we always correctly re-arm timeouts
-    - [MEDIUM] stream_sock_process_data moved to stream_sock.c
-    - [MAJOR] make the client side use stream_sock_process_data()
-    - [MEDIUM] split stream_sock_process_data
-    - [OPTIM] stream_sock_read must check for null-reads more often
-    - [MINOR] only call flow analysers when their read side is connected.
-    - [MEDIUM] reintroduce BF_HIJACK with produce_content
-    - [MINOR] re-arrange buffer flags and rename some of them
-    - [MINOR] do not check for BF_SHUTR when computing write timeout
-    - [OPTIM] ev_sepoll: detect newly created FDs and check them once
-    - [OPTIM] reduce the number of calls to task_wakeup()
-    - [OPTIM] force inlining of large functions with gcc >= 3
-    - [MEDIUM] indicate a reason for a task wakeup
-    - [MINOR] change type of fdtab[]->owner to void*
-    - [MAJOR] make stream sockets aware of the stream interface
-    - [MEDIUM] stream interface: add the ->shutw method as well as in and out buffers
-    - [MEDIUM] buffers: add BF_READ_ATTACHED and BF_ANA_TIMEOUT
-    - [MEDIUM] process_session: make use of the new buffer flags
-    - [CLEANUP] process_session: move debug outputs out of the critical loop
-    - [MEDIUM] move QUEUE and TAR timers to stream interfaces
-    - [OPTIM] add compiler hints in tick_is_expired()
-    - [MINOR] add buffer_check_timeouts() to check what timeouts have fired.
-    - [MEDIUM] use buffer_check_timeouts instead of stream_sock_check_timeouts()
-    - [MINOR] add an expiration flag to the stream_sock_interface
-    - [MAJOR] migrate the connection logic to stream interface
-    - [MAJOR] add a connection error state to the stream_interface
-    - [MEDIUM] add the SN_CURR_SESS flag to the session to track open sessions
-    - [MEDIUM] continue layering cleanups.
-    - [MEDIUM] stream_interface: added a DISconnected state between CON/EST and CLO
-    - [MEDIUM] remove stream_sock_update_data()
-    - [MINOR] maintain a global session list in order to ease debugging
-    - [BUG] shutw must imply close during a connect
-    - [MEDIUM] process shutw during connection attempt
-    - [MEDIUM] make the stream interface control the SHUT{R,W} bits
-    - [MAJOR] complete layer4/7 separation
-    - [CLEANUP] move the session-related functions to session.c
-    - [MINOR] call session->do_log() for logging
-    - [MINOR] replace the ambiguous client_return function by stream_int_return
-    - [MINOR] replace client_retnclose() with stream_int_retnclose()
-    - [MINOR] replace srv_close_with_err() with http_server_error()
-    - [MEDIUM] make the http server error function a pointer in the session
-    - [CLEANUP] session.c: removed some migration left-overs in sess_establish()
-    - [MINOR] stream_sock_data_finish() should not expose fd
-    - [MEDIUM] extract TCP request processing from HTTP
-    - [MEDIUM] extract the HTTP tarpit code from process_request().
-    - [MEDIUM] move the HTTP request body analyser out of process_request().
-    - [MEDIUM] rename process_request to http_process_request
-    - [BUG] fix forgotten server session counter
-    - [MINOR] declare process_session in session.h, not proto_http.h
-    - [MEDIUM] first pass of lifting to proto_uxst.c:uxst_event_accept()
-    - [MINOR] add an analyser code for UNIX stats request
-    - [MINOR] pre-set analyser flags on the listener at registration time
-    - [BUG] do not forward close from cons to prod with analysers
-    - [MEDIUM] ensure that sock->shutw() also closes read for init states
-    - [MINOR] add an analyser state in struct session
-    - [MAJOR] make unix sockets work again with stats
-    - [MEDIUM] remove cli_fd, srv_fd, cli_state and srv_state from the session
-    - [MINOR] move the listener reference from fd to session
-    - [MEDIUM] reference the current hijack function in the buffer itself
-    - [MINOR] slightly rebalance stats_dump_{raw,http}
-    - [MINOR] add a new back-reference type : struct bref
-    - [MINOR] add back-references to sessions for later use by a dumper.
-    - [MEDIUM] add support for "show sess" in unix stats socket
-    - [BUG] do not release the connection slot during a retry
-    - [BUG] dynamic connection throttling could return a max of zero conns
-    - [BUG] do not try to pause backends during reload
-    - [BUG] ensure that listeners from disabled proxies are correctly unbound.
-    - [BUG] acl-related keywords are not allowed in defaults sections
-    - [BUG] cookie capture is declared in the frontend but checked on the backend
-    - [BUG] critical errors should be reported even in daemon mode
-    - [MINOR] redirect: add support for the "drop-query" option
-    - [MINOR] redirect: add support for "set-cookie" and "clear-cookie"
-    - [MINOR] redirect: in prefix mode a "/" means not to change the URI
-    - [BUG] do not dequeue requests on a dead server
-    - [BUG] do not dequeue the backend's pending connections on a dead server
-    - [MINOR] stats: indicate if a task is running in "show sess"
-    - [BUG] check timeout must not be changed if timeout.check is not set
-    - [BUG] "option transparent" is for backend, not frontend !
-    - [MINOR] transfer errors were not reported anymore in data phase
-    - [MEDIUM] add a send limit to a buffer
-    - [MEDIUM] don't report buffer timeout when there is I/O activity
-    - [MEDIUM] indicate when we don't care about read timeout
-    - [MINOR] add flags to indicate when a stream interface is waiting for space/data
-    - [MEDIUM] enable inter-stream_interface wakeup calls
-    - [MAJOR] implement autonomous inter-socket forwarding
-    - [MINOR] add the splice_len member to the buffer struct in preparation of splice support
-    - [MEDIUM] stream_sock: factor out the return path in case of no-writes
-    - [MEDIUM] i/o: rework ->to_forward and ->send_max
-    - [OPTIM] stream_sock: do not ask for polling on EAGAIN if we have read
-    - [OPTIM] buffer: replace rlim by max_len
-    - [OPTIM] stream_sock: factor out the buffer full handling out of the loop
-    - [CLEANUP] replace a few occurrences of (flags & X) && !(flags & Y)
-    - [CLEANUP] stream_sock: move the write-nothing condition out of the loop
-    - [MEDIUM] split stream_sock_write() into callback and core functions
-    - [MEDIUM] stream_sock_read: call ->chk_snd whenever there are data pending
-    - [MINOR] stream_sock: fix a few wrong empty calculations
-    - [MEDIUM] stream_sock: try to send pending data on chk_snd()
-    - [MINOR] global.maxpipes: add the ability to reserve file descriptors for pipes
-    - [MEDIUM] splice: add configuration options and set global.maxpipes
-    - [MINOR] introduce structures required to support Linux kernel splicing
-    - [MEDIUM] add definitions for Linux kernel splicing
-    - [MAJOR] complete support for linux 2.6 kernel splicing
-    - [BUG] reserve some pipes for backends with splice enabled
-    - [MEDIUM] splice: add hints to support older buggy kernels
-    - [MEDIUM] introduce pipe pools
-    - [MEDIUM] splice: make use of pipe pools
-    - [STATS] report pipe usage in the statistics
-    - [OPTIM] make global.maxpipes default to global.maxconn/4 when not specified
-    - [BUILD] fix snapshot date extraction with negative timezones
-    - [MEDIUM] move global tuning options to the global structure
-    - [MEDIUM] splice: add the global "nosplice" option
-    - [BUILD] add USE_LINUX_SPLICE to enable LINUX_SPLICE on linux 2.6
-    - [BUG] we must not exit if protocol binding only returns a warning
-    - [MINOR] add support for bind interface name
-    - [BUG] inform the user when root is expected but not set
-    - [MEDIUM] add support for source interface binding
-    - [MEDIUM] add support for source interface binding at the server level
-    - [MEDIUM] implement bind-process to limit service presence by process
-    - [DOC] document maxpipes, nosplice, option splice-{auto,request,response}
-    - [DOC] filled the logging section of the configuration manual
-    - [DOC] document HTTP status codes
-    - [DOC] document a few missing info about errorfile
-    - [BUG] fix random memory corruption using "show sess"
-    - [BUG] fix unix socket processing of interrupted output
-    - [DOC] add diagrams of queuing and future ACL design
-    - [BUILD] proto_http did not build on gcc-2.95
-    - [BUG] the "source" keyword must first clear optional settings
-    - [BUG] global.tune.maxaccept must be limited even in mono-process mode
-    - [MINOR] ensure that http_msg_analyzer updates pointer to invalid char
-    - [MEDIUM] store a complete dump of request and response errors in proxies
-    - [MEDIUM] implement error dump on unix socket with "show errors"
-    - [DOC] document "show errors"
-    - [MINOR] errors dump must use user-visible date, not internal date.
-    - [MINOR] time: add __usec_to_1024th to convert usecs to 1024th of second
-    - [MINOR] add curr_sec_ms and curr_sec_ms_scaled for current second.
-    - [MEDIUM] measure and report session rate on frontend, backends and servers
-    - [BUG] the "connslots" keyword was matched as "connlots"
-    - [MINOR] acl: add 2 new verbs: fe_sess_rate and be_sess_rate
-    - [MEDIUM] implement "rate-limit sessions" for the frontend
-    - [BUG] interface binding: length must include the trailing zero
-    - [BUG] typo in timeout error reporting : report *res and not *err
-    - [OPTIM] maintain_proxies: only wake up when the frontend will be ready
-    - [OPTIM] rate-limit: cleaner behaviour on low rates and reduce consumption
-    - [BUG] switch server-side stream interface to close in case of abort
-    - [CLEANUP] remove last references to term_trace
-    - [OPTIM] freq_ctr: do not rotate the counters when reading
-    - [BUG] disable any analysers for monitoring requests
-    - [BUG] rate-limit in defaults section was ignored
-    - [BUG] task: fix handling of duplicate keys
-    - [OPTIM] task: don't unlink a task from a wait queue when waking it up
-    - [OPTIM] displace tasks in the wait queue only if absolutely needed
-    - [MEDIUM] minor update to the task api: let the scheduler queue itself
-    - [BUG] event_accept() must always wake the task up, even in health mode
-    - [CLEANUP] task: distinguish between clock ticks and timers
-    - [OPTIM] task: reduce the number of calls to task_queue()
-    - [OPTIM] do not re-check req buffer when only response has changed
-    - [CLEANUP] don't enable kernel splicing when socket is closed
-    - [CLEANUP] buffer_flush() was misleading, rename it as buffer_erase
-    - [MINOR] buffers: implement buffer_flush()
-    - [MEDIUM] rearrange forwarding condition to enable splice during analysis
-    - [BUILD] build fixes for Solaris
-    - [BUILD] proto_http did not build on gcc-2.95 (again)
-    - [CONTRIB] halog: fast log parser for haproxy
-    - [CONTRIB] halog: faster fgets() and add support for percentile reporting
-
-2008/04/19 : 1.3.15
-    - [BUILD] Added support for 'make install'
-    - [BUILD] Added 'install-man' make target for installing the man page
-    - [BUILD] Added 'install-bin' make target
-    - [BUILD] Added 'install-doc' make target
-    - [BUILD] Removed "/" after '$(DESTDIR)' in install targets
-    - [BUILD] Changed 'install' target to install the binaries first
-    - [BUILD] Replace hardcoded 'LD = gcc' with 'LD = $(CC)'
-    - [MEDIUM]: Inversion for options
-    - [MEDIUM]: Count retries and redispatches also for servers, fix redistribute_pending, extend logs, %d->%u cleanup
-    - [BUG]: Restore clearing t->logs.bytes
-    - [MEDIUM]: rework checks handling
-    - [DOC] Update a "contrib" file with a hint about a scheme used for formathing subjects
-    - [MEDIUM] Implement "track [<backend>/]<server>"
-    - [MINOR] Implement persistent id for proxies and servers
-    - [BUG] Don't increment server connections too much + fix retries
-    - [MEDIUM]: Prevent redispatcher from selecting the same server, version #3
-    - [MAJOR] proto_uxst rework -> SNMP support
-    - [BUG] appsession lookup in URL does not work
-    - [BUG] transparent proxy address was ignored in backend
-    - [BUG] hot reconfiguration failed because of a wrong error check
-    - [DOC] big update to the configuration manual
-    - [DOC] large update to the configuration manual
-    - [DOC] document more options
-    - [BUILD] major rework of the GNU Makefile
-    - [STATS] add support for "show info" on the unix socket
-    - [DOC] document options forwardfor to logasap
-    - [MINOR] add support for the "backlog" parameter
-    - [OPTIM] introduce global parameter "tune.maxaccept"
-    - [MEDIUM] introduce "timeout http-request" in frontends
-    - [MINOR] tarpit timeout is also allowed in backends
-    - [BUG] increment server connections for each connect()
-    - [MEDIUM] add a turn-around state of one second after a connection failure
-    - [BUG] fix typo in redispatched connection
-    - [DOC] document options nolinger to ssl-hello-chk
-    - [DOC] added documentation for "option tcplog" to "use_backend"
-    - [BUG] connect_server: server might not exist when sending error report
-    - [MEDIUM] support fully transparent proxy on Linux (USE_LINUX_TPROXY)
-    - [MEDIUM] add non-local bind to connect() on Linux
-    - [MINOR] add transparent proxy support for balabit's Tproxy v4
-    - [BUG] use backend's source and not server's source with tproxy
-    - [BUG] fix overlapping server flags
-    - [MEDIUM] fix server health checks source address selection
-    - [BUG] build failed on CONFIG_HAP_LINUX_TPROXY without CONFIG_HAP_CTTPROXY
-    - [DOC] added "server", "source" and "stats" keywords
-    - [DOC] all server parameters have been documented
-    - [DOC] document all req* and rsp* keywords.
-    - [DOC] added documentation about HTTP header manipulations
-    - [BUG] log response byte count, not request
-    - [BUILD] code did not build in full debug mode
-    - [BUG] fix truncated responses with sepoll
-    - [MINOR] use s->frt_addr as the server's address in transparent proxy
-    - [MINOR] fix configuration hint about timeouts
-    - [DOC] minor cleanup of the doc and notice to contributors
-    - [MINOR] report correct section type for unknown keywords.
-    - [BUILD] update MacOS Makefile to build on newer versions
-    - [DOC] fix erroneous "useallbackups" option in the doc
-    - [DOC] applied small fixes from early readers
-    - [MINOR] add configuration support for "redir" server keyword
-    - [MEDIUM] completely implement the server redirection method
-    - [TESTS] add a test case for the server redirection mechanism
-    - [DOC] add a configuration entry for "server ... redir <prefix>"
-    - [BUILD] backend.c and checks.c did not build without tproxy !
-    - Revert "[BUILD] backend.c and checks.c did not build without tproxy !"
-    - [BUILD] backend.c and checks.c did not build without tproxy !
-    - [OPTIM] used unsigned ints for HTTP state and message offsets
-    - [OPTIM] GCC4's builtin_expect() is suboptimal
-    - [BUG] failed conns were sometimes incremented in the frontend!
-    - [BUG] timeout.check was not pre-set to eternity
-    - [TESTS] add test-pollers.cfg to easily report pollers in use
-    - [BUG] do not apply timeout.connect in checks if unset
-    - [BUILD] ensure that makefile understands USE_DLMALLOC=1
-    - [MINOR] silent gcc for a wrong warning
-    - [CLEANUP] update .gitignore to ignore more temporary files
-    - [CLEANUP] report dlmalloc's source path only if explictly specified
-    - [BUG] str2sun could leak a small buffer in case of error during parsing
-    - [BUG] option allbackups was not working anymore in roundrobin mode
-    - [MAJOR] implementation of the "leastconn" load balancing algorithm
-    - [BUILD] ensure that users don't build without setting the target anymore.
-    - [DOC] document the leastconn LB algo
-    - [MEDIUM] fix stats socket limitation to 16 kB
-    - [DOC] fix unescaped space in httpchk example.
-    - [BUG] fix double-decrement of server connections
-    - [TESTS] add a test case for port mapping
-    - [TESTS] add a benchmark for integer hashing
-    - [TESTS] add new methods in ip-hash test file
-    - [MAJOR] implement parameter hashing for POST requests
-
-2007/12/06 : 1.3.14
-    - New option http_proxy (Alexandre Cassen)
-    - add support for "maxqueue" to limit server queue overload (Elijah Epifanov)
-    - Check for duplicated conflicting proxies (Krzysztof Oledzki)
-    - stats: report server and backend cumulated downtime (Krzysztof Oledzki)
-    - use backends only with use_backend directive (Krzysztof Oledzki)
-    - Handle long lines properly (Krzysztof Oledzki)
-    - Implement and use generic findproxy and relax duplicated proxy check (Krzysztof Oledzki)
-    - continous statistics (Krzysztof Oledzki)
-    - add support for logging via a UNIX socket (Robert Tsai)
-    - fix error checking in strl2ic/strl2uic()
-    - fix calls to localtime()
-    - provide easier-to-use ultoa_* functions
-    - provide easy-to-use limit_r and LIM2A* macros
-    - add a simple test for the status page
-    - move error codes to common/errors.h
-    - silent warning about LIST_* being redefined on OpenBSD
-    - add socket address length to the protocols
-    - group PR_O_BALANCE_* bits into a checkable value
-    - externalize the "balance" option parser to backend.c
-    - introduce the "url_param" balance method
-    - make default_backend work in TCP mode too
-    - disable warning about localtime_r on Solaris
-    - adjust error messages about conflicting proxies
-    - avoid calling some layer7 functions if not needed
-    - simplify error path in event_accept()
-    - add an options field to the listeners
-    - added a new state to listeners
-    - unbind_listener() must use fd_delete() and not close()
-    - add a generic unbind_listener() primitive
-    - add a generic delete_listener() primitive
-    - add a generic unbind_all_listeners() primitive
-    - create proto_tcp and move initialization of proxy listeners
-    - stats: report numerical process ID, proxy ID and server ID
-    - relative_pid was not initialized
-    - missing header names in raw stats output
-    - fix missing parenthesis in check_response_for_cacheability
-    - small optimization on session_process_counters()
-    - merge ebtree version 3.0
-    - make ebtree headers multiple-include compatible
-    - ebtree: include config.h for REGPRM*
-    - differentiate between generic LB params and map-specific ones
-    - add a weight divisor to the struct proxy
-    - implement the Fast Weighted Round Robin (FWRR) algo
-    - include filltab25.c to experiment on FWRR for dynamic weights
-    - merge test-fwrr.cfg to validate dynamic weights
-    - move the load balancing algorithm to be->lbprm.algo
-    - change server check result to a bit field
-    - implement "http-check disable-on-404" for graceful shutdown
-    - secure the calling conditions of ->set_server_status_{up,down}
-    - report disabled servers as "NOLB" when they are still UP
-    - document the "http-check disable-on-404" option
-    - http-check disable-on-404 is not limited to HTTP mode
-    - add a test file for disable-on-404
-    - use distinct bits per load-balancing algorithm type
-    - implement the slowstart parameter for servers
-    - document the server's slowstart parameter
-    - stats: report the server warm up status in a "throttle" column
-    - fix 2 minor issues on AIX
-    - add the "nbsrv" ACL verb
-    - add the "fail" condition to monitor requests
-    - remove a warning from gcc due to htons() in standard.c
-    - fwrr: ensure that we never overflow in placements
-    - store the build options to report with -vv
-    - fix the status return of the init script (R.I. Pienaar)
-    - stats: real time monitoring script for unix socket (Prizee) 
-    - document "nbsrv" and "monitor fail"
-    - restrict the set of allowed characters for identifiers
-    - implement a time parsing function
-    - add support for time units in the configuration
-    - add a bit of documentation about timers
-    - introduce separation between contimeout, and tarpit + queue
-    - introduce the "timeout" keyword
-    - grouped all timeouts in one structure
-    - slowstart is in ms, not seconds
-    - slowstart: ensure we don't start with a null weight
-    - report the number of times each server was selected
-    - fix build on AIX due to recent log changes
-    - fix build on Solaris due to recent log changes
-
-2007/10/18 : 1.3.13
-    - replace the code under O'Reilly license (Arnaud Cornet)
-    - add a small man page (Arnaud Cornet)
-    - stats: report haproxy's version by default (Krzysztof Oledzki)
-    - stats: count server retries and redispatches (Krzysztof Oledzki)
-    - core: added easy support for Doug Lea's malloc (dlmalloc)
-    - core: fade out memory usage when stopping proxies
-    - core: moved the sockaddr pointer to the fdtab structure
-    - core: add generic protocol support
-    - core: implement client-side support for PF_UNIX sockets
-    - stats: implement the CSV output
-    - stats: add a link to the CSV export HTML page
-    - stats: implement the statistics output on a unix socket
-    - config: introduce the "stats" keyword in global section
-    - build: centralize version and date into one file for each
-    - tests: added a new hash algorithm
-
-2007/10/18 : 1.3.12.3
-    - add the "nolinger" option to disable data lingering (Alexandre Cassen)
-    - fix double-free during clean exit (Krzysztof Oledzki)
-    - prevent the system from sending an RST when closing health-checks
-      (Krzysztof Oledzki)
-    - do not add a cache-control header when on non-cacheable responses
-      (Krzysztof Oledzki)
-    - spread health checks even more (Krzysztof Oledzki)
-    - stats: scope "." must match the backend and not the frontend
-    - fixed call to chroot() during startup
-    - fix wrong timeout computation in event_accept()
-    - remove condition for exit() under fork() failure
-
-2007/09/20 : 1.3.12.2
-    - fix configuration sanity checks for TCP listeners
-    - set the log socket receive window to zero bytes
-    - pre-initialize timeouts to infinity, not zero
-    - fix the SIGHUP message not to alert on server-less proxies
-    - timeouts and retries could be ignored when switching backend
-    - added a file to check that "retries" works.
-    - O'Reilly has clarified its license
-
-2007/09/05 : 1.3.12.1
-    - spec I/O: fix allocations of spec entries for an FD
-    - ensure we never overflow in chunk_printf()
-    - improve behaviour with large number of servers per proxy
-    - add support for "stats refresh <interval>"
-    - stats page: added links for 'refresh' and 'hide down'
-    - fix backend's weight in the stats page.
-    - the "stats" keyword is not allowed in a pure frontend.
-    - provide a test configuration file for stats and checks
-
-2007/06/17 : 1.3.12
-    - fix segfault at exit when using captures
-    - bug: negation in ACL conds was not cleared between terms
-    - errorfile: use a local file to feed error messages
-    - acl: support '-i' to ignore case when matching
-    - acl: smarter integer comparison with operators eq,lt,gt,le,ge
-    - acl: support maching on 'path' component
-    - acl: implement matching on header values
-    - acl: distinguish between request and response headers
-    - acl: permit to return any header when no name specified
-    - acl: provide default ACLs
-    - added the 'use_backend' keyword for full content-switching
-    - acl: specify the direction during fetches
-    - acl: provide the argument length for fetch functions
-    - acl: provide a reference to the expr to fetch()
-    - improve memory freeing upon exit
-    - str2net() must not change the const char *
-    - shut warnings 'is*' macros from ctype.h on solaris
-
-2007/06/03 : 1.3.11.4
-    - do not re-arm read timeout in SHUTR state !
-    - optimize I/O by detecting system starvation
-    - the epoll FD must not be shared between processes
-    - limit the number of events returned by *poll*
-
-2007/05/14 : 1.3.11.3
-    - pre-initialize timeouts with tv_eternity during parsing
-
-2007/05/14 : 1.3.11.2
-    - fixed broken health-checks since switch to timeval
-
-2007/05/14 : 1.3.11.1
-    - fixed ev_kqueue which was forgotten during the switch to timeval
-    - allowed null timeouts for past events in select
-
-2007/05/14 : 1.3.11
-    - fixed ev_sepoll again by rewriting the state machine
-    - switched all timeouts to timevals instead of milliseconds
-    - improved memory management using mempools v2.
-    - several minor optimizations
-
-2007/05/09 : 1.3.10.2
-    - fixed build on OpenBSD (missing types.h)
-
-2007/05/09 : 1.3.10.1
-    - fixed sepoll transition matrix (two states were missing)
-
-2007/05/08 : 1.3.10
-    - several fixes in ev_sepoll
-    - fixed some expiration dates on some tasks
-    - fixed a bug in connection establishment detection due to speculative I/O
-    - fixed rare bug occuring on TCP with early close (reported by Andy Smith)
-    - implemented URI hashing algorithm (Guillaume Dallaire)
-    - implemented SMTP health checks (Peter van Dijk)
-    - replaced the rbtree with ul2tree from old scheduler project
-    - new framework for generic ACL support
-    - added the 'acl' and 'block' keywords to the config language
-    - added several ACL criteria and matches (IP, port, URI, ...)
-    - cleaned up and better modularization for some time functions
-    - fixed list macros
-    - fixed useless memory allocation in str2net()
-    - store the original destination address in the session
-
-2007/04/15 : 1.3.9
-    - modularized the polling mechanisms and use function pointers instead
-      of macros at many places
-    - implemented support for FreeBSD's kqueue() polling mechanism
-    - fixed a warning on OpenBSD : MIN/MAX redefined
-    - change socket registration order at startup to accomodate kqueue.
-    - several makefile cleanups to support old shells
-    - fix build with limits.h once for all
-    - ev_epoll: do not rely on fd_sets anymore, use changes stacks instead.
-    - fdtab now holds the results of polling
-    - implemented support for speculative I/O processing with epoll()
-    - remove useless calls to shutdown(SHUT_RD), resulting in small speed boost
-    - auto-registering of pollers at load time
-
-2007/04/03 : 1.3.8.2
-    - rewriting either the status line or request line could crash the
-      process due to a pointer which ought to be reset before parsing.
-    - rewriting the status line in the response did not work, it caused
-      a 502 Bad Gateway due to an erroneous state during parsing
-
-2007/04/01 : 1.3.8.1
-    - fix reqadd when no option httpclose is used.
-    - removed now unused fiprm and beprm from proxies
-    - split logs into two versions : TCP and HTTP
-    - added some docs about http headers storage and acls
-    - added a VIM script for syntax color highlighting (Bruno Michel)
-
-2007/03/25 : 1.3.8
-    - fixed several bugs which might have caused a crash with bad configs
-    - several optimizations in header processing
-    - many progresses towards transaction-based processing
-    - option forwardfor may be used in frontends
-    - completed HTTP response processing
-    - some code refactoring between request and response processing
-    - new HTTP header manipulation functions
-    - optimizations on the recv() patch to reduce CPU usage under very
-      high data rates.
-    - more user-friendly help about the 'usesrc' keyword (CTTPROXY)
-    - username/groupname support from Marcus Rueckert
-    - added the "except" keyword to the "forwardfor" option (Bryan German)
-    - support for health-checks on other addresses (Fabrice Dulaunoy)
-    - makefile for MacOS 10.4 / Darwin (Dan Zinngrabe)
-    - do not insert "Connection: close" in HTTP/1.0 messages
-
-2007/01/26 : 1.3.7
-    - fix critical bug introduced with 1.3.6 : an empty request header
-      may lead to a crash due to missing pointer assignment
-    - hdr_idx might be left uninitialized in debug mode
-    - fixed build on FreeBSD due to missing fd_set declaration
-
-2007/01/22 : 1.3.6.1
-    - change in the header chaining broke cookies and authentication
-
-2007/01/22 : 1.3.6
-    - stats now support the HEAD method too
-    - extracted http request from the session
-    - huge rework of the HTTP parser which is now a 28-state FSM.
-    - linux-style likely/unlikely macros for optimization hints
-    - do not create a server socket when there's no server
-    - imported lots of docs
-
-2007/01/07 : 1.3.5
-    - stats: swap color sets for active and backup servers
-    - try to guess server check port when unset
-    - added complete support and doc for TCP Splicing
-    - replace the wait-queue linked list with an rbtree.
-    - a few bugfixes and cleanups
-
-2007/01/02 : 1.3.4
-    - support for cttproxy on the server side to present the client
-      address to the server.
-    - added support for SO_REUSEPORT on Linux (needs kernel patch)
-    - new RFC2616-compliant HTTP request parser with header indexing
-    - split proxies in frontends, rulesets and backends
-    - implemented the 'req[i]setbe' to select a backend depending
-      on the contents
-    - added the 'default_backend' keyword to select a default BE.
-    - new stats page featuring FEs and BEs + bytes in both dirs
-    - improved log format to indicate the backend and the time in ms.
-    - lots of cleanups
-
-2006/10/15 : 1.3.3
-    - fix broken redispatch option in case the connection has already
-      been marked "in progress" (ie: nearly always).
-    - support regparm on x86 to speed up some often called functions
-    - removed a few useless calls to gettimeofday() in log functions.
-    - lots of 'const char*' cleanups
-    - turn every FD_* into functions which are faster on recent CPUs
-
-2006/09/03 : 1.3.2
-    - started the changes towards I/O completion callbacks. stream_sock* have
-      replaced event_*.
-    - added the new "reqtarpit" and "reqitarpit" protection features
-
-2006/07/09 : 1.3.1 (1.2.15)
-   - now, haproxy warns about missing timeout during startup to try to
-     eliminate all those buggy configurations.
-   - added "Content-Type: text/html" in responses wherever appropriate, as
-     suggested by Cameron Simpson.
-   - implemented "option ssl-hello-chk" to use SSLv3 CLIENT HELLO messages to
-     test server's health
-   - implemented "monitor-uri" so that haproxy can reply to a specific URI with
-     an "HTTP/1.0 200 OK" response. This is useful to validate multiple proxies
-     at once.
-
-2006/06/29 : 1.3.0
-   - exploded the whole file into multiple .c and .h. No functionnal
-     difference is expected at all.
-   - fixed a bug by which neither stats nor error messages could be returned if
-     'clitimeout' was missing.
-
-2006/05/21 : 1.2.14
-   - new HTML status report with the 'stats' keyword.
-   - added the 'abortonclose' option to better resist traffic surges
-   - implemented dynamic traffic regulation with the 'minconn' option
-   - show request time on denied requests
-   - definitely fixed hot reconf on OpenBSD by the use of SO_REUSEPORT
-   - now a proxy instance is allowed to run without servers, which is
-     useful to dedicate one instance to stats
-   - added lots of error counters
-   - a missing parenthesis preventd matching of cacheable cookies
-   - a missing parenthesis in poll_loop() might have caused missed events.
-
-2006/05/14 : 1.2.13.1
-   - an uninitialized field in the struct session could cause a crash when
-     the session was freed. This has been encountered on Solaris only.
-   - Solaris and OpenBSD no not support shutdown() on listening socket. Let's
-     be nice to them by performing a soft stop if pause fails.
-
-2006/05/13 : 1.2.13
-   - 'maxconn' server parameter to do per-server session limitation
-   - queueing to support non-blocking session limitation
-   - fixed removal of cookies for cookie-less servers such as backup servers
-   - two separate wait queues for expirable and non-expirable tasks provide
-     better performance with lots of sessions.
-   - some code cleanups and performance improvements
-   - made state dumps a bit more verbose
-   - fixed missing checks for NULL srv in dispatch mode
-   - load balancing on backup servers was not possible in source hash mode.
-   - two session flags shared the same bit, but fortunately they were not
-     compatible.
-
-2006/04/15 : 1.2.12
-   Very few changes preparing for more important changes to support per-server
-   session limitations and queueing :
-   - ignore leading empty lines in HTTP requests as suggested by RFC2616.
-   - added the 'weight' parameter to the servers, limited to 1..256. It applies
-     to roundrobin and source hash.
-   - the optional '-s' option could clobber '-st' and '-sf' if compiled in.
-
-2006/03/30 : 1.2.11.1
-   - under some conditions, it might have been possible that when the
-     last dead server became available, it would not have been used
-     till another one would have changed state. Could not be reproduced
-     at all, however seems possible from the code.
-
-2006/03/25 : 1.2.11
-   - added the '-db' command-line option to disable backgrounding.
-   - added the -sf/-st command-line arguments which are used to specify
-     a list of pids to send a FINISH or TERMINATE signal upon startup.
-     They will also be asked to release their port if a bind fails.
-   - reworked the startup mechanism to allow the sending of a signal to a list
-     of old pids if a socket cannot be bound, with a retry for a limited amount
-     of time (1 second by default).
-   - added the ability to enforce limits on memory usage.
-   - added the 'source' load-balancing algorithm which uses the source IP(v4|v6)
-   - re-architectured the server round-robin mechanism to ease integration of
-     other algorithms. It now relies on the number of active and backup servers.
-   - added a counter for the number of active and backup servers, and report
-     these numbers upon SIGHUP or state change.
-
-2006/03/23 : 1.2.10.1
-  - while fixing the backup server round-robin "feature", a new bug was
-    introduced which could miss some backup servers.
-  - the displayed proxy name was wrong when dumping upon SIGHUP.
-
-2006/03/19 : 1.2.10
-  - assert.h is needed when DEBUG is defined.
-  - ENORMOUS long standing bug affecting the epoll polling system :
-    event_data is a union, not a structure !
-  - Make fd management more robust and easier to debug. Also some
-    micro-optimisations.
-  - Limit the number of consecutive accept() in multi-process mode.
-    This produces a more evenly distributed load across the processes and
-    slightly improves performance by reducing bottlenecks.
-  - Make health-checks be more regular, and faster to retry after a timeout.
-  - Fixed some messages to ease parsing of alerts.
-  - provided a patch to enable epoll on RHEL3 kernels.
-  - Separated OpenBSD build from the main Makefile into a new one.
-
-2006/03/15 : 1.2.9
-  - haproxy could not be stopped after being paused, it had to be woken up
-    first. This has been fixed.
-  - the 'ulimit-n' parameter is now optional and by default computed from
-    maxconn + the number of listeners + the number of health-checks.
-  - it is now possible to specify a maximum number of connections at build
-    time with the SYSTEM_MAXCONN define. The value set in the configuration
-    file will then be limited to this value, and only the command-line '-n'
-    option will be able to bypass it. It will prevent against accidental
-    high memory usage on small systems.
-  - RFC2616 expects that any HTTP agent accepts multi-line headers. Earlier
-    versions did not detect a line beginning with a space as the continuation
-    of previous header. It is now correct.
-  - health checks sent to servers configured with identical intervals were
-    sent in perfect synchronisation because the initial time was the same
-    for all. This could induce high load peaks when fragile servers were
-    hosting tens of instances for the same application.  Now the load is
-    spread evenly across the smallest interval amongst a listener.
-  - a new 'forceclose' option was added to make the proxy close the outgoing
-    channel to the server once it has sent all its headers and the server
-    starts responding. This helps some servers which don't close upon the
-    'Connection: close' header. It implies 'option httpclose'.
-  - there was a bug in the way the backup servers were handled. They were
-    erroneously load-balanced while the doc said the opposite. Since
-    load-balanced backup servers is one of the features some people have
-    been asking for, the problem was fixed to reflect the documented
-    behaviour and a new option 'allbackups' was introduced to provide the
-    feature to those who need it.
-  - a never ending connect() could lead to a fast select() loop if its
-    timeout times the number of retransmits exceeded the server read or write
-    timeout, because the later was used to compute select()'s timeout while
-    the connection timeout was not reached.
-  - now we initialize the libc's localtime structures very early so that even
-    under OOM conditions, we can still send dated error messages without
-    segfaulting.
-  - the 'daemon' mode implies 'quiet' and disables 'verbose' because file
-    descriptors are closed.
-
-2006/01/29 : 1.2.8
-  - fixed a nasty bug affecting poll/epoll which could return unmodified data
-    from the server to the client, and sometimes lead to memory corruption
-    crashing the process.
-  - added the new pause/play mechanism with SIGTTOU/SIGTTIN for hot-reconf.
-
-2005/12/18 : 1.2.7.1
-  - the "retries" option was ignored because connect() could not return an
-    error if the connection failed before the timeout.
-  - TCP health-checks could not detect a connection refused in poll/epoll
-    mode.
-
-2005/11/13 : 1.2.7
-  - building with -DUSE_PCRE should include PCRE headers and not regex.h. At
-    least on Solaris, this caused the libc's regex primitives to be used instead
-    of PCRE, which caused trouble on group references. This is now fixed.
-  - delayed the quiet mode during startup so that most of the startup alerts can
-    be displayed even in quiet mode.
-  - display an alert when a listener has no address, invalid or no port, or when
-    there are no enabled listeners upon startup.
-  - added "static-pcre" to the list of supported regex options in the Makefile.
-
-2005/10/09 : 1.2.7rc (1.1.33rc)
-  - second batch of socklen_t changes.
-  - clean-ups from Cameron Simpson.
-  - because tv_remain() does not know about eternity, using no timeout can
-    make select() spin around a null time-out. Bug reported by Cameron Simpson.
-  - client read timeout was not properly set to eternity initialized after an
-    accept() if it was not set in the config. It remained undetected so long
-    because eternity is 0 and newly allocated pages are zeroed by the system.
-  - do not call get_original_dst() when not in transparent mode.
-  - implemented a workaround for a bug in certain epoll() implementations on
-    linux-2.4 kernels (epoll-lt <= 0.21).
-  - implemented TCP keepalive with new options : tcpka, clitcpka, srvtcpka.
-
-2005/08/07 : 1.2.6
-  - clean-up patch from Alexander Lazic fixes build on Debian 3.1 (socklen_t).
-
-2005/07/06 : 1.2.6-pre5 (1.1.32)
-  - added the number of active sessions (proxy/process) in the logs
-
-2005/07/06 : 1.2.6-pre4 (1.1.32-pre4)
-  - the time-out fix introduced in 1.1.25 caused a corner case where it was
-    possible for a client to keep a connection maintained regardless of the
-    timeout if the server closed the connection during the HEADER phase,
-    while the client ignored the close request while doing nothing in the
-    other direction. This has been fixed now by ensuring that read timeouts
-    are re-armed when switching to any SHUTW state.
-
-2005/07/05 : 1.2.6-pre3 (1.1.32-pre3)
-  - enhanced error reporting in the logs. Now the proxy will precisely detect
-    various error conditions related to the system and/or process limits, and
-    generate LOG_EMERG logs indicating that a resource has been exhausted.
-  - logs will contain two new characters for the error cause : 'R' indicates
-    a resource exhausted, and 'I' indicates an internal error, though this
-    one should never happen.
-  - server connection timeouts can now be reported in the logs (sC), as well
-    as connections refused because of maxconn limitations (PC).
-
-2005/07/05 : 1.2.6-pre2 (1.1.32-pre2)
-  - new global configuration keyword "ulimit-n" may be used to raise the FD
-    limit to usable values.
-  - a warning is now displayed on startup if the FD limit is lower than the
-    configured maximum number of sockets.
-
-2005/07/05 : 1.2.6-pre1 (1.1.32-pre1)
-  - new configuration keyword "monitor-net" makes it possible to be monitored
-    by external devices which connect to the proxy without being logged nor
-    forwarded to any server. Particularly useful on generic TCPv4 relays.
-
-2005/06/21 : 1.2.5.2
-  - fixed build on PPC where chars are unsigned by default
-
-2005/05/02 : 1.2.5.1
-  - dirty hack to fix a bug introduced with epoll : if we close an FD and
-    immediately reassign it to another session through a connect(), the
-    Prev{Read,Write}Events are not updated, which causes trouble detecting
-    changes, thus leading to many timeouts at high loads.
-
-2005/04/30 : 1.2.5 (1.1.31)
-  - changed the runtime argument to disable epoll() to '-de'
-  - changed the runtime argument to disable poll() to '-dp'
-  - added global options 'nopoll' and 'noepoll' to do the same at the
-    configuration level.
-  - added a 'linux24e' target to the Makefile for Linux 2.4 systems patched to
-    support epoll().
-  - changed default FD_SETSIZE to 65536 on Solaris (default=1024)
-  - conditionned signals redirection to #ifdef DEBUG_MEMORY
-
-2005/04/26 : 1.2.5-pre4
-  - made epoll() support a compile-time option : ENABLE_EPOLL
-  - provided a very little libc replacement for a possibly missing epoll()
-    implementation which can be enabled by -DUSE_MY_EPOLL
-  - implemented the poll() poller, which can be enabled with -DENABLE_POLL.
-    The equivalent runtime argument becomes '-P'. A few tests show that it
-    performs like select() with many fds, but slightly slower (certainly
-    because of the higher amount of memory involved).
-  - separated the 3 polling methods and the tasks scheduler into 4 distinct
-    functions which makes the code a lot more modular.
-  - moved some event tables to private static declarations inside the poller
-    functions.
-  - the poller functions can now initialize themselves, run, and cleanup.
-  - changed the runtime argument to enable epoll() to '-E'.
-  - removed buggy epoll_ctl() code in the client_retnclose() function. This
-    function was never meant to remove anything.
-  - fixed a typo which caused glibc to yell about a double free on exit.
-  - removed error checking after epoll_ctl(DEL) because we can never know if
-    the fd is still active or already closed.
-  - added a few entries in the makefile
-
-2005/04/25 : 1.2.5-pre3
-  - experimental epoll() support (use temporary '-e' argument)
-
-2005/04/24 : 1.2.5-pre2
-  - implemented the HTTP 303 code for error redirection. This forces the
-    browser to fetch the given URI with a GET request. The new keyword for
-    this is 'errorloc303', and a new 'errorloc302' keyword has been created
-    to make them easily distinguishable.
-  - added more controls in the parser for valid use of '\x' sequence.
-  - few fixes from Alex & Klaus
-
-2005/02/17 : 1.2.5-pre1
-  - fixed a few errors in the documentation
-
-2005/02/13
-  - do not pre-initialize unused file-descriptors before select() anymore.
-
-2005/01/22 : 1.2.4
-  - merged Alexander Lazic's and Klaus Wagner's work on application
-    cookie-based persistence. Since this is the first merge, this version is
-    not intended for general use and reports are more than welcome. Some
-    documentation is really needed though.
-
-2005/01/22 : 1.2.3 (1.1.30)
-  - add an architecture guide to the documentation
-  - released without any changes
-
-2004/12/26 : 1.2.3-pre1 (1.1.30-pre1)
-  - increased default BUFSIZE to 16 kB to accept max headers of 8 kB which is
-    compatible with Apache. This limit can be configured in the makefile now.
-    Thanks to Eric Fehr for the checks.
-  - added a per-server "source" option which now makes it possible to bind to
-    a different source for each (potentially identical) server.
-  - changed cookie-based server selection slightly to allow several servers to
-    share a same cookie, thus making it possible to associate backup servers to
-    live servers and ease soft-stop for maintenance periods. (Alexander Lazic)
-  - added the cookie 'prefix' mode which makes it possible to use persistence
-    with thin clients which support only one cookie. The server name is prefixed
-    before the application cookie, and restore back.
-  - fixed the order of servers within an instance to match documentation. Now
-    the servers are *really* used in the order of their declaration. This is
-    particularly important when multiple backup servers are in use.
-
-2004/10/18 : 1.2.2 (1.1.29)
-  - fixed a bug where a TCP connection would be logged twice if the 'logasap'
-    option was enabled without the 'tcplog' option.
-  - encode_string() would use hdr_encode_map instead of the map argument.
-
-2004/08/10 : (1.1.29-pre2)
-  - the logged request is now encoded with '#XX' for unprintable characters
-  - new keywords 'capture request header' and 'capture response header' enable
-    logging of arbitrary HTTP headers in requests and responses
-  - removed "-DSOLARIS" after replacing the last inet_aton() with inet_pton()
-
-2004/06/06 : 1.2.1 (1.1.28)
-  - added the '-V' command line option to verbosely report errors even though
-    the -q or 'quiet' options are specified. This is useful with '-c'.
-  - added a Red Hat init script and a .spec from Simon Matter <simon.matter@invoca.ch>
-
-2004/06/05 :
-  - added the "logasap" option which produces a log without waiting for the data
-    to be transferred from the server to the client.
-  - added the "httpclose" option which removes any "connection:" header and adds
-    "Connection: close" in both direction.
-  - added the 'checkcache' option which blocks cacheable responses containing
-    dangerous headers, such as 'set-cookie'.
-  - added 'rspdeny' and 'rspideny' to block certain responses to avoid sensible
-    information leak from servers.
-
-2004/04/18 :
-  - send an EMERG log when no server is available for a given proxy
-  - added the '-c' command line option to syntactically check the
-    configuration file without starting the service.
-
-2003/11/09 : 1.2.0
-  - the same as 1.1.27 + IPv6 support on the client side
-
-2003/10/27 : 1.1.27
-  - the configurable HTTP health check introduced in 1.1.23 revealed a shameful
-    bug : the code still assumed that HTTP requests were the same size as the
-    original ones (22 bytes), and failed if they were not.
-  - added support for pidfiles.
-
-2003/10/22 : 1.1.26
-  - the fix introduced in 1.1.25 for client timeouts while waiting for servers
-    broke almost all compatibility with POST requests, because the proxy
-    stopped to read anything from the client as soon as it got all of its
-    headers.
-
-2003/10/15 : 1.1.25
-  - added the 'tcplog' option, which provides enhanced, HTTP-like logs for
-    generic TCP proxies, or lighter logs for HTTP proxies.
-  - fixed a time-out condition wrongly reported as client time-out in data
-    phase if the client timeout was lower than the connect timeout times the
-    number of retries.
-
-2003/09/21 : 1.1.24
-  - if a client sent a full request then shut its write connection down, then
-    the request was aborted. This case was detected only when using haproxy
-    both as health-check client and as a server.
-  - if 'option httpchk' is used in a 'health' mode server, then responses will
-    change from 'OK' to 'HTTP/1.0 200 OK'.
-  - fixed a Linux-only bug in case of HTTP server health-checks, where a single
-    server response followed by a close could be ignored, and the server seen
-    as failed.
-
-2003/09/19 : 1.1.23
-  - fixed a stupid bug introduced in 1.1.22 which caused second and subsequent
-    'default' sections to keep previous parameters, and not initialize logs
-    correctly.
-  - fixed a second stupid bug introduced in 1.1.22 which caused configurations
-    relying on 'dispatch' mode to segfault at the first connection.
-  - 'option httpchk' now supports method, HTTP version and a few headers.
-  - now, 'option httpchk', 'cookie' and 'capture' can be specified in
-    'defaults' section
-
-2003/09/10 : 1.1.22
-  - 'listen' now supports optionnal address:port-range lists
-  - 'bind' introduced to add new listen addresses
-  - fixed a bug which caused a session to be kept established on a server till
-    it timed out if the client closed during the DATA phase.
-  - the port part of each server address can now be empty to make the proxy
-    connect to the server on the same port it was connected to, be an absolute
-    unsigned number to reflect a single port (as in older versions), or an
-    explicitly signed number (+N/-N) to indicate that this offset must be
-    applied to the port the proxy was connected to, when connecting to the
-    server.
-  - the 'port' server option allows the user to specify a different
-    health-check port than the service one. It is mandatory when only relative
-    ports have been specified and check is required. By default, the checks are
-    sent to the service port.
-  - new 'defaults' section which is rather similar to 'listen' except that all
-    values are only used as default values for future 'listen' sections, until
-    a new 'defaults' resets them. At the moment, server options, regexes,
-    cookie names and captures cannot be set in the 'defaults' section.
-
-2003/05/06 : 1.1.21
-  - changed the debug output format so that it now includes the session unique
-    ID followed by the instance name at the beginning of each line.
-  - in debug mode, accept now shows the client's IP and port.
-  - added one 3 small debugging scripts to search and pretty print debug output
-  - changed the default health check request to "OPTIONS /" instead of
-    "OPTIONS *" since not all servers implement the later one.
-  - "option httpchk" now accepts an optional parameter allowing the user to
-    specify and URI other than '/' during health-checks.
-
-2003/04/21 : 1.1.20
-  - fixed two problems with time-outs, one where a server would be logged as
-    timed out during transfer that take longer to complete than the fixed
-    time-out, and one where clients were logged as timed-out during the data
-    phase because they didn't have anything to send. This sometimes caused
-    slow client connections to close too early while in fact there was no
-    problem. The proper fix would be to have a per-fd time-out with
-    conditions depending on the state of the HTTP FSM.
-
-2003/04/16 : 1.1.19
-  - haproxy was NOT RFC compliant because it was case-sensitive on HTTP
-    "Cookie:" and "Set-Cookie:" headers. This caused JVM 1.4 to fail on
-    cookie persistence because it uses "cookie:". Two memcmp() have been
-    replaced with strncasecmp().
-
-2003/04/02 : 1.1.18
-  - Haproxy can be compiled with PCRE regex instead of libc regex, by setting
-    REGEX=pcre on the make command line.
-  - HTTP health-checks now use "OPTIONS *" instead of "OPTIONS /".
-  - when explicit source address binding is required, it is now also used for
-    health-checks.
-  - added 'reqpass' and 'reqipass' to allow certain headers but not the request
-    itself.
-  - factored several strings to reduce binary size by about 2 kB.
-  - replaced setreuid() and setregid() with more standard setuid() and setgid().
-  - added 4 status flags to the log line indicating who ended the connection
-    first, the sessions state, the validity of the cookie, and action taken on
-    the set-cookie header.
-
-2002/10/18 : 1.1.17
-  - add the notion of "backup" servers, which are used only when all other
-    servers are down.
-  - make Set-Cookie return "" instead of "(null)" when the server has no
-    cookie assigned (useful for backup servers).
-  - "log" now supports an optionnal level name (info, notice, err ...) above
-    which nothing is sent.
-  - replaced some strncmp() with memcmp() for better efficiency.
-  - added "capture cookie" option which logs client and/or server cookies
-  - cleaned up/down messages and dump servers states upon SIGHUP
-  - added a redirection feature for errors : "errorloc <errnum> <url>"
-  - now we won't insist on connecting to a dead server, even with a cookie,
-    unless option "persist" is specified.
-  - added HTTP/408 response for client request time-out and HTTP/50[234] for
-    server reply time-out or errors.
-
-2002/09/01 : 1.1.16
-  - implement HTTP health checks when option "httpchk" is specified.
-
-2002/08/07 : 1.1.15
-  - replaced setpgid()/setpgrp() with setsid() for better portability, because
-    setpgrp() doesn't have the same meaning under Solaris, Linux, and OpenBSD.
-
-2002/07/20 : 1.1.14
-  - added "postonly" cookie mode
-
-2002/07/15 : 1.1.13
-  - tv_diff used inverted parameters which led to negative times !
-
-2002/07/13 : 1.1.12
-  - fixed stats monitoring, and optimized some tv_* for most common cases.
-  - replaced temporary 'newhdr' with 'trash' to reduce stack size
-  - made HTTP errors more HTML-fiendly.
-  - renamed strlcpy() to strlcpy2() because of a slightly difference between
-    their behaviour (return value), to avoid confusion.
-  - restricted HTTP messages to HTTP proxies only
-  - added a 502 message when the connection has been refused by the server,
-    to prevent clients from believing this is a zero-byte HTTP 0.9 reply.
-  - changed 'Cache-control:' from 'no-cache="set-cookie"' to 'private' when
-    inserting a cookie, because some caches (apache) don't understand it.
-  - fixed processing of server headers when client is in SHUTR state
-
-2002/07/04 :
-  - automatically close fd's 0,1 and 2 when going daemon ; setpgrp() after
-    setpgid()
-
-2002/06/04 : 1.1.11
-  - fixed multi-cookie handling in client request to allow clean deletion
-    in insert+indirect mode. Now, only the server cookie is deleted and not
-    all the header. Should now be compliant to RFC2965.
-  - added a "nocache" option to "cookie" to specify that we explicitly want
-    to add a "cache-control" header when we add a cookie.
-    It is also possible to add an "Expires: <old-date>" to keep compatibility
-    with old/broken caches.
-
-2002/05/10 : 1.1.10
-  - if a cookie is used in insert+indirect mode, it's desirable that the
-    the servers don't see it. It was not possible to remove it correctly
-    with regexps, so now it's removed automatically.
-
-2002/04/19 : 1.1.9
-  - don't use snprintf()'s return value as an end of message since it may
-    be larger. This caused bus errors and segfaults in internal libc's
-    getenv() during localtime() in send_log().
-  - removed dead insecure send_syslog() function and all references to it.
-  - fixed warnings on Solaris due to buggy implementation of isXXXX().
-
-2002/04/18 : 1.1.8
-  - option "dontlognull"
-  - fixed "double space" bug in config parser
-  - fixed an uninitialized server field in case of dispatch
-    with no existing server which could cause a segfault during
-    logging.
-  - the pid logged was always the father's, which was wrong for daemons.
-  - fixed wrong level "LOG_INFO" for message "proxy started".
-
-2002/04/13 :
-  - http logging is now complete :
-    - ip:port, date, proxy, server
-    - req_time, conn_time, hdr_time, tot_time
-    - status, size, request
-  - source address
-
-2002/04/12 : 1.1.7
-  - added option forwardfor
-  - added reqirep, reqidel, reqiallow, reqideny, rspirep, rspidel
-  - added "log global" in "listen" section.
-
-2002/04/09 :
-  - added a new "global" section :
-    - logs
-    - debug, quiet, daemon modes
-    - uid, gid, chroot, nbproc, maxconn
-
-2002/04/08 : 1.1.6
-  - regex are now chained and not limited anymore.
-  - unavailable server now returns HTTP/502.
-  - increased per-line args limit to 40
-  - added reqallow/reqdeny to block some request on matches
-  - added HTTP 400/403 responses
-
-2002/04/03 : 1.1.5
-  - connection logging displayed incorrect source address.
-  - added proxy start/stop and server up/down log events.
-  - replaced log message short buffers with larger trash.
-  - enlarged buffer to 8 kB and replace buffer to 4 kB.
-
-2002/03/25 : 1.1.4
-  - made rise/fall/interval time configurable
-
-2002/03/22 : 1.1.3
-  - fixed a bug : cr_expire and cw_expire were inverted in CL_STSHUT[WR]
-    which could lead to loops.
-
-2002/03/21 : 1.1.2
-  - fixed a bug in buffer management where we could have a loop
-    between event_read() and process_{cli|srv} if R==BUFSIZE-MAXREWRITE.
-    => implemented an adjustable buffer limit.
-  - fixed a bug : expiration of tasks in wait queue timeout is used again,
-    and running tasks are skipped.
-  - added some debug lines for accept events.
-  - send warnings for servers up/down.
-
-2002/03/12 : 1.1.1
-  - fixed a bug in total failure handling
-  - fixed a bug in timestamp comparison within same second (tv_cmp_ms)
-
-2002/03/10 : 1.1.0
-  - fixed a few timeout bugs
-  - rearranged the task scheduler subsystem to improve performance,
-    add new tasks, and make it easier to later port to librt ;
-  - allow multiple accept() for one select() wake up ;
-  - implemented internal load balancing with basic health-check ;
-  - cookie insertion and header add/replace/delete, with better strings
-    support.
-
-2002/03/08
-  - reworked buffer handling to fix a few rewrite bugs, and
-    improve overall performance.
-  - implement the "purge" option to delete server cookies in direct mode.
-
-2002/03/07
-  - fixed some error cases where the maxfd was not decreased.
-
-2002/02/26
-  - now supports transparent proxying, at least on linux 2.4.
-
-2002/02/12
-  - soft stop works again (fixed select timeout computation).
-  - it seems that TCP proxies sometimes cannot timeout.
-  - added a "quiet" mode.
-  - enforce file descriptor limitation on socket() and accept().
-
-2001/12/30 : release of version 1.0.2 : fixed a bug in header processing
-2001/12/19 : release of version 1.0.1 : no MSG_NOSIGNAL on solaris
-2001/12/16 : release of version 1.0.0.
-2001/12/16 : added syslog capability for each accepted connection.
-2001/11/19 : corrected premature end of files and occasional SIGPIPE.
-2001/10/31 : added health-check type servers (mode health) which replies OK then closes.
-2001/10/30 : added the ability to support standard TCP proxies and HTTP proxies
-		with or without cookies (use keyword http for this).
-2001/09/01 : added client/server header replacing with regexps.
-		eg:
-       		cliexp ^(Host:\ [^:]*).* Host:\ \1:80
-       		srvexp ^Server:\ .* Server:\ Apache
-2000/11/29 : first fully working release with complete FSMs and timeouts.
-2000/11/28 : major rewrite
-2000/11/26 : first write
diff --git a/deps/haproxy-1.4.21/LICENSE b/deps/haproxy-1.4.21/LICENSE
deleted file mode 100644
index a422f78..0000000
--- a/deps/haproxy-1.4.21/LICENSE
+++ /dev/null
@@ -1,32 +0,0 @@
-HAPROXY's license - 2006/06/15
-
-Historically, haproxy has been covered by GPL version 2. However, an issue
-appeared in GPL which will prevent external non-GPL code from being built
-using the headers provided with haproxy. My long-term goal is to build a core
-system able to load external modules to support specific application protocols.
-
-Since some protocols are found in rare environments (finance, industry, ...),
-some of them might be accessible only after signing an NDA. Enforcing GPL on
-such modules would only prevent them from ever being implemented, while not
-providing anything useful to ordinary users.
-
-For this reason, I *want* to be able to support binary only external modules
-when needed, with a GPL core and GPL modules for standard protocols, so that
-people fixing bugs don't keep them secretly to try to stay over competition.
-
-The solution was then to apply the LGPL license to the exportable include
-files, while keeping the GPL for all the rest. This way, it still is mandatory
-to redistribute modified code under customer request, but at the same time, it
-is expressly permitted to write, compile, link and load non-GPL code using the
-LGPL header files and not to distribute them if it causes a legal problem.
-
-Of course, users are strongly encouraged to continue the work under GPL as long
-as possible, since this license has allowed useful enhancements, contributions
-and fixes from talented people around the world.
-
-The text of the licenses lies in the "doc" directory. All the files provided in
-this package are covered by the GPL unless expressly stated otherwise in them.
-Every patch or contribution provided by external people will by default comply
-with the license of the files it affects, or be rejected.
-
-Willy Tarreau - w@1wt.eu
diff --git a/deps/haproxy-1.4.21/Makefile b/deps/haproxy-1.4.21/Makefile
deleted file mode 100644
index 8def6d3..0000000
--- a/deps/haproxy-1.4.21/Makefile
+++ /dev/null
@@ -1,583 +0,0 @@
-# This GNU Makefile supports different OS and CPU combinations.
-#
-# You should use it this way :
-#   [g]make TARGET=os ARCH=arch CPU=cpu USE_xxx=1 ...
-#
-# Valid USE_* options are the following. Most of them are automatically set by
-# the TARGET, others have to be explictly specified :
-#   USE_CTTPROXY         : enable CTTPROXY on Linux (needs kernel patch).
-#   USE_DLMALLOC         : enable use of dlmalloc (see DLMALLOC_SRC)
-#   USE_EPOLL            : enable epoll() on Linux 2.6. Automatic.
-#   USE_GETSOCKNAME      : enable getsockname() on Linux 2.2. Automatic.
-#   USE_KQUEUE           : enable kqueue() on BSD. Automatic.
-#   USE_MY_EPOLL         : redefine epoll_* syscalls. Automatic.
-#   USE_NETFILTER        : enable netfilter on Linux. Automatic.
-#   USE_PCRE             : enable use of libpcre for regex. Recommended.
-#   USE_POLL             : enable poll(). Automatic.
-#   USE_REGPARM          : enable regparm optimization. Recommended on x86.
-#   USE_SEPOLL           : enable speculative epoll(). Automatic.
-#   USE_STATIC_PCRE      : enable static libpcre. Recommended.
-#   USE_TPROXY           : enable transparent proxy. Automatic.
-#   USE_LINUX_TPROXY     : enable full transparent proxy (needs kernel 2.6.28).
-#   USE_LINUX_SPLICE     : enable kernel 2.6 splicing (broken on old kernels)
-#   USE_LIBCRYPT         : enable crypted passwords using -lcrypt
-#   USE_CRYPT_H          : set it if your system requires including crypt.h
-#
-# Options can be forced by specifying "USE_xxx=1" or can be disabled by using
-# "USE_xxx=" (empty string).
-#
-# Variables useful for packagers :
-#   CC is set to "gcc" by default and is used for compilation only.
-#   LD is set to "gcc" by default and is used for linking only.
-#   ARCH may be useful to force build of 32-bit binary on 64-bit systems
-#   CFLAGS is automatically set for the specified CPU and may be overridden.
-#   LDFLAGS is automatically set to -g and may be overridden.
-#   SMALL_OPTS may be used to specify some options to shrink memory usage.
-#   DEBUG may be used to set some internal debugging options.
-#   ADDINC may be used to complete the include path in the form -Ipath.
-#   ADDLIB may be used to complete the library list in the form -Lpath -llib.
-#   DEFINE may be used to specify any additional define, which will be reported
-#          by "haproxy -vv" in CFLAGS.
-#   SILENT_DEFINE may be used to specify other defines which will not be
-#     reported by "haproxy -vv".
-#   DESTDIR is not set by default and is used for installation only.
-#           It might be useful to set DESTDIR if you want to install haproxy
-#           in a sandbox.
-#   PREFIX  is set to "/usr/local" by default and is used for installation only.
-#   SBINDIR is set to "$(PREFIX)/sbin" by default and is used for installation
-#           only.
-#   MANDIR  is set to "$(PREFIX)/share/man" by default and is used for
-#           installation only.
-#   DOCDIR  is set to "$(PREFIX)/doc/haproxy" by default and is used for
-#           installation only.
-#
-# Other variables :
-#   DLMALLOC_SRC   : build with dlmalloc, indicate the location of dlmalloc.c.
-#   DLMALLOC_THRES : should match PAGE_SIZE on every platform (default: 4096).
-#   PCREDIR        : force the path to libpcre.
-#   IGNOREGIT      : ignore GIT commit versions if set.
-#   VERSION        : force haproxy version reporting.
-#   SUBVERS        : add a sub-version (eg: platform, model, ...).
-#   VERDATE        : force haproxy's release date.
-
-#### Installation options.
-DESTDIR =
-PREFIX = /usr/local
-SBINDIR = $(PREFIX)/sbin
-MANDIR = $(PREFIX)/share/man
-DOCDIR = $(PREFIX)/doc/haproxy
-
-#### TARGET system
-# Use TARGET=<target_name> to optimize for a specifc target OS among the
-# following list (use the default "generic" if uncertain) :
-#    generic, linux22, linux24, linux24e, linux26, solaris,
-#    freebsd, openbsd, cygwin, custom
-TARGET =
-
-#### TARGET CPU
-# Use CPU=<cpu_name> to optimize for a particular CPU, among the following
-# list :
-#    generic, native, i586, i686, ultrasparc, custom
-CPU = generic
-
-#### Architecture, used when not building for native architecture
-# Use ARCH=<arch_name> to force build for a specific architecture. Known
-# architectures will lead to "-m32" or "-m64" being added to CFLAGS and
-# LDFLAGS. This can be required to build 32-bit binaries on 64-bit targets.
-# Currently, only 32, 64, x86_64, i386, i486, i586 and i686 are understood.
-ARCH =
-
-#### Toolchain options.
-# GCC is normally used both for compiling and linking.
-CC = gcc
-LD = $(CC)
-
-#### Debug flags (typically "-g").
-# Those flags only feed CFLAGS so it is not mandatory to use this form.
-DEBUG_CFLAGS = -g
-
-#### Compiler-specific flags that may be used to disable some negative over-
-# optimization or to silence some warnings. -fno-strict-aliasing is needed with
-# gcc >= 4.4.
-SPEC_CFLAGS = -fno-strict-aliasing
-
-#### Memory usage tuning
-# If small memory footprint is required, you can reduce the buffer size. There
-# are 2 buffers per concurrent session, so 16 kB buffers will eat 32 MB memory
-# with 1000 concurrent sessions. Putting it slightly lower than a page size
-# will prevent the additional parameters to go beyond a page. 8030 bytes is
-# exactly 5.5 TCP segments of 1460 bytes and is generally good. Useful tuning
-# macros include :
-#    SYSTEM_MAXCONN, BUFSIZE, MAXREWRITE, REQURI_LEN, CAPTURE_LEN.
-# Example: SMALL_OPTS = -DBUFSIZE=8030 -DMAXREWRITE=1030 -DSYSTEM_MAXCONN=1024
-SMALL_OPTS =
-
-#### Debug settings
-# You can enable debugging on specific code parts by setting DEBUG=-DDEBUG_xxx.
-# Currently defined DEBUG macros include DEBUG_FULL, DEBUG_MEMORY, DEBUG_FSM,
-# DEBUG_HASH and DEBUG_AUTH. Please check sources for exact meaning or do not
-# use at all.
-DEBUG =
-
-#### Additional include and library dirs
-# Redefine this if you want to add some special PATH to include/libs
-ADDINC =
-ADDLIB =
-
-#### Specific macro definitions
-# Use DEFINE=-Dxxx to set any tunable macro. Anything declared here will appear
-# in the build options reported by "haproxy -vv". Use SILENT_DEFINE if you do
-# not want to pollute the report with complex defines.
-DEFINE =
-SILENT_DEFINE =
-
-
-#### CPU dependant optimizations
-# Some CFLAGS are set by default depending on the target CPU. Those flags only
-# feed CPU_CFLAGS, which in turn feed CFLAGS, so it is not mandatory to use
-# them. You should not have to change these options. Better use CPU_CFLAGS or
-# even CFLAGS instead.
-CPU_CFLAGS.generic    = -O2
-CPU_CFLAGS.native     = -O2 -march=native
-CPU_CFLAGS.i586       = -O2 -march=i586
-CPU_CFLAGS.i686       = -O2 -march=i686
-CPU_CFLAGS.ultrasparc = -O6 -mcpu=v9 -mtune=ultrasparc
-CPU_CFLAGS            = $(CPU_CFLAGS.$(CPU))
-
-#### ARCH dependant flags, may be overriden by CPU flags
-ARCH_FLAGS.32     = -m32
-ARCH_FLAGS.64     = -m64
-ARCH_FLAGS.i386   = -m32 -march=i386
-ARCH_FLAGS.i486   = -m32 -march=i486
-ARCH_FLAGS.i586   = -m32 -march=i586
-ARCH_FLAGS.i686   = -m32 -march=i686
-ARCH_FLAGS.x86_64 = -m64 -march=x86-64
-ARCH_FLAGS        = $(ARCH_FLAGS.$(ARCH))
-
-#### Common CFLAGS
-# These CFLAGS contain general optimization options, CPU-specific optimizations
-# and debug flags. They may be overridden by some distributions which prefer to
-# set all of them at once instead of playing with the CPU and DEBUG variables.
-CFLAGS = $(ARCH_FLAGS) $(CPU_CFLAGS) $(DEBUG_CFLAGS) $(SPEC_CFLAGS)
-
-#### Common LDFLAGS
-# These LDFLAGS are used as the first "ld" options, regardless of any library
-# path or any other option. They may be changed to add any linker-specific
-# option at the beginning of the ld command line.
-LDFLAGS = $(ARCH_FLAGS) -g
-
-#### Target system options
-# Depending on the target platform, some options are set, as well as some
-# CFLAGS and LDFLAGS. The USE_* values are set to "implicit" so that they are
-# not reported in the build options string. You should not have to change
-# anything there.
-ifeq ($(TARGET),generic)
-  # generic system target has nothing specific
-  USE_POLL   = implicit
-  USE_TPROXY = implicit
-else
-ifeq ($(TARGET),linux22)
-  # This is for Linux 2.2
-  USE_GETSOCKNAME = implicit
-  USE_POLL        = implicit
-  USE_TPROXY      = implicit
-  USE_LIBCRYPT    = implicit
-else
-ifeq ($(TARGET),linux24)
-  # This is for standard Linux 2.4 with netfilter but without epoll()
-  USE_GETSOCKNAME = implicit
-  USE_NETFILTER   = implicit
-  USE_POLL        = implicit
-  USE_TPROXY      = implicit
-  USE_LIBCRYPT    = implicit
-else
-ifeq ($(TARGET),linux24e)
-  # This is for enhanced Linux 2.4 with netfilter and epoll() patch > 0.21
-  USE_GETSOCKNAME = implicit
-  USE_NETFILTER   = implicit
-  USE_POLL        = implicit
-  USE_EPOLL       = implicit
-  USE_SEPOLL      = implicit
-  USE_MY_EPOLL    = implicit
-  USE_TPROXY      = implicit
-  USE_LIBCRYPT    = implicit
-else
-ifeq ($(TARGET),linux26)
-  # This is for standard Linux 2.6 with netfilter and standard epoll()
-  USE_GETSOCKNAME = implicit
-  USE_NETFILTER   = implicit
-  USE_POLL        = implicit
-  USE_EPOLL       = implicit
-  USE_SEPOLL      = implicit
-  USE_TPROXY      = implicit
-  USE_LIBCRYPT    = implicit
-else
-ifeq ($(TARGET),solaris)
-  # This is for Solaris 8
-  USE_POLL       = implicit
-  TARGET_CFLAGS  = -fomit-frame-pointer -DFD_SETSIZE=65536 -D_REENTRANT
-  TARGET_LDFLAGS = -lnsl -lsocket
-  USE_TPROXY     = implicit
-  USE_LIBCRYPT    = implicit
-  USE_CRYPT_H     = implicit
-else
-ifeq ($(TARGET),freebsd)
-  # This is for FreeBSD
-  USE_POLL       = implicit
-  USE_KQUEUE     = implicit
-  USE_TPROXY     = implicit
-  USE_LIBCRYPT   = implicit
-else
-ifeq ($(TARGET),openbsd)
-  # This is for OpenBSD >= 3.0
-  USE_POLL       = implicit
-  USE_KQUEUE     = implicit
-  USE_TPROXY     = implicit
-else
-ifeq ($(TARGET),cygwin)
-  # This is for Cygwin
-  # Cygwin adds IPv6 support only in version 1.7 (in beta right now). 
-  USE_POLL   = implicit
-  USE_TPROXY = implicit
-  TARGET_CFLAGS  = $(if $(filter 1.5.%, $(shell uname -r)), -DUSE_IPV6 -DAF_INET6=23 -DINET6_ADDRSTRLEN=46, )
-endif # cygwin
-endif # openbsd
-endif # freebsd
-endif # solaris
-endif # linux26
-endif # linux24e
-endif # linux24
-endif # linux22
-endif # generic
-
-
-#### Old-style REGEX library settings for compatibility with previous setups.
-# It is still possible to use REGEX=<regex_lib> to select an alternative regex
-# library. By default, we use libc's regex. On Solaris 8/Sparc, grouping seems
-# to be broken using libc, so consider using pcre instead. Supported values are
-# "libc", "pcre", and "static-pcre". Use of this method is deprecated in favor
-# of "USE_PCRE" and "USE_STATIC_PCRE" (see build options below).
-REGEX = libc
-
-ifeq ($(REGEX),pcre)
-USE_PCRE = 1
-$(warning WARNING! use of "REGEX=pcre" is deprecated, consider using "USE_PCRE=1" instead.)
-endif
-
-ifeq ($(REGEX),static-pcre)
-USE_STATIC_PCRE = 1
-$(warning WARNING! use of "REGEX=pcre-static" is deprecated, consider using "USE_STATIC_PCRE=1" instead.)
-endif
-
-#### Old-style TPROXY settings
-ifneq ($(findstring -DTPROXY,$(DEFINE)),)
-USE_TPROXY = 1
-$(warning WARNING! use of "DEFINE=-DTPROXY" is deprecated, consider using "USE_TPROXY=1" instead.)
-endif
-
-
-#### Determine version, sub-version and release date.
-# If GIT is found, and IGNOREGIT is not set, VERSION, SUBVERS and VERDATE are
-# extracted from the last commit. Otherwise, use the contents of the files
-# holding the same names in the current directory.
-
-ifeq ($(IGNOREGIT),)
-VERSION := $(shell [ -d .git/. ] && ref=`(git describe --tags) 2>/dev/null` && ref=$${ref%-g*} && echo "$${ref\#v}")
-ifneq ($(VERSION),)
-# OK git is there and works.
-SUBVERS := $(shell comms=`git log --no-merges v$(VERSION).. 2>/dev/null |grep -c ^commit `; [ $$comms -gt 0 ] && echo "-$$comms" )
-VERDATE := $(shell date +%Y/%m/%d -d "`git log --pretty=fuller HEAD^.. 2>/dev/null | sed -ne '/^CommitDate:/{s/\(^[^ ]*:\)\|\( [-+].*\)//gp;q}'`" )
-endif
-endif
-
-# Last commit version not found, take it from the files.
-ifeq ($(VERSION),)
-VERSION := $(shell cat VERSION 2>/dev/null || touch VERSION)
-endif
-ifeq ($(SUBVERS),)
-SUBVERS := $(shell cat SUBVERS 2>/dev/null || touch SUBVERS)
-endif
-ifeq ($(VERDATE),)
-VERDATE := $(shell cat VERDATE 2>/dev/null || touch VERDATE)
-endif
-
-#### Build options
-# Do not change these ones, enable USE_* variables instead.
-OPTIONS_CFLAGS  =
-OPTIONS_LDFLAGS =
-OPTIONS_OBJS    =
-
-# This variable collects all USE_* values except those set to "implicit". This
-# is used to report a list of all flags which were used to build this version.
-# Do not assign anything to it.
-BUILD_OPTIONS =
-
-# Return USE_xxx=$(USE_xxx) unless $(USE_xxx) = "implicit"
-# Usage: 
-#   BUILD_OPTIONS += $(call ignore_implicit,USE_xxx)
-ignore_implicit = $(patsubst %=implicit,,$(1)=$($(1)))
-
-ifneq ($(USE_TCPSPLICE),)
-$(error experimental option USE_TCPSPLICE has been removed, check USE_LINUX_SPLICE)
-endif
-
-ifneq ($(USE_LINUX_SPLICE),)
-OPTIONS_CFLAGS += -DCONFIG_HAP_LINUX_SPLICE
-BUILD_OPTIONS  += $(call ignore_implicit,USE_LINUX_SPLICE)
-endif
-
-ifneq ($(USE_CTTPROXY),)
-OPTIONS_CFLAGS += -DCONFIG_HAP_CTTPROXY
-OPTIONS_OBJS   += src/cttproxy.o
-BUILD_OPTIONS  += $(call ignore_implicit,USE_CTTPROXY)
-endif
-
-ifneq ($(USE_TPROXY),)
-OPTIONS_CFLAGS += -DTPROXY
-BUILD_OPTIONS  += $(call ignore_implicit,USE_TPROXY)
-endif
-
-ifneq ($(USE_LINUX_TPROXY),)
-OPTIONS_CFLAGS += -DCONFIG_HAP_LINUX_TPROXY
-BUILD_OPTIONS  += $(call ignore_implicit,USE_LINUX_TPROXY)
-endif
-
-ifneq ($(USE_LIBCRYPT),)
-OPTIONS_CFLAGS  += -DCONFIG_HAP_CRYPT
-BUILD_OPTIONS   += $(call ignore_implicit,USE_LIBCRYPT)
-OPTIONS_LDFLAGS += -lcrypt
-endif
-
-ifneq ($(USE_CRYPT_H),)
-OPTIONS_CFLAGS  += -DNEED_CRYPT_H
-BUILD_OPTIONS   += $(call ignore_implicit,USE_CRYPT_H)
-endif
-
-ifneq ($(USE_POLL),)
-OPTIONS_CFLAGS += -DENABLE_POLL
-OPTIONS_OBJS   += src/ev_poll.o
-BUILD_OPTIONS  += $(call ignore_implicit,USE_POLL)
-endif
-
-ifneq ($(USE_EPOLL),)
-OPTIONS_CFLAGS += -DENABLE_EPOLL
-OPTIONS_OBJS   += src/ev_epoll.o
-BUILD_OPTIONS  += $(call ignore_implicit,USE_EPOLL)
-endif
-
-ifneq ($(USE_SEPOLL),)
-OPTIONS_CFLAGS += -DENABLE_SEPOLL
-OPTIONS_OBJS   += src/ev_sepoll.o
-BUILD_OPTIONS  += $(call ignore_implicit,USE_SEPOLL)
-endif
-
-ifneq ($(USE_MY_EPOLL),)
-OPTIONS_CFLAGS += -DUSE_MY_EPOLL
-BUILD_OPTIONS  += $(call ignore_implicit,USE_MY_EPOLL)
-endif
-
-ifneq ($(USE_KQUEUE),)
-OPTIONS_CFLAGS += -DENABLE_KQUEUE
-OPTIONS_OBJS   += src/ev_kqueue.o
-BUILD_OPTIONS  += $(call ignore_implicit,USE_KQUEUE)
-endif
-
-ifneq ($(USE_NETFILTER),)
-OPTIONS_CFLAGS += -DNETFILTER
-BUILD_OPTIONS  += $(call ignore_implicit,USE_NETFILTER)
-endif
-
-ifneq ($(USE_GETSOCKNAME),)
-OPTIONS_CFLAGS += -DUSE_GETSOCKNAME
-BUILD_OPTIONS  += $(call ignore_implicit,USE_GETSOCKNAME)
-endif
-
-ifneq ($(USE_REGPARM),)
-OPTIONS_CFLAGS += -DCONFIG_REGPARM=3
-BUILD_OPTIONS  += $(call ignore_implicit,USE_REGPARM)
-endif
-
-# report DLMALLOC_SRC only if explicitly specified
-ifneq ($(DLMALLOC_SRC),)
-BUILD_OPTIONS += DLMALLOC_SRC=$(DLMALLOC_SRC)
-endif
-
-ifneq ($(USE_DLMALLOC),)
-BUILD_OPTIONS  += $(call ignore_implicit,USE_DLMALLOC)
-ifeq ($(DLMALLOC_SRC),)
-DLMALLOC_SRC=src/dlmalloc.c
-endif
-endif
-
-ifneq ($(DLMALLOC_SRC),)
-# DLMALLOC_THRES may be changed to match PAGE_SIZE on every platform
-DLMALLOC_THRES = 4096
-OPTIONS_OBJS  += src/dlmalloc.o
-endif
-
-ifneq ($(USE_PCRE),)
-# PCREDIR is the directory hosting include/pcre.h and lib/libpcre.*. It is
-# automatically detected but can be forced if required. Forcing it to an empty
-# string will result in search only in the default paths.
-ifeq ($(PCREDIR),)
-PCREDIR	        := $(shell pcre-config --prefix 2>/dev/null || echo /usr/local)
-endif
-ifeq ($(USE_STATIC_PCRE),)
-OPTIONS_CFLAGS  += -DUSE_PCRE $(if $(PCREDIR),-I$(PCREDIR)/include)
-OPTIONS_LDFLAGS += $(if $(PCREDIR),-L$(PCREDIR)/lib) -lpcreposix -lpcre
-endif
-BUILD_OPTIONS   += $(call ignore_implicit,USE_PCRE)
-endif
-
-ifneq ($(USE_STATIC_PCRE),)
-# PCREDIR is the directory hosting include/pcre.h and lib/libpcre.*. It is
-# automatically detected but can be forced if required.
-ifeq ($(PCREDIR),)
-PCREDIR         := $(shell pcre-config --prefix 2>/dev/null || echo /usr/local)
-endif
-OPTIONS_CFLAGS  += -DUSE_PCRE $(if $(PCREDIR),-I$(PCREDIR)/include)
-OPTIONS_LDFLAGS += $(if $(PCREDIR),-L$(PCREDIR)/lib) -Wl,-Bstatic -lpcreposix -lpcre -Wl,-Bdynamic
-BUILD_OPTIONS   += $(call ignore_implicit,USE_STATIC_PCRE)
-endif
-
-# This one can be changed to look for ebtree files in an external directory
-EBTREE_DIR := ebtree
-
-#### Global compile options
-VERBOSE_CFLAGS = $(CFLAGS) $(TARGET_CFLAGS) $(SMALL_OPTS) $(DEFINE)
-COPTS  = -Iinclude -I$(EBTREE_DIR) -Wall
-COPTS += $(CFLAGS) $(TARGET_CFLAGS) $(SMALL_OPTS) $(DEFINE) $(SILENT_DEFINE)
-COPTS += $(DEBUG) $(OPTIONS_CFLAGS) $(ADDINC)
-
-ifneq ($(VERSION)$(SUBVERS),)
-COPTS += -DCONFIG_HAPROXY_VERSION=\"$(VERSION)$(SUBVERS)\"
-endif
-
-ifneq ($(VERDATE),)
-COPTS += -DCONFIG_HAPROXY_DATE=\"$(VERDATE)\"
-endif
-
-#### Global link options
-# These options are added at the end of the "ld" command line. Use LDFLAGS to
-# add options at the beginning of the "ld" command line if needed.
-LDOPTS = $(TARGET_LDFLAGS) $(OPTIONS_LDFLAGS) $(ADDLIB)
-
-ifeq ($(TARGET),)
-all:
-	@echo
-	@echo "Due to too many reports of suboptimized setups, building without"
-	@echo "specifying the target is no longer supported. Please specify the"
-	@echo "target OS in the TARGET variable, in the following form:"
-	@echo
-	@echo "   $ make TARGET=xxx"
-	@echo
-	@echo "Please choose the target among the following supported list :"
-	@echo
-	@echo "   linux26, linux24, linux24e, linux22, solaris"
-	@echo "   freebsd, openbsd, cygwin, custom, generic"
-	@echo
-	@echo "Use \"generic\" if you don't want any optimization, \"custom\" if you"
-	@echo "want to precisely tweak every option, or choose the target which"
-	@echo "matches your OS the most in order to gain the maximum performance"
-	@echo "out of it. Please check the Makefile in case of doubts."
-	@echo
-	@exit 1
-else
-all: haproxy
-endif
-
-OBJS = src/haproxy.o src/sessionhash.o src/base64.o src/protocols.o \
-       src/uri_auth.o src/standard.o src/buffers.o src/log.o src/task.o \
-       src/time.o src/fd.o src/pipe.o src/regex.o src/cfgparse.o src/server.o \
-       src/checks.o src/queue.o src/client.o src/proxy.o src/stick_table.o src/proto_uxst.o \
-       src/proto_http.o src/stream_sock.o src/appsession.o src/backend.o \
-       src/lb_chash.o src/lb_fwlc.o src/lb_fwrr.o src/lb_map.o \
-       src/stream_interface.o src/dumpstats.o src/proto_tcp.o \
-       src/session.o src/hdr_idx.o src/ev_select.o src/signal.o \
-       src/acl.o src/pattern.o src/memory.o src/freq_ctr.o src/auth.o
-
-EBTREE_OBJS = $(EBTREE_DIR)/ebtree.o \
-              $(EBTREE_DIR)/eb32tree.o $(EBTREE_DIR)/eb64tree.o \
-              $(EBTREE_DIR)/ebmbtree.o $(EBTREE_DIR)/ebsttree.o \
-              $(EBTREE_DIR)/ebimtree.o $(EBTREE_DIR)/ebistree.o
-
-# Not used right now
-LIB_EBTREE = $(EBTREE_DIR)/libebtree.a
-
-haproxy: $(OBJS) $(OPTIONS_OBJS) $(EBTREE_OBJS)
-	$(LD) $(LDFLAGS) -o $@ $^ $(LDOPTS)
-
-$(LIB_EBTREE): $(EBTREE_OBJS)
-	$(AR) rv $@ $^
-
-objsize: haproxy
-	@objdump -t $^|grep ' g '|grep -F '.text'|awk '{print $$5 FS $$6}'|sort
-
-%.o:	%.c
-	$(CC) $(COPTS) -c -o $@ $<
-
-src/haproxy.o:	src/haproxy.c
-	$(CC) $(COPTS) \
-	      -DBUILD_TARGET='"$(strip $(TARGET))"' \
-	      -DBUILD_ARCH='"$(strip $(ARCH))"' \
-	      -DBUILD_CPU='"$(strip $(CPU))"' \
-	      -DBUILD_CC='"$(strip $(CC))"' \
-	      -DBUILD_CFLAGS='"$(strip $(VERBOSE_CFLAGS))"' \
-	      -DBUILD_OPTIONS='"$(strip $(BUILD_OPTIONS))"' \
-	       -c -o $@ $<
-
-src/dlmalloc.o: $(DLMALLOC_SRC)
-	$(CC) $(COPTS) -DDEFAULT_MMAP_THRESHOLD=$(DLMALLOC_THRES) -c -o $@ $<
-
-install-man:
-	install -d $(DESTDIR)$(MANDIR)/man1
-	install -m 644 doc/haproxy.1 $(DESTDIR)$(MANDIR)/man1
-
-install-doc:
-	install -d $(DESTDIR)$(DOCDIR)
-	for x in configuration architecture haproxy-en haproxy-fr; do \
-		install -m 644 doc/$$x.txt $(DESTDIR)$(DOCDIR) ; \
-	done
-
-install-bin: haproxy
-	install -d $(DESTDIR)$(SBINDIR)
-	install haproxy $(DESTDIR)$(SBINDIR)
-
-install: install-bin install-man install-doc
-
-clean:
-	rm -f *.[oas] src/*.[oas] ebtree/*.[oas] haproxy test
-	for dir in . src include/* doc ebtree; do rm -f $$dir/*~ $$dir/*.rej $$dir/core; done
-	rm -f haproxy-$(VERSION).tar.gz haproxy-$(VERSION)$(SUBVERS).tar.gz
-	rm -f haproxy-$(VERSION) nohup.out gmon.out
-
-tags:
-	find src include \( -name '*.c' -o -name '*.h' \) -print0 | \
-	   xargs -0 etags --declarations --members
-
-tar:	clean
-	ln -s . haproxy-$(VERSION)
-	tar --exclude=haproxy-$(VERSION)/.git \
-	    --exclude=haproxy-$(VERSION)/haproxy-$(VERSION) \
-	    --exclude=haproxy-$(VERSION)/haproxy-$(VERSION).tar.gz \
-	    -cf - haproxy-$(VERSION)/* | gzip -c9 >haproxy-$(VERSION).tar.gz
-	rm -f haproxy-$(VERSION)
-
-git-tar: clean
-	git archive --format=tar --prefix="haproxy-$(VERSION)/" HEAD | gzip -9 > haproxy-$(VERSION)$(SUBVERS).tar.gz
-
-version:
-	@echo "VERSION: $(VERSION)"
-	@echo "SUBVERS: $(SUBVERS)"
-	@echo "VERDATE: $(VERDATE)"
-
-# never use this one if you don't know what it is used for.
-update-version:
-	@echo "Ready to update the following versions :"
-	@echo "VERSION: $(VERSION)"
-	@echo "SUBVERS: $(SUBVERS)"
-	@echo "VERDATE: $(VERDATE)"
-	@echo "Press [ENTER] to continue or Ctrl-C to abort now.";read
-	echo "$(VERSION)" > VERSION
-	echo "$(SUBVERS)" > SUBVERS
-	echo "$(VERDATE)" > VERDATE
diff --git a/deps/haproxy-1.4.21/Makefile.bsd b/deps/haproxy-1.4.21/Makefile.bsd
deleted file mode 100644
index a27949e..0000000
--- a/deps/haproxy-1.4.21/Makefile.bsd
+++ /dev/null
@@ -1,150 +0,0 @@
-# This makefile is dedicated to OpenBSD (and possibly other BSDs)
-# You should use it this way :
-#   make TARGET=os CPU=cpu
-#
-# Some optional components may be added, such as DLMALLOC :
-#
-#   make TARGET=freebsd CPU=i686 DLMALLOC_SRC=/usr/local/src/dlmalloc.c \
-#        OPT_OBJS=src/dlmalloc.o
-
-# Select target OS. TARGET must match a system for which COPTS and LIBS are
-# correctly defined below.
-TARGET = openbsd
-
-# pass CPU=<cpu_name> to make to optimize for a particular CPU
-CPU = generic
-#CPU = native
-#CPU = i586
-#CPU = i686
-#CPU = ultrasparc
-
-# By default, we use libc's regex. WARNING! On Solaris 8/Sparc, group
-# references seem broken using libc ! Use pcre instead.
-REGEX=libc
-#REGEX=pcre
-#REGEX=static-pcre
-
-# tools options
-CC = gcc
-LD = gcc
-
-# This is the directory hosting include/pcre.h and lib/libpcre.* when REGEX=pcre
-PCREDIR!= pcre-config --prefix 2>/dev/null || :
-#PCREDIR=/usr/local
-
-# This is for OpenBSD 3.0 and above
-COPTS.openbsd = -DENABLE_POLL -DENABLE_KQUEUE
-LIBS.openbsd =
-
-# CPU dependant optimizations
-COPTS.generic = -O2
-COPTS.native = -O2 -march=native
-COPTS.i586 = -O2 -march=i586
-COPTS.i686 = -O2 -march=i686
-COPTS.ultrasparc = -O6 -mcpu=v9 -mtune=ultrasparc
-
-# options for standard regex library
-COPTS.libc=
-LIBS.libc=
-
-# options for libpcre
-COPTS.pcre=-DUSE_PCRE -I$(PCREDIR)/include
-LIBS.pcre=-L$(PCREDIR)/lib -lpcreposix -lpcre
-
-# options for static libpcre
-COPTS.static-pcre=-DUSE_PCRE -I$(PCREDIR)/include
-LIBS.static-pcre=-L$(PCREDIR)/lib -Wl,-Bstatic -lpcreposix -lpcre -Wl,-Bdynamic
-
-# you can enable debug arguments with "DEBUG=-g" or disable them with "DEBUG="
-#DEBUG = -g -DDEBUG_MEMORY -DDEBUG_FULL
-DEBUG = -g
-
-# if small memory footprint is required, you can reduce the buffer size. There
-# are 2 buffers per concurrent session, so 16 kB buffers will eat 32 MB memory
-# with 1000 concurrent sessions. Putting it slightly lower than a page size
-# will avoid the additionnal paramters to overflow a page. 8030 bytes is
-# exactly 5.5 TCP segments of 1460 bytes.
-#SMALL_OPTS =
-SMALL_OPTS = -DBUFSIZE=8030 -DMAXREWRITE=1030 -DSYSTEM_MAXCONN=1024
-
-# redefine this if you want to add some special PATH to include/libs
-ADDINC =
-ADDLIB =
-
-# redefine this if you want to add some special .o files
-OPT_OBJS =
-
-# set some defines when needed.
-# Known ones are -DENABLE_POLL
-# - use -DTPROXY to compile with transparent proxy support.
-DEFINE = -DTPROXY
-
-# May be changed to patch PAGE_SIZE on every platform when using dlmalloc
-DLMALLOC_THRES=4096
-
-# global options
-TARGET_OPTS=$(COPTS.$(TARGET))
-REGEX_OPTS=$(COPTS.$(REGEX))
-CPU_OPTS=$(COPTS.$(CPU))
-SPEC_OPTS=-fno-strict-aliasing
-
-VERSION != cat VERSION 2>/dev/null || touch VERSION
-SUBVERS != cat SUBVERS 2>/dev/null || touch SUBVERS
-VERDATE != cat VERDATE 2>/dev/null || touch VERDATE
-
-VER_OPTS := -DCONFIG_HAPROXY_VERSION=\"$(VERSION)$(SUBVERS)\" \
-            -DCONFIG_HAPROXY_DATE=\"$(VERDATE)\"
-
-# This one can be changed to look for ebtree files in an external directory
-EBTREE_DIR := ebtree
-
-COPTS   = -Iinclude -I$(EBTREE_DIR) $(ADDINC) $(CPU_OPTS) $(TARGET_OPTS) \
-          $(SPEC_OPTS) $(REGEX_OPTS) $(SMALL_OPTS) $(VER_OPTS) $(DEFINE)
-LIBS    = $(LIBS.$(TARGET)) $(LIBS.$(REGEX)) $(ADDLIB)
-CFLAGS  = -Wall $(COPTS) $(DEBUG)
-LDFLAGS = -g
-
-OBJS = src/haproxy.o src/sessionhash.o src/base64.o src/protocols.o \
-       src/uri_auth.o src/standard.o src/buffers.o src/log.o src/task.o \
-       src/time.o src/fd.o src/pipe.o src/regex.o src/cfgparse.o src/server.o \
-       src/checks.o src/queue.o src/client.o src/proxy.o src/proto_uxst.o \
-       src/proto_http.o src/stream_sock.o src/appsession.o src/backend.o \
-       src/stream_interface.o src/dumpstats.o src/proto_tcp.o \
-       src/session.o src/hdr_idx.o src/ev_select.o src/signal.o \
-       src/lb_chash.o src/lb_fwlc.o src/lb_fwrr.o src/lb_map.o \
-       src/ev_poll.o src/ev_kqueue.o \
-       src/acl.o src/memory.o src/freq_ctr.o \
-       src/auth.o src/stick_table.o src/pattern.o
-
-EBTREE_OBJS = $(EBTREE_DIR)/ebtree.o \
-              $(EBTREE_DIR)/eb32tree.o $(EBTREE_DIR)/eb64tree.o \
-              $(EBTREE_DIR)/ebmbtree.o $(EBTREE_DIR)/ebsttree.o \
-              $(EBTREE_DIR)/ebimtree.o $(EBTREE_DIR)/ebistree.o
-
-all: haproxy
-
-haproxy: $(OBJS) $(OPT_OBJS) $(EBTREE_OBJS)
-	$(LD) $(LDFLAGS) -o $@ $> $(LIBS)
-
-.SUFFIXES: .c.o
-
-.c.o:
-	$(CC) $(CFLAGS) -c -o $@ $>
-
-src/haproxy.o: src/haproxy.c
-	$(CC) $(CFLAGS) -DBUILD_TARGET='"$(TARGET)"' -DBUILD_CC='"$(CC)"' \
-	                -DBUILD_CPU='"$(CPU)"' -DBUILD_REGEX='"$(REGEX)"' \
-	                -DBUILD_OPTS='"$(COPTS)"' -c -o $@ $>
-
-src/dlmalloc.o: $(DLMALLOC_SRC)
-	$(CC) $(CFLAGS) -DDEFAULT_MMAP_THRESHOLD=$(DLMALLOC_THRES) -c -o $@ $>
-
-clean:
-	rm -f *.[oas] src/*.[oas] ebtree/*.[oas] haproxy test
-	for dir in . src include/* doc ebtree; do rm -f $$dir/*~ $$dir/*.rej $$dir/core; done
-	rm -f haproxy-$(VERSION).tar.gz haproxy-$(VERSION) nohup.out gmon.out
-
-version:
-	@echo "VERSION: $(VERSION)"
-	@echo "SUBVERS: $(SUBVERS)"
-	@echo "VERDATE: $(VERDATE)"
diff --git a/deps/haproxy-1.4.21/Makefile.osx b/deps/haproxy-1.4.21/Makefile.osx
deleted file mode 100644
index c32acab..0000000
--- a/deps/haproxy-1.4.21/Makefile.osx
+++ /dev/null
@@ -1,147 +0,0 @@
-# This makefile is dedicated to darwin (and possibly other BSDs)
-# You should use it this way :
-#   make TARGET=os CPU=cpu
-#
-# Some optional components may be added, such as DLMALLOC :
-#
-#   make DLMALLOC_SRC=/usr/local/src/dlmalloc.c \
-#        OPT_OBJS=src/dlmalloc.o
-
-# Select target OS. TARGET must match a system for which COPTS and LIBS are
-# correctly defined below.
-TARGET = generic
-
-# pass CPU=<cpu_name> to make to optimize for a particular CPU
-CPU = generic
-#CPU = native
-#CPU = i586
-#CPU = i686
-#CPU = ultrasparc
-
-# By default, we use libc's regex. WARNING! On Solaris 8/Sparc, group
-# references seem broken using libc ! Use pcre instead.
-REGEX=libc
-#REGEX=pcre
-#REGEX=static-pcre
-
-# tools options
-CC = gcc
-LD = gcc
-
-# This is the directory hosting include/pcre.h and lib/libpcre.* when REGEX=pcre
-PCREDIR!= pcre-config --prefix 2>/dev/null || :
-#PCREDIR=/usr/local
-
-# This one can be changed to look for ebtree files in an external directory
-EBTREE_DIR = ebtree
-
-# This is for darwin 3.0 and above
-COPTS.darwin = -DENABLE_POLL -DENABLE_KQUEUE
-LIBS.darwin =
-
-# CPU dependant optimizations
-COPTS.generic = -O2
-COPTS.native = -O2 -march=native
-COPTS.i586 = -O2 -march=i586
-COPTS.i686 = -O2 -march=i686
-COPTS.ultrasparc = -O6 -mcpu=v9 -mtune=ultrasparc
-
-# options for standard regex library
-COPTS.libc=
-LIBS.libc=
-
-# options for libpcre
-COPTS.pcre=-DUSE_PCRE -I$(PCREDIR)/include
-LIBS.pcre=-L$(PCREDIR)/lib -lpcreposix -lpcre
-
-# options for static libpcre
-COPTS.static-pcre=-DUSE_PCRE -I$(PCREDIR)/include
-LIBS.static-pcre=-L$(PCREDIR)/lib -Wl,-Bstatic -lpcreposix -lpcre -Wl,-Bdynamic
-
-# you can enable debug arguments with "DEBUG=-g" or disable them with "DEBUG="
-#DEBUG = -g -DDEBUG_MEMORY -DDEBUG_FULL
-DEBUG = -g
-
-# if small memory footprint is required, you can reduce the buffer size. There
-# are 2 buffers per concurrent session, so 16 kB buffers will eat 32 MB memory
-# with 1000 concurrent sessions. Putting it slightly lower than a page size
-# will avoid the additionnal paramters to overflow a page. 8030 bytes is
-# exactly 5.5 TCP segments of 1460 bytes.
-#SMALL_OPTS =
-SMALL_OPTS = -DBUFSIZE=8030 -DMAXREWRITE=1030 -DSYSTEM_MAXCONN=1024
-
-# redefine this if you want to add some special PATH to include/libs
-ADDINC =
-ADDLIB =
-
-# set some defines when needed.
-# Known ones are -DENABLE_POLL
-# - use -DTPROXY to compile with transparent proxy support.
-DEFINE = -DTPROXY 
-
-# May be changed to patch PAGE_SIZE on every platform when using dlmalloc
-DLMALLOC_THRES=4096
-
-# global options
-TARGET_OPTS=$(COPTS.$(TARGET))
-REGEX_OPTS=$(COPTS.$(REGEX))
-CPU_OPTS=$(COPTS.$(CPU))
-SPEC_OPTS=-fno-strict-aliasing
-
-VERSION != cat VERSION 2>/dev/null || touch VERSION
-SUBVERS != cat SUBVERS 2>/dev/null || touch SUBVERS
-VERDATE != cat VERDATE 2>/dev/null || touch VERDATE
-
-VER_OPTS := -DCONFIG_HAPROXY_VERSION=\"$(VERSION)$(SUBVERS)\" \
-            -DCONFIG_HAPROXY_DATE=\"$(VERDATE)\"
-
-COPTS   = -Iinclude -I$(EBTREE_DIR) $(ADDINC) $(CPU_OPTS) $(TARGET_OPTS) \
-          $(SPEC_OPTS) $(REGEX_OPTS) $(SMALL_OPTS) $(VER_OPTS) $(DEFINE)
-LIBS    = $(LIBS.$(TARGET)) $(LIBS.$(REGEX)) $(ADDLIB)
-CFLAGS  = -Wall $(COPTS) $(DEBUG) -isysroot /Developer/SDKs/MacOSX10.4u.sdk -arch ppc -arch i386 -mmacosx-version-min=10.4
-LDFLAGS = -g -isysroot /Developer/SDKs/MacOSX10.4u.sdk -arch ppc -arch i386 -mmacosx-version-min=10.4
-
-OBJS = src/haproxy.o src/sessionhash.o src/base64.o src/protocols.o \
-       src/uri_auth.o src/standard.o src/buffers.o src/log.o src/task.o \
-       src/time.o src/fd.o src/pipe.o src/regex.o src/cfgparse.o src/server.o \
-       src/checks.o src/queue.o src/client.o src/proxy.o src/proto_uxst.o \
-       src/proto_http.o src/stream_sock.o src/appsession.o src/backend.o \
-       src/stream_interface.o src/dumpstats.o src/proto_tcp.o \
-       src/session.o src/hdr_idx.o src/ev_select.o src/signal.o \
-       src/lb_chash.o src/lb_fwlc.o src/lb_fwrr.o src/lb_map.o \
-       src/ev_poll.o \
-       src/acl.o src/memory.o src/freq_ctr.o \
-       src/auth.o src/stick_table.o src/pattern.o
-
-EBTREE_OBJS = $(EBTREE_DIR)/ebtree.o \
-              $(EBTREE_DIR)/eb32tree.o $(EBTREE_DIR)/eb64tree.o \
-              $(EBTREE_DIR)/ebmbtree.o $(EBTREE_DIR)/ebsttree.o \
-              $(EBTREE_DIR)/ebimtree.o $(EBTREE_DIR)/ebistree.o
-
-all: haproxy
-
-haproxy: $(OBJS) $(EBTREE_OBJS)
-	$(LD) $(LDFLAGS) $(OBJS) $(EBTREE_OBJS) -o $@
-
-.SUFFIXES: .c.o
-
-.c.o:
-	$(CC) $(CFLAGS) -c -o $@ $<
-
-src/haproxy.o: src/haproxy.c
-	$(CC) $(CFLAGS) -DBUILD_TARGET='"$(TARGET)"' -DBUILD_CC='"$(CC)"' \
-	                -DBUILD_CPU='"$(CPU)"' -DBUILD_REGEX='"$(REGEX)"' \
-	                -DBUILD_OPTS='"$(COPTS)"' -c -o $@ $<
-
-src/dlmalloc.o: $(DLMALLOC_SRC)
-	$(CC) $(CFLAGS) -DDEFAULT_MMAP_THRESHOLD=$(DLMALLOC_THRES) -c -o $@ $<
-
-clean:
-	rm -f *.[oas] src/*.[oas] ebtree/*.[oas] haproxy test
-	for dir in . src include/* doc ebtree; do rm -f $$dir/*~ $$dir/*.rej $$dir/core; done
-	rm -f haproxy-$(VERSION).tar.gz haproxy-$(VERSION) nohup.out gmon.out
-
-version:
-	@echo "VERSION: $(VERSION)"
-	@echo "SUBVERS: $(SUBVERS)"
-	@echo "VERDATE: $(VERDATE)"
diff --git a/deps/haproxy-1.4.21/README b/deps/haproxy-1.4.21/README
deleted file mode 100644
index 899f436..0000000
--- a/deps/haproxy-1.4.21/README
+++ /dev/null
@@ -1,425 +0,0 @@
-                         ----------------------
-                             HAProxy how-to
-                         ----------------------
-                              version 1.4
-                             willy tarreau
-                               2010/09/16
-
-
-1) How to build it
-------------------
-
-To build haproxy, you will need :
-  - GNU make. Neither Solaris nor OpenBSD's make work with the GNU Makefile.
-    However, specific Makefiles for BSD and OSX are provided.
-  - GCC between 2.91 and 4.5.0. Others may work, but not tested.
-  - GNU ld
-
-Also, you might want to build with libpcre support, which will provide a very
-efficient regex implementation and will also fix some badness on Solaris' one.
-
-To build haproxy, you have to choose your target OS amongst the following ones
-and assign it to the TARGET variable :
-
-  - linux22     for Linux 2.2
-  - linux24     for Linux 2.4 and above (default)
-  - linux24e    for Linux 2.4 with support for a working epoll (> 0.21)
-  - linux26     for Linux 2.6 and above
-  - solaris     for Solaris 8 or 10 (others untested)
-  - freebsd     for FreeBSD 5 to 8.0 (others untested)
-  - openbsd     for OpenBSD 3.1 to 4.6 (others untested)
-  - cygwin      for Cygwin
-  - generic     for any other OS.
-  - custom      to manually adjust every setting
-
-You may also choose your CPU to benefit from some optimizations. This is
-particularly important on UltraSparc machines. For this, you can assign
-one of the following choices to the CPU variable :
-
-  - i686 for intel PentiumPro, Pentium 2 and above, AMD Athlon
-  - i586 for intel Pentium, AMD K6, VIA C3.
-  - ultrasparc : Sun UltraSparc I/II/III/IV processor
-  - native : use the build machine's specific processor optimizations
-  - generic : any other processor or no specific optimization. (default)
-
-Alternatively, you may just set the CPU_CFLAGS value to the optimal GCC options
-for your platform.
-
-You may want to build specific target binaries which do not match your native
-compiler's target. This is particularly true on 64-bit systems when you want
-to build a 32-bit binary. Use the ARCH variable for this purpose. Right now
-it only knows about a few x86 variants (i386,i486,i586,i686,x86_64), two
-generic ones (32,64) and sets -m32/-m64 as well as -march=<arch> accordingly.
-
-If your system supports PCRE (Perl Compatible Regular Expressions), then you
-really should build with libpcre which is between 2 and 10 times faster than
-other libc implementations. Regex are used for header processing (deletion,
-rewriting, allow, deny). The only inconvenient of libpcre is that it is not
-yet widely spread, so if you build for other systems, you might get into
-trouble if they don't have the dynamic library. In this situation, you should
-statically link libpcre into haproxy so that it will not be necessary to
-install it on target systems. Available build options for PCRE are :
-
-  - USE_PCRE=1 to use libpcre, in whatever form is available on your system
-    (shared or static)
-
-  - USE_STATIC_PCRE=1 to use a static version of libpcre even if the dynamic
-    one is available. This will enhance portability.
-
-  - with no option, use your OS libc's standard regex implemntation (default).
-    Warning! group references on Solaris seem broken. Use static-pcre whenever
-    possible.
-
-By default, the DEBUG variable is set to '-g' to enable debug symbols. It is
-not wise to disable it on uncommon systems, because it's often the only way to
-get a complete core when you need one. Otherwise, you can set DEBUG to '-s' to
-strip the binary.
-
-For example, I use this to build for Solaris 8 :
-
-    $ make TARGET=solaris CPU=ultrasparc USE_STATIC_PCRE=1
-
-And I build it this way on OpenBSD or FreeBSD :
-
-    $ make -f Makefile.bsd REGEX=pcre DEBUG= COPTS.generic="-Os -fomit-frame-pointer -mgnu"
-
-In order to build a 32-bit binary on an x86_64 Linux system :
-
-    $ make TARGET=linux26 ARCH=i386
-
-If you need to pass other defines, includes, libraries, etc... then please
-check the Makefile to see which ones will be available in your case, and
-use the USE_* variables in the GNU Makefile, or ADDINC, ADDLIB, and DEFINE
-variables in the BSD makefiles.
-
-AIX 5.3 is known to work with the generic target. However, for the binary to
-also run on 5.2 or earlier, you need to build with DEFINE="-D_MSGQSUPPORT",
-otherwise __fd_select() will be used while not being present in the libc.
-
-
-2) How to install it
---------------------
-
-To install haproxy, you can either copy the single resulting binary to the
-place you want, or run :
-
-    $ sudo make install
-
-If you're packaging it for another system, you can specify its root directory
-in the usual DESTDIR variable.
-
-
-3) How to set it up
--------------------
-
-There is some documentation in the doc/ directory :
-
-    - architecture.txt : this is the architecture manual. It is quite old and
-      does not tell about the nice new features, but it's still a good starting
-      point when you know what you want but don't know how to do it.
-
-    - configuration.txt : this is the configuration manual. It recalls a few
-      essential HTTP basic concepts, and details all the configuration file
-      syntax (keywords, units). It also describes the log and stats format. It
-      is normally always up to date. If you see that something is missing from
-      it, please report it as this is a bug.
-
-    - haproxy-en.txt / haproxy-fr.txt : these are the old outdated docs. You
-      should never need them. If you do, then please report what you didn't
-      find in the other ones.
-
-    - gpl.txt / lgpl.txt : the copy of the licenses covering the software. See
-      the 'LICENSE' file at the top for more information.
-
-    - the rest is mainly for developers.
-
-There are also a number of nice configuration examples in the "examples"
-directory as well as on several sites and articles on the net which are linked
-to from the haproxy web site.
-
-
-4) How to report a bug
-----------------------
-
-It is possible that from time to time you'll find a bug. A bug is a case where
-what you see is not what is documented. Otherwise it can be a misdesign. If you
-find that something is stupidly design, please discuss it on the list (see the
-"how to contribute" section below). If you feel like you're proceeding right
-and haproxy doesn't obey, then first ask yourself if it is possible that nobody
-before you has even encountered this issue. If it's unlikely, the you probably
-have an issue in your setup. Just in case of doubt, please consult the mailing
-list archives :
-
-                        http://www.formilux.org/archives/haproxy/
-                        http://marc.info/?l=haproxy
-
-Otherwise, please try to gather the maximum amount of information to help
-reproduce the issue and send that to the mailing list :
-
-                        haproxy@formilux.org
-
-Please include your configuration and logs. You can mask your IP addresses and
-passwords, we don't need them. But it's essential that you post your config if
-you want people to guess what is happening.
-
-Also, keep in mind that haproxy is designed to NEVER CRASH. If you see it die
-without any reason, then it definitely is a critical bug that must be reported
-and urgently fixed. It has happened a couple of times in the past, essentially
-on development versions running on new architectures. If you think your setup
-is fairly common, then it is possible that the issue is totally unrelated.
-Anyway, if that happens, feel free to contact me directly, as I will give you
-instructions on how to collect a usable core file, and will probably ask for
-other captures that you'll not want to share with the list.
-
-
-5) How to contribute
---------------------
-
-It is possible that you'll want to add a specific feature to satisfy your needs
-or one of your customers'. Contributions are welcome, however I'm often very
-picky about changes. I will generally reject patches that change massive parts
-of the code, or that touch the core parts without any good reason if those
-changes have not been discussed first.
-
-The proper place to discuss your changes is the HAProxy Mailing List. There are
-enough skilled readers to catch hazardous mistakes and to suggest improvements.
-I trust a number of them enough to merge a patch if they say it's OK, so using
-the list is the fastest way to get your code reviewed and merged. You can
-subscribe to it by sending an empty e-mail at the following address :
-
-                        haproxy+subscribe@formilux.org
-
-If you have an idea about something to implement, *please* discuss it on the
-list first. It has already happened several times that two persons did the same
-thing simultaneously. This is a waste of time for both of them. It's also very
-common to see some changes rejected because they're done in a way that will
-conflict with future evolutions, or that does not leave a good feeling. It's
-always unpleasant for the person who did the work, and it is unpleasant for me
-too because I value people's time and efforts. That would not happen if these
-were discussed first. There is no problem posting work in progress to the list,
-it happens quite often in fact. Also, don't waste your time with the doc when
-submitting patches for review, only add the doc with the patch you consider
-ready to merge.
-
-If your work is very confidential and you can't publicly discuss it, you can
-also mail me directly about it, but your mail may be waiting several days in
-the queue before you get a response.
-
-If you'd like a feature to be added but you think you don't have the skills to
-implement it yourself, you should follow these steps :
-
-    1. discuss the feature on the mailing list. It is possible that someone
-       else has already implemented it, or that someone will tell you how to
-       proceed without it, or even why not to do it. It is also possible that
-       in fact it's quite easy to implement and people will guide you through
-       the process. That way you'll finally have YOUR patch merged, providing
-       the feature YOU need.
-
-    2. if you really can't code it yourself after discussing it, then you may
-       consider contacting someone to do the job for you. Some people on the
-       list might be OK with trying to do it. Otherwise, you can check the list
-       of contributors at the URL below, some of the regular contributors may
-       be able to do the work, probably not for free but their time is as much
-       valuable as yours after all, you can't eat the cake and have it too.
-
-The list of past and regular contributors is available below. It lists not only
-significant code contributions (features, fixes), but also time or money
-donations :
-
-                        http://haproxy.1wt.eu/contrib.html
-
-Note to contributors: it's very handy when patches comes with a properly
-formated subject. There are 3 criteria of particular importance in any patch :
-
-  - its nature (is it a fix for a bug, a new feature, an optimization, ...)
-  - its importance, which generally reflects the risk of merging/not merging it
-  - what area it applies to (eg: http, stats, startup, config, doc, ...)
-
-It's important to make these 3 criteria easy to spot in the patch's subject,
-because it's the first (and sometimes the only) thing which is read when
-reviewing patches to find which ones need to be backported to older versions.
-
-Specifically, bugs must be clearly easy to spot so that they're never missed.
-Any patch fixing a bug must have the "BUG" tag in its subject. Most common
-patch types include :
-
-  - BUG      fix for a bug. The severity of the bug should also be indicated
-             when known. Similarly, if a backport is needed to older versions,
-             it should be indicated on the last line of the commit message. If
-             the bug has been identified as a regression brought by a specific
-             patch or version, this indication will be appreciated too. New
-             maintenance releases are generally emitted when a few of these
-             patches are merged.
-
-  - CLEANUP  code cleanup, silence of warnings, etc... theorically no impact.
-             These patches will rarely be seen in stable branches, though they
-             may appear when they remove some annoyance or when they make
-             backporting easier. By nature, a cleanup is always minor.
-
-  - REORG    code reorganization. Some blocks may be moved to other places,
-             some important checks might be swapped, etc... These changes
-             always present a risk of regression. For this reason, they should
-             never be mixed with any bug fix nor functional change. Code is
-             only moved as-is. Indicating the risk of breakage is highly
-             recommended.
-
-  - BUILD    updates or fixes for build issues. Changes to makefiles also fall
-             into this category. The risk of breakage should be indicated if
-             known. It is also appreciated to indicate what platforms and/or
-             configurations were tested after the change.
-
-  - OPTIM    some code was optimised. Sometimes if the regression risk is very
-             low and the gains significant, such patches may be merged in the
-             stable branch. Depending on the amount of code changed or replaced
-             and the level of trust the author has in the change, the risk of
-             regression should be indicated.
-
-  - RELEASE  release of a new version (development or stable).
-
-  - LICENSE  licensing updates (may impact distro packagers).
-
-
-When the patch cannot be categorized, it's best not to put any tag. This is
-commonly the case for new features, which development versions are mostly made
-of.
-
-Additionally, the importance of the patch should be indicated when known. A
-single upper-case word is preferred, among :
-
-  - MINOR    minor change, very low risk of impact. It is often the case for
-             code additions that don't touch live code. For a bug, it generally
-             indicates an annoyance, nothing more.
-
-  - MEDIUM   medium risk, may cause unexpected regressions of low importance or
-             which may quickly be discovered. For a bug, it generally indicates
-             something odd which requires changing the configuration in an
-             undesired way to work around the issue.
-
-  - MAJOR    major risk of hidden regression. This happens when I rearrange
-             large parts of code, when I play with timeouts, with variable
-             initializations, etc... We should only exceptionally find such
-             patches in stable branches. For a bug, it indicates severe
-             reliability issues for which workarounds are identified with or
-             without performance impacts.
-
-  - CRITICAL medium-term reliability or security is at risk and workarounds,
-             if they exist, might not always be acceptable. An upgrade is
-             absolutely required. A maintenance release may be emitted even if
-             only one of these bugs are fixed. Note that this tag is only used
-             with bugs. Such patches must indicate what is the first version
-             affected, and if known, the commit ID which introduced the issue.
-
-If this criterion doesn't apply, it's best not to put it. For instance, most
-doc updates and most examples or test files are just added or updated without
-any need to qualify a level of importance.
-
-The area the patch applies to is quite important, because some areas are known
-to be similar in older versions, suggesting a backport might be desirable, and
-conversely, some areas are known to be specific to one version. When the tag is
-used alone, uppercase is preferred for readability, otherwise lowercase is fine
-too. The following tags are suggested but not limitative :
-
- - doc       documentation updates or fixes. No code is affected, no need to
-             upgrade. These patches can also be sent right after a new feature,
-             to document it.
-
- - examples  example files. Be careful, sometimes these files are packaged.
-
- - tests     regression test files. No code is affected, no need to upgrade.
-
- - init      initialization code, arguments parsing, etc...
-
- - config    configuration parser, mostly used when adding new config keywords
-
- - http      the HTTP engine
-
- - stats     the stats reporting engine as well as the stats socket CLI
-
- - checks    the health checks engine (eg: when adding new checks)
-
- - acl       the ACL processing core or some ACLs from other areas
-
- - peers     the peer synchronization engine
-
- - listeners everything related to incoming connection settings
-
- - frontend  everything related to incoming connection processing
-
- - backend   everything related to LB algorithms and server farm
-
- - session   session processing and flags (very sensible, be careful)
-
- - server    server connection management, queueing
-
- - proxy     proxy maintenance (start/stop)
-
- - log       log management
-
- - poll      any of the pollers
-
- - halog     the halog sub-component in the contrib directory
-
- - contrib   any addition to the contrib directory
-
-Other names may be invented when more precise indications are meaningful, for
-instance : "cookie" which indicates cookie processing in the HTTP core. Last,
-indicating the name of the affected file is also a good way to quickly spot
-changes. Many commits were already tagged with "stream_sock" or "cfgparse" for
-instance.
-
-It is desired that AT LEAST one of the 3 criteria tags is reported in the patch
-subject. Ideally, we would have the 3 most often. The two first criteria should
-be present before a first colon (':'). If both are present, then they should be
-delimited with a slash ('/'). The 3rd criterion (area) should appear next, also
-followed by a colon. Thus, all of the following messages are valid :
-
-Examples of messages :
-  - DOC: document options forwardfor to logasap
-  - DOC/MAJOR: reorganize the whole document and change indenting
-  - BUG: stats: connection reset counters must be plain ascii, not HTML
-  - BUG/MINOR: stats: connection reset counters must be plain ascii, not HTML
-  - MEDIUM: checks: support multi-packet health check responses
-  - RELEASE: Released version 1.4.2
-  - BUILD: stats: stdint is not present on solaris
-  - OPTIM/MINOR: halog: make fgets parse more bytes by blocks
-  - REORG/MEDIUM: move syscall redefinition to specific places
-
-Please do not use square brackets anymore around the tags, because they give me
-more work when merging patches. By default I'm asking Git to keep them but this
-causes trouble when patches are prefixed with the [PATCH] tag because in order
-not to store it, I have to hand-edit the patches. So as of now, I will ask Git
-to remove whatever is located between square brackets, which implies that any
-subject formatted the old way will have its tag stripped out.
-
-In fact, one of the only square bracket tags that still makes sense is '[RFC]'
-at the beginning of the subject, when you're asking for someone to review your
-change before getting it merged. If the patch is OK to be merged, then I can
-merge it as-is and the '[RFC]' tag will automatically be removed. If you don't
-want it to be merged at all, you can simply state it in the message, or use an
-alternate '[WIP]' tag ("work in progress").
-
-The tags are not rigid, follow your intuition first, anyway I reserve the right
-to change them when merging the patch. It may happen that a same patch has a
-different tag in two distinct branches. The reason is that a bug in one branch
-may just be a cleanup in the other one because the code cannot be triggered.
-
-
-For a more efficient interaction between the mainline code and your code, I can
-only strongly encourage you to try the Git version control system :
-
-                        http://git-scm.com/
-
-It's very fast, lightweight and lets you undo/redo your work as often as you
-want, without making your mistakes visible to the rest of the world. It will
-definitely help you contribute quality code and take other people's feedback
-in consideration. In order to clone the HAProxy Git repository :
-
-    $ git clone http://git.1wt.eu/git/haproxy-1.4.git    (stable 1.4)
-    $ git clone http://git.1wt.eu/git/haproxy.git/       (development)
-
-If you decide to use Git for your developments, then your commit messages will
-have the subject line in the format described above, then the whole description
-of your work (mainly why you did it) will be in the body. You can directly send
-your commits to the mailing list, the format is convenient to read and process.
-
--- end
diff --git a/deps/haproxy-1.4.21/ROADMAP b/deps/haproxy-1.4.21/ROADMAP
deleted file mode 100644
index f5c638f..0000000
--- a/deps/haproxy-1.4.21/ROADMAP
+++ /dev/null
@@ -1,112 +0,0 @@
-'+' = done, '-' = todo, '*' = done except doc
-
-1.2.12 :
- + weighted RR/SH
-
-1.2.13 :
- + maxconn
- + queueing
-
-1.2.14 :
- + HTML status page
-
-        stats enable
-        stats uri /?stats  
-        stats realm w.ods.org\ statistics
-        stats auth user1:pass1
-        stats auth user2:pass2
-        stats auth user3:pass3
-        stats scope <px_id> | '.'
-
- + allow server-less proxies (for stats)
-
- - separate timeout controls
-
- + option 'abortonclose' : if the session is queued or being connecting
-   to the server, and the client sends a shutdown(), then decide to abort
-   the session early because in most situations, this will be caused by
-   a client hitting the 'Stop' button, so there's no reason to overload
-   the servers with unservable requests. However, this is not HTTP compliant
-   and might cause little trouble to some very specific clients used to
-   close immediately after sending the request (no support for KA, which ones?)
-
- + minconn : makes the server's maxconn dynamic, which will be computed as a
-   ratio of the proxy's sessions :
-     srv->effective_maxconn =
-          max(srv->maxconn * px->nbsess / px->maxconn, srv->minconn)
-
-1.2.15 :
- + monitor-uri : specify an URI for which we will always return 'HTTP/1.0 200'
-   and never forward nor log it.
-
- + option ssl-hello-chk : send SSLv3 client hello messages to check the servers
-
-1.3 :
- - remove unused STATTIME
-
- - reference all the include files that must be created, possibly under subdirs :
-
-   - acl.h      => more general ACL work
-   - appcook.h  => appsession-related cookies
-   - backend.h  => back-end part of the PR_O_* + backend definitions
-   - buffers.h  => buffer management relying on memory.h
-   - capture.h  => header and cookie capture
-   - cfgparse.h => configuration parser
-   - checks.h   => health checks
-   - clireq.h   => the client side "request" part of the current sessions.
-   - compat.h   => compatibility with other OSes (TCP_NODELAY, ...)
-   - config.h   => config parameters, renamed CONFIG_HAP_*, includes defaults.h
-   - controls.h => SN_CACHEABLE, ...
-   - cookies.h  => definitions related to cookie management + SN_SCK_*
-   - defaults.h => many default values, might disappear soon after cleanup
-   - frontend.h => front-end part of the PR_O_* + client definitions + listeners
-   - global.h   => shared global variables
-   - http.h     => HTTP state definitions and transitions
-   - httperr.{hc} => HTTP return codes
-   - libtask.h  => task scheduler
-   - libtime.h  => time-related definitions
-   - loadbal.h  => load balancing algorithms
-   - log.h      => log definitions
-   - memory.h   => pools
-   - polling.h  => definitions of select(), poll(), INTBITS, ...
-   - queue.h    => queue management
-   - regex.h    => filtering
-   - servers.h  => servers definitions (SRV_*, states, ...)
-   - fd.h       => FD_ST* (add FD_DGRAM), RES_*, socket states, etc...
-   - srvreq.h   => the server side "request" part of the current sessions.
-   - standard.h => general purpose macros and defines (eg: MIN/MAX, ...)
-   - startup.h  => MODE_*
-   - tuning.h   => platform-specific tuning parameters
-
-
- - clarify licence by adding a 'MODULE_LICENCE("GPL")' or something equivalent.
-
- - handle half-closed connections better (cli/srv would not distinguish
-   DATA/SHUTR/SHUTW, it would be a session flag which would tell shutr/shutw).
-   Check how it got changed in httpterm.
-
- - 3 memory models : failsafe (prealloc), normal (current), optimal (alloc on
-   demand)
-
- - wait queues replaced for priority-based trees
-
- - ability to assign a prio based on L7 matching
-
- - prio-based O(1) scheduler
-
- - maxconn reserve for VIP/admins
-
- - verify if it would be worth implementing an epoll_ctl_batch() for Linux
-
- - balance LC/WLC (patch available)
-
- - option minservers XXX : activates some backup servers when active servers
-   are insufficient
-
- - monitor minservers XXX : monitor-net and monitor-uri could report a failure
-   when the number of active servers is below this threshold.
-
- - option smtp-chk : use SMTP health checks (avoid logs if possible)
-
- - new keyword 'check' : check http xxx, check smtp xxx, check ssl-hello
-
diff --git a/deps/haproxy-1.4.21/SUBVERS b/deps/haproxy-1.4.21/SUBVERS
deleted file mode 100644
index 8b13789..0000000
--- a/deps/haproxy-1.4.21/SUBVERS
+++ /dev/null
@@ -1 +0,0 @@
-
diff --git a/deps/haproxy-1.4.21/TODO b/deps/haproxy-1.4.21/TODO
deleted file mode 100644
index 74b3cce..0000000
--- a/deps/haproxy-1.4.21/TODO
+++ /dev/null
@@ -1,181 +0,0 @@
-* x-forwarded-for
-* implmenter l'option "log global" au niveau proxy pour utiliser les logs
-  globaux.
-* matching case-insensitive
-* implmenter outgoing addr
-* loguer t_cnx, t_data, t_total
-+ factoriser la fonction de log (send_log = send_syslog+warning+alert)
-+ dsactivation du keep-alive (suppression des ^Connection: et ajout des Connection: close)
-  -> 4 lignes (2 del, 2 add) suffisent.
-+ ne pas loguer certaines adresses IP sources
-  -> pour les health-checks uniquement -> pas de log pour les requtes
-     vides (option dontlognull)
-- mesurer le tps consomm entre deux select, et fournir la conso CPU :
-  %cpu = 100 * (tpreselect(n+1)-tpostselect(n)) / (tpreselect(n+1)-tpreselect(n))
-* implmenter limitation fd dans la conf : setrlimit(RLIMIT_NOFILE, ...)
-- implmenter core/no-core dans la conf : setrlimit(RLIMIT_CORE, ...)
-- optimiser les regex pour acclrer les matches :
-  - compter les matches
-  - si match(n) & ([n].cpt > [n-1].cpt) & ([n].action == [n-1].action), swap(n,n-1)
-  - rgulirement, diviser tous les compteurs (lors d'un dpassement par exemple)
-- filtrage sur l'adresse IP source, et stocker le pointeur sur la dernire regex
-  matche dans la "session" pour acclrer les regex.
-- gestion keep-alive
-
-+ handle parametrable HTTP health-checks replies
-- differentiate http headers and http uris
-- support environment variables in config file
-- support keep-alive
-- support SSL
-
-===================== demandes ==========================
-ok> 1) coute sur une plage de ports :
-ok>   listen XXX 1.2.3.4:21000-21060
-ok> 
-ok> 2) coutes multiples :
-ok>   listen XXX 1.2.3.4:21000
-ok>   bind 2.3.4.5:21001
-ok>   bind 2.3.4.5:21000-21060
-ok> 
-ok> => on en arrive  ceci :
-ok> 
-ok> listen XXX [ address:port ]
-ok>    bind addr:plage-port[,[addr:]plage-port]*
-ok>    bind ...
-ok>    ...
-ok> 
-ok>    => proxy->listen_fd et proxy->listen_addr doivent tre
-ok> 	  mis dans des listes
-ok>    => OK pour listen, implmenter le BIND.
-ok> 
-ok> 3) reconnexion sur le mme port sur le serveur :
-ok> 
-ok>    server XXX 1.2.3.4[:port]
-ok>    si <port> n'est pas spcifi, on utilise le mme port que celui qui a reu
-ok>    la connexion. Dans ce cas, il faut pouvoir forcer le port du health-check
-ok>    par un nouveau parametre "port".
-ok> 
-ok> => a permet les forwardings de plages :
-ok> 
-ok> listen XXX
-ok>    bind 1.2.3.4:10000-11000
-ok>    server 1.2.3.5
-ok> 
-4) paramtres par dfaut :
-   crer une section "defaults" qui prcise les paramtres par dfaut pour les
-   sections suivantes, concernant les paramtres suivants :
-     ok- les logs
-     ok- les modes (tcp/http)
-     ok- le balancing (round-robin/source)
-     ok- les time-outs
-     ok- maxconn
-     ok- redisp
-     ok- les options
-     ok- le retry
-     ok- les checks
-     ok- les cookies/captures
-       - les options des serveurs ?
-       - les filtres et regex ?
-
-*  implmenter "balance source" pour faire un hash sur la source.
-   permettre de spcifier un masque sur lequel s'applique le hachage,
-   ainsi qu'une option pour hacher en fonction de l'adresse dans le
-   champ "x-forwarded-for". Problme pour le support des pannes: ce
-   type de hash est utile l o la persistence par cookie ne peut pas
-   s'appliquer, donc comment faire pour assurer un maximum de persistence
-   en cas de panne ?
-
-6) possibilit d'un process spar par listen :
-   listen XXX
-      fork [ group_id ]
-
-   le fait de spcifier group_id fera que toutes les instances utilisant le
-   mme identifiant de groupe seront gres par un mme processus.
-
-   -> plus souple et plus comprhensible de faire des sections par processus,
-      ce qui rsoud galement le cas ci-dessous. Ex:
-   process_group X
-      nbproc X
-      uid X
-      chroot X
-      listen ...
-
-7) grer un chroot/uid/gid diffrents par process :
-   listen XXX
-      chroot /truc
-      uid 123
-      gid 456
-
-8) beaucoup de paramtres pourraient tre spcifiques aux serveurs et non
-   aux instances. Exemples :
-   * adresse IP source pour atteindre le serveur
-   - mthode de health-check (proto, ...)
-   * mthode de health-check (port)
-   - poids
-   - alerte en cas de disparition
-   - le nombre max de sessions  lui envoyer
-
-ok> 9) ajouter des paramtres optionnels  l'option "httpchk" permettant
-ok>    de forcer la mthode, la version HTTP et des headers.
-ok>    ex: option httpchk        -> OPTIONS / HTTP/1.0
-ok> 	   option httpchk /test  -> OPTIONS /test HTTP/1.0
-ok> 	   option httpchk HEAD / HTTP/1.0\nHost:\ www   -> tel quel
-
-Todo for 1.1
-============
-* "no more server" alert
-* config check
-- anti-flapping
-
-Todo for 1.2
-============
-- direct <server> <regex> <match>
-- new config syntax allowing braces to be able to shorten lines
-- insert/learn/check/log unique request ID, and add the ability
-  to block bad responses.
-- IPv6 :
-* listen [ip4.ip4.ip4.ip4]:port[-port]
-* listen [ip6::...ip6]/port[-port]
-- server xxx ipv4 | ipv4: | ipv4:port[-port] | ipv6/ | ipv6/port[-port]
-* appcookie
-* weighted round robin
-- option to shutdown(listen_sock) when max connections reached
-* epoll
-- replace the event scheduler with an O(log(N)) one. The timer queue will
-  need a tree with a known end (to speed up queueing of latest events), and
-  no entry for eternity.
-- refine memory management so that the request buffer is only allocated in
-  cli_read() and response buffer during srv_read(). This would protect against
-  attacks with thousands connections : 20000 connections consume 340 MB RSS and
-  1.3 GB VSZ on Linux. Data should be in a separate buffer to prevent any
-  activity on the buffer's pointers from touching the buffer page itself.
-- make buffer size configurable in global options
-* monitor number of simultaneous sessions in logs (per srv/inst/global)
-* ignore leading empty lines in HTTP requests
-+ limit the per-server number of sessions and queue incoming connections
-  => still needs refinement (actions at servers UP/DOWN, timeouts)
-- new 'timeout' keyword to set all timeouts (including the queue)
-- ability to intercept an URI to report statistics
-- ability to intercept an URI to return 404
-- embedded error pages loaded in memory at startup time (eg: for expired time
-  in connection queue)
-
-
-TODO for 1.3
-============
-  - check all copyrights
-  - fix Makefile.bsd
-  - separate inline functions to put them in files covered by GPL
-  - implement HTTP status 414 - request URI too long
-  - implement 'use_filters <proxy>' and 'use_backend <proxy>'
-  - fix the logs. The logs might be defined from the frontend and
-    augmented depending on the backends' options. Another solution
-    would be to support a 'log' type entity just like the frontend,
-    filters and backend, on which every entity could rely.
-  - implement 'on uri <uri> <proxy>', 'on host <host> <proxy>'
-  - remove the first now useless hop in hdr_idx
-  - balance on URI hash (specify length or depth)
-  - balance on any header hash (eg: host)
-  - balance with redirections to real servers
-  - multi-site LB with weighted redirections to the remote one
-
diff --git a/deps/haproxy-1.4.21/VERDATE b/deps/haproxy-1.4.21/VERDATE
deleted file mode 100644
index 0b3225b..0000000
--- a/deps/haproxy-1.4.21/VERDATE
+++ /dev/null
@@ -1 +0,0 @@
-2012/05/21
diff --git a/deps/haproxy-1.4.21/VERSION b/deps/haproxy-1.4.21/VERSION
deleted file mode 100644
index 8cc8fe0..0000000
--- a/deps/haproxy-1.4.21/VERSION
+++ /dev/null
@@ -1 +0,0 @@
-1.4.21
diff --git a/deps/haproxy-1.4.21/contrib/base64/base64rev-gen.c b/deps/haproxy-1.4.21/contrib/base64/base64rev-gen.c
deleted file mode 100644
index faffc87..0000000
--- a/deps/haproxy-1.4.21/contrib/base64/base64rev-gen.c
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * base64rev generator
- *
- * Copyright 2009-2010 Krzysztof Piotr Oledzki <ole@ans.pl>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <stdio.h>
-
-const char base64tab[65]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
-char base64rev[128];
-
-#define base '#'	/* arbitrary chosen base value */
-#define B64MAX	64
-#define B64PADV B64MAX
-
-int main() {
-	char *p, c;
-	int i, min = 255, max = 0;
-
-	for (i = 0; i < sizeof(base64rev); i++)
-		base64rev[i] = base;
-
-	for (i = 0;  i < B64MAX; i++) {
-		c = base64tab[i];
-
-		if (min > c)
-			min = c;
-
-		if (max < c)
-			max = c;
-	}
-
-	for (i = 0;  i < B64MAX; i++) {
-		c = base64tab[i];
-
-		if (base+i+1 > 127) {
-			printf("Wrong base value @%d\n", i);
-			return 1;
-		}
-
-		base64rev[c - min] = base+i+1;
-	}
-
-	base64rev['=' - min] = base + B64PADV;
-
-	base64rev[max - min + 1] = '\0';
-
-	printf("#define B64BASE '%c'\n", base);
-	printf("#define B64CMIN '%c'\n", min);
-	printf("#define B64CMAX '%c'\n", max);
-	printf("#define B64PADV %u\n", B64PADV);
-
-	p = base64rev;
-	printf("const char base64rev[]=\"");
-	for (p = base64rev; *p; p++) {
-		if (*p == '\\')
-			printf("\\%c", *p);
-		else
-			printf("%c", *p);
-	}
-	printf("\"\n");
-
-	return 0;
-}
diff --git a/deps/haproxy-1.4.21/contrib/halog/Makefile b/deps/haproxy-1.4.21/contrib/halog/Makefile
deleted file mode 100644
index c488470..0000000
--- a/deps/haproxy-1.4.21/contrib/halog/Makefile
+++ /dev/null
@@ -1,16 +0,0 @@
-EBTREE_DIR = ../../ebtree
-INCLUDE  = -I../../include -I$(EBTREE_DIR)
-
-CC       = gcc
-OPTIMIZE = -O3
-
-OBJS     = halog halog64
-
-halog: halog.c fgets2.c
-	$(CC) $(OPTIMIZE) -o $@ $(INCLUDE) $(EBTREE_DIR)/ebtree.c $(EBTREE_DIR)/eb32tree.c $(EBTREE_DIR)/eb64tree.c $(EBTREE_DIR)/ebmbtree.c $(EBTREE_DIR)/ebsttree.c $(EBTREE_DIR)/ebistree.c $(EBTREE_DIR)/ebimtree.c $^
-
-halog64: halog.c fgets2-64.c
-	$(CC) $(OPTIMIZE) -o $@ $(INCLUDE) $(EBTREE_DIR)/ebtree.c $(EBTREE_DIR)/eb32tree.c $(EBTREE_DIR)/eb64tree.c $(EBTREE_DIR)/ebmbtree.c $(EBTREE_DIR)/ebsttree.c $(EBTREE_DIR)/ebistree.c $(EBTREE_DIR)/ebimtree.c $^
-
-clean:
-	rm -f $(OBJS)
diff --git a/deps/haproxy-1.4.21/contrib/halog/fgets2-64.c b/deps/haproxy-1.4.21/contrib/halog/fgets2-64.c
deleted file mode 100644
index 1be6f22..0000000
--- a/deps/haproxy-1.4.21/contrib/halog/fgets2-64.c
+++ /dev/null
@@ -1,175 +0,0 @@
-/*
- * fast fgets() replacement for log parsing
- *
- * Copyright 2000-2009 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- * This function manages its own buffer and returns a pointer to that buffer
- * in order to avoid expensive memory copies. It also checks for line breaks
- * 32 bits at a time. It could be improved a lot using mmap() but we would
- * not be allowed to replace trailing \n with zeroes and we would be limited
- * to small log files on 32-bit machines.
- *
- */
-
-#include <stdlib.h>
-#include <string.h>
-#include <stdio.h>
-#include <unistd.h>
-
-// return non-zero if the integer contains at least one zero byte
-static inline unsigned int has_zero(unsigned int x)
-{
-	unsigned int y;
-
-	/* Principle: we want to perform 4 tests on one 32-bit int at once. For
-	 * this, we have to simulate an SIMD instruction which we don't have by
-	 * default. The principle is that a zero byte is the only one which
-	 * will cause a 1 to appear on the upper bit of a byte/word/etc... when
-	 * we subtract 1. So we can detect a zero byte if a one appears at any
-	 * of the bits 7, 15, 23 or 31 where it was not. It takes only one
-	 * instruction to test for the presence of any of these bits, but it is
-	 * still complex to check for their initial absence. Thus, we'll
-	 * proceed differently : we first save and clear only those bits, then
-	 * we check in the final result if one of them is present and was not.
-	 */
-	y = x;
-        y -= 0x01010101;    /* generate a carry */
-        y &= ~x;             /* clear the bits that were already set */
-        return y & 0x80808080;
-}
-
-
-// return non-zero if the argument contains at least one zero byte. See principle above.
-static inline unsigned long long has_zero64(unsigned long long x)
-{
-	unsigned long long y;
-
-	y = x;
-	y -= 0x0101010101010101ULL;     /* generate a carry */
-	y &= ~x;                        /* clear the bits that were already set */
-	return y & 0x8080808080808080ULL;
-}
-
-#define FGETS2_BUFSIZE		(256*1024)
-const char *fgets2(FILE *stream)
-{
-	static char buffer[FGETS2_BUFSIZE + 68];
-	static char *end = buffer;
-	static char *line = buffer;
-
-	char *next;
-	int ret;
-
-	next = line;
-
-	while (1) {
-		/* this is a speed-up, we read 64 bits at once and check for an
-		 * LF character there. We stop if found then continue one at a
-		 * time.
-		 */
-
-		if (next <= end) {
-			/* max 3 bytes tested here */
-			while ((((unsigned long)next) & 3) && *next != '\n')
-				next++;
-
-			/* maybe we have can skip 4 more bytes */
-			if ((((unsigned long)next) & 4) && !has_zero(*(unsigned int *)next ^ 0x0A0A0A0AU))
-				next += 4;
-		}
-
-		/* now next is multiple of 8 or equal to end */
-		while (next <= (end-68)) {
-			if (has_zero64(*(unsigned long long *)next ^ 0x0A0A0A0A0A0A0A0AULL))
-				break;
-			next += 8;
-			if (has_zero64(*(unsigned long long *)next ^ 0x0A0A0A0A0A0A0A0AULL))
-				break;
-			next += 8;
-			if (has_zero64(*(unsigned long long *)next ^ 0x0A0A0A0A0A0A0A0AULL))
-				break;
-			next += 8;
-			if (has_zero64(*(unsigned long long *)next ^ 0x0A0A0A0A0A0A0A0AULL))
-				break;
-			next += 8;
-			if (has_zero64(*(unsigned long long *)next ^ 0x0A0A0A0A0A0A0A0AULL))
-				break;
-			next += 8;
-			if (has_zero64(*(unsigned long long *)next ^ 0x0A0A0A0A0A0A0A0AULL))
-				break;
-			next += 8;
-			if (has_zero64(*(unsigned long long *)next ^ 0x0A0A0A0A0A0A0A0AULL))
-				break;
-			next += 8;
-			if (has_zero64(*(unsigned long long *)next ^ 0x0A0A0A0A0A0A0A0AULL))
-				break;
-			next += 8;
-		}
-
-		/* maybe we can skip 4 more bytes */
-		if (!has_zero(*(unsigned int *)next ^ 0x0A0A0A0AU))
-			next += 4;
-
-		/* We finish if needed : if <next> is below <end>, it means we
-		 * found an LF in one of the 4 following bytes.
-		 */
-		while (next < end) {
-			if (*next == '\n') {
-				const char *start = line;
-
-				*next = '\0';
-				line = next + 1;
-				return start;
-			}
-			next++;
-		}
-
-		/* we found an incomplete line. First, let's move the
-		 * remaining part of the buffer to the beginning, then
-		 * try to complete the buffer with a new read. We can't
-		 * rely on <next> anymore because it went past <end>.
-		 */
-		if (line > buffer) {
-			if (end != line)
-				memmove(buffer, line, end - line);
-			end = buffer + (end - line);
-			next = end;
-			line = buffer;
-		} else {
-			if (end == buffer + FGETS2_BUFSIZE)
-				return NULL;
-		}
-
-		ret = read(fileno(stream), end, buffer + FGETS2_BUFSIZE - end);
-
-		if (ret <= 0) {
-			if (end == line)
-				return NULL;
-
-			*end = '\0';
-			end = line; /* ensure we stop next time */
-			return line;
-		}
-
-		end += ret;
-		*end = '\n'; /* make parser stop ASAP */
-		/* search for '\n' again */
-	}
-}
-
-#ifdef BENCHMARK
-int main() {
-	const char *p;
-	unsigned int lines = 0;
-
-	while ((p=fgets2(stdin)))
-		lines++;
-	printf("lines=%d\n", lines);
-	return 0;
-}
-#endif
diff --git a/deps/haproxy-1.4.21/contrib/halog/fgets2.c b/deps/haproxy-1.4.21/contrib/halog/fgets2.c
deleted file mode 100644
index 1fd19d7..0000000
--- a/deps/haproxy-1.4.21/contrib/halog/fgets2.c
+++ /dev/null
@@ -1,154 +0,0 @@
-/*
- * fast fgets() replacement for log parsing
- *
- * Copyright 2000-2009 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- * This function manages its own buffer and returns a pointer to that buffer
- * in order to avoid expensive memory copies. It also checks for line breaks
- * 32 bits at a time. It could be improved a lot using mmap() but we would
- * not be allowed to replace trailing \n with zeroes and we would be limited
- * to small log files on 32-bit machines.
- *
- */
-
-#include <stdlib.h>
-#include <string.h>
-#include <stdio.h>
-#include <unistd.h>
-
-// return non-zero if the integer contains at least one zero byte
-static inline unsigned int has_zero(unsigned int x)
-{
-	unsigned int y;
-
-	/* Principle: we want to perform 4 tests on one 32-bit int at once. For
-	 * this, we have to simulate an SIMD instruction which we don't have by
-	 * default. The principle is that a zero byte is the only one which
-	 * will cause a 1 to appear on the upper bit of a byte/word/etc... when
-	 * we subtract 1. So we can detect a zero byte if a one appears at any
-	 * of the bits 7, 15, 23 or 31 where it was not. It takes only one
-	 * instruction to test for the presence of any of these bits, but it is
-	 * still complex to check for their initial absence. Thus, we'll
-	 * proceed differently : we first save and clear only those bits, then
-	 * we check in the final result if one of them is present and was not.
-	 */
-	y = x;
-	y -= 0x01010101;     /* generate a carry */
-	y &= ~x;             /* clear the bits that were already set */
-	return y & 0x80808080;
-}
-
-
-#define FGETS2_BUFSIZE		(256*1024)
-const char *fgets2(FILE *stream)
-{
-	static char buffer[FGETS2_BUFSIZE + 32];
-	static char *end = buffer;
-	static char *line = buffer;
-
-	char *next;
-	int ret;
-
-	next = line;
-
-	while (1) {
-		/* this is a speed-up, we read 32 bits at once and check for an
-		 * LF character there. We stop if found then continue one at a
-		 * time.
-		 */
-		while (next < end && (((unsigned long)next) & 3) && *next != '\n')
-			next++;
-
-		/* Now next is multiple of 4 or equal to end. We know we can safely
-		 * read up to 32 bytes past end if needed because they're allocated.
-		 */
-		while (next < end) {
-			if (has_zero(*(unsigned int *)next ^ 0x0A0A0A0A))
-				break;
-			next += 4;
-			if (has_zero(*(unsigned int *)next ^ 0x0A0A0A0A))
-				break;
-			next += 4;
-			if (has_zero(*(unsigned int *)next ^ 0x0A0A0A0A))
-				break;
-			next += 4;
-			if (has_zero(*(unsigned int *)next ^ 0x0A0A0A0A))
-				break;
-			next += 4;
-			if (has_zero(*(unsigned int *)next ^ 0x0A0A0A0A))
-				break;
-			next += 4;
-			if (has_zero(*(unsigned int *)next ^ 0x0A0A0A0A))
-				break;
-			next += 4;
-			if (has_zero(*(unsigned int *)next ^ 0x0A0A0A0A))
-				break;
-			next += 4;
-			if (has_zero(*(unsigned int *)next ^ 0x0A0A0A0A))
-				break;
-			next += 4;
-		}
-
-		/* We finish if needed : if <next> is below <end>, it means we
-		 * found an LF in one of the 4 following bytes.
-		 */
-		while (next < end) {
-			if (*next == '\n') {
-				const char *start = line;
-
-				*next = '\0';
-				line = next + 1;
-				return start;
-			}
-			next++;
-		}
-
-		/* we found an incomplete line. First, let's move the
-		 * remaining part of the buffer to the beginning, then
-		 * try to complete the buffer with a new read. We can't
-		 * rely on <next> anymore because it went past <end>.
-		 */
-		if (line > buffer) {
-			if (end != line)
-				memmove(buffer, line, end - line);
-			end = buffer + (end - line);
-			next = end;
-			line = buffer;
-		} else {
-			if (end == buffer + FGETS2_BUFSIZE)
-				return NULL;
-		}
-
-		ret = read(fileno(stream), end, buffer + FGETS2_BUFSIZE - end);
-
-		if (ret <= 0) {
-			if (end == line)
-				return NULL;
-
-			*end = '\0';
-			end = line; /* ensure we stop next time */
-			return line;
-		}
-
-		end += ret;
-		*end = '\n';  /* make parser stop ASAP */
-		/* search for '\n' again */
-	}
-}
-
-#ifdef BENCHMARK
-int main() {
-	const char *p;
-	unsigned int lines = 0;
-
-	while ((p=fgets2(stdin)))
-		lines++;
-	printf("lines=%d\n", lines);
-	return 0;
-}
-#endif
diff --git a/deps/haproxy-1.4.21/contrib/halog/halog.c b/deps/haproxy-1.4.21/contrib/halog/halog.c
deleted file mode 100644
index 7048ae2..0000000
--- a/deps/haproxy-1.4.21/contrib/halog/halog.c
+++ /dev/null
@@ -1,1417 +0,0 @@
-/*
- * haproxy log statistics reporter
- *
- * Copyright 2000-2010 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <errno.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <syslog.h>
-#include <string.h>
-#include <unistd.h>
-#include <ctype.h>
-
-#include <eb32tree.h>
-#include <eb64tree.h>
-#include <ebistree.h>
-#include <ebsttree.h>
-
-#define SOURCE_FIELD 5
-#define ACCEPT_FIELD 6
-#define SERVER_FIELD 8
-#define TIME_FIELD 9
-#define STATUS_FIELD 10
-#define TERM_CODES_FIELD 14
-#define CONN_FIELD 15
-#define QUEUE_LEN_FIELD 16
-#define METH_FIELD 17
-#define URL_FIELD 18
-#define MAXLINE 16384
-#define QBITS 4
-
-#define SEP(c) ((unsigned char)(c) <= ' ')
-#define SKIP_CHAR(p,c) do { while (1) { int __c = (unsigned char)*p++; if (__c == c) break; if (__c <= ' ') { p--; break; } } } while (0)
-
-/* [0] = err/date, [1] = req, [2] = conn, [3] = resp, [4] = data */
-static struct eb_root timers[5] = {
-	EB_ROOT_UNIQUE, EB_ROOT_UNIQUE, EB_ROOT_UNIQUE,
-	EB_ROOT_UNIQUE, EB_ROOT_UNIQUE,
-};
-
-struct timer {
-	struct eb32_node node;
-	unsigned int count;
-};
-
-struct srv_st {
-	unsigned int st_cnt[6]; /* 0xx to 5xx */
-	unsigned int nb_ct, nb_rt, nb_ok;
-	unsigned long long cum_ct, cum_rt;
-	struct ebmb_node node;
-	/* don't put anything else here, the server name will be there */
-};
-
-struct url_stat {
-	union {
-		struct ebpt_node url;
-		struct eb64_node val;
-	} node;
-	char *url;
-	unsigned long long total_time;    /* sum(all reqs' times) */
-	unsigned long long total_time_ok; /* sum(all OK reqs' times) */
-	unsigned int nb_err, nb_req;
-};
-
-#define FILT_COUNT_ONLY		0x01
-#define FILT_INVERT		0x02
-#define FILT_QUIET		0x04
-#define FILT_ERRORS_ONLY	0x08
-#define FILT_ACC_DELAY		0x10
-#define FILT_ACC_COUNT		0x20
-#define FILT_GRAPH_TIMERS	0x40
-#define FILT_PERCENTILE		0x80
-#define FILT_TIME_RESP         0x100
-
-#define FILT_INVERT_ERRORS     0x200
-#define FILT_INVERT_TIME_RESP  0x400
-
-#define FILT_COUNT_STATUS      0x800
-#define FILT_COUNT_SRV_STATUS 0x1000
-#define FILT_COUNT_TERM_CODES 0x2000
-
-#define FILT_COUNT_URL_ONLY  0x004000
-#define FILT_COUNT_URL_COUNT 0x008000
-#define FILT_COUNT_URL_ERR   0x010000
-#define FILT_COUNT_URL_TTOT  0x020000
-#define FILT_COUNT_URL_TAVG  0x040000
-#define FILT_COUNT_URL_TTOTO 0x080000
-#define FILT_COUNT_URL_TAVGO 0x100000
-#define FILT_COUNT_URL_ANY   (FILT_COUNT_URL_ONLY|FILT_COUNT_URL_COUNT|FILT_COUNT_URL_ERR| \
-			      FILT_COUNT_URL_TTOT|FILT_COUNT_URL_TAVG|FILT_COUNT_URL_TTOTO|FILT_COUNT_URL_TAVGO)
-
-#define FILT_HTTP_ONLY       0x200000
-#define FILT_TERM_CODE_NAME  0x400000
-#define FILT_INVERT_TERM_CODE_NAME 0x800000
-
-#define FILT_HTTP_STATUS           0x1000000
-#define FILT_INVERT_HTTP_STATUS    0x2000000
-#define FILT_QUEUE_ONLY            0x4000000
-#define FILT_QUEUE_SRV_ONLY        0x8000000
-
-unsigned int filter = 0;
-unsigned int filter_invert = 0;
-const char *line;
-int linenum = 0;
-int parse_err = 0;
-int lines_out = 0;
-
-const char *fgets2(FILE *stream);
-
-void filter_count_url(const char *accept_field, const char *time_field, struct timer **tptr);
-void filter_count_srv_status(const char *accept_field, const char *time_field, struct timer **tptr);
-void filter_count_term_codes(const char *accept_field, const char *time_field, struct timer **tptr);
-void filter_count_status(const char *accept_field, const char *time_field, struct timer **tptr);
-void filter_graphs(const char *accept_field, const char *time_field, struct timer **tptr);
-void filter_output_line(const char *accept_field, const char *time_field, struct timer **tptr);
-void filter_accept_holes(const char *accept_field, const char *time_field, struct timer **tptr);
-
-void usage(FILE *output, const char *msg)
-{
-	fprintf(output,
-		"%s"
-		"Usage: halog [-h|--help] for long help\n"
-		"       halog [-q] [-c] [-v] {-gt|-pct|-st|-tc|-srv|-u|-uc|-ue|-ua|-ut|-uao|-uto}\n"
-		"       [-s <skip>] [-e|-E] [-H] [-rt|-RT <time>] [-ad <delay>] [-ac <count>]\n"
-		"       [-Q|-QS] [-tcn|-TCN <termcode>] [ -hs|-HS [min][:[max]] ] < log\n"
-		"\n",
-		msg ? msg : ""
-		);
-}
-
-void die(const char *msg)
-{
-	usage(stderr, msg);
-	exit(1);
-}
-
-void help()
-{
-	usage(stdout, NULL);
-	printf(
-	       "Input filters (several filters may be combined) :\n"
-	       " -H                      only match lines containing HTTP logs (ignore TCP)\n"
-	       " -E                      only match lines without any error (no 5xx status)\n"
-	       " -e                      only match lines with errors (status 5xx or negative)\n"
-	       " -rt|-RT <time>          only match response times larger|smaller than <time>\n"
-	       " -Q|-QS                  only match queued requests (any queue|server queue)\n"
-	       " -tcn|-TCN <code>        only match requests with/without termination code <code>\n"
-	       " -hs|-HS <[min][:][max]> only match requests with HTTP status codes within/not\n"
-	       "                         within min..max. Any of them may be omitted. Exact\n"
-	       "                         code is checked for if no ':' is specified.\n"
-	       "Modifiers\n"
-	       " -v                      invert the input filtering condition\n"
-	       " -q                      don't report errors/warnings\n"
-	       "\n"
-	       "Output filters - only one may be used at a time\n"
-	       " -c    only report the number of lines that would have been printed\n"
-	       " -pct  output connect and response times percentiles\n"
-	       " -st   output number of requests per HTTP status code\n"
-	       " -tc   output number of requests per termination code (2 chars)\n"
-	       " -srv  output statistics per server (time, requests, errors)\n"
-	       " -u*   output statistics per URL (time, requests, errors)\n"
-	       "       Additional characters indicate the output sorting key :\n"
-	       "       -u : by URL, -uc : request count, -ue : error count\n"
-	       "       -ua : average response time, -uto : average total time\n"
-	       "       -uao, -uto: average times computed on valid ('OK') requests\n"
-	       );
-	exit(0);
-}
-
-
-/* return pointer to first char not part of current field starting at <p>. */
-
-#if defined(__i386__)
-/* this one is always faster on 32-bits */
-static inline const char *field_stop(const char *p)
-{
-	asm(
-	    /* Look for spaces */
-	    "4:                  \n\t"
-	    "inc   %0            \n\t"
-	    "cmpb  $0x20, -1(%0) \n\t"
-	    "ja    4b            \n\t"
-	    "jz    3f            \n\t"
-
-	    /* we only get there for control chars 0..31. Leave if we find '\0' */
-	    "cmpb  $0x0, -1(%0)  \n\t"
-	    "jnz   4b            \n\t"
-
-	    /* return %0-1 = position of the last char we checked */
-	    "3:                  \n\t"
-	    "dec   %0            \n\t"
-	    : "=r" (p)
-	    : "0" (p)
-	    );
-	return p;
-}
-#else
-const char *field_stop(const char *p)
-{
-	unsigned char c;
-
-	while (1) {
-		c = *(p++);
-		if (c > ' ')
-			continue;
-		if (c == ' ' || c == 0)
-			break;
-	}
-	return p - 1;
-}
-#endif
-
-/* return field <field> (starting from 1) in string <p>. Only consider
- * contiguous spaces (or tabs) as one delimiter. May return pointer to
- * last char if field is not found. Equivalent to awk '{print $field}'.
- */
-const char *field_start(const char *p, int field)
-{
-#ifndef PREFER_ASM
-	unsigned char c;
-	while (1) {
-		/* skip spaces */
-		while (1) {
-			c = *(p++);
-			if (c > ' ')
-				break;
-			if (c == ' ')
-				continue;
-			if (!c) /* end of line */
-				return p-1;
-			/* other char => new field */
-			break;
-		}
-
-		/* start of field */
-		field--;
-		if (!field)
-			return p-1;
-
-		/* skip this field */
-		while (1) {
-			c = *(p++);
-			if (c == ' ')
-				break;
-			if (c > ' ')
-				continue;
-			if (c == '\0')
-				return p - 1;
-		}
-	}
-#else
-	/* This version works optimally on i386 and x86_64 but the code above
-	 * shows similar performance. However, depending on the version of GCC
-	 * used, inlining rules change and it may have difficulties to make
-	 * efficient use of this code at other locations and could result in
-	 * worse performance (eg: gcc 4.4). You may want to experience.
-	 */
-	asm(
-	    /* skip spaces */
-	    "1:                  \n\t"
-	    "inc   %0            \n\t"
-	    "cmpb  $0x20, -1(%0) \n\t"
-	    "ja    2f            \n\t"
-	    "jz    1b            \n\t"
-
-	    /* we only get there for control chars 0..31. Leave if we find '\0' */
-	    "cmpb  $0x0, -1(%0)  \n\t"
-	    "jz    3f            \n\t"
-
-	    /* start of field at [%0-1]. Check if we need to skip more fields */
-	    "2:                  \n\t"
-	    "dec   %1            \n\t"
-	    "jz    3f            \n\t"
-
-	    /* Look for spaces */
-	    "4:                  \n\t"
-	    "inc   %0            \n\t"
-	    "cmpb  $0x20, -1(%0) \n\t"
-	    "jz    1b            \n\t"
-	    "ja    4b            \n\t"
-
-	    /* we only get there for control chars 0..31. Leave if we find '\0' */
-	    "cmpb  $0x0, -1(%0)  \n\t"
-	    "jnz   4b            \n\t"
-
-	    /* return %0-1 = position of the last char we checked */
-	    "3:                  \n\t"
-	    "dec   %0            \n\t"
-	    : "=r" (p)
-	    : "r" (field), "0" (p)
-	    );
-	return p;
-#endif
-}
-
-/* keep only the <bits> higher bits of <i> */
-static inline unsigned int quantify_u32(unsigned int i, int bits)
-{
-	int high;
-
-	if (!bits)
-		return 0;
-
-	if (i)
-		high = fls_auto(i);    // 1 to 32
-	else
-		high = 0;
-
-	if (high <= bits)
-		return i;
-
-	return i & ~((1 << (high - bits)) - 1);
-}
-
-/* keep only the <bits> higher bits of the absolute value of <i>, as well as
- * its sign. */
-static inline int quantify(int i, int bits)
-{
-	if (i >= 0)
-		return quantify_u32(i, bits);
-	else
-		return -quantify_u32(-i, bits);
-}
-
-/* Insert timer value <v> into tree <r>. A pre-allocated node must be passed
- * in <alloc>. It may be NULL, in which case the function will allocate it
- * itself. It will be reset to NULL once consumed. The caller is responsible
- * for freeing the node once not used anymore. The node where the value was
- * inserted is returned.
- */
-struct timer *insert_timer(struct eb_root *r, struct timer **alloc, int v)
-{
-	struct timer *t = *alloc;
-	struct eb32_node *n;
-
-	if (!t) {
-		t = calloc(sizeof(*t), 1);
-		if (unlikely(!t)) {
-			fprintf(stderr, "%s: not enough memory\n", __FUNCTION__);
-			exit(1);
-		}
-	}
-	t->node.key = quantify(v, QBITS);         // keep only the higher QBITS bits
-
-	n = eb32i_insert(r, &t->node);
-	if (n == &t->node)
-		t = NULL;  /* node inserted, will malloc next time */
-
-	*alloc = t;
-	return container_of(n, struct timer, node);
-}
-
-/* Insert value value <v> into tree <r>. A pre-allocated node must be passed
- * in <alloc>. It may be NULL, in which case the function will allocate it
- * itself. It will be reset to NULL once consumed. The caller is responsible
- * for freeing the node once not used anymore. The node where the value was
- * inserted is returned.
- */
-struct timer *insert_value(struct eb_root *r, struct timer **alloc, int v)
-{
-	struct timer *t = *alloc;
-	struct eb32_node *n;
-
-	if (!t) {
-		t = calloc(sizeof(*t), 1);
-		if (unlikely(!t)) {
-			fprintf(stderr, "%s: not enough memory\n", __FUNCTION__);
-			exit(1);
-		}
-	}
-	t->node.key = v;
-
-	n = eb32i_insert(r, &t->node);
-	if (n == &t->node)
-		t = NULL;  /* node inserted, will malloc next time */
-
-	*alloc = t;
-	return container_of(n, struct timer, node);
-}
-
-int str2ic(const char *s)
-{
-	int i = 0;
-	int j, k;
-
-	if (*s != '-') {
-		/* positive number */
-		while (1) {
-			j = (*s++) - '0';
-			k = i * 10;
-			if ((unsigned)j > 9)
-				break;
-			i = k + j;
-		}
-	} else {
-		/* negative number */
-		s++;
-		while (1) {
-			j = (*s++) - '0';
-			k = i * 10;
-			if ((unsigned)j > 9)
-				break;
-			i = k - j;
-		}
-	}
-
-	return i;
-}
-
-
-/* Equivalent to strtoul with a length. */
-static inline unsigned int __strl2ui(const char *s, int len)
-{
-	unsigned int i = 0;
-	while (len-- > 0) {
-		i = i * 10 - '0';
-		i += (unsigned char)*s++;
-	}
-	return i;
-}
-
-unsigned int strl2ui(const char *s, int len)
-{
-	return __strl2ui(s, len);
-}
-
-/* Convert "[04/Dec/2008:09:49:40.555]" to an integer equivalent to the time of
- * the day in milliseconds. It returns -1 for all unparsable values. The parser
- * looks ugly but gcc emits far better code that way.
- */
-int convert_date(const char *field)
-{
-	unsigned int h, m, s, ms;
-	unsigned char c;
-	const char *b, *e;
-
-	h = m = s = ms = 0;
-	e = field;
-
-	/* skip the date */
-	while (1) {
-		c = *(e++);
-		if (c == ':')
-			break;
-		if (!c)
-			goto out_err;
-	}
-
-	/* hour + ':' */
-	b = e;
-	while (1) {
-		c = *(e++) - '0';
-		if (c > 9)
-			break;
-		h = h * 10 + c;
-	}
-	if (c == (unsigned char)(0 - '0'))
-		goto out_err;
-
-	/* minute + ':' */
-	b = e;
-	while (1) {
-		c = *(e++) - '0';
-		if (c > 9)
-			break;
-		m = m * 10 + c;
-	}
-	if (c == (unsigned char)(0 - '0'))
-		goto out_err;
-
-	/* second + '.' or ']' */
-	b = e;
-	while (1) {
-		c = *(e++) - '0';
-		if (c > 9)
-			break;
-		s = s * 10 + c;
-	}
-	if (c == (unsigned char)(0 - '0'))
-		goto out_err;
-
-	/* if there's a '.', we have milliseconds */
-	if (c == (unsigned char)('.' - '0')) {
-		/* millisecond second + ']' */
-		b = e;
-		while (1) {
-			c = *(e++) - '0';
-			if (c > 9)
-				break;
-			ms = ms * 10 + c;
-		}
-		if (c == (unsigned char)(0 - '0'))
-			goto out_err;
-	}
-	return (((h * 60) + m) * 60 + s) * 1000 + ms;
- out_err:
-	return -1;
-}
-
-void truncated_line(int linenum, const char *line)
-{
-	if (!(filter & FILT_QUIET))
-		fprintf(stderr, "Truncated line %d: %s\n", linenum, line);
-}
-
-int main(int argc, char **argv)
-{
-	const char *b, *e, *p, *time_field, *accept_field;
-	const char *filter_term_code_name = NULL;
-	const char *output_file = NULL;
-	int f, last, err;
-	struct timer *t = NULL;
-	struct eb32_node *n;
-	struct url_stat *ustat = NULL;
-	int val, test;
-	int filter_acc_delay = 0, filter_acc_count = 0;
-	int filter_time_resp = 0;
-	int filt_http_status_low = 0, filt_http_status_high = 0;
-	int skip_fields = 1;
-
-	void (*line_filter)(const char *accept_field, const char *time_field, struct timer **tptr) = NULL;
-
-	argc--; argv++;
-	while (argc > 0) {
-		if (*argv[0] != '-')
-			break;
-
-		if (strcmp(argv[0], "-ad") == 0) {
-			if (argc < 2) die("missing option for -ad");
-			argc--; argv++;
-			filter |= FILT_ACC_DELAY;
-			filter_acc_delay = atol(*argv);
-		}
-		else if (strcmp(argv[0], "-ac") == 0) {
-			if (argc < 2) die("missing option for -ac");
-			argc--; argv++;
-			filter |= FILT_ACC_COUNT;
-			filter_acc_count = atol(*argv);
-		}
-		else if (strcmp(argv[0], "-rt") == 0) {
-			if (argc < 2) die("missing option for -rt");
-			argc--; argv++;
-			filter |= FILT_TIME_RESP;
-			filter_time_resp = atol(*argv);
-		}
-		else if (strcmp(argv[0], "-RT") == 0) {
-			if (argc < 2) die("missing option for -RT");
-			argc--; argv++;
-			filter |= FILT_TIME_RESP | FILT_INVERT_TIME_RESP;
-			filter_time_resp = atol(*argv);
-		}
-		else if (strcmp(argv[0], "-s") == 0) {
-			if (argc < 2) die("missing option for -s");
-			argc--; argv++;
-			skip_fields = atol(*argv);
-		}
-		else if (strcmp(argv[0], "-e") == 0)
-			filter |= FILT_ERRORS_ONLY;
-		else if (strcmp(argv[0], "-E") == 0)
-			filter |= FILT_ERRORS_ONLY | FILT_INVERT_ERRORS;
-		else if (strcmp(argv[0], "-H") == 0)
-			filter |= FILT_HTTP_ONLY;
-		else if (strcmp(argv[0], "-Q") == 0)
-			filter |= FILT_QUEUE_ONLY;
-		else if (strcmp(argv[0], "-QS") == 0)
-			filter |= FILT_QUEUE_SRV_ONLY;
-		else if (strcmp(argv[0], "-c") == 0)
-			filter |= FILT_COUNT_ONLY;
-		else if (strcmp(argv[0], "-q") == 0)
-			filter |= FILT_QUIET;
-		else if (strcmp(argv[0], "-v") == 0)
-			filter_invert = !filter_invert;
-		else if (strcmp(argv[0], "-gt") == 0)
-			filter |= FILT_GRAPH_TIMERS;
-		else if (strcmp(argv[0], "-pct") == 0)
-			filter |= FILT_PERCENTILE;
-		else if (strcmp(argv[0], "-st") == 0)
-			filter |= FILT_COUNT_STATUS;
-		else if (strcmp(argv[0], "-srv") == 0)
-			filter |= FILT_COUNT_SRV_STATUS;
-		else if (strcmp(argv[0], "-tc") == 0)
-			filter |= FILT_COUNT_TERM_CODES;
-		else if (strcmp(argv[0], "-tcn") == 0) {
-			if (argc < 2) die("missing option for -tcn");
-			argc--; argv++;
-			filter |= FILT_TERM_CODE_NAME;
-			filter_term_code_name = *argv;
-		}
-		else if (strcmp(argv[0], "-TCN") == 0) {
-			if (argc < 2) die("missing option for -TCN");
-			argc--; argv++;
-			filter |= FILT_TERM_CODE_NAME | FILT_INVERT_TERM_CODE_NAME;
-			filter_term_code_name = *argv;
-		}
-		else if (strcmp(argv[0], "-hs") == 0 || strcmp(argv[0], "-HS") == 0) {
-			char *sep, *str;
-
-			if (argc < 2) die("missing option for -hs/-HS ([min]:[max])");
-			filter |= FILT_HTTP_STATUS;
-			if (argv[0][1] == 'H')
-				filter |= FILT_INVERT_HTTP_STATUS;
-
-			argc--; argv++;
-			str = *argv;
-			sep = strchr(str, ':');  /* [min]:[max] */
-			if (!sep)
-				sep = str; /* make max point to min */
-			else
-				*sep++ = 0;
-			filt_http_status_low = *str ? atol(str) : 0;
-			filt_http_status_high = *sep ? atol(sep) : 65535;
-		}
-		else if (strcmp(argv[0], "-u") == 0)
-			filter |= FILT_COUNT_URL_ONLY;
-		else if (strcmp(argv[0], "-uc") == 0)
-			filter |= FILT_COUNT_URL_COUNT;
-		else if (strcmp(argv[0], "-ue") == 0)
-			filter |= FILT_COUNT_URL_ERR;
-		else if (strcmp(argv[0], "-ua") == 0)
-			filter |= FILT_COUNT_URL_TAVG;
-		else if (strcmp(argv[0], "-ut") == 0)
-			filter |= FILT_COUNT_URL_TTOT;
-		else if (strcmp(argv[0], "-uao") == 0)
-			filter |= FILT_COUNT_URL_TAVGO;
-		else if (strcmp(argv[0], "-uto") == 0)
-			filter |= FILT_COUNT_URL_TTOTO;
-		else if (strcmp(argv[0], "-o") == 0) {
-			if (output_file)
-				die("Fatal: output file name already specified.\n");
-			if (argc < 2)
-				die("Fatal: missing output file name.\n");
-			output_file = argv[1];
-		}
-		else if (strcmp(argv[0], "-h") == 0 || strcmp(argv[0], "--help") == 0)
-			help();
-		argc--;
-		argv++;
-	}
-
-	if (!filter)
-		die("No action specified.\n");
-
-	if (filter & FILT_ACC_COUNT && !filter_acc_count)
-		filter_acc_count=1;
-
-	if (filter & FILT_ACC_DELAY && !filter_acc_delay)
-		filter_acc_delay = 1;
-
-
-	/* by default, all lines are printed */
-	line_filter = filter_output_line;
-	if (filter & (FILT_ACC_COUNT|FILT_ACC_DELAY))
-		line_filter = filter_accept_holes;
-	else if (filter & (FILT_GRAPH_TIMERS|FILT_PERCENTILE))
-		line_filter = filter_graphs;
-	else if (filter & FILT_COUNT_STATUS)
-		line_filter = filter_count_status;
-	else if (filter & FILT_COUNT_TERM_CODES)
-		line_filter = filter_count_term_codes;
-	else if (filter & FILT_COUNT_SRV_STATUS)
-		line_filter = filter_count_srv_status;
-	else if (filter & FILT_COUNT_URL_ANY)
-		line_filter = filter_count_url;
-	else if (filter & FILT_COUNT_ONLY)
-		line_filter = NULL;
-
-	while ((line = fgets2(stdin)) != NULL) {
-		linenum++;
-		time_field = NULL; accept_field = NULL;
-
-		test = 1;
-
-		/* for any line we process, we first ensure that there is a field
-		 * looking like the accept date field (beginning with a '[').
-		 */
-		accept_field = field_start(line, ACCEPT_FIELD + skip_fields);
-		if (unlikely(*accept_field != '[')) {
-			parse_err++;
-			continue;
-		}
-
-		/* the day of month field is begin 01 and 31 */
-		if (accept_field[1] < '0' || accept_field[1] > '3') {
-			parse_err++;
-			continue;
-		}
-
-		if (filter & FILT_HTTP_ONLY) {
-			/* only report lines with at least 4 timers */
-			if (!time_field) {
-				time_field = field_start(accept_field, TIME_FIELD - ACCEPT_FIELD + 1);
-				if (unlikely(!*time_field)) {
-					truncated_line(linenum, line);
-					continue;
-				}
-			}
-
-			e = field_stop(time_field + 1);
-			/* we have field TIME_FIELD in [time_field]..[e-1] */
-			p = time_field;
-			f = 0;
-			while (!SEP(*p)) {
-				if (++f == 4)
-					break;
-				SKIP_CHAR(p, '/');
-			}
-			test &= (f >= 4);
-		}
-
-		if (filter & FILT_TIME_RESP) {
-			int tps;
-
-			/* only report lines with response times larger than filter_time_resp */
-			if (!time_field) {
-				time_field = field_start(accept_field, TIME_FIELD - ACCEPT_FIELD + 1);
-				if (unlikely(!*time_field)) {
-					truncated_line(linenum, line);
-					continue;
-				}
-			}
-
-			e = field_stop(time_field + 1);
-			/* we have field TIME_FIELD in [time_field]..[e-1], let's check only the response time */
-
-			p = time_field;
-			err = 0;
-			f = 0;
-			while (!SEP(*p)) {
-				tps = str2ic(p);
-				if (tps < 0) {
-					tps = -1;
-					err = 1;
-				}
-				if (++f == 4)
-					break;
-				SKIP_CHAR(p, '/');
-			}
-
-			if (unlikely(f < 4)) {
-				parse_err++;
-				continue;
-			}
-
-			test &= (tps >= filter_time_resp) ^ !!(filter & FILT_INVERT_TIME_RESP);
-		}
-
-		if (filter & (FILT_ERRORS_ONLY | FILT_HTTP_STATUS)) {
-			/* Check both error codes (-1, 5xx) and status code ranges */
-			if (time_field)
-				b = field_start(time_field, STATUS_FIELD - TIME_FIELD + 1);
-			else
-				b = field_start(accept_field, STATUS_FIELD - ACCEPT_FIELD + 1);
-
-			if (unlikely(!*b)) {
-				truncated_line(linenum, line);
-				continue;
-			}
-
-			val = str2ic(b);
-			if (filter & FILT_ERRORS_ONLY)
-				test &= (val < 0 || (val >= 500 && val <= 599)) ^ !!(filter & FILT_INVERT_ERRORS);
-
-			if (filter & FILT_HTTP_STATUS)
-				test &= (val >= filt_http_status_low && val <= filt_http_status_high) ^ !!(filter & FILT_INVERT_HTTP_STATUS);
-		}
-
-		if (filter & (FILT_QUEUE_ONLY|FILT_QUEUE_SRV_ONLY)) {
-			/* Check if the server's queue is non-nul */
-			if (time_field)
-				b = field_start(time_field, QUEUE_LEN_FIELD - TIME_FIELD + 1);
-			else
-				b = field_start(accept_field, QUEUE_LEN_FIELD - ACCEPT_FIELD + 1);
-
-			if (unlikely(!*b)) {
-				truncated_line(linenum, line);
-				continue;
-			}
-
-			if (*b == '0') {
-				if (filter & FILT_QUEUE_SRV_ONLY) {
-					test = 0;
-				}
-				else {
-					do {
-						b++;
-						if (*b == '/') {
-							b++;
-							break;
-						}
-					} while (*b);
-					test &= ((unsigned char)(*b - '1') < 9);
-				}
-			}
-		}
-
-		if (filter & FILT_TERM_CODE_NAME) {
-			/* only report corresponding termination code name */
-			if (time_field)
-				b = field_start(time_field, TERM_CODES_FIELD - TIME_FIELD + 1);
-			else
-				b = field_start(accept_field, TERM_CODES_FIELD - ACCEPT_FIELD + 1);
-
-			if (unlikely(!*b)) {
-				truncated_line(linenum, line);
-				continue;
-			}
-
-			test &= (b[0] == filter_term_code_name[0] && b[1] == filter_term_code_name[1]) ^ !!(filter & FILT_INVERT_TERM_CODE_NAME);
-		}
-
-
-		test ^= filter_invert;
-		if (!test)
-			continue;
-
-		/************** here we process inputs *******************/
-
-		if (line_filter)
-			line_filter(accept_field, time_field, &t);
-		else
-			lines_out++; /* we're just counting lines */
-	}
-
-
-	/*****************************************************
-	 * Here we've finished reading all input. Depending on the
-	 * filters, we may still have some analysis to run on the
-	 * collected data and to output data in a new format.
-	 *************************************************** */
-
-	if (t)
-		free(t);
-
-	if (filter & FILT_COUNT_ONLY) {
-		printf("%d\n", lines_out);
-		exit(0);
-	}
-
-	if (filter & (FILT_ACC_COUNT|FILT_ACC_DELAY)) {
-		/* sort and count all timers. Output will look like this :
-		 * <accept_date> <delta_ms from previous one> <nb entries>
-		 */
-		n = eb32_first(&timers[0]);
-
-		if (n)
-			last = n->key;
-		while (n) {
-			unsigned int d, h, m, s, ms;
-
-			t = container_of(n, struct timer, node);
-			h = n->key;
-			d = h - last;
-			last = h;
-
-			if (d >= filter_acc_delay && t->count >= filter_acc_count) {
-				ms = h % 1000; h = h / 1000;
-				s = h % 60; h = h / 60;
-				m = h % 60; h = h / 60;
-				lines_out++;
-				printf("%02d:%02d:%02d.%03d %d %d %d\n", h, m, s, ms, last, d, t->count);
-			}
-			n = eb32_next(n);
-		}
-	}
-	else if (filter & FILT_GRAPH_TIMERS) {
-		/* sort all timers */
-		for (f = 0; f < 5; f++) {
-			struct eb32_node *n;
-			int val;
-
-			val = 0;
-			n = eb32_first(&timers[f]);
-			while (n) {
-				int i;
-				double d;
-
-				t = container_of(n, struct timer, node);
-				last = n->key;
-				val = t->count;
-
-				i = (last < 0) ? -last : last;
-				i = fls_auto(i) - QBITS;
-
-				if (i > 0)
-					d = val / (double)(1 << i);
-				else
-					d = val;
-
-				if (d > 0.0) {
-					printf("%d %d %f\n", f, last, d+1.0);
-					lines_out++;
-				}
-
-				n = eb32_next(n);
-			}
-		}
-	}
-	else if (filter & FILT_PERCENTILE) {
-		/* report timers by percentile :
-		 *    <percent> <total> <max_req_time> <max_conn_time> <max_resp_time> <max_data_time>
-		 * We don't count errs.
-		 */
-		struct eb32_node *n[5];
-		unsigned long cum[5];
-		double step;
-
-		if (!lines_out)
-			goto empty;
-
-		for (f = 1; f < 5; f++) {
-			n[f] = eb32_first(&timers[f]);
-			cum[f] = container_of(n[f], struct timer, node)->count;
-		}
-
-		for (step = 1; step <= 1000;) {
-			unsigned int thres = lines_out * (step / 1000.0);
-
-			printf("%3.1f %d ", step/10.0, thres);
-			for (f = 1; f < 5; f++) {
-				struct eb32_node *next;
-				while (cum[f] < thres) {
-					/* need to find other keys */
-					next = eb32_next(n[f]);
-					if (!next)
-						break;
-					n[f] = next;
-					cum[f] += container_of(next, struct timer, node)->count;
-				}
-
-				/* value still within $step % of total */
-				printf("%d ", n[f]->key);
-			}
-			putchar('\n');
-			if (step >= 100 && step < 900)
-				step += 50;  // jump 5% by 5% between those steps.
-			else if (step >= 20 && step < 980)
-				step += 10;
-			else
-				step += 1;
-		}
-	}
-	else if (filter & FILT_COUNT_STATUS) {
-		/* output all statuses in the form of <status> <occurrences> */
-		n = eb32_first(&timers[0]);
-		while (n) {
-			t = container_of(n, struct timer, node);
-			printf("%d %d\n", n->key, t->count);
-			lines_out++;
-			n = eb32_next(n);
-		}
-	}
-	else if (filter & FILT_COUNT_SRV_STATUS) {
-		struct ebmb_node *srv_node;
-		struct srv_st *srv;
-
-		printf("#srv_name 1xx 2xx 3xx 4xx 5xx other tot_req req_ok pct_ok avg_ct avg_rt\n");
-
-		srv_node = ebmb_first(&timers[0]);
-		while (srv_node) {
-			int tot_rq;
-
-			srv = container_of(srv_node, struct srv_st, node);
-
-			tot_rq = 0;
-			for (f = 0; f <= 5; f++)
-				tot_rq += srv->st_cnt[f];
-
-			printf("%s %d %d %d %d %d %d %d %d %.1f %d %d\n",
-			       srv_node->key, srv->st_cnt[1], srv->st_cnt[2],
-			       srv->st_cnt[3], srv->st_cnt[4], srv->st_cnt[5], srv->st_cnt[0],
-			       tot_rq,
-			       srv->nb_ok, (double)srv->nb_ok * 100.0 / (tot_rq?tot_rq:1),
-			       (int)(srv->cum_ct / (srv->nb_ct?srv->nb_ct:1)), (int)(srv->cum_rt / (srv->nb_rt?srv->nb_rt:1)));
-			srv_node = ebmb_next(srv_node);
-			lines_out++;
-		}
-	}
-	else if (filter & FILT_COUNT_TERM_CODES) {
-		/* output all statuses in the form of <code> <occurrences> */
-		n = eb32_first(&timers[0]);
-		while (n) {
-			t = container_of(n, struct timer, node);
-			printf("%c%c %d\n", (n->key >> 8), (n->key) & 255, t->count);
-			lines_out++;
-			n = eb32_next(n);
-		}
-	}
-	else if (filter & FILT_COUNT_URL_ANY) {
-		struct eb_node *node, *next;
-
-		if (!(filter & FILT_COUNT_URL_ONLY)) {
-			/* we have to sort on another criterion. We'll use timers[1] for the
-			 * destination tree.
-			 */
-
-			timers[1] = EB_ROOT; /* reconfigure to accept duplicates */
-			for (node = eb_first(&timers[0]); node; node = next) {
-				next = eb_next(node);
-				eb_delete(node);
-
-				ustat = container_of(node, struct url_stat, node.url.node);
-
-				if (filter & FILT_COUNT_URL_COUNT)
-					ustat->node.val.key = ustat->nb_req;
-				else if (filter & FILT_COUNT_URL_ERR)
-					ustat->node.val.key = ustat->nb_err;
-				else if (filter & FILT_COUNT_URL_TTOT)
-					ustat->node.val.key = ustat->total_time;
-				else if (filter & FILT_COUNT_URL_TAVG)
-					ustat->node.val.key = ustat->nb_req ? ustat->total_time / ustat->nb_req : 0;
-				else if (filter & FILT_COUNT_URL_TTOTO)
-					ustat->node.val.key = ustat->total_time_ok;
-				else if (filter & FILT_COUNT_URL_TAVGO)
-					ustat->node.val.key = (ustat->nb_req - ustat->nb_err) ? ustat->total_time_ok / (ustat->nb_req - ustat->nb_err) : 0;
-				else
-					ustat->node.val.key = 0;
-
-				eb64_insert(&timers[1], &ustat->node.val);
-			}
-			/* switch trees */
-			timers[0] = timers[1];
-		}
-
-		printf("#req err ttot tavg oktot okavg url\n");
-
-		/* scan the tree in its reverse sorting order */
-		node = eb_last(&timers[0]);
-		while (node) {
-			ustat = container_of(node, struct url_stat, node.url.node);
-			printf("%d %d %Ld %Ld %Ld %Ld %s\n",
-			       ustat->nb_req,
-			       ustat->nb_err,
-			       ustat->total_time,
-			       ustat->nb_req ? ustat->total_time / ustat->nb_req : 0,
-			       ustat->total_time_ok,
-			       (ustat->nb_req - ustat->nb_err) ? ustat->total_time_ok / (ustat->nb_req - ustat->nb_err) : 0,
-			       ustat->url);
-
-			node = eb_prev(node);
-			lines_out++;
-		}
-	}
-
- empty:
-	if (!(filter & FILT_QUIET))
-		fprintf(stderr, "%d lines in, %d lines out, %d parsing errors\n",
-			linenum, lines_out, parse_err);
-	exit(0);
-}
-
-void filter_output_line(const char *accept_field, const char *time_field, struct timer **tptr)
-{
-	puts(line);
-	lines_out++;
-}
-
-void filter_accept_holes(const char *accept_field, const char *time_field, struct timer **tptr)
-{
-	struct timer *t2;
-	int val;
-
-	val = convert_date(accept_field);
-	if (unlikely(val < 0)) {
-		truncated_line(linenum, line);
-		return;
-	}
-
-	t2 = insert_value(&timers[0], tptr, val);
-	t2->count++;
-	lines_out++;
-	return;
-}
-
-void filter_count_status(const char *accept_field, const char *time_field, struct timer **tptr)
-{
-	struct timer *t2;
-	const char *b;
-	int val;
-
-	if (time_field)
-		b = field_start(time_field, STATUS_FIELD - TIME_FIELD + 1);
-	else
-		b = field_start(accept_field, STATUS_FIELD - ACCEPT_FIELD + 1);
-
-	if (unlikely(!*b)) {
-		truncated_line(linenum, line);
-		return;
-	}
-
-	val = str2ic(b);
-
-	t2 = insert_value(&timers[0], tptr, val);
-	t2->count++;
-}
-
-void filter_count_term_codes(const char *accept_field, const char *time_field, struct timer **tptr)
-{
-	struct timer *t2;
-	const char *b;
-	int val;
-
-	if (time_field)
-		b = field_start(time_field, TERM_CODES_FIELD - TIME_FIELD + 1);
-	else
-		b = field_start(accept_field, TERM_CODES_FIELD - ACCEPT_FIELD + 1);
-
-	if (unlikely(!*b)) {
-		truncated_line(linenum, line);
-		return;
-	}
-
-	val = 256 * b[0] + b[1];
-
-	t2 = insert_value(&timers[0], tptr, val);
-	t2->count++;
-}
-
-void filter_count_srv_status(const char *accept_field, const char *time_field, struct timer **tptr)
-{
-	const char *b, *e, *p;
-	int f, err, array[5];
-	struct ebmb_node *srv_node;
-	struct srv_st *srv;
-	int val;
-
-	/* the server field is before the status field, so let's
-	 * parse them in the proper order.
-	 */
-	b = field_start(accept_field, SERVER_FIELD - ACCEPT_FIELD + 1);
-	if (unlikely(!*b)) {
-		truncated_line(linenum, line);
-		return;
-	}
-
-	e = field_stop(b + 1);  /* we have the server name in [b]..[e-1] */
-
-	/* the chance that a server name already exists is extremely high,
-	 * so let's perform a normal lookup first.
-	 */
-	srv_node = ebst_lookup_len(&timers[0], b, e - b);
-	srv = container_of(srv_node, struct srv_st, node);
-
-	if (!srv_node) {
-		/* server not yet in the tree, let's create it */
-		srv = (void *)calloc(1, sizeof(struct srv_st) + e - b + 1);
-		srv_node = &srv->node;
-		memcpy(&srv_node->key, b, e - b);
-		srv_node->key[e - b] = '\0';
-		ebst_insert(&timers[0], srv_node);
-	}
-
-	/* let's collect the connect and response times */
-	if (!time_field) {
-		time_field = field_start(e, TIME_FIELD - SERVER_FIELD);
-		if (unlikely(!*time_field)) {
-			truncated_line(linenum, line);
-			return;
-		}
-	}
-
-	e = field_stop(time_field + 1);
-	/* we have field TIME_FIELD in [time_field]..[e-1] */
-
-	p = time_field;
-	err = 0;
-	f = 0;
-	while (!SEP(*p)) {
-		array[f] = str2ic(p);
-		if (array[f] < 0) {
-			array[f] = -1;
-			err = 1;
-		}
-		if (++f == 5)
-			break;
-		SKIP_CHAR(p, '/');
-	}
-
-	if (unlikely(f < 5)){
-		parse_err++;
-		return;
-	}
-
-	/* OK we have our timers in array[2,3] */
-	if (!err)
-		srv->nb_ok++;
-
-	if (array[2] >= 0) {
-		srv->cum_ct += array[2];
-		srv->nb_ct++;
-	}
-
-	if (array[3] >= 0) {
-		srv->cum_rt += array[3];
-		srv->nb_rt++;
-	}
-
-	/* we're interested in the 5 HTTP status classes (1xx ... 5xx), and
-	 * the invalid ones which will be reported as 0.
-	 */
-	b = field_start(e, STATUS_FIELD - TIME_FIELD);
-	if (unlikely(!*b)) {
-		truncated_line(linenum, line);
-		return;
-	}
-
-	val = 0;
-	if (*b >= '1' && *b <= '5')
-		val = *b - '0';
-
-	srv->st_cnt[val]++;
-}
-
-void filter_count_url(const char *accept_field, const char *time_field, struct timer **tptr)
-{
-	struct url_stat *ustat = NULL;
-	struct ebpt_node *ebpt_old;
-	const char *b, *e;
-	int f, err, array[5];
-
-	/* let's collect the response time */
-	if (!time_field) {
-		time_field = field_start(accept_field, TIME_FIELD - ACCEPT_FIELD + 1);  // avg 115 ns per line
-		if (unlikely(!*time_field)) {
-			truncated_line(linenum, line);
-			return;
-		}
-	}
-
-	/* we have the field TIME_FIELD starting at <time_field>. We'll
-	 * parse the 5 timers to detect errors, it takes avg 55 ns per line.
-	 */
-	e = time_field; err = 0; f = 0;
-	while (!SEP(*e)) {
-		array[f] = str2ic(e);
-		if (array[f] < 0) {
-			array[f] = -1;
-			err = 1;
-		}
-		if (++f == 5)
-			break;
-		SKIP_CHAR(e, '/');
-	}
-	if (f < 5) {
-		parse_err++;
-		return;
-	}
-
-	/* OK we have our timers in array[3], and err is >0 if at
-	 * least one -1 was seen. <e> points to the first char of
-	 * the last timer. Let's prepare a new node with that.
-	 */
-	if (unlikely(!ustat))
-		ustat = calloc(1, sizeof(*ustat));
-
-	ustat->nb_err = err;
-	ustat->nb_req = 1;
-
-	/* use array[4] = total time in case of error */
-	ustat->total_time = (array[3] >= 0) ? array[3] : array[4];
-	ustat->total_time_ok = (array[3] >= 0) ? array[3] : 0;
-
-	/* the line may be truncated because of a bad request or anything like this,
-	 * without a method. Also, if it does not begin with an quote, let's skip to
-	 * the next field because it's a capture. Let's fall back to the "method" itself
-	 * if there's nothing else.
-	 */
-	e = field_start(e, METH_FIELD - TIME_FIELD + 1); // avg 100 ns per line
-	while (*e != '"' && *e) {
-		/* Note: some syslog servers escape quotes ! */
-		if (*e == '\\' && e[1] == '"')
-			break;
-		e = field_start(e, 2);
-	}
-
-	if (unlikely(!*e)) {
-		truncated_line(linenum, line);
-		return;
-	}
-
-	b = field_start(e, URL_FIELD - METH_FIELD + 1); // avg 40 ns per line
-	if (!*b)
-		b = e;
-
-	/* stop at end of field or first ';' or '?', takes avg 64 ns per line */
-	e = b;
-	do {
-		if (*e == ' ' || *e == '?' || *e == ';') {
-			*(char *)e = 0;
-			break;
-		}
-		e++;
-	} while (*e);
-
-	/* now instead of copying the URL for a simple lookup, we'll link
-	 * to it from the node we're trying to insert. If it returns a
-	 * different value, it was already there. Otherwise we just have
-	 * to dynamically realloc an entry using strdup().
-	 */
-	ustat->node.url.key = (char *)b;
-	ebpt_old = ebis_insert(&timers[0], &ustat->node.url);
-
-	if (ebpt_old != &ustat->node.url) {
-		struct url_stat *ustat_old;
-		/* node was already there, let's update previous one */
-		ustat_old = container_of(ebpt_old, struct url_stat, node.url);
-		ustat_old->nb_req ++;
-		ustat_old->nb_err += ustat->nb_err;
-		ustat_old->total_time += ustat->total_time;
-		ustat_old->total_time_ok += ustat->total_time_ok;
-	} else {
-		ustat->url = ustat->node.url.key = strdup(ustat->node.url.key);
-		ustat = NULL; /* node was used */
-	}
-}
-
-void filter_graphs(const char *accept_field, const char *time_field, struct timer **tptr)
-{
-	struct timer *t2;
-	const char *e, *p;
-	int f, err, array[5];
-
-	if (!time_field) {
-		time_field = field_start(accept_field, TIME_FIELD - ACCEPT_FIELD + 1);
-		if (unlikely(!*time_field)) {
-			truncated_line(linenum, line);
-			return;
-		}
-	}
-
-	e = field_stop(time_field + 1);
-	/* we have field TIME_FIELD in [time_field]..[e-1] */
-
-	p = time_field;
-	err = 0;
-	f = 0;
-	while (!SEP(*p)) {
-		array[f] = str2ic(p);
-		if (array[f] < 0) {
-			array[f] = -1;
-			err = 1;
-		}
-		if (++f == 5)
-			break;
-		SKIP_CHAR(p, '/');
-	}
-
-	if (unlikely(f < 5)) {
-		parse_err++;
-		return;
-	}
-
-	/* if we find at least one negative time, we count one error
-	 * with a time equal to the total session time. This will
-	 * emphasize quantum timing effects associated to known
-	 * timeouts. Note that on some buggy machines, it is possible
-	 * that the total time is negative, hence the reason to reset
-	 * it.
-	 */
-
-	if (filter & FILT_GRAPH_TIMERS) {
-		if (err) {
-			if (array[4] < 0)
-				array[4] = -1;
-			t2 = insert_timer(&timers[0], tptr, array[4]);  // total time
-			t2->count++;
-		} else {
-			int v;
-
-			t2 = insert_timer(&timers[1], tptr, array[0]); t2->count++;  // req
-			t2 = insert_timer(&timers[2], tptr, array[2]); t2->count++;  // conn
-			t2 = insert_timer(&timers[3], tptr, array[3]); t2->count++;  // resp
-
-			v = array[4] - array[0] - array[1] - array[2] - array[3]; // data time
-			if (v < 0 && !(filter & FILT_QUIET))
-				fprintf(stderr, "ERR: %s (%d %d %d %d %d => %d)\n",
-					line, array[0], array[1], array[2], array[3], array[4], v);
-			t2 = insert_timer(&timers[4], tptr, v); t2->count++;
-			lines_out++;
-		}
-	} else { /* percentile */
-		if (err) {
-			if (array[4] < 0)
-				array[4] = -1;
-			t2 = insert_value(&timers[0], tptr, array[4]);  // total time
-			t2->count++;
-		} else {
-			int v;
-
-			t2 = insert_value(&timers[1], tptr, array[0]); t2->count++;  // req
-			t2 = insert_value(&timers[2], tptr, array[2]); t2->count++;  // conn
-			t2 = insert_value(&timers[3], tptr, array[3]); t2->count++;  // resp
-
-			v = array[4] - array[0] - array[1] - array[2] - array[3]; // data time
-			if (v < 0 && !(filter & FILT_QUIET))
-				fprintf(stderr, "ERR: %s (%d %d %d %d %d => %d)\n",
-					line, array[0], array[1], array[2], array[3], array[4], v);
-			t2 = insert_value(&timers[4], tptr, v); t2->count++;
-			lines_out++;
-		}
-	}
-}
-
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/contrib/netsnmp-perl/README b/deps/haproxy-1.4.21/contrib/netsnmp-perl/README
deleted file mode 100644
index f44eb5b..0000000
--- a/deps/haproxy-1.4.21/contrib/netsnmp-perl/README
+++ /dev/null
@@ -1,111 +0,0 @@
-SNMP support for HAProxy
-Copyright 2007-2008 Krzysztof Piotr Oledzki <ole@ans.pl>
-
-Root OID: 1.3.6.1.4.1.29385.106
-
-Files:
- - README: this file
- - haproxy.pl: Net-SNMP embedded perl module
- - haproxy_backend.xml: Cacti snmp-query definition for backends
- - haproxy_frontend.xml: Cacti snmp-query definition for frontends
-
-Install:
- cp haproxy.pl /etc/snmp/
- grep -q "disablePerl false" /etc/snmp/snmpd.conf || echo "disablePerl false" >> /etc/snmp/snmpd.conf
- echo "perl do '/etc/snmp/haproxy.pl';" >> /etc/snmp/snmpd.conf
-
-Supported commands:
- - GET (snmpget, snmpbulkget): quite fast.
- - GETNEXT (snmpwalk, snmpbulkwalk): not so fast as requires to transfer
-    and parse a lot of data during each step. Always use "get" instead of "walk"
-    if that's possible.
-
-Supported OIDs:
- - 1.3.6.1.4.1.29385.106.1: get a variable from stats
-    Usage: 1.3.6.1.4.1.29385.106.1.$type.$field.$iid.$sid
-
-     - type is one of:
-       0) frontend
-       1) backend
-       2) server
-
-     - field is one of:
-       0..32) CSV format variable
-       10001) index
-       10002) unique name
-
-     - iid is a proxy id 
-
-     - sid is a service id (sid): 0 for frontends and backends, >= 1 for servers
-
- - 1.3.6.1.4.1.29385.106.2: get a variable from info
-    Usage: 1.3.6.1.4.1.29385.106.2.$req.$varnr
-
-      - req is one of:
-        0) get variable name
-        1) gat variable value
-
-Examples:
-
-- Get a list of frontends (type: 0) with status (field: 17):
-$ snmpbulkwalk -c public -v2c 192.168.0.1 1.3.6.1.4.1.29385.106.1.0.17
-SNMPv2-SMI::enterprises.29385.106.1.0.17.1.0 = STRING: "OPEN"
-SNMPv2-SMI::enterprises.29385.106.1.0.17.47.0 = STRING: "OPEN"
-
-- Get a list of backends (type: 1) with index (field: 10001):
-$ snmpbulkwalk -c public -v2c 192.168.0.1 1.3.6.1.4.1.29385.106.1.1.10001
-SNMPv2-SMI::enterprises.29385.106.1.1.10001.1.0 = STRING: "1.0"
-SNMPv2-SMI::enterprises.29385.106.1.1.10001.1100.0 = STRING: "1100.0"
-SNMPv2-SMI::enterprises.29385.106.1.1.10001.1101.0 = STRING: "1101.0"
-SNMPv2-SMI::enterprises.29385.106.1.1.10001.1200.0 = STRING: "1200.0"
-SNMPv2-SMI::enterprises.29385.106.1.1.10001.1201.0 = STRING: "1201.0"
-SNMPv2-SMI::enterprises.29385.106.1.1.10001.1300.0 = STRING: "1300.0"
-SNMPv2-SMI::enterprises.29385.106.1.1.10001.1400.0 = STRING: "1400.0"
-SNMPv2-SMI::enterprises.29385.106.1.1.10001.1401.0 = STRING: "1401.0"
-SNMPv2-SMI::enterprises.29385.106.1.1.10001.1500.0 = STRING: "1500.0"
-(...)
-
-- Get a list of servers (type: 2) with unique name (field: 10002):
-$ snmpbulkwalk -c public -v2c 192.168.0.1 1.3.6.1.4.1.29385.106.1.2.10002
-SNMPv2-SMI::enterprises.29385.106.1.2.10002.1100.1001 = STRING: "backend1/s2"
-SNMPv2-SMI::enterprises.29385.106.1.2.10002.1100.1002 = STRING: "backend1/s5"
-SNMPv2-SMI::enterprises.29385.106.1.2.10002.1100.1003 = STRING: "backend1/s6"
-SNMPv2-SMI::enterprises.29385.106.1.2.10002.1100.1012 = STRING: "backend1/s7"
-SNMPv2-SMI::enterprises.29385.106.1.2.10002.1101.1001 = STRING: "backend2/s9"
-SNMPv2-SMI::enterprises.29385.106.1.2.10002.1101.1002 = STRING: "backend2/s10"
-SNMPv2-SMI::enterprises.29385.106.1.2.10002.1101.1003 = STRING: "backend2/s11"
-SNMPv2-SMI::enterprises.29385.106.1.2.10002.1101.1012 = STRING: "backend2/s12"
-SNMPv2-SMI::enterprises.29385.106.1.2.10002.1200.1001 = STRING: "backend3/s8"
-(...)
-
-- Get a list of servers (type: 2) with weight (field: 18) in proxy 4300:
-$ snmpbulkwalk -c public -v2c 192.168.0.1 1.3.6.1.4.1.29385.106.1.2.18.4300
-SNMPv2-SMI::enterprises.29385.106.1.2.18.4300.1001 = STRING: "40"
-SNMPv2-SMI::enterprises.29385.106.1.2.18.4300.1002 = STRING: "25"
-SNMPv2-SMI::enterprises.29385.106.1.2.18.4300.1003 = STRING: "40"
-SNMPv2-SMI::enterprises.29385.106.1.2.18.4300.1012 = STRING: "80"
-
-- Get total sessions count (field: 7) in frontend (type: 1), sid.iid: 47.0 (proxy #47):
-snmpget -c public -v2c 192.168.0.1 enterprises.29385.106.1.0.7.47.0
-SNMPv2-SMI::enterprises.29385.106.1.0.7.47.0 = STRING: "1014019"
-
-- Get a list of available variables (req: 0):
-$ snmpbulkwalk -c public -v2c 192.168.0.1 1.3.6.1.4.1.29385.106.2.0
-SNMPv2-SMI::enterprises.29385.106.2.0.0 = STRING: "Name"
-SNMPv2-SMI::enterprises.29385.106.2.0.1 = STRING: "Version"
-SNMPv2-SMI::enterprises.29385.106.2.0.2 = STRING: "Release_date"
-SNMPv2-SMI::enterprises.29385.106.2.0.3 = STRING: "Nbproc"
-SNMPv2-SMI::enterprises.29385.106.2.0.4 = STRING: "Process_num"
-SNMPv2-SMI::enterprises.29385.106.2.0.5 = STRING: "Pid"
-SNMPv2-SMI::enterprises.29385.106.2.0.6 = STRING: "Uptime"
-SNMPv2-SMI::enterprises.29385.106.2.0.7 = STRING: "Uptime_sec"
-SNMPv2-SMI::enterprises.29385.106.2.0.8 = STRING: "Memmax_MB"
-SNMPv2-SMI::enterprises.29385.106.2.0.9 = STRING: "Ulimit-n"
-SNMPv2-SMI::enterprises.29385.106.2.0.10 = STRING: "Maxsock"
-SNMPv2-SMI::enterprises.29385.106.2.0.11 = STRING: "Maxconn"
-SNMPv2-SMI::enterprises.29385.106.2.0.12 = STRING: "CurrConns"
-
-- Get a variable (req: 1), varnr: 7 (Uptime_sec):
-$ snmpget -c public -v2c 192.168.0.1 1.3.6.1.4.1.29385.106.2.1.7
-SNMPv2-SMI::enterprises.29385.106.2.1.7 = STRING: "18761"
- 
diff --git a/deps/haproxy-1.4.21/contrib/netsnmp-perl/cacti_data_query_haproxy_backends.xml b/deps/haproxy-1.4.21/contrib/netsnmp-perl/cacti_data_query_haproxy_backends.xml
deleted file mode 100644
index 2cf5009..0000000
--- a/deps/haproxy-1.4.21/contrib/netsnmp-perl/cacti_data_query_haproxy_backends.xml
+++ /dev/null
@@ -1,750 +0,0 @@
-<cacti>	
-	<hash_040013d1dd43e3e5cee941860ea277826c4fe2>
-		<name>HaProxy Backends</name>
-		<description></description>
-		<xml_path>&lt;path_cacti&gt;/resource/snmp_queries/haproxy_backend.xml</xml_path>
-		<data_input_id>hash_030013bf566c869ac6443b0c75d1c32b5a350e</data_input_id>
-		<graphs>
-			<hash_1100134d2954fa52f51ed186916f2cf624a8b9>
-				<name>HAProxy Backend Sessions</name>
-				<graph_template_id>hash_000013cdbf9accfcd57d9e0a7c97896313ddee</graph_template_id>
-				<rrd>
-					<item_000>
-						<snmp_field_name>beSTot</snmp_field_name>
-						<data_template_id>hash_010013fa4d4fff334b60e9064e89082173fe34</data_template_id>
-						<data_template_rrd_id>hash_080013230e04055a4228154123e74c6586d435</data_template_rrd_id>
-					</item_000>
-					<item_001>
-						<snmp_field_name>beEResp</snmp_field_name>
-						<data_template_id>hash_010013fa4d4fff334b60e9064e89082173fe34</data_template_id>
-						<data_template_rrd_id>hash_080013088549c8d7e8cdc80f19bae4d78dc296</data_template_rrd_id>
-					</item_001>
-				</rrd>
-				<sv_graph>
-					<hash_12001368ff8a0bfc447cb94d02e0d17cc3e252>
-						<field_name>ResponseErrors</field_name>
-						<sequence>1</sequence>
-						<text>ResponseErrors</text>
-					</hash_12001368ff8a0bfc447cb94d02e0d17cc3e252>
-					<hash_120013c2e81996ac5a70f67fa4a07e95eea035>
-						<field_name>TotalSessions</field_name>
-						<sequence>1</sequence>
-						<text>TotalSessions</text>
-					</hash_120013c2e81996ac5a70f67fa4a07e95eea035>
-				</sv_graph>
-				<sv_data_source>
-					<hash_130013169b7ea71d2aa3a8abaece19de7feeff>
-						<field_name>ResponseErrors</field_name>
-						<data_template_id>hash_010013fa4d4fff334b60e9064e89082173fe34</data_template_id>
-						<sequence>1</sequence>
-						<text>ResponseErrors</text>
-					</hash_130013169b7ea71d2aa3a8abaece19de7feeff>
-					<hash_130013a61ea1bb051f2162ba635c815324678d>
-						<field_name>TotalSessions</field_name>
-						<data_template_id>hash_010013fa4d4fff334b60e9064e89082173fe34</data_template_id>
-						<sequence>1</sequence>
-						<text>TotalSessions</text>
-					</hash_130013a61ea1bb051f2162ba635c815324678d>
-				</sv_data_source>
-			</hash_1100134d2954fa52f51ed186916f2cf624a8b9>
-			<hash_110013abc35ade0aae030d90f817dfd91486f4>
-				<name>HAProxy Backend Traffic</name>
-				<graph_template_id>hash_000013b6d238ff2532fcc19ab498043c7c65c2</graph_template_id>
-				<rrd>
-					<item_000>
-						<snmp_field_name>beBOut</snmp_field_name>
-						<data_template_id>hash_010013a63ddba34026d2c07d73c0ef2ae64b54</data_template_id>
-						<data_template_rrd_id>hash_0800136c0e4debeb9b084231d858faabd82f8f</data_template_rrd_id>
-					</item_000>
-					<item_001>
-						<snmp_field_name>beBIn</snmp_field_name>
-						<data_template_id>hash_010013a63ddba34026d2c07d73c0ef2ae64b54</data_template_id>
-						<data_template_rrd_id>hash_0800132f5283f17a7cde63137189d4d3ea7e4e</data_template_rrd_id>
-					</item_001>
-				</rrd>
-				<sv_graph>
-					<hash_1200133ba4a6c8aacf161f3e2411afd7053b8d>
-						<field_name>BytesIn</field_name>
-						<sequence>1</sequence>
-						<text>BytesIn</text>
-					</hash_1200133ba4a6c8aacf161f3e2411afd7053b8d>
-					<hash_1200130f8f674b52f6ea2e09608b505abfb3a1>
-						<field_name>BytesOut</field_name>
-						<sequence>1</sequence>
-						<text>BytesOut</text>
-					</hash_1200130f8f674b52f6ea2e09608b505abfb3a1>
-				</sv_graph>
-				<sv_data_source>
-					<hash_130013d9fb3064081d77e553c5ce732f15c909>
-						<field_name>BytesIn</field_name>
-						<data_template_id>hash_010013fa4d4fff334b60e9064e89082173fe34</data_template_id>
-						<sequence>1</sequence>
-						<text>BytesIn</text>
-					</hash_130013d9fb3064081d77e553c5ce732f15c909>
-					<hash_1300134fc96e4392a7a86d05fda31c2d5d334c>
-						<field_name>BytesOut</field_name>
-						<data_template_id>hash_010013fa4d4fff334b60e9064e89082173fe34</data_template_id>
-						<sequence>1</sequence>
-						<text>BytesOut</text>
-					</hash_1300134fc96e4392a7a86d05fda31c2d5d334c>
-					<hash_130013a7aad3557880ac197539a1d658f5d5da>
-						<field_name>BytesIn</field_name>
-						<data_template_id>hash_010013a63ddba34026d2c07d73c0ef2ae64b54</data_template_id>
-						<sequence>1</sequence>
-						<text>BytesIn</text>
-					</hash_130013a7aad3557880ac197539a1d658f5d5da>
-					<hash_130013acb469b673f6adbaa21ad5c634c3683f>
-						<field_name>BytesOut</field_name>
-						<data_template_id>hash_010013a63ddba34026d2c07d73c0ef2ae64b54</data_template_id>
-						<sequence>1</sequence>
-						<text>BytesOut</text>
-					</hash_130013acb469b673f6adbaa21ad5c634c3683f>
-				</sv_data_source>
-			</hash_110013abc35ade0aae030d90f817dfd91486f4>
-		</graphs>
-	</hash_040013d1dd43e3e5cee941860ea277826c4fe2>
-	<hash_030013bf566c869ac6443b0c75d1c32b5a350e>
-		<name>Get SNMP Data (Indexed)</name>
-		<type_id>3</type_id>
-		<input_string></input_string>
-		<fields>
-			<hash_070013617cdc8a230615e59f06f361ef6e7728>
-				<name>SNMP IP Address</name>
-				<update_rra></update_rra>
-				<regexp_match></regexp_match>
-				<allow_nulls></allow_nulls>
-				<type_code>hostname</type_code>
-				<input_output>in</input_output>
-				<data_name>management_ip</data_name>
-			</hash_070013617cdc8a230615e59f06f361ef6e7728>
-			<hash_070013acb449d1451e8a2a655c2c99d31142c7>
-				<name>SNMP Community</name>
-				<update_rra></update_rra>
-				<regexp_match></regexp_match>
-				<allow_nulls></allow_nulls>
-				<type_code>snmp_community</type_code>
-				<input_output>in</input_output>
-				<data_name>snmp_community</data_name>
-			</hash_070013acb449d1451e8a2a655c2c99d31142c7>
-			<hash_070013f4facc5e2ca7ebee621f09bc6d9fc792>
-				<name>SNMP Username (v3)</name>
-				<update_rra></update_rra>
-				<regexp_match></regexp_match>
-				<allow_nulls>on</allow_nulls>
-				<type_code>snmp_username</type_code>
-				<input_output>in</input_output>
-				<data_name>snmp_username</data_name>
-			</hash_070013f4facc5e2ca7ebee621f09bc6d9fc792>
-			<hash_0700131cc1493a6781af2c478fa4de971531cf>
-				<name>SNMP Password (v3)</name>
-				<update_rra></update_rra>
-				<regexp_match></regexp_match>
-				<allow_nulls>on</allow_nulls>
-				<type_code>snmp_password</type_code>
-				<input_output>in</input_output>
-				<data_name>snmp_password</data_name>
-			</hash_0700131cc1493a6781af2c478fa4de971531cf>
-			<hash_070013b5c23f246559df38662c255f4aa21d6b>
-				<name>SNMP Version (1, 2, or 3)</name>
-				<update_rra></update_rra>
-				<regexp_match></regexp_match>
-				<allow_nulls></allow_nulls>
-				<type_code>snmp_version</type_code>
-				<input_output>in</input_output>
-				<data_name>snmp_version</data_name>
-			</hash_070013b5c23f246559df38662c255f4aa21d6b>
-			<hash_0700136027a919c7c7731fbe095b6f53ab127b>
-				<name>Index Type</name>
-				<update_rra></update_rra>
-				<regexp_match></regexp_match>
-				<allow_nulls></allow_nulls>
-				<type_code>index_type</type_code>
-				<input_output>in</input_output>
-				<data_name>index_type</data_name>
-			</hash_0700136027a919c7c7731fbe095b6f53ab127b>
-			<hash_070013cbbe5c1ddfb264a6e5d509ce1c78c95f>
-				<name>Index Value</name>
-				<update_rra></update_rra>
-				<regexp_match></regexp_match>
-				<allow_nulls></allow_nulls>
-				<type_code>index_value</type_code>
-				<input_output>in</input_output>
-				<data_name>index_value</data_name>
-			</hash_070013cbbe5c1ddfb264a6e5d509ce1c78c95f>
-			<hash_070013e6deda7be0f391399c5130e7c4a48b28>
-				<name>Output Type ID</name>
-				<update_rra></update_rra>
-				<regexp_match></regexp_match>
-				<allow_nulls></allow_nulls>
-				<type_code>output_type</type_code>
-				<input_output>in</input_output>
-				<data_name>output_type</data_name>
-			</hash_070013e6deda7be0f391399c5130e7c4a48b28>
-			<hash_070013c1f36ee60c3dc98945556d57f26e475b>
-				<name>SNMP Port</name>
-				<update_rra></update_rra>
-				<regexp_match></regexp_match>
-				<allow_nulls></allow_nulls>
-				<type_code>snmp_port</type_code>
-				<input_output>in</input_output>
-				<data_name>snmp_port</data_name>
-			</hash_070013c1f36ee60c3dc98945556d57f26e475b>
-		</fields>
-	</hash_030013bf566c869ac6443b0c75d1c32b5a350e>
-	<hash_000013cdbf9accfcd57d9e0a7c97896313ddee>
-		<name>HAProxy Backend Sessions</name>
-		<graph>
-			<t_title></t_title>
-			<title>|host_description| - HaProxy - |query_bePxName| Backend Sessions</title>
-			<t_image_format_id></t_image_format_id>
-			<image_format_id>1</image_format_id>
-			<t_height></t_height>
-			<height>120</height>
-			<t_width></t_width>
-			<width>500</width>
-			<t_auto_scale></t_auto_scale>
-			<auto_scale>on</auto_scale>
-			<t_auto_scale_opts></t_auto_scale_opts>
-			<auto_scale_opts>2</auto_scale_opts>
-			<t_auto_scale_log></t_auto_scale_log>
-			<auto_scale_log></auto_scale_log>
-			<t_auto_scale_rigid></t_auto_scale_rigid>
-			<auto_scale_rigid></auto_scale_rigid>
-			<t_auto_padding></t_auto_padding>
-			<auto_padding>on</auto_padding>
-			<t_export></t_export>
-			<export>on</export>
-			<t_upper_limit></t_upper_limit>
-			<upper_limit>10000</upper_limit>
-			<t_lower_limit></t_lower_limit>
-			<lower_limit>0</lower_limit>
-			<t_base_value></t_base_value>
-			<base_value>1000</base_value>
-			<t_unit_value></t_unit_value>
-			<unit_value></unit_value>
-			<t_unit_exponent_value></t_unit_exponent_value>
-			<unit_exponent_value></unit_exponent_value>
-			<t_vertical_label></t_vertical_label>
-			<vertical_label></vertical_label>
-		</graph>
-		<items>
-			<hash_1000131ecaf3728447913a30dfa80cdd9cdff4>
-				<task_item_id>hash_080013230e04055a4228154123e74c6586d435</task_item_id>
-				<color_id>0000FF</color_id>
-				<graph_type_id>5</graph_type_id>
-				<consolidation_function_id>1</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Total Sessions:</text_format>
-				<hard_return></hard_return>
-				<sequence>5</sequence>
-			</hash_1000131ecaf3728447913a30dfa80cdd9cdff4>
-			<hash_1000132171a00b34d33f99ef24bcc235fbb6a3>
-				<task_item_id>hash_080013230e04055a4228154123e74c6586d435</task_item_id>
-				<color_id>0</color_id>
-				<graph_type_id>9</graph_type_id>
-				<consolidation_function_id>4</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Current:</text_format>
-				<hard_return></hard_return>
-				<sequence>6</sequence>
-			</hash_1000132171a00b34d33f99ef24bcc235fbb6a3>
-			<hash_1000132129590e72a46480422f85e063d8cf4d>
-				<task_item_id>hash_080013230e04055a4228154123e74c6586d435</task_item_id>
-				<color_id>0</color_id>
-				<graph_type_id>9</graph_type_id>
-				<consolidation_function_id>1</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Average:</text_format>
-				<hard_return></hard_return>
-				<sequence>7</sequence>
-			</hash_1000132129590e72a46480422f85e063d8cf4d>
-			<hash_1000138d11fec869f88ccf2fa3227bcffadfc3>
-				<task_item_id>hash_080013230e04055a4228154123e74c6586d435</task_item_id>
-				<color_id>0</color_id>
-				<graph_type_id>9</graph_type_id>
-				<consolidation_function_id>3</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Maximum:</text_format>
-				<hard_return>on</hard_return>
-				<sequence>8</sequence>
-			</hash_1000138d11fec869f88ccf2fa3227bcffadfc3>
-			<hash_100013783d295131617ad996e4699533a134ea>
-				<task_item_id>hash_080013088549c8d7e8cdc80f19bae4d78dc296</task_item_id>
-				<color_id>EA8F00</color_id>
-				<graph_type_id>5</graph_type_id>
-				<consolidation_function_id>1</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Response Errors:</text_format>
-				<hard_return></hard_return>
-				<sequence>9</sequence>
-			</hash_100013783d295131617ad996e4699533a134ea>
-			<hash_1000139bc04e5072b25ca992ee0b0eec981b95>
-				<task_item_id>hash_080013088549c8d7e8cdc80f19bae4d78dc296</task_item_id>
-				<color_id>0</color_id>
-				<graph_type_id>9</graph_type_id>
-				<consolidation_function_id>4</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Current:</text_format>
-				<hard_return></hard_return>
-				<sequence>10</sequence>
-			</hash_1000139bc04e5072b25ca992ee0b0eec981b95>
-			<hash_1000136333a9334fa0dc0d2f75c031dee1dcc5>
-				<task_item_id>hash_080013088549c8d7e8cdc80f19bae4d78dc296</task_item_id>
-				<color_id>0</color_id>
-				<graph_type_id>9</graph_type_id>
-				<consolidation_function_id>1</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Average:</text_format>
-				<hard_return></hard_return>
-				<sequence>11</sequence>
-			</hash_1000136333a9334fa0dc0d2f75c031dee1dcc5>
-			<hash_10001386e0e18d79915cd21ff123fb830e150e>
-				<task_item_id>hash_080013088549c8d7e8cdc80f19bae4d78dc296</task_item_id>
-				<color_id>0</color_id>
-				<graph_type_id>9</graph_type_id>
-				<consolidation_function_id>3</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Maximum:</text_format>
-				<hard_return>on</hard_return>
-				<sequence>12</sequence>
-			</hash_10001386e0e18d79915cd21ff123fb830e150e>
-			<hash_100013206b0b016daf267ff0a1daa7733ecf25>
-				<task_item_id>0</task_item_id>
-				<color_id>0</color_id>
-				<graph_type_id>1</graph_type_id>
-				<consolidation_function_id>1</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Graph Last Updated: |date_time|</text_format>
-				<hard_return>on</hard_return>
-				<sequence>13</sequence>
-			</hash_100013206b0b016daf267ff0a1daa7733ecf25>
-		</items>
-		<inputs>
-			<hash_090013871102d568ae1a0d7d79aa4b0d3a6411>
-				<name>Data Source [TotalSessions]</name>
-				<description></description>
-				<column_name>task_item_id</column_name>
-				<items>hash_0000131ecaf3728447913a30dfa80cdd9cdff4|hash_0000132171a00b34d33f99ef24bcc235fbb6a3|hash_0000132129590e72a46480422f85e063d8cf4d|hash_0000138d11fec869f88ccf2fa3227bcffadfc3</items>
-			</hash_090013871102d568ae1a0d7d79aa4b0d3a6411>
-			<hash_090013320fd0edeb30465be51274fa3ecbe168>
-				<name>Data Source [ResponseErrors]</name>
-				<description></description>
-				<column_name>task_item_id</column_name>
-				<items>hash_000013783d295131617ad996e4699533a134ea|hash_0000139bc04e5072b25ca992ee0b0eec981b95|hash_0000136333a9334fa0dc0d2f75c031dee1dcc5|hash_00001386e0e18d79915cd21ff123fb830e150e</items>
-			</hash_090013320fd0edeb30465be51274fa3ecbe168>
-		</inputs>
-	</hash_000013cdbf9accfcd57d9e0a7c97896313ddee>
-	<hash_000013b6d238ff2532fcc19ab498043c7c65c2>
-		<name>HAProxy Backend Traffic</name>
-		<graph>
-			<t_title></t_title>
-			<title>|host_description| - HaProxy |query_bePxName| Backend Traffic</title>
-			<t_image_format_id></t_image_format_id>
-			<image_format_id>1</image_format_id>
-			<t_height></t_height>
-			<height>120</height>
-			<t_width></t_width>
-			<width>500</width>
-			<t_auto_scale></t_auto_scale>
-			<auto_scale>on</auto_scale>
-			<t_auto_scale_opts></t_auto_scale_opts>
-			<auto_scale_opts>2</auto_scale_opts>
-			<t_auto_scale_log></t_auto_scale_log>
-			<auto_scale_log></auto_scale_log>
-			<t_auto_scale_rigid></t_auto_scale_rigid>
-			<auto_scale_rigid></auto_scale_rigid>
-			<t_auto_padding></t_auto_padding>
-			<auto_padding>on</auto_padding>
-			<t_export></t_export>
-			<export>on</export>
-			<t_upper_limit></t_upper_limit>
-			<upper_limit>10000000000</upper_limit>
-			<t_lower_limit></t_lower_limit>
-			<lower_limit>0</lower_limit>
-			<t_base_value></t_base_value>
-			<base_value>1024</base_value>
-			<t_unit_value></t_unit_value>
-			<unit_value></unit_value>
-			<t_unit_exponent_value></t_unit_exponent_value>
-			<unit_exponent_value></unit_exponent_value>
-			<t_vertical_label></t_vertical_label>
-			<vertical_label>bytes</vertical_label>
-		</graph>
-		<items>
-			<hash_100013184e60d8dac2421c2787887fe07f6d25>
-				<task_item_id>hash_0800132f5283f17a7cde63137189d4d3ea7e4e</task_item_id>
-				<color_id>6EA100</color_id>
-				<graph_type_id>5</graph_type_id>
-				<consolidation_function_id>1</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Ingress Traffic:</text_format>
-				<hard_return></hard_return>
-				<sequence>2</sequence>
-			</hash_100013184e60d8dac2421c2787887fe07f6d25>
-			<hash_100013f3889b4094b935798483e489b5f5e16e>
-				<task_item_id>hash_0800132f5283f17a7cde63137189d4d3ea7e4e</task_item_id>
-				<color_id>0</color_id>
-				<graph_type_id>9</graph_type_id>
-				<consolidation_function_id>4</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Current:</text_format>
-				<hard_return></hard_return>
-				<sequence>3</sequence>
-			</hash_100013f3889b4094b935798483e489b5f5e16e>
-			<hash_1000134bbdf263db6461f5d76717c12564c42c>
-				<task_item_id>hash_0800132f5283f17a7cde63137189d4d3ea7e4e</task_item_id>
-				<color_id>0</color_id>
-				<graph_type_id>9</graph_type_id>
-				<consolidation_function_id>1</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Average:</text_format>
-				<hard_return></hard_return>
-				<sequence>4</sequence>
-			</hash_1000134bbdf263db6461f5d76717c12564c42c>
-			<hash_1000131b708578244e36caba0f4dea67230c80>
-				<task_item_id>hash_0800132f5283f17a7cde63137189d4d3ea7e4e</task_item_id>
-				<color_id>0</color_id>
-				<graph_type_id>9</graph_type_id>
-				<consolidation_function_id>3</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Maximum:</text_format>
-				<hard_return>on</hard_return>
-				<sequence>5</sequence>
-			</hash_1000131b708578244e36caba0f4dea67230c80>
-			<hash_1000133e2f02edb1a55bcdd20e925a3849fd37>
-				<task_item_id>hash_0800136c0e4debeb9b084231d858faabd82f8f</task_item_id>
-				<color_id>FF0000</color_id>
-				<graph_type_id>5</graph_type_id>
-				<consolidation_function_id>1</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Egress Traffic:</text_format>
-				<hard_return></hard_return>
-				<sequence>6</sequence>
-			</hash_1000133e2f02edb1a55bcdd20e925a3849fd37>
-			<hash_1000134517c9799c71e03dcd2278681858d70f>
-				<task_item_id>hash_0800136c0e4debeb9b084231d858faabd82f8f</task_item_id>
-				<color_id>0</color_id>
-				<graph_type_id>9</graph_type_id>
-				<consolidation_function_id>4</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Current:</text_format>
-				<hard_return></hard_return>
-				<sequence>7</sequence>
-			</hash_1000134517c9799c71e03dcd2278681858d70f>
-			<hash_1000132edf24a4592c9537d2341ec20c588fc2>
-				<task_item_id>hash_0800136c0e4debeb9b084231d858faabd82f8f</task_item_id>
-				<color_id>0</color_id>
-				<graph_type_id>9</graph_type_id>
-				<consolidation_function_id>1</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Average:</text_format>
-				<hard_return></hard_return>
-				<sequence>8</sequence>
-			</hash_1000132edf24a4592c9537d2341ec20c588fc2>
-			<hash_100013150e680935bfccc75f1f88c7c60030f7>
-				<task_item_id>hash_0800136c0e4debeb9b084231d858faabd82f8f</task_item_id>
-				<color_id>0</color_id>
-				<graph_type_id>9</graph_type_id>
-				<consolidation_function_id>3</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Maximum:</text_format>
-				<hard_return>on</hard_return>
-				<sequence>9</sequence>
-			</hash_100013150e680935bfccc75f1f88c7c60030f7>
-			<hash_1000135dcb7625a1a21d8d94fdf2f97d302a42>
-				<task_item_id>0</task_item_id>
-				<color_id>0</color_id>
-				<graph_type_id>1</graph_type_id>
-				<consolidation_function_id>1</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Graph Last Updated: |date_time|</text_format>
-				<hard_return>on</hard_return>
-				<sequence>10</sequence>
-			</hash_1000135dcb7625a1a21d8d94fdf2f97d302a42>
-		</items>
-		<inputs>
-			<hash_090013952f2971b58b10f88a55d63a0388a429>
-				<name>Data Source [BytesIn]</name>
-				<description></description>
-				<column_name>task_item_id</column_name>
-				<items>hash_000013184e60d8dac2421c2787887fe07f6d25|hash_000013f3889b4094b935798483e489b5f5e16e|hash_0000134bbdf263db6461f5d76717c12564c42c|hash_0000131b708578244e36caba0f4dea67230c80</items>
-			</hash_090013952f2971b58b10f88a55d63a0388a429>
-			<hash_09001393a65aa111654d6801846a6cb523580b>
-				<name>Data Source [BytesOut]</name>
-				<description></description>
-				<column_name>task_item_id</column_name>
-				<items>hash_0000133e2f02edb1a55bcdd20e925a3849fd37|hash_0000134517c9799c71e03dcd2278681858d70f|hash_0000132edf24a4592c9537d2341ec20c588fc2|hash_000013150e680935bfccc75f1f88c7c60030f7</items>
-			</hash_09001393a65aa111654d6801846a6cb523580b>
-		</inputs>
-	</hash_000013b6d238ff2532fcc19ab498043c7c65c2>
-	<hash_010013fa4d4fff334b60e9064e89082173fe34>
-		<name>HAProxy Backend Session Stats</name>
-		<ds>
-			<t_name></t_name>
-			<name>|host_description| - Haproxy - |query_bePxName| Backend Session Stats</name>
-			<data_input_id>hash_030013bf566c869ac6443b0c75d1c32b5a350e</data_input_id>
-			<t_rra_id></t_rra_id>
-			<t_rrd_step></t_rrd_step>
-			<rrd_step>300</rrd_step>
-			<t_active></t_active>
-			<active>on</active>
-			<rra_items>hash_150013c21df5178e5c955013591239eb0afd46|hash_1500130d9c0af8b8acdc7807943937b3208e29|hash_1500136fc2d038fb42950138b0ce3e9874cc60|hash_150013e36f3adb9f152adfa5dc50fd2b23337e|hash_15001352829408ab566127eede2c74d201c678|hash_150013e73fb797d3ab2a9b97c3ec29e9690910</rra_items>
-		</ds>
-		<items>
-			<hash_080013230e04055a4228154123e74c6586d435>
-				<t_data_source_name></t_data_source_name>
-				<data_source_name>TotalSessions</data_source_name>
-				<t_rrd_minimum></t_rrd_minimum>
-				<rrd_minimum>0</rrd_minimum>
-				<t_rrd_maximum></t_rrd_maximum>
-				<rrd_maximum>10000</rrd_maximum>
-				<t_data_source_type_id></t_data_source_type_id>
-				<data_source_type_id>2</data_source_type_id>
-				<t_rrd_heartbeat></t_rrd_heartbeat>
-				<rrd_heartbeat>600</rrd_heartbeat>
-				<t_data_input_field_id></t_data_input_field_id>
-				<data_input_field_id>0</data_input_field_id>
-			</hash_080013230e04055a4228154123e74c6586d435>
-			<hash_080013088549c8d7e8cdc80f19bae4d78dc296>
-				<t_data_source_name></t_data_source_name>
-				<data_source_name>ResponseErrors</data_source_name>
-				<t_rrd_minimum></t_rrd_minimum>
-				<rrd_minimum>0</rrd_minimum>
-				<t_rrd_maximum></t_rrd_maximum>
-				<rrd_maximum>10000</rrd_maximum>
-				<t_data_source_type_id></t_data_source_type_id>
-				<data_source_type_id>2</data_source_type_id>
-				<t_rrd_heartbeat></t_rrd_heartbeat>
-				<rrd_heartbeat>600</rrd_heartbeat>
-				<t_data_input_field_id></t_data_input_field_id>
-				<data_input_field_id>0</data_input_field_id>
-			</hash_080013088549c8d7e8cdc80f19bae4d78dc296>
-		</items>
-		<data>
-			<item_000>
-				<data_input_field_id>hash_070013c1f36ee60c3dc98945556d57f26e475b</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_000>
-			<item_001>
-				<data_input_field_id>hash_070013e6deda7be0f391399c5130e7c4a48b28</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_001>
-			<item_002>
-				<data_input_field_id>hash_070013cbbe5c1ddfb264a6e5d509ce1c78c95f</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_002>
-			<item_003>
-				<data_input_field_id>hash_0700136027a919c7c7731fbe095b6f53ab127b</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_003>
-			<item_004>
-				<data_input_field_id>hash_070013b5c23f246559df38662c255f4aa21d6b</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_004>
-			<item_005>
-				<data_input_field_id>hash_0700131cc1493a6781af2c478fa4de971531cf</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_005>
-			<item_006>
-				<data_input_field_id>hash_070013f4facc5e2ca7ebee621f09bc6d9fc792</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_006>
-			<item_007>
-				<data_input_field_id>hash_070013acb449d1451e8a2a655c2c99d31142c7</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_007>
-			<item_008>
-				<data_input_field_id>hash_070013617cdc8a230615e59f06f361ef6e7728</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_008>
-		</data>
-	</hash_010013fa4d4fff334b60e9064e89082173fe34>
-	<hash_010013a63ddba34026d2c07d73c0ef2ae64b54>
-		<name>HAProxy Backend Traffic Stats</name>
-		<ds>
-			<t_name></t_name>
-			<name>|host_description| - Haproxy - |query_bePxName| Backend Traffic Stats</name>
-			<data_input_id>hash_030013bf566c869ac6443b0c75d1c32b5a350e</data_input_id>
-			<t_rra_id></t_rra_id>
-			<t_rrd_step></t_rrd_step>
-			<rrd_step>300</rrd_step>
-			<t_active></t_active>
-			<active>on</active>
-			<rra_items>hash_150013c21df5178e5c955013591239eb0afd46|hash_1500130d9c0af8b8acdc7807943937b3208e29|hash_1500136fc2d038fb42950138b0ce3e9874cc60|hash_150013e36f3adb9f152adfa5dc50fd2b23337e|hash_150013a4aa6f4de84eaa00008f88d3f5bd8520|hash_150013e73fb797d3ab2a9b97c3ec29e9690910</rra_items>
-		</ds>
-		<items>
-			<hash_0800136c0e4debeb9b084231d858faabd82f8f>
-				<t_data_source_name></t_data_source_name>
-				<data_source_name>BytesOut</data_source_name>
-				<t_rrd_minimum></t_rrd_minimum>
-				<rrd_minimum>0</rrd_minimum>
-				<t_rrd_maximum></t_rrd_maximum>
-				<rrd_maximum>10000000000</rrd_maximum>
-				<t_data_source_type_id></t_data_source_type_id>
-				<data_source_type_id>2</data_source_type_id>
-				<t_rrd_heartbeat></t_rrd_heartbeat>
-				<rrd_heartbeat>600</rrd_heartbeat>
-				<t_data_input_field_id></t_data_input_field_id>
-				<data_input_field_id>0</data_input_field_id>
-			</hash_0800136c0e4debeb9b084231d858faabd82f8f>
-			<hash_0800132f5283f17a7cde63137189d4d3ea7e4e>
-				<t_data_source_name></t_data_source_name>
-				<data_source_name>BytesIn</data_source_name>
-				<t_rrd_minimum></t_rrd_minimum>
-				<rrd_minimum>0</rrd_minimum>
-				<t_rrd_maximum></t_rrd_maximum>
-				<rrd_maximum>10000000000</rrd_maximum>
-				<t_data_source_type_id></t_data_source_type_id>
-				<data_source_type_id>2</data_source_type_id>
-				<t_rrd_heartbeat></t_rrd_heartbeat>
-				<rrd_heartbeat>600</rrd_heartbeat>
-				<t_data_input_field_id></t_data_input_field_id>
-				<data_input_field_id>0</data_input_field_id>
-			</hash_0800132f5283f17a7cde63137189d4d3ea7e4e>
-		</items>
-		<data>
-			<item_000>
-				<data_input_field_id>hash_070013c1f36ee60c3dc98945556d57f26e475b</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_000>
-			<item_001>
-				<data_input_field_id>hash_070013e6deda7be0f391399c5130e7c4a48b28</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_001>
-			<item_002>
-				<data_input_field_id>hash_070013cbbe5c1ddfb264a6e5d509ce1c78c95f</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_002>
-			<item_003>
-				<data_input_field_id>hash_0700136027a919c7c7731fbe095b6f53ab127b</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_003>
-			<item_004>
-				<data_input_field_id>hash_070013b5c23f246559df38662c255f4aa21d6b</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_004>
-			<item_005>
-				<data_input_field_id>hash_0700131cc1493a6781af2c478fa4de971531cf</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_005>
-			<item_006>
-				<data_input_field_id>hash_070013f4facc5e2ca7ebee621f09bc6d9fc792</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_006>
-			<item_007>
-				<data_input_field_id>hash_070013acb449d1451e8a2a655c2c99d31142c7</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_007>
-			<item_008>
-				<data_input_field_id>hash_070013617cdc8a230615e59f06f361ef6e7728</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_008>
-		</data>
-	</hash_010013a63ddba34026d2c07d73c0ef2ae64b54>
-	<hash_150013c21df5178e5c955013591239eb0afd46>
-		<name>Daily (5 Minute Average)</name>
-		<x_files_factor>0.5</x_files_factor>
-		<steps>1</steps>
-		<rows>600</rows>
-		<timespan>86400</timespan>
-		<cf_items>1|2|3|4</cf_items>
-	</hash_150013c21df5178e5c955013591239eb0afd46>
-	<hash_1500130d9c0af8b8acdc7807943937b3208e29>
-		<name>Weekly (30 Minute Average)</name>
-		<x_files_factor>0.5</x_files_factor>
-		<steps>6</steps>
-		<rows>700</rows>
-		<timespan>604800</timespan>
-		<cf_items>1|2|3|4</cf_items>
-	</hash_1500130d9c0af8b8acdc7807943937b3208e29>
-	<hash_1500136fc2d038fb42950138b0ce3e9874cc60>
-		<name>Monthly (2 Hour Average)</name>
-		<x_files_factor>0.5</x_files_factor>
-		<steps>24</steps>
-		<rows>775</rows>
-		<timespan>2678400</timespan>
-		<cf_items>1|2|3|4</cf_items>
-	</hash_1500136fc2d038fb42950138b0ce3e9874cc60>
-	<hash_150013e36f3adb9f152adfa5dc50fd2b23337e>
-		<name>Yearly (1 Day Average)</name>
-		<x_files_factor>0.5</x_files_factor>
-		<steps>288</steps>
-		<rows>797</rows>
-		<timespan>33053184</timespan>
-		<cf_items>1|2|3|4</cf_items>
-	</hash_150013e36f3adb9f152adfa5dc50fd2b23337e>
-	<hash_1500130028a19ed71b758898eaa55ab1c59694>
-		<name>Three days (5 minutes average)</name>
-		<x_files_factor>0.5</x_files_factor>
-		<steps>6</steps>
-		<rows>700</rows>
-		<timespan>302400</timespan>
-		<cf_items>1|2|3|4</cf_items>
-	</hash_1500130028a19ed71b758898eaa55ab1c59694>
-	<hash_150013e73fb797d3ab2a9b97c3ec29e9690910>
-		<name>Hourly (1 Minute Average)</name>
-		<x_files_factor>0.5</x_files_factor>
-		<steps>1</steps>
-		<rows>500</rows>
-		<timespan>14400</timespan>
-		<cf_items>1|3</cf_items>
-	</hash_150013e73fb797d3ab2a9b97c3ec29e9690910>
-	<hash_060013e9c43831e54eca8069317a2ce8c6f751>
-		<name>Normal</name>
-		<gprint_text>%8.2lf %s</gprint_text>
-	</hash_060013e9c43831e54eca8069317a2ce8c6f751>
-</cacti>
\ No newline at end of file
diff --git a/deps/haproxy-1.4.21/contrib/netsnmp-perl/cacti_data_query_haproxy_frontends.xml b/deps/haproxy-1.4.21/contrib/netsnmp-perl/cacti_data_query_haproxy_frontends.xml
deleted file mode 100644
index 67508d7..0000000
--- a/deps/haproxy-1.4.21/contrib/netsnmp-perl/cacti_data_query_haproxy_frontends.xml
+++ /dev/null
@@ -1,750 +0,0 @@
-<cacti>	
-	<hash_0400138cb70c1064bd60742726af23828c4b05>
-		<name>HAProxy Frontends</name>
-		<description></description>
-		<xml_path>&lt;path_cacti&gt;/resource/snmp_queries/haproxy_frontend.xml</xml_path>
-		<data_input_id>hash_030013bf566c869ac6443b0c75d1c32b5a350e</data_input_id>
-		<graphs>
-			<hash_110013c1c2bca3af0ae4e2ce0de096aa79dba5>
-				<name>HAProxy Frontend Sessions</name>
-				<graph_template_id>hash_00001328b6727aa54dde6bb3f5dde939ae03aa</graph_template_id>
-				<rrd>
-					<item_000>
-						<snmp_field_name>feSTot</snmp_field_name>
-						<data_template_id>hash_0100139f985697a7530256b4e35c95ef03db20</data_template_id>
-						<data_template_rrd_id>hash_080013f9c76e05d0a87b2d32f9a5b014e17aab</data_template_rrd_id>
-					</item_000>
-					<item_001>
-						<snmp_field_name>feEReq</snmp_field_name>
-						<data_template_id>hash_0100139f985697a7530256b4e35c95ef03db20</data_template_id>
-						<data_template_rrd_id>hash_080013c137bec94d7220e65a5b3dfa4049c242</data_template_rrd_id>
-					</item_001>
-				</rrd>
-				<sv_graph>
-					<hash_1200130f0e4ffcd11f807d23794ab805d7901a>
-						<field_name>TotalSessions</field_name>
-						<sequence>1</sequence>
-						<text>TotalSessions</text>
-					</hash_1200130f0e4ffcd11f807d23794ab805d7901a>
-					<hash_1200134fc506db9ce45c0e5cb38a429ad8e077>
-						<field_name>RequestErrors</field_name>
-						<sequence>1</sequence>
-						<text>RequestErrors</text>
-					</hash_1200134fc506db9ce45c0e5cb38a429ad8e077>
-				</sv_graph>
-				<sv_data_source>
-					<hash_1300138a5efc51c95b400c3139b352ce110969>
-						<field_name>RequestErrors</field_name>
-						<data_template_id>hash_0100139f985697a7530256b4e35c95ef03db20</data_template_id>
-						<sequence>1</sequence>
-						<text>RequestErrors</text>
-					</hash_1300138a5efc51c95b400c3139b352ce110969>
-					<hash_130013e374903ab025bc2728f2f9abeb412ac3>
-						<field_name>TotalSessions</field_name>
-						<data_template_id>hash_0100139f985697a7530256b4e35c95ef03db20</data_template_id>
-						<sequence>1</sequence>
-						<text>TotalSessions</text>
-					</hash_130013e374903ab025bc2728f2f9abeb412ac3>
-				</sv_data_source>
-			</hash_110013c1c2bca3af0ae4e2ce0de096aa79dba5>
-			<hash_1100130838495d5d82f25f4a675ee7c56543a5>
-				<name>HAProxy Frontend Traffic</name>
-				<graph_template_id>hash_000013d0fe9e9efc2746de488fdede0419b051</graph_template_id>
-				<rrd>
-					<item_000>
-						<snmp_field_name>feBOut</snmp_field_name>
-						<data_template_id>hash_010013a88327df77ea19e333ddd96096c34751</data_template_id>
-						<data_template_rrd_id>hash_0800137db81cd58fbbbd203af0f55c15c2081a</data_template_rrd_id>
-					</item_000>
-					<item_001>
-						<snmp_field_name>feBIn</snmp_field_name>
-						<data_template_id>hash_010013a88327df77ea19e333ddd96096c34751</data_template_id>
-						<data_template_rrd_id>hash_08001305772980bb6de1f12223d7ec53e323c4</data_template_rrd_id>
-					</item_001>
-				</rrd>
-				<sv_graph>
-					<hash_120013934d1311136bccb4d9ca5a67e240afeb>
-						<field_name>BytesIn</field_name>
-						<sequence>1</sequence>
-						<text>BytesIn</text>
-					</hash_120013934d1311136bccb4d9ca5a67e240afeb>
-					<hash_12001399a6e6fb09b025bc60a214cb00e6d1f0>
-						<field_name>BytesOut</field_name>
-						<sequence>1</sequence>
-						<text>BytesOut</text>
-					</hash_12001399a6e6fb09b025bc60a214cb00e6d1f0>
-				</sv_graph>
-				<sv_data_source>
-					<hash_1300135f35cdaeda1a1169be21e52a85af339e>
-						<field_name>BytesOut</field_name>
-						<data_template_id>hash_0100139f985697a7530256b4e35c95ef03db20</data_template_id>
-						<sequence>1</sequence>
-						<text>BytesOut</text>
-					</hash_1300135f35cdaeda1a1169be21e52a85af339e>
-					<hash_1300136ee916a0c0ce8dad133b9dfcf32e2581>
-						<field_name>BytesIn</field_name>
-						<data_template_id>hash_0100139f985697a7530256b4e35c95ef03db20</data_template_id>
-						<sequence>1</sequence>
-						<text>BytesIn</text>
-					</hash_1300136ee916a0c0ce8dad133b9dfcf32e2581>
-					<hash_13001382c5a3b953f8d1583b168d15beed6e9c>
-						<field_name>BytesOut</field_name>
-						<data_template_id>hash_010013a88327df77ea19e333ddd96096c34751</data_template_id>
-						<sequence>1</sequence>
-						<text>BytesOut</text>
-					</hash_13001382c5a3b953f8d1583b168d15beed6e9c>
-					<hash_1300132c486fa1a5e875179031ea9f5328614b>
-						<field_name>BytesIn</field_name>
-						<data_template_id>hash_010013a88327df77ea19e333ddd96096c34751</data_template_id>
-						<sequence>1</sequence>
-						<text>BytesIn</text>
-					</hash_1300132c486fa1a5e875179031ea9f5328614b>
-				</sv_data_source>
-			</hash_1100130838495d5d82f25f4a675ee7c56543a5>
-		</graphs>
-	</hash_0400138cb70c1064bd60742726af23828c4b05>
-	<hash_030013bf566c869ac6443b0c75d1c32b5a350e>
-		<name>Get SNMP Data (Indexed)</name>
-		<type_id>3</type_id>
-		<input_string></input_string>
-		<fields>
-			<hash_070013617cdc8a230615e59f06f361ef6e7728>
-				<name>SNMP IP Address</name>
-				<update_rra></update_rra>
-				<regexp_match></regexp_match>
-				<allow_nulls></allow_nulls>
-				<type_code>hostname</type_code>
-				<input_output>in</input_output>
-				<data_name>management_ip</data_name>
-			</hash_070013617cdc8a230615e59f06f361ef6e7728>
-			<hash_070013acb449d1451e8a2a655c2c99d31142c7>
-				<name>SNMP Community</name>
-				<update_rra></update_rra>
-				<regexp_match></regexp_match>
-				<allow_nulls></allow_nulls>
-				<type_code>snmp_community</type_code>
-				<input_output>in</input_output>
-				<data_name>snmp_community</data_name>
-			</hash_070013acb449d1451e8a2a655c2c99d31142c7>
-			<hash_070013f4facc5e2ca7ebee621f09bc6d9fc792>
-				<name>SNMP Username (v3)</name>
-				<update_rra></update_rra>
-				<regexp_match></regexp_match>
-				<allow_nulls>on</allow_nulls>
-				<type_code>snmp_username</type_code>
-				<input_output>in</input_output>
-				<data_name>snmp_username</data_name>
-			</hash_070013f4facc5e2ca7ebee621f09bc6d9fc792>
-			<hash_0700131cc1493a6781af2c478fa4de971531cf>
-				<name>SNMP Password (v3)</name>
-				<update_rra></update_rra>
-				<regexp_match></regexp_match>
-				<allow_nulls>on</allow_nulls>
-				<type_code>snmp_password</type_code>
-				<input_output>in</input_output>
-				<data_name>snmp_password</data_name>
-			</hash_0700131cc1493a6781af2c478fa4de971531cf>
-			<hash_070013b5c23f246559df38662c255f4aa21d6b>
-				<name>SNMP Version (1, 2, or 3)</name>
-				<update_rra></update_rra>
-				<regexp_match></regexp_match>
-				<allow_nulls></allow_nulls>
-				<type_code>snmp_version</type_code>
-				<input_output>in</input_output>
-				<data_name>snmp_version</data_name>
-			</hash_070013b5c23f246559df38662c255f4aa21d6b>
-			<hash_0700136027a919c7c7731fbe095b6f53ab127b>
-				<name>Index Type</name>
-				<update_rra></update_rra>
-				<regexp_match></regexp_match>
-				<allow_nulls></allow_nulls>
-				<type_code>index_type</type_code>
-				<input_output>in</input_output>
-				<data_name>index_type</data_name>
-			</hash_0700136027a919c7c7731fbe095b6f53ab127b>
-			<hash_070013cbbe5c1ddfb264a6e5d509ce1c78c95f>
-				<name>Index Value</name>
-				<update_rra></update_rra>
-				<regexp_match></regexp_match>
-				<allow_nulls></allow_nulls>
-				<type_code>index_value</type_code>
-				<input_output>in</input_output>
-				<data_name>index_value</data_name>
-			</hash_070013cbbe5c1ddfb264a6e5d509ce1c78c95f>
-			<hash_070013e6deda7be0f391399c5130e7c4a48b28>
-				<name>Output Type ID</name>
-				<update_rra></update_rra>
-				<regexp_match></regexp_match>
-				<allow_nulls></allow_nulls>
-				<type_code>output_type</type_code>
-				<input_output>in</input_output>
-				<data_name>output_type</data_name>
-			</hash_070013e6deda7be0f391399c5130e7c4a48b28>
-			<hash_070013c1f36ee60c3dc98945556d57f26e475b>
-				<name>SNMP Port</name>
-				<update_rra></update_rra>
-				<regexp_match></regexp_match>
-				<allow_nulls></allow_nulls>
-				<type_code>snmp_port</type_code>
-				<input_output>in</input_output>
-				<data_name>snmp_port</data_name>
-			</hash_070013c1f36ee60c3dc98945556d57f26e475b>
-		</fields>
-	</hash_030013bf566c869ac6443b0c75d1c32b5a350e>
-	<hash_00001328b6727aa54dde6bb3f5dde939ae03aa>
-		<name>HAProxy Frontend Sessions</name>
-		<graph>
-			<t_title></t_title>
-			<title>|host_description| - HaProxy - |query_fePxName| Frontend Sessions</title>
-			<t_image_format_id></t_image_format_id>
-			<image_format_id>1</image_format_id>
-			<t_height></t_height>
-			<height>120</height>
-			<t_width></t_width>
-			<width>500</width>
-			<t_auto_scale></t_auto_scale>
-			<auto_scale>on</auto_scale>
-			<t_auto_scale_opts></t_auto_scale_opts>
-			<auto_scale_opts>2</auto_scale_opts>
-			<t_auto_scale_log></t_auto_scale_log>
-			<auto_scale_log></auto_scale_log>
-			<t_auto_scale_rigid></t_auto_scale_rigid>
-			<auto_scale_rigid></auto_scale_rigid>
-			<t_auto_padding></t_auto_padding>
-			<auto_padding>on</auto_padding>
-			<t_export></t_export>
-			<export>on</export>
-			<t_upper_limit></t_upper_limit>
-			<upper_limit>10000</upper_limit>
-			<t_lower_limit></t_lower_limit>
-			<lower_limit>0</lower_limit>
-			<t_base_value></t_base_value>
-			<base_value>1000</base_value>
-			<t_unit_value></t_unit_value>
-			<unit_value></unit_value>
-			<t_unit_exponent_value></t_unit_exponent_value>
-			<unit_exponent_value></unit_exponent_value>
-			<t_vertical_label></t_vertical_label>
-			<vertical_label></vertical_label>
-		</graph>
-		<items>
-			<hash_100013b1ecfd75df9c17c0ba11acc5e9b7d8f8>
-				<task_item_id>hash_080013f9c76e05d0a87b2d32f9a5b014e17aab</task_item_id>
-				<color_id>0000FF</color_id>
-				<graph_type_id>5</graph_type_id>
-				<consolidation_function_id>1</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Total Sessions:</text_format>
-				<hard_return></hard_return>
-				<sequence>5</sequence>
-			</hash_100013b1ecfd75df9c17c0ba11acc5e9b7d8f8>
-			<hash_100013fa878148199aee5bb2a10b7693318347>
-				<task_item_id>hash_080013f9c76e05d0a87b2d32f9a5b014e17aab</task_item_id>
-				<color_id>0</color_id>
-				<graph_type_id>9</graph_type_id>
-				<consolidation_function_id>4</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Current:</text_format>
-				<hard_return></hard_return>
-				<sequence>6</sequence>
-			</hash_100013fa878148199aee5bb2a10b7693318347>
-			<hash_1000137d834c383afa4863974edc19a337e260>
-				<task_item_id>hash_080013f9c76e05d0a87b2d32f9a5b014e17aab</task_item_id>
-				<color_id>0</color_id>
-				<graph_type_id>9</graph_type_id>
-				<consolidation_function_id>1</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Average:</text_format>
-				<hard_return></hard_return>
-				<sequence>7</sequence>
-			</hash_1000137d834c383afa4863974edc19a337e260>
-			<hash_1000138b0422b293230883462cfbfe32144d47>
-				<task_item_id>hash_080013f9c76e05d0a87b2d32f9a5b014e17aab</task_item_id>
-				<color_id>0</color_id>
-				<graph_type_id>9</graph_type_id>
-				<consolidation_function_id>3</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Maximum:</text_format>
-				<hard_return>on</hard_return>
-				<sequence>8</sequence>
-			</hash_1000138b0422b293230883462cfbfe32144d47>
-			<hash_1000131c87ed4e76c026cd131418d792822944>
-				<task_item_id>hash_080013c137bec94d7220e65a5b3dfa4049c242</task_item_id>
-				<color_id>EA8F00</color_id>
-				<graph_type_id>5</graph_type_id>
-				<consolidation_function_id>1</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Request Errors:</text_format>
-				<hard_return></hard_return>
-				<sequence>9</sequence>
-			</hash_1000131c87ed4e76c026cd131418d792822944>
-			<hash_100013a9993114514cb1abea4b929f984222ea>
-				<task_item_id>hash_080013c137bec94d7220e65a5b3dfa4049c242</task_item_id>
-				<color_id>0</color_id>
-				<graph_type_id>9</graph_type_id>
-				<consolidation_function_id>4</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Current:</text_format>
-				<hard_return></hard_return>
-				<sequence>10</sequence>
-			</hash_100013a9993114514cb1abea4b929f984222ea>
-			<hash_1000131bc67adbaa8b77cd6c73d9622c7eebc1>
-				<task_item_id>hash_080013c137bec94d7220e65a5b3dfa4049c242</task_item_id>
-				<color_id>0</color_id>
-				<graph_type_id>9</graph_type_id>
-				<consolidation_function_id>1</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Average:</text_format>
-				<hard_return></hard_return>
-				<sequence>12</sequence>
-			</hash_1000131bc67adbaa8b77cd6c73d9622c7eebc1>
-			<hash_1000138840d17711368b90a61132ba83e9edb8>
-				<task_item_id>hash_080013c137bec94d7220e65a5b3dfa4049c242</task_item_id>
-				<color_id>0</color_id>
-				<graph_type_id>9</graph_type_id>
-				<consolidation_function_id>3</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Maximum:</text_format>
-				<hard_return>on</hard_return>
-				<sequence>13</sequence>
-			</hash_1000138840d17711368b90a61132ba83e9edb8>
-			<hash_100013e8ddbe92933ba99b2d2ebc8f76a06e2e>
-				<task_item_id>0</task_item_id>
-				<color_id>0</color_id>
-				<graph_type_id>1</graph_type_id>
-				<consolidation_function_id>1</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Graph Last Updated: |date_time|</text_format>
-				<hard_return>on</hard_return>
-				<sequence>14</sequence>
-			</hash_100013e8ddbe92933ba99b2d2ebc8f76a06e2e>
-		</items>
-		<inputs>
-			<hash_0900134bedc49c15c9557fc95cdbc8850a5cb1>
-				<name>Data Source [TotalSessions]</name>
-				<description></description>
-				<column_name>task_item_id</column_name>
-				<items>hash_000013b1ecfd75df9c17c0ba11acc5e9b7d8f8|hash_000013fa878148199aee5bb2a10b7693318347|hash_0000138b0422b293230883462cfbfe32144d47|hash_0000137d834c383afa4863974edc19a337e260</items>
-			</hash_0900134bedc49c15c9557fc95cdbc8850a5cb1>
-			<hash_090013f3f3dfd39bb035006de08df94415e828>
-				<name>Data Source [RequestErrors]</name>
-				<description></description>
-				<column_name>task_item_id</column_name>
-				<items>hash_0000131c87ed4e76c026cd131418d792822944|hash_000013a9993114514cb1abea4b929f984222ea|hash_0000131bc67adbaa8b77cd6c73d9622c7eebc1|hash_0000138840d17711368b90a61132ba83e9edb8</items>
-			</hash_090013f3f3dfd39bb035006de08df94415e828>
-		</inputs>
-	</hash_00001328b6727aa54dde6bb3f5dde939ae03aa>
-	<hash_000013d0fe9e9efc2746de488fdede0419b051>
-		<name>HAProxy Frontend Traffic</name>
-		<graph>
-			<t_title></t_title>
-			<title>|host_description| - HaProxy |query_fePxName| Frontend Traffic</title>
-			<t_image_format_id></t_image_format_id>
-			<image_format_id>1</image_format_id>
-			<t_height></t_height>
-			<height>120</height>
-			<t_width></t_width>
-			<width>500</width>
-			<t_auto_scale></t_auto_scale>
-			<auto_scale>on</auto_scale>
-			<t_auto_scale_opts></t_auto_scale_opts>
-			<auto_scale_opts>2</auto_scale_opts>
-			<t_auto_scale_log></t_auto_scale_log>
-			<auto_scale_log></auto_scale_log>
-			<t_auto_scale_rigid></t_auto_scale_rigid>
-			<auto_scale_rigid></auto_scale_rigid>
-			<t_auto_padding></t_auto_padding>
-			<auto_padding>on</auto_padding>
-			<t_export></t_export>
-			<export>on</export>
-			<t_upper_limit></t_upper_limit>
-			<upper_limit>10000000000</upper_limit>
-			<t_lower_limit></t_lower_limit>
-			<lower_limit>0</lower_limit>
-			<t_base_value></t_base_value>
-			<base_value>1024</base_value>
-			<t_unit_value></t_unit_value>
-			<unit_value></unit_value>
-			<t_unit_exponent_value></t_unit_exponent_value>
-			<unit_exponent_value></unit_exponent_value>
-			<t_vertical_label></t_vertical_label>
-			<vertical_label>bytes</vertical_label>
-		</graph>
-		<items>
-			<hash_100013d5c13ff711cbd645e9f88697b2c5e61b>
-				<task_item_id>hash_08001305772980bb6de1f12223d7ec53e323c4</task_item_id>
-				<color_id>6EA100</color_id>
-				<graph_type_id>5</graph_type_id>
-				<consolidation_function_id>1</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Ingress Traffic:</text_format>
-				<hard_return></hard_return>
-				<sequence>2</sequence>
-			</hash_100013d5c13ff711cbd645e9f88697b2c5e61b>
-			<hash_10001353cff0cd64c4d70574ef9da42f62c86a>
-				<task_item_id>hash_08001305772980bb6de1f12223d7ec53e323c4</task_item_id>
-				<color_id>0</color_id>
-				<graph_type_id>9</graph_type_id>
-				<consolidation_function_id>4</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Current:</text_format>
-				<hard_return></hard_return>
-				<sequence>3</sequence>
-			</hash_10001353cff0cd64c4d70574ef9da42f62c86a>
-			<hash_1000136788d44f6207ce323ad40ccc8f15d462>
-				<task_item_id>hash_08001305772980bb6de1f12223d7ec53e323c4</task_item_id>
-				<color_id>0</color_id>
-				<graph_type_id>9</graph_type_id>
-				<consolidation_function_id>1</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Average:</text_format>
-				<hard_return></hard_return>
-				<sequence>4</sequence>
-			</hash_1000136788d44f6207ce323ad40ccc8f15d462>
-			<hash_100013d4cb02a8fb7fa37ef1e37d8b78333ea3>
-				<task_item_id>hash_08001305772980bb6de1f12223d7ec53e323c4</task_item_id>
-				<color_id>0</color_id>
-				<graph_type_id>9</graph_type_id>
-				<consolidation_function_id>3</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Maximum:</text_format>
-				<hard_return>on</hard_return>
-				<sequence>5</sequence>
-			</hash_100013d4cb02a8fb7fa37ef1e37d8b78333ea3>
-			<hash_1000137d82a7f3c82c698fe4e9cecc03d680b1>
-				<task_item_id>hash_0800137db81cd58fbbbd203af0f55c15c2081a</task_item_id>
-				<color_id>FF0000</color_id>
-				<graph_type_id>5</graph_type_id>
-				<consolidation_function_id>1</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Egress Traffic:</text_format>
-				<hard_return></hard_return>
-				<sequence>6</sequence>
-			</hash_1000137d82a7f3c82c698fe4e9cecc03d680b1>
-			<hash_100013d2d059378b521327426b451324bbb608>
-				<task_item_id>hash_0800137db81cd58fbbbd203af0f55c15c2081a</task_item_id>
-				<color_id>0</color_id>
-				<graph_type_id>9</graph_type_id>
-				<consolidation_function_id>4</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Current:</text_format>
-				<hard_return></hard_return>
-				<sequence>7</sequence>
-			</hash_100013d2d059378b521327426b451324bbb608>
-			<hash_1000132eef0fae129ef21ad2d73e5e80814a23>
-				<task_item_id>hash_0800137db81cd58fbbbd203af0f55c15c2081a</task_item_id>
-				<color_id>0</color_id>
-				<graph_type_id>9</graph_type_id>
-				<consolidation_function_id>1</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Average:</text_format>
-				<hard_return></hard_return>
-				<sequence>8</sequence>
-			</hash_1000132eef0fae129ef21ad2d73e5e80814a23>
-			<hash_1000138365462951b1f4e6b1a76f20b91be65d>
-				<task_item_id>hash_0800137db81cd58fbbbd203af0f55c15c2081a</task_item_id>
-				<color_id>0</color_id>
-				<graph_type_id>9</graph_type_id>
-				<consolidation_function_id>3</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Maximum:</text_format>
-				<hard_return>on</hard_return>
-				<sequence>9</sequence>
-			</hash_1000138365462951b1f4e6b1a76f20b91be65d>
-			<hash_100013eefc9c0f83c57d6d6f8d75fbd45965a3>
-				<task_item_id>0</task_item_id>
-				<color_id>0</color_id>
-				<graph_type_id>1</graph_type_id>
-				<consolidation_function_id>1</consolidation_function_id>
-				<cdef_id>0</cdef_id>
-				<value></value>
-				<gprint_id>hash_060013e9c43831e54eca8069317a2ce8c6f751</gprint_id>
-				<text_format>Graph Last Updated: |date_time|</text_format>
-				<hard_return>on</hard_return>
-				<sequence>10</sequence>
-			</hash_100013eefc9c0f83c57d6d6f8d75fbd45965a3>
-		</items>
-		<inputs>
-			<hash_090013384e7b730bb32653e3fbce5ce509977d>
-				<name>Data Source [BytesOut]</name>
-				<description></description>
-				<column_name>task_item_id</column_name>
-				<items>hash_000013d2d059378b521327426b451324bbb608|hash_0000137d82a7f3c82c698fe4e9cecc03d680b1|hash_0000132eef0fae129ef21ad2d73e5e80814a23|hash_0000138365462951b1f4e6b1a76f20b91be65d</items>
-			</hash_090013384e7b730bb32653e3fbce5ce509977d>
-			<hash_090013e5ff60e3069b2d28d905f6affa63250e>
-				<name>Data Source [BytesIn]</name>
-				<description></description>
-				<column_name>task_item_id</column_name>
-				<items>hash_00001353cff0cd64c4d70574ef9da42f62c86a|hash_000013d5c13ff711cbd645e9f88697b2c5e61b|hash_0000136788d44f6207ce323ad40ccc8f15d462|hash_000013d4cb02a8fb7fa37ef1e37d8b78333ea3</items>
-			</hash_090013e5ff60e3069b2d28d905f6affa63250e>
-		</inputs>
-	</hash_000013d0fe9e9efc2746de488fdede0419b051>
-	<hash_0100139f985697a7530256b4e35c95ef03db20>
-		<name>HAProxy Frontend Session Stats</name>
-		<ds>
-			<t_name></t_name>
-			<name>|host_description| - Haproxy - |query_fePxName| Frontend Session Stats</name>
-			<data_input_id>hash_030013bf566c869ac6443b0c75d1c32b5a350e</data_input_id>
-			<t_rra_id></t_rra_id>
-			<t_rrd_step></t_rrd_step>
-			<rrd_step>300</rrd_step>
-			<t_active></t_active>
-			<active>on</active>
-			<rra_items>hash_150013c21df5178e5c955013591239eb0afd46|hash_1500130d9c0af8b8acdc7807943937b3208e29|hash_1500136fc2d038fb42950138b0ce3e9874cc60|hash_150013e36f3adb9f152adfa5dc50fd2b23337e|hash_1500139b529013942d5a6891d05a84d17175e0|hash_150013e73fb797d3ab2a9b97c3ec29e9690910</rra_items>
-		</ds>
-		<items>
-			<hash_080013c137bec94d7220e65a5b3dfa4049c242>
-				<t_data_source_name></t_data_source_name>
-				<data_source_name>RequestErrors</data_source_name>
-				<t_rrd_minimum></t_rrd_minimum>
-				<rrd_minimum>0</rrd_minimum>
-				<t_rrd_maximum></t_rrd_maximum>
-				<rrd_maximum>10000</rrd_maximum>
-				<t_data_source_type_id></t_data_source_type_id>
-				<data_source_type_id>2</data_source_type_id>
-				<t_rrd_heartbeat></t_rrd_heartbeat>
-				<rrd_heartbeat>600</rrd_heartbeat>
-				<t_data_input_field_id></t_data_input_field_id>
-				<data_input_field_id>0</data_input_field_id>
-			</hash_080013c137bec94d7220e65a5b3dfa4049c242>
-			<hash_080013f9c76e05d0a87b2d32f9a5b014e17aab>
-				<t_data_source_name></t_data_source_name>
-				<data_source_name>TotalSessions</data_source_name>
-				<t_rrd_minimum></t_rrd_minimum>
-				<rrd_minimum>0</rrd_minimum>
-				<t_rrd_maximum></t_rrd_maximum>
-				<rrd_maximum>10000</rrd_maximum>
-				<t_data_source_type_id></t_data_source_type_id>
-				<data_source_type_id>2</data_source_type_id>
-				<t_rrd_heartbeat></t_rrd_heartbeat>
-				<rrd_heartbeat>600</rrd_heartbeat>
-				<t_data_input_field_id></t_data_input_field_id>
-				<data_input_field_id>0</data_input_field_id>
-			</hash_080013f9c76e05d0a87b2d32f9a5b014e17aab>
-		</items>
-		<data>
-			<item_000>
-				<data_input_field_id>hash_070013c1f36ee60c3dc98945556d57f26e475b</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_000>
-			<item_001>
-				<data_input_field_id>hash_070013e6deda7be0f391399c5130e7c4a48b28</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_001>
-			<item_002>
-				<data_input_field_id>hash_070013cbbe5c1ddfb264a6e5d509ce1c78c95f</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_002>
-			<item_003>
-				<data_input_field_id>hash_0700136027a919c7c7731fbe095b6f53ab127b</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_003>
-			<item_004>
-				<data_input_field_id>hash_070013b5c23f246559df38662c255f4aa21d6b</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_004>
-			<item_005>
-				<data_input_field_id>hash_0700131cc1493a6781af2c478fa4de971531cf</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_005>
-			<item_006>
-				<data_input_field_id>hash_070013f4facc5e2ca7ebee621f09bc6d9fc792</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_006>
-			<item_007>
-				<data_input_field_id>hash_070013acb449d1451e8a2a655c2c99d31142c7</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_007>
-			<item_008>
-				<data_input_field_id>hash_070013617cdc8a230615e59f06f361ef6e7728</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_008>
-		</data>
-	</hash_0100139f985697a7530256b4e35c95ef03db20>
-	<hash_010013a88327df77ea19e333ddd96096c34751>
-		<name>HAProxy Frontend Traffic Stats</name>
-		<ds>
-			<t_name></t_name>
-			<name>|host_description| - Haproxy - |query_fePxName| Frontend Traffic Stats</name>
-			<data_input_id>hash_030013bf566c869ac6443b0c75d1c32b5a350e</data_input_id>
-			<t_rra_id></t_rra_id>
-			<t_rrd_step></t_rrd_step>
-			<rrd_step>300</rrd_step>
-			<t_active></t_active>
-			<active>on</active>
-			<rra_items>hash_150013c21df5178e5c955013591239eb0afd46|hash_1500130d9c0af8b8acdc7807943937b3208e29|hash_1500136fc2d038fb42950138b0ce3e9874cc60|hash_150013e36f3adb9f152adfa5dc50fd2b23337e|hash_15001369b0abdb84cea4d93762fd5a5d0c2777|hash_150013e73fb797d3ab2a9b97c3ec29e9690910</rra_items>
-		</ds>
-		<items>
-			<hash_0800137db81cd58fbbbd203af0f55c15c2081a>
-				<t_data_source_name></t_data_source_name>
-				<data_source_name>BytesOut</data_source_name>
-				<t_rrd_minimum></t_rrd_minimum>
-				<rrd_minimum>0</rrd_minimum>
-				<t_rrd_maximum></t_rrd_maximum>
-				<rrd_maximum>10000000000</rrd_maximum>
-				<t_data_source_type_id></t_data_source_type_id>
-				<data_source_type_id>2</data_source_type_id>
-				<t_rrd_heartbeat></t_rrd_heartbeat>
-				<rrd_heartbeat>600</rrd_heartbeat>
-				<t_data_input_field_id></t_data_input_field_id>
-				<data_input_field_id>0</data_input_field_id>
-			</hash_0800137db81cd58fbbbd203af0f55c15c2081a>
-			<hash_08001305772980bb6de1f12223d7ec53e323c4>
-				<t_data_source_name></t_data_source_name>
-				<data_source_name>BytesIn</data_source_name>
-				<t_rrd_minimum></t_rrd_minimum>
-				<rrd_minimum>0</rrd_minimum>
-				<t_rrd_maximum></t_rrd_maximum>
-				<rrd_maximum>10000000000</rrd_maximum>
-				<t_data_source_type_id></t_data_source_type_id>
-				<data_source_type_id>2</data_source_type_id>
-				<t_rrd_heartbeat></t_rrd_heartbeat>
-				<rrd_heartbeat>600</rrd_heartbeat>
-				<t_data_input_field_id></t_data_input_field_id>
-				<data_input_field_id>0</data_input_field_id>
-			</hash_08001305772980bb6de1f12223d7ec53e323c4>
-		</items>
-		<data>
-			<item_000>
-				<data_input_field_id>hash_070013c1f36ee60c3dc98945556d57f26e475b</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_000>
-			<item_001>
-				<data_input_field_id>hash_070013e6deda7be0f391399c5130e7c4a48b28</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_001>
-			<item_002>
-				<data_input_field_id>hash_070013cbbe5c1ddfb264a6e5d509ce1c78c95f</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_002>
-			<item_003>
-				<data_input_field_id>hash_0700136027a919c7c7731fbe095b6f53ab127b</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_003>
-			<item_004>
-				<data_input_field_id>hash_070013b5c23f246559df38662c255f4aa21d6b</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_004>
-			<item_005>
-				<data_input_field_id>hash_0700131cc1493a6781af2c478fa4de971531cf</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_005>
-			<item_006>
-				<data_input_field_id>hash_070013f4facc5e2ca7ebee621f09bc6d9fc792</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_006>
-			<item_007>
-				<data_input_field_id>hash_070013acb449d1451e8a2a655c2c99d31142c7</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_007>
-			<item_008>
-				<data_input_field_id>hash_070013617cdc8a230615e59f06f361ef6e7728</data_input_field_id>
-				<t_value></t_value>
-				<value></value>
-			</item_008>
-		</data>
-	</hash_010013a88327df77ea19e333ddd96096c34751>
-	<hash_150013c21df5178e5c955013591239eb0afd46>
-		<name>Daily (5 Minute Average)</name>
-		<x_files_factor>0.5</x_files_factor>
-		<steps>1</steps>
-		<rows>600</rows>
-		<timespan>86400</timespan>
-		<cf_items>1|2|3|4</cf_items>
-	</hash_150013c21df5178e5c955013591239eb0afd46>
-	<hash_1500130d9c0af8b8acdc7807943937b3208e29>
-		<name>Weekly (30 Minute Average)</name>
-		<x_files_factor>0.5</x_files_factor>
-		<steps>6</steps>
-		<rows>700</rows>
-		<timespan>604800</timespan>
-		<cf_items>1|2|3|4</cf_items>
-	</hash_1500130d9c0af8b8acdc7807943937b3208e29>
-	<hash_1500136fc2d038fb42950138b0ce3e9874cc60>
-		<name>Monthly (2 Hour Average)</name>
-		<x_files_factor>0.5</x_files_factor>
-		<steps>24</steps>
-		<rows>775</rows>
-		<timespan>2678400</timespan>
-		<cf_items>1|2|3|4</cf_items>
-	</hash_1500136fc2d038fb42950138b0ce3e9874cc60>
-	<hash_150013e36f3adb9f152adfa5dc50fd2b23337e>
-		<name>Yearly (1 Day Average)</name>
-		<x_files_factor>0.5</x_files_factor>
-		<steps>288</steps>
-		<rows>797</rows>
-		<timespan>33053184</timespan>
-		<cf_items>1|2|3|4</cf_items>
-	</hash_150013e36f3adb9f152adfa5dc50fd2b23337e>
-	<hash_1500136399acb234c65ef56054d5a82b23bc20>
-		<name>Three days (5 minutes average)</name>
-		<x_files_factor>0.5</x_files_factor>
-		<steps>6</steps>
-		<rows>700</rows>
-		<timespan>302400</timespan>
-		<cf_items>1|2|3|4</cf_items>
-	</hash_1500136399acb234c65ef56054d5a82b23bc20>
-	<hash_150013e73fb797d3ab2a9b97c3ec29e9690910>
-		<name>Hourly (1 Minute Average)</name>
-		<x_files_factor>0.5</x_files_factor>
-		<steps>1</steps>
-		<rows>500</rows>
-		<timespan>14400</timespan>
-		<cf_items>1|3</cf_items>
-	</hash_150013e73fb797d3ab2a9b97c3ec29e9690910>
-	<hash_060013e9c43831e54eca8069317a2ce8c6f751>
-		<name>Normal</name>
-		<gprint_text>%8.2lf %s</gprint_text>
-	</hash_060013e9c43831e54eca8069317a2ce8c6f751>
-</cacti>
\ No newline at end of file
diff --git a/deps/haproxy-1.4.21/contrib/netsnmp-perl/haproxy.pl b/deps/haproxy-1.4.21/contrib/netsnmp-perl/haproxy.pl
deleted file mode 100644
index f4c3621..0000000
--- a/deps/haproxy-1.4.21/contrib/netsnmp-perl/haproxy.pl
+++ /dev/null
@@ -1,249 +0,0 @@
-#
-# Net-SNMP perl plugin for Haproxy
-# Version 0.30
-#
-# Copyright 2007-2010 Krzysztof Piotr Oledzki <ole@ans.pl>
-#
-# 1. get a variable from "show stat":
-#  1.3.6.1.4.1.29385.106.1.$type.$field.$iid.$sid
-#   type: 0->frontend, 1->backend, 2->server, 3->socket
-#
-# 2. get a variable from "show info":
-#  1.3.6.1.4.1.29385.106.2.$req.$varnr
-#
-# TODO:
-# - implement read timeout
-#
-
-use NetSNMP::agent (':all');
-use NetSNMP::ASN qw(:all);
-use IO::Socket::UNIX;
-
-use strict;
-
-my $agent = new NetSNMP::agent('Name' => 'Haproxy');
-my $sa = "/var/run/haproxy.stat";
-
-use constant OID_HAPROXY => '1.3.6.1.4.1.29385.106';
-use constant OID_HAPROXY_STATS => OID_HAPROXY . '.1';
-use constant OID_HAPROXY_INFO => OID_HAPROXY . '.2';
-
-my $oid_stat = new NetSNMP::OID(OID_HAPROXY_STATS);
-my $oid_info = new NetSNMP::OID(OID_HAPROXY_INFO);
-
-use constant STATS_PXNAME => 0;
-use constant STATS_SVNAME => 1;
-use constant STATS_IID => 27;
-use constant STATS_SID => 28;
-use constant STATS_TYPE => 32;
-
-use constant FIELD_INDEX => 10001;
-use constant FIELD_NAME => 10002;
-
-my %info_vars = (
-	0	=> 'Name',
-	1	=> 'Version',
-	2	=> 'Release_date',
-	3	=> 'Nbproc',
-	4	=> 'Process_num',
-	5	=> 'Pid',
-	6	=> 'Uptime',
-	7	=> 'Uptime_sec',
-	8	=> 'Memmax_MB',
-	9	=> 'Ulimit-n',
-	10	=> 'Maxsock',
-	11	=> 'Maxconn',
-	12	=> 'Maxpipes',
-	13	=> 'CurrConns',
-	14	=> 'PipesUsed',
-	15	=> 'PipesFree',
-	16	=> 'Tasks',
-	17	=> 'Run_queue',
-	18	=> 'node',
-	19	=> 'description',
-);
-
-sub find_next_stat_id {
-	my($type, $field, $proxyid, $sid) = @_;
-
-	my $obj = 1 << $type;
-
-	my $np = -1;
-	my $nl = -1;
-
-	my $sock = new IO::Socket::UNIX (Peer => $sa, Type => SOCK_STREAM, Timeout => 1);
-	next if !$sock;
-
-	print $sock "show stat -1 $obj -1\n";
-
-	while(<$sock>) {
-		chomp;
-		my @d = split(',');
-
-		last if !$d[$field] && $field != FIELD_INDEX && $field != FIELD_NAME && /^#/;
-		next if /^#/;
-
-		next if $d[STATS_TYPE] != $type;
-
-		next if ($d[STATS_IID] < $proxyid) || ($d[STATS_IID] == $proxyid && $d[STATS_SID] <= $sid);
-
-		if ($np == -1 || $d[STATS_IID] < $np || ($d[STATS_IID] == $np && $d[STATS_SID] < $nl)) {
-			$np = $d[STATS_IID];
-			$nl = $d[STATS_SID];
-			next;
-		}
-	}
-
-	close($sock);
-
-	return 0 if ($np == -1);
-
-	return "$type.$field.$np.$nl"
-}
-
-sub haproxy_stat {
-	my($handler, $registration_info, $request_info, $requests) = @_;
-
-	for(my $request = $requests; $request; $request = $request->next()) {
-		my $oid = $request->getOID();
-
-		$oid =~ s/$oid_stat//;
-		$oid =~ s/^\.//;
-
-		my $mode = $request_info->getMode();
-
-		my($type, $field, $proxyid, $sid, $or) = split('\.', $oid, 5);
-
-		next if $type > 3 || defined($or);
-
-		if ($mode == MODE_GETNEXT) {
-
-			$type = 0 if !$type;
-			$field = 0 if !$field;
-			$proxyid = 0 if !$proxyid;
-			$sid = 0 if !$sid;
-
-			my $nextid = find_next_stat_id($type, $field, $proxyid, $sid);
-			$nextid = find_next_stat_id($type, $field+1, 0, 0) if !$nextid;
-			$nextid = find_next_stat_id($type+1, 0, 0, 0) if !$nextid;
-
-			if ($nextid) {
-				($type, $field, $proxyid, $sid) = split('\.', $nextid);
-				$request->setOID(sprintf("%s.%s", OID_HAPROXY_STATS, $nextid));
-				$mode = MODE_GET;
-			}
-		}
-
-		if ($mode == MODE_GET) {
-				next if !defined($proxyid) || !defined($type) || !defined($sid) || !defined($field);
-
-				my $obj = 1 << $type;
-
-				my $sock = new IO::Socket::UNIX (Peer => $sa, Type => SOCK_STREAM, Timeout => 1);
-				next if !$sock;
-
-				print $sock "show stat $proxyid $obj $sid\n";
-
-				while(<$sock>) {
-					chomp;
-					my @data = split(',');
-
-					last if !defined($data[$field]) && $field != FIELD_INDEX && $field != FIELD_NAME;
-
-					if ($proxyid) {
-						next if $data[STATS_IID] ne $proxyid;
-						next if $data[STATS_SID] ne $sid;
-						next if $data[STATS_TYPE] ne $type;
-					}
-
-					if ($field == FIELD_INDEX) {
-						$request->setValue(ASN_OCTET_STR,
-							sprintf("%s.%s", $data[STATS_IID],
-								$data[STATS_SID]));
-					} elsif ($field == FIELD_NAME) {
-						$request->setValue(ASN_OCTET_STR,
-							sprintf("%s/%s", $data[STATS_PXNAME],
-								$data[STATS_SVNAME]));
-					} else {
-						$request->setValue(ASN_OCTET_STR, $data[$field]);
-					}
-
-					close($sock);
-					last;
-				}
-
-				close($sock);
-				next;
-		}
-
-  	}
-}
-
-sub haproxy_info {
-	my($handler, $registration_info, $request_info, $requests) = @_;
-
-	for(my $request = $requests; $request; $request = $request->next()) {
-		my $oid = $request->getOID();
-
-		$oid =~ s/$oid_info//;
-		$oid =~ s/^\.//;
-
-		my $mode = $request_info->getMode();
-
-		my($req, $nr, $or) = split('\.', $oid, 3);
-
-		next if $req >= 2 || defined($or);
-
-		if ($mode == MODE_GETNEXT) {
-			$req = 0 if !defined($req);
-			$nr  = -1 if !defined($nr);
-
-			if (!defined($info_vars{$nr+1})) {
-				$req++;
-				$nr = -1;
-			}
-
-			next if $req >= 2;
-
-			$request->setOID(sprintf("%s.%s.%s", OID_HAPROXY_INFO, $req, ++$nr));
-			$mode = MODE_GET;
-			
-		}
-
-		if ($mode == MODE_GET) {
-
-			next if !defined($req) || !defined($nr);
-
-			if ($req == 0) {
-				next if !defined($info_vars{$nr});
-				$request->setValue(ASN_OCTET_STR, $info_vars{$nr});
-				next;
-			}
-
-			if ($req == 1) {
-				next if !defined($info_vars{$nr});
-
-				my $sock = new IO::Socket::UNIX (Peer => $sa, Type => SOCK_STREAM, Timeout => 1);
-				next if !$sock;
-
-				print $sock "show info\n";
-
-				while(<$sock>) {
-					chomp;
-					my ($key, $val) = /(.*):\s*(.*)/;
-
-					next if $info_vars{$nr} ne $key;
-
-					$request->setValue(ASN_OCTET_STR, $val);
-					last;
-				}
-
-				close($sock);
-			}
-		}
-	}
-}
-
-$agent->register('Haproxy stat', OID_HAPROXY_STATS, \&haproxy_stat);
-$agent->register('Haproxy info', OID_HAPROXY_INFO, \&haproxy_info);
-
diff --git a/deps/haproxy-1.4.21/contrib/netsnmp-perl/haproxy_backend.xml b/deps/haproxy-1.4.21/contrib/netsnmp-perl/haproxy_backend.xml
deleted file mode 100644
index a5dbe54..0000000
--- a/deps/haproxy-1.4.21/contrib/netsnmp-perl/haproxy_backend.xml
+++ /dev/null
@@ -1,83 +0,0 @@
-<interface>
-	<name>Haproxy - backend</name>
-	<oid_index>.1.3.6.1.4.1.29385.106.1.1.10001</oid_index>
-	<fields>
-		<beIID>
-			<name>Proxy ID</name>
-			<method>get</method>
-			<source>value</source>
-			<direction>input</direction>
-			<oid>.1.3.6.1.4.1.29385.106.1.1.27</oid>
-		</beIID>
-		<beSID>
-			<name>Service ID</name>
-			<method>get</method>
-			<source>value</source>
-			<direction>input</direction>
-			<oid>.1.3.6.1.4.1.29385.106.1.1.28</oid>
-		</beSID>
-		<bePxName>
-			<name>Proxy Name</name>
-			<method>get</method>
-			<source>value</source>
-			<direction>input</direction>
-			<oid>.1.3.6.1.4.1.29385.106.1.1.0</oid>
-		</bePxName>
-		<beSvName>
-			<name>Service Name</name>
-			<method>get</method>
-			<source>value</source>
-			<direction>input</direction>
-			<oid>.1.3.6.1.4.1.29385.106.1.1.1</oid>
-		</beSvName>
-		<beSTot>
-			<name>Total Sessions</name>
-			<method>get</method>
-			<source>value</source>
-			<direction>output</direction>
-			<oid>.1.3.6.1.4.1.29385.106.1.1.7</oid>
-		</beSTot>
-		<beBIn>
-			<name>Bytes In</name>
-			<method>get</method>
-			<source>value</source>
-			<direction>output</direction>
-			<oid>.1.3.6.1.4.1.29385.106.1.1.8</oid>
-		</beBIn>
-		<beBOut>
-			<name>Bytes Out</name>
-			<method>get</method>
-			<source>value</source>
-			<direction>output</direction>
-			<oid>.1.3.6.1.4.1.29385.106.1.1.9</oid>
-		</beBOut>
-		<beEConn>
-			<name>Connection Errors</name>
-			<method>get</method>
-			<source>value</source>
-			<direction>output</direction>
-			<oid>.1.3.6.1.4.1.29385.106.1.1.13</oid>
-		</beEConn>
-		<beEResp>
-			<name>Response Errors</name>
-			<method>get</method>
-			<source>value</source>
-			<direction>output</direction>
-			<oid>.1.3.6.1.4.1.29385.106.1.1.14</oid>
-		</beEResp>
-		<beLBTot>
-			<name>LB Total</name>
-			<method>get</method>
-			<source>value</source>
-			<direction>output</direction>
-			<oid>.1.3.6.1.4.1.29385.106.1.1.30</oid>
-		</beLBTot>
-		<beDReq>
-			<name>Denied Requests</name>
-			<method>get</method>
-			<source>value</source>
-			<direction>output</direction>
-			<oid>.1.3.6.1.4.1.29385.106.1.1.10</oid>
-		</beDReq>
-	</fields>
-</interface>
diff --git a/deps/haproxy-1.4.21/contrib/netsnmp-perl/haproxy_frontend.xml b/deps/haproxy-1.4.21/contrib/netsnmp-perl/haproxy_frontend.xml
deleted file mode 100644
index 028ebc7..0000000
--- a/deps/haproxy-1.4.21/contrib/netsnmp-perl/haproxy_frontend.xml
+++ /dev/null
@@ -1,83 +0,0 @@
-<interface>
-	<name>Haproxy - frontend</name>
-	<oid_index>.1.3.6.1.4.1.29385.106.1.0.10001</oid_index>
-	<fields>
-		<feIID>
-			<name>Proxy ID</name>
-			<method>get</method>
-			<source>value</source>
-			<direction>input</direction>
-			<oid>.1.3.6.1.4.1.29385.106.1.0.27</oid>
-		</feIID>
-		<feSID>
-			<name>Service ID</name>
-			<method>get</method>
-			<source>value</source>
-			<direction>input</direction>
-			<oid>.1.3.6.1.4.1.29385.106.1.0.28</oid>
-		</feSID>
-		<fePxName>
-			<name>Proxy Name</name>
-			<method>get</method>
-			<source>value</source>
-			<direction>input</direction>
-			<oid>.1.3.6.1.4.1.29385.106.1.0.0</oid>
-		</fePxName>
-		<feSvName>
-			<name>Service Name</name>
-			<method>get</method>
-			<source>value</source>
-			<direction>input</direction>
-			<oid>.1.3.6.1.4.1.29385.106.1.0.1</oid>
-		</feSvName>
-		<feSCur>
-			<name>Current Sessions</name>
-			<method>get</method>
-			<source>value</source>
-			<direction>output</direction>
-			<oid>.1.3.6.1.4.1.29385.106.1.0.4</oid>
-		</feSCur>
-		<feSMax>
-			<name>Maximum Sessions</name>
-			<method>get</method>
-			<source>value</source>
-			<direction>output</direction>
-			<oid>.1.3.6.1.4.1.29385.106.1.0.5</oid>
-		</feSMax>
-		<feSTot>
-			<name>Total Sessions</name>
-			<method>get</method>
-			<source>value</source>
-			<direction>output</direction>
-			<oid>.1.3.6.1.4.1.29385.106.1.0.7</oid>
-		</feSTot>
-		<feEReq>
-			<name>Request Errors</name>
-			<method>get</method>
-			<source>value</source>
-			<direction>output</direction>
-			<oid>.1.3.6.1.4.1.29385.106.1.0.12</oid>
-		</feEReq>
-		<feBIn>
-			<name>Bytes In</name>
-			<method>get</method>
-			<source>value</source>
-			<direction>output</direction>
-			<oid>.1.3.6.1.4.1.29385.106.1.0.8</oid>
-		</feBIn>
-		<feBOut>
-			<name>Bytes Out</name>
-			<method>get</method>
-			<source>value</source>
-			<direction>output</direction>
-			<oid>.1.3.6.1.4.1.29385.106.1.0.9</oid>
-		</feBOut>
-		<feDReq>
-			<name>Denied Requests</name>
-			<method>get</method>
-			<source>value</source>
-			<direction>output</direction>
-			<oid>.1.3.6.1.4.1.29385.106.1.0.10</oid>
-		</feDReq>
-	</fields>
-</interface>
diff --git a/deps/haproxy-1.4.21/contrib/netsnmp-perl/haproxy_socket.xml b/deps/haproxy-1.4.21/contrib/netsnmp-perl/haproxy_socket.xml
deleted file mode 100644
index 63ae110..0000000
--- a/deps/haproxy-1.4.21/contrib/netsnmp-perl/haproxy_socket.xml
+++ /dev/null
@@ -1,90 +0,0 @@
-<interface>
-	<name>HAProxy - socket</name>
-	<oid_index>.1.3.6.1.4.1.29385.106.1.3.10001</oid_index>
-	<fields>
-		<feseID>
-			<name>Unique Index</name>
-			<method>get</method>
-			<source>value</source>
-			<direction>input</direction>
-			<oid>.1.3.6.1.4.1.29385.106.1.3.10001</oid>
-		</feseID>
-		<feIID>
-			<name>Proxy ID</name>
-			<method>get</method>
-			<source>value</source>
-			<direction>input</direction>
-			<oid>.1.3.6.1.4.1.29385.106.1.3.27</oid>
-		</feIID>
-		<feSID>
-			<name>Service ID</name>
-			<method>get</method>
-			<source>value</source>
-			<direction>input</direction>
-			<oid>.1.3.6.1.4.1.29385.106.1.3.28</oid>
-		</feSID>
-		<fePxName>
-			<name>Proxy Name</name>
-			<method>get</method>
-			<source>value</source>
-			<direction>input</direction>
-			<oid>.1.3.6.1.4.1.29385.106.1.3.0</oid>
-		</fePxName>
-		<feSvName>
-			<name>Service Name</name>
-			<method>get</method>
-			<source>value</source>
-			<direction>input</direction>
-			<oid>.1.3.6.1.4.1.29385.106.1.3.1</oid>
-		</feSvName>
-		<feSCur>
-			<name>Current Sessions</name>
-			<method>get</method>
-			<source>value</source>
-			<direction>output</direction>
-			<oid>.1.3.6.1.4.1.29385.106.1.3.4</oid>
-		</feSCur>
-		<feSMax>
-			<name>Maximum Sessions</name>
-			<method>get</method>
-			<source>value</source>
-			<direction>output</direction>
-			<oid>.1.3.6.1.4.1.29385.106.1.3.5</oid>
-		</feSMax>
-		<feSTot>
-			<name>Total Sessions</name>
-			<method>get</method>
-			<source>value</source>
-			<direction>output</direction>
-			<oid>.1.3.6.1.4.1.29385.106.1.3.7</oid>
-		</feSTot>
-		<feEReq>
-			<name>Request Errors</name>
-			<method>get</method>
-			<source>value</source>
-			<direction>output</direction>
-			<oid>.1.3.6.1.4.1.29385.106.1.3.12</oid>
-		</feEReq>
-		<feBIn>
-			<name>Bytes In</name>
-			<method>get</method>
-			<source>value</source>
-			<direction>output</direction>
-			<oid>.1.3.6.1.4.1.29385.106.1.3.8</oid>
-		</feBIn>
-		<feBOut>
-			<name>Bytes Out</name>
-			<method>get</method>
-			<source>value</source>
-			<direction>output</direction>
-			<oid>.1.3.6.1.4.1.29385.106.1.3.9</oid>
-		</feBOut>
-		<feDReq>
-			<name>Denied Requests</name>
-			<method>get</method>
-			<source>value</source>
-			<direction>output</direction>
-			<oid>.1.3.6.1.4.1.29385.106.1.3.10</oid>
-		</feDReq>
-	</fields>
-</interface>
diff --git a/deps/haproxy-1.4.21/contrib/selinux/README b/deps/haproxy-1.4.21/contrib/selinux/README
deleted file mode 100644
index 7ad924d..0000000
--- a/deps/haproxy-1.4.21/contrib/selinux/README
+++ /dev/null
@@ -1,18 +0,0 @@
-This directory includes an selinux policy for haproxy. It assumes
-the following file locations:
-
-	/usr/sbin/haproxy		-- binary
-	/etc/haproxy/haproxy\.cfg	-- configuration
-	/var/run/haproxy\.pid		-- pid-file
-	/var/run/haproxy\.sock(.*)	-- stats socket
-	/var/empty/haproxy		-- chroot dir
-
-To build and load it on RHEL5 you'll need the "selinux-policy-devel" package,
-and from within this directory run:
-
-	make -f /usr/share/selinux/devel/Makefile
-	sudo semodule -i haproxy.pp
-	restorecon /usr/sbin/haproxy /etc/haproxy/haproxy.cfg /var/run/haproxy.pid /var/run/haproxy.sock*
-
-
-Feedback to Jan-Frode Myklebust <janfrode@tanso.no> is much appreciated,
diff --git a/deps/haproxy-1.4.21/contrib/selinux/haproxy.fc b/deps/haproxy-1.4.21/contrib/selinux/haproxy.fc
deleted file mode 100644
index 63a0828..0000000
--- a/deps/haproxy-1.4.21/contrib/selinux/haproxy.fc
+++ /dev/null
@@ -1,6 +0,0 @@
-# haproxy labeling policy
-# file: haproxy.fc
-/usr/sbin/haproxy           -- gen_context(system_u:object_r:haproxy_exec_t, s0)
-/etc/haproxy/haproxy\.cfg   -- gen_context(system_u:object_r:haproxy_conf_t, s0)
-/var/run/haproxy\.pid       -- gen_context(system_u:object_r:haproxy_var_run_t, s0)
-/var/run/haproxy\.sock(.*)  -- gen_context(system_u:object_r:haproxy_var_run_t, s0)
diff --git a/deps/haproxy-1.4.21/contrib/selinux/haproxy.if b/deps/haproxy-1.4.21/contrib/selinux/haproxy.if
deleted file mode 100644
index 236ad38..0000000
--- a/deps/haproxy-1.4.21/contrib/selinux/haproxy.if
+++ /dev/null
@@ -1,2 +0,0 @@
-## <summary>selinux policy module for haproxy</summary>
-
diff --git a/deps/haproxy-1.4.21/contrib/selinux/haproxy.te b/deps/haproxy-1.4.21/contrib/selinux/haproxy.te
deleted file mode 100644
index bc124fb..0000000
--- a/deps/haproxy-1.4.21/contrib/selinux/haproxy.te
+++ /dev/null
@@ -1,66 +0,0 @@
-policy_module(haproxy,1.0.0)
-
-########################################
-#
-# Declarations
-#
-
-type haproxy_t;
-type haproxy_exec_t;
-type haproxy_port_t;
-init_daemon_domain(haproxy_t, haproxy_exec_t)
-
-type haproxy_var_run_t;
-files_pid_file(haproxy_var_run_t)
-
-type haproxy_conf_t;
-files_config_file(haproxy_conf_t)
-
-########################################
-#
-# Local policy
-#
-
-# Configuration files - read
-allow haproxy_t haproxy_conf_t : dir list_dir_perms;
-allow haproxy_t haproxy_conf_t : file read_file_perms;
-allow haproxy_t haproxy_conf_t : lnk_file read_file_perms;
-
-# PID and socket file - create, read, and write
-files_pid_filetrans(haproxy_t, haproxy_var_run_t, { file sock_file })
-allow haproxy_t haproxy_var_run_t:file manage_file_perms;
-allow haproxy_t haproxy_var_run_t:sock_file { create rename link setattr unlink };
-
-allow haproxy_t self : tcp_socket create_stream_socket_perms;
-allow haproxy_t self: udp_socket create_socket_perms;
-allow haproxy_t self: capability { setgid setuid sys_chroot sys_resource kill };
-allow haproxy_t self: process { setrlimit signal };
-
-
-logging_send_syslog_msg(haproxy_t)
-
-corenet_tcp_bind_all_ports(haproxy_t)
-corenet_tcp_connect_all_ports(haproxy_t)
-corenet_tcp_bind_all_nodes(haproxy_t)
-corenet_tcp_sendrecv_all_ports(haproxy_t)
-corenet_tcp_recvfrom_unlabeled(haproxy_t)
-
-# use shared libraries
-libs_use_ld_so(haproxy_t)
-libs_use_shared_libs(haproxy_t)
-
-# Read /etc/localtime:
-miscfiles_read_localization(haproxy_t)
-# Read /etc/passwd and more.
-files_read_etc_files(haproxy_t)
-
-# RHEL5 specific:
-require {
-	type unlabeled_t;
-	type haproxy_t;
-	class packet send;
-	class packet recv;
-}
-
-allow haproxy_t unlabeled_t:packet { send recv };
-
diff --git a/deps/haproxy-1.4.21/doc/acl.fig b/deps/haproxy-1.4.21/doc/acl.fig
deleted file mode 100644
index 253a053..0000000
--- a/deps/haproxy-1.4.21/doc/acl.fig
+++ /dev/null
@@ -1,229 +0,0 @@
-#FIG 3.2  Produced by xfig version 3.2.5-alpha5
-Portrait
-Center
-Metric
-A4      
-100.00
-Single
--2
-1200 2
-6 2430 1080 2700 2250
-1 2 0 1 0 11 52 -1 20 0.000 1 0.0000 2587 1687 113 563 2474 1687 2700 1687
-4 1 0 50 -1 16 8 1.5708 4 120 840 2610 1710 tcp-req inspect\001
--6
-6 5805 1080 6255 2250
-1 2 0 1 0 29 52 -1 20 0.000 1 0.0000 6052 1687 203 563 5849 1687 6255 1687
-4 1 0 50 -1 16 8 1.5708 4 90 300 6030 1710 HTTP\001
-4 1 0 50 -1 16 8 1.5708 4 120 615 6165 1710 processing\001
--6
-6 1575 3375 1800 4500
-2 2 0 1 0 29 52 -1 20 0.000 0 0 -1 0 0 5
-	 1575 3375 1800 3375 1800 4500 1575 4500 1575 3375
-4 1 0 50 -1 16 8 1.5708 4 120 735 1710 3960 http-resp out\001
--6
-6 2025 3375 2250 4500
-2 2 0 1 0 29 52 -1 20 0.000 0 0 -1 0 0 5
-	 2025 3375 2250 3375 2250 4500 2025 4500 2025 3375
-4 1 0 50 -1 16 8 1.5708 4 120 735 2160 3960 http-resp out\001
--6
-6 810 3600 1080 4230
-4 1 0 50 -1 16 8 1.5708 4 105 555 900 3915 Response\001
-4 1 0 50 -1 16 8 1.5708 4 105 450 1065 3915 to client\001
--6
-6 720 1350 1035 2070
-4 1 0 50 -1 16 8 1.5708 4 120 540 855 1710 Requests \001
-4 1 0 50 -1 16 8 1.5708 4 105 645 1020 1710 from clients\001
--6
-6 7695 1350 8010 1980
-4 1 0 50 -1 16 8 1.5708 4 120 510 7830 1665 Requests\001
-4 1 0 50 -1 16 8 1.5708 4 105 555 7995 1665 to servers\001
--6
-6 7785 3600 8055 4230
-4 1 0 50 -1 16 8 1.5708 4 105 555 7875 3915 Response\001
-4 1 0 50 -1 16 8 1.5708 4 105 630 8055 3915 from server\001
--6
-1 2 0 1 0 11 52 -1 20 0.000 1 0.0000 1687 1687 113 563 1574 1687 1800 1687
-1 2 0 1 0 11 52 -1 20 0.000 1 0.0000 7087 3937 113 563 6974 3937 7200 3937
-1 2 0 1 0 29 52 -1 20 0.000 1 0.0000 4072 3937 203 563 3869 3937 4275 3937
-1 2 0 1 0 29 52 -1 20 0.000 1 0.0000 2903 3937 203 563 2700 3937 3106 3937
-2 3 0 1 0 6 54 -1 20 0.000 0 0 -1 0 0 9
-	 1485 900 1485 2475 4140 2475 4140 1035 6390 1035 6390 2340
-	 6840 2340 6840 900 1485 900
-2 3 0 1 0 2 54 -1 20 0.000 0 0 -1 0 0 9
-	 4365 1035 4365 2475 7290 2475 7290 900 6840 900 6840 2340
-	 5715 2340 5715 1035 4365 1035
-2 2 0 1 0 29 52 -1 20 0.000 0 0 -1 0 0 5
-	 4950 1125 5175 1125 5175 2250 4950 2250 4950 1125
-2 2 0 1 0 29 52 -1 20 0.000 0 0 -1 0 0 5
-	 5400 1125 5625 1125 5625 2250 5400 2250 5400 1125
-2 2 0 1 0 11 52 -1 20 0.000 0 0 -1 0 0 5
-	 2025 1125 2250 1125 2250 2250 2025 2250 2025 1125
-2 2 0 1 0 11 52 -1 20 0.000 0 0 -1 0 0 5
-	 2925 1125 3150 1125 3150 2250 2925 2250 2925 1125
-2 1 0 1 0 0 50 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 60.00 120.00
-	 1125 1710 1575 1710
-2 1 0 1 0 0 50 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 60.00 120.00
-	 1125 1935 1575 1755
-2 1 0 1 0 0 50 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 60.00 120.00
-	 1125 1485 1575 1665
-2 2 0 1 0 29 52 -1 20 0.000 0 0 -1 0 0 5
-	 3825 1125 4050 1125 4050 2250 3825 2250 3825 1125
-2 2 0 1 0 6 50 -1 20 0.000 0 0 -1 0 0 5
-	 1575 450 2025 450 2025 540 1575 540 1575 450
-2 2 0 1 0 2 50 -1 20 0.000 0 0 -1 0 0 5
-	 1575 675 2025 675 2025 765 1575 765 1575 675
-2 2 0 1 0 11 50 -1 20 0.000 0 0 -1 0 0 5
-	 3150 450 3600 450 3600 540 3150 540 3150 450
-2 2 0 1 0 29 50 -1 20 0.000 0 0 -1 0 0 5
-	 3150 675 3600 675 3600 765 3150 765 3150 675
-2 2 0 1 0 29 52 -1 20 0.000 0 0 -1 0 0 5
-	 6525 1125 6750 1125 6750 2250 6525 2250 6525 1125
-2 1 0 1 0 0 50 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 60.00 120.00
-	 7200 1665 7650 1665
-2 1 0 1 0 0 50 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 60.00 120.00
-	 7200 1620 7650 1530
-2 1 0 1 0 0 50 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 60.00 120.00
-	 7200 1710 7650 1800
-2 2 0 1 0 29 52 -1 20 0.000 0 0 -1 0 0 5
-	 6975 1125 7200 1125 7200 2250 6975 2250 6975 1125
-2 2 0 1 0 29 52 -1 20 0.000 0 0 -1 0 0 5
-	 3375 1125 3600 1125 3600 2250 3375 2250 3375 1125
-2 2 0 1 0 11 52 -1 20 0.000 0 0 -1 0 0 5
-	 4500 1125 4725 1125 4725 2250 4500 2250 4500 1125
-2 1 0 1 0 0 50 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 30.00 60.00
-	 1800 1665 2025 1665
-2 1 0 1 0 0 50 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 30.00 60.00
-	 2250 1665 2475 1665
-2 1 0 1 0 0 50 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 30.00 60.00
-	 2700 1665 2925 1665
-2 1 0 1 0 0 50 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 30.00 60.00
-	 3150 1665 3375 1665
-2 1 0 1 0 0 50 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 30.00 60.00
-	 3600 1665 3825 1665
-2 1 0 1 0 0 50 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 30.00 60.00
-	 4725 1665 4950 1665
-2 1 0 1 0 0 50 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 30.00 60.00
-	 5175 1665 5400 1665
-2 1 0 1 0 0 50 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 30.00 60.00
-	 5625 1665 5850 1665
-2 1 0 1 0 0 50 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 30.00 60.00
-	 6750 1665 6975 1665
-2 1 0 1 0 0 50 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 30.00 60.00
-	 6255 1665 6525 1665
-2 1 0 1 0 0 50 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 30.00 60.00
-	 4050 1665 4500 1665
-2 1 0 1 0 0 50 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 30.00 60.00
-	 4050 1620 4500 1530
-2 1 0 1 0 0 50 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 30.00 60.00
-	 4050 1710 4500 1800
-2 2 0 1 0 11 52 -1 20 0.000 0 0 -1 0 0 5
-	 6525 3375 6750 3375 6750 4500 6525 4500 6525 3375
-2 2 0 1 0 29 52 -1 20 0.000 0 0 -1 0 0 5
-	 6075 3375 6300 3375 6300 4500 6075 4500 6075 3375
-2 3 0 1 0 2 54 -1 20 0.000 0 0 -1 0 0 9
-	 7290 3150 7290 4725 5985 4725 5985 3285 2385 3285 2385 4590
-	 1935 4590 1935 3150 7290 3150
-2 3 0 1 0 6 54 -1 20 0.000 0 0 -1 0 0 9
-	 1935 3150 1485 3150 1485 4725 5985 4725 5985 3285 5085 3285
-	 5085 4590 1935 4590 1935 3150
-2 2 0 1 0 11 52 -1 20 0.000 0 0 -1 0 0 5
-	 5625 3375 5850 3375 5850 4500 5625 4500 5625 3375
-2 2 0 1 0 29 52 -1 20 0.000 0 0 -1 0 0 5
-	 5175 3375 5400 3375 5400 4500 5175 4500 5175 3375
-2 1 0 1 0 0 54 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 60.00 120.00
-	 7650 3915 7200 3915
-2 1 0 1 0 0 54 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 60.00 120.00
-	 1575 3915 1125 3915
-2 1 0 1 0 0 50 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 30.00 60.00
-	 6975 3915 6750 3915
-2 1 0 1 0 0 50 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 30.00 60.00
-	 6525 3915 6300 3915
-2 1 0 1 0 0 50 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 30.00 60.00
-	 6075 3915 5850 3915
-2 1 0 1 0 0 50 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 30.00 60.00
-	 5625 3915 5400 3915
-2 1 0 1 0 0 50 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 30.00 60.00
-	 2025 3915 1800 3915
-2 1 0 1 0 0 50 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 30.00 60.00
-	 5175 3915 4275 3915
-2 1 0 1 0 0 50 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 30.00 60.00
-	 3870 3915 3105 3915
-2 1 0 1 0 0 50 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 30.00 60.00
-	 2700 3915 2250 3915
-2 1 0 1 0 0 50 -1 -1 0.000 0 0 -1 1 0 3
-	1 1 1.00 30.00 60.00
-	 3465 2250 3465 2880 2970 3465
-2 1 0 1 0 0 50 -1 -1 0.000 0 0 -1 1 0 4
-	1 1 1.00 30.00 60.00
-	 5040 2250 5040 2655 3600 2880 3015 3510
-2 1 0 1 0 0 50 -1 -1 0.000 0 0 -1 1 0 4
-	1 1 1.00 30.00 60.00
-	 6075 2250 6075 2565 3645 2925 3060 3555
-2 1 0 1 0 0 50 -1 -1 0.000 0 0 -1 1 0 4
-	1 1 1.00 30.00 60.00
-	 6615 2250 6615 2610 3690 2970 3060 3645
-2 1 0 1 0 0 50 -1 -1 0.000 0 0 -1 1 0 4
-	1 1 1.00 30.00 60.00
-	 7065 2250 7065 2655 3735 3015 3060 3690
-2 1 0 1 0 0 50 -1 -1 0.000 0 0 -1 1 0 4
-	1 1 1.00 30.00 60.00
-	 5265 3375 5265 2970 3825 3105 3105 3780
-2 1 0 1 0 0 50 -1 -1 0.000 0 0 -1 1 0 4
-	1 1 1.00 30.00 60.00
-	 6165 3375 6165 2835 3780 3060 3105 3735
-4 1 0 50 -1 16 8 1.5708 4 120 630 2160 1710 tcp-request\001
-4 1 0 50 -1 16 8 1.5708 4 120 870 3060 1710 tcp-req content\001
-4 1 0 50 -1 16 8 1.5708 4 120 600 5085 1710 http-req in\001
-4 1 0 50 -1 16 8 1.5708 4 105 690 3960 1710 use-backend\001
-4 1 0 50 -1 16 8 1.5708 4 75 570 5535 1710 use-server\001
-4 1 0 50 -1 16 8 1.5708 4 120 360 1710 1710 accept\001
-4 0 0 50 -1 18 6 0.0000 4 90 435 2115 540 frontend\001
-4 0 0 50 -1 18 6 0.0000 4 90 405 2115 765 backend\001
-4 0 0 50 -1 18 6 0.0000 4 105 150 3735 540 tcp\001
-4 0 0 50 -1 18 6 0.0000 4 105 450 3735 765 http only\001
-4 2 0 50 -1 18 6 0.0000 4 90 435 4050 2430 frontend\001
-4 0 0 50 -1 18 6 0.0000 4 90 405 4455 2430 backend\001
-4 1 0 50 -1 16 8 1.5708 4 120 675 6660 1710 http-req out\001
-4 1 0 50 -1 16 8 1.5708 4 120 675 7110 1710 http-req out\001
-4 1 0 50 -1 16 8 1.5708 4 120 600 3510 1710 http-req in\001
-4 1 0 50 -1 16 8 1.5708 4 120 870 4635 1710 tcp-req content\001
-4 1 0 50 -1 16 8 1.5708 4 120 660 6210 3960 http-resp in\001
-4 1 0 50 -1 16 8 1.5708 4 120 930 6660 3960 tcp-resp content\001
-4 1 0 50 -1 16 8 1.5708 4 120 900 7110 3960 tcp-resp inspect\001
-4 1 0 50 -1 16 8 1.5708 4 120 930 5760 3960 tcp-resp content\001
-4 1 0 50 -1 16 8 1.5708 4 120 660 5310 3960 http-resp in\001
-4 0 0 50 -1 18 6 0.0000 4 90 405 6075 4680 backend\001
-4 1 0 50 -1 16 8 1.5708 4 90 300 4050 3960 HTTP\001
-4 1 0 50 -1 16 8 1.5708 4 120 615 4185 3960 processing\001
-4 1 0 50 -1 16 8 1.5708 4 90 300 2835 3915 Error\001
-4 1 0 50 -1 16 8 1.5708 4 120 615 2970 3915 processing\001
-4 2 0 50 -1 18 6 0.0000 4 90 435 5895 4680 frontend\001
diff --git a/deps/haproxy-1.4.21/doc/architecture.txt b/deps/haproxy-1.4.21/doc/architecture.txt
deleted file mode 100644
index 6135f80..0000000
--- a/deps/haproxy-1.4.21/doc/architecture.txt
+++ /dev/null
@@ -1,1448 +0,0 @@
-                           -------------------
-                                 HAProxy
-                           Architecture  Guide
-                           -------------------
-                             version 1.1.34
-                              willy tarreau
-                               2006/01/29
-
-
-This document provides real world examples with working configurations.
-Please note that except stated otherwise, global configuration parameters
-such as logging, chrooting, limits and time-outs are not described here.
-
-===================================================
-1. Simple HTTP load-balancing with cookie insertion
-===================================================
-
-A web application often saturates the front-end server with high CPU loads,
-due to the scripting language involved. It also relies on a back-end database
-which is not much loaded. User contexts are stored on the server itself, and
-not in the database, so that simply adding another server with simple IP/TCP
-load-balancing would not work.
-
-                +-------+
-                |clients|  clients and/or reverse-proxy
-                +---+---+
-                    |
-                   -+-----+--------+----
-                          |       _|_db
-                       +--+--+   (___)
-                       | web |   (___)
-                       +-----+   (___)
-                   192.168.1.1   192.168.1.2
-
-
-Replacing the web server with a bigger SMP system would cost much more than
-adding low-cost pizza boxes. The solution is to buy N cheap boxes and install
-the application on them. Install haproxy on the old one which will spread the
-load across the new boxes.
-
-  192.168.1.1    192.168.1.11-192.168.1.14   192.168.1.2
- -------+-----------+-----+-----+-----+--------+----
-        |           |     |     |     |       _|_db
-     +--+--+      +-+-+ +-+-+ +-+-+ +-+-+    (___)
-     | LB1 |      | A | | B | | C | | D |    (___)
-     +-----+      +---+ +---+ +---+ +---+    (___)
-     haproxy        4 cheap web servers
-
-
-Config on haproxy (LB1) :
--------------------------
-       
-    listen webfarm 192.168.1.1:80
-       mode http
-       balance roundrobin
-       cookie SERVERID insert indirect
-       option httpchk HEAD /index.html HTTP/1.0
-       server webA 192.168.1.11:80 cookie A check
-       server webB 192.168.1.12:80 cookie B check
-       server webC 192.168.1.13:80 cookie C check
-       server webD 192.168.1.14:80 cookie D check
-       
-
-Description :
--------------
- - LB1 will receive clients requests.
- - if a request does not contain a cookie, it will be forwarded to a valid
-   server
- - in return, a cookie "SERVERID" will be inserted in the response holding the
-   server name (eg: "A").
- - when the client comes again with the cookie "SERVERID=A", LB1 will know that
-   it must be forwarded to server A. The cookie will be removed so that the
-   server does not see it.
- - if server "webA" dies, the requests will be sent to another valid server
-   and a cookie will be reassigned.
-
-
-Flows :
--------
-
-(client)                           (haproxy)                         (server A)
-  >-- GET /URI1 HTTP/1.0 ------------> |
-               ( no cookie, haproxy forwards in load-balancing mode. )
-                                       | >-- GET /URI1 HTTP/1.0 ---------->
-                                       | <-- HTTP/1.0 200 OK -------------<
-               ( the proxy now adds the server cookie in return )
-  <-- HTTP/1.0 200 OK ---------------< |
-      Set-Cookie: SERVERID=A           |
-  >-- GET /URI2 HTTP/1.0 ------------> |
-      Cookie: SERVERID=A               |
-      ( the proxy sees the cookie. it forwards to server A and deletes it )
-                                       | >-- GET /URI2 HTTP/1.0 ---------->
-                                       | <-- HTTP/1.0 200 OK -------------<
-   ( the proxy does not add the cookie in return because the client knows it )
-  <-- HTTP/1.0 200 OK ---------------< |
-  >-- GET /URI3 HTTP/1.0 ------------> |
-      Cookie: SERVERID=A               |
-                                    ( ... )
-
-
-Limits :
---------
- - if clients use keep-alive (HTTP/1.1), only the first response will have
-   a cookie inserted, and only the first request of each session will be
-   analyzed. This does not cause trouble in insertion mode because the cookie
-   is put immediately in the first response, and the session is maintained to
-   the same server for all subsequent requests in the same session. However,
-   the cookie will not be removed from the requests forwarded to the servers,
-   so the server must not be sensitive to unknown cookies. If this causes
-   trouble, you can disable keep-alive by adding the following option :
-
-        option httpclose
-
- - if for some reason the clients cannot learn more than one cookie (eg: the
-   clients are indeed some home-made applications or gateways), and the
-   application already produces a cookie, you can use the "prefix" mode (see
-   below).
-
- - LB1 becomes a very sensible server. If LB1 dies, nothing works anymore.
-   => you can back it up using keepalived (see below)
-
- - if the application needs to log the original client's IP, use the
-   "forwardfor" option which will add an "X-Forwarded-For" header with the
-   original client's IP address. You must also use "httpclose" to ensure
-   that you will rewrite every requests and not only the first one of each
-   session :
-
-        option httpclose
-        option forwardfor
-
- - if the application needs to log the original destination IP, use the
-   "originalto" option which will add an "X-Original-To" header with the
-   original destination IP address. You must also use "httpclose" to ensure
-   that you will rewrite every requests and not only the first one of each
-   session :
-
-        option httpclose
-        option originalto
-
-   The web server will have to be configured to use this header instead.
-   For example, on apache, you can use LogFormat for this :
-
-        LogFormat "%{X-Forwarded-For}i %l %u %t \"%r\" %>s %b " combined
-        CustomLog /var/log/httpd/access_log combined
-
-Hints :
--------
-Sometimes on the internet, you will find a few percent of the clients which
-disable cookies on their browser. Obviously they have troubles everywhere on
-the web, but you can still help them access your site by using the "source"
-balancing algorithm instead of the "roundrobin". It ensures that a given IP
-address always reaches the same server as long as the number of servers remains
-unchanged. Never use this behind a proxy or in a small network, because the
-distribution will be unfair. However, in large internal networks, and on the
-internet, it works quite well. Clients which have a dynamic address will not
-be affected as long as they accept the cookie, because the cookie always has
-precedence over load balancing :
-
-    listen webfarm 192.168.1.1:80
-       mode http
-       balance source
-       cookie SERVERID insert indirect
-       option httpchk HEAD /index.html HTTP/1.0
-       server webA 192.168.1.11:80 cookie A check
-       server webB 192.168.1.12:80 cookie B check
-       server webC 192.168.1.13:80 cookie C check
-       server webD 192.168.1.14:80 cookie D check
-       
-
-==================================================================
-2. HTTP load-balancing with cookie prefixing and high availability
-==================================================================
-
-Now you don't want to add more cookies, but rather use existing ones. The
-application already generates a "JSESSIONID" cookie which is enough to track
-sessions, so we'll prefix this cookie with the server name when we see it.
-Since the load-balancer becomes critical, it will be backed up with a second
-one in VRRP mode using keepalived under Linux.
-
-Download the latest version of keepalived from this site and install it
-on each load-balancer LB1 and LB2 :
-
-       http://www.keepalived.org/
-
-You then have a shared IP between the two load-balancers (we will still use the
-original IP). It is active only on one of them at any moment. To allow the
-proxy to bind to the shared IP on Linux 2.4, you must enable it in /proc :
-
-# echo 1 >/proc/sys/net/ipv4/ip_nonlocal_bind
-
-
-    shared IP=192.168.1.1
-  192.168.1.3  192.168.1.4    192.168.1.11-192.168.1.14   192.168.1.2
- -------+------------+-----------+-----+-----+-----+--------+----
-        |            |           |     |     |     |       _|_db
-     +--+--+      +--+--+      +-+-+ +-+-+ +-+-+ +-+-+    (___)
-     | LB1 |      | LB2 |      | A | | B | | C | | D |    (___)
-     +-----+      +-----+      +---+ +---+ +---+ +---+    (___)
-     haproxy      haproxy        4 cheap web servers
-     keepalived   keepalived
-
-
-Config on both proxies (LB1 and LB2) :
---------------------------------------       
-
-    listen webfarm 192.168.1.1:80
-       mode http
-       balance roundrobin
-       cookie JSESSIONID prefix
-       option httpclose
-       option forwardfor
-       option httpchk HEAD /index.html HTTP/1.0
-       server webA 192.168.1.11:80 cookie A check
-       server webB 192.168.1.12:80 cookie B check
-       server webC 192.168.1.13:80 cookie C check
-       server webD 192.168.1.14:80 cookie D check
-       
-
-Notes: the proxy will modify EVERY cookie sent by the client and the server,
-so it is important that it can access to ALL cookies in ALL requests for
-each session. This implies that there is no keep-alive (HTTP/1.1), thus the
-"httpclose" option. Only if you know for sure that the client(s) will never
-use keep-alive (eg: Apache 1.3 in reverse-proxy mode), you can remove this
-option.
-
-
-Configuration for keepalived on LB1/LB2 :
------------------------------------------
-
-    vrrp_script chk_haproxy {           # Requires keepalived-1.1.13
-        script "killall -0 haproxy"     # cheaper than pidof
-        interval 2                      # check every 2 seconds
-	weight 2                        # add 2 points of prio if OK
-    }
-
-    vrrp_instance VI_1 {
-        interface eth0
-        state MASTER
-        virtual_router_id 51
-        priority 101                    # 101 on master, 100 on backup
-        virtual_ipaddress {
-            192.168.1.1
-        }
-        track_script {
-            chk_haproxy
-        }
-    }
-
-
-Description :
--------------
- - LB1 is VRRP master (keepalived), LB2 is backup. Both monitor the haproxy
-   process, and lower their prio if it fails, leading to a failover to the
-   other node.
- - LB1 will receive clients requests on IP 192.168.1.1.
- - both load-balancers send their checks from their native IP.
- - if a request does not contain a cookie, it will be forwarded to a valid
-   server
- - in return, if a JESSIONID cookie is seen, the server name will be prefixed
-   into it, followed by a delimitor ('~')
- - when the client comes again with the cookie "JSESSIONID=A~xxx", LB1 will
-   know that it must be forwarded to server A. The server name will then be
-   extracted from cookie before it is sent to the server.
- - if server "webA" dies, the requests will be sent to another valid server
-   and a cookie will be reassigned.
-
-
-Flows :
--------
-
-(client)                           (haproxy)                         (server A)
-  >-- GET /URI1 HTTP/1.0 ------------> |
-               ( no cookie, haproxy forwards in load-balancing mode. )
-                                       | >-- GET /URI1 HTTP/1.0 ---------->
-                                       |     X-Forwarded-For: 10.1.2.3
-                                       | <-- HTTP/1.0 200 OK -------------<
-                        ( no cookie, nothing changed )
-  <-- HTTP/1.0 200 OK ---------------< |
-  >-- GET /URI2 HTTP/1.0 ------------> |
-    ( no cookie, haproxy forwards in lb mode, possibly to another server. )
-                                       | >-- GET /URI2 HTTP/1.0 ---------->
-                                       |     X-Forwarded-For: 10.1.2.3
-                                       | <-- HTTP/1.0 200 OK -------------<
-                                       |     Set-Cookie: JSESSIONID=123
-    ( the cookie is identified, it will be prefixed with the server name )
-  <-- HTTP/1.0 200 OK ---------------< |
-      Set-Cookie: JSESSIONID=A~123     |
-  >-- GET /URI3 HTTP/1.0 ------------> |
-      Cookie: JSESSIONID=A~123         |
-       ( the proxy sees the cookie, removes the server name and forwards
-          to server A which sees the same cookie as it previously sent )
-                                       | >-- GET /URI3 HTTP/1.0 ---------->
-                                       |     Cookie: JSESSIONID=123
-                                       |     X-Forwarded-For: 10.1.2.3
-                                       | <-- HTTP/1.0 200 OK -------------<
-                        ( no cookie, nothing changed )
-  <-- HTTP/1.0 200 OK ---------------< |
-                                    ( ... )
-
-Hints :
--------
-Sometimes, there will be some powerful servers in the farm, and some smaller
-ones. In this situation, it may be desirable to tell haproxy to respect the
-difference in performance. Let's consider that WebA and WebB are two old
-P3-1.2 GHz while WebC and WebD are shiny new Opteron-2.6 GHz. If your
-application scales with CPU, you may assume a very rough 2.6/1.2 performance
-ratio between the servers. You can inform haproxy about this using the "weight"
-keyword, with values between 1 and 256. It will then spread the load the most
-smoothly possible respecting those ratios :
-
-       server webA 192.168.1.11:80 cookie A weight 12 check
-       server webB 192.168.1.12:80 cookie B weight 12 check
-       server webC 192.168.1.13:80 cookie C weight 26 check
-       server webD 192.168.1.14:80 cookie D weight 26 check
-
-
-========================================================
-2.1 Variations involving external layer 4 load-balancers
-========================================================
-
-Instead of using a VRRP-based active/backup solution for the proxies,
-they can also be load-balanced by a layer4 load-balancer (eg: Alteon)
-which will also check that the services run fine on both proxies :
-
-              | VIP=192.168.1.1
-         +----+----+
-         | Alteon  |
-         +----+----+
-              |
- 192.168.1.3  |  192.168.1.4  192.168.1.11-192.168.1.14   192.168.1.2
- -------+-----+------+-----------+-----+-----+-----+--------+----
-        |            |           |     |     |     |       _|_db
-     +--+--+      +--+--+      +-+-+ +-+-+ +-+-+ +-+-+    (___)
-     | LB1 |      | LB2 |      | A | | B | | C | | D |    (___)
-     +-----+      +-----+      +---+ +---+ +---+ +---+    (___)
-     haproxy      haproxy        4 cheap web servers
-
-
-Config on both proxies (LB1 and LB2) :
---------------------------------------
-       
-    listen webfarm 0.0.0.0:80
-       mode http
-       balance roundrobin
-       cookie JSESSIONID prefix
-       option httpclose
-       option forwardfor
-       option httplog
-       option dontlognull
-       option httpchk HEAD /index.html HTTP/1.0
-       server webA 192.168.1.11:80 cookie A check
-       server webB 192.168.1.12:80 cookie B check
-       server webC 192.168.1.13:80 cookie C check
-       server webD 192.168.1.14:80 cookie D check
-
-The "dontlognull" option is used to prevent the proxy from logging the health
-checks from the Alteon. If a session exchanges no data, then it will not be
-logged.
-       
-Config on the Alteon :
-----------------------
-
-    /c/slb/real  11
-           ena
-           name "LB1"
-           rip 192.168.1.3
-    /c/slb/real  12
-           ena
-           name "LB2"
-           rip 192.168.1.4
-    /c/slb/group 10
-           name "LB1-2"
-           metric roundrobin
-           health tcp
-           add 11
-           add 12
-    /c/slb/virt 10
-           ena
-           vip 192.168.1.1
-    /c/slb/virt 10/service http
-           group 10
-
-
-Note: the health-check on the Alteon is set to "tcp" to prevent the proxy from
-forwarding the connections. It can also be set to "http", but for this the
-proxy must specify a "monitor-net" with the Alteons' addresses, so that the
-Alteon can really check that the proxies can talk HTTP but without forwarding
-the connections to the end servers. Check next section for an example on how to
-use monitor-net.
-
-
-============================================================
-2.2 Generic TCP relaying and external layer 4 load-balancers
-============================================================
-
-Sometimes it's useful to be able to relay generic TCP protocols (SMTP, TSE,
-VNC, etc...), for example to interconnect private networks. The problem comes
-when you use external load-balancers which need to send periodic health-checks
-to the proxies, because these health-checks get forwarded to the end servers.
-The solution is to specify a network which will be dedicated to monitoring
-systems and must not lead to a forwarding connection nor to any log, using the
-"monitor-net" keyword. Note: this feature expects a version of haproxy greater
-than or equal to 1.1.32 or 1.2.6.
-
-
-                |  VIP=172.16.1.1   |
-           +----+----+         +----+----+
-           | Alteon1 |         | Alteon2 |
-           +----+----+         +----+----+
- 192.168.1.252  |  GW=192.168.1.254 |  192.168.1.253
-                |                   |
-          ------+---+------------+--+-----------------> TSE farm : 192.168.1.10
-       192.168.1.1  |            | 192.168.1.2
-                 +--+--+      +--+--+
-                 | LB1 |      | LB2 |
-                 +-----+      +-----+
-                 haproxy      haproxy
-
-
-Config on both proxies (LB1 and LB2) :
---------------------------------------
-       
-    listen tse-proxy
-       bind :3389,:1494,:5900  # TSE, ICA and VNC at once.
-       mode tcp
-       balance roundrobin
-       server tse-farm 192.168.1.10
-       monitor-net 192.168.1.252/31
-
-The "monitor-net" option instructs the proxies that any connection coming from
-192.168.1.252 or 192.168.1.253 will not be logged nor forwarded and will be
-closed immediately. The Alteon load-balancers will then see the proxies alive
-without perturbating the service.
-
-Config on the Alteon :
-----------------------
-
-    /c/l3/if 1
-           ena
-           addr 192.168.1.252
-           mask 255.255.255.0
-    /c/slb/real  11
-           ena
-           name "LB1"
-           rip 192.168.1.1
-    /c/slb/real  12
-           ena
-           name "LB2"
-           rip 192.168.1.2
-    /c/slb/group 10
-           name "LB1-2"
-           metric roundrobin
-           health tcp
-           add 11
-           add 12
-    /c/slb/virt 10
-           ena
-           vip 172.16.1.1
-    /c/slb/virt 10/service 1494
-           group 10
-    /c/slb/virt 10/service 3389
-           group 10
-    /c/slb/virt 10/service 5900
-           group 10
-
-
-Special handling of SSL :
--------------------------
-Sometimes, you want to send health-checks to remote systems, even in TCP mode,
-in order to be able to failover to a backup server in case the first one is
-dead. Of course, you can simply enable TCP health-checks, but it sometimes
-happens that intermediate firewalls between the proxies and the remote servers
-acknowledge the TCP connection themselves, showing an always-up server. Since
-this is generally encountered on long-distance communications, which often
-involve SSL, an SSL health-check has been implemented to workaround this issue.
-It sends SSL Hello messages to the remote server, which in turns replies with
-SSL Hello messages. Setting it up is very easy :
-
-    listen tcp-syslog-proxy
-       bind :1514      # listen to TCP syslog traffic on this port (SSL)
-       mode tcp
-       balance roundrobin
-       option ssl-hello-chk
-       server syslog-prod-site 192.168.1.10 check
-       server syslog-back-site 192.168.2.10 check backup
-
-
-=========================================================
-3. Simple HTTP/HTTPS load-balancing with cookie insertion
-=========================================================
-
-This is the same context as in example 1 above, but the web
-server uses HTTPS.
-
-                +-------+
-                |clients|  clients
-                +---+---+
-                    |
-                   -+-----+--------+----
-                          |       _|_db
-                       +--+--+   (___)
-                       | SSL |   (___)
-                       | web |   (___)
-                       +-----+
-                   192.168.1.1   192.168.1.2
-
-
-Since haproxy does not handle SSL, this part will have to be extracted from the
-servers (freeing even more resources) and installed on the load-balancer
-itself. Install haproxy and apache+mod_ssl on the old box which will spread the
-load between the new boxes. Apache will work in SSL reverse-proxy-cache. If the
-application is correctly developped, it might even lower its load. However,
-since there now is a cache between the clients and haproxy, some security
-measures must be taken to ensure that inserted cookies will not be cached.
-
-
-  192.168.1.1    192.168.1.11-192.168.1.14   192.168.1.2
- -------+-----------+-----+-----+-----+--------+----
-        |           |     |     |     |       _|_db
-     +--+--+      +-+-+ +-+-+ +-+-+ +-+-+    (___)
-     | LB1 |      | A | | B | | C | | D |    (___)
-     +-----+      +---+ +---+ +---+ +---+    (___)
-     apache         4 cheap web servers
-     mod_ssl
-     haproxy 
-
-
-Config on haproxy (LB1) :
--------------------------
-       
-    listen 127.0.0.1:8000
-       mode http
-       balance roundrobin
-       cookie SERVERID insert indirect nocache
-       option httpchk HEAD /index.html HTTP/1.0
-       server webA 192.168.1.11:80 cookie A check
-       server webB 192.168.1.12:80 cookie B check
-       server webC 192.168.1.13:80 cookie C check
-       server webD 192.168.1.14:80 cookie D check
-       
-
-Description :
--------------
- - apache on LB1 will receive clients requests on port 443
- - it forwards it to haproxy bound to 127.0.0.1:8000
- - if a request does not contain a cookie, it will be forwarded to a valid
-   server
- - in return, a cookie "SERVERID" will be inserted in the response holding the
-   server name (eg: "A"), and a "Cache-control: private" header will be added
-   so that the apache does not cache any page containing such cookie.
- - when the client comes again with the cookie "SERVERID=A", LB1 will know that
-   it must be forwarded to server A. The cookie will be removed so that the
-   server does not see it.
- - if server "webA" dies, the requests will be sent to another valid server
-   and a cookie will be reassigned.
-
-Notes :
--------
- - if the cookie works in "prefix" mode, there is no need to add the "nocache"
-   option because it is an application cookie which will be modified, and the
-   application flags will be preserved.
- - if apache 1.3 is used as a front-end before haproxy, it always disables
-   HTTP keep-alive on the back-end, so there is no need for the "httpclose"
-   option on haproxy.
- - configure apache to set the X-Forwarded-For header itself, and do not do
-   it on haproxy if you need the application to know about the client's IP.
-
-
-Flows :
--------
-
-(apache)                           (haproxy)                         (server A)
-  >-- GET /URI1 HTTP/1.0 ------------> |
-               ( no cookie, haproxy forwards in load-balancing mode. )
-                                       | >-- GET /URI1 HTTP/1.0 ---------->
-                                       | <-- HTTP/1.0 200 OK -------------<
-               ( the proxy now adds the server cookie in return )
-  <-- HTTP/1.0 200 OK ---------------< |
-      Set-Cookie: SERVERID=A           |
-      Cache-Control: private           |
-  >-- GET /URI2 HTTP/1.0 ------------> |
-      Cookie: SERVERID=A               |
-      ( the proxy sees the cookie. it forwards to server A and deletes it )
-                                       | >-- GET /URI2 HTTP/1.0 ---------->
-                                       | <-- HTTP/1.0 200 OK -------------<
-   ( the proxy does not add the cookie in return because the client knows it )
-  <-- HTTP/1.0 200 OK ---------------< |
-  >-- GET /URI3 HTTP/1.0 ------------> |
-      Cookie: SERVERID=A               |
-                                    ( ... )
-
-
-
-========================================
-3.1. Alternate solution using Stunnel
-========================================
-
-When only SSL is required and cache is not needed, stunnel is a cheaper
-solution than Apache+mod_ssl. By default, stunnel does not process HTTP and
-does not add any X-Forwarded-For header, but there is a patch on the official
-haproxy site to provide this feature to recent stunnel versions.
-
-This time, stunnel will only process HTTPS and not HTTP. This means that
-haproxy will get all HTTP traffic, so haproxy will have to add the
-X-Forwarded-For header for HTTP traffic, but not for HTTPS traffic since
-stunnel will already have done it. We will use the "except" keyword to tell
-haproxy that connections from local host already have a valid header.
-
-
-  192.168.1.1    192.168.1.11-192.168.1.14   192.168.1.2
- -------+-----------+-----+-----+-----+--------+----
-        |           |     |     |     |       _|_db
-     +--+--+      +-+-+ +-+-+ +-+-+ +-+-+    (___)
-     | LB1 |      | A | | B | | C | | D |    (___)
-     +-----+      +---+ +---+ +---+ +---+    (___)
-     stunnel        4 cheap web servers
-     haproxy 
-
-
-Config on stunnel (LB1) :
--------------------------
-
-    cert=/etc/stunnel/stunnel.pem
-    setuid=stunnel
-    setgid=proxy
-
-    socket=l:TCP_NODELAY=1
-    socket=r:TCP_NODELAY=1
-
-    [https]
-    accept=192.168.1.1:443
-    connect=192.168.1.1:80
-    xforwardedfor=yes
-
-
-Config on haproxy (LB1) :
--------------------------
-       
-    listen 192.168.1.1:80
-       mode http
-       balance roundrobin
-       option forwardfor except 192.168.1.1
-       cookie SERVERID insert indirect nocache
-       option httpchk HEAD /index.html HTTP/1.0
-       server webA 192.168.1.11:80 cookie A check
-       server webB 192.168.1.12:80 cookie B check
-       server webC 192.168.1.13:80 cookie C check
-       server webD 192.168.1.14:80 cookie D check
-
-Description :
--------------
- - stunnel on LB1 will receive clients requests on port 443
- - it forwards them to haproxy bound to port 80
- - haproxy will receive HTTP client requests on port 80 and decrypted SSL
-   requests from Stunnel on the same port.
- - stunnel will add the X-Forwarded-For header
- - haproxy will add the X-Forwarded-For header for everyone except the local
-   address (stunnel).
-
-
-========================================
-4. Soft-stop for application maintenance
-========================================
-
-When an application is spread across several servers, the time to update all
-instances increases, so the application seems jerky for a longer period.
-
-HAproxy offers several solutions for this. Although it cannot be reconfigured
-without being stopped, nor does it offer any external command, there are other
-working solutions.
-
-
-=========================================
-4.1 Soft-stop using a file on the servers
-=========================================
-
-This trick is quite common and very simple: put a file on the server which will
-be checked by the proxy. When you want to stop the server, first remove this
-file. The proxy will see the server as failed, and will not send it any new
-session, only the old ones if the "persist" option is used. Wait a bit then
-stop the server when it does not receive anymore connections.
-
-       
-    listen 192.168.1.1:80
-       mode http
-       balance roundrobin
-       cookie SERVERID insert indirect
-       option httpchk HEAD /running HTTP/1.0
-       server webA 192.168.1.11:80 cookie A check inter 2000 rise 2 fall 2
-       server webB 192.168.1.12:80 cookie B check inter 2000 rise 2 fall 2
-       server webC 192.168.1.13:80 cookie C check inter 2000 rise 2 fall 2
-       server webD 192.168.1.14:80 cookie D check inter 2000 rise 2 fall 2
-       option persist
-       redispatch
-       contimeout 5000
-
-
-Description :
--------------
- - every 2 seconds, haproxy will try to access the file "/running" on the
-   servers, and declare the server as down after 2 attempts (4 seconds).
- - only the servers which respond with a 200 or 3XX response will be used.
- - if a request does not contain a cookie, it will be forwarded to a valid
-   server
- - if a request contains a cookie for a failed server, haproxy will insist
-   on trying to reach the server anyway, to let the user finish what he was
-   doing. ("persist" option)
- - if the server is totally stopped, the connection will fail and the proxy
-   will rebalance the client to another server ("redispatch")
-
-Usage on the web servers :
---------------------------
-- to start the server :
-    # /etc/init.d/httpd start
-    # touch /home/httpd/www/running
-
-- to soft-stop the server
-    # rm -f /home/httpd/www/running
-
-- to completely stop the server :
-    # /etc/init.d/httpd stop
-
-Limits
-------
-If the server is totally powered down, the proxy will still try to reach it
-for those clients who still have a cookie referencing it, and the connection
-attempt will expire after 5 seconds ("contimeout"), and only after that, the
-client will be redispatched to another server. So this mode is only useful
-for software updates where the server will suddenly refuse the connection
-because the process is stopped. The problem is the same if the server suddenly
-crashes. All of its users will be fairly perturbated.
-
-
-==================================
-4.2 Soft-stop using backup servers
-==================================
-
-A better solution which covers every situation is to use backup servers.
-Version 1.1.30 fixed a bug which prevented a backup server from sharing
-the same cookie as a standard server.
-
-       
-    listen 192.168.1.1:80
-       mode http
-       balance roundrobin
-       redispatch
-       cookie SERVERID insert indirect
-       option httpchk HEAD / HTTP/1.0
-       server webA 192.168.1.11:80 cookie A check port 81 inter 2000
-       server webB 192.168.1.12:80 cookie B check port 81 inter 2000
-       server webC 192.168.1.13:80 cookie C check port 81 inter 2000
-       server webD 192.168.1.14:80 cookie D check port 81 inter 2000
-
-       server bkpA 192.168.1.11:80 cookie A check port 80 inter 2000 backup
-       server bkpB 192.168.1.12:80 cookie B check port 80 inter 2000 backup
-       server bkpC 192.168.1.13:80 cookie C check port 80 inter 2000 backup
-       server bkpD 192.168.1.14:80 cookie D check port 80 inter 2000 backup
-
-Description
------------
-Four servers webA..D are checked on their port 81 every 2 seconds. The same
-servers named bkpA..D are checked on the port 80, and share the exact same
-cookies. Those servers will only be used when no other server is available
-for the same cookie.
-
-When the web servers are started, only the backup servers are seen as
-available. On the web servers, you need to redirect port 81 to local
-port 80, either with a local proxy (eg: a simple haproxy tcp instance),
-or with iptables (linux) or pf (openbsd). This is because we want the
-real web server to reply on this port, and not a fake one. Eg, with
-iptables :
-
-  # /etc/init.d/httpd start
-  # iptables -t nat -A PREROUTING -p tcp --dport 81 -j REDIRECT --to-port 80
-
-A few seconds later, the standard server is seen up and haproxy starts to send
-it new requests on its real port 80 (only new users with no cookie, of course).
-
-If a server completely crashes (even if it does not respond at the IP level),
-both the standard and backup servers will fail, so clients associated to this
-server will be redispatched to other live servers and will lose their sessions.
-
-Now if you want to enter a server into maintenance, simply stop it from
-responding on port 81 so that its standard instance will be seen as failed,
-but the backup will still work. Users will not notice anything since the
-service is still operational :
-
-  # iptables -t nat -D PREROUTING -p tcp --dport 81 -j REDIRECT --to-port 80
-
-The health checks on port 81 for this server will quickly fail, and the
-standard server will be seen as failed. No new session will be sent to this
-server, and existing clients with a valid cookie will still reach it because
-the backup server will still be up.
-
-Now wait as long as you want for the old users to stop using the service, and
-once you see that the server does not receive any traffic, simply stop it :
-
-  # /etc/init.d/httpd stop
-
-The associated backup server will in turn fail, and if any client still tries
-to access this particular server, he will be redispatched to any other valid
-server because of the "redispatch" option.
-
-This method has an advantage : you never touch the proxy when doing server
-maintenance. The people managing the servers can make them disappear smoothly.
-
-
-4.2.1 Variations for operating systems without any firewall software
---------------------------------------------------------------------
-
-The downside is that you need a redirection solution on the server just for
-the health-checks. If the server OS does not support any firewall software,
-this redirection can also be handled by a simple haproxy in tcp mode :
-
-    global
-        daemon
-        quiet
-        pidfile /var/run/haproxy-checks.pid
-    listen 0.0.0.0:81
-        mode tcp
-        dispatch 127.0.0.1:80
-        contimeout 1000
-        clitimeout 10000
-        srvtimeout 10000
-
-To start the web service :
-
-  # /etc/init.d/httpd start
-  # haproxy -f /etc/haproxy/haproxy-checks.cfg
-
-To soft-stop the service :
-
-  # kill $(</var/run/haproxy-checks.pid)
-
-The port 81 will stop responding and the load-balancer will notice the failure.
-
-
-4.2.2 Centralizing the server management
-----------------------------------------
-
-If one finds it preferable to manage the servers from the load-balancer itself,
-the port redirector can be installed on the load-balancer itself. See the
-example with iptables below.
-
-Make the servers appear as operational :
-  # iptables -t nat -A OUTPUT -d 192.168.1.11 -p tcp --dport 81 -j DNAT --to-dest :80
-  # iptables -t nat -A OUTPUT -d 192.168.1.12 -p tcp --dport 81 -j DNAT --to-dest :80
-  # iptables -t nat -A OUTPUT -d 192.168.1.13 -p tcp --dport 81 -j DNAT --to-dest :80
-  # iptables -t nat -A OUTPUT -d 192.168.1.14 -p tcp --dport 81 -j DNAT --to-dest :80
-
-Soft stop one server :
-  # iptables -t nat -D OUTPUT -d 192.168.1.12 -p tcp --dport 81 -j DNAT --to-dest :80
-
-Another solution is to use the "COMAFILE" patch provided by Alexander Lazic,
-which is available for download here :
-
-   http://w.ods.org/tools/haproxy/contrib/
-
-
-4.2.3 Notes :
--------------
-  - Never, ever, start a fake service on port 81 for the health-checks, because
-    a real web service failure will not be detected as long as the fake service
-    runs. You must really forward the check port to the real application.
-
-  - health-checks will be sent twice as often, once for each standard server,
-    and once for each backup server. All this will be multiplicated by the
-    number of processes if you use multi-process mode. You will have to ensure
-    that all the checks sent to the server do not overload it.
-
-=======================
-4.3 Hot reconfiguration
-=======================
-
-There are two types of haproxy users :
-  - those who can never do anything in production out of maintenance periods ;
-  - those who can do anything at any time provided that the consequences are
-    limited.
-
-The first ones have no problem stopping the server to change configuration
-because they got some maintenance periods during which they can break anything.
-So they will even prefer doing a clean stop/start sequence to ensure everything
-will work fine upon next reload. Since those have represented the majority of
-haproxy uses, there has been little effort trying to improve this.
-
-However, the second category is a bit different. They like to be able to fix an
-error in a configuration file without anyone noticing. This can sometimes also
-be the case for the first category because humans are not failsafe.
-
-For this reason, a new hot reconfiguration mechanism has been introduced in
-version 1.1.34. Its usage is very simple and works even in chrooted
-environments with lowered privileges. The principle is very simple : upon
-reception of a SIGTTOU signal, the proxy will stop listening to all the ports.
-This will release the ports so that a new instance can be started. Existing
-connections will not be broken at all. If the new instance fails to start,
-then sending a SIGTTIN signal back to the original processes will restore
-the listening ports. This is possible without any special privileges because
-the sockets will not have been closed, so the bind() is still valid. Otherwise,
-if the new process starts successfully, then sending a SIGUSR1 signal to the
-old one ensures that it will exit as soon as its last session ends.
-
-A hot reconfiguration script would look like this :
-
-  # save previous state
-  mv /etc/haproxy/config /etc/haproxy/config.old
-  mv /var/run/haproxy.pid /var/run/haproxy.pid.old
-
-  mv /etc/haproxy/config.new /etc/haproxy/config
-  kill -TTOU $(cat /var/run/haproxy.pid.old)
-  if haproxy -p /var/run/haproxy.pid -f /etc/haproxy/config; then
-    echo "New instance successfully loaded, stopping previous one."
-    kill -USR1 $(cat /var/run/haproxy.pid.old)
-    rm -f /var/run/haproxy.pid.old
-    exit 1
-  else
-    echo "New instance failed to start, resuming previous one."
-    kill -TTIN $(cat /var/run/haproxy.pid.old)
-    rm -f /var/run/haproxy.pid
-    mv /var/run/haproxy.pid.old /var/run/haproxy.pid
-    mv /etc/haproxy/config /etc/haproxy/config.new
-    mv /etc/haproxy/config.old /etc/haproxy/config
-    exit 0
-  fi
-
-After this, you can still force old connections to end by sending
-a SIGTERM to the old process if it still exists :
-
-    kill $(cat /var/run/haproxy.pid.old)
-    rm -f /var/run/haproxy.pid.old
-
-Be careful with this as in multi-process mode, some pids might already
-have been reallocated to completely different processes.
-
-
-==================================================
-5. Multi-site load-balancing with local preference
-==================================================
-
-5.1 Description of the problem
-==============================
-
-Consider a world-wide company with sites on several continents. There are two
-production sites SITE1 and SITE2 which host identical applications. There are
-many offices around the world. For speed and communication cost reasons, each
-office uses the nearest site by default, but can switch to the backup site in
-the event of a site or application failure. There also are users on the
-production sites, which use their local sites by default, but can switch to the
-other site in case of a local application failure.
-
-The main constraints are :
-
-  - application persistence : although the application is the same on both
-    sites, there is no session synchronisation between the sites. A failure
-    of one server or one site can cause a user to switch to another server
-    or site, but when the server or site comes back, the user must not switch
-    again.
-
-  - communication costs : inter-site communication should be reduced to the
-    minimum. Specifically, in case of a local application failure, every
-    office should be able to switch to the other site without continuing to
-    use the default site.
-
-5.2 Solution
-============
-  - Each production site will have two haproxy load-balancers in front of its
-    application servers to balance the load across them and provide local HA.
-    We will call them "S1L1" and "S1L2" on site 1, and "S2L1" and "S2L2" on
-    site 2. These proxies will extend the application's JSESSIONID cookie to
-    put the server name as a prefix.
-
-  - Each production site will have one front-end haproxy director to provide
-    the service to local users and to remote offices. It will load-balance
-    across the two local load-balancers, and will use the other site's
-    load-balancers as backup servers. It will insert the local site identifier
-    in a SITE cookie for the local load-balancers, and the remote site
-    identifier for the remote load-balancers. These front-end directors will
-    be called "SD1" and "SD2" for "Site Director".
-
-  - Each office will have one haproxy near the border gateway which will direct
-    local users to their preference site by default, or to the backup site in
-    the event of a previous failure. It will also analyze the SITE cookie, and
-    direct the users to the site referenced in the cookie. Thus, the preferred
-    site will be declared as a normal server, and the backup site will be
-    declared as a backup server only, which will only be used when the primary
-    site is unreachable, or when the primary site's director has forwarded
-    traffic to the second site. These proxies will be called "OP1".."OPXX"
-    for "Office Proxy #XX".
-
-  
-5.3 Network diagram
-===================
-
-Note : offices 1 and 2 are on the same continent as site 1, while
-       office 3 is on the same continent as site 3. Each production
-       site can reach the second one either through the WAN or through
-       a dedicated link.
-
-
-        Office1         Office2                          Office3
-         users           users                            users
-192.168  # # #   192.168 # # #                            # # #
-.1.0/24  | | |   .2.0/24 | | |             192.168.3.0/24 | | |	  
-  --+----+-+-+-   --+----+-+-+-                   ---+----+-+-+- 
-    |      | .1     |      | .1                      |      | .1
-    |    +-+-+      |    +-+-+                       |    +-+-+
-    |    |OP1|      |    |OP2|                       |    |OP3|  ...
-  ,-:-.  +---+    ,-:-.  +---+                     ,-:-.  +---+
- (  X  )         (  X  )                          (  X  )        
-  `-:-'           `-:-'             ,---.          `-:-'         
-  --+---------------+------+----~~~(  X  )~~~~-------+---------+-
-                           |        `---'                      |    
-                           |                                   |    
-                 +---+   ,-:-.                       +---+   ,-:-.  
-                 |SD1|  (  X  )                      |SD2|  (  X  )
-   ( SITE 1 )    +-+-+   `-:-'         ( SITE 2 )    +-+-+   `-:-'
-                   |.1     |                           |.1     |    
-   10.1.1.0/24     |       |     ,---. 10.2.1.0/24     |       |    
-        -+-+-+-+-+-+-+-----+-+--(  X  )------+-+-+-+-+-+-+-----+-+--
-         | | | | |   |       |   `---'       | | | | |   |       |
-      ...# # # # #   |.11    |.12         ...# # # # #   |.11    |.12
-          Site 1   +-+--+  +-+--+              Site 2  +-+--+  +-+--+   
-          Local    |S1L1|  |S1L2|              Local   |S2L1|  |S2L2|   
-          users    +-+--+  +--+-+              users   +-+--+  +--+-+   
-                     |        |	                         |        |     
-   10.1.2.0/24    -+-+-+--+--++--      10.2.2.0/24    -+-+-+--+--++--   
-                   |.1       |.4                       |.1       |.4
-                 +-+-+     +-+-+                     +-+-+     +-+-+    
-                 |W11| ~~~ |W14|                     |W21| ~~~ |W24|    
-                 +---+     +---+                     +---+     +---+    
-              4 application servers               4 application servers
-                    on site 1                           on site 2
-
-
-
-5.4 Description
-===============
-
-5.4.1 Local users
------------------
- - Office 1 users connect to OP1 = 192.168.1.1
- - Office 2 users connect to OP2 = 192.168.2.1
- - Office 3 users connect to OP3 = 192.168.3.1
- - Site 1 users connect to SD1 = 10.1.1.1
- - Site 2 users connect to SD2 = 10.2.1.1
-
-5.4.2 Office proxies
---------------------
- - Office 1 connects to site 1 by default and uses site 2 as a backup.
- - Office 2 connects to site 1 by default and uses site 2 as a backup.
- - Office 3 connects to site 2 by default and uses site 1 as a backup.
-
-The offices check the local site's SD proxy every 30 seconds, and the
-remote one every 60 seconds.
-
-
-Configuration for Office Proxy OP1
-----------------------------------
-
-    listen 192.168.1.1:80
-       mode http
-       balance roundrobin
-       redispatch
-       cookie SITE
-       option httpchk HEAD / HTTP/1.0
-       server SD1 10.1.1.1:80 cookie SITE1 check inter 30000
-       server SD2 10.2.1.1:80 cookie SITE2 check inter 60000 backup
-
-
-Configuration for Office Proxy OP2
-----------------------------------
-
-    listen 192.168.2.1:80
-       mode http
-       balance roundrobin
-       redispatch
-       cookie SITE
-       option httpchk HEAD / HTTP/1.0
-       server SD1 10.1.1.1:80 cookie SITE1 check inter 30000
-       server SD2 10.2.1.1:80 cookie SITE2 check inter 60000 backup
-
-
-Configuration for Office Proxy OP3
-----------------------------------
-
-    listen 192.168.3.1:80
-       mode http
-       balance roundrobin
-       redispatch
-       cookie SITE
-       option httpchk HEAD / HTTP/1.0
-       server SD2 10.2.1.1:80 cookie SITE2 check inter 30000
-       server SD1 10.1.1.1:80 cookie SITE1 check inter 60000 backup
-
-
-5.4.3 Site directors ( SD1 and SD2 )
-------------------------------------
-The site directors forward traffic to the local load-balancers, and set a
-cookie to identify the site. If no local load-balancer is available, or if
-the local application servers are all down, it will redirect traffic to the
-remote site, and report this in the SITE cookie. In order not to uselessly
-load each site's WAN link, each SD will check the other site at a lower
-rate. The site directors will also insert their client's address so that
-the application server knows which local user or remote site accesses it.
-
-The SITE cookie which is set by these directors will also be understood
-by the office proxies. This is important because if SD1 decides to forward
-traffic to site 2, it will write "SITE2" in the "SITE" cookie, and on next
-request, the office proxy will automatically and directly talk to SITE2 if
-it can reach it. If it cannot, it will still send the traffic to SITE1
-where SD1 will in turn try to reach SITE2.
-
-The load-balancers checks are performed on port 81. As we'll see further,
-the load-balancers provide a health monitoring port 81 which reroutes to
-port 80 but which allows them to tell the SD that they are going down soon
-and that the SD must not use them anymore.
-
-
-Configuration for SD1
----------------------
-
-    listen 10.1.1.1:80
-       mode http
-       balance roundrobin
-       redispatch
-       cookie SITE insert indirect
-       option httpchk HEAD / HTTP/1.0
-       option forwardfor
-       server S1L1 10.1.1.11:80 cookie SITE1 check port 81 inter 4000
-       server S1L2 10.1.1.12:80 cookie SITE1 check port 81 inter 4000
-       server S2L1 10.2.1.11:80 cookie SITE2 check port 81 inter 8000 backup
-       server S2L2 10.2.1.12:80 cookie SITE2 check port 81 inter 8000 backup
-
-Configuration for SD2
----------------------
-
-    listen 10.2.1.1:80
-       mode http
-       balance roundrobin
-       redispatch
-       cookie SITE insert indirect
-       option httpchk HEAD / HTTP/1.0
-       option forwardfor
-       server S2L1 10.2.1.11:80 cookie SITE2 check port 81 inter 4000
-       server S2L2 10.2.1.12:80 cookie SITE2 check port 81 inter 4000
-       server S1L1 10.1.1.11:80 cookie SITE1 check port 81 inter 8000 backup
-       server S1L2 10.1.1.12:80 cookie SITE1 check port 81 inter 8000 backup
-
-
-5.4.4 Local load-balancers S1L1, S1L2, S2L1, S2L2
--------------------------------------------------
-Please first note that because SD1 and SD2 use the same cookie for both
-servers on a same site, the second load-balancer of each site will only
-receive load-balanced requests, but as soon as the SITE cookie will be
-set, only the first LB will receive the requests because it will be the
-first one to match the cookie.
-
-The load-balancers will spread the load across 4 local web servers, and
-use the JSESSIONID provided by the application to provide server persistence
-using the new 'prefix' method. Soft-stop will also be implemented as described
-in section 4 above. Moreover, these proxies will provide their own maintenance
-soft-stop. Port 80 will be used for application traffic, while port 81 will
-only be used for health-checks and locally rerouted to port 80. A grace time
-will be specified to service on port 80, but not on port 81. This way, a soft
-kill (kill -USR1) on the proxy will only kill the health-check forwarder so
-that the site director knows it must not use this load-balancer anymore. But
-the service will still work for 20 seconds and as long as there are established
-sessions.
-
-These proxies will also be the only ones to disable HTTP keep-alive in the
-chain, because it is enough to do it at one place, and it's necessary to do
-it with 'prefix' cookies.
-
-Configuration for S1L1/S1L2
----------------------------
-
-    listen 10.1.1.11:80 # 10.1.1.12:80 for S1L2
-       grace 20000  # don't kill us until 20 seconds have elapsed
-       mode http
-       balance roundrobin
-       cookie JSESSIONID prefix
-       option httpclose
-       option forwardfor
-       option httpchk HEAD / HTTP/1.0
-       server W11 10.1.2.1:80 cookie W11 check port 81 inter 2000
-       server W12 10.1.2.2:80 cookie W12 check port 81 inter 2000
-       server W13 10.1.2.3:80 cookie W13 check port 81 inter 2000
-       server W14 10.1.2.4:80 cookie W14 check port 81 inter 2000
-
-       server B11 10.1.2.1:80 cookie W11 check port 80 inter 4000 backup
-       server B12 10.1.2.2:80 cookie W12 check port 80 inter 4000 backup
-       server B13 10.1.2.3:80 cookie W13 check port 80 inter 4000 backup
-       server B14 10.1.2.4:80 cookie W14 check port 80 inter 4000 backup
-
-    listen 10.1.1.11:81 # 10.1.1.12:81 for S1L2
-       mode tcp
-       dispatch 10.1.1.11:80  # 10.1.1.12:80 for S1L2
-
-
-Configuration for S2L1/S2L2
----------------------------
-
-    listen 10.2.1.11:80 # 10.2.1.12:80 for S2L2
-       grace 20000  # don't kill us until 20 seconds have elapsed
-       mode http
-       balance roundrobin
-       cookie JSESSIONID prefix
-       option httpclose
-       option forwardfor
-       option httpchk HEAD / HTTP/1.0
-       server W21 10.2.2.1:80 cookie W21 check port 81 inter 2000
-       server W22 10.2.2.2:80 cookie W22 check port 81 inter 2000
-       server W23 10.2.2.3:80 cookie W23 check port 81 inter 2000
-       server W24 10.2.2.4:80 cookie W24 check port 81 inter 2000
-
-       server B21 10.2.2.1:80 cookie W21 check port 80 inter 4000 backup
-       server B22 10.2.2.2:80 cookie W22 check port 80 inter 4000 backup
-       server B23 10.2.2.3:80 cookie W23 check port 80 inter 4000 backup
-       server B24 10.2.2.4:80 cookie W24 check port 80 inter 4000 backup
-
-    listen 10.2.1.11:81 # 10.2.1.12:81 for S2L2
-       mode tcp
-       dispatch 10.2.1.11:80  # 10.2.1.12:80 for S2L2
-
-
-5.5 Comments
-------------
-Since each site director sets a cookie identifying the site, remote office
-users will have their office proxies direct them to the right site and stick
-to this site as long as the user still uses the application and the site is
-available. Users on production sites will be directed to the right site by the
-site directors depending on the SITE cookie.
-
-If the WAN link dies on a production site, the remote office users will not
-see their site anymore, so they will redirect the traffic to the second site.
-If there are dedicated inter-site links as on the diagram above, the second
-SD will see the cookie and still be able to reach the original site. For
-example :
-
-Office 1 user sends the following to OP1 :
-  GET / HTTP/1.0
-  Cookie: SITE=SITE1; JSESSIONID=W14~123;
-
-OP1 cannot reach site 1 because its external router is dead. So the SD1 server
-is seen as dead, and OP1 will then forward the request to SD2 on site 2,
-regardless of the SITE cookie.
-
-SD2 on site 2 receives a SITE cookie containing "SITE1". Fortunately, it
-can reach Site 1's load balancers S1L1 and S1L2. So it forwards the request
-so S1L1 (the first one with the same cookie).
-
-S1L1 (on site 1) finds "W14" in the JSESSIONID cookie, so it can forward the
-request to the right server, and the user session will continue to work. Once
-the Site 1's WAN link comes back, OP1 will see SD1 again, and will not route
-through SITE 2 anymore.
-
-However, when a new user on Office 1 connects to the application during a
-site 1 failure, it does not contain any cookie. Since OP1 does not see SD1
-because of the network failure, it will direct the request to SD2 on site 2,
-which will by default direct the traffic to the local load-balancers, S2L1 and
-S2L2. So only initial users will load the inter-site link, not the new ones.
-
-
-===================
-6. Source balancing
-===================
-
-Sometimes it may reveal useful to access servers from a pool of IP addresses
-instead of only one or two. Some equipments (NAT firewalls, load-balancers)
-are sensible to source address, and often need many sources to distribute the
-load evenly amongst their internal hash buckets.
-
-To do this, you simply have to use several times the same server with a
-different source. Example :
-
-    listen 0.0.0.0:80
-       mode tcp
-       balance roundrobin
-       server from1to1 10.1.1.1:80 source 10.1.2.1
-       server from2to1 10.1.1.1:80 source 10.1.2.2
-       server from3to1 10.1.1.1:80 source 10.1.2.3
-       server from4to1 10.1.1.1:80 source 10.1.2.4
-       server from5to1 10.1.1.1:80 source 10.1.2.5
-       server from6to1 10.1.1.1:80 source 10.1.2.6
-       server from7to1 10.1.1.1:80 source 10.1.2.7
-       server from8to1 10.1.1.1:80 source 10.1.2.8
-
-
-=============================================
-7. Managing high loads on application servers
-=============================================
-
-One of the roles often expected from a load balancer is to mitigate the load on
-the servers during traffic peaks. More and more often, we see heavy frameworks
-used to deliver flexible and evolutive web designs, at the cost of high loads
-on the servers, or very low concurrency. Sometimes, response times are also
-rather high. People developing web sites relying on such frameworks very often
-look for a load balancer which is able to distribute the load in the most
-evenly fashion and which will be nice with the servers.
-
-There is a powerful feature in haproxy which achieves exactly this : request
-queueing associated with concurrent connections limit.
-
-Let's say you have an application server which supports at most 20 concurrent
-requests. You have 3 servers, so you can accept up to 60 concurrent HTTP
-connections, which often means 30 concurrent users in case of keep-alive (2
-persistent connections per user).
-
-Even if you disable keep-alive, if the server takes a long time to respond,
-you still have a high risk of multiple users clicking at the same time and
-having their requests unserved because of server saturation. To workaround
-the problem, you increase the concurrent connection limit on the servers,
-but their performance stalls under higher loads.
-
-The solution is to limit the number of connections between the clients and the
-servers. You set haproxy to limit the number of connections on a per-server
-basis, and you let all the users you want connect to it. It will then fill all
-the servers up to the configured connection limit, and will put the remaining
-connections in a queue, waiting for a connection to be released on a server.
-
-This ensures five essential principles :
-
-  - all clients can be served whatever their number without crashing the
-    servers, the only impact it that the response time can be delayed.
-
-  - the servers can be used at full throttle without the risk of stalling,
-    and fine tuning can lead to optimal performance.
-
-  - response times can be reduced by making the servers work below the
-    congestion point, effectively leading to shorter response times even
-    under moderate loads.
-
-  - no domino effect when a server goes down or starts up. Requests will be
-    queued more or less, always respecting servers limits.
-
-  - it's easy to achieve high performance even on memory-limited hardware.
-    Indeed, heavy frameworks often consume huge amounts of RAM and not always
-    all the CPU available. In case of wrong sizing, reducing the number of
-    concurrent connections will protect against memory shortages while still
-    ensuring optimal CPU usage.
-
-
-Example :
----------
-
-Haproxy is installed in front of an application servers farm. It will limit
-the concurrent connections to 4 per server (one thread per CPU), thus ensuring
-very fast response times.
-
-
-  192.168.1.1   192.168.1.11-192.168.1.13   192.168.1.2
- -------+-------------+-----+-----+------------+----
-        |             |     |     |           _|_db
-     +--+--+        +-+-+ +-+-+ +-+-+        (___)
-     | LB1 |        | A | | B | | C |        (___)
-     +-----+        +---+ +---+ +---+        (___)
-     haproxy       3 application servers
-                   with heavy frameworks
-
-
-Config on haproxy (LB1) :
--------------------------
-       
-    listen appfarm 192.168.1.1:80
-       mode http
-       maxconn 10000
-       option httpclose
-       option forwardfor
-       balance roundrobin
-       cookie SERVERID insert indirect
-       option httpchk HEAD /index.html HTTP/1.0
-       server railsA 192.168.1.11:80 cookie A maxconn 4 check
-       server railsB 192.168.1.12:80 cookie B maxconn 4 check
-       server railsC 192.168.1.13:80 cookie C maxconn 4 check
-       contimeout 60000
-
-
-Description :
--------------
-The proxy listens on IP 192.168.1.1, port 80, and expects HTTP requests. It
-can accept up to 10000 concurrent connections on this socket. It follows the
-roundrobin algorithm to assign servers to connections as long as servers are
-not saturated.
-
-It allows up to 4 concurrent connections per server, and will queue the
-requests above this value. The "contimeout" parameter is used to set the
-maximum time a connection may take to establish on a server, but here it
-is also used to set the maximum time a connection may stay unserved in the
-queue (1 minute here).
-
-If the servers can each process 4 requests in 10 ms on average, then at 3000
-connections, response times will be delayed by at most :
-
-   3000 / 3 servers / 4 conns * 10 ms = 2.5 seconds
-
-Which is not that dramatic considering the huge number of users for such a low
-number of servers.
-
-When connection queues fill up and application servers are starving, response
-times will grow and users might abort by clicking on the "Stop" button. It is
-very undesirable to send aborted requests to servers, because they will eat
-CPU cycles for nothing.
-
-An option has been added to handle this specific case : "option abortonclose".
-By specifying it, you tell haproxy that if an input channel is closed on the
-client side AND the request is still waiting in the queue, then it is highly
-likely that the user has stopped, so we remove the request from the queue
-before it will get served.
-
-
-Managing unfair response times
-------------------------------
-
-Sometimes, the application server will be very slow for some requests (eg:
-login page) and faster for other requests. This may cause excessive queueing
-of expectedly fast requests when all threads on the server are blocked on a
-request to the database. Then the only solution is to increase the number of
-concurrent connections, so that the server can handle a large average number
-of slow connections with threads left to handle faster connections.
-
-But as we have seen, increasing the number of connections on the servers can
-be detrimental to performance (eg: Apache processes fighting for the accept()
-lock). To improve this situation, the "minconn" parameter has been introduced.
-When it is set, the maximum connection concurrency on the server will be bound
-by this value, and the limit will increase with the number of clients waiting
-in queue, till the clients connected to haproxy reach the proxy's maxconn, in
-which case the connections per server will reach the server's maxconn. It means
-that during low-to-medium loads, the minconn will be applied, and during surges
-the maxconn will be applied. It ensures both optimal response times under
-normal loads, and availability under very high loads.
-
-Example :
----------
-       
-    listen appfarm 192.168.1.1:80
-       mode http
-       maxconn 10000
-       option httpclose
-       option abortonclose
-       option forwardfor
-       balance roundrobin
-       # The servers will get 4 concurrent connections under low
-       # loads, and 12 when there will be 10000 clients.
-       server railsA 192.168.1.11:80 minconn 4 maxconn 12 check
-       server railsB 192.168.1.12:80 minconn 4 maxconn 12 check
-       server railsC 192.168.1.13:80 minconn 4 maxconn 12 check
-       contimeout 60000
-
-
diff --git a/deps/haproxy-1.4.21/doc/configuration.txt b/deps/haproxy-1.4.21/doc/configuration.txt
deleted file mode 100644
index 1d4344a..0000000
--- a/deps/haproxy-1.4.21/doc/configuration.txt
+++ /dev/null
@@ -1,8604 +0,0 @@
-                         ----------------------
-                                 HAProxy
-                          Configuration Manual
-                         ----------------------
-                             version 1.4.21
-                             willy tarreau
-                               2012/05/21
-
-
-This document covers the configuration language as implemented in the version
-specified above. It does not provide any hint, example or advice. For such
-documentation, please refer to the Reference Manual or the Architecture Manual.
-The summary below is meant to help you search sections by name and navigate
-through the document.
-
-Note to documentation contributors :
-    This document is formated with 80 columns per line, with even number of
-    spaces for indentation and without tabs. Please follow these rules strictly
-    so that it remains easily printable everywhere. If a line needs to be
-    printed verbatim and does not fit, please end each line with a backslash
-    ('\') and continue on next line. If you add sections, please update the
-    summary below for easier searching.
-
-
-Summary
--------
-
-1.    Quick reminder about HTTP
-1.1.      The HTTP transaction model
-1.2.      HTTP request
-1.2.1.        The Request line
-1.2.2.        The request headers
-1.3.      HTTP response
-1.3.1.        The Response line
-1.3.2.        The response headers
-
-2.    Configuring HAProxy
-2.1.      Configuration file format
-2.2.      Time format
-2.3.      Examples
-
-3.    Global parameters
-3.1.      Process management and security
-3.2.      Performance tuning
-3.3.      Debugging
-3.4.      Userlists
-
-4.    Proxies
-4.1.      Proxy keywords matrix
-4.2.      Alphabetically sorted keywords reference
-
-5.    Server and default-server options
-
-6.    HTTP header manipulation
-
-7.    Using ACLs and pattern extraction
-7.1.      Matching integers
-7.2.      Matching strings
-7.3.      Matching regular expressions (regexes)
-7.4.      Matching IPv4 addresses
-7.5.      Available matching criteria
-7.5.1.        Matching at Layer 4 and below
-7.5.2.        Matching contents at Layer 4
-7.5.3.        Matching at Layer 7
-7.6.      Pre-defined ACLs
-7.7.      Using ACLs to form conditions
-7.8.      Pattern extraction
-
-8.    Logging
-8.1.      Log levels
-8.2.      Log formats
-8.2.1.        Default log format
-8.2.2.        TCP log format
-8.2.3.        HTTP log format
-8.3.      Advanced logging options
-8.3.1.        Disabling logging of external tests
-8.3.2.        Logging before waiting for the session to terminate
-8.3.3.        Raising log level upon errors
-8.3.4.        Disabling logging of successful connections
-8.4.      Timing events
-8.5.      Session state at disconnection
-8.6.      Non-printable characters
-8.7.      Capturing HTTP cookies
-8.8.      Capturing HTTP headers
-8.9.      Examples of logs
-
-9.    Statistics and monitoring
-9.1.      CSV format
-9.2.      Unix Socket commands
-
-
-1. Quick reminder about HTTP
-----------------------------
-
-When haproxy is running in HTTP mode, both the request and the response are
-fully analyzed and indexed, thus it becomes possible to build matching criteria
-on almost anything found in the contents.
-
-However, it is important to understand how HTTP requests and responses are
-formed, and how HAProxy decomposes them. It will then become easier to write
-correct rules and to debug existing configurations.
-
-
-1.1. The HTTP transaction model
--------------------------------
-
-The HTTP protocol is transaction-driven. This means that each request will lead
-to one and only one response. Traditionally, a TCP connection is established
-from the client to the server, a request is sent by the client on the
-connection, the server responds and the connection is closed. A new request
-will involve a new connection :
-
-  [CON1] [REQ1] ... [RESP1] [CLO1] [CON2] [REQ2] ... [RESP2] [CLO2] ...
-
-In this mode, called the "HTTP close" mode, there are as many connection
-establishments as there are HTTP transactions. Since the connection is closed
-by the server after the response, the client does not need to know the content
-length.
-
-Due to the transactional nature of the protocol, it was possible to improve it
-to avoid closing a connection between two subsequent transactions. In this mode
-however, it is mandatory that the server indicates the content length for each
-response so that the client does not wait indefinitely. For this, a special
-header is used: "Content-length". This mode is called the "keep-alive" mode :
-
-  [CON] [REQ1] ... [RESP1] [REQ2] ... [RESP2] [CLO] ...
-
-Its advantages are a reduced latency between transactions, and less processing
-power required on the server side. It is generally better than the close mode,
-but not always because the clients often limit their concurrent connections to
-a smaller value.
-
-A last improvement in the communications is the pipelining mode. It still uses
-keep-alive, but the client does not wait for the first response to send the
-second request. This is useful for fetching large number of images composing a
-page :
-
-  [CON] [REQ1] [REQ2] ... [RESP1] [RESP2] [CLO] ...
-
-This can obviously have a tremendous benefit on performance because the network
-latency is eliminated between subsequent requests. Many HTTP agents do not
-correctly support pipelining since there is no way to associate a response with
-the corresponding request in HTTP. For this reason, it is mandatory for the
-server to reply in the exact same order as the requests were received.
-
-By default HAProxy operates in a tunnel-like mode with regards to persistent
-connections: for each connection it processes the first request and forwards
-everything else (including additional requests) to selected server. Once
-established, the connection is persisted both on the client and server
-sides. Use "option http-server-close" to preserve client persistent connections
-while handling every incoming request individually, dispatching them one after
-another to servers, in HTTP close mode. Use "option httpclose" to switch both
-sides to HTTP close mode. "option forceclose" and "option
-http-pretend-keepalive" help working around servers misbehaving in HTTP close
-mode.
-
-
-1.2. HTTP request
------------------
-
-First, let's consider this HTTP request :
-
-  Line     Contents
-  number
-     1     GET /serv/login.php?lang=en&profile=2 HTTP/1.1
-     2     Host: www.mydomain.com
-     3     User-agent: my small browser
-     4     Accept: image/jpeg, image/gif
-     5     Accept: image/png
-
-
-1.2.1. The Request line
------------------------
-
-Line 1 is the "request line". It is always composed of 3 fields :
-
-  - a METHOD      : GET
-  - a URI         : /serv/login.php?lang=en&profile=2
-  - a version tag : HTTP/1.1
-
-All of them are delimited by what the standard calls LWS (linear white spaces),
-which are commonly spaces, but can also be tabs or line feeds/carriage returns
-followed by spaces/tabs. The method itself cannot contain any colon (':') and
-is limited to alphabetic letters. All those various combinations make it
-desirable that HAProxy performs the splitting itself rather than leaving it to
-the user to write a complex or inaccurate regular expression.
-
-The URI itself can have several forms :
-
-  - A "relative URI" :
-
-      /serv/login.php?lang=en&profile=2
-
-    It is a complete URL without the host part. This is generally what is
-    received by servers, reverse proxies and transparent proxies.
-
-  - An "absolute URI", also called a "URL" :
-
-      http://192.168.0.12:8080/serv/login.php?lang=en&profile=2
-
-    It is composed of a "scheme" (the protocol name followed by '://'), a host
-    name or address, optionally a colon (':') followed by a port number, then
-    a relative URI beginning at the first slash ('/') after the address part.
-    This is generally what proxies receive, but a server supporting HTTP/1.1
-    must accept this form too.
-
-  - a star ('*') : this form is only accepted in association with the OPTIONS
-    method and is not relayable. It is used to inquiry a next hop's
-    capabilities.
-
-  - an address:port combination : 192.168.0.12:80
-    This is used with the CONNECT method, which is used to establish TCP
-    tunnels through HTTP proxies, generally for HTTPS, but sometimes for
-    other protocols too.
-
-In a relative URI, two sub-parts are identified. The part before the question
-mark is called the "path". It is typically the relative path to static objects
-on the server. The part after the question mark is called the "query string".
-It is mostly used with GET requests sent to dynamic scripts and is very
-specific to the language, framework or application in use.
-
-
-1.2.2. The request headers
---------------------------
-
-The headers start at the second line. They are composed of a name at the
-beginning of the line, immediately followed by a colon (':'). Traditionally,
-an LWS is added after the colon but that's not required. Then come the values.
-Multiple identical headers may be folded into one single line, delimiting the
-values with commas, provided that their order is respected. This is commonly
-encountered in the "Cookie:" field. A header may span over multiple lines if
-the subsequent lines begin with an LWS. In the example in 1.2, lines 4 and 5
-define a total of 3 values for the "Accept:" header.
-
-Contrary to a common mis-conception, header names are not case-sensitive, and
-their values are not either if they refer to other header names (such as the
-"Connection:" header).
-
-The end of the headers is indicated by the first empty line. People often say
-that it's a double line feed, which is not exact, even if a double line feed
-is one valid form of empty line.
-
-Fortunately, HAProxy takes care of all these complex combinations when indexing
-headers, checking values and counting them, so there is no reason to worry
-about the way they could be written, but it is important not to accuse an
-application of being buggy if it does unusual, valid things.
-
-Important note:
-   As suggested by RFC2616, HAProxy normalizes headers by replacing line breaks
-   in the middle of headers by LWS in order to join multi-line headers. This
-   is necessary for proper analysis and helps less capable HTTP parsers to work
-   correctly and not to be fooled by such complex constructs.
-
-
-1.3. HTTP response
-------------------
-
-An HTTP response looks very much like an HTTP request. Both are called HTTP
-messages. Let's consider this HTTP response :
-
-  Line     Contents
-  number
-     1     HTTP/1.1 200 OK
-     2     Content-length: 350
-     3     Content-Type: text/html
-
-As a special case, HTTP supports so called "Informational responses" as status
-codes 1xx. These messages are special in that they don't convey any part of the
-response, they're just used as sort of a signaling message to ask a client to
-continue to post its request for instance. In the case of a status 100 response
-the requested information will be carried by the next non-100 response message
-following the informational one. This implies that multiple responses may be
-sent to a single request, and that this only works when keep-alive is enabled
-(1xx messages are HTTP/1.1 only). HAProxy handles these messages and is able to
-correctly forward and skip them, and only process the next non-100 response. As
-such, these messages are neither logged nor transformed, unless explicitly
-state otherwise. Status 101 messages indicate that the protocol is changing
-over the same connection and that haproxy must switch to tunnel mode, just as
-if a CONNECT had occurred. Then the Upgrade header would contain additional
-information about the type of protocol the connection is switching to.
-
-
-1.3.1. The Response line
-------------------------
-
-Line 1 is the "response line". It is always composed of 3 fields :
-
-  - a version tag : HTTP/1.1
-  - a status code : 200
-  - a reason      : OK
-
-The status code is always 3-digit. The first digit indicates a general status :
- - 1xx = informational message to be skipped (eg: 100, 101)
- - 2xx = OK, content is following   (eg: 200, 206)
- - 3xx = OK, no content following   (eg: 302, 304)
- - 4xx = error caused by the client (eg: 401, 403, 404)
- - 5xx = error caused by the server (eg: 500, 502, 503)
-
-Please refer to RFC2616 for the detailed meaning of all such codes. The
-"reason" field is just a hint, but is not parsed by clients. Anything can be
-found there, but it's a common practice to respect the well-established
-messages. It can be composed of one or multiple words, such as "OK", "Found",
-or "Authentication Required".
-
-Haproxy may emit the following status codes by itself :
-
-  Code  When / reason
-   200  access to stats page, and when replying to monitoring requests
-   301  when performing a redirection, depending on the configured code
-   302  when performing a redirection, depending on the configured code
-   303  when performing a redirection, depending on the configured code
-   400  for an invalid or too large request
-   401  when an authentication is required to perform the action (when
-        accessing the stats page)
-   403  when a request is forbidden by a "block" ACL or "reqdeny" filter
-   408  when the request timeout strikes before the request is complete
-   500  when haproxy encounters an unrecoverable internal error, such as a
-        memory allocation failure, which should never happen
-   502  when the server returns an empty, invalid or incomplete response, or
-        when an "rspdeny" filter blocks the response.
-   503  when no server was available to handle the request, or in response to
-        monitoring requests which match the "monitor fail" condition
-   504  when the response timeout strikes before the server responds
-
-The error 4xx and 5xx codes above may be customized (see "errorloc" in section
-4.2).
-
-
-1.3.2. The response headers
----------------------------
-
-Response headers work exactly like request headers, and as such, HAProxy uses
-the same parsing function for both. Please refer to paragraph 1.2.2 for more
-details.
-
-
-2. Configuring HAProxy
-----------------------
-
-2.1. Configuration file format
-------------------------------
-
-HAProxy's configuration process involves 3 major sources of parameters :
-
-  - the arguments from the command-line, which always take precedence
-  - the "global" section, which sets process-wide parameters
-  - the proxies sections which can take form of "defaults", "listen",
-    "frontend" and "backend".
-
-The configuration file syntax consists in lines beginning with a keyword
-referenced in this manual, optionally followed by one or several parameters
-delimited by spaces. If spaces have to be entered in strings, then they must be
-preceded by a backslash ('\') to be escaped. Backslashes also have to be
-escaped by doubling them.
-
-
-2.2. Time format
-----------------
-
-Some parameters involve values representing time, such as timeouts. These
-values are generally expressed in milliseconds (unless explicitly stated
-otherwise) but may be expressed in any other unit by suffixing the unit to the
-numeric value. It is important to consider this because it will not be repeated
-for every keyword. Supported units are :
-
-  - us : microseconds. 1 microsecond = 1/1000000 second
-  - ms : milliseconds. 1 millisecond = 1/1000 second. This is the default.
-  - s  : seconds. 1s = 1000ms
-  - m  : minutes. 1m = 60s = 60000ms
-  - h  : hours.   1h = 60m = 3600s = 3600000ms
-  - d  : days.    1d = 24h = 1440m = 86400s = 86400000ms
-
-
-2.3. Examples
--------------
-
-    # Simple configuration for an HTTP proxy listening on port 80 on all
-    # interfaces and forwarding requests to a single backend "servers" with a
-    # single server "server1" listening on 127.0.0.1:8000
-    global
-        daemon
-        maxconn 256
-
-    defaults
-        mode http
-        timeout connect 5000ms
-        timeout client 50000ms
-        timeout server 50000ms
-
-    frontend http-in
-        bind *:80
-        default_backend servers
-
-    backend servers
-        server server1 127.0.0.1:8000 maxconn 32
-
-
-    # The same configuration defined with a single listen block. Shorter but
-    # less expressive, especially in HTTP mode.
-    global
-        daemon
-        maxconn 256
-
-    defaults
-        mode http
-        timeout connect 5000ms
-        timeout client 50000ms
-        timeout server 50000ms
-
-    listen http-in
-        bind *:80
-        server server1 127.0.0.1:8000 maxconn 32
-
-
-Assuming haproxy is in $PATH, test these configurations in a shell with:
-
-    $ sudo haproxy -f configuration.conf -c
-
-
-3. Global parameters
---------------------
-
-Parameters in the "global" section are process-wide and often OS-specific. They
-are generally set once for all and do not need being changed once correct. Some
-of them have command-line equivalents.
-
-The following keywords are supported in the "global" section :
-
- * Process management and security
-   - chroot
-   - daemon
-   - gid
-   - group
-   - log
-   - log-send-hostname
-   - nbproc
-   - pidfile
-   - uid
-   - ulimit-n
-   - user
-   - stats
-   - node
-   - description
-
- * Performance tuning
-   - maxconn
-   - maxpipes
-   - noepoll
-   - nokqueue
-   - nopoll
-   - nosepoll
-   - nosplice
-   - spread-checks
-   - tune.bufsize
-   - tune.chksize
-   - tune.maxaccept
-   - tune.maxpollevents
-   - tune.maxrewrite
-   - tune.rcvbuf.client
-   - tune.rcvbuf.server
-   - tune.sndbuf.client
-   - tune.sndbuf.server
-
- * Debugging
-   - debug
-   - quiet
-
-
-3.1. Process management and security
-------------------------------------
-
-chroot <jail dir>
-  Changes current directory to <jail dir> and performs a chroot() there before
-  dropping privileges. This increases the security level in case an unknown
-  vulnerability would be exploited, since it would make it very hard for the
-  attacker to exploit the system. This only works when the process is started
-  with superuser privileges. It is important to ensure that <jail_dir> is both
-  empty and unwritable to anyone.
-
-daemon
-  Makes the process fork into background. This is the recommended mode of
-  operation. It is equivalent to the command line "-D" argument. It can be
-  disabled by the command line "-db" argument.
-
-gid <number>
-  Changes the process' group ID to <number>. It is recommended that the group
-  ID is dedicated to HAProxy or to a small set of similar daemons. HAProxy must
-  be started with a user belonging to this group, or with superuser privileges.
-  See also "group" and "uid".
-
-group <group name>
-  Similar to "gid" but uses the GID of group name <group name> from /etc/group.
-  See also "gid" and "user".
-
-log <address> <facility> [max level [min level]]
-  Adds a global syslog server. Up to two global servers can be defined. They
-  will receive logs for startups and exits, as well as all logs from proxies
-  configured with "log global".
-
-  <address> can be one of:
-
-        - An IPv4 address optionally followed by a colon and a UDP port. If
-          no port is specified, 514 is used by default (the standard syslog
-          port).
-
-        - A filesystem path to a UNIX domain socket, keeping in mind
-          considerations for chroot (be sure the path is accessible inside
-          the chroot) and uid/gid (be sure the path is appropriately
-          writeable).
-
-  <facility> must be one of the 24 standard syslog facilities :
-
-          kern   user   mail   daemon auth   syslog lpr    news
-          uucp   cron   auth2  ftp    ntp    audit  alert  cron2
-          local0 local1 local2 local3 local4 local5 local6 local7
-
-  An optional level can be specified to filter outgoing messages. By default,
-  all messages are sent. If a maximum level is specified, only messages with a
-  severity at least as important as this level will be sent. An optional minimum
-  level can be specified. If it is set, logs emitted with a more severe level
-  than this one will be capped to this level. This is used to avoid sending
-  "emerg" messages on all terminals on some default syslog configurations.
-  Eight levels are known :
-
-          emerg  alert  crit   err    warning notice info  debug
-
-log-send-hostname [<string>]
-  Sets the hostname field in the syslog header. If optional "string" parameter
-  is set the header is set to the string contents, otherwise uses the hostname
-  of the system. Generally used if one is not relaying logs through an
-  intermediate syslog server or for simply customizing the hostname printed in
-  the logs.
-
-log-tag <string>
-  Sets the tag field in the syslog header to this string. It defaults to the
-  program name as launched from the command line, which usually is "haproxy".
-  Sometimes it can be useful to differentiate between multiple processes
-  running on the same host.
-
-nbproc <number>
-  Creates <number> processes when going daemon. This requires the "daemon"
-  mode. By default, only one process is created, which is the recommended mode
-  of operation. For systems limited to small sets of file descriptors per
-  process, it may be needed to fork multiple daemons. USING MULTIPLE PROCESSES
-  IS HARDER TO DEBUG AND IS REALLY DISCOURAGED. See also "daemon".
-
-pidfile <pidfile>
-  Writes pids of all daemons into file <pidfile>. This option is equivalent to
-  the "-p" command line argument. The file must be accessible to the user
-  starting the process. See also "daemon".
-
-stats socket <path> [{uid | user} <uid>] [{gid | group} <gid>] [mode <mode>]
-             [level <level>]
-
-  Creates a UNIX socket in stream mode at location <path>. Any previously
-  existing socket will be backed up then replaced. Connections to this socket
-  will return various statistics outputs and even allow some commands to be
-  issued. Please consult section 9.2 "Unix Socket commands" for more details.
-
-  An optional "level" parameter can be specified to restrict the nature of
-  the commands that can be issued on the socket :
-    - "user" is the least privileged level ; only non-sensitive stats can be
-      read, and no change is allowed. It would make sense on systems where it
-      is not easy to restrict access to the socket.
-
-    - "operator" is the default level and fits most common uses. All data can
-      be read, and only non-sensitive changes are permitted (eg: clear max
-      counters).
-
-    - "admin" should be used with care, as everything is permitted (eg: clear
-      all counters).
-
-  On platforms which support it, it is possible to restrict access to this
-  socket by specifying numerical IDs after "uid" and "gid", or valid user and
-  group names after the "user" and "group" keywords. It is also possible to
-  restrict permissions on the socket by passing an octal value after the "mode"
-  keyword (same syntax as chmod). Depending on the platform, the permissions on
-  the socket will be inherited from the directory which hosts it, or from the
-  user the process is started with.
-
-stats timeout <timeout, in milliseconds>
-  The default timeout on the stats socket is set to 10 seconds. It is possible
-  to change this value with "stats timeout". The value must be passed in
-  milliseconds, or be suffixed by a time unit among { us, ms, s, m, h, d }.
-
-stats maxconn <connections>
-  By default, the stats socket is limited to 10 concurrent connections. It is
-  possible to change this value with "stats maxconn".
-
-uid <number>
-  Changes the process' user ID to <number>. It is recommended that the user ID
-  is dedicated to HAProxy or to a small set of similar daemons. HAProxy must
-  be started with superuser privileges in order to be able to switch to another
-  one. See also "gid" and "user".
-
-ulimit-n <number>
-  Sets the maximum number of per-process file-descriptors to <number>. By
-  default, it is automatically computed, so it is recommended not to use this
-  option.
-
-user <user name>
-  Similar to "uid" but uses the UID of user name <user name> from /etc/passwd.
-  See also "uid" and "group".
-
-node <name>
-  Only letters, digits, hyphen and underscore are allowed, like in DNS names.
-
-  This statement is useful in HA configurations where two or more processes or
-  servers share the same IP address. By setting a different node-name on all
-  nodes, it becomes easy to immediately spot what server is handling the
-  traffic.
-
-description <text>
-  Add a text that describes the instance.
-
-  Please note that it is required to escape certain characters (# for example)
-  and this text is inserted into a html page so you should avoid using
-  "<" and ">" characters.
-
-
-3.2. Performance tuning
------------------------
-
-maxconn <number>
-  Sets the maximum per-process number of concurrent connections to <number>. It
-  is equivalent to the command-line argument "-n". Proxies will stop accepting
-  connections when this limit is reached. The "ulimit-n" parameter is
-  automatically adjusted according to this value. See also "ulimit-n".
-
-maxpipes <number>
-  Sets the maximum per-process number of pipes to <number>. Currently, pipes
-  are only used by kernel-based tcp splicing. Since a pipe contains two file
-  descriptors, the "ulimit-n" value will be increased accordingly. The default
-  value is maxconn/4, which seems to be more than enough for most heavy usages.
-  The splice code dynamically allocates and releases pipes, and can fall back
-  to standard copy, so setting this value too low may only impact performance.
-
-noepoll
-  Disables the use of the "epoll" event polling system on Linux. It is
-  equivalent to the command-line argument "-de". The next polling system
-  used will generally be "poll". See also "nosepoll", and "nopoll".
-
-nokqueue
-  Disables the use of the "kqueue" event polling system on BSD. It is
-  equivalent to the command-line argument "-dk". The next polling system
-  used will generally be "poll". See also "nopoll".
-
-nopoll
-  Disables the use of the "poll" event polling system. It is equivalent to the
-  command-line argument "-dp". The next polling system used will be "select".
-  It should never be needed to disable "poll" since it's available on all
-  platforms supported by HAProxy. See also "nosepoll", and "nopoll" and
-  "nokqueue".
-
-nosepoll
-  Disables the use of the "speculative epoll" event polling system on Linux. It
-  is equivalent to the command-line argument "-ds". The next polling system
-  used will generally be "epoll". See also "nosepoll", and "nopoll".
-
-nosplice
-  Disables the use of kernel tcp splicing between sockets on Linux. It is
-  equivalent to the command line argument "-dS".  Data will then be copied
-  using conventional and more portable recv/send calls. Kernel tcp splicing is
-  limited to some very recent instances of kernel 2.6. Most versions between
-  2.6.25 and 2.6.28 are buggy and will forward corrupted data, so they must not
-  be used. This option makes it easier to globally disable kernel splicing in
-  case of doubt. See also "option splice-auto", "option splice-request" and
-  "option splice-response".
-
-spread-checks <0..50, in percent>
-  Sometimes it is desirable to avoid sending health checks to servers at exact
-  intervals, for instance when many logical servers are located on the same
-  physical server. With the help of this parameter, it becomes possible to add
-  some randomness in the check interval between 0 and +/- 50%. A value between
-  2 and 5 seems to show good results. The default value remains at 0.
-
-tune.bufsize <number>
-  Sets the buffer size to this size (in bytes). Lower values allow more
-  sessions to coexist in the same amount of RAM, and higher values allow some
-  applications with very large cookies to work. The default value is 16384 and
-  can be changed at build time. It is strongly recommended not to change this
-  from the default value, as very low values will break some services such as
-  statistics, and values larger than default size will increase memory usage,
-  possibly causing the system to run out of memory. At least the global maxconn
-  parameter should be decreased by the same factor as this one is increased.
-
-tune.chksize <number>
-  Sets the check buffer size to this size (in bytes). Higher values may help
-  find string or regex patterns in very large pages, though doing so may imply
-  more memory and CPU usage. The default value is 16384 and can be changed at
-  build time. It is not recommended to change this value, but to use better
-  checks whenever possible.
-
-tune.maxaccept <number>
-  Sets the maximum number of consecutive accepts that a process may perform on
-  a single wake up. High values give higher priority to high connection rates,
-  while lower values give higher priority to already established connections.
-  This value is limited to 100 by default in single process mode. However, in
-  multi-process mode (nbproc > 1), it defaults to 8 so that when one process
-  wakes up, it does not take all incoming connections for itself and leaves a
-  part of them to other processes. Setting this value to -1 completely disables
-  the limitation. It should normally not be needed to tweak this value.
-
-tune.maxpollevents <number>
-  Sets the maximum amount of events that can be processed at once in a call to
-  the polling system. The default value is adapted to the operating system. It
-  has been noticed that reducing it below 200 tends to slightly decrease
-  latency at the expense of network bandwidth, and increasing it above 200
-  tends to trade latency for slightly increased bandwidth.
-
-tune.maxrewrite <number>
-  Sets the reserved buffer space to this size in bytes. The reserved space is
-  used for header rewriting or appending. The first reads on sockets will never
-  fill more than bufsize-maxrewrite. Historically it has defaulted to half of
-  bufsize, though that does not make much sense since there are rarely large
-  numbers of headers to add. Setting it too high prevents processing of large
-  requests or responses. Setting it too low prevents addition of new headers
-  to already large requests or to POST requests. It is generally wise to set it
-  to about 1024. It is automatically readjusted to half of bufsize if it is
-  larger than that. This means you don't have to worry about it when changing
-  bufsize.
-
-tune.rcvbuf.client <number>
-tune.rcvbuf.server <number>
-  Forces the kernel socket receive buffer size on the client or the server side
-  to the specified value in bytes. This value applies to all TCP/HTTP frontends
-  and backends. It should normally never be set, and the default size (0) lets
-  the kernel autotune this value depending on the amount of available memory.
-  However it can sometimes help to set it to very low values (eg: 4096) in
-  order to save kernel memory by preventing it from buffering too large amounts
-  of received data. Lower values will significantly increase CPU usage though.
-
-tune.sndbuf.client <number>
-tune.sndbuf.server <number>
-  Forces the kernel socket send buffer size on the client or the server side to
-  the specified value in bytes. This value applies to all TCP/HTTP frontends
-  and backends. It should normally never be set, and the default size (0) lets
-  the kernel autotune this value depending on the amount of available memory.
-  However it can sometimes help to set it to very low values (eg: 4096) in
-  order to save kernel memory by preventing it from buffering too large amounts
-  of received data. Lower values will significantly increase CPU usage though.
-  Another use case is to prevent write timeouts with extremely slow clients due
-  to the kernel waiting for a large part of the buffer to be read before
-  notifying haproxy again.
-
-
-3.3. Debugging
---------------
-
-debug
-  Enables debug mode which dumps to stdout all exchanges, and disables forking
-  into background. It is the equivalent of the command-line argument "-d". It
-  should never be used in a production configuration since it may prevent full
-  system startup.
-
-quiet
-  Do not display any message during startup. It is equivalent to the command-
-  line argument "-q".
-
-3.4. Userlists
---------------
-It is possible to control access to frontend/backend/listen sections or to
-http stats by allowing only authenticated and authorized users. To do this,
-it is required to create at least one userlist and to define users.
-
-userlist <listname>
-  Creates new userlist with name <listname>. Many independent userlists can be
-  used to store authentication & authorization data for independent customers.
-
-group <groupname> [users <user>,<user>,(...)]
-  Adds group <groupname> to the current userlist. It is also possible to
-  attach users to this group by using a comma separated list of names
-  proceeded by "users" keyword.
-
-user <username> [password|insecure-password <password>]
-                [groups <group>,<group>,(...)]
-  Adds user <username> to the current userlist. Both secure (encrypted) and
-  insecure (unencrypted) passwords can be used. Encrypted passwords are
-  evaluated using the crypt(3) function so depending of the system's
-  capabilities, different algorithms are supported. For example modern Glibc
-  based Linux system supports MD5, SHA-256, SHA-512 and of course classic,
-  DES-based method of crypting passwords.
-
-
-  Example:
-        userlist L1
-          group G1 users tiger,scott
-          group G2 users xdb,scott
-
-          user tiger password $6$k6y3o.eP$JlKBx9za9667qe4(...)xHSwRv6J.C0/D7cV91
-          user scott insecure-password elgato
-          user xdb insecure-password hello
-
-        userlist L2
-          group G1
-          group G2
-
-          user tiger password $6$k6y3o.eP$JlKBx(...)xHSwRv6J.C0/D7cV91 groups G1
-          user scott insecure-password elgato groups G1,G2
-          user xdb insecure-password hello groups G2
-
-  Please note that both lists are functionally identical.
-
-4. Proxies
-----------
-
-Proxy configuration can be located in a set of sections :
- - defaults <name>
- - frontend <name>
- - backend  <name>
- - listen   <name>
-
-A "defaults" section sets default parameters for all other sections following
-its declaration. Those default parameters are reset by the next "defaults"
-section. See below for the list of parameters which can be set in a "defaults"
-section. The name is optional but its use is encouraged for better readability.
-
-A "frontend" section describes a set of listening sockets accepting client
-connections.
-
-A "backend" section describes a set of servers to which the proxy will connect
-to forward incoming connections.
-
-A "listen" section defines a complete proxy with its frontend and backend
-parts combined in one section. It is generally useful for TCP-only traffic.
-
-All proxy names must be formed from upper and lower case letters, digits,
-'-' (dash), '_' (underscore) , '.' (dot) and ':' (colon). ACL names are
-case-sensitive, which means that "www" and "WWW" are two different proxies.
-
-Historically, all proxy names could overlap, it just caused troubles in the
-logs. Since the introduction of content switching, it is mandatory that two
-proxies with overlapping capabilities (frontend/backend) have different names.
-However, it is still permitted that a frontend and a backend share the same
-name, as this configuration seems to be commonly encountered.
-
-Right now, two major proxy modes are supported : "tcp", also known as layer 4,
-and "http", also known as layer 7. In layer 4 mode, HAProxy simply forwards
-bidirectional traffic between two sides. In layer 7 mode, HAProxy analyzes the
-protocol, and can interact with it by allowing, blocking, switching, adding,
-modifying, or removing arbitrary contents in requests or responses, based on
-arbitrary criteria.
-
-
-4.1. Proxy keywords matrix
---------------------------
-
-The following list of keywords is supported. Most of them may only be used in a
-limited set of section types. Some of them are marked as "deprecated" because
-they are inherited from an old syntax which may be confusing or functionally
-limited, and there are new recommended keywords to replace them. Keywords
-marked with "(*)" can be optionally inverted using the "no" prefix, eg. "no
-option contstats". This makes sense when the option has been enabled by default
-and must be disabled for a specific instance. Such options may also be prefixed
-with "default" in order to restore default settings regardless of what has been
-specified in a previous "defaults" section.
-
-
- keyword                              defaults   frontend   listen    backend
-------------------------------------+----------+----------+---------+---------
-acl                                       -          X         X         X
-appsession                                -          -         X         X
-backlog                                   X          X         X         -
-balance                                   X          -         X         X
-bind                                      -          X         X         -
-bind-process                              X          X         X         X
-block                                     -          X         X         X
-capture cookie                            -          X         X         -
-capture request header                    -          X         X         -
-capture response header                   -          X         X         -
-clitimeout                  (deprecated)  X          X         X         -
-contimeout                  (deprecated)  X          -         X         X
-cookie                                    X          -         X         X
-default-server                            X          -         X         X
-default_backend                           X          X         X         -
-description                               -          X         X         X
-disabled                                  X          X         X         X
-dispatch                                  -          -         X         X
-enabled                                   X          X         X         X
-errorfile                                 X          X         X         X
-errorloc                                  X          X         X         X
-errorloc302                               X          X         X         X
--- keyword -------------------------- defaults - frontend - listen -- backend -
-errorloc303                               X          X         X         X
-force-persist                             -          X         X         X
-fullconn                                  X          -         X         X
-grace                                     X          X         X         X
-hash-type                                 X          -         X         X
-http-check disable-on-404                 X          -         X         X
-http-check expect                         -          -         X         X
-http-check send-state                     X          -         X         X
-http-request                              -          X         X         X
-id                                        -          X         X         X
-ignore-persist                            -          X         X         X
-log                                       X          X         X         X
-maxconn                                   X          X         X         -
-mode                                      X          X         X         X
-monitor fail                              -          X         X         -
-monitor-net                               X          X         X         -
-monitor-uri                               X          X         X         -
-option abortonclose                  (*)  X          -         X         X
-option accept-invalid-http-request   (*)  X          X         X         -
-option accept-invalid-http-response  (*)  X          -         X         X
-option allbackups                    (*)  X          -         X         X
-option checkcache                    (*)  X          -         X         X
-option clitcpka                      (*)  X          X         X         -
-option contstats                     (*)  X          X         X         -
-option dontlog-normal                (*)  X          X         X         -
-option dontlognull                   (*)  X          X         X         -
-option forceclose                    (*)  X          X         X         X
--- keyword -------------------------- defaults - frontend - listen -- backend -
-option forwardfor                         X          X         X         X
-option http-no-delay                 (*)  X          X         X         X
-option http-pretend-keepalive        (*)  X          X         X         X
-option http-server-close             (*)  X          X         X         X
-option http-use-proxy-header         (*)  X          X         X         -
-option httpchk                            X          -         X         X
-option httpclose                     (*)  X          X         X         X
-option httplog                            X          X         X         X
-option http_proxy                    (*)  X          X         X         X
-option independant-streams           (*)  X          X         X         X
-option ldap-check                         X          -         X         X
-option log-health-checks             (*)  X          -         X         X
-option log-separate-errors           (*)  X          X         X         -
-option logasap                       (*)  X          X         X         -
-option mysql-check                        X          -         X         X
-option nolinger                      (*)  X          X         X         X
-option originalto                         X          X         X         X
-option persist                       (*)  X          -         X         X
-option redispatch                    (*)  X          -         X         X
-option smtpchk                            X          -         X         X
-option socket-stats                  (*)  X          X         X         -
-option splice-auto                   (*)  X          X         X         X
-option splice-request                (*)  X          X         X         X
-option splice-response               (*)  X          X         X         X
-option srvtcpka                      (*)  X          -         X         X
-option ssl-hello-chk                      X          -         X         X
--- keyword -------------------------- defaults - frontend - listen -- backend -
-option tcp-smart-accept              (*)  X          X         X         -
-option tcp-smart-connect             (*)  X          -         X         X
-option tcpka                              X          X         X         X
-option tcplog                             X          X         X         X
-option transparent                   (*)  X          -         X         X
-persist rdp-cookie                        X          -         X         X
-rate-limit sessions                       X          X         X         -
-redirect                                  -          X         X         X
-redisp                      (deprecated)  X          -         X         X
-redispatch                  (deprecated)  X          -         X         X
-reqadd                                    -          X         X         X
-reqallow                                  -          X         X         X
-reqdel                                    -          X         X         X
-reqdeny                                   -          X         X         X
-reqiallow                                 -          X         X         X
-reqidel                                   -          X         X         X
-reqideny                                  -          X         X         X
-reqipass                                  -          X         X         X
-reqirep                                   -          X         X         X
-reqisetbe                                 -          X         X         X
-reqitarpit                                -          X         X         X
-reqpass                                   -          X         X         X
-reqrep                                    -          X         X         X
--- keyword -------------------------- defaults - frontend - listen -- backend -
-reqsetbe                                  -          X         X         X
-reqtarpit                                 -          X         X         X
-retries                                   X          -         X         X
-rspadd                                    -          X         X         X
-rspdel                                    -          X         X         X
-rspdeny                                   -          X         X         X
-rspidel                                   -          X         X         X
-rspideny                                  -          X         X         X
-rspirep                                   -          X         X         X
-rsprep                                    -          X         X         X
-server                                    -          -         X         X
-source                                    X          -         X         X
-srvtimeout                  (deprecated)  X          -         X         X
-stats admin                               -          -         X         X
-stats auth                                X          -         X         X
-stats enable                              X          -         X         X
-stats hide-version                        X          -         X         X
-stats http-request                        -          -         X         X
-stats realm                               X          -         X         X
-stats refresh                             X          -         X         X
-stats scope                               X          -         X         X
-stats show-desc                           X          -         X         X
-stats show-legends                        X          -         X         X
-stats show-node                           X          -         X         X
-stats uri                                 X          -         X         X
--- keyword -------------------------- defaults - frontend - listen -- backend -
-stick match                               -          -         X         X
-stick on                                  -          -         X         X
-stick store-request                       -          -         X         X
-stick-table                               -          -         X         X
-tcp-request content accept                -          X         X         -
-tcp-request content reject                -          X         X         -
-tcp-request inspect-delay                 -          X         X         -
-timeout check                             X          -         X         X
-timeout client                            X          X         X         -
-timeout clitimeout          (deprecated)  X          X         X         -
-timeout connect                           X          -         X         X
-timeout contimeout          (deprecated)  X          -         X         X
-timeout http-keep-alive                   X          X         X         X
-timeout http-request                      X          X         X         X
-timeout queue                             X          -         X         X
-timeout server                            X          -         X         X
-timeout srvtimeout          (deprecated)  X          -         X         X
-timeout tarpit                            X          X         X         X
-transparent                 (deprecated)  X          -         X         X
-use_backend                               -          X         X         -
-------------------------------------+----------+----------+---------+---------
- keyword                              defaults   frontend   listen    backend
-
-
-4.2. Alphabetically sorted keywords reference
----------------------------------------------
-
-This section provides a description of each keyword and its usage.
-
-
-acl <aclname> <criterion> [flags] [operator] <value> ...
-  Declare or complete an access list.
-  May be used in sections :   defaults | frontend | listen | backend
-                                 no    |    yes   |   yes  |   yes
-  Example:
-        acl invalid_src  src          0.0.0.0/7 224.0.0.0/3
-        acl invalid_src  src_port     0:1023
-        acl local_dst    hdr(host) -i localhost
-
-  See section 7 about ACL usage.
-
-
-appsession <cookie> len <length> timeout <holdtime>
-           [request-learn] [prefix] [mode <path-parameters|query-string>]
-  Define session stickiness on an existing application cookie.
-  May be used in sections :   defaults | frontend | listen | backend
-                                 no    |    no    |   yes  |   yes
-  Arguments :
-    <cookie>   this is the name of the cookie used by the application and which
-               HAProxy will have to learn for each new session.
-
-    <length>   this is the max number of characters that will be memorized and
-               checked in each cookie value.
-
-    <holdtime> this is the time after which the cookie will be removed from
-               memory if unused. If no unit is specified, this time is in
-               milliseconds.
-
-    request-learn
-               If this option is specified, then haproxy will be able to learn
-               the cookie found in the request in case the server does not
-               specify any in response. This is typically what happens with
-               PHPSESSID cookies, or when haproxy's session expires before
-               the application's session and the correct server is selected.
-               It is recommended to specify this option to improve reliability.
-
-    prefix     When this option is specified, haproxy will match on the cookie
-               prefix (or URL parameter prefix). The appsession value is the
-               data following this prefix.
-
-               Example :
-               appsession ASPSESSIONID len 64 timeout 3h prefix
-
-               This will match the cookie ASPSESSIONIDXXXX=XXXXX,
-               the appsession value will be XXXX=XXXXX.
-
-    mode       This option allows to change the URL parser mode.
-               2 modes are currently supported :
-               - path-parameters :
-                 The parser looks for the appsession in the path parameters
-                 part (each parameter is separated by a semi-colon), which is
-                 convenient for JSESSIONID for example.
-                 This is the default mode if the option is not set.
-               - query-string :
-                 In this mode, the parser will look for the appsession in the
-                 query string.
-
-  When an application cookie is defined in a backend, HAProxy will check when
-  the server sets such a cookie, and will store its value in a table, and
-  associate it with the server's identifier. Up to <length> characters from
-  the value will be retained. On each connection, haproxy will look for this
-  cookie both in the "Cookie:" headers, and as a URL parameter (depending on
-  the mode used). If a known value is found, the client will be directed to the
-  server associated with this value. Otherwise, the load balancing algorithm is
-  applied. Cookies are automatically removed from memory when they have been
-  unused for a duration longer than <holdtime>.
-
-  The definition of an application cookie is limited to one per backend.
-
-  Note : Consider not using this feature in multi-process mode (nbproc > 1)
-         unless you know what you do : memory is not shared between the
-         processes, which can result in random behaviours.
-
-  Example :
-        appsession JSESSIONID len 52 timeout 3h
-
-  See also : "cookie", "capture cookie", "balance", "stick", "stick-table",
-             "ignore-persist", "nbproc" and "bind-process".
-
-
-backlog <conns>
-  Give hints to the system about the approximate listen backlog desired size
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   no
-  Arguments :
-    <conns>   is the number of pending connections. Depending on the operating
-              system, it may represent the number of already acknowledged
-              connections, of non-acknowledged ones, or both.
-
-  In order to protect against SYN flood attacks, one solution is to increase
-  the system's SYN backlog size. Depending on the system, sometimes it is just
-  tunable via a system parameter, sometimes it is not adjustable at all, and
-  sometimes the system relies on hints given by the application at the time of
-  the listen() syscall. By default, HAProxy passes the frontend's maxconn value
-  to the listen() syscall. On systems which can make use of this value, it can
-  sometimes be useful to be able to specify a different value, hence this
-  backlog parameter.
-
-  On Linux 2.4, the parameter is ignored by the system. On Linux 2.6, it is
-  used as a hint and the system accepts up to the smallest greater power of
-  two, and never more than some limits (usually 32768).
-
-  See also : "maxconn" and the target operating system's tuning guide.
-
-
-balance <algorithm> [ <arguments> ]
-balance url_param <param> [check_post [<max_wait>]]
-  Define the load balancing algorithm to be used in a backend.
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments :
-    <algorithm> is the algorithm used to select a server when doing load
-                balancing. This only applies when no persistence information
-                is available, or when a connection is redispatched to another
-                server. <algorithm> may be one of the following :
-
-      roundrobin  Each server is used in turns, according to their weights.
-                  This is the smoothest and fairest algorithm when the server's
-                  processing time remains equally distributed. This algorithm
-                  is dynamic, which means that server weights may be adjusted
-                  on the fly for slow starts for instance. It is limited by
-                  design to 4128 active servers per backend. Note that in some
-                  large farms, when a server becomes up after having been down
-                  for a very short time, it may sometimes take a few hundreds
-                  requests for it to be re-integrated into the farm and start
-                  receiving traffic. This is normal, though very rare. It is
-                  indicated here in case you would have the chance to observe
-                  it, so that you don't worry.
-
-      static-rr   Each server is used in turns, according to their weights.
-                  This algorithm is as similar to roundrobin except that it is
-                  static, which means that changing a server's weight on the
-                  fly will have no effect. On the other hand, it has no design
-                  limitation on the number of servers, and when a server goes
-                  up, it is always immediately reintroduced into the farm, once
-                  the full map is recomputed. It also uses slightly less CPU to
-                  run (around -1%).
-
-      leastconn   The server with the lowest number of connections receives the
-                  connection. Round-robin is performed within groups of servers
-                  of the same load to ensure that all servers will be used. Use
-                  of this algorithm is recommended where very long sessions are
-                  expected, such as LDAP, SQL, TSE, etc... but is not very well
-                  suited for protocols using short sessions such as HTTP. This
-                  algorithm is dynamic, which means that server weights may be
-                  adjusted on the fly for slow starts for instance.
-
-      source      The source IP address is hashed and divided by the total
-                  weight of the running servers to designate which server will
-                  receive the request. This ensures that the same client IP
-                  address will always reach the same server as long as no
-                  server goes down or up. If the hash result changes due to the
-                  number of running servers changing, many clients will be
-                  directed to a different server. This algorithm is generally
-                  used in TCP mode where no cookie may be inserted. It may also
-                  be used on the Internet to provide a best-effort stickiness
-                  to clients which refuse session cookies. This algorithm is
-                  static by default, which means that changing a server's
-                  weight on the fly will have no effect, but this can be
-                  changed using "hash-type".
-
-      uri         The left part of the URI (before the question mark) is hashed
-                  and divided by the total weight of the running servers. The
-                  result designates which server will receive the request. This
-                  ensures that a same URI will always be directed to the same
-                  server as long as no server goes up or down. This is used
-                  with proxy caches and anti-virus proxies in order to maximize
-                  the cache hit rate. Note that this algorithm may only be used
-                  in an HTTP backend. This algorithm is static by default,
-                  which means that changing a server's weight on the fly will
-                  have no effect, but this can be changed using "hash-type".
-
-                  This algorithm support two optional parameters "len" and
-                  "depth", both followed by a positive integer number. These
-                  options may be helpful when it is needed to balance servers
-                  based on the beginning of the URI only. The "len" parameter
-                  indicates that the algorithm should only consider that many
-                  characters at the beginning of the URI to compute the hash.
-                  Note that having "len" set to 1 rarely makes sense since most
-                  URIs start with a leading "/".
-
-                  The "depth" parameter indicates the maximum directory depth
-                  to be used to compute the hash. One level is counted for each
-                  slash in the request. If both parameters are specified, the
-                  evaluation stops when either is reached.
-
-      url_param   The URL parameter specified in argument will be looked up in
-                  the query string of each HTTP GET request.
-
-                  If the modifier "check_post" is used, then an HTTP POST
-                  request entity will be searched for the parameter argument,
-                  when it is not found in a query string after a question mark
-                  ('?') in the URL. Optionally, specify a number of octets to
-                  wait for before attempting to search the message body. If the
-                  entity can not be searched, then round robin is used for each
-                  request. For instance, if your clients always send the LB
-                  parameter in the first 128 bytes, then specify that. The
-                  default is 48. The entity data will not be scanned until the
-                  required number of octets have arrived at the gateway, this
-                  is the minimum of: (default/max_wait, Content-Length or first
-                  chunk length). If Content-Length is missing or zero, it does
-                  not need to wait for more data than the client promised to
-                  send. When Content-Length is present and larger than
-                  <max_wait>, then waiting is limited to <max_wait> and it is
-                  assumed that this will be enough data to search for the
-                  presence of the parameter. In the unlikely event that
-                  Transfer-Encoding: chunked is used, only the first chunk is
-                  scanned. Parameter values separated by a chunk boundary, may
-                  be randomly balanced if at all.
-
-                  If the parameter is found followed by an equal sign ('=') and
-                  a value, then the value is hashed and divided by the total
-                  weight of the running servers. The result designates which
-                  server will receive the request.
-
-                  This is used to track user identifiers in requests and ensure
-                  that a same user ID will always be sent to the same server as
-                  long as no server goes up or down. If no value is found or if
-                  the parameter is not found, then a round robin algorithm is
-                  applied. Note that this algorithm may only be used in an HTTP
-                  backend. This algorithm is static by default, which means
-                  that changing a server's weight on the fly will have no
-                  effect, but this can be changed using "hash-type".
-
-      hdr(<name>) The HTTP header <name> will be looked up in each HTTP request.
-                  Just as with the equivalent ACL 'hdr()' function, the header
-                  name in parenthesis is not case sensitive. If the header is
-                  absent or if it does not contain any value, the roundrobin
-                  algorithm is applied instead.
-
-                  An optional 'use_domain_only' parameter is available, for
-                  reducing the hash algorithm to the main domain part with some
-                  specific headers such as 'Host'. For instance, in the Host
-                  value "haproxy.1wt.eu", only "1wt" will be considered.
-
-                  This algorithm is static by default, which means that
-                  changing a server's weight on the fly will have no effect,
-                  but this can be changed using "hash-type".
-
-      rdp-cookie
-      rdp-cookie(name)
-                  The RDP cookie <name> (or "mstshash" if omitted) will be
-                  looked up and hashed for each incoming TCP request. Just as
-                  with the equivalent ACL 'req_rdp_cookie()' function, the name
-                  is not case-sensitive. This mechanism is useful as a degraded
-                  persistence mode, as it makes it possible to always send the
-                  same user (or the same session ID) to the same server. If the
-                  cookie is not found, the normal roundrobin algorithm is
-                  used instead.
-
-                  Note that for this to work, the frontend must ensure that an
-                  RDP cookie is already present in the request buffer. For this
-                  you must use 'tcp-request content accept' rule combined with
-                  a 'req_rdp_cookie_cnt' ACL.
-
-                  This algorithm is static by default, which means that
-                  changing a server's weight on the fly will have no effect,
-                  but this can be changed using "hash-type".
-
-    <arguments> is an optional list of arguments which may be needed by some
-                algorithms. Right now, only "url_param" and "uri" support an
-                optional argument.
-
-                balance uri [len <len>] [depth <depth>]
-                balance url_param <param> [check_post [<max_wait>]]
-
-  The load balancing algorithm of a backend is set to roundrobin when no other
-  algorithm, mode nor option have been set. The algorithm may only be set once
-  for each backend.
-
-  Examples :
-        balance roundrobin
-        balance url_param userid
-        balance url_param session_id check_post 64
-        balance hdr(User-Agent)
-        balance hdr(host)
-        balance hdr(Host) use_domain_only
-
-  Note: the following caveats and limitations on using the "check_post"
-  extension with "url_param" must be considered :
-
-    - all POST requests are eligible for consideration, because there is no way
-      to determine if the parameters will be found in the body or entity which
-      may contain binary data. Therefore another method may be required to
-      restrict consideration of POST requests that have no URL parameters in
-      the body. (see acl reqideny http_end)
-
-    - using a <max_wait> value larger than the request buffer size does not
-      make sense and is useless. The buffer size is set at build time, and
-      defaults to 16 kB.
-
-    - Content-Encoding is not supported, the parameter search will probably
-      fail; and load balancing will fall back to Round Robin.
-
-    - Expect: 100-continue is not supported, load balancing will fall back to
-      Round Robin.
-
-    - Transfer-Encoding (RFC2616 3.6.1) is only supported in the first chunk.
-      If the entire parameter value is not present in the first chunk, the
-      selection of server is undefined (actually, defined by how little
-      actually appeared in the first chunk).
-
-    - This feature does not support generation of a 100, 411 or 501 response.
-
-    - In some cases, requesting "check_post" MAY attempt to scan the entire
-      contents of a message body. Scanning normally terminates when linear
-      white space or control characters are found, indicating the end of what
-      might be a URL parameter list. This is probably not a concern with SGML
-      type message bodies.
-
-  See also : "dispatch", "cookie", "appsession", "transparent", "hash-type" and
-             "http_proxy".
-
-
-bind [<address>]:<port_range> [, ...]
-bind [<address>]:<port_range> [, ...] interface <interface>
-bind [<address>]:<port_range> [, ...] mss <maxseg>
-bind [<address>]:<port_range> [, ...] transparent
-bind [<address>]:<port_range> [, ...] id <id>
-bind [<address>]:<port_range> [, ...] name <name>
-bind [<address>]:<port_range> [, ...] defer-accept
-bind [<address>]:<port_range> [, ...] accept-proxy
-  Define one or several listening addresses and/or ports in a frontend.
-  May be used in sections :   defaults | frontend | listen | backend
-                                  no   |    yes   |   yes  |   no
-  Arguments :
-    <address>     is optional and can be a host name, an IPv4 address, an IPv6
-                  address, or '*'. It designates the address the frontend will
-                  listen on. If unset, all IPv4 addresses of the system will be
-                  listened on. The same will apply for '*' or the system's
-                  special address "0.0.0.0".
-
-    <port_range>  is either a unique TCP port, or a port range for which the
-                  proxy will accept connections for the IP address specified
-                  above. The port is mandatory. Note that in the case of an
-                  IPv6 address, the port is always the number after the last
-                  colon (':'). A range can either be :
-                   - a numerical port (ex: '80')
-                   - a dash-delimited ports range explicitly stating the lower
-                     and upper bounds (ex: '2000-2100') which are included in
-                     the range.
-
-                  Particular care must be taken against port ranges, because
-                  every <address:port> couple consumes one socket (= a file
-                  descriptor), so it's easy to consume lots of descriptors
-                  with a simple range, and to run out of sockets. Also, each
-                  <address:port> couple must be used only once among all
-                  instances running on a same system. Please note that binding
-                  to ports lower than 1024 generally require particular
-                  privileges to start the program, which are independant of
-                  the 'uid' parameter.
-
-    <interface>   is an optional physical interface name. This is currently
-                  only supported on Linux. The interface must be a physical
-                  interface, not an aliased interface. When specified, all
-                  addresses on the same line will only be accepted if the
-                  incoming packet physically come through the designated
-                  interface. It is also possible to bind multiple frontends to
-                  the same address if they are bound to different interfaces.
-                  Note that binding to a physical interface requires root
-                  privileges.
-
-    <maxseg>      is an optional TCP Maximum Segment Size (MSS) value to be
-                  advertised on incoming connections. This can be used to force
-                  a lower MSS for certain specific ports, for instance for
-                  connections passing through a VPN. Note that this relies on a
-                  kernel feature which is theorically supported under Linux but
-                  was buggy in all versions prior to 2.6.28. It may or may not
-                  work on other operating systems. The commonly advertised
-                  value on Ethernet networks is 1460 = 1500(MTU) - 40(IP+TCP).
-
-    <id>          is a persistent value for socket ID. Must be positive and
-                  unique in the proxy. An unused value will automatically be
-                  assigned if unset. Can only be used when defining only a
-                  single socket.
-
-    <name>        is an optional name provided for stats
-
-    transparent   is an optional keyword which is supported only on certain
-                  Linux kernels. It indicates that the addresses will be bound
-                  even if they do not belong to the local machine. Any packet
-                  targeting any of these addresses will be caught just as if
-                  the address was locally configured. This normally requires
-                  that IP forwarding is enabled. Caution! do not use this with
-                  the default address '*', as it would redirect any traffic for
-                  the specified port. This keyword is available only when
-                  HAProxy is built with USE_LINUX_TPROXY=1.
-
-    defer-accept  is an optional keyword which is supported only on certain
-                  Linux kernels. It states that a connection will only be
-                  accepted once some data arrive on it, or at worst after the
-                  first retransmit. This should be used only on protocols for
-                  which the client talks first (eg: HTTP). It can slightly
-                  improve performance by ensuring that most of the request is
-                  already available when the connection is accepted. On the
-                  other hand, it will not be able to detect connections which
-                  don't talk. It is important to note that this option is
-                  broken in all kernels up to 2.6.31, as the connection is
-                  never accepted until the client talks. This can cause issues
-                  with front firewalls which would see an established
-                  connection while the proxy will only see it in SYN_RECV.
-
-    accept-proxy  is an optional keyword which enforces use of the PROXY
-                  protocol over any connection accepted by this listener. The
-                  PROXY protocol dictates the layer 3/4 addresses of the
-                  incoming connection to be used everywhere an address is used,
-                  with the only exception of "tcp-request connection" rules
-                  which will only see the real connection address. Logs will
-                  reflect the addresses indicated in the protocol, unless it is
-                  violated, in which case the real address will still be used.
-                  This keyword combined with support from external components
-                  can be used as an efficient and reliable alternative to the
-                  X-Forwarded-For mechanism which is not always reliable and
-                  not even always usable.
-
-  It is possible to specify a list of address:port combinations delimited by
-  commas. The frontend will then listen on all of these addresses. There is no
-  fixed limit to the number of addresses and ports which can be listened on in
-  a frontend, as well as there is no limit to the number of "bind" statements
-  in a frontend.
-
-  Example :
-        listen http_proxy
-            bind :80,:443
-            bind 10.0.0.1:10080,10.0.0.1:10443
-            bind 127.0.0.1:8443 accept-proxy
-
-  See also : "source", "option forwardfor" and the PROXY protocol
-             documentation.
-
-
-bind-process [ all | odd | even | <number 1-32> ] ...
-  Limit visibility of an instance to a certain set of processes numbers.
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   yes
-  Arguments :
-    all           All process will see this instance. This is the default. It
-                  may be used to override a default value.
-
-    odd           This instance will be enabled on processes 1,3,5,...31. This
-                  option may be combined with other numbers.
-
-    even          This instance will be enabled on processes 2,4,6,...32. This
-                  option may be combined with other numbers. Do not use it
-                  with less than 2 processes otherwise some instances might be
-                  missing from all processes.
-
-    number        The instance will be enabled on this process number, between
-                  1 and 32. You must be careful not to reference a process
-                  number greater than the configured global.nbproc, otherwise
-                  some instances might be missing from all processes.
-
-  This keyword limits binding of certain instances to certain processes. This
-  is useful in order not to have too many processes listening to the same
-  ports. For instance, on a dual-core machine, it might make sense to set
-  'nbproc 2' in the global section, then distributes the listeners among 'odd'
-  and 'even' instances.
-
-  At the moment, it is not possible to reference more than 32 processes using
-  this keyword, but this should be more than enough for most setups. Please
-  note that 'all' really means all processes and is not limited to the first
-  32.
-
-  If some backends are referenced by frontends bound to other processes, the
-  backend automatically inherits the frontend's processes.
-
-  Example :
-        listen app_ip1
-            bind 10.0.0.1:80
-            bind-process odd
-
-        listen app_ip2
-            bind 10.0.0.2:80
-            bind-process even
-
-        listen management
-            bind 10.0.0.3:80
-            bind-process 1 2 3 4
-
-  See also : "nbproc" in global section.
-
-
-block { if | unless } <condition>
-  Block a layer 7 request if/unless a condition is matched
-  May be used in sections :   defaults | frontend | listen | backend
-                                 no    |    yes   |   yes  |   yes
-
-  The HTTP request will be blocked very early in the layer 7 processing
-  if/unless <condition> is matched. A 403 error will be returned if the request
-  is blocked. The condition has to reference ACLs (see section 7). This is
-  typically used to deny access to certain sensitive resources if some
-  conditions are met or not met. There is no fixed limit to the number of
-  "block" statements per instance.
-
-  Example:
-        acl invalid_src  src          0.0.0.0/7 224.0.0.0/3
-        acl invalid_src  src_port     0:1023
-        acl local_dst    hdr(host) -i localhost
-        block if invalid_src || local_dst
-
-  See section 7 about ACL usage.
-
-
-capture cookie <name> len <length>
-  Capture and log a cookie in the request and in the response.
-  May be used in sections :   defaults | frontend | listen | backend
-                                  no   |    yes   |   yes  |   no
-  Arguments :
-    <name>    is the beginning of the name of the cookie to capture. In order
-              to match the exact name, simply suffix the name with an equal
-              sign ('='). The full name will appear in the logs, which is
-              useful with application servers which adjust both the cookie name
-              and value (eg: ASPSESSIONXXXXX).
-
-    <length>  is the maximum number of characters to report in the logs, which
-              include the cookie name, the equal sign and the value, all in the
-              standard "name=value" form. The string will be truncated on the
-              right if it exceeds <length>.
-
-  Only the first cookie is captured. Both the "cookie" request headers and the
-  "set-cookie" response headers are monitored. This is particularly useful to
-  check for application bugs causing session crossing or stealing between
-  users, because generally the user's cookies can only change on a login page.
-
-  When the cookie was not presented by the client, the associated log column
-  will report "-". When a request does not cause a cookie to be assigned by the
-  server, a "-" is reported in the response column.
-
-  The capture is performed in the frontend only because it is necessary that
-  the log format does not change for a given frontend depending on the
-  backends. This may change in the future. Note that there can be only one
-  "capture cookie" statement in a frontend. The maximum capture length is
-  configured in the sources by default to 64 characters. It is not possible to
-  specify a capture in a "defaults" section.
-
-  Example:
-        capture cookie ASPSESSION len 32
-
-  See also : "capture request header", "capture response header" as well as
-            section 8 about logging.
-
-
-capture request header <name> len <length>
-  Capture and log the first occurrence of the specified request header.
-  May be used in sections :   defaults | frontend | listen | backend
-                                  no   |    yes   |   yes  |   no
-  Arguments :
-    <name>    is the name of the header to capture. The header names are not
-              case-sensitive, but it is a common practice to write them as they
-              appear in the requests, with the first letter of each word in
-              upper case. The header name will not appear in the logs, only the
-              value is reported, but the position in the logs is respected.
-
-    <length>  is the maximum number of characters to extract from the value and
-              report in the logs. The string will be truncated on the right if
-              it exceeds <length>.
-
-  Only the first value of the last occurrence of the header is captured. The
-  value will be added to the logs between braces ('{}'). If multiple headers
-  are captured, they will be delimited by a vertical bar ('|') and will appear
-  in the same order they were declared in the configuration. Non-existent
-  headers will be logged just as an empty string. Common uses for request
-  header captures include the "Host" field in virtual hosting environments, the
-  "Content-length" when uploads are supported, "User-agent" to quickly
-  differentiate between real users and robots, and "X-Forwarded-For" in proxied
-  environments to find where the request came from.
-
-  Note that when capturing headers such as "User-agent", some spaces may be
-  logged, making the log analysis more difficult. Thus be careful about what
-  you log if you know your log parser is not smart enough to rely on the
-  braces.
-
-  There is no limit to the number of captured request headers, but each capture
-  is limited to 64 characters. In order to keep log format consistent for a
-  same frontend, header captures can only be declared in a frontend. It is not
-  possible to specify a capture in a "defaults" section.
-
-  Example:
-        capture request header Host len 15
-        capture request header X-Forwarded-For len 15
-        capture request header Referrer len 15
-
-  See also : "capture cookie", "capture response header" as well as section 8
-             about logging.
-
-
-capture response header <name> len <length>
-  Capture and log the first occurrence of the specified response header.
-  May be used in sections :   defaults | frontend | listen | backend
-                                  no   |    yes   |   yes  |   no
-  Arguments :
-    <name>    is the name of the header to capture. The header names are not
-              case-sensitive, but it is a common practice to write them as they
-              appear in the response, with the first letter of each word in
-              upper case. The header name will not appear in the logs, only the
-              value is reported, but the position in the logs is respected.
-
-    <length>  is the maximum number of characters to extract from the value and
-              report in the logs. The string will be truncated on the right if
-              it exceeds <length>.
-
-  Only the first value of the last occurrence of the header is captured. The
-  result will be added to the logs between braces ('{}') after the captured
-  request headers. If multiple headers are captured, they will be delimited by
-  a vertical bar ('|') and will appear in the same order they were declared in
-  the configuration. Non-existent headers will be logged just as an empty
-  string. Common uses for response header captures include the "Content-length"
-  header which indicates how many bytes are expected to be returned, the
-  "Location" header to track redirections.
-
-  There is no limit to the number of captured response headers, but each
-  capture is limited to 64 characters. In order to keep log format consistent
-  for a same frontend, header captures can only be declared in a frontend. It
-  is not possible to specify a capture in a "defaults" section.
-
-  Example:
-        capture response header Content-length len 9
-        capture response header Location len 15
-
-  See also : "capture cookie", "capture request header" as well as section 8
-             about logging.
-
-
-clitimeout <timeout> (deprecated)
-  Set the maximum inactivity time on the client side.
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   no
-  Arguments :
-    <timeout> is the timeout value is specified in milliseconds by default, but
-              can be in any other unit if the number is suffixed by the unit,
-              as explained at the top of this document.
-
-  The inactivity timeout applies when the client is expected to acknowledge or
-  send data. In HTTP mode, this timeout is particularly important to consider
-  during the first phase, when the client sends the request, and during the
-  response while it is reading data sent by the server. The value is specified
-  in milliseconds by default, but can be in any other unit if the number is
-  suffixed by the unit, as specified at the top of this document. In TCP mode
-  (and to a lesser extent, in HTTP mode), it is highly recommended that the
-  client timeout remains equal to the server timeout in order to avoid complex
-  situations to debug. It is a good practice to cover one or several TCP packet
-  losses by specifying timeouts that are slightly above multiples of 3 seconds
-  (eg: 4 or 5 seconds).
-
-  This parameter is specific to frontends, but can be specified once for all in
-  "defaults" sections. This is in fact one of the easiest solutions not to
-  forget about it. An unspecified timeout results in an infinite timeout, which
-  is not recommended. Such a usage is accepted and works but reports a warning
-  during startup because it may results in accumulation of expired sessions in
-  the system if the system's timeouts are not configured either.
-
-  This parameter is provided for compatibility but is currently deprecated.
-  Please use "timeout client" instead.
-
-  See also : "timeout client", "timeout http-request", "timeout server", and
-             "srvtimeout".
-
-
-contimeout <timeout> (deprecated)
-  Set the maximum time to wait for a connection attempt to a server to succeed.
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments :
-    <timeout> is the timeout value is specified in milliseconds by default, but
-              can be in any other unit if the number is suffixed by the unit,
-              as explained at the top of this document.
-
-  If the server is located on the same LAN as haproxy, the connection should be
-  immediate (less than a few milliseconds). Anyway, it is a good practice to
-  cover one or several TCP packet losses by specifying timeouts that are
-  slightly above multiples of 3 seconds (eg: 4 or 5 seconds). By default, the
-  connect timeout also presets the queue timeout to the same value if this one
-  has not been specified. Historically, the contimeout was also used to set the
-  tarpit timeout in a listen section, which is not possible in a pure frontend.
-
-  This parameter is specific to backends, but can be specified once for all in
-  "defaults" sections. This is in fact one of the easiest solutions not to
-  forget about it. An unspecified timeout results in an infinite timeout, which
-  is not recommended. Such a usage is accepted and works but reports a warning
-  during startup because it may results in accumulation of failed sessions in
-  the system if the system's timeouts are not configured either.
-
-  This parameter is provided for backwards compatibility but is currently
-  deprecated. Please use "timeout connect", "timeout queue" or "timeout tarpit"
-  instead.
-
-  See also : "timeout connect", "timeout queue", "timeout tarpit",
-             "timeout server", "contimeout".
-
-
-cookie <name> [ rewrite | insert | prefix ] [ indirect ] [ nocache ]
-              [ postonly ] [ preserve ] [ domain <domain> ]*
-              [ maxidle <idle> ] [ maxlife <life> ]
-  Enable cookie-based persistence in a backend.
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments :
-    <name>    is the name of the cookie which will be monitored, modified or
-              inserted in order to bring persistence. This cookie is sent to
-              the client via a "Set-Cookie" header in the response, and is
-              brought back by the client in a "Cookie" header in all requests.
-              Special care should be taken to choose a name which does not
-              conflict with any likely application cookie. Also, if the same
-              backends are subject to be used by the same clients (eg:
-              HTTP/HTTPS), care should be taken to use different cookie names
-              between all backends if persistence between them is not desired.
-
-    rewrite   This keyword indicates that the cookie will be provided by the
-              server and that haproxy will have to modify its value to set the
-              server's identifier in it. This mode is handy when the management
-              of complex combinations of "Set-cookie" and "Cache-control"
-              headers is left to the application. The application can then
-              decide whether or not it is appropriate to emit a persistence
-              cookie. Since all responses should be monitored, this mode only
-              works in HTTP close mode. Unless the application behaviour is
-              very complex and/or broken, it is advised not to start with this
-              mode for new deployments. This keyword is incompatible with
-              "insert" and "prefix".
-
-    insert    This keyword indicates that the persistence cookie will have to
-              be inserted by haproxy in server responses if the client did not
-
-              already have a cookie that would have permitted it to access this
-              server. When used without the "preserve" option, if the server
-              emits a cookie with the same name, it will be remove before
-              processing.  For this reason, this mode can be used to upgrade
-              existing configurations running in the "rewrite" mode. The cookie
-              will only be a session cookie and will not be stored on the
-              client's disk. By default, unless the "indirect" option is added,
-              the server will see the cookies emitted by the client. Due to
-              caching effects, it is generally wise to add the "nocache" or
-              "postonly" keywords (see below). The "insert" keyword is not
-              compatible with "rewrite" and "prefix".
-
-    prefix    This keyword indicates that instead of relying on a dedicated
-              cookie for the persistence, an existing one will be completed.
-              This may be needed in some specific environments where the client
-              does not support more than one single cookie and the application
-              already needs it. In this case, whenever the server sets a cookie
-              named <name>, it will be prefixed with the server's identifier
-              and a delimiter. The prefix will be removed from all client
-              requests so that the server still finds the cookie it emitted.
-              Since all requests and responses are subject to being modified,
-              this mode requires the HTTP close mode. The "prefix" keyword is
-              not compatible with "rewrite" and "insert".
-
-    indirect  When this option is specified, no cookie will be emitted to a
-              client which already has a valid one for the server which has
-              processed the request. If the server sets such a cookie itself,
-              it will be removed, unless the "preserve" option is also set. In
-              "insert" mode, this will additionally remove cookies from the
-              requests transmitted to the server, making the persistence
-              mechanism totally transparent from an application point of view.
-
-    nocache   This option is recommended in conjunction with the insert mode
-              when there is a cache between the client and HAProxy, as it
-              ensures that a cacheable response will be tagged non-cacheable if
-              a cookie needs to be inserted. This is important because if all
-              persistence cookies are added on a cacheable home page for
-              instance, then all customers will then fetch the page from an
-              outer cache and will all share the same persistence cookie,
-              leading to one server receiving much more traffic than others.
-              See also the "insert" and "postonly" options.
-
-    postonly  This option ensures that cookie insertion will only be performed
-              on responses to POST requests. It is an alternative to the
-              "nocache" option, because POST responses are not cacheable, so
-              this ensures that the persistence cookie will never get cached.
-              Since most sites do not need any sort of persistence before the
-              first POST which generally is a login request, this is a very
-              efficient method to optimize caching without risking to find a
-              persistence cookie in the cache.
-              See also the "insert" and "nocache" options.
-
-    preserve  This option may only be used with "insert" and/or "indirect". It
-              allows the server to emit the persistence cookie itself. In this
-              case, if a cookie is found in the response, haproxy will leave it
-              untouched. This is useful in order to end persistence after a
-              logout request for instance. For this, the server just has to
-              emit a cookie with an invalid value (eg: empty) or with a date in
-              the past. By combining this mechanism with the "disable-on-404"
-              check option, it is possible to perform a completely graceful
-              shutdown because users will definitely leave the server after
-              they logout.
-
-    domain    This option allows to specify the domain at which a cookie is
-              inserted. It requires exactly one parameter: a valid domain
-              name. If the domain begins with a dot, the browser is allowed to
-              use it for any host ending with that name. It is also possible to
-              specify several domain names by invoking this option multiple
-              times. Some browsers might have small limits on the number of
-              domains, so be careful when doing that. For the record, sending
-              10 domains to MSIE 6 or Firefox 2 works as expected.
-
-    maxidle   This option allows inserted cookies to be ignored after some idle
-              time. It only works with insert-mode cookies. When a cookie is
-              sent to the client, the date this cookie was emitted is sent too.
-              Upon further presentations of this cookie, if the date is older
-              than the delay indicated by the parameter (in seconds), it will
-              be ignored. Otherwise, it will be refreshed if needed when the
-              response is sent to the client. This is particularly useful to
-              prevent users who never close their browsers from remaining for
-              too long on the same server (eg: after a farm size change). When
-              this option is set and a cookie has no date, it is always
-              accepted, but gets refreshed in the response. This maintains the
-              ability for admins to access their sites. Cookies that have a
-              date in the future further than 24 hours are ignored. Doing so
-              lets admins fix timezone issues without risking kicking users off
-              the site.
-
-    maxlife   This option allows inserted cookies to be ignored after some life
-              time, whether they're in use or not. It only works with insert
-              mode cookies. When a cookie is first sent to the client, the date
-              this cookie was emitted is sent too. Upon further presentations
-              of this cookie, if the date is older than the delay indicated by
-              the parameter (in seconds), it will be ignored. If the cookie in
-              the request has no date, it is accepted and a date will be set.
-              Cookies that have a date in the future further than 24 hours are
-              ignored. Doing so lets admins fix timezone issues without risking
-              kicking users off the site. Contrary to maxidle, this value is
-              not refreshed, only the first visit date counts. Both maxidle and
-              maxlife may be used at the time. This is particularly useful to
-              prevent users who never close their browsers from remaining for
-              too long on the same server (eg: after a farm size change). This
-              is stronger than the maxidle method in that it forces a
-              redispatch after some absolute delay.
-
-  There can be only one persistence cookie per HTTP backend, and it can be
-  declared in a defaults section. The value of the cookie will be the value
-  indicated after the "cookie" keyword in a "server" statement. If no cookie
-  is declared for a given server, the cookie is not set.
-
-  Examples :
-        cookie JSESSIONID prefix
-        cookie SRV insert indirect nocache
-        cookie SRV insert postonly indirect
-        cookie SRV insert indirect nocache maxidle 30m maxlife 8h
-
-  See also : "appsession", "balance source", "capture cookie", "server"
-             and "ignore-persist".
-
-
-default-server [param*]
-  Change default options for a server in a backend
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments:
-    <param*>  is a list of parameters for this server. The "default-server"
-              keyword accepts an important number of options and has a complete
-              section dedicated to it. Please refer to section 5 for more
-              details.
-
-  Example :
-        default-server inter 1000 weight 13
-
-  See also: "server" and section 5 about server options
-
-
-default_backend <backend>
-  Specify the backend to use when no "use_backend" rule has been matched.
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   no
-  Arguments :
-    <backend> is the name of the backend to use.
-
-  When doing content-switching between frontend and backends using the
-  "use_backend" keyword, it is often useful to indicate which backend will be
-  used when no rule has matched. It generally is the dynamic backend which
-  will catch all undetermined requests.
-
-  Example :
-
-        use_backend     dynamic  if  url_dyn
-        use_backend     static   if  url_css url_img extension_img
-        default_backend dynamic
-
-  See also : "use_backend", "reqsetbe", "reqisetbe"
-
-
-disabled
-  Disable a proxy, frontend or backend.
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   yes
-  Arguments :
-
-  The "disabled" keyword is used to disable an instance, mainly in order to
-  liberate a listening port or to temporarily disable a service. The instance
-  will still be created and its configuration will be checked, but it will be
-  created in the "stopped" state and will appear as such in the statistics. It
-  will not receive any traffic nor will it send any health-checks or logs. It
-  is possible to disable many instances at once by adding the "disabled"
-  keyword in a "defaults" section.
-
-  See also : "enabled"
-
-
-dispatch <address>:<port>
-  Set a default server address
-  May be used in sections :   defaults | frontend | listen | backend
-                                 no    |    no    |   yes  |   yes
-  Arguments : none
-
-    <address> is the IPv4 address of the default server. Alternatively, a
-              resolvable hostname is supported, but this name will be resolved
-              during start-up.
-
-    <ports>   is a mandatory port specification. All connections will be sent
-              to this port, and it is not permitted to use port offsets as is
-              possible with normal servers.
-
-  The "dispatch" keyword designates a default server for use when no other
-  server can take the connection. In the past it was used to forward non
-  persistent connections to an auxiliary load balancer. Due to its simple
-  syntax, it has also been used for simple TCP relays. It is recommended not to
-  use it for more clarity, and to use the "server" directive instead.
-
-  See also : "server"
-
-
-enabled
-  Enable a proxy, frontend or backend.
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   yes
-  Arguments : none
-
-  The "enabled" keyword is used to explicitly enable an instance, when the
-  defaults has been set to "disabled". This is very rarely used.
-
-  See also : "disabled"
-
-
-errorfile <code> <file>
-  Return a file contents instead of errors generated by HAProxy
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   yes
-  Arguments :
-    <code>    is the HTTP status code. Currently, HAProxy is capable of
-              generating codes 200, 400, 403, 408, 500, 502, 503, and 504.
-
-    <file>    designates a file containing the full HTTP response. It is
-              recommended to follow the common practice of appending ".http" to
-              the filename so that people do not confuse the response with HTML
-              error pages, and to use absolute paths, since files are read
-              before any chroot is performed.
-
-  It is important to understand that this keyword is not meant to rewrite
-  errors returned by the server, but errors detected and returned by HAProxy.
-  This is why the list of supported errors is limited to a small set.
-
-  Code 200 is emitted in response to requests matching a "monitor-uri" rule.
-
-  The files are returned verbatim on the TCP socket. This allows any trick such
-  as redirections to another URL or site, as well as tricks to clean cookies,
-  force enable or disable caching, etc... The package provides default error
-  files returning the same contents as default errors.
-
-  The files should not exceed the configured buffer size (BUFSIZE), which
-  generally is 8 or 16 kB, otherwise they will be truncated. It is also wise
-  not to put any reference to local contents (eg: images) in order to avoid
-  loops between the client and HAProxy when all servers are down, causing an
-  error to be returned instead of an image. For better HTTP compliance, it is
-  recommended that all header lines end with CR-LF and not LF alone.
-
-  The files are read at the same time as the configuration and kept in memory.
-  For this reason, the errors continue to be returned even when the process is
-  chrooted, and no file change is considered while the process is running. A
-  simple method for developing those files consists in associating them to the
-  403 status code and interrogating a blocked URL.
-
-  See also : "errorloc", "errorloc302", "errorloc303"
-
-  Example :
-        errorfile 400 /etc/haproxy/errorfiles/400badreq.http
-        errorfile 403 /etc/haproxy/errorfiles/403forbid.http
-        errorfile 503 /etc/haproxy/errorfiles/503sorry.http
-
-
-errorloc <code> <url>
-errorloc302 <code> <url>
-  Return an HTTP redirection to a URL instead of errors generated by HAProxy
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   yes
-  Arguments :
-    <code>    is the HTTP status code. Currently, HAProxy is capable of
-              generating codes 200, 400, 403, 408, 500, 502, 503, and 504.
-
-    <url>     it is the exact contents of the "Location" header. It may contain
-              either a relative URI to an error page hosted on the same site,
-              or an absolute URI designating an error page on another site.
-              Special care should be given to relative URIs to avoid redirect
-              loops if the URI itself may generate the same error (eg: 500).
-
-  It is important to understand that this keyword is not meant to rewrite
-  errors returned by the server, but errors detected and returned by HAProxy.
-  This is why the list of supported errors is limited to a small set.
-
-  Code 200 is emitted in response to requests matching a "monitor-uri" rule.
-
-  Note that both keyword return the HTTP 302 status code, which tells the
-  client to fetch the designated URL using the same HTTP method. This can be
-  quite problematic in case of non-GET methods such as POST, because the URL
-  sent to the client might not be allowed for something other than GET. To
-  workaround this problem, please use "errorloc303" which send the HTTP 303
-  status code, indicating to the client that the URL must be fetched with a GET
-  request.
-
-  See also : "errorfile", "errorloc303"
-
-
-errorloc303 <code> <url>
-  Return an HTTP redirection to a URL instead of errors generated by HAProxy
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   yes
-  Arguments :
-    <code>    is the HTTP status code. Currently, HAProxy is capable of
-              generating codes 400, 403, 408, 500, 502, 503, and 504.
-
-    <url>     it is the exact contents of the "Location" header. It may contain
-              either a relative URI to an error page hosted on the same site,
-              or an absolute URI designating an error page on another site.
-              Special care should be given to relative URIs to avoid redirect
-              loops if the URI itself may generate the same error (eg: 500).
-
-  It is important to understand that this keyword is not meant to rewrite
-  errors returned by the server, but errors detected and returned by HAProxy.
-  This is why the list of supported errors is limited to a small set.
-
-  Code 200 is emitted in response to requests matching a "monitor-uri" rule.
-
-  Note that both keyword return the HTTP 303 status code, which tells the
-  client to fetch the designated URL using the same HTTP GET method. This
-  solves the usual problems associated with "errorloc" and the 302 code. It is
-  possible that some very old browsers designed before HTTP/1.1 do not support
-  it, but no such problem has been reported till now.
-
-  See also : "errorfile", "errorloc", "errorloc302"
-
-
-force-persist { if | unless } <condition>
-  Declare a condition to force persistence on down servers
-  May be used in sections:    defaults | frontend | listen | backend
-                                  no   |    yes   |   yes  |   yes
-
-  By default, requests are not dispatched to down servers. It is possible to
-  force this using "option persist", but it is unconditional and redispatches
-  to a valid server if "option redispatch" is set. That leaves with very little
-  possibilities to force some requests to reach a server which is artificially
-  marked down for maintenance operations.
-
-  The "force-persist" statement allows one to declare various ACL-based
-  conditions which, when met, will cause a request to ignore the down status of
-  a server and still try to connect to it. That makes it possible to start a
-  server, still replying an error to the health checks, and run a specially
-  configured browser to test the service. Among the handy methods, one could
-  use a specific source IP address, or a specific cookie. The cookie also has
-  the advantage that it can easily be added/removed on the browser from a test
-  page. Once the service is validated, it is then possible to open the service
-  to the world by returning a valid response to health checks.
-
-  The forced persistence is enabled when an "if" condition is met, or unless an
-  "unless" condition is met. The final redispatch is always disabled when this
-  is used.
-
-  See also : "option redispatch", "ignore-persist", "persist",
-             and section 7 about ACL usage.
-
-
-fullconn <conns>
-  Specify at what backend load the servers will reach their maxconn
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments :
-    <conns>   is the number of connections on the backend which will make the
-              servers use the maximal number of connections.
-
-  When a server has a "maxconn" parameter specified, it means that its number
-  of concurrent connections will never go higher. Additionally, if it has a
-  "minconn" parameter, it indicates a dynamic limit following the backend's
-  load. The server will then always accept at least <minconn> connections,
-  never more than <maxconn>, and the limit will be on the ramp between both
-  values when the backend has less than <conns> concurrent connections. This
-  makes it possible to limit the load on the servers during normal loads, but
-  push it further for important loads without overloading the servers during
-  exceptional loads.
-
-  Example :
-     # The servers will accept between 100 and 1000 concurrent connections each
-     # and the maximum of 1000 will be reached when the backend reaches 10000
-     # connections.
-     backend dynamic
-        fullconn   10000
-        server     srv1   dyn1:80 minconn 100 maxconn 1000
-        server     srv2   dyn2:80 minconn 100 maxconn 1000
-
-  See also : "maxconn", "server"
-
-
-grace <time>
-  Maintain a proxy operational for some time after a soft stop
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   yes
-  Arguments :
-    <time>    is the time (by default in milliseconds) for which the instance
-              will remain operational with the frontend sockets still listening
-              when a soft-stop is received via the SIGUSR1 signal.
-
-  This may be used to ensure that the services disappear in a certain order.
-  This was designed so that frontends which are dedicated to monitoring by an
-  external equipment fail immediately while other ones remain up for the time
-  needed by the equipment to detect the failure.
-
-  Note that currently, there is very little benefit in using this parameter,
-  and it may in fact complicate the soft-reconfiguration process more than
-  simplify it.
-
-
-hash-type <method>
-  Specify a method to use for mapping hashes to servers
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments :
-    map-based   the hash table is a static array containing all alive servers.
-                The hashes will be very smooth, will consider weights, but will
-                be static in that weight changes while a server is up will be
-                ignored. This means that there will be no slow start. Also,
-                since a server is selected by its position in the array, most
-                mappings are changed when the server count changes. This means
-                that when a server goes up or down, or when a server is added
-                to a farm, most connections will be redistributed to different
-                servers. This can be inconvenient with caches for instance.
-
-    consistent  the hash table is a tree filled with many occurrences of each
-                server. The hash key is looked up in the tree and the closest
-                server is chosen. This hash is dynamic, it supports changing
-                weights while the servers are up, so it is compatible with the
-                slow start feature. It has the advantage that when a server
-                goes up or down, only its associations are moved. When a server
-                is added to the farm, only a few part of the mappings are
-                redistributed, making it an ideal algorithm for caches.
-                However, due to its principle, the algorithm will never be very
-                smooth and it may sometimes be necessary to adjust a server's
-                weight or its ID to get a more balanced distribution. In order
-                to get the same distribution on multiple load balancers, it is
-                important that all servers have the same IDs.
-
-  The default hash type is "map-based" and is recommended for most usages.
-
-  See also : "balance", "server"
-
-
-http-check disable-on-404
-  Enable a maintenance mode upon HTTP/404 response to health-checks
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments : none
-
-  When this option is set, a server which returns an HTTP code 404 will be
-  excluded from further load-balancing, but will still receive persistent
-  connections. This provides a very convenient method for Web administrators
-  to perform a graceful shutdown of their servers. It is also important to note
-  that a server which is detected as failed while it was in this mode will not
-  generate an alert, just a notice. If the server responds 2xx or 3xx again, it
-  will immediately be reinserted into the farm. The status on the stats page
-  reports "NOLB" for a server in this mode. It is important to note that this
-  option only works in conjunction with the "httpchk" option. If this option
-  is used with "http-check expect", then it has precedence over it so that 404
-  responses will still be considered as soft-stop.
-
-  See also : "option httpchk", "http-check expect"
-
-
-http-check expect [!] <match> <pattern>
-  Make HTTP health checks consider reponse contents or specific status codes
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments :
-    <match>   is a keyword indicating how to look for a specific pattern in the
-              response. The keyword may be one of "status", "rstatus",
-              "string", or "rstring". The keyword may be preceeded by an
-              exclamation mark ("!") to negate the match. Spaces are allowed
-              between the exclamation mark and the keyword. See below for more
-              details on the supported keywords.
-
-    <pattern> is the pattern to look for. It may be a string or a regular
-              expression. If the pattern contains spaces, they must be escaped
-              with the usual backslash ('\').
-
-  By default, "option httpchk" considers that response statuses 2xx and 3xx
-  are valid, and that others are invalid. When "http-check expect" is used,
-  it defines what is considered valid or invalid. Only one "http-check"
-  statement is supported in a backend. If a server fails to respond or times
-  out, the check obviously fails. The available matches are :
-
-    status <string> : test the exact string match for the HTTP status code.
-                      A health check respose will be considered valid if the
-                      response's status code is exactly this string. If the
-                      "status" keyword is prefixed with "!", then the response
-                      will be considered invalid if the status code matches.
-
-    rstatus <regex> : test a regular expression for the HTTP status code.
-                      A health check respose will be considered valid if the
-                      response's status code matches the expression. If the
-                      "rstatus" keyword is prefixed with "!", then the response
-                      will be considered invalid if the status code matches.
-                      This is mostly used to check for multiple codes.
-
-    string <string> : test the exact string match in the HTTP response body.
-                      A health check respose will be considered valid if the
-                      response's body contains this exact string. If the
-                      "string" keyword is prefixed with "!", then the response
-                      will be considered invalid if the body contains this
-                      string. This can be used to look for a mandatory word at
-                      the end of a dynamic page, or to detect a failure when a
-                      specific error appears on the check page (eg: a stack
-                      trace).
-
-    rstring <regex> : test a regular expression on the HTTP response body.
-                      A health check respose will be considered valid if the
-                      response's body matches this expression. If the "rstring"
-                      keyword is prefixed with "!", then the response will be
-                      considered invalid if the body matches the expression.
-                      This can be used to look for a mandatory word at the end
-                      of a dynamic page, or to detect a failure when a specific
-                      error appears on the check page (eg: a stack trace).
-
-  It is important to note that the responses will be limited to a certain size
-  defined by the global "tune.chksize" option, which defaults to 16384 bytes.
-  Thus, too large responses may not contain the mandatory pattern when using
-  "string" or "rstring". If a large response is absolutely required, it is
-  possible to change the default max size by setting the global variable.
-  However, it is worth keeping in mind that parsing very large responses can
-  waste some CPU cycles, especially when regular expressions are used, and that
-  it is always better to focus the checks on smaller resources.
-
-  Last, if "http-check expect" is combined with "http-check disable-on-404",
-  then this last one has precedence when the server responds with 404.
-
-  Examples :
-         # only accept status 200 as valid
-         http-check expect status 200
-
-         # consider SQL errors as errors
-         http-check expect ! string SQL\ Error
-
-         # consider status 5xx only as errors
-         http-check expect ! rstatus ^5
-
-         # check that we have a correct hexadecimal tag before /html
-         http-check expect rstring <!--tag:[0-9a-f]*</html>
-
-  See also : "option httpchk", "http-check disable-on-404"
-
-
-http-check send-state
-  Enable emission of a state header with HTTP health checks
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments : none
-
-  When this option is set, haproxy will systematically send a special header
-  "X-Haproxy-Server-State" with a list of parameters indicating to each server
-  how they are seen by haproxy. This can be used for instance when a server is
-  manipulated without access to haproxy and the operator needs to know whether
-  haproxy still sees it up or not, or if the server is the last one in a farm.
-
-  The header is composed of fields delimited by semi-colons, the first of which
-  is a word ("UP", "DOWN", "NOLB"), possibly followed by a number of valid
-  checks on the total number before transition, just as appears in the stats
-  interface. Next headers are in the form "<variable>=<value>", indicating in
-  no specific order some values available in the stats interface :
-    - a variable "name", containing the name of the backend followed by a slash
-      ("/") then the name of the server. This can be used when a server is
-      checked in multiple backends.
-
-    - a variable "node" containing the name of the haproxy node, as set in the
-      global "node" variable, otherwise the system's hostname if unspecified.
-
-    - a variable "weight" indicating the weight of the server, a slash ("/")
-      and the total weight of the farm (just counting usable servers). This
-      helps to know if other servers are available to handle the load when this
-      one fails.
-
-    - a variable "scur" indicating the current number of concurrent connections
-      on the server, followed by a slash ("/") then the total number of
-      connections on all servers of the same backend.
-
-    - a variable "qcur" indicating the current number of requests in the
-      server's queue.
-
-  Example of a header received by the application server :
-    >>>  X-Haproxy-Server-State: UP 2/3; name=bck/srv2; node=lb1; weight=1/2; \
-           scur=13/22; qcur=0
-
-  See also : "option httpchk", "http-check disable-on-404"
-
-http-request { allow | deny | auth [realm <realm>] }
-             [ { if | unless } <condition> ]
-  Access control for Layer 7 requests
-
-  May be used in sections:   defaults | frontend | listen | backend
-                                no    |    yes   |   yes  |   yes
-
-  These set of options allow to fine control access to a
-  frontend/listen/backend. Each option may be followed by if/unless and acl.
-  First option with matched condition (or option without condition) is final.
-  For "deny" a 403 error will be returned, for "allow" normal processing is
-  performed, for "auth" a 401/407 error code is returned so the client
-  should be asked to enter a username and password.
-
-  There is no fixed limit to the number of http-request statements per
-  instance.
-
-  Example:
-        acl nagios src 192.168.129.3
-        acl local_net src 192.168.0.0/16
-        acl auth_ok http_auth(L1)
-
-        http-request allow if nagios
-        http-request allow if local_net auth_ok
-        http-request auth realm Gimme if local_net auth_ok
-        http-request deny
-
-  Example:
-        acl auth_ok http_auth_group(L1) G1
-
-        http-request auth unless auth_ok
-
-  See also : "stats http-request", section 3.4 about userlists and section 7
-             about ACL usage.
-
-http-send-name-header [<header>]
-  Add the server name to a request. Use the header string given by <header>
-
-  May be used in sections:   defaults | frontend | listen | backend
-                               yes    |    no    |   yes  |   yes
-
-  Arguments :
-
-    <header>  The header string to use to send the server name
-
-  The "http-send-name-header" statement causes the name of the target
-  server to be added to the headers of an HTTP request.  The name
-  is added with the header string proved.
-
-  See also : "server"
-
-id <value>
-  Set a persistent ID to a proxy.
-  May be used in sections :   defaults | frontend | listen | backend
-                                  no   |    yes   |   yes  |   yes
-  Arguments : none
-
-  Set a persistent ID for the proxy. This ID must be unique and positive.
-  An unused ID will automatically be assigned if unset. The first assigned
-  value will be 1. This ID is currently only returned in statistics.
-
-
-ignore-persist { if | unless } <condition>
-  Declare a condition to ignore persistence
-  May be used in sections:    defaults | frontend | listen | backend
-                                  no   |    yes   |   yes  |   yes
-
-  By default, when cookie persistence is enabled, every requests containing
-  the cookie are unconditionally persistent (assuming the target server is up
-  and running).
-
-  The "ignore-persist" statement allows one to declare various ACL-based
-  conditions which, when met, will cause a request to ignore persistence.
-  This is sometimes useful to load balance requests for static files, which
-  oftenly don't require persistence. This can also be used to fully disable
-  persistence for a specific User-Agent (for example, some web crawler bots).
-
-  Combined with "appsession", it can also help reduce HAProxy memory usage, as
-  the appsession table won't grow if persistence is ignored.
-
-  The persistence is ignored when an "if" condition is met, or unless an
-  "unless" condition is met.
-
-  See also : "force-persist", "cookie", and section 7 about ACL usage.
-
-
-log global
-log <address> <facility> [<level> [<minlevel>]]
-  Enable per-instance logging of events and traffic.
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   yes
-  Arguments :
-    global     should be used when the instance's logging parameters are the
-               same as the global ones. This is the most common usage. "global"
-               replaces <address>, <facility> and <level> with those of the log
-               entries found in the "global" section. Only one "log global"
-               statement may be used per instance, and this form takes no other
-               parameter.
-
-    <address>  indicates where to send the logs. It takes the same format as
-               for the "global" section's logs, and can be one of :
-
-               - An IPv4 address optionally followed by a colon (':') and a UDP
-                 port. If no port is specified, 514 is used by default (the
-                 standard syslog port).
-
-               - A filesystem path to a UNIX domain socket, keeping in mind
-                 considerations for chroot (be sure the path is accessible
-                 inside the chroot) and uid/gid (be sure the path is
-                 appropriately writeable).
-
-    <facility> must be one of the 24 standard syslog facilities :
-
-                 kern   user   mail   daemon auth   syslog lpr    news
-                 uucp   cron   auth2  ftp    ntp    audit  alert  cron2
-                 local0 local1 local2 local3 local4 local5 local6 local7
-
-    <level>    is optional and can be specified to filter outgoing messages. By
-               default, all messages are sent. If a level is specified, only
-               messages with a severity at least as important as this level
-               will be sent. An optional minimum level can be specified. If it
-               is set, logs emitted with a more severe level than this one will
-               be capped to this level. This is used to avoid sending "emerg"
-               messages on all terminals on some default syslog configurations.
-               Eight levels are known :
-
-                 emerg  alert  crit   err    warning notice info  debug
-
-  Note that up to two "log" entries may be specified per instance. However, if
-  "log global" is used and if the "global" section already contains 2 log
-  entries, then additional log entries will be ignored.
-
-  Also, it is important to keep in mind that it is the frontend which decides
-  what to log from a connection, and that in case of content switching, the log
-  entries from the backend will be ignored. Connections are logged at level
-  "info".
-
-  However, backend log declaration define how and where servers status changes
-  will be logged. Level "notice" will be used to indicate a server going up,
-  "warning" will be used for termination signals and definitive service
-  termination, and "alert" will be used for when a server goes down.
-
-  Note : According to RFC3164, messages are truncated to 1024 bytes before
-         being emitted.
-
-  Example :
-    log global
-    log 127.0.0.1:514 local0 notice         # only send important events
-    log 127.0.0.1:514 local0 notice notice  # same but limit output level
-
-
-maxconn <conns>
-  Fix the maximum number of concurrent connections on a frontend
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   no
-  Arguments :
-    <conns>   is the maximum number of concurrent connections the frontend will
-              accept to serve. Excess connections will be queued by the system
-              in the socket's listen queue and will be served once a connection
-              closes.
-
-  If the system supports it, it can be useful on big sites to raise this limit
-  very high so that haproxy manages connection queues, instead of leaving the
-  clients with unanswered connection attempts. This value should not exceed the
-  global maxconn. Also, keep in mind that a connection contains two buffers
-  of 8kB each, as well as some other data resulting in about 17 kB of RAM being
-  consumed per established connection. That means that a medium system equipped
-  with 1GB of RAM can withstand around 40000-50000 concurrent connections if
-  properly tuned.
-
-  Also, when <conns> is set to large values, it is possible that the servers
-  are not sized to accept such loads, and for this reason it is generally wise
-  to assign them some reasonable connection limits.
-
-  See also : "server", global section's "maxconn", "fullconn"
-
-
-mode { tcp|http|health }
-  Set the running mode or protocol of the instance
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   yes
-  Arguments :
-    tcp       The instance will work in pure TCP mode. A full-duplex connection
-              will be established between clients and servers, and no layer 7
-              examination will be performed. This is the default mode. It
-              should be used for SSL, SSH, SMTP, ...
-
-    http      The instance will work in HTTP mode. The client request will be
-              analyzed in depth before connecting to any server. Any request
-              which is not RFC-compliant will be rejected. Layer 7 filtering,
-              processing and switching will be possible. This is the mode which
-              brings HAProxy most of its value.
-
-    health    The instance will work in "health" mode. It will just reply "OK"
-              to incoming connections and close the connection. Nothing will be
-              logged. This mode is used to reply to external components health
-              checks. This mode is deprecated and should not be used anymore as
-              it is possible to do the same and even better by combining TCP or
-              HTTP modes with the "monitor" keyword.
-
-  When doing content switching, it is mandatory that the frontend and the
-  backend are in the same mode (generally HTTP), otherwise the configuration
-  will be refused.
-
-  Example :
-     defaults http_instances
-         mode http
-
-  See also : "monitor", "monitor-net"
-
-
-monitor fail { if | unless } <condition>
-  Add a condition to report a failure to a monitor HTTP request.
-  May be used in sections :   defaults | frontend | listen | backend
-                                 no    |    yes   |   yes  |   no
-  Arguments :
-    if <cond>     the monitor request will fail if the condition is satisfied,
-                  and will succeed otherwise. The condition should describe a
-                  combined test which must induce a failure if all conditions
-                  are met, for instance a low number of servers both in a
-                  backend and its backup.
-
-    unless <cond> the monitor request will succeed only if the condition is
-                  satisfied, and will fail otherwise. Such a condition may be
-                  based on a test on the presence of a minimum number of active
-                  servers in a list of backends.
-
-  This statement adds a condition which can force the response to a monitor
-  request to report a failure. By default, when an external component queries
-  the URI dedicated to monitoring, a 200 response is returned. When one of the
-  conditions above is met, haproxy will return 503 instead of 200. This is
-  very useful to report a site failure to an external component which may base
-  routing advertisements between multiple sites on the availability reported by
-  haproxy. In this case, one would rely on an ACL involving the "nbsrv"
-  criterion. Note that "monitor fail" only works in HTTP mode. Both status
-  messages may be tweaked using "errorfile" or "errorloc" if needed.
-
-  Example:
-     frontend www
-        mode http
-        acl site_dead nbsrv(dynamic) lt 2
-        acl site_dead nbsrv(static)  lt 2
-        monitor-uri   /site_alive
-        monitor fail  if site_dead
-
-  See also : "monitor-net", "monitor-uri", "errorfile", "errorloc"
-
-
-monitor-net <source>
-  Declare a source network which is limited to monitor requests
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   no
-  Arguments :
-    <source>  is the source IPv4 address or network which will only be able to
-              get monitor responses to any request. It can be either an IPv4
-              address, a host name, or an address followed by a slash ('/')
-              followed by a mask.
-
-  In TCP mode, any connection coming from a source matching <source> will cause
-  the connection to be immediately closed without any log. This allows another
-  equipment to probe the port and verify that it is still listening, without
-  forwarding the connection to a remote server.
-
-  In HTTP mode, a connection coming from a source matching <source> will be
-  accepted, the following response will be sent without waiting for a request,
-  then the connection will be closed : "HTTP/1.0 200 OK". This is normally
-  enough for any front-end HTTP probe to detect that the service is UP and
-  running without forwarding the request to a backend server.
-
-  Monitor requests are processed very early. It is not possible to block nor
-  divert them using ACLs. They cannot be logged either, and it is the intended
-  purpose. They are only used to report HAProxy's health to an upper component,
-  nothing more. Right now, it is not possible to set failure conditions on
-  requests caught by "monitor-net".
-
-  Last, please note that only one "monitor-net" statement can be specified in
-  a frontend. If more than one is found, only the last one will be considered.
-
-  Example :
-    # addresses .252 and .253 are just probing us.
-    frontend www
-        monitor-net 192.168.0.252/31
-
-  See also : "monitor fail", "monitor-uri"
-
-
-monitor-uri <uri>
-  Intercept a URI used by external components' monitor requests
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   no
-  Arguments :
-    <uri>     is the exact URI which we want to intercept to return HAProxy's
-              health status instead of forwarding the request.
-
-  When an HTTP request referencing <uri> will be received on a frontend,
-  HAProxy will not forward it nor log it, but instead will return either
-  "HTTP/1.0 200 OK" or "HTTP/1.0 503 Service unavailable", depending on failure
-  conditions defined with "monitor fail". This is normally enough for any
-  front-end HTTP probe to detect that the service is UP and running without
-  forwarding the request to a backend server. Note that the HTTP method, the
-  version and all headers are ignored, but the request must at least be valid
-  at the HTTP level. This keyword may only be used with an HTTP-mode frontend.
-
-  Monitor requests are processed very early. It is not possible to block nor
-  divert them using ACLs. They cannot be logged either, and it is the intended
-  purpose. They are only used to report HAProxy's health to an upper component,
-  nothing more. However, it is possible to add any number of conditions using
-  "monitor fail" and ACLs so that the result can be adjusted to whatever check
-  can be imagined (most often the number of available servers in a backend).
-
-  Example :
-    # Use /haproxy_test to report haproxy's status
-    frontend www
-        mode http
-        monitor-uri /haproxy_test
-
-  See also : "monitor fail", "monitor-net"
-
-
-option abortonclose
-no option abortonclose
-  Enable or disable early dropping of aborted requests pending in queues.
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |     no   |   yes  |   yes
-  Arguments : none
-
-  In presence of very high loads, the servers will take some time to respond.
-  The per-instance connection queue will inflate, and the response time will
-  increase respective to the size of the queue times the average per-session
-  response time. When clients will wait for more than a few seconds, they will
-  often hit the "STOP" button on their browser, leaving a useless request in
-  the queue, and slowing down other users, and the servers as well, because the
-  request will eventually be served, then aborted at the first error
-  encountered while delivering the response.
-
-  As there is no way to distinguish between a full STOP and a simple output
-  close on the client side, HTTP agents should be conservative and consider
-  that the client might only have closed its output channel while waiting for
-  the response. However, this introduces risks of congestion when lots of users
-  do the same, and is completely useless nowadays because probably no client at
-  all will close the session while waiting for the response. Some HTTP agents
-  support this behaviour (Squid, Apache, HAProxy), and others do not (TUX, most
-  hardware-based load balancers). So the probability for a closed input channel
-  to represent a user hitting the "STOP" button is close to 100%, and the risk
-  of being the single component to break rare but valid traffic is extremely
-  low, which adds to the temptation to be able to abort a session early while
-  still not served and not pollute the servers.
-
-  In HAProxy, the user can choose the desired behaviour using the option
-  "abortonclose". By default (without the option) the behaviour is HTTP
-  compliant and aborted requests will be served. But when the option is
-  specified, a session with an incoming channel closed will be aborted while
-  it is still possible, either pending in the queue for a connection slot, or
-  during the connection establishment if the server has not yet acknowledged
-  the connection request. This considerably reduces the queue size and the load
-  on saturated servers when users are tempted to click on STOP, which in turn
-  reduces the response time for other users.
-
-  If this option has been enabled in a "defaults" section, it can be disabled
-  in a specific instance by prepending the "no" keyword before it.
-
-  See also : "timeout queue" and server's "maxconn" and "maxqueue" parameters
-
-
-option accept-invalid-http-request
-no option accept-invalid-http-request
-  Enable or disable relaxing of HTTP request parsing
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   no
-  Arguments : none
-
-  By default, HAProxy complies with RFC2616 in terms of message parsing. This
-  means that invalid characters in header names are not permitted and cause an
-  error to be returned to the client. This is the desired behaviour as such
-  forbidden characters are essentially used to build attacks exploiting server
-  weaknesses, and bypass security filtering. Sometimes, a buggy browser or
-  server will emit invalid header names for whatever reason (configuration,
-  implementation) and the issue will not be immediately fixed. In such a case,
-  it is possible to relax HAProxy's header name parser to accept any character
-  even if that does not make sense, by specifying this option.
-
-  This option should never be enabled by default as it hides application bugs
-  and open security breaches. It should only be deployed after a problem has
-  been confirmed.
-
-  When this option is enabled, erroneous header names will still be accepted in
-  requests, but the complete request will be captured in order to permit later
-  analysis using the "show errors" request on the UNIX stats socket. Doing this
-  also helps confirming that the issue has been solved.
-
-  If this option has been enabled in a "defaults" section, it can be disabled
-  in a specific instance by prepending the "no" keyword before it.
-
-  See also : "option accept-invalid-http-response" and "show errors" on the
-             stats socket.
-
-
-option accept-invalid-http-response
-no option accept-invalid-http-response
-  Enable or disable relaxing of HTTP response parsing
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |     no   |   yes  |   yes
-  Arguments : none
-
-  By default, HAProxy complies with RFC2616 in terms of message parsing. This
-  means that invalid characters in header names are not permitted and cause an
-  error to be returned to the client. This is the desired behaviour as such
-  forbidden characters are essentially used to build attacks exploiting server
-  weaknesses, and bypass security filtering. Sometimes, a buggy browser or
-  server will emit invalid header names for whatever reason (configuration,
-  implementation) and the issue will not be immediately fixed. In such a case,
-  it is possible to relax HAProxy's header name parser to accept any character
-  even if that does not make sense, by specifying this option.
-
-  This option should never be enabled by default as it hides application bugs
-  and open security breaches. It should only be deployed after a problem has
-  been confirmed.
-
-  When this option is enabled, erroneous header names will still be accepted in
-  responses, but the complete response will be captured in order to permit
-  later analysis using the "show errors" request on the UNIX stats socket.
-  Doing this also helps confirming that the issue has been solved.
-
-  If this option has been enabled in a "defaults" section, it can be disabled
-  in a specific instance by prepending the "no" keyword before it.
-
-  See also : "option accept-invalid-http-request" and "show errors" on the
-             stats socket.
-
-
-option allbackups
-no option allbackups
-  Use either all backup servers at a time or only the first one
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |     no   |   yes  |   yes
-  Arguments : none
-
-  By default, the first operational backup server gets all traffic when normal
-  servers are all down. Sometimes, it may be preferred to use multiple backups
-  at once, because one will not be enough. When "option allbackups" is enabled,
-  the load balancing will be performed among all backup servers when all normal
-  ones are unavailable. The same load balancing algorithm will be used and the
-  servers' weights will be respected. Thus, there will not be any priority
-  order between the backup servers anymore.
-
-  This option is mostly used with static server farms dedicated to return a
-  "sorry" page when an application is completely offline.
-
-  If this option has been enabled in a "defaults" section, it can be disabled
-  in a specific instance by prepending the "no" keyword before it.
-
-
-option checkcache
-no option checkcache
-  Analyze all server responses and block requests with cacheable cookies
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |     no   |   yes  |   yes
-  Arguments : none
-
-  Some high-level frameworks set application cookies everywhere and do not
-  always let enough control to the developer to manage how the responses should
-  be cached. When a session cookie is returned on a cacheable object, there is a
-  high risk of session crossing or stealing between users traversing the same
-  caches. In some situations, it is better to block the response than to let
-  some sensitive session information go in the wild.
-
-  The option "checkcache" enables deep inspection of all server responses for
-  strict compliance with HTTP specification in terms of cacheability. It
-  carefully checks "Cache-control", "Pragma" and "Set-cookie" headers in server
-  response to check if there's a risk of caching a cookie on a client-side
-  proxy. When this option is enabled, the only responses which can be delivered
-  to the client are :
-    - all those without "Set-Cookie" header ;
-    - all those with a return code other than 200, 203, 206, 300, 301, 410,
-      provided that the server has not set a "Cache-control: public" header ;
-    - all those that come from a POST request, provided that the server has not
-      set a 'Cache-Control: public' header ;
-    - those with a 'Pragma: no-cache' header
-    - those with a 'Cache-control: private' header
-    - those with a 'Cache-control: no-store' header
-    - those with a 'Cache-control: max-age=0' header
-    - those with a 'Cache-control: s-maxage=0' header
-    - those with a 'Cache-control: no-cache' header
-    - those with a 'Cache-control: no-cache="set-cookie"' header
-    - those with a 'Cache-control: no-cache="set-cookie,' header
-      (allowing other fields after set-cookie)
-
-  If a response doesn't respect these requirements, then it will be blocked
-  just as if it was from an "rspdeny" filter, with an "HTTP 502 bad gateway".
-  The session state shows "PH--" meaning that the proxy blocked the response
-  during headers processing. Additionally, an alert will be sent in the logs so
-  that admins are informed that there's something to be fixed.
-
-  Due to the high impact on the application, the application should be tested
-  in depth with the option enabled before going to production. It is also a
-  good practice to always activate it during tests, even if it is not used in
-  production, as it will report potentially dangerous application behaviours.
-
-  If this option has been enabled in a "defaults" section, it can be disabled
-  in a specific instance by prepending the "no" keyword before it.
-
-
-option clitcpka
-no option clitcpka
-  Enable or disable the sending of TCP keepalive packets on the client side
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   no
-  Arguments : none
-
-  When there is a firewall or any session-aware component between a client and
-  a server, and when the protocol involves very long sessions with long idle
-  periods (eg: remote desktops), there is a risk that one of the intermediate
-  components decides to expire a session which has remained idle for too long.
-
-  Enabling socket-level TCP keep-alives makes the system regularly send packets
-  to the other end of the connection, leaving it active. The delay between
-  keep-alive probes is controlled by the system only and depends both on the
-  operating system and its tuning parameters.
-
-  It is important to understand that keep-alive packets are neither emitted nor
-  received at the application level. It is only the network stacks which sees
-  them. For this reason, even if one side of the proxy already uses keep-alives
-  to maintain its connection alive, those keep-alive packets will not be
-  forwarded to the other side of the proxy.
-
-  Please note that this has nothing to do with HTTP keep-alive.
-
-  Using option "clitcpka" enables the emission of TCP keep-alive probes on the
-  client side of a connection, which should help when session expirations are
-  noticed between HAProxy and a client.
-
-  If this option has been enabled in a "defaults" section, it can be disabled
-  in a specific instance by prepending the "no" keyword before it.
-
-  See also : "option srvtcpka", "option tcpka"
-
-
-option contstats
-  Enable continuous traffic statistics updates
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   no
-  Arguments : none
-
-  By default, counters used for statistics calculation are incremented
-  only when a session finishes. It works quite well when serving small
-  objects, but with big ones (for example large images or archives) or
-  with A/V streaming, a graph generated from haproxy counters looks like
-  a hedgehog. With this option enabled counters get incremented continuously,
-  during a whole session. Recounting touches a hotpath directly so
-  it is not enabled by default, as it has small performance impact (~0.5%).
-
-
-option dontlog-normal
-no option dontlog-normal
-  Enable or disable logging of normal, successful connections
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   no
-  Arguments : none
-
-  There are large sites dealing with several thousand connections per second
-  and for which logging is a major pain. Some of them are even forced to turn
-  logs off and cannot debug production issues. Setting this option ensures that
-  normal connections, those which experience no error, no timeout, no retry nor
-  redispatch, will not be logged. This leaves disk space for anomalies. In HTTP
-  mode, the response status code is checked and return codes 5xx will still be
-  logged.
-
-  It is strongly discouraged to use this option as most of the time, the key to
-  complex issues is in the normal logs which will not be logged here. If you
-  need to separate logs, see the "log-separate-errors" option instead.
-
-  See also : "log", "dontlognull", "log-separate-errors" and section 8 about
-             logging.
-
-
-option dontlognull
-no option dontlognull
-  Enable or disable logging of null connections
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   no
-  Arguments : none
-
-  In certain environments, there are components which will regularly connect to
-  various systems to ensure that they are still alive. It can be the case from
-  another load balancer as well as from monitoring systems. By default, even a
-  simple port probe or scan will produce a log. If those connections pollute
-  the logs too much, it is possible to enable option "dontlognull" to indicate
-  that a connection on which no data has been transferred will not be logged,
-  which typically corresponds to those probes.
-
-  It is generally recommended not to use this option in uncontrolled
-  environments (eg: internet), otherwise scans and other malicious activities
-  would not be logged.
-
-  If this option has been enabled in a "defaults" section, it can be disabled
-  in a specific instance by prepending the "no" keyword before it.
-
-  See also : "log", "monitor-net", "monitor-uri" and section 8 about logging.
-
-
-option forceclose
-no option forceclose
-  Enable or disable active connection closing after response is transferred.
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   yes
-  Arguments : none
-
-  Some HTTP servers do not necessarily close the connections when they receive
-  the "Connection: close" set by "option httpclose", and if the client does not
-  close either, then the connection remains open till the timeout expires. This
-  causes high number of simultaneous connections on the servers and shows high
-  global session times in the logs.
-
-  When this happens, it is possible to use "option forceclose". It will
-  actively close the outgoing server channel as soon as the server has finished
-  to respond. This option implicitly enables the "httpclose" option. Note that
-  this option also enables the parsing of the full request and response, which
-  means we can close the connection to the server very quickly, releasing some
-  resources earlier than with httpclose.
-
-  This option may also be combined with "option http-pretend-keepalive", which
-  will disable sending of the "Connection: close" header, but will still cause
-  the connection to be closed once the whole response is received.
-
-  If this option has been enabled in a "defaults" section, it can be disabled
-  in a specific instance by prepending the "no" keyword before it.
-
-  See also : "option httpclose" and "option http-pretend-keepalive"
-
-
-option forwardfor [ except <network> ] [ header <name> ] [ if-none ]
-  Enable insertion of the X-Forwarded-For header to requests sent to servers
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   yes
-  Arguments :
-    <network> is an optional argument used to disable this option for sources
-              matching <network>
-    <name>    an optional argument to specify a different "X-Forwarded-For"
-              header name.
-
-  Since HAProxy works in reverse-proxy mode, the servers see its IP address as
-  their client address. This is sometimes annoying when the client's IP address
-  is expected in server logs. To solve this problem, the well-known HTTP header
-  "X-Forwarded-For" may be added by HAProxy to all requests sent to the server.
-  This header contains a value representing the client's IP address. Since this
-  header is always appended at the end of the existing header list, the server
-  must be configured to always use the last occurrence of this header only. See
-  the server's manual to find how to enable use of this standard header. Note
-  that only the last occurrence of the header must be used, since it is really
-  possible that the client has already brought one.
-
-  The keyword "header" may be used to supply a different header name to replace
-  the default "X-Forwarded-For". This can be useful where you might already
-  have a "X-Forwarded-For" header from a different application (eg: stunnel),
-  and you need preserve it. Also if your backend server doesn't use the
-  "X-Forwarded-For" header and requires different one (eg: Zeus Web Servers
-  require "X-Cluster-Client-IP").
-
-  Sometimes, a same HAProxy instance may be shared between a direct client
-  access and a reverse-proxy access (for instance when an SSL reverse-proxy is
-  used to decrypt HTTPS traffic). It is possible to disable the addition of the
-  header for a known source address or network by adding the "except" keyword
-  followed by the network address. In this case, any source IP matching the
-  network will not cause an addition of this header. Most common uses are with
-  private networks or 127.0.0.1.
-
-  Alternatively, the keyword "if-none" states that the header will only be
-  added if it is not present. This should only be used in perfectly trusted
-  environment, as this might cause a security issue if headers reaching haproxy
-  are under the control of the end-user.
-
-  This option may be specified either in the frontend or in the backend. If at
-  least one of them uses it, the header will be added. Note that the backend's
-  setting of the header subargument takes precedence over the frontend's if
-  both are defined. In the case of the "if-none" argument, if at least one of
-  the frontend or the backend does not specify it, it wants the addition to be
-  mandatory, so it wins.
-
-  It is important to note that by default, HAProxy works in tunnel mode and
-  only inspects the first request of a connection, meaning that only the first
-  request will have the header appended, which is certainly not what you want.
-  In order to fix this, ensure that any of the "httpclose", "forceclose" or
-  "http-server-close" options is set when using this option.
-
-  Examples :
-    # Public HTTP address also used by stunnel on the same machine
-    frontend www
-        mode http
-        option forwardfor except 127.0.0.1  # stunnel already adds the header
-
-    # Those servers want the IP Address in X-Client
-    backend www
-        mode http
-        option forwardfor header X-Client
-
-  See also : "option httpclose", "option http-server-close",
-             "option forceclose"
-
-
-option http-no-delay
-no option http-no-delay
-  Instruct the system to favor low interactive delays over performance in HTTP
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   yes
-  Arguments : none
-
-  In HTTP, each payload is unidirectional and has no notion of interactivity.
-  Any agent is expected to queue data somewhat for a reasonably low delay.
-  There are some very rare server-to-server applications that abuse the HTTP
-  protocol and expect the payload phase to be highly interactive, with many
-  interleaved data chunks in both directions within a single request. This is
-  absolutely not supported by the HTTP specification and will not work across
-  most proxies or servers. When such applications attempt to do this through
-  haproxy, it works but they will experience high delays due to the network
-  optimizations which favor performance by instructing the system to wait for
-  enough data to be available in order to only send full packets. Typical
-  delays are around 200 ms per round trip. Note that this only happens with
-  abnormal uses. Normal uses such as CONNECT requests nor WebSockets are not
-  affected.
-
-  When "option http-no-delay" is present in either the frontend or the backend
-  used by a connection, all such optimizations will be disabled in order to
-  make the exchanges as fast as possible. Of course this offers no guarantee on
-  the functionality, as it may break at any other place. But if it works via
-  HAProxy, it will work as fast as possible. This option should never be used
-  by default, and should never be used at all unless such a buggy application
-  is discovered. The impact of using this option is an increase of bandwidth
-  usage and CPU usage, which may significantly lower performance in high
-  latency environments.
-
-
-option http-pretend-keepalive
-no option http-pretend-keepalive
-  Define whether haproxy will announce keepalive to the server or not
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   yes
-  Arguments : none
-
-  When running with "option http-server-close" or "option forceclose", haproxy
-  adds a "Connection: close" header to the request forwarded to the server.
-  Unfortunately, when some servers see this header, they automatically refrain
-  from using the chunked encoding for responses of unknown length, while this
-  is totally unrelated. The immediate effect is that this prevents haproxy from
-  maintaining the client connection alive. A second effect is that a client or
-  a cache could receive an incomplete response without being aware of it, and
-  consider the response complete.
-
-  By setting "option http-pretend-keepalive", haproxy will make the server
-  believe it will keep the connection alive. The server will then not fall back
-  to the abnormal undesired above. When haproxy gets the whole response, it
-  will close the connection with the server just as it would do with the
-  "forceclose" option. That way the client gets a normal response and the
-  connection is correctly closed on the server side.
-
-  It is recommended not to enable this option by default, because most servers
-  will more efficiently close the connection themselves after the last packet,
-  and release its buffers slightly earlier. Also, the added packet on the
-  network could slightly reduce the overall peak performance. However it is
-  worth noting that when this option is enabled, haproxy will have slightly
-  less work to do. So if haproxy is the bottleneck on the whole architecture,
-  enabling this option might save a few CPU cycles.
-
-  This option may be set both in a frontend and in a backend. It is enabled if
-  at least one of the frontend or backend holding a connection has it enabled.
-  This option may be compbined with "option httpclose", which will cause
-  keepalive to be announced to the server and close to be announced to the
-  client. This practice is discouraged though.
-
-  If this option has been enabled in a "defaults" section, it can be disabled
-  in a specific instance by prepending the "no" keyword before it.
-
-  See also : "option forceclose" and "option http-server-close"
-
-
-option http-server-close
-no option http-server-close
-  Enable or disable HTTP connection closing on the server side
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   yes
-  Arguments : none
-
-  By default, when a client communicates with a server, HAProxy will only
-  analyze, log, and process the first request of each connection. Setting
-  "option http-server-close" enables HTTP connection-close mode on the server
-  side while keeping the ability to support HTTP keep-alive and pipelining on
-  the client side.  This provides the lowest latency on the client side (slow
-  network) and the fastest session reuse on the server side to save server
-  resources, similarly to "option forceclose". It also permits non-keepalive
-  capable servers to be served in keep-alive mode to the clients if they
-  conform to the requirements of RFC2616. Please note that some servers do not
-  always conform to those requirements when they see "Connection: close" in the
-  request. The effect will be that keep-alive will never be used. A workaround
-  consists in enabling "option http-pretend-keepalive".
-
-  At the moment, logs will not indicate whether requests came from the same
-  session or not. The accept date reported in the logs corresponds to the end
-  of the previous request, and the request time corresponds to the time spent
-  waiting for a new request. The keep-alive request time is still bound to the
-  timeout defined by "timeout http-keep-alive" or "timeout http-request" if
-  not set.
-
-  This option may be set both in a frontend and in a backend. It is enabled if
-  at least one of the frontend or backend holding a connection has it enabled.
-  It is worth noting that "option forceclose" has precedence over "option
-  http-server-close" and that combining "http-server-close" with "httpclose"
-  basically achieve the same result as "forceclose".
-
-  If this option has been enabled in a "defaults" section, it can be disabled
-  in a specific instance by prepending the "no" keyword before it.
-
-  See also : "option forceclose", "option http-pretend-keepalive",
-             "option httpclose" and "1.1. The HTTP transaction model".
-
-
-option http-use-proxy-header
-no option http-use-proxy-header
-  Make use of non-standard Proxy-Connection header instead of Connection
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   no
-  Arguments : none
-
-  While RFC2616 explicitly states that HTTP/1.1 agents must use the
-  Connection header to indicate their wish of persistent or non-persistent
-  connections, both browsers and proxies ignore this header for proxied
-  connections and make use of the undocumented, non-standard Proxy-Connection
-  header instead. The issue begins when trying to put a load balancer between
-  browsers and such proxies, because there will be a difference between what
-  haproxy understands and what the client and the proxy agree on.
-
-  By setting this option in a frontend, haproxy can automatically switch to use
-  that non-standard header if it sees proxied requests. A proxied request is
-  defined here as one where the URI begins with neither a '/' nor a '*'. The
-  choice of header only affects requests passing through proxies making use of
-  one of the "httpclose", "forceclose" and "http-server-close" options. Note
-  that this option can only be specified in a frontend and will affect the
-  request along its whole life.
-
-  Also, when this option is set, a request which requires authentication will
-  automatically switch to use proxy authentication headers if it is itself a
-  proxied request. That makes it possible to check or enforce authentication in
-  front of an existing proxy.
-
-  This option should normally never be used, except in front of a proxy.
-
-  See also : "option httpclose", "option forceclose" and "option
-             http-server-close".
-
-
-option httpchk
-option httpchk <uri>
-option httpchk <method> <uri>
-option httpchk <method> <uri> <version>
-  Enable HTTP protocol to check on the servers health
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments :
-    <method>  is the optional HTTP method used with the requests. When not set,
-              the "OPTIONS" method is used, as it generally requires low server
-              processing and is easy to filter out from the logs. Any method
-              may be used, though it is not recommended to invent non-standard
-              ones.
-
-    <uri>     is the URI referenced in the HTTP requests. It defaults to " / "
-              which is accessible by default on almost any server, but may be
-              changed to any other URI. Query strings are permitted.
-
-    <version> is the optional HTTP version string. It defaults to "HTTP/1.0"
-              but some servers might behave incorrectly in HTTP 1.0, so turning
-              it to HTTP/1.1 may sometimes help. Note that the Host field is
-              mandatory in HTTP/1.1, and as a trick, it is possible to pass it
-              after "\r\n" following the version string.
-
-  By default, server health checks only consist in trying to establish a TCP
-  connection. When "option httpchk" is specified, a complete HTTP request is
-  sent once the TCP connection is established, and responses 2xx and 3xx are
-  considered valid, while all other ones indicate a server failure, including
-  the lack of any response.
-
-  The port and interval are specified in the server configuration.
-
-  This option does not necessarily require an HTTP backend, it also works with
-  plain TCP backends. This is particularly useful to check simple scripts bound
-  to some dedicated ports using the inetd daemon.
-
-  Examples :
-      # Relay HTTPS traffic to Apache instance and check service availability
-      # using HTTP request "OPTIONS * HTTP/1.1" on port 80.
-      backend https_relay
-          mode tcp
-          option httpchk OPTIONS * HTTP/1.1\r\nHost:\ www
-          server apache1 192.168.1.1:443 check port 80
-
-  See also : "option ssl-hello-chk", "option smtpchk", "option mysql-check",
-             "http-check" and the "check", "port" and "inter" server options.
-
-
-option httpclose
-no option httpclose
-  Enable or disable passive HTTP connection closing
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   yes
-  Arguments : none
-
-  By default, when a client communicates with a server, HAProxy will only
-  analyze, log, and process the first request of each connection. If "option
-  httpclose" is set, it will check if a "Connection: close" header is already
-  set in each direction, and will add one if missing. Each end should react to
-  this by actively closing the TCP connection after each transfer, thus
-  resulting in a switch to the HTTP close mode. Any "Connection" header
-  different from "close" will also be removed.
-
-  It seldom happens that some servers incorrectly ignore this header and do not
-  close the connection eventhough they reply "Connection: close". For this
-  reason, they are not compatible with older HTTP 1.0 browsers. If this happens
-  it is possible to use the "option forceclose" which actively closes the
-  request connection once the server responds. Option "forceclose" also
-  releases the server connection earlier because it does not have to wait for
-  the client to acknowledge it.
-
-  This option may be set both in a frontend and in a backend. It is enabled if
-  at least one of the frontend or backend holding a connection has it enabled.
-  If "option forceclose" is specified too, it has precedence over "httpclose".
-  If "option http-server-close" is enabled at the same time as "httpclose", it
-  basically achieves the same result as "option forceclose".
-
-  If this option has been enabled in a "defaults" section, it can be disabled
-  in a specific instance by prepending the "no" keyword before it.
-
-  See also : "option forceclose", "option http-server-close" and
-             "1.1. The HTTP transaction model".
-
-
-option httplog [ clf ]
-  Enable logging of HTTP request, session state and timers
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   yes
-  Arguments :
-    clf       if the "clf" argument is added, then the output format will be
-              the CLF format instead of HAProxy's default HTTP format. You can
-              use this when you need to feed HAProxy's logs through a specific
-              log analyser which only support the CLF format and which is not
-              extensible.
-
-  By default, the log output format is very poor, as it only contains the
-  source and destination addresses, and the instance name. By specifying
-  "option httplog", each log line turns into a much richer format including,
-  but not limited to, the HTTP request, the connection timers, the session
-  status, the connections numbers, the captured headers and cookies, the
-  frontend, backend and server name, and of course the source address and
-  ports.
-
-  This option may be set either in the frontend or the backend.
-
-  If this option has been enabled in a "defaults" section, it can be disabled
-  in a specific instance by prepending the "no" keyword before it. Specifying
-  only "option httplog" will automatically clear the 'clf' mode if it was set
-  by default.
-
-  See also :  section 8 about logging.
-
-
-option http_proxy
-no option http_proxy
-  Enable or disable plain HTTP proxy mode
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   yes
-  Arguments : none
-
-  It sometimes happens that people need a pure HTTP proxy which understands
-  basic proxy requests without caching nor any fancy feature. In this case,
-  it may be worth setting up an HAProxy instance with the "option http_proxy"
-  set. In this mode, no server is declared, and the connection is forwarded to
-  the IP address and port found in the URL after the "http://" scheme.
-
-  No host address resolution is performed, so this only works when pure IP
-  addresses are passed. Since this option's usage perimeter is rather limited,
-  it will probably be used only by experts who know they need exactly it. Last,
-  if the clients are susceptible of sending keep-alive requests, it will be
-  needed to add "option httpclose" to ensure that all requests will correctly
-  be analyzed.
-
-  If this option has been enabled in a "defaults" section, it can be disabled
-  in a specific instance by prepending the "no" keyword before it.
-
-  Example :
-    # this backend understands HTTP proxy requests and forwards them directly.
-    backend direct_forward
-        option httpclose
-        option http_proxy
-
-  See also : "option httpclose"
-
-
-option independant-streams
-no option independant-streams
-  Enable or disable independant timeout processing for both directions
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |  yes
-  Arguments : none
-
-  By default, when data is sent over a socket, both the write timeout and the
-  read timeout for that socket are refreshed, because we consider that there is
-  activity on that socket, and we have no other means of guessing if we should
-  receive data or not.
-
-  While this default behaviour is desirable for almost all applications, there
-  exists a situation where it is desirable to disable it, and only refresh the
-  read timeout if there are incoming data. This happens on sessions with large
-  timeouts and low amounts of exchanged data such as telnet session. If the
-  server suddenly disappears, the output data accumulates in the system's
-  socket buffers, both timeouts are correctly refreshed, and there is no way
-  to know the server does not receive them, so we don't timeout. However, when
-  the underlying protocol always echoes sent data, it would be enough by itself
-  to detect the issue using the read timeout. Note that this problem does not
-  happen with more verbose protocols because data won't accumulate long in the
-  socket buffers.
-
-  When this option is set on the frontend, it will disable read timeout updates
-  on data sent to the client. There probably is little use of this case. When
-  the option is set on the backend, it will disable read timeout updates on
-  data sent to the server. Doing so will typically break large HTTP posts from
-  slow lines, so use it with caution.
-
-  See also : "timeout client" and "timeout server"
-
-
-option ldap-check
-  Use LDAPv3 health checks for server testing
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments : none
-
-  It is possible to test that the server correctly talks LDAPv3 instead of just
-  testing that it accepts the TCP connection. When this option is set, an
-  LDAPv3 anonymous simple bind message is sent to the server, and the response
-  is analyzed to find an LDAPv3 bind response message.
-
-  The server is considered valid only when the LDAP response contains success
-  resultCode (http://tools.ietf.org/html/rfc4511#section-4.1.9).
-
-  Logging of bind requests is server dependent see your documentation how to
-  configure it.
-
-  Example :
-        option ldap-check
-
-  See also : "option httpchk"
-
-
-option log-health-checks
-no option log-health-checks
-  Enable or disable logging of health checks
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |  yes
-  Arguments : none
-
-  Enable health checks logging so it possible to check for example what
-  was happening before a server crash. Failed health check are logged if
-  server is UP and succeeded health checks if server is DOWN, so the amount
-  of additional information is limited.
-
-  If health check logging is enabled no health check status is printed
-  when servers is set up UP/DOWN/ENABLED/DISABLED.
-
-  See also: "log" and section 8 about logging.
-
-
-option log-separate-errors
-no option log-separate-errors
-  Change log level for non-completely successful connections
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   no
-  Arguments : none
-
-  Sometimes looking for errors in logs is not easy. This option makes haproxy
-  raise the level of logs containing potentially interesting information such
-  as errors, timeouts, retries, redispatches, or HTTP status codes 5xx. The
-  level changes from "info" to "err". This makes it possible to log them
-  separately to a different file with most syslog daemons. Be careful not to
-  remove them from the original file, otherwise you would lose ordering which
-  provides very important information.
-
-  Using this option, large sites dealing with several thousand connections per
-  second may log normal traffic to a rotating buffer and only archive smaller
-  error logs.
-
-  See also : "log", "dontlognull", "dontlog-normal" and section 8 about
-             logging.
-
-
-option logasap
-no option logasap
-  Enable or disable early logging of HTTP requests
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   no
-  Arguments : none
-
-  By default, HTTP requests are logged upon termination so that the total
-  transfer time and the number of bytes appear in the logs. When large objects
-  are being transferred, it may take a while before the request appears in the
-  logs. Using "option logasap", the request gets logged as soon as the server
-  sends the complete headers. The only missing information in the logs will be
-  the total number of bytes which will indicate everything except the amount
-  of data transferred, and the total time which will not take the transfer
-  time into account. In such a situation, it's a good practice to capture the
-  "Content-Length" response header so that the logs at least indicate how many
-  bytes are expected to be transferred.
-
-  Examples :
-      listen http_proxy 0.0.0.0:80
-          mode http
-          option httplog
-          option logasap
-          log 192.168.2.200 local3
-
-    >>> Feb  6 12:14:14 localhost \
-          haproxy[14389]: 10.0.1.2:33317 [06/Feb/2009:12:14:14.655] http-in \
-          static/srv1 9/10/7/14/+30 200 +243 - - ---- 3/1/1/1/0 1/0 \
-          "GET /image.iso HTTP/1.0"
-
-  See also : "option httplog", "capture response header", and section 8 about
-             logging.
-
-
-option mysql-check [ user <username> ]
-  Use MySQL health checks for server testing
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments :
-    <username> This is the username which will be used when connecting to MySQL
-               server.
-
-  If you specify a username, the check consists of sending two MySQL packet,
-  one Client Authentication packet, and one QUIT packet, to correctly close
-  MySQL session. We then parse the MySQL Handshake Initialisation packet and/or
-  Error packet. It is a basic but useful test which does not produce error nor
-  aborted connect on the server. However, it requires adding an authorization
-  in the MySQL table, like this :
-
-      USE mysql;
-      INSERT INTO user (Host,User) values ('<ip_of_haproxy>','<username>');
-      FLUSH PRIVILEGES;
-
-  If you don't specify a username (it is deprecated and not recommended), the
-  check only consists in parsing the Mysql Handshake Initialisation packet or
-  Error packet, we don't send anything in this mode. It was reported that it
-  can generate lockout if check is too frequent and/or if there is not enough
-  traffic. In fact, you need in this case to check MySQL "max_connect_errors"
-  value as if a connection is established successfully within fewer than MySQL
-  "max_connect_errors" attempts after a previous connection was interrupted,
-  the error count for the host is cleared to zero. If HAProxy's server get
-  blocked, the "FLUSH HOSTS" statement is the only way to unblock it.
-
-  Remember that this does not check database presence nor database consistency.
-  To do this, you can use an external check with xinetd for example.
-
-  The check requires MySQL >=3.22, for older version, please use TCP check.
-
-  Most often, an incoming MySQL server needs to see the client's IP address for
-  various purposes, including IP privilege matching and connection logging.
-  When possible, it is often wise to masquerade the client's IP address when
-  connecting to the server using the "usesrc" argument of the "source" keyword,
-  which requires the cttproxy feature to be compiled in, and the MySQL server
-  to route the client via the machine hosting haproxy.
-
-  See also: "option httpchk"
-
-
-option nolinger
-no option nolinger
-  Enable or disable immediate session resource cleaning after close
-  May be used in sections:    defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   yes
-  Arguments : none
-
-  When clients or servers abort connections in a dirty way (eg: they are
-  physically disconnected), the session timeouts triggers and the session is
-  closed. But it will remain in FIN_WAIT1 state for some time in the system,
-  using some resources and possibly limiting the ability to establish newer
-  connections.
-
-  When this happens, it is possible to activate "option nolinger" which forces
-  the system to immediately remove any socket's pending data on close. Thus,
-  the session is instantly purged from the system's tables. This usually has
-  side effects such as increased number of TCP resets due to old retransmits
-  getting immediately rejected. Some firewalls may sometimes complain about
-  this too.
-
-  For this reason, it is not recommended to use this option when not absolutely
-  needed. You know that you need it when you have thousands of FIN_WAIT1
-  sessions on your system (TIME_WAIT ones do not count).
-
-  This option may be used both on frontends and backends, depending on the side
-  where it is required. Use it on the frontend for clients, and on the backend
-  for servers.
-
-  If this option has been enabled in a "defaults" section, it can be disabled
-  in a specific instance by prepending the "no" keyword before it.
-
-
-option originalto [ except <network> ] [ header <name> ]
-  Enable insertion of the X-Original-To header to requests sent to servers
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   yes
-  Arguments :
-    <network> is an optional argument used to disable this option for sources
-              matching <network>
-    <name>    an optional argument to specify a different "X-Original-To"
-              header name.
-
-  Since HAProxy can work in transparent mode, every request from a client can
-  be redirected to the proxy and HAProxy itself can proxy every request to a
-  complex SQUID environment and the destination host from SO_ORIGINAL_DST will
-  be lost. This is annoying when you want access rules based on destination ip
-  addresses. To solve this problem, a new HTTP header "X-Original-To" may be
-  added by HAProxy to all requests sent to the server. This header contains a
-  value representing the original destination IP address. Since this must be
-  configured to always use the last occurrence of this header only. Note that
-  only the last occurrence of the header must be used, since it is really
-  possible that the client has already brought one.
-
-  The keyword "header" may be used to supply a different header name to replace
-  the default "X-Original-To". This can be useful where you might already
-  have a "X-Original-To" header from a different application, and you need
-  preserve it. Also if your backend server doesn't use the "X-Original-To"
-  header and requires different one.
-
-  Sometimes, a same HAProxy instance may be shared between a direct client
-  access and a reverse-proxy access (for instance when an SSL reverse-proxy is
-  used to decrypt HTTPS traffic). It is possible to disable the addition of the
-  header for a known source address or network by adding the "except" keyword
-  followed by the network address. In this case, any source IP matching the
-  network will not cause an addition of this header. Most common uses are with
-  private networks or 127.0.0.1.
-
-  This option may be specified either in the frontend or in the backend. If at
-  least one of them uses it, the header will be added. Note that the backend's
-  setting of the header subargument takes precedence over the frontend's if
-  both are defined.
-
-  It is important to note that by default, HAProxy works in tunnel mode and
-  only inspects the first request of a connection, meaning that only the first
-  request will have the header appended, which is certainly not what you want.
-  In order to fix this, ensure that any of the "httpclose", "forceclose" or
-  "http-server-close" options is set when using this option.
-
-  Examples :
-    # Original Destination address
-    frontend www
-        mode http
-        option originalto except 127.0.0.1
-
-    # Those servers want the IP Address in X-Client-Dst
-    backend www
-        mode http
-        option originalto header X-Client-Dst
-
-  See also : "option httpclose", "option http-server-close",
-             "option forceclose"
-
-
-option persist
-no option persist
-  Enable or disable forced persistence on down servers
-  May be used in sections:    defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments : none
-
-  When an HTTP request reaches a backend with a cookie which references a dead
-  server, by default it is redispatched to another server. It is possible to
-  force the request to be sent to the dead server first using "option persist"
-  if absolutely needed. A common use case is when servers are under extreme
-  load and spend their time flapping. In this case, the users would still be
-  directed to the server they opened the session on, in the hope they would be
-  correctly served. It is recommended to use "option redispatch" in conjunction
-  with this option so that in the event it would not be possible to connect to
-  the server at all (server definitely dead), the client would finally be
-  redirected to another valid server.
-
-  If this option has been enabled in a "defaults" section, it can be disabled
-  in a specific instance by prepending the "no" keyword before it.
-
-  See also : "option redispatch", "retries", "force-persist"
-
-
-option redispatch
-no option redispatch
-  Enable or disable session redistribution in case of connection failure
-  May be used in sections:    defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments : none
-
-  In HTTP mode, if a server designated by a cookie is down, clients may
-  definitely stick to it because they cannot flush the cookie, so they will not
-  be able to access the service anymore.
-
-  Specifying "option redispatch" will allow the proxy to break their
-  persistence and redistribute them to a working server.
-
-  It also allows to retry last connection to another server in case of multiple
-  connection failures. Of course, it requires having "retries" set to a nonzero
-  value.
-
-  This form is the preferred form, which replaces both the "redispatch" and
-  "redisp" keywords.
-
-  If this option has been enabled in a "defaults" section, it can be disabled
-  in a specific instance by prepending the "no" keyword before it.
-
-  See also : "redispatch", "retries", "force-persist"
-
-
-option smtpchk
-option smtpchk <hello> <domain>
-  Use SMTP health checks for server testing
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments :
-    <hello>   is an optional argument. It is the "hello" command to use. It can
-              be either "HELO" (for SMTP) or "EHLO" (for ESTMP). All other
-              values will be turned into the default command ("HELO").
-
-    <domain>  is the domain name to present to the server. It may only be
-              specified (and is mandatory) if the hello command has been
-              specified. By default, "localhost" is used.
-
-  When "option smtpchk" is set, the health checks will consist in TCP
-  connections followed by an SMTP command. By default, this command is
-  "HELO localhost". The server's return code is analyzed and only return codes
-  starting with a "2" will be considered as valid. All other responses,
-  including a lack of response will constitute an error and will indicate a
-  dead server.
-
-  This test is meant to be used with SMTP servers or relays. Depending on the
-  request, it is possible that some servers do not log each connection attempt,
-  so you may want to experiment to improve the behaviour. Using telnet on port
-  25 is often easier than adjusting the configuration.
-
-  Most often, an incoming SMTP server needs to see the client's IP address for
-  various purposes, including spam filtering, anti-spoofing and logging. When
-  possible, it is often wise to masquerade the client's IP address when
-  connecting to the server using the "usesrc" argument of the "source" keyword,
-  which requires the cttproxy feature to be compiled in.
-
-  Example :
-        option smtpchk HELO mydomain.org
-
-  See also : "option httpchk", "source"
-
-
-option socket-stats
-no option socket-stats
-
-  Enable or disable collecting & providing separate statistics for each socket.
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   no
-
-  Arguments : none
-
-
-option splice-auto
-no option splice-auto
-  Enable or disable automatic kernel acceleration on sockets in both directions
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   yes
-  Arguments : none
-
-  When this option is enabled either on a frontend or on a backend, haproxy
-  will automatically evaluate the opportunity to use kernel tcp splicing to
-  forward data between the client and the server, in either direction. Haproxy
-  uses heuristics to estimate if kernel splicing might improve performance or
-  not. Both directions are handled independently. Note that the heuristics used
-  are not much aggressive in order to limit excessive use of splicing. This
-  option requires splicing to be enabled at compile time, and may be globally
-  disabled with the global option "nosplice". Since splice uses pipes, using it
-  requires that there are enough spare pipes.
-
-  Important note: kernel-based TCP splicing is a Linux-specific feature which
-  first appeared in kernel 2.6.25. It offers kernel-based acceleration to
-  transfer data between sockets without copying these data to user-space, thus
-  providing noticeable performance gains and CPU cycles savings. Since many
-  early implementations are buggy, corrupt data and/or are inefficient, this
-  feature is not enabled by default, and it should be used with extreme care.
-  While it is not possible to detect the correctness of an implementation,
-  2.6.29 is the first version offering a properly working implementation. In
-  case of doubt, splicing may be globally disabled using the global "nosplice"
-  keyword.
-
-  Example :
-        option splice-auto
-
-  If this option has been enabled in a "defaults" section, it can be disabled
-  in a specific instance by prepending the "no" keyword before it.
-
-  See also : "option splice-request", "option splice-response", and global
-             options "nosplice" and "maxpipes"
-
-
-option splice-request
-no option splice-request
-  Enable or disable automatic kernel acceleration on sockets for requests
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   yes
-  Arguments : none
-
-  When this option is enabled either on a frontend or on a backend, haproxy
-  will user kernel tcp splicing whenever possible to forward data going from
-  the client to the server. It might still use the recv/send scheme if there
-  are no spare pipes left. This option requires splicing to be enabled at
-  compile time, and may be globally disabled with the global option "nosplice".
-  Since splice uses pipes, using it requires that there are enough spare pipes.
-
-  Important note: see "option splice-auto" for usage limitations.
-
-  Example :
-        option splice-request
-
-  If this option has been enabled in a "defaults" section, it can be disabled
-  in a specific instance by prepending the "no" keyword before it.
-
-  See also : "option splice-auto", "option splice-response", and global options
-             "nosplice" and "maxpipes"
-
-
-option splice-response
-no option splice-response
-  Enable or disable automatic kernel acceleration on sockets for responses
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   yes
-  Arguments : none
-
-  When this option is enabled either on a frontend or on a backend, haproxy
-  will user kernel tcp splicing whenever possible to forward data going from
-  the server to the client. It might still use the recv/send scheme if there
-  are no spare pipes left. This option requires splicing to be enabled at
-  compile time, and may be globally disabled with the global option "nosplice".
-  Since splice uses pipes, using it requires that there are enough spare pipes.
-
-  Important note: see "option splice-auto" for usage limitations.
-
-  Example :
-        option splice-response
-
-  If this option has been enabled in a "defaults" section, it can be disabled
-  in a specific instance by prepending the "no" keyword before it.
-
-  See also : "option splice-auto", "option splice-request", and global options
-             "nosplice" and "maxpipes"
-
-
-option srvtcpka
-no option srvtcpka
-  Enable or disable the sending of TCP keepalive packets on the server side
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments : none
-
-  When there is a firewall or any session-aware component between a client and
-  a server, and when the protocol involves very long sessions with long idle
-  periods (eg: remote desktops), there is a risk that one of the intermediate
-  components decides to expire a session which has remained idle for too long.
-
-  Enabling socket-level TCP keep-alives makes the system regularly send packets
-  to the other end of the connection, leaving it active. The delay between
-  keep-alive probes is controlled by the system only and depends both on the
-  operating system and its tuning parameters.
-
-  It is important to understand that keep-alive packets are neither emitted nor
-  received at the application level. It is only the network stacks which sees
-  them. For this reason, even if one side of the proxy already uses keep-alives
-  to maintain its connection alive, those keep-alive packets will not be
-  forwarded to the other side of the proxy.
-
-  Please note that this has nothing to do with HTTP keep-alive.
-
-  Using option "srvtcpka" enables the emission of TCP keep-alive probes on the
-  server side of a connection, which should help when session expirations are
-  noticed between HAProxy and a server.
-
-  If this option has been enabled in a "defaults" section, it can be disabled
-  in a specific instance by prepending the "no" keyword before it.
-
-  See also : "option clitcpka", "option tcpka"
-
-
-option ssl-hello-chk
-  Use SSLv3 client hello health checks for server testing
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments : none
-
-  When some SSL-based protocols are relayed in TCP mode through HAProxy, it is
-  possible to test that the server correctly talks SSL instead of just testing
-  that it accepts the TCP connection. When "option ssl-hello-chk" is set, pure
-  SSLv3 client hello messages are sent once the connection is established to
-  the server, and the response is analyzed to find an SSL server hello message.
-  The server is considered valid only when the response contains this server
-  hello message.
-
-  All servers tested till there correctly reply to SSLv3 client hello messages,
-  and most servers tested do not even log the requests containing only hello
-  messages, which is appreciable.
-
-  See also: "option httpchk"
-
-
-option tcp-smart-accept
-no option tcp-smart-accept
-  Enable or disable the saving of one ACK packet during the accept sequence
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |    no
-  Arguments : none
-
-  When an HTTP connection request comes in, the system acknowledges it on
-  behalf of HAProxy, then the client immediately sends its request, and the
-  system acknowledges it too while it is notifying HAProxy about the new
-  connection. HAProxy then reads the request and responds. This means that we
-  have one TCP ACK sent by the system for nothing, because the request could
-  very well be acknowledged by HAProxy when it sends its response.
-
-  For this reason, in HTTP mode, HAProxy automatically asks the system to avoid
-  sending this useless ACK on platforms which support it (currently at least
-  Linux). It must not cause any problem, because the system will send it anyway
-  after 40 ms if the response takes more time than expected to come.
-
-  During complex network debugging sessions, it may be desirable to disable
-  this optimization because delayed ACKs can make troubleshooting more complex
-  when trying to identify where packets are delayed. It is then possible to
-  fall back to normal behaviour by specifying "no option tcp-smart-accept".
-
-  It is also possible to force it for non-HTTP proxies by simply specifying
-  "option tcp-smart-accept". For instance, it can make sense with some services
-  such as SMTP where the server speaks first.
-
-  It is recommended to avoid forcing this option in a defaults section. In case
-  of doubt, consider setting it back to automatic values by prepending the
-  "default" keyword before it, or disabling it using the "no" keyword.
-
-  See also : "option tcp-smart-connect"
-
-
-option tcp-smart-connect
-no option tcp-smart-connect
-  Enable or disable the saving of one ACK packet during the connect sequence
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments : none
-
-  On certain systems (at least Linux), HAProxy can ask the kernel not to
-  immediately send an empty ACK upon a connection request, but to directly
-  send the buffer request instead. This saves one packet on the network and
-  thus boosts performance. It can also be useful for some servers, because they
-  immediately get the request along with the incoming connection.
-
-  This feature is enabled when "option tcp-smart-connect" is set in a backend.
-  It is not enabled by default because it makes network troubleshooting more
-  complex.
-
-  It only makes sense to enable it with protocols where the client speaks first
-  such as HTTP. In other situations, if there is no data to send in place of
-  the ACK, a normal ACK is sent.
-
-  If this option has been enabled in a "defaults" section, it can be disabled
-  in a specific instance by prepending the "no" keyword before it.
-
-  See also : "option tcp-smart-accept"
-
-
-option tcpka
-  Enable or disable the sending of TCP keepalive packets on both sides
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   yes
-  Arguments : none
-
-  When there is a firewall or any session-aware component between a client and
-  a server, and when the protocol involves very long sessions with long idle
-  periods (eg: remote desktops), there is a risk that one of the intermediate
-  components decides to expire a session which has remained idle for too long.
-
-  Enabling socket-level TCP keep-alives makes the system regularly send packets
-  to the other end of the connection, leaving it active. The delay between
-  keep-alive probes is controlled by the system only and depends both on the
-  operating system and its tuning parameters.
-
-  It is important to understand that keep-alive packets are neither emitted nor
-  received at the application level. It is only the network stacks which sees
-  them. For this reason, even if one side of the proxy already uses keep-alives
-  to maintain its connection alive, those keep-alive packets will not be
-  forwarded to the other side of the proxy.
-
-  Please note that this has nothing to do with HTTP keep-alive.
-
-  Using option "tcpka" enables the emission of TCP keep-alive probes on both
-  the client and server sides of a connection. Note that this is meaningful
-  only in "defaults" or "listen" sections. If this option is used in a
-  frontend, only the client side will get keep-alives, and if this option is
-  used in a backend, only the server side will get keep-alives. For this
-  reason, it is strongly recommended to explicitly use "option clitcpka" and
-  "option srvtcpka" when the configuration is split between frontends and
-  backends.
-
-  See also : "option clitcpka", "option srvtcpka"
-
-
-option tcplog
-  Enable advanced logging of TCP connections with session state and timers
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   yes
-  Arguments : none
-
-  By default, the log output format is very poor, as it only contains the
-  source and destination addresses, and the instance name. By specifying
-  "option tcplog", each log line turns into a much richer format including, but
-  not limited to, the connection timers, the session status, the connections
-  numbers, the frontend, backend and server name, and of course the source
-  address and ports. This option is useful for pure TCP proxies in order to
-  find which of the client or server disconnects or times out. For normal HTTP
-  proxies, it's better to use "option httplog" which is even more complete.
-
-  This option may be set either in the frontend or the backend.
-
-  See also :  "option httplog", and section 8 about logging.
-
-
-option transparent
-no option transparent
-  Enable client-side transparent proxying
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments : none
-
-  This option was introduced in order to provide layer 7 persistence to layer 3
-  load balancers. The idea is to use the OS's ability to redirect an incoming
-  connection for a remote address to a local process (here HAProxy), and let
-  this process know what address was initially requested. When this option is
-  used, sessions without cookies will be forwarded to the original destination
-  IP address of the incoming request (which should match that of another
-  equipment), while requests with cookies will still be forwarded to the
-  appropriate server.
-
-  Note that contrary to a common belief, this option does NOT make HAProxy
-  present the client's IP to the server when establishing the connection.
-
-  See also: the "usesrc" argument of the "source" keyword, and the
-            "transparent" option of the "bind" keyword.
-
-
-persist rdp-cookie
-persist rdp-cookie(name)
-  Enable RDP cookie-based persistence
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments :
-    <name>    is the optional name of the RDP cookie to check. If omitted, the
-              default cookie name "msts" will be used. There currently is no
-              valid reason to change this name.
-
-  This statement enables persistence based on an RDP cookie. The RDP cookie
-  contains all information required to find the server in the list of known
-  servers. So when this option is set in the backend, the request is analysed
-  and if an RDP cookie is found, it is decoded. If it matches a known server
-  which is still UP (or if "option persist" is set), then the connection is
-  forwarded to this server.
-
-  Note that this only makes sense in a TCP backend, but for this to work, the
-  frontend must have waited long enough to ensure that an RDP cookie is present
-  in the request buffer. This is the same requirement as with the "rdp-cookie"
-  load-balancing method. Thus it is highly recommended to put all statements in
-  a single "listen" section.
-
-  Also, it is important to understand that the terminal server will emit this
-  RDP cookie only if it is configured for "token redirection mode", which means
-  that the "IP address redirection" option is disabled.
-
-  Example :
-        listen tse-farm
-            bind :3389
-            # wait up to 5s for an RDP cookie in the request
-            tcp-request inspect-delay 5s
-            tcp-request content accept if RDP_COOKIE
-            # apply RDP cookie persistence
-            persist rdp-cookie
-            # if server is unknown, let's balance on the same cookie.
-            # alternatively, "balance leastconn" may be useful too.
-            balance rdp-cookie
-            server srv1 1.1.1.1:3389
-            server srv2 1.1.1.2:3389
-
-  See also : "balance rdp-cookie", "tcp-request" and the "req_rdp_cookie" ACL.
-
-
-rate-limit sessions <rate>
-  Set a limit on the number of new sessions accepted per second on a frontend
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   no
-  Arguments :
-    <rate>    The <rate> parameter is an integer designating the maximum number
-              of new sessions per second to accept on the frontend.
-
-  When the frontend reaches the specified number of new sessions per second, it
-  stops accepting new connections until the rate drops below the limit again.
-  During this time, the pending sessions will be kept in the socket's backlog
-  (in system buffers) and haproxy will not even be aware that sessions are
-  pending. When applying very low limit on a highly loaded service, it may make
-  sense to increase the socket's backlog using the "backlog" keyword.
-
-  This feature is particularly efficient at blocking connection-based attacks
-  or service abuse on fragile servers. Since the session rate is measured every
-  millisecond, it is extremely accurate. Also, the limit applies immediately,
-  no delay is needed at all to detect the threshold.
-
-  Example : limit the connection rate on SMTP to 10 per second max
-        listen smtp
-            mode tcp
-            bind :25
-            rate-limit sessions 10
-            server 127.0.0.1:1025
-
-  Note : when the maximum rate is reached, the frontend's status appears as
-         "FULL" in the statistics, exactly as when it is saturated.
-
-  See also : the "backlog" keyword and the "fe_sess_rate" ACL criterion.
-
-
-redirect location <to> [code <code>] <option> [{if | unless} <condition>]
-redirect prefix   <to> [code <code>] <option> [{if | unless} <condition>]
-  Return an HTTP redirection if/unless a condition is matched
-  May be used in sections :   defaults | frontend | listen | backend
-                                 no    |    yes   |   yes  |   yes
-
-  If/unless the condition is matched, the HTTP request will lead to a redirect
-  response. If no condition is specified, the redirect applies unconditionally.
-
-  Arguments :
-    <to>      With "redirect location", the exact value in <to> is placed into
-              the HTTP "Location" header. In case of "redirect prefix", the
-              "Location" header is built from the concatenation of <to> and the
-              complete URI, including the query string, unless the "drop-query"
-              option is specified (see below). As a special case, if <to>
-              equals exactly "/" in prefix mode, then nothing is inserted
-              before the original URI. It allows one to redirect to the same
-              URL.
-
-    <code>    The code is optional. It indicates which type of HTTP redirection
-              is desired. Only codes 301, 302 and 303 are supported, and 302 is
-              used if no code is specified. 301 means "Moved permanently", and
-              a browser may cache the Location. 302 means "Moved permanently"
-              and means that the browser should not cache the redirection. 303
-              is equivalent to 302 except that the browser will fetch the
-              location with a GET method.
-
-    <option>  There are several options which can be specified to adjust the
-              expected behaviour of a redirection :
-
-      - "drop-query"
-        When this keyword is used in a prefix-based redirection, then the
-        location will be set without any possible query-string, which is useful
-        for directing users to a non-secure page for instance. It has no effect
-        with a location-type redirect.
-
-      - "append-slash"
-        This keyword may be used in conjunction with "drop-query" to redirect
-        users who use a URL not ending with a '/' to the same one with the '/'.
-        It can be useful to ensure that search engines will only see one URL.
-        For this, a return code 301 is preferred.
-
-      - "set-cookie NAME[=value]"
-        A "Set-Cookie" header will be added with NAME (and optionally "=value")
-        to the response. This is sometimes used to indicate that a user has
-        been seen, for instance to protect against some types of DoS. No other
-        cookie option is added, so the cookie will be a session cookie. Note
-        that for a browser, a sole cookie name without an equal sign is
-        different from a cookie with an equal sign.
-
-      - "clear-cookie NAME[=]"
-        A "Set-Cookie" header will be added with NAME (and optionally "="), but
-        with the "Max-Age" attribute set to zero. This will tell the browser to
-        delete this cookie. It is useful for instance on logout pages. It is
-        important to note that clearing the cookie "NAME" will not remove a
-        cookie set with "NAME=value". You have to clear the cookie "NAME=" for
-        that, because the browser makes the difference.
-
-  Example: move the login URL only to HTTPS.
-        acl clear      dst_port  80
-        acl secure     dst_port  8080
-        acl login_page url_beg   /login
-        acl logout     url_beg   /logout
-        acl uid_given  url_reg   /login?userid=[^&]+
-        acl cookie_set hdr_sub(cookie) SEEN=1
-
-        redirect prefix   https://mysite.com set-cookie SEEN=1 if !cookie_set
-        redirect prefix   https://mysite.com           if login_page !secure
-        redirect prefix   http://mysite.com drop-query if login_page !uid_given
-        redirect location http://mysite.com/           if !login_page secure
-        redirect location / clear-cookie USERID=       if logout
-
-  Example: send redirects for request for articles without a '/'.
-        acl missing_slash path_reg ^/article/[^/]*$
-        redirect code 301 prefix / drop-query append-slash if missing_slash
-
-  See section 7 about ACL usage.
-
-
-redisp (deprecated)
-redispatch (deprecated)
-  Enable or disable session redistribution in case of connection failure
-  May be used in sections:    defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments : none
-
-  In HTTP mode, if a server designated by a cookie is down, clients may
-  definitely stick to it because they cannot flush the cookie, so they will not
-  be able to access the service anymore.
-
-  Specifying "redispatch" will allow the proxy to break their persistence and
-  redistribute them to a working server.
-
-  It also allows to retry last connection to another server in case of multiple
-  connection failures. Of course, it requires having "retries" set to a nonzero
-  value.
-
-  This form is deprecated, do not use it in any new configuration, use the new
-  "option redispatch" instead.
-
-  See also : "option redispatch"
-
-
-reqadd  <string> [{if | unless} <cond>]
-  Add a header at the end of the HTTP request
-  May be used in sections :   defaults | frontend | listen | backend
-                                 no    |    yes   |   yes  |   yes
-  Arguments :
-    <string>  is the complete line to be added. Any space or known delimiter
-              must be escaped using a backslash ('\'). Please refer to section
-              6 about HTTP header manipulation for more information.
-
-    <cond>    is an optional matching condition built from ACLs. It makes it
-              possible to ignore this rule when other conditions are not met.
-
-  A new line consisting in <string> followed by a line feed will be added after
-  the last header of an HTTP request.
-
-  Header transformations only apply to traffic which passes through HAProxy,
-  and not to traffic generated by HAProxy, such as health-checks or error
-  responses.
-
-  Example : add "X-Proto: SSL" to requests coming via port 81
-     acl is-ssl  dst_port       81
-     reqadd      X-Proto:\ SSL  if is-ssl
-
-  See also: "rspadd", section 6 about HTTP header manipulation, and section 7
-            about ACLs.
-
-
-reqallow  <search> [{if | unless} <cond>]
-reqiallow <search> [{if | unless} <cond>] (ignore case)
-  Definitely allow an HTTP request if a line matches a regular expression
-  May be used in sections :   defaults | frontend | listen | backend
-                                 no    |    yes   |   yes  |   yes
-  Arguments :
-    <search>  is the regular expression applied to HTTP headers and to the
-              request line. This is an extended regular expression. Parenthesis
-              grouping is supported and no preliminary backslash is required.
-              Any space or known delimiter must be escaped using a backslash
-              ('\'). The pattern applies to a full line at a time. The
-              "reqallow" keyword strictly matches case while "reqiallow"
-              ignores case.
-
-    <cond>    is an optional matching condition built from ACLs. It makes it
-              possible to ignore this rule when other conditions are not met.
-
-  A request containing any line which matches extended regular expression
-  <search> will mark the request as allowed, even if any later test would
-  result in a deny. The test applies both to the request line and to request
-  headers. Keep in mind that URLs in request line are case-sensitive while
-  header names are not.
-
-  It is easier, faster and more powerful to use ACLs to write access policies.
-  Reqdeny, reqallow and reqpass should be avoided in new designs.
-
-  Example :
-     # allow www.* but refuse *.local
-     reqiallow ^Host:\ www\.
-     reqideny  ^Host:\ .*\.local
-
-  See also: "reqdeny", "block", section 6 about HTTP header manipulation, and
-            section 7 about ACLs.
-
-
-reqdel  <search> [{if | unless} <cond>]
-reqidel <search> [{if | unless} <cond>]  (ignore case)
-  Delete all headers matching a regular expression in an HTTP request
-  May be used in sections :   defaults | frontend | listen | backend
-                                 no    |    yes   |   yes  |   yes
-  Arguments :
-    <search>  is the regular expression applied to HTTP headers and to the
-              request line. This is an extended regular expression. Parenthesis
-              grouping is supported and no preliminary backslash is required.
-              Any space or known delimiter must be escaped using a backslash
-              ('\'). The pattern applies to a full line at a time. The "reqdel"
-              keyword strictly matches case while "reqidel" ignores case.
-
-    <cond>    is an optional matching condition built from ACLs. It makes it
-              possible to ignore this rule when other conditions are not met.
-
-  Any header line matching extended regular expression <search> in the request
-  will be completely deleted. Most common use of this is to remove unwanted
-  and/or dangerous headers or cookies from a request before passing it to the
-  next servers.
-
-  Header transformations only apply to traffic which passes through HAProxy,
-  and not to traffic generated by HAProxy, such as health-checks or error
-  responses. Keep in mind that header names are not case-sensitive.
-
-  Example :
-     # remove X-Forwarded-For header and SERVER cookie
-     reqidel ^X-Forwarded-For:.*
-     reqidel ^Cookie:.*SERVER=
-
-  See also: "reqadd", "reqrep", "rspdel", section 6 about HTTP header
-            manipulation, and section 7 about ACLs.
-
-
-reqdeny  <search> [{if | unless} <cond>]
-reqideny <search> [{if | unless} <cond>]  (ignore case)
-  Deny an HTTP request if a line matches a regular expression
-  May be used in sections :   defaults | frontend | listen | backend
-                                 no    |    yes   |   yes  |   yes
-  Arguments :
-    <search>  is the regular expression applied to HTTP headers and to the
-              request line. This is an extended regular expression. Parenthesis
-              grouping is supported and no preliminary backslash is required.
-              Any space or known delimiter must be escaped using a backslash
-              ('\'). The pattern applies to a full line at a time. The
-              "reqdeny" keyword strictly matches case while "reqideny" ignores
-              case.
-
-    <cond>    is an optional matching condition built from ACLs. It makes it
-              possible to ignore this rule when other conditions are not met.
-
-  A request containing any line which matches extended regular expression
-  <search> will mark the request as denied, even if any later test would
-  result in an allow. The test applies both to the request line and to request
-  headers. Keep in mind that URLs in request line are case-sensitive while
-  header names are not.
-
-  A denied request will generate an "HTTP 403 forbidden" response once the
-  complete request has been parsed. This is consistent with what is practiced
-  using ACLs.
-
-  It is easier, faster and more powerful to use ACLs to write access policies.
-  Reqdeny, reqallow and reqpass should be avoided in new designs.
-
-  Example :
-     # refuse *.local, then allow www.*
-     reqideny  ^Host:\ .*\.local
-     reqiallow ^Host:\ www\.
-
-  See also: "reqallow", "rspdeny", "block", section 6 about HTTP header
-            manipulation, and section 7 about ACLs.
-
-
-reqpass  <search> [{if | unless} <cond>]
-reqipass <search> [{if | unless} <cond>]  (ignore case)
-  Ignore any HTTP request line matching a regular expression in next rules
-  May be used in sections :   defaults | frontend | listen | backend
-                                 no    |    yes   |   yes  |   yes
-  Arguments :
-    <search>  is the regular expression applied to HTTP headers and to the
-              request line. This is an extended regular expression. Parenthesis
-              grouping is supported and no preliminary backslash is required.
-              Any space or known delimiter must be escaped using a backslash
-              ('\'). The pattern applies to a full line at a time. The
-              "reqpass" keyword strictly matches case while "reqipass" ignores
-              case.
-
-    <cond>    is an optional matching condition built from ACLs. It makes it
-              possible to ignore this rule when other conditions are not met.
-
-  A request containing any line which matches extended regular expression
-  <search> will skip next rules, without assigning any deny or allow verdict.
-  The test applies both to the request line and to request headers. Keep in
-  mind that URLs in request line are case-sensitive while header names are not.
-
-  It is easier, faster and more powerful to use ACLs to write access policies.
-  Reqdeny, reqallow and reqpass should be avoided in new designs.
-
-  Example :
-     # refuse *.local, then allow www.*, but ignore "www.private.local"
-     reqipass  ^Host:\ www.private\.local
-     reqideny  ^Host:\ .*\.local
-     reqiallow ^Host:\ www\.
-
-  See also: "reqallow", "reqdeny", "block", section 6 about HTTP header
-            manipulation, and section 7 about ACLs.
-
-
-reqrep  <search> <string> [{if | unless} <cond>]
-reqirep <search> <string> [{if | unless} <cond>]   (ignore case)
-  Replace a regular expression with a string in an HTTP request line
-  May be used in sections :   defaults | frontend | listen | backend
-                                 no    |    yes   |   yes  |   yes
-  Arguments :
-    <search>  is the regular expression applied to HTTP headers and to the
-              request line. This is an extended regular expression. Parenthesis
-              grouping is supported and no preliminary backslash is required.
-              Any space or known delimiter must be escaped using a backslash
-              ('\'). The pattern applies to a full line at a time. The "reqrep"
-              keyword strictly matches case while "reqirep" ignores case.
-
-    <string>  is the complete line to be added. Any space or known delimiter
-              must be escaped using a backslash ('\'). References to matched
-              pattern groups are possible using the common \N form, with N
-              being a single digit between 0 and 9. Please refer to section
-              6 about HTTP header manipulation for more information.
-
-    <cond>    is an optional matching condition built from ACLs. It makes it
-              possible to ignore this rule when other conditions are not met.
-
-  Any line matching extended regular expression <search> in the request (both
-  the request line and header lines) will be completely replaced with <string>.
-  Most common use of this is to rewrite URLs or domain names in "Host" headers.
-
-  Header transformations only apply to traffic which passes through HAProxy,
-  and not to traffic generated by HAProxy, such as health-checks or error
-  responses. Note that for increased readability, it is suggested to add enough
-  spaces between the request and the response. Keep in mind that URLs in
-  request line are case-sensitive while header names are not.
-
-  Example :
-     # replace "/static/" with "/" at the beginning of any request path.
-     reqrep ^([^\ :]*)\ /static/(.*)     \1\ /\2
-     # replace "www.mydomain.com" with "www" in the host name.
-     reqirep ^Host:\ www.mydomain.com   Host:\ www
-
-  See also: "reqadd", "reqdel", "rsprep", section 6 about HTTP header
-            manipulation, and section 7 about ACLs.
-
-
-reqtarpit  <search> [{if | unless} <cond>]
-reqitarpit <search> [{if | unless} <cond>]  (ignore case)
-  Tarpit an HTTP request containing a line matching a regular expression
-  May be used in sections :   defaults | frontend | listen | backend
-                                 no    |    yes   |   yes  |   yes
-  Arguments :
-    <search>  is the regular expression applied to HTTP headers and to the
-              request line. This is an extended regular expression. Parenthesis
-              grouping is supported and no preliminary backslash is required.
-              Any space or known delimiter must be escaped using a backslash
-              ('\'). The pattern applies to a full line at a time. The
-              "reqtarpit" keyword strictly matches case while "reqitarpit"
-              ignores case.
-
-    <cond>    is an optional matching condition built from ACLs. It makes it
-              possible to ignore this rule when other conditions are not met.
-
-  A request containing any line which matches extended regular expression
-  <search> will be tarpitted, which means that it will connect to nowhere, will
-  be kept open for a pre-defined time, then will return an HTTP error 500 so
-  that the attacker does not suspect it has been tarpitted. The status 500 will
-  be reported in the logs, but the completion flags will indicate "PT". The
-  delay is defined by "timeout tarpit", or "timeout connect" if the former is
-  not set.
-
-  The goal of the tarpit is to slow down robots attacking servers with
-  identifiable requests. Many robots limit their outgoing number of connections
-  and stay connected waiting for a reply which can take several minutes to
-  come. Depending on the environment and attack, it may be particularly
-  efficient at reducing the load on the network and firewalls.
-
-  Examples :
-     # ignore user-agents reporting any flavour of "Mozilla" or "MSIE", but
-     # block all others.
-     reqipass   ^User-Agent:\.*(Mozilla|MSIE)
-     reqitarpit ^User-Agent:
-
-     # block bad guys
-     acl badguys src 10.1.0.3 172.16.13.20/28
-     reqitarpit . if badguys
-
-  See also: "reqallow", "reqdeny", "reqpass", section 6 about HTTP header
-            manipulation, and section 7 about ACLs.
-
-
-retries <value>
-  Set the number of retries to perform on a server after a connection failure
-  May be used in sections:    defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments :
-    <value>   is the number of times a connection attempt should be retried on
-              a server when a connection either is refused or times out. The
-              default value is 3.
-
-  It is important to understand that this value applies to the number of
-  connection attempts, not full requests. When a connection has effectively
-  been established to a server, there will be no more retry.
-
-  In order to avoid immediate reconnections to a server which is restarting,
-  a turn-around timer of 1 second is applied before a retry occurs.
-
-  When "option redispatch" is set, the last retry may be performed on another
-  server even if a cookie references a different server.
-
-  See also : "option redispatch"
-
-
-rspadd <string> [{if | unless} <cond>]
-  Add a header at the end of the HTTP response
-  May be used in sections :   defaults | frontend | listen | backend
-                                 no    |    yes   |   yes  |   yes
-  Arguments :
-    <string>  is the complete line to be added. Any space or known delimiter
-              must be escaped using a backslash ('\'). Please refer to section
-              6 about HTTP header manipulation for more information.
-
-    <cond>    is an optional matching condition built from ACLs. It makes it
-              possible to ignore this rule when other conditions are not met.
-
-  A new line consisting in <string> followed by a line feed will be added after
-  the last header of an HTTP response.
-
-  Header transformations only apply to traffic which passes through HAProxy,
-  and not to traffic generated by HAProxy, such as health-checks or error
-  responses.
-
-  See also: "reqadd", section 6 about HTTP header manipulation, and section 7
-            about ACLs.
-
-
-rspdel  <search> [{if | unless} <cond>]
-rspidel <search> [{if | unless} <cond>]  (ignore case)
-  Delete all headers matching a regular expression in an HTTP response
-  May be used in sections :   defaults | frontend | listen | backend
-                                 no    |    yes   |   yes  |   yes
-  Arguments :
-    <search>  is the regular expression applied to HTTP headers and to the
-              response line. This is an extended regular expression, so
-              parenthesis grouping is supported and no preliminary backslash
-              is required. Any space or known delimiter must be escaped using
-              a backslash ('\'). The pattern applies to a full line at a time.
-              The "rspdel" keyword strictly matches case while "rspidel"
-              ignores case.
-
-    <cond>    is an optional matching condition built from ACLs. It makes it
-              possible to ignore this rule when other conditions are not met.
-
-  Any header line matching extended regular expression <search> in the response
-  will be completely deleted. Most common use of this is to remove unwanted
-  and/or sensitive headers or cookies from a response before passing it to the
-  client.
-
-  Header transformations only apply to traffic which passes through HAProxy,
-  and not to traffic generated by HAProxy, such as health-checks or error
-  responses. Keep in mind that header names are not case-sensitive.
-
-  Example :
-     # remove the Server header from responses
-     reqidel ^Server:.*
-
-  See also: "rspadd", "rsprep", "reqdel", section 6 about HTTP header
-            manipulation, and section 7 about ACLs.
-
-
-rspdeny  <search> [{if | unless} <cond>]
-rspideny <search> [{if | unless} <cond>]  (ignore case)
-  Block an HTTP response if a line matches a regular expression
-  May be used in sections :   defaults | frontend | listen | backend
-                                 no    |    yes   |   yes  |   yes
-  Arguments :
-    <search>  is the regular expression applied to HTTP headers and to the
-              response line. This is an extended regular expression, so
-              parenthesis grouping is supported and no preliminary backslash
-              is required. Any space or known delimiter must be escaped using
-              a backslash ('\'). The pattern applies to a full line at a time.
-              The "rspdeny" keyword strictly matches case while "rspideny"
-              ignores case.
-
-    <cond>    is an optional matching condition built from ACLs. It makes it
-              possible to ignore this rule when other conditions are not met.
-
-  A response containing any line which matches extended regular expression
-  <search> will mark the request as denied. The test applies both to the
-  response line and to response headers. Keep in mind that header names are not
-  case-sensitive.
-
-  Main use of this keyword is to prevent sensitive information leak and to
-  block the response before it reaches the client. If a response is denied, it
-  will be replaced with an HTTP 502 error so that the client never retrieves
-  any sensitive data.
-
-  It is easier, faster and more powerful to use ACLs to write access policies.
-  Rspdeny should be avoided in new designs.
-
-  Example :
-     # Ensure that no content type matching ms-word will leak
-     rspideny  ^Content-type:\.*/ms-word
-
-  See also: "reqdeny", "acl", "block", section 6 about HTTP header manipulation
-            and section 7 about ACLs.
-
-
-rsprep  <search> <string> [{if | unless} <cond>]
-rspirep <search> <string> [{if | unless} <cond>]  (ignore case)
-  Replace a regular expression with a string in an HTTP response line
-  May be used in sections :   defaults | frontend | listen | backend
-                                 no    |    yes   |   yes  |   yes
-  Arguments :
-    <search>  is the regular expression applied to HTTP headers and to the
-              response line. This is an extended regular expression, so
-              parenthesis grouping is supported and no preliminary backslash
-              is required. Any space or known delimiter must be escaped using
-              a backslash ('\'). The pattern applies to a full line at a time.
-              The "rsprep" keyword strictly matches case while "rspirep"
-              ignores case.
-
-    <string>  is the complete line to be added. Any space or known delimiter
-              must be escaped using a backslash ('\'). References to matched
-              pattern groups are possible using the common \N form, with N
-              being a single digit between 0 and 9. Please refer to section
-              6 about HTTP header manipulation for more information.
-
-    <cond>    is an optional matching condition built from ACLs. It makes it
-              possible to ignore this rule when other conditions are not met.
-
-  Any line matching extended regular expression <search> in the response (both
-  the response line and header lines) will be completely replaced with
-  <string>. Most common use of this is to rewrite Location headers.
-
-  Header transformations only apply to traffic which passes through HAProxy,
-  and not to traffic generated by HAProxy, such as health-checks or error
-  responses. Note that for increased readability, it is suggested to add enough
-  spaces between the request and the response. Keep in mind that header names
-  are not case-sensitive.
-
-  Example :
-     # replace "Location: 127.0.0.1:8080" with "Location: www.mydomain.com"
-     rspirep ^Location:\ 127.0.0.1:8080    Location:\ www.mydomain.com
-
-  See also: "rspadd", "rspdel", "reqrep", section 6 about HTTP header
-            manipulation, and section 7 about ACLs.
-
-
-server <name> <address>[:port] [param*]
-  Declare a server in a backend
-  May be used in sections :   defaults | frontend | listen | backend
-                                 no    |    no    |   yes  |   yes
-  Arguments :
-    <name>    is the internal name assigned to this server. This name will
-              appear in logs and alerts.  If "http-send-server-name" is
-              set, it will be added to the request header sent to the server.
-
-    <address> is the IPv4 address of the server. Alternatively, a resolvable
-              hostname is supported, but this name will be resolved during
-              start-up. If no address is specified in front of the port, or if
-              address "0.0.0.0" is specified, then the address used will be the
-              same as the one used by the incoming connection. This makes it
-              possible to relay connections for many IPs on a different port or
-              to perform transparent forwarding with connection limitation.
-
-    <ports>   is an optional port specification. If set, all connections will
-              be sent to this port. If unset, the same port the client
-              connected to will be used. The port may also be prefixed by a "+"
-              or a "-". In this case, the server's port will be determined by
-              adding this value to the client's port.
-
-    <param*>  is a list of parameters for this server. The "server" keywords
-              accepts an important number of options and has a complete section
-              dedicated to it. Please refer to section 5 for more details.
-
-  Examples :
-        server first  10.1.1.1:1080 cookie first  check inter 1000
-        server second 10.1.1.2:1080 cookie second check inter 1000
-
-  See also: "default-server", "http-send-name-header" and section 5 about
-             server options
-
-
-source <addr>[:<port>] [usesrc { <addr2>[:<port2>] | client | clientip } ]
-source <addr>[:<port>] [usesrc { <addr2>[:<port2>] | hdr_ip(<hdr>[,<occ>]) } ]
-source <addr>[:<port>] [interface <name>]
-  Set the source address for outgoing connections
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments :
-    <addr>    is the IPv4 address HAProxy will bind to before connecting to a
-              server. This address is also used as a source for health checks.
-              The default value of 0.0.0.0 means that the system will select
-              the most appropriate address to reach its destination.
-
-    <port>    is an optional port. It is normally not needed but may be useful
-              in some very specific contexts. The default value of zero means
-              the system will select a free port. Note that port ranges are not
-              supported in the backend. If you want to force port ranges, you
-              have to specify them on each "server" line.
-
-    <addr2>   is the IP address to present to the server when connections are
-              forwarded in full transparent proxy mode. This is currently only
-              supported on some patched Linux kernels. When this address is
-              specified, clients connecting to the server will be presented
-              with this address, while health checks will still use the address
-              <addr>.
-
-    <port2>   is the optional port to present to the server when connections
-              are forwarded in full transparent proxy mode (see <addr2> above).
-              The default value of zero means the system will select a free
-              port.
-
-    <hdr>     is the name of a HTTP header in which to fetch the IP to bind to.
-              This is the name of a comma-separated header list which can
-              contain multiple IP addresses. By default, the last occurrence is
-              used. This is designed to work with the X-Forwarded-For header
-              and to automatically bind to the the client's IP address as seen
-              by previous proxy, typically Stunnel. In order to use another
-              occurrence from the last one, please see the <occ> parameter
-              below. When the header (or occurrence) is not found, no binding
-              is performed so that the proxy's default IP address is used. Also
-              keep in mind that the header name is case insensitive, as for any
-              HTTP header.
-
-    <occ>     is the occurrence number of a value to be used in a multi-value
-              header. This is to be used in conjunction with "hdr_ip(<hdr>)",
-              in order to specificy which occurrence to use for the source IP
-              address. Positive values indicate a position from the first
-              occurrence, 1 being the first one. Negative values indicate
-              positions relative to the last one, -1 being the last one. This
-              is helpful for situations where an X-Forwarded-For header is set
-              at the entry point of an infrastructure and must be used several
-              proxy layers away. When this value is not specified, -1 is
-              assumed. Passing a zero here disables the feature.
-
-    <name>    is an optional interface name to which to bind to for outgoing
-              traffic. On systems supporting this features (currently, only
-              Linux), this allows one to bind all traffic to the server to
-              this interface even if it is not the one the system would select
-              based on routing tables. This should be used with extreme care.
-              Note that using this option requires root privileges.
-
-  The "source" keyword is useful in complex environments where a specific
-  address only is allowed to connect to the servers. It may be needed when a
-  private address must be used through a public gateway for instance, and it is
-  known that the system cannot determine the adequate source address by itself.
-
-  An extension which is available on certain patched Linux kernels may be used
-  through the "usesrc" optional keyword. It makes it possible to connect to the
-  servers with an IP address which does not belong to the system itself. This
-  is called "full transparent proxy mode". For this to work, the destination
-  servers have to route their traffic back to this address through the machine
-  running HAProxy, and IP forwarding must generally be enabled on this machine.
-
-  In this "full transparent proxy" mode, it is possible to force a specific IP
-  address to be presented to the servers. This is not much used in fact. A more
-  common use is to tell HAProxy to present the client's IP address. For this,
-  there are two methods :
-
-    - present the client's IP and port addresses. This is the most transparent
-      mode, but it can cause problems when IP connection tracking is enabled on
-      the machine, because a same connection may be seen twice with different
-      states. However, this solution presents the huge advantage of not
-      limiting the system to the 64k outgoing address+port couples, because all
-      of the client ranges may be used.
-
-    - present only the client's IP address and select a spare port. This
-      solution is still quite elegant but slightly less transparent (downstream
-      firewalls logs will not match upstream's). It also presents the downside
-      of limiting the number of concurrent connections to the usual 64k ports.
-      However, since the upstream and downstream ports are different, local IP
-      connection tracking on the machine will not be upset by the reuse of the
-      same session.
-
-  Note that depending on the transparent proxy technology used, it may be
-  required to force the source address. In fact, cttproxy version 2 requires an
-  IP address in <addr> above, and does not support setting of "0.0.0.0" as the
-  IP address because it creates NAT entries which much match the exact outgoing
-  address. Tproxy version 4 and some other kernel patches which work in pure
-  forwarding mode generally will not have this limitation.
-
-  This option sets the default source for all servers in the backend. It may
-  also be specified in a "defaults" section. Finer source address specification
-  is possible at the server level using the "source" server option. Refer to
-  section 5 for more information.
-
-  Examples :
-        backend private
-            # Connect to the servers using our 192.168.1.200 source address
-            source 192.168.1.200
-
-        backend transparent_ssl1
-            # Connect to the SSL farm from the client's source address
-            source 192.168.1.200 usesrc clientip
-
-        backend transparent_ssl2
-            # Connect to the SSL farm from the client's source address and port
-            # not recommended if IP conntrack is present on the local machine.
-            source 192.168.1.200 usesrc client
-
-        backend transparent_ssl3
-            # Connect to the SSL farm from the client's source address. It
-            # is more conntrack-friendly.
-            source 192.168.1.200 usesrc clientip
-
-        backend transparent_smtp
-            # Connect to the SMTP farm from the client's source address/port
-            # with Tproxy version 4.
-            source 0.0.0.0 usesrc clientip
-
-        backend transparent_http
-            # Connect to the servers using the client's IP as seen by previous
-            # proxy.
-            source 0.0.0.0 usesrc hdr_ip(x-forwarded-for,-1)
-
-  See also : the "source" server option in section 5, the Tproxy patches for
-             the Linux kernel on www.balabit.com, the "bind" keyword.
-
-
-srvtimeout <timeout> (deprecated)
-  Set the maximum inactivity time on the server side.
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments :
-    <timeout> is the timeout value specified in milliseconds by default, but
-              can be in any other unit if the number is suffixed by the unit,
-              as explained at the top of this document.
-
-  The inactivity timeout applies when the server is expected to acknowledge or
-  send data. In HTTP mode, this timeout is particularly important to consider
-  during the first phase of the server's response, when it has to send the
-  headers, as it directly represents the server's processing time for the
-  request. To find out what value to put there, it's often good to start with
-  what would be considered as unacceptable response times, then check the logs
-  to observe the response time distribution, and adjust the value accordingly.
-
-  The value is specified in milliseconds by default, but can be in any other
-  unit if the number is suffixed by the unit, as specified at the top of this
-  document. In TCP mode (and to a lesser extent, in HTTP mode), it is highly
-  recommended that the client timeout remains equal to the server timeout in
-  order to avoid complex situations to debug. Whatever the expected server
-  response times, it is a good practice to cover at least one or several TCP
-  packet losses by specifying timeouts that are slightly above multiples of 3
-  seconds (eg: 4 or 5 seconds minimum).
-
-  This parameter is specific to backends, but can be specified once for all in
-  "defaults" sections. This is in fact one of the easiest solutions not to
-  forget about it. An unspecified timeout results in an infinite timeout, which
-  is not recommended. Such a usage is accepted and works but reports a warning
-  during startup because it may results in accumulation of expired sessions in
-  the system if the system's timeouts are not configured either.
-
-  This parameter is provided for compatibility but is currently deprecated.
-  Please use "timeout server" instead.
-
-  See also : "timeout server", "timeout client" and "clitimeout".
-
-
-stats admin { if | unless } <cond>
-  Enable statistics admin level if/unless a condition is matched
-  May be used in sections :   defaults | frontend | listen | backend
-                                 no    |    no    |   yes  |   yes
-
-  This statement enables the statistics admin level if/unless a condition is
-  matched.
-
-  The admin level allows to enable/disable servers from the web interface. By
-  default, statistics page is read-only for security reasons.
-
-  Note : Consider not using this feature in multi-process mode (nbproc > 1)
-         unless you know what you do : memory is not shared between the
-         processes, which can result in random behaviours.
-
-  Currently, the POST request is limited to the buffer size minus the reserved
-  buffer space, which means that if the list of servers is too long, the
-  request won't be processed. It is recommended to alter few servers at a
-  time.
-
-  Example :
-    # statistics admin level only for localhost
-    backend stats_localhost
-        stats enable
-        stats admin if LOCALHOST
-
-  Example :
-    # statistics admin level always enabled because of the authentication
-    backend stats_auth
-        stats enable
-        stats auth  admin:AdMiN123
-        stats admin if TRUE
-
-  Example :
-    # statistics admin level depends on the authenticated user
-    userlist stats-auth
-        group admin    users admin
-        user  admin    insecure-password AdMiN123
-        group readonly users haproxy
-        user  haproxy  insecure-password haproxy
-
-    backend stats_auth
-        stats enable
-        acl AUTH       http_auth(stats-auth)
-        acl AUTH_ADMIN http_auth_group(stats-auth) admin
-        stats http-request auth unless AUTH
-        stats admin if AUTH_ADMIN
-
-  See also : "stats enable", "stats auth", "stats http-request", "nbproc",
-             "bind-process", section 3.4 about userlists and section 7 about
-             ACL usage.
-
-
-stats auth <user>:<passwd>
-  Enable statistics with authentication and grant access to an account
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments :
-    <user>    is a user name to grant access to
-
-    <passwd>  is the cleartext password associated to this user
-
-  This statement enables statistics with default settings, and restricts access
-  to declared users only. It may be repeated as many times as necessary to
-  allow as many users as desired. When a user tries to access the statistics
-  without a valid account, a "401 Forbidden" response will be returned so that
-  the browser asks the user to provide a valid user and password. The real
-  which will be returned to the browser is configurable using "stats realm".
-
-  Since the authentication method is HTTP Basic Authentication, the passwords
-  circulate in cleartext on the network. Thus, it was decided that the
-  configuration file would also use cleartext passwords to remind the users
-  that those ones should not be sensitive and not shared with any other account.
-
-  It is also possible to reduce the scope of the proxies which appear in the
-  report using "stats scope".
-
-  Though this statement alone is enough to enable statistics reporting, it is
-  recommended to set all other settings in order to avoid relying on default
-  unobvious parameters.
-
-  Example :
-    # public access (limited to this backend only)
-    backend public_www
-        server srv1 192.168.0.1:80
-        stats enable
-        stats hide-version
-        stats scope   .
-        stats uri     /admin?stats
-        stats realm   Haproxy\ Statistics
-        stats auth    admin1:AdMiN123
-        stats auth    admin2:AdMiN321
-
-    # internal monitoring access (unlimited)
-    backend private_monitoring
-        stats enable
-        stats uri     /admin?stats
-        stats refresh 5s
-
-  See also : "stats enable", "stats realm", "stats scope", "stats uri"
-
-
-stats enable
-  Enable statistics reporting with default settings
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments : none
-
-  This statement enables statistics reporting with default settings defined
-  at build time. Unless stated otherwise, these settings are used :
-    - stats uri   : /haproxy?stats
-    - stats realm : "HAProxy Statistics"
-    - stats auth  : no authentication
-    - stats scope : no restriction
-
-  Though this statement alone is enough to enable statistics reporting, it is
-  recommended to set all other settings in order to avoid relying on default
-  unobvious parameters.
-
-  Example :
-    # public access (limited to this backend only)
-    backend public_www
-        server srv1 192.168.0.1:80
-        stats enable
-        stats hide-version
-        stats scope   .
-        stats uri     /admin?stats
-        stats realm   Haproxy\ Statistics
-        stats auth    admin1:AdMiN123
-        stats auth    admin2:AdMiN321
-
-    # internal monitoring access (unlimited)
-    backend private_monitoring
-        stats enable
-        stats uri     /admin?stats
-        stats refresh 5s
-
-  See also : "stats auth", "stats realm", "stats uri"
-
-
-stats hide-version
-  Enable statistics and hide HAProxy version reporting
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments : none
-
-  By default, the stats page reports some useful status information along with
-  the statistics. Among them is HAProxy's version. However, it is generally
-  considered dangerous to report precise version to anyone, as it can help them
-  target known weaknesses with specific attacks. The "stats hide-version"
-  statement removes the version from the statistics report. This is recommended
-  for public sites or any site with a weak login/password.
-
-  Though this statement alone is enough to enable statistics reporting, it is
-  recommended to set all other settings in order to avoid relying on default
-  unobvious parameters.
-
-  Example :
-    # public access (limited to this backend only)
-    backend public_www
-        server srv1 192.168.0.1:80
-        stats enable
-        stats hide-version
-        stats scope   .
-        stats uri     /admin?stats
-        stats realm   Haproxy\ Statistics
-        stats auth    admin1:AdMiN123
-        stats auth    admin2:AdMiN321
-
-    # internal monitoring access (unlimited)
-    backend private_monitoring
-        stats enable
-        stats uri     /admin?stats
-        stats refresh 5s
-
-  See also : "stats auth", "stats enable", "stats realm", "stats uri"
-
-
-stats http-request { allow | deny | auth [realm <realm>] }
-             [ { if | unless } <condition> ]
-  Access control for statistics
-
-  May be used in sections:   defaults | frontend | listen | backend
-                                no    |    no    |   yes  |   yes
-
-  As "http-request", these set of options allow to fine control access to
-  statistics. Each option may be followed by if/unless and acl.
-  First option with matched condition (or option without condition) is final.
-  For "deny" a 403 error will be returned, for "allow" normal processing is
-  performed, for "auth" a 401/407 error code is returned so the client
-  should be asked to enter a username and password.
-
-  There is no fixed limit to the number of http-request statements per
-  instance.
-
-  See also : "http-request", section 3.4 about userlists and section 7
-             about ACL usage.
-
-
-stats realm <realm>
-  Enable statistics and set authentication realm
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments :
-    <realm>   is the name of the HTTP Basic Authentication realm reported to
-              the browser. The browser uses it to display it in the pop-up
-              inviting the user to enter a valid username and password.
-
-  The realm is read as a single word, so any spaces in it should be escaped
-  using a backslash ('\').
-
-  This statement is useful only in conjunction with "stats auth" since it is
-  only related to authentication.
-
-  Though this statement alone is enough to enable statistics reporting, it is
-  recommended to set all other settings in order to avoid relying on default
-  unobvious parameters.
-
-  Example :
-    # public access (limited to this backend only)
-    backend public_www
-        server srv1 192.168.0.1:80
-        stats enable
-        stats hide-version
-        stats scope   .
-        stats uri     /admin?stats
-        stats realm   Haproxy\ Statistics
-        stats auth    admin1:AdMiN123
-        stats auth    admin2:AdMiN321
-
-    # internal monitoring access (unlimited)
-    backend private_monitoring
-        stats enable
-        stats uri     /admin?stats
-        stats refresh 5s
-
-  See also : "stats auth", "stats enable", "stats uri"
-
-
-stats refresh <delay>
-  Enable statistics with automatic refresh
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments :
-    <delay>   is the suggested refresh delay, specified in seconds, which will
-              be returned to the browser consulting the report page. While the
-              browser is free to apply any delay, it will generally respect it
-              and refresh the page this every seconds. The refresh interval may
-              be specified in any other non-default time unit, by suffixing the
-              unit after the value, as explained at the top of this document.
-
-  This statement is useful on monitoring displays with a permanent page
-  reporting the load balancer's activity. When set, the HTML report page will
-  include a link "refresh"/"stop refresh" so that the user can select whether
-  he wants automatic refresh of the page or not.
-
-  Though this statement alone is enough to enable statistics reporting, it is
-  recommended to set all other settings in order to avoid relying on default
-  unobvious parameters.
-
-  Example :
-    # public access (limited to this backend only)
-    backend public_www
-        server srv1 192.168.0.1:80
-        stats enable
-        stats hide-version
-        stats scope   .
-        stats uri     /admin?stats
-        stats realm   Haproxy\ Statistics
-        stats auth    admin1:AdMiN123
-        stats auth    admin2:AdMiN321
-
-    # internal monitoring access (unlimited)
-    backend private_monitoring
-        stats enable
-        stats uri     /admin?stats
-        stats refresh 5s
-
-  See also : "stats auth", "stats enable", "stats realm", "stats uri"
-
-
-stats scope { <name> | "." }
-  Enable statistics and limit access scope
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments :
-    <name>    is the name of a listen, frontend or backend section to be
-              reported. The special name "." (a single dot) designates the
-              section in which the statement appears.
-
-  When this statement is specified, only the sections enumerated with this
-  statement will appear in the report. All other ones will be hidden. This
-  statement may appear as many times as needed if multiple sections need to be
-  reported. Please note that the name checking is performed as simple string
-  comparisons, and that it is never checked that a give section name really
-  exists.
-
-  Though this statement alone is enough to enable statistics reporting, it is
-  recommended to set all other settings in order to avoid relying on default
-  unobvious parameters.
-
-  Example :
-    # public access (limited to this backend only)
-    backend public_www
-        server srv1 192.168.0.1:80
-        stats enable
-        stats hide-version
-        stats scope   .
-        stats uri     /admin?stats
-        stats realm   Haproxy\ Statistics
-        stats auth    admin1:AdMiN123
-        stats auth    admin2:AdMiN321
-
-    # internal monitoring access (unlimited)
-    backend private_monitoring
-        stats enable
-        stats uri     /admin?stats
-        stats refresh 5s
-
-  See also : "stats auth", "stats enable", "stats realm", "stats uri"
-
-
-stats show-desc [ <description> ]
-  Enable reporting of a description on the statistics page.
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-
-    <name>    is an optional description to be reported. If unspecified, the
-              description from global section is automatically used instead.
-
-  This statement is useful for users that offer shared services to their
-  customers, where node or description should be different for each customer.
-
-  Though this statement alone is enough to enable statistics reporting, it is
-  recommended to set all other settings in order to avoid relying on default
-  unobvious parameters.  By default description is not shown.
-
-  Example :
-    # internal monitoring access (unlimited)
-    backend private_monitoring
-        stats enable
-        stats show-desc Master node for Europe, Asia, Africa
-        stats uri       /admin?stats
-        stats refresh   5s
-
-  See also: "show-node", "stats enable", "stats uri" and "description" in
-            global section.
-
-
-stats show-legends
-  Enable reporting additional informations on the statistics page :
-    - cap: capabilities (proxy)
-    - mode: one of tcp, http or health (proxy)
-    - id: SNMP ID (proxy, socket, server)
-    - IP (socket, server)
-    - cookie (backend, server)
-
-  Though this statement alone is enough to enable statistics reporting, it is
-  recommended to set all other settings in order to avoid relying on default
-  unobvious parameters.  Default behaviour is not to show this information.
-
-  See also: "stats enable", "stats uri".
-
-
-stats show-node [ <name> ]
-  Enable reporting of a host name on the statistics page.
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments:
-    <name>    is an optional name to be reported. If unspecified, the
-              node name from global section is automatically used instead.
-
-  This statement is useful for users that offer shared services to their
-  customers, where node or description might be different on a stats page
-  provided for each customer.  Default behaviour is not to show host name.
-
-  Though this statement alone is enough to enable statistics reporting, it is
-  recommended to set all other settings in order to avoid relying on default
-  unobvious parameters.
-
-  Example:
-    # internal monitoring access (unlimited)
-    backend private_monitoring
-        stats enable
-        stats show-node Europe-1
-        stats uri       /admin?stats
-        stats refresh   5s
-
-  See also: "show-desc", "stats enable", "stats uri", and "node" in global
-            section.
-
-
-stats uri <prefix>
-  Enable statistics and define the URI prefix to access them
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments :
-    <prefix>  is the prefix of any URI which will be redirected to stats. This
-              prefix may contain a question mark ('?') to indicate part of a
-              query string.
-
-  The statistics URI is intercepted on the relayed traffic, so it appears as a
-  page within the normal application. It is strongly advised to ensure that the
-  selected URI will never appear in the application, otherwise it will never be
-  possible to reach it in the application.
-
-  The default URI compiled in haproxy is "/haproxy?stats", but this may be
-  changed at build time, so it's better to always explicitly specify it here.
-  It is generally a good idea to include a question mark in the URI so that
-  intermediate proxies refrain from caching the results. Also, since any string
-  beginning with the prefix will be accepted as a stats request, the question
-  mark helps ensuring that no valid URI will begin with the same words.
-
-  It is sometimes very convenient to use "/" as the URI prefix, and put that
-  statement in a "listen" instance of its own. That makes it easy to dedicate
-  an address or a port to statistics only.
-
-  Though this statement alone is enough to enable statistics reporting, it is
-  recommended to set all other settings in order to avoid relying on default
-  unobvious parameters.
-
-  Example :
-    # public access (limited to this backend only)
-    backend public_www
-        server srv1 192.168.0.1:80
-        stats enable
-        stats hide-version
-        stats scope   .
-        stats uri     /admin?stats
-        stats realm   Haproxy\ Statistics
-        stats auth    admin1:AdMiN123
-        stats auth    admin2:AdMiN321
-
-    # internal monitoring access (unlimited)
-    backend private_monitoring
-        stats enable
-        stats uri     /admin?stats
-        stats refresh 5s
-
-  See also : "stats auth", "stats enable", "stats realm"
-
-
-stick match <pattern> [table <table>] [{if | unless} <cond>]
-  Define a request pattern matching condition to stick a user to a server
-  May be used in sections :   defaults | frontend | listen | backend
-                                 no    |    no    |   yes  |   yes
-
-  Arguments :
-    <pattern>  is a pattern extraction rule as described in section 7.8. It
-               describes what elements of the incoming request or connection
-               will be analysed in the hope to find a matching entry in a
-               stickiness table. This rule is mandatory.
-
-    <table>    is an optional stickiness table name. If unspecified, the same
-               backend's table is used. A stickiness table is declared using
-               the "stick-table" statement.
-
-    <cond>     is an optional matching condition. It makes it possible to match
-               on a certain criterion only when other conditions are met (or
-               not met). For instance, it could be used to match on a source IP
-               address except when a request passes through a known proxy, in
-               which case we'd match on a header containing that IP address.
-
-  Some protocols or applications require complex stickiness rules and cannot
-  always simply rely on cookies nor hashing. The "stick match" statement
-  describes a rule to extract the stickiness criterion from an incoming request
-  or connection. See section 7 for a complete list of possible patterns and
-  transformation rules.
-
-  The table has to be declared using the "stick-table" statement. It must be of
-  a type compatible with the pattern. By default it is the one which is present
-  in the same backend. It is possible to share a table with other backends by
-  referencing it using the "table" keyword. If another table is referenced,
-  the server's ID inside the backends are used. By default, all server IDs
-  start at 1 in each backend, so the server ordering is enough. But in case of
-  doubt, it is highly recommended to force server IDs using their "id" setting.
-
-  It is possible to restrict the conditions where a "stick match" statement
-  will apply, using "if" or "unless" followed by a condition. See section 7 for
-  ACL based conditions.
-
-  There is no limit on the number of "stick match" statements. The first that
-  applies and matches will cause the request to be directed to the same server
-  as was used for the request which created the entry. That way, multiple
-  matches can be used as fallbacks.
-
-  The stick rules are checked after the persistence cookies, so they will not
-  affect stickiness if a cookie has already been used to select a server. That
-  way, it becomes very easy to insert cookies and match on IP addresses in
-  order to maintain stickiness between HTTP and HTTPS.
-
-  Note : Consider not using this feature in multi-process mode (nbproc > 1)
-         unless you know what you do : memory is not shared between the
-         processes, which can result in random behaviours.
-
-  Example :
-    # forward SMTP users to the same server they just used for POP in the
-    # last 30 minutes
-    backend pop
-        mode tcp
-        balance roundrobin
-        stick store-request src
-        stick-table type ip size 200k expire 30m
-        server s1 192.168.1.1:110
-        server s2 192.168.1.1:110
-
-    backend smtp
-        mode tcp
-        balance roundrobin
-        stick match src table pop
-        server s1 192.168.1.1:25
-        server s2 192.168.1.1:25
-
-  See also : "stick-table", "stick on", "nbproc", "bind-process" and section 7
-             about ACLs and pattern extraction.
-
-
-stick on <pattern> [table <table>] [{if | unless} <condition>]
-  Define a request pattern to associate a user to a server
-  May be used in sections :   defaults | frontend | listen | backend
-                                 no    |    no    |   yes  |   yes
-
-  Note : This form is exactly equivalent to "stick match" followed by
-         "stick store-request", all with the same arguments. Please refer
-         to both keywords for details. It is only provided as a convenience
-         for writing more maintainable configurations.
-
-  Note : Consider not using this feature in multi-process mode (nbproc > 1)
-         unless you know what you do : memory is not shared between the
-         processes, which can result in random behaviours.
-
-  Examples :
-    # The following form ...
-    stick on src table pop if !localhost
-
-    # ...is strictly equivalent to this one :
-    stick match src table pop if !localhost
-    stick store-request src table pop if !localhost
-
-
-    # Use cookie persistence for HTTP, and stick on source address for HTTPS as
-    # well as HTTP without cookie. Share the same table between both accesses.
-    backend http
-        mode http
-        balance roundrobin
-        stick on src table https
-        cookie SRV insert indirect nocache
-        server s1 192.168.1.1:80 cookie s1
-        server s2 192.168.1.1:80 cookie s2
-
-    backend https
-        mode tcp
-        balance roundrobin
-        stick-table type ip size 200k expire 30m
-        stick on src
-        server s1 192.168.1.1:443
-        server s2 192.168.1.1:443
-
-  See also : "stick match", "stick store-request", "nbproc" and "bind-process".
-
-
-stick store-request <pattern> [table <table>] [{if | unless} <condition>]
-  Define a request pattern used to create an entry in a stickiness table
-  May be used in sections :   defaults | frontend | listen | backend
-                                 no    |    no    |   yes  |   yes
-
-  Arguments :
-    <pattern>  is a pattern extraction rule as described in section 7.8. It
-               describes what elements of the incoming request or connection
-               will be analysed, extracted and stored in the table once a
-               server is selected.
-
-    <table>    is an optional stickiness table name. If unspecified, the same
-               backend's table is used. A stickiness table is declared using
-               the "stick-table" statement.
-
-    <cond>     is an optional storage condition. It makes it possible to store
-               certain criteria only when some conditions are met (or not met).
-               For instance, it could be used to store the source IP address
-               except when the request passes through a known proxy, in which
-               case we'd store a converted form of a header containing that IP
-               address.
-
-  Some protocols or applications require complex stickiness rules and cannot
-  always simply rely on cookies nor hashing. The "stick store-request" statement
-  describes a rule to decide what to extract from the request and when to do
-  it, in order to store it into a stickiness table for further requests to
-  match it using the "stick match" statement. Obviously the extracted part must
-  make sense and have a chance to be matched in a further request. Storing a
-  client's IP address for instance often makes sense. Storing an ID found in a
-  URL parameter also makes sense. Storing a source port will almost never make
-  any sense because it will be randomly matched. See section 7 for a complete
-  list of possible patterns and transformation rules.
-
-  The table has to be declared using the "stick-table" statement. It must be of
-  a type compatible with the pattern. By default it is the one which is present
-  in the same backend. It is possible to share a table with other backends by
-  referencing it using the "table" keyword. If another table is referenced,
-  the server's ID inside the backends are used. By default, all server IDs
-  start at 1 in each backend, so the server ordering is enough. But in case of
-  doubt, it is highly recommended to force server IDs using their "id" setting.
-
-  It is possible to restrict the conditions where a "stick store-request"
-  statement will apply, using "if" or "unless" followed by a condition. This
-  condition will be evaluated while parsing the request, so any criteria can be
-  used. See section 7 for ACL based conditions.
-
-  There is no limit on the number of "stick store-request" statements, but
-  there is a limit of 8 simultaneous stores per request or response. This
-  makes it possible to store up to 8 criteria, all extracted from either the
-  request or the response, regardless of the number of rules. Only the 8 first
-  ones which match will be kept. Using this, it is possible to feed multiple
-  tables at once in the hope to increase the chance to recognize a user on
-  another protocol or access method.
-
-  The "store-request" rules are evaluated once the server connection has been
-  established, so that the table will contain the real server that processed
-  the request.
-
-  Note : Consider not using this feature in multi-process mode (nbproc > 1)
-         unless you know what you do : memory is not shared between the
-         processes, which can result in random behaviours.
-
-  Example :
-    # forward SMTP users to the same server they just used for POP in the
-    # last 30 minutes
-    backend pop
-        mode tcp
-        balance roundrobin
-        stick store-request src
-        stick-table type ip size 200k expire 30m
-        server s1 192.168.1.1:110
-        server s2 192.168.1.1:110
-
-    backend smtp
-        mode tcp
-        balance roundrobin
-        stick match src table pop
-        server s1 192.168.1.1:25
-        server s2 192.168.1.1:25
-
-  See also : "stick-table", "stick on", "nbproc", "bind-process" and section 7
-             about ACLs and pattern extraction.
-
-
-stick-table type {ip | integer | string [len <length>] } size <size>
-            [expire <expire>] [nopurge]
-  Configure the stickiness table for the current backend
-  May be used in sections :   defaults | frontend | listen | backend
-                                 no    |    no    |   yes  |   yes
-
-  Arguments :
-    ip         a table declared with "type ip" will only store IPv4 addresses.
-               This form is very compact (about 50 bytes per entry) and allows
-               very fast entry lookup and stores with almost no overhead. This
-               is mainly used to store client source IP addresses.
-
-    integer    a table declared with "type integer" will store 32bit integers
-               which can represent a client identifier found in a request for
-               instance.
-
-    string     a table declared with "type string" will store substrings of up
-               to <len> characters. If the string provided by the pattern
-               extractor is larger than <len>, it will be truncated before
-               being stored. During matching, at most <len> characters will be
-               compared between the string in the table and the extracted
-               pattern. When not specified, the string is automatically limited
-               to 31 characters.
-
-    <length>   is the maximum number of characters that will be stored in a
-               "string" type table. See type "string" above. Be careful when
-               changing this parameter as memory usage will proportionally
-               increase.
-
-    <size>     is the maximum number of entries that can fit in the table. This
-               value directly impacts memory usage. Count approximately
-               50 bytes per entry, plus the size of a string if any. The size
-               supports suffixes "k", "m", "g" for 2^10, 2^20 and 2^30 factors.
-
-    [nopurge]  indicates that we refuse to purge older entries when the table
-               is full. When not specified and the table is full when haproxy
-               wants to store an entry in it, it will flush a few of the oldest
-               entries in order to release some space for the new ones. This is
-               most often the desired behaviour. In some specific cases, it
-               be desirable to refuse new entries instead of purging the older
-               ones. That may be the case when the amount of data to store is
-               far above the hardware limits and we prefer not to offer access
-               to new clients than to reject the ones already connected. When
-               using this parameter, be sure to properly set the "expire"
-               parameter (see below).
-
-    <expire>   defines the maximum duration of an entry in the table since it
-               was last created, refreshed or matched. The expiration delay is
-               defined using the standard time format, similarly as the various
-               timeouts. The maximum duration is slightly above 24 days. See
-               section 2.2 for more information. If this delay is not specified,
-               the session won't automatically expire, but older entries will
-               be removed once full. Be sure not to use the "nopurge" parameter
-               if not expiration delay is specified.
-
-  The is only one stick-table per backend. At the moment of writing this doc,
-  it does not seem useful to have multiple tables per backend. If this happens
-  to be required, simply create a dummy backend with a stick-table in it and
-  reference it.
-
-  It is important to understand that stickiness based on learning information
-  has some limitations, including the fact that all learned associations are
-  lost upon restart. In general it can be good as a complement but not always
-  as an exclusive stickiness.
-
-  See also : "stick match", "stick on", "stick store-request", and section 2.2
-             about time format.
-
-
-tcp-request content accept [{if | unless} <condition>]
-  Accept a connection if/unless a content inspection condition is matched
-  May be used in sections :   defaults | frontend | listen | backend
-                                 no    |    yes   |   yes  |   no
-
-  During TCP content inspection, the connection is immediately validated if the
-  condition is true (when used with "if") or false (when used with "unless").
-  Most of the time during content inspection, a condition will be in an
-  uncertain state which is neither true nor false. The evaluation immediately
-  stops when such a condition is encountered. It is important to understand
-  that "accept" and "reject" rules are evaluated in their exact declaration
-  order, so that it is possible to build complex rules from them. There is no
-  specific limit to the number of rules which may be inserted.
-
-  Note that the "if/unless" condition is optional. If no condition is set on
-  the action, it is simply performed unconditionally.
-
-  If no "tcp-request content" rules are matched, the default action already is
-  "accept". Thus, this statement alone does not bring anything without another
-  "reject" statement.
-
-  See section 7 about ACL usage.
-
-  See also : "tcp-request content reject", "tcp-request inspect-delay"
-
-
-tcp-request content reject [{if | unless} <condition>]
-  Reject a connection if/unless a content inspection condition is matched
-  May be used in sections :   defaults | frontend | listen | backend
-                                 no    |    yes   |   yes  |   no
-
-  During TCP content inspection, the connection is immediately rejected if the
-  condition is true (when used with "if") or false (when used with "unless").
-  Most of the time during content inspection, a condition will be in an
-  uncertain state which is neither true nor false. The evaluation immediately
-  stops when such a condition is encountered. It is important to understand
-  that "accept" and "reject" rules are evaluated in their exact declaration
-  order, so that it is possible to build complex rules from them. There is no
-  specific limit to the number of rules which may be inserted.
-
-  Note that the "if/unless" condition is optional. If no condition is set on
-  the action, it is simply performed unconditionally.
-
-  If no "tcp-request content" rules are matched, the default action is set to
-  "accept".
-
-  Example:
-        # reject SMTP connection if client speaks first
-        tcp-request inspect-delay 30s
-        acl content_present req_len gt 0
-        tcp-request reject if content_present
-
-        # Forward HTTPS connection only if client speaks
-        tcp-request inspect-delay 30s
-        acl content_present req_len gt 0
-        tcp-request accept if content_present
-        tcp-request reject
-
-  See section 7 about ACL usage.
-
-  See also : "tcp-request content accept", "tcp-request inspect-delay"
-
-
-tcp-request inspect-delay <timeout>
-  Set the maximum allowed time to wait for data during content inspection
-  May be used in sections :   defaults | frontend | listen | backend
-                                 no    |    yes   |   yes  |   no
-  Arguments :
-    <timeout> is the timeout value specified in milliseconds by default, but
-              can be in any other unit if the number is suffixed by the unit,
-              as explained at the top of this document.
-
-  People using haproxy primarily as a TCP relay are often worried about the
-  risk of passing any type of protocol to a server without any analysis. In
-  order to be able to analyze the request contents, we must first withhold
-  the data then analyze them. This statement simply enables withholding of
-  data for at most the specified amount of time.
-
-  Note that when performing content inspection, haproxy will evaluate the whole
-  rules for every new chunk which gets in, taking into account the fact that
-  those data are partial. If no rule matches before the aforementioned delay,
-  a last check is performed upon expiration, this time considering that the
-  contents are definitive. If no delay is set, haproxy will not wait at all
-  and will immediately apply a verdict based on the available information.
-  Obviously this is unlikely to be very useful and might even be racy, so such
-  setups are not recommended.
-
-  As soon as a rule matches, the request is released and continues as usual. If
-  the timeout is reached and no rule matches, the default policy will be to let
-  it pass through unaffected.
-
-  For most protocols, it is enough to set it to a few seconds, as most clients
-  send the full request immediately upon connection. Add 3 or more seconds to
-  cover TCP retransmits but that's all. For some protocols, it may make sense
-  to use large values, for instance to ensure that the client never talks
-  before the server (eg: SMTP), or to wait for a client to talk before passing
-  data to the server (eg: SSL). Note that the client timeout must cover at
-  least the inspection delay, otherwise it will expire first. If the client
-  closes the connection or if the buffer is full, the delay immediately expires
-  since the contents will not be able to change anymore.
-
-  See also : "tcp-request content accept", "tcp-request content reject",
-             "timeout client".
-
-
-timeout check <timeout>
-  Set additional check timeout, but only after a connection has been already
-  established.
-
-  May be used in sections:    defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments:
-    <timeout> is the timeout value specified in milliseconds by default, but
-              can be in any other unit if the number is suffixed by the unit,
-              as explained at the top of this document.
-
-  If set, haproxy uses min("timeout connect", "inter") as a connect timeout
-  for check and "timeout check" as an additional read timeout. The "min" is
-  used so that people running with *very* long "timeout connect" (eg. those
-  who needed this due to the queue or tarpit) do not slow down their checks.
-  (Please also note that there is no valid reason to have such long connect
-  timeouts, because "timeout queue" and "timeout tarpit" can always be used to
-  avoid that).
-
-  If "timeout check" is not set haproxy uses "inter" for complete check
-  timeout (connect + read) exactly like all <1.3.15 version.
-
-  In most cases check request is much simpler and faster to handle than normal
-  requests and people may want to kick out laggy servers so this timeout should
-  be smaller than "timeout server".
-
-  This parameter is specific to backends, but can be specified once for all in
-  "defaults" sections. This is in fact one of the easiest solutions not to
-  forget about it.
-
-  See also: "timeout connect", "timeout queue", "timeout server",
-            "timeout tarpit".
-
-
-timeout client <timeout>
-timeout clitimeout <timeout> (deprecated)
-  Set the maximum inactivity time on the client side.
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   no
-  Arguments :
-    <timeout> is the timeout value specified in milliseconds by default, but
-              can be in any other unit if the number is suffixed by the unit,
-              as explained at the top of this document.
-
-  The inactivity timeout applies when the client is expected to acknowledge or
-  send data. In HTTP mode, this timeout is particularly important to consider
-  during the first phase, when the client sends the request, and during the
-  response while it is reading data sent by the server. The value is specified
-  in milliseconds by default, but can be in any other unit if the number is
-  suffixed by the unit, as specified at the top of this document. In TCP mode
-  (and to a lesser extent, in HTTP mode), it is highly recommended that the
-  client timeout remains equal to the server timeout in order to avoid complex
-  situations to debug. It is a good practice to cover one or several TCP packet
-  losses by specifying timeouts that are slightly above multiples of 3 seconds
-  (eg: 4 or 5 seconds).
-
-  This parameter is specific to frontends, but can be specified once for all in
-  "defaults" sections. This is in fact one of the easiest solutions not to
-  forget about it. An unspecified timeout results in an infinite timeout, which
-  is not recommended. Such a usage is accepted and works but reports a warning
-  during startup because it may results in accumulation of expired sessions in
-  the system if the system's timeouts are not configured either.
-
-  This parameter replaces the old, deprecated "clitimeout". It is recommended
-  to use it to write new configurations. The form "timeout clitimeout" is
-  provided only by backwards compatibility but its use is strongly discouraged.
-
-  See also : "clitimeout", "timeout server".
-
-
-timeout connect <timeout>
-timeout contimeout <timeout> (deprecated)
-  Set the maximum time to wait for a connection attempt to a server to succeed.
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments :
-    <timeout> is the timeout value specified in milliseconds by default, but
-              can be in any other unit if the number is suffixed by the unit,
-              as explained at the top of this document.
-
-  If the server is located on the same LAN as haproxy, the connection should be
-  immediate (less than a few milliseconds). Anyway, it is a good practice to
-  cover one or several TCP packet losses by specifying timeouts that are
-  slightly above multiples of 3 seconds (eg: 4 or 5 seconds). By default, the
-  connect timeout also presets both queue and tarpit timeouts to the same value
-  if these have not been specified.
-
-  This parameter is specific to backends, but can be specified once for all in
-  "defaults" sections. This is in fact one of the easiest solutions not to
-  forget about it. An unspecified timeout results in an infinite timeout, which
-  is not recommended. Such a usage is accepted and works but reports a warning
-  during startup because it may results in accumulation of failed sessions in
-  the system if the system's timeouts are not configured either.
-
-  This parameter replaces the old, deprecated "contimeout". It is recommended
-  to use it to write new configurations. The form "timeout contimeout" is
-  provided only by backwards compatibility but its use is strongly discouraged.
-
-  See also: "timeout check", "timeout queue", "timeout server", "contimeout",
-            "timeout tarpit".
-
-
-timeout http-keep-alive <timeout>
-  Set the maximum allowed time to wait for a new HTTP request to appear
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   yes
-  Arguments :
-    <timeout> is the timeout value specified in milliseconds by default, but
-              can be in any other unit if the number is suffixed by the unit,
-              as explained at the top of this document.
-
-  By default, the time to wait for a new request in case of keep-alive is set
-  by "timeout http-request". However this is not always convenient because some
-  people want very short keep-alive timeouts in order to release connections
-  faster, and others prefer to have larger ones but still have short timeouts
-  once the request has started to present itself.
-
-  The "http-keep-alive" timeout covers these needs. It will define how long to
-  wait for a new HTTP request to start coming after a response was sent. Once
-  the first byte of request has been seen, the "http-request" timeout is used
-  to wait for the complete request to come. Note that empty lines prior to a
-  new request do not refresh the timeout and are not counted as a new request.
-
-  There is also another difference between the two timeouts : when a connection
-  expires during timeout http-keep-alive, no error is returned, the connection
-  just closes. If the connection expires in "http-request" while waiting for a
-  connection to complete, a HTTP 408 error is returned.
-
-  In general it is optimal to set this value to a few tens to hundreds of
-  milliseconds, to allow users to fetch all objects of a page at once but
-  without waiting for further clicks. Also, if set to a very small value (eg:
-  1 millisecond) it will probably only accept pipelined requests but not the
-  non-pipelined ones. It may be a nice trade-off for very large sites running
-  with tens to hundreds of thousands of clients.
-
-  If this parameter is not set, the "http-request" timeout applies, and if both
-  are not set, "timeout client" still applies at the lower level. It should be
-  set in the frontend to take effect, unless the frontend is in TCP mode, in
-  which case the HTTP backend's timeout will be used.
-
-  See also : "timeout http-request", "timeout client".
-
-
-timeout http-request <timeout>
-  Set the maximum allowed time to wait for a complete HTTP request
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   yes
-  Arguments :
-    <timeout> is the timeout value specified in milliseconds by default, but
-              can be in any other unit if the number is suffixed by the unit,
-              as explained at the top of this document.
-
-  In order to offer DoS protection, it may be required to lower the maximum
-  accepted time to receive a complete HTTP request without affecting the client
-  timeout. This helps protecting against established connections on which
-  nothing is sent. The client timeout cannot offer a good protection against
-  this abuse because it is an inactivity timeout, which means that if the
-  attacker sends one character every now and then, the timeout will not
-  trigger. With the HTTP request timeout, no matter what speed the client
-  types, the request will be aborted if it does not complete in time.
-
-  Note that this timeout only applies to the header part of the request, and
-  not to any data. As soon as the empty line is received, this timeout is not
-  used anymore. It is used again on keep-alive connections to wait for a second
-  request if "timeout http-keep-alive" is not set.
-
-  Generally it is enough to set it to a few seconds, as most clients send the
-  full request immediately upon connection. Add 3 or more seconds to cover TCP
-  retransmits but that's all. Setting it to very low values (eg: 50 ms) will
-  generally work on local networks as long as there are no packet losses. This
-  will prevent people from sending bare HTTP requests using telnet.
-
-  If this parameter is not set, the client timeout still applies between each
-  chunk of the incoming request. It should be set in the frontend to take
-  effect, unless the frontend is in TCP mode, in which case the HTTP backend's
-  timeout will be used.
-
-  See also : "timeout http-keep-alive", "timeout client".
-
-
-timeout queue <timeout>
-  Set the maximum time to wait in the queue for a connection slot to be free
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments :
-    <timeout> is the timeout value specified in milliseconds by default, but
-              can be in any other unit if the number is suffixed by the unit,
-              as explained at the top of this document.
-
-  When a server's maxconn is reached, connections are left pending in a queue
-  which may be server-specific or global to the backend. In order not to wait
-  indefinitely, a timeout is applied to requests pending in the queue. If the
-  timeout is reached, it is considered that the request will almost never be
-  served, so it is dropped and a 503 error is returned to the client.
-
-  The "timeout queue" statement allows to fix the maximum time for a request to
-  be left pending in a queue. If unspecified, the same value as the backend's
-  connection timeout ("timeout connect") is used, for backwards compatibility
-  with older versions with no "timeout queue" parameter.
-
-  See also : "timeout connect", "contimeout".
-
-
-timeout server <timeout>
-timeout srvtimeout <timeout> (deprecated)
-  Set the maximum inactivity time on the server side.
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments :
-    <timeout> is the timeout value specified in milliseconds by default, but
-              can be in any other unit if the number is suffixed by the unit,
-              as explained at the top of this document.
-
-  The inactivity timeout applies when the server is expected to acknowledge or
-  send data. In HTTP mode, this timeout is particularly important to consider
-  during the first phase of the server's response, when it has to send the
-  headers, as it directly represents the server's processing time for the
-  request. To find out what value to put there, it's often good to start with
-  what would be considered as unacceptable response times, then check the logs
-  to observe the response time distribution, and adjust the value accordingly.
-
-  The value is specified in milliseconds by default, but can be in any other
-  unit if the number is suffixed by the unit, as specified at the top of this
-  document. In TCP mode (and to a lesser extent, in HTTP mode), it is highly
-  recommended that the client timeout remains equal to the server timeout in
-  order to avoid complex situations to debug. Whatever the expected server
-  response times, it is a good practice to cover at least one or several TCP
-  packet losses by specifying timeouts that are slightly above multiples of 3
-  seconds (eg: 4 or 5 seconds minimum).
-
-  This parameter is specific to backends, but can be specified once for all in
-  "defaults" sections. This is in fact one of the easiest solutions not to
-  forget about it. An unspecified timeout results in an infinite timeout, which
-  is not recommended. Such a usage is accepted and works but reports a warning
-  during startup because it may results in accumulation of expired sessions in
-  the system if the system's timeouts are not configured either.
-
-  This parameter replaces the old, deprecated "srvtimeout". It is recommended
-  to use it to write new configurations. The form "timeout srvtimeout" is
-  provided only by backwards compatibility but its use is strongly discouraged.
-
-  See also : "srvtimeout", "timeout client".
-
-
-timeout tarpit <timeout>
-  Set the duration for which tarpitted connections will be maintained
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    yes   |   yes  |   yes
-  Arguments :
-    <timeout> is the tarpit duration specified in milliseconds by default, but
-              can be in any other unit if the number is suffixed by the unit,
-              as explained at the top of this document.
-
-  When a connection is tarpitted using "reqtarpit", it is maintained open with
-  no activity for a certain amount of time, then closed. "timeout tarpit"
-  defines how long it will be maintained open.
-
-  The value is specified in milliseconds by default, but can be in any other
-  unit if the number is suffixed by the unit, as specified at the top of this
-  document. If unspecified, the same value as the backend's connection timeout
-  ("timeout connect") is used, for backwards compatibility with older versions
-  with no "timeout tarpit" parameter.
-
-  See also : "timeout connect", "contimeout".
-
-
-transparent (deprecated)
-  Enable client-side transparent proxying
-  May be used in sections :   defaults | frontend | listen | backend
-                                 yes   |    no    |   yes  |   yes
-  Arguments : none
-
-  This keyword was introduced in order to provide layer 7 persistence to layer
-  3 load balancers. The idea is to use the OS's ability to redirect an incoming
-  connection for a remote address to a local process (here HAProxy), and let
-  this process know what address was initially requested. When this option is
-  used, sessions without cookies will be forwarded to the original destination
-  IP address of the incoming request (which should match that of another
-  equipment), while requests with cookies will still be forwarded to the
-  appropriate server.
-
-  The "transparent" keyword is deprecated, use "option transparent" instead.
-
-  Note that contrary to a common belief, this option does NOT make HAProxy
-  present the client's IP to the server when establishing the connection.
-
-  See also: "option transparent"
-
-
-use_backend <backend> if <condition>
-use_backend <backend> unless <condition>
-  Switch to a specific backend if/unless an ACL-based condition is matched.
-  May be used in sections :   defaults | frontend | listen | backend
-                                  no   |    yes   |   yes  |   no
-  Arguments :
-    <backend>   is the name of a valid backend or "listen" section.
-
-    <condition> is a condition composed of ACLs, as described in section 7.
-
-  When doing content-switching, connections arrive on a frontend and are then
-  dispatched to various backends depending on a number of conditions. The
-  relation between the conditions and the backends is described with the
-  "use_backend" keyword. While it is normally used with HTTP processing, it can
-  also be used in pure TCP, either without content using stateless ACLs (eg:
-  source address validation) or combined with a "tcp-request" rule to wait for
-  some payload.
-
-  There may be as many "use_backend" rules as desired. All of these rules are
-  evaluated in their declaration order, and the first one which matches will
-  assign the backend.
-
-  In the first form, the backend will be used if the condition is met. In the
-  second form, the backend will be used if the condition is not met. If no
-  condition is valid, the backend defined with "default_backend" will be used.
-  If no default backend is defined, either the servers in the same section are
-  used (in case of a "listen" section) or, in case of a frontend, no server is
-  used and a 503 service unavailable response is returned.
-
-  Note that it is possible to switch from a TCP frontend to an HTTP backend. In
-  this case, either the frontend has already checked that the protocol is HTTP,
-  and backend processing will immediately follow, or the backend will wait for
-  a complete HTTP request to get in. This feature is useful when a frontend
-  must decode several protocols on a unique port, one of them being HTTP.
-
-  See also: "default_backend", "tcp-request", and section 7 about ACLs.
-
-
-5. Server and default-server options
-------------------------------------
-
-The "server" and "default-server" keywords support a certain number of settings
-which are all passed as arguments on the server line. The order in which those
-arguments appear does not count, and they are all optional. Some of those
-settings are single words (booleans) while others expect one or several values
-after them. In this case, the values must immediately follow the setting name.
-Except default-server, all those settings must be specified after the server's
-address if they are used:
-
-  server <name> <address>[:port] [settings ...]
-  default-server [settings ...]
-
-The currently supported settings are the following ones.
-
-addr <ipv4>
-  Using the "addr" parameter, it becomes possible to use a different IP address
-  to send health-checks. On some servers, it may be desirable to dedicate an IP
-  address to specific component able to perform complex tests which are more
-  suitable to health-checks than the application. This parameter is ignored if
-  the "check" parameter is not set. See also the "port" parameter.
-
-  Supported in default-server: No
-
-backup
-  When "backup" is present on a server line, the server is only used in load
-  balancing when all other non-backup servers are unavailable. Requests coming
-  with a persistence cookie referencing the server will always be served
-  though. By default, only the first operational backup server is used, unless
-  the "allbackups" option is set in the backend. See also the "allbackups"
-  option.
-
-  Supported in default-server: No
-
-check
-  This option enables health checks on the server. By default, a server is
-  always considered available. If "check" is set, the server will receive
-  periodic health checks to ensure that it is really able to serve requests.
-  The default address and port to send the tests to are those of the server,
-  and the default source is the same as the one defined in the backend. It is
-  possible to change the address using the "addr" parameter, the port using the
-  "port" parameter, the source address using the "source" address, and the
-  interval and timers using the "inter", "rise" and "fall" parameters. The
-  request method is define in the backend using the "httpchk", "smtpchk",
-  "mysql-check" and "ssl-hello-chk" options. Please refer to those options and
-  parameters for more information.
-
-  Supported in default-server: No
-
-cookie <value>
-  The "cookie" parameter sets the cookie value assigned to the server to
-  <value>. This value will be checked in incoming requests, and the first
-  operational server possessing the same value will be selected. In return, in
-  cookie insertion or rewrite modes, this value will be assigned to the cookie
-  sent to the client. There is nothing wrong in having several servers sharing
-  the same cookie value, and it is in fact somewhat common between normal and
-  backup servers. See also the "cookie" keyword in backend section.
-
-  Supported in default-server: No
-
-disabled
-  The "disabled" keyword starts the server in the "disabled" state. That means
-  that it is marked down in maintenance mode, and no connection other than the
-  ones allowed by persist mode will reach it. It is very well suited to setup
-  new servers, because normal traffic will never reach them, while it is still
-  possible to test the service by making use of the force-persist mechanism.
-
-  Supported in default-server: No
-
-error-limit <count>
-  If health observing is enabled, the "error-limit" parameter specifies the
-  number of consecutive errors that triggers event selected by the "on-error"
-  option. By default it is set to 10 consecutive errors.
-
-  Supported in default-server: Yes
-
-  See also the "check", "error-limit" and "on-error".
-
-fall <count>
-  The "fall" parameter states that a server will be considered as dead after
-  <count> consecutive unsuccessful health checks. This value defaults to 3 if
-  unspecified. See also the "check", "inter" and "rise" parameters.
-
-  Supported in default-server: Yes
-
-id <value>
-  Set a persistent ID for the server. This ID must be positive and unique for
-  the proxy. An unused ID will automatically be assigned if unset. The first
-  assigned value will be 1. This ID is currently only returned in statistics.
-
-  Supported in default-server: No
-
-inter <delay>
-fastinter <delay>
-downinter <delay>
-  The "inter" parameter sets the interval between two consecutive health checks
-  to <delay> milliseconds. If left unspecified, the delay defaults to 2000 ms.
-  It is also possible to use "fastinter" and "downinter" to optimize delays
-  between checks depending on the server state :
-
-             Server state            |             Interval used
-    ---------------------------------+-----------------------------------------
-     UP 100% (non-transitional)      | "inter"
-    ---------------------------------+-----------------------------------------
-     Transitionally UP (going down), |
-     Transitionally DOWN (going up), | "fastinter" if set, "inter" otherwise.
-     or yet unchecked.               |
-    ---------------------------------+-----------------------------------------
-     DOWN 100% (non-transitional)    | "downinter" if set, "inter" otherwise.
-    ---------------------------------+-----------------------------------------
-
-  Just as with every other time-based parameter, they can be entered in any
-  other explicit unit among { us, ms, s, m, h, d }. The "inter" parameter also
-  serves as a timeout for health checks sent to servers if "timeout check" is
-  not set. In order to reduce "resonance" effects when multiple servers are
-  hosted on the same hardware, the health-checks of all servers are started
-  with a small time offset between them. It is also possible to add some random
-  noise in the health checks interval using the global "spread-checks"
-  keyword. This makes sense for instance when a lot of backends use the same
-  servers.
-
-  Supported in default-server: Yes
-
-maxconn <maxconn>
-  The "maxconn" parameter specifies the maximal number of concurrent
-  connections that will be sent to this server. If the number of incoming
-  concurrent requests goes higher than this value, they will be queued, waiting
-  for a connection to be released. This parameter is very important as it can
-  save fragile servers from going down under extreme loads. If a "minconn"
-  parameter is specified, the limit becomes dynamic. The default value is "0"
-  which means unlimited. See also the "minconn" and "maxqueue" parameters, and
-  the backend's "fullconn" keyword.
-
-  Supported in default-server: Yes
-
-maxqueue <maxqueue>
-  The "maxqueue" parameter specifies the maximal number of connections which
-  will wait in the queue for this server. If this limit is reached, next
-  requests will be redispatched to other servers instead of indefinitely
-  waiting to be served. This will break persistence but may allow people to
-  quickly re-log in when the server they try to connect to is dying. The
-  default value is "0" which means the queue is unlimited. See also the
-  "maxconn" and "minconn" parameters.
-
-  Supported in default-server: Yes
-
-minconn <minconn>
-  When the "minconn" parameter is set, the maxconn limit becomes a dynamic
-  limit following the backend's load. The server will always accept at least
-  <minconn> connections, never more than <maxconn>, and the limit will be on
-  the ramp between both values when the backend has less than <fullconn>
-  concurrent connections. This makes it possible to limit the load on the
-  server during normal loads, but push it further for important loads without
-  overloading the server during exceptional loads. See also the "maxconn"
-  and "maxqueue" parameters, as well as the "fullconn" backend keyword.
-
-  Supported in default-server: Yes
-
-observe <mode>
-  This option enables health adjusting based on observing communication with
-  the server. By default this functionality is disabled and enabling it also
-  requires to enable health checks. There are two supported modes: "layer4" and
-  "layer7". In layer4 mode, only successful/unsuccessful tcp connections are
-  significant. In layer7, which is only allowed for http proxies, responses
-  received from server are verified, like valid/wrong http code, unparsable
-  headers, a timeout, etc. Valid status codes include 100 to 499, 501 and 505.
-
-  Supported in default-server: No
-
-  See also the "check", "on-error" and "error-limit".
-
-on-error <mode>
-  Select what should happen when enough consecutive errors are detected.
-  Currently, four modes are available:
-  - fastinter: force fastinter
-  - fail-check: simulate a failed check, also forces fastinter (default)
-  - sudden-death: simulate a pre-fatal failed health check, one more failed
-    check will mark a server down, forces fastinter
-  - mark-down: mark the server immediately down and force fastinter
-
-  Supported in default-server: Yes
-
-  See also the "check", "observe" and "error-limit".
-
-port <port>
-  Using the "port" parameter, it becomes possible to use a different port to
-  send health-checks. On some servers, it may be desirable to dedicate a port
-  to a specific component able to perform complex tests which are more suitable
-  to health-checks than the application. It is common to run a simple script in
-  inetd for instance. This parameter is ignored if the "check" parameter is not
-  set. See also the "addr" parameter.
-
-  Supported in default-server: Yes
-
-redir <prefix>
-  The "redir" parameter enables the redirection mode for all GET and HEAD
-  requests addressing this server. This means that instead of having HAProxy
-  forward the request to the server, it will send an "HTTP 302" response with
-  the "Location" header composed of this prefix immediately followed by the
-  requested URI beginning at the leading '/' of the path component. That means
-  that no trailing slash should be used after <prefix>. All invalid requests
-  will be rejected, and all non-GET or HEAD requests will be normally served by
-  the server. Note that since the response is completely forged, no header
-  mangling nor cookie insertion is possible in the response. However, cookies in
-  requests are still analysed, making this solution completely usable to direct
-  users to a remote location in case of local disaster. Main use consists in
-  increasing bandwidth for static servers by having the clients directly
-  connect to them. Note: never use a relative location here, it would cause a
-  loop between the client and HAProxy!
-
-  Example :  server srv1 192.168.1.1:80 redir http://image1.mydomain.com check
-
-  Supported in default-server: No
-
-rise <count>
-  The "rise" parameter states that a server will be considered as operational
-  after <count> consecutive successful health checks. This value defaults to 2
-  if unspecified. See also the "check", "inter" and "fall" parameters.
-
-  Supported in default-server: Yes
-
-slowstart <start_time_in_ms>
-  The "slowstart" parameter for a server accepts a value in milliseconds which
-  indicates after how long a server which has just come back up will run at
-  full speed. Just as with every other time-based parameter, it can be entered
-  in any other explicit unit among { us, ms, s, m, h, d }. The speed grows
-  linearly from 0 to 100% during this time. The limitation applies to two
-  parameters :
-
-  - maxconn: the number of connections accepted by the server will grow from 1
-    to 100% of the usual dynamic limit defined by (minconn,maxconn,fullconn).
-
-  - weight: when the backend uses a dynamic weighted algorithm, the weight
-    grows linearly from 1 to 100%. In this case, the weight is updated at every
-    health-check. For this reason, it is important that the "inter" parameter
-    is smaller than the "slowstart", in order to maximize the number of steps.
-
-  The slowstart never applies when haproxy starts, otherwise it would cause
-  trouble to running servers. It only applies when a server has been previously
-  seen as failed.
-
-  Supported in default-server: Yes
-
-source <addr>[:<pl>[-<ph>]] [usesrc { <addr2>[:<port2>] | client | clientip } ]
-source <addr>[:<port>] [usesrc { <addr2>[:<port2>] | hdr_ip(<hdr>[,<occ>]) } ]
-source <addr>[:<pl>[-<ph>]] [interface <name>] ...
-  The "source" parameter sets the source address which will be used when
-  connecting to the server. It follows the exact same parameters and principle
-  as the backend "source" keyword, except that it only applies to the server
-  referencing it. Please consult the "source" keyword for details.
-
-  Additionally, the "source" statement on a server line allows one to specify a
-  source port range by indicating the lower and higher bounds delimited by a
-  dash ('-'). Some operating systems might require a valid IP address when a
-  source port range is specified. It is permitted to have the same IP/range for
-  several servers. Doing so makes it possible to bypass the maximum of 64k
-  total concurrent connections. The limit will then reach 64k connections per
-  server.
-
-  Supported in default-server: No
-
-track [<proxy>/]<server>
-  This option enables ability to set the current state of the server by
-  tracking another one. Only a server with checks enabled can be tracked
-  so it is not possible for example to track a server that tracks another
-  one. If <proxy> is omitted the current one is used. If disable-on-404 is
-  used, it has to be enabled on both proxies.
-
-  Supported in default-server: No
-
-weight <weight>
-  The "weight" parameter is used to adjust the server's weight relative to
-  other servers. All servers will receive a load proportional to their weight
-  relative to the sum of all weights, so the higher the weight, the higher the
-  load. The default weight is 1, and the maximal value is 256. A value of 0
-  means the server will not participate in load-balancing but will still accept
-  persistent connections. If this parameter is used to distribute the load
-  according to server's capacity, it is recommended to start with values which
-  can both grow and shrink, for instance between 10 and 100 to leave enough
-  room above and below for later adjustments.
-
-  Supported in default-server: Yes
-
-
-6. HTTP header manipulation
----------------------------
-
-In HTTP mode, it is possible to rewrite, add or delete some of the request and
-response headers based on regular expressions. It is also possible to block a
-request or a response if a particular header matches a regular expression,
-which is enough to stop most elementary protocol attacks, and to protect
-against information leak from the internal network. But there is a limitation
-to this : since HAProxy's HTTP engine does not support keep-alive, only headers
-passed during the first request of a TCP session will be seen. All subsequent
-headers will be considered data only and not analyzed. Furthermore, HAProxy
-never touches data contents, it stops analysis at the end of headers.
-
-There is an exception though. If HAProxy encounters an "Informational Response"
-(status code 1xx), it is able to process all rsp* rules which can allow, deny,
-rewrite or delete a header, but it will refuse to add a header to any such
-messages as this is not HTTP-compliant. The reason for still processing headers
-in such responses is to stop and/or fix any possible information leak which may
-happen, for instance because another downstream equipment would unconditionally
-add a header, or if a server name appears there. When such messages are seen,
-normal processing still occurs on the next non-informational messages.
-
-This section covers common usage of the following keywords, described in detail
-in section 4.2 :
-
-  - reqadd     <string>
-  - reqallow   <search>
-  - reqiallow  <search>
-  - reqdel     <search>
-  - reqidel    <search>
-  - reqdeny    <search>
-  - reqideny   <search>
-  - reqpass    <search>
-  - reqipass   <search>
-  - reqrep     <search> <replace>
-  - reqirep    <search> <replace>
-  - reqtarpit  <search>
-  - reqitarpit <search>
-  - rspadd     <string>
-  - rspdel     <search>
-  - rspidel    <search>
-  - rspdeny    <search>
-  - rspideny   <search>
-  - rsprep     <search> <replace>
-  - rspirep    <search> <replace>
-
-With all these keywords, the same conventions are used. The <search> parameter
-is a POSIX extended regular expression (regex) which supports grouping through
-parenthesis (without the backslash). Spaces and other delimiters must be
-prefixed with a backslash ('\') to avoid confusion with a field delimiter.
-Other characters may be prefixed with a backslash to change their meaning :
-
-  \t   for a tab
-  \r   for a carriage return (CR)
-  \n   for a new line (LF)
-  \    to mark a space and differentiate it from a delimiter
-  \#   to mark a sharp and differentiate it from a comment
-  \\   to use a backslash in a regex
-  \\\\ to use a backslash in the text (*2 for regex, *2 for haproxy)
-  \xXX to write the ASCII hex code XX as in the C language
-
-The <replace> parameter contains the string to be used to replace the largest
-portion of text matching the regex. It can make use of the special characters
-above, and can reference a substring which is delimited by parenthesis in the
-regex, by writing a backslash ('\') immediately followed by one digit from 0 to
-9 indicating the group position (0 designating the entire line). This practice
-is very common to users of the "sed" program.
-
-The <string> parameter represents the string which will systematically be added
-after the last header line. It can also use special character sequences above.
-
-Notes related to these keywords :
----------------------------------
-  - these keywords are not always convenient to allow/deny based on header
-    contents. It is strongly recommended to use ACLs with the "block" keyword
-    instead, resulting in far more flexible and manageable rules.
-
-  - lines are always considered as a whole. It is not possible to reference
-    a header name only or a value only. This is important because of the way
-    headers are written (notably the number of spaces after the colon).
-
-  - the first line is always considered as a header, which makes it possible to
-    rewrite or filter HTTP requests URIs or response codes, but in turn makes
-    it harder to distinguish between headers and request line. The regex prefix
-    ^[^\ \t]*[\ \t] matches any HTTP method followed by a space, and the prefix
-    ^[^ \t:]*: matches any header name followed by a colon.
-
-  - for performances reasons, the number of characters added to a request or to
-    a response is limited at build time to values between 1 and 4 kB. This
-    should normally be far more than enough for most usages. If it is too short
-    on occasional usages, it is possible to gain some space by removing some
-    useless headers before adding new ones.
-
-  - keywords beginning with "reqi" and "rspi" are the same as their counterpart
-    without the 'i' letter except that they ignore case when matching patterns.
-
-  - when a request passes through a frontend then a backend, all req* rules
-    from the frontend will be evaluated, then all req* rules from the backend
-    will be evaluated. The reverse path is applied to responses.
-
-  - req* statements are applied after "block" statements, so that "block" is
-    always the first one, but before "use_backend" in order to permit rewriting
-    before switching.
-
-
-7. Using ACLs and pattern extraction
-------------------------------------
-
-The use of Access Control Lists (ACL) provides a flexible solution to perform
-content switching and generally to take decisions based on content extracted
-from the request, the response or any environmental status. The principle is
-simple :
-
-  - define test criteria with sets of values
-  - perform actions only if a set of tests is valid
-
-The actions generally consist in blocking the request, or selecting a backend.
-
-In order to define a test, the "acl" keyword is used. The syntax is :
-
-   acl <aclname> <criterion> [flags] [operator] <value> ...
-
-This creates a new ACL <aclname> or completes an existing one with new tests.
-Those tests apply to the portion of request/response specified in <criterion>
-and may be adjusted with optional flags [flags]. Some criteria also support
-an operator which may be specified before the set of values. The values are
-of the type supported by the criterion, and are separated by spaces.
-
-ACL names must be formed from upper and lower case letters, digits, '-' (dash),
-'_' (underscore) , '.' (dot) and ':' (colon). ACL names are case-sensitive,
-which means that "my_acl" and "My_Acl" are two different ACLs.
-
-There is no enforced limit to the number of ACLs. The unused ones do not affect
-performance, they just consume a small amount of memory.
-
-The following ACL flags are currently supported :
-
-   -i : ignore case during matching of all subsequent patterns.
-   -f : load patterns from a file.
-   -- : force end of flags. Useful when a string looks like one of the flags.
-
-The "-f" flag is special as it loads all of the lines it finds in the file
-specified in argument and loads all of them before continuing. It is even
-possible to pass multiple "-f" arguments if the patterns are to be loaded from
-multiple files. Empty lines as well as lines beginning with a sharp ('#') will
-be ignored. All leading spaces and tabs will be stripped. If it is absolutely
-needed to insert a valid pattern beginning with a sharp, just prefix it with a
-space so that it is not taken for a comment. Depending on the data type and
-match method, haproxy may load the lines into a binary tree, allowing very fast
-lookups. This is true for IPv4 and exact string matching. In this case,
-duplicates will automatically be removed. Also, note that the "-i" flag applies
-to subsequent entries and not to entries loaded from files preceeding it. For
-instance :
-
-    acl valid-ua hdr(user-agent) -f exact-ua.lst -i -f generic-ua.lst  test
-
-In this example, each line of "exact-ua.lst" will be exactly matched against
-the "user-agent" header of the request. Then each line of "generic-ua" will be
-case-insensitively matched. Then the word "test" will be insensitively matched
-too.
-
-Note that right now it is difficult for the ACL parsers to report errors, so if
-a file is unreadable or unparsable, the most you'll get is a parse error in the
-ACL. Thus, file-based ACLs should only be produced by reliable processes.
-
-Supported types of values are :
-
-  - integers or integer ranges
-  - strings
-  - regular expressions
-  - IP addresses and networks
-
-
-7.1. Matching integers
-----------------------
-
-Matching integers is special in that ranges and operators are permitted. Note
-that integer matching only applies to positive values. A range is a value
-expressed with a lower and an upper bound separated with a colon, both of which
-may be omitted.
-
-For instance, "1024:65535" is a valid range to represent a range of
-unprivileged ports, and "1024:" would also work. "0:1023" is a valid
-representation of privileged ports, and ":1023" would also work.
-
-As a special case, some ACL functions support decimal numbers which are in fact
-two integers separated by a dot. This is used with some version checks for
-instance. All integer properties apply to those decimal numbers, including
-ranges and operators.
-
-For an easier usage, comparison operators are also supported. Note that using
-operators with ranges does not make much sense and is strongly discouraged.
-Similarly, it does not make much sense to perform order comparisons with a set
-of values.
-
-Available operators for integer matching are :
-
-  eq : true if the tested value equals at least one value
-  ge : true if the tested value is greater than or equal to at least one value
-  gt : true if the tested value is greater than at least one value
-  le : true if the tested value is less than or equal to at least one value
-  lt : true if the tested value is less than at least one value
-
-For instance, the following ACL matches any negative Content-Length header :
-
-  acl negative-length hdr_val(content-length) lt 0
-
-This one matches SSL versions between 3.0 and 3.1 (inclusive) :
-
-  acl sslv3 req_ssl_ver 3:3.1
-
-
-7.2. Matching strings
----------------------
-
-String matching applies to verbatim strings as they are passed, with the
-exception of the backslash ("\") which makes it possible to escape some
-characters such as the space. If the "-i" flag is passed before the first
-string, then the matching will be performed ignoring the case. In order
-to match the string "-i", either set it second, or pass the "--" flag
-before the first string. Same applies of course to match the string "--".
-
-
-7.3. Matching regular expressions (regexes)
--------------------------------------------
-
-Just like with string matching, regex matching applies to verbatim strings as
-they are passed, with the exception of the backslash ("\") which makes it
-possible to escape some characters such as the space. If the "-i" flag is
-passed before the first regex, then the matching will be performed ignoring
-the case. In order to match the string "-i", either set it second, or pass
-the "--" flag before the first string. Same principle applies of course to
-match the string "--".
-
-
-7.4. Matching IPv4 addresses
-----------------------------
-
-IPv4 addresses values can be specified either as plain addresses or with a
-netmask appended, in which case the IPv4 address matches whenever it is
-within the network. Plain addresses may also be replaced with a resolvable
-host name, but this practice is generally discouraged as it makes it more
-difficult to read and debug configurations. If hostnames are used, you should
-at least ensure that they are present in /etc/hosts so that the configuration
-does not depend on any random DNS match at the moment the configuration is
-parsed.
-
-
-7.5. Available matching criteria
---------------------------------
-
-7.5.1. Matching at Layer 4 and below
-------------------------------------
-
-A first set of criteria applies to information which does not require any
-analysis of the request or response contents. Those generally include TCP/IP
-addresses and ports, as well as internal values independant on the stream.
-
-always_false
-  This one never matches. All values and flags are ignored. It may be used as
-  a temporary replacement for another one when adjusting configurations.
-
-always_true
-  This one always matches. All values and flags are ignored. It may be used as
-  a temporary replacement for another one when adjusting configurations.
-
-avg_queue <integer>
-avg_queue(backend) <integer>
-  Returns the total number of queued connections of the designated backend
-  divided by the number of active servers. This is very similar to "queue"
-  except that the size of the farm is considered, in order to give a more
-  accurate measurement of the time it may take for a new connection to be
-  processed. The main usage is to return a sorry page to new users when it
-  becomes certain they will get a degraded service. Note that in the event
-  there would not be any active server anymore, we would consider twice the
-  number of queued connections as the measured value. This is a fair estimate,
-  as we expect one server to get back soon anyway, but we still prefer to send
-  new traffic to another backend if in better shape. See also the "queue",
-  "be_conn", and "be_sess_rate" criteria.
-
-be_conn <integer>
-be_conn(backend) <integer>
-  Applies to the number of currently established connections on the backend,
-  possibly including the connection being evaluated. If no backend name is
-  specified, the current one is used. But it is also possible to check another
-  backend. It can be used to use a specific farm when the nominal one is full.
-  See also the "fe_conn", "queue" and "be_sess_rate" criteria.
-
-be_id <integer>
-  Applies to the backend's id. Can be used in frontends to check from which
-  backend it was called.
-
-be_sess_rate <integer>
-be_sess_rate(backend) <integer>
-  Returns true when the sessions creation rate on the backend matches the
-  specified values or ranges, in number of new sessions per second. This is
-  used to switch to an alternate backend when an expensive or fragile one
-  reaches too high a session rate, or to limit abuse of service (eg. prevent
-  sucking of an online dictionary).
-
-  Example :
-        # Redirect to an error page if the dictionary is requested too often
-        backend dynamic
-            mode http
-            acl being_scanned be_sess_rate gt 100
-            redirect location /denied.html if being_scanned
-
-connslots <integer>
-connslots(backend) <integer>
-  The basic idea here is to be able to measure the number of connection "slots"
-  still available (connection + queue), so that anything beyond that (intended
-  usage; see "use_backend" keyword) can be redirected to a different backend.
-
-  'connslots' = number of available server connection slots, + number of
-  available server queue slots.
-
-  Note that while "fe_conn" may be used, "connslots" comes in especially
-  useful when you have a case of traffic going to one single ip, splitting into
-  multiple backends (perhaps using acls to do name-based load balancing) and
-  you want to be able to differentiate between different backends, and their
-  available "connslots".  Also, whereas "nbsrv" only measures servers that are
-  actually *down*, this acl is more fine-grained and looks into the number of
-  available connection slots as well. See also "queue" and "avg_queue".
-
-  OTHER CAVEATS AND NOTES: at this point in time, the code does not take care
-  of dynamic connections. Also, if any of the server maxconn, or maxqueue is 0,
-  then this acl clearly does not make sense, in which case the value returned
-  will be -1.
-
-dst <ip_address>
-  Applies to the local IPv4 address the client connected to. It can be used to
-  switch to a different backend for some alternative addresses.
-
-dst_conn <integer>
-  Applies to the number of currently established connections on the same socket
-  including the one being evaluated. It can be used to either return a sorry
-  page before hard-blocking, or to use a specific backend to drain new requests
-  when the socket is considered saturated. This offers the ability to assign
-  different limits to different listening ports or addresses. See also the
-  "fe_conn" and "be_conn" criteria.
-
-dst_port <integer>
-  Applies to the local port the client connected to. It can be used to switch
-  to a different backend for some alternative ports.
-
-fe_conn <integer>
-fe_conn(frontend) <integer>
-  Applies to the number of currently established connections on the frontend,
-  possibly including the connection being evaluated. If no frontend name is
-  specified, the current one is used. But it is also possible to check another
-  frontend. It can be used to either return a sorry page before hard-blocking,
-  or to use a specific backend to drain new requests when the farm is
-  considered saturated. See also the "dst_conn", "be_conn" and "fe_sess_rate"
-  criteria.
-
-fe_id <integer>
-  Applies to the frontend's id. Can be used in backends to check from which
-  frontend it was called.
-
-fe_sess_rate <integer>
-fe_sess_rate(frontend) <integer>
-  Returns true when the session creation rate on the current or the named
-  frontend matches the specified values or ranges, expressed in new sessions
-  per second. This is used to limit the connection rate to acceptable ranges in
-  order to prevent abuse of service at the earliest moment. This can be
-  combined with layer 4 ACLs in order to force the clients to wait a bit for
-  the rate to go down below the limit.
-
-  Example :
-        # This frontend limits incoming mails to 10/s with a max of 100
-        # concurrent connections. We accept any connection below 10/s, and
-        # force excess clients to wait for 100 ms. Since clients are limited to
-        # 100 max, there cannot be more than 10 incoming mails per second.
-        frontend mail
-            bind :25
-            mode tcp
-            maxconn 100
-            acl too_fast fe_sess_rate ge 10
-            tcp-request inspect-delay 100ms
-            tcp-request content accept if ! too_fast
-            tcp-request content accept if WAIT_END
-
-nbsrv <integer>
-nbsrv(backend) <integer>
-  Returns true when the number of usable servers of either the current backend
-  or the named backend matches the values or ranges specified. This is used to
-  switch to an alternate backend when the number of servers is too low to
-  to handle some load. It is useful to report a failure when combined with
-  "monitor fail".
-
-queue <integer>
-queue(backend) <integer>
-  Returns the total number of queued connections of the designated backend,
-  including all the connections in server queues. If no backend name is
-  specified, the current one is used, but it is also possible to check another
-  one. This can be used to take actions when queuing goes above a known level,
-  generally indicating a surge of traffic or a massive slowdown on the servers.
-  One possible action could be to reject new users but still accept old ones.
-  See also the "avg_queue", "be_conn", and "be_sess_rate" criteria.
-
-so_id <integer>
-  Applies to the socket's id. Useful in frontends with many bind keywords.
-
-src <ip_address>
-  Applies to the client's IPv4 address. It is usually used to limit access to
-  certain resources such as statistics. Note that it is the TCP-level source
-  address which is used, and not the address of a client behind a proxy.
-
-src_port <integer>
-  Applies to the client's TCP source port. This has a very limited usage.
-
-srv_id <integer>
-  Applies to the server's id. Can be used in frontends or backends.
-
-srv_is_up(<server>)
-srv_is_up(<backend>/<server>)
-  Returns true when the designated server is UP, and false when it is either
-  DOWN or in maintenance mode. If <backend> is omitted, then the server is
-  looked up in the current backend. The function takes no arguments since it
-  is used as a boolean. It is mainly used to take action based on an external
-  status reported via a health check (eg: a geographical site's availability).
-  Another possible use which is more of a hack consists in using dummy servers
-  as boolean variables that can be enabled or disabled from the CLI, so that
-  rules depending on those ACLs can be tweaked in realtime.
-
-
-7.5.2. Matching contents at Layer 4
------------------------------------
-
-A second set of criteria depends on data found in buffers, but which can change
-during analysis. This requires that some data has been buffered, for instance
-through TCP request content inspection. Please see the "tcp-request" keyword
-for more detailed information on the subject.
-
-req_len <integer>
-  Returns true when the length of the data in the request buffer matches the
-  specified range. It is important to understand that this test does not
-  return false as long as the buffer is changing. This means that a check with
-  equality to zero will almost always immediately match at the beginning of the
-  session, while a test for more data will wait for that data to come in and
-  return false only when haproxy is certain that no more data will come in.
-  This test was designed to be used with TCP request content inspection.
-
-req_proto_http
-  Returns true when data in the request buffer look like HTTP and correctly
-  parses as such. It is the same parser as the common HTTP request parser which
-  is used so there should be no surprises. This test can be used for instance
-  to direct HTTP traffic to a given port and HTTPS traffic to another one
-  using TCP request content inspection rules.
-
-req_rdp_cookie       <string>
-req_rdp_cookie(name) <string>
-  Returns true when data in the request buffer look like the RDP protocol, and
-  a cookie is present and equal to <string>. By default, any cookie name is
-  checked, but a specific cookie name can be specified in parenthesis. The
-  parser only checks for the first cookie, as illustrated in the RDP protocol
-  specification. The cookie name is case insensitive. This ACL can be useful
-  with the "MSTS" cookie, as it can contain the user name of the client
-  connecting to the server if properly configured on the client. This can be
-  used to restrict access to certain servers to certain users.
-
-req_rdp_cookie_cnt       <integer>
-req_rdp_cookie_cnt(name) <integer>
-  Returns true when the data in the request buffer look like the RDP protocol
-  and the number of RDP cookies matches the specified range (typically zero or
-  one). Optionally a specific cookie name can be checked. This is a simple way
-  of detecting the RDP protocol, as clients generally send the MSTS or MSTSHASH
-  cookies.
-
-req_ssl_ver <decimal>
-  Returns true when data in the request buffer look like SSL, with a protocol
-  version matching the specified range. Both SSLv2 hello messages and SSLv3
-  messages are supported. The test tries to be strict enough to avoid being
-  easily fooled. In particular, it waits for as many bytes as announced in the
-  message header if this header looks valid (bound to the buffer size). Note
-  that TLSv1 is announced as SSL version 3.1. This test was designed to be used
-  with TCP request content inspection.
-
-wait_end
-  Waits for the end of the analysis period to return true. This may be used in
-  conjunction with content analysis to avoid returning a wrong verdict early.
-  It may also be used to delay some actions, such as a delayed reject for some
-  special addresses. Since it either stops the rules evaluation or immediately
-  returns true, it is recommended to use this acl as the last one in a rule.
-  Please note that the default ACL "WAIT_END" is always usable without prior
-  declaration. This test was designed to be used with TCP request content
-  inspection.
-
-  Examples :
-     # delay every incoming request by 2 seconds
-     tcp-request inspect-delay 2s
-     tcp-request content accept if WAIT_END
-
-     # don't immediately tell bad guys they are rejected
-     tcp-request inspect-delay 10s
-     acl goodguys src 10.0.0.0/24
-     acl badguys  src 10.0.1.0/24
-     tcp-request content accept if goodguys
-     tcp-request content reject if badguys WAIT_END
-     tcp-request content reject
-
-
-7.5.3. Matching at Layer 7
---------------------------
-
-A third set of criteria applies to information which can be found at the
-application layer (layer 7). Those require that a full HTTP request has been
-read, and are only evaluated then. They may require slightly more CPU resources
-than the layer 4 ones, but not much since the request and response are indexed.
-
-hdr <string>
-hdr(header) <string>
-  Note: all the "hdr*" matching criteria either apply to all headers, or to a
-  particular header whose name is passed between parenthesis and without any
-  space. The header name is not case-sensitive. The header matching complies
-  with RFC2616, and treats as separate headers all values delimited by commas.
-  Use the shdr() variant for response headers sent by the server.
-
-  The "hdr" criteria returns true if any of the headers matching the criteria
-  match any of the strings. This can be used to check exact for values. For
-  instance, checking that "connection: close" is set :
-
-     hdr(Connection) -i close
-
-hdr_beg <string>
-hdr_beg(header) <string>
-  Returns true when one of the headers begins with one of the strings. See
-  "hdr" for more information on header matching. Use the shdr_beg() variant for
-  response headers sent by the server.
-
-hdr_cnt <integer>
-hdr_cnt(header) <integer>
-  Returns true when the number of occurrence of the specified header matches
-  the values or ranges specified. It is important to remember that one header
-  line may count as several headers if it has several values. This is used to
-  detect presence, absence or abuse of a specific header, as well as to block
-  request smuggling attacks by rejecting requests which contain more than one
-  of certain headers. See "hdr" for more information on header matching. Use
-  the shdr_cnt() variant for response headers sent by the server.
-
-hdr_dir <string>
-hdr_dir(header) <string>
-  Returns true when one of the headers contains one of the strings either
-  isolated or delimited by slashes. This is used to perform filename or
-  directory name matching, and may be used with Referer. See "hdr" for more
-  information on header matching. Use the shdr_dir() variant for response
-  headers sent by the server.
-
-hdr_dom <string>
-hdr_dom(header) <string>
-  Returns true when one of the headers contains one of the strings either
-  isolated or delimited by dots. This is used to perform domain name matching,
-  and may be used with the Host header. See "hdr" for more information on
-  header matching. Use the shdr_dom() variant for response headers sent by the
-  server.
-
-hdr_end <string>
-hdr_end(header) <string>
-  Returns true when one of the headers ends with one of the strings. See "hdr"
-  for more information on header matching. Use the shdr_end() variant for
-  response headers sent by the server.
-
-hdr_ip <ip_address>
-hdr_ip(header) <ip_address>
-  Returns true when one of the headers' values contains an IP address matching
-  <ip_address>. This is mainly used with headers such as X-Forwarded-For or
-  X-Client-IP. See "hdr" for more information on header matching. Use the
-  shdr_ip() variant for response headers sent by the server.
-
-hdr_len <integer>
-hdr_len(<header>) <integer>
-  Returns true when at least one of the headers has a length which matches the
-  values or ranges specified. This may be used to detect empty or too large
-  headers. See "hdr" for more information on header matching. Use the
-  shdr_len() variant for response headers sent by the server.
-
-hdr_reg <regex>
-hdr_reg(header) <regex>
-  Returns true when one of the headers matches of the regular expressions. It
-  can be used at any time, but it is important to remember that regex matching
-  is slower than other methods. See also other "hdr_" criteria, as well as
-  "hdr" for more information on header matching. Use the shdr_reg() variant for
-  response headers sent by the server.
-
-hdr_sub <string>
-hdr_sub(header) <string>
-  Returns true when one of the headers contains one of the strings. See "hdr"
-  for more information on header matching. Use the shdr_sub() variant for
-  response headers sent by the server.
-
-hdr_val <integer>
-hdr_val(header) <integer>
-  Returns true when one of the headers starts with a number which matches the
-  values or ranges specified. This may be used to limit content-length to
-  acceptable values for example. See "hdr" for more information on header
-  matching. Use the shdr_val() variant for response headers sent by the server.
-
-http_auth(userlist)
-http_auth_group(userlist) <group> [<group>]*
-  Returns true when authentication data received from the client matches
-  username & password stored on the userlist. It is also possible to
-  use http_auth_group to check if the user is assigned to at least one
-  of specified groups.
-
-  Currently only http basic auth is supported.
-
-http_first_req
-  Returns true when the request being processed is the first one of the
-  connection. This can be used to add or remove headers that may be missing
-  from some requests when a request is not the first one, or even to perform
-  some specific ACL checks only on the first request.
-
-method <string>
-  Applies to the method in the HTTP request, eg: "GET". Some predefined ACL
-  already check for most common methods.
-
-path <string>
-  Returns true when the path part of the request, which starts at the first
-  slash and ends before the question mark, equals one of the strings. It may be
-  used to match known files, such as /favicon.ico.
-
-path_beg <string>
-  Returns true when the path begins with one of the strings. This can be used
-  to send certain directory names to alternative backends.
-
-path_dir <string>
-  Returns true when one of the strings is found isolated or delimited with
-  slashes in the path. This is used to perform filename or directory name
-  matching without the risk of wrong match due to colliding prefixes. See also
-  "url_dir" and "path_sub".
-
-path_dom <string>
-  Returns true when one of the strings is found isolated or delimited with dots
-  in the path. This may be used to perform domain name matching in proxy
-  requests. See also "path_sub" and "url_dom".
-
-path_end <string>
-  Returns true when the path ends with one of the strings. This may be used to
-  control file name extension.
-
-path_len <integer>
-  Returns true when the path length matches the values or ranges specified.
-  This may be used to detect abusive requests for instance.
-
-path_reg <regex>
-  Returns true when the path matches one of the regular expressions. It can be
-  used any time, but it is important to remember that regex matching is slower
-  than other methods. See also "url_reg" and all "path_" criteria.
-
-path_sub <string>
-  Returns true when the path contains one of the strings. It can be used to
-  detect particular patterns in paths, such as "../" for example. See also
-  "path_dir".
-
-req_ver <string>
-  Applies to the version string in the HTTP request, eg: "1.0". Some predefined
-  ACL already check for versions 1.0 and 1.1.
-
-status <integer>
-  Applies to the HTTP status code in the HTTP response, eg: "302". It can be
-  used to act on responses depending on status ranges, for instance, remove
-  any Location header if the response is not a 3xx.
-
-url <string>
-  Applies to the whole URL passed in the request. The only real use is to match
-  "*", for which there already is a predefined ACL.
-
-url_beg <string>
-  Returns true when the URL begins with one of the strings. This can be used to
-  check whether a URL begins with a slash or with a protocol scheme.
-
-url_dir <string>
-  Returns true when one of the strings is found isolated or delimited with
-  slashes in the URL. This is used to perform filename or directory name
-  matching without the risk of wrong match due to colliding prefixes. See also
-  "path_dir" and "url_sub".
-
-url_dom <string>
-  Returns true when one of the strings is found isolated or delimited with dots
-  in the URL. This is used to perform domain name matching without the risk of
-  wrong match due to colliding prefixes. See also "url_sub".
-
-url_end <string>
-  Returns true when the URL ends with one of the strings. It has very limited
-  use. "path_end" should be used instead for filename matching.
-
-url_ip <ip_address>
-  Applies to the IP address specified in the absolute URI in an HTTP request.
-  It can be used to prevent access to certain resources such as local network.
-  It is useful with option "http_proxy".
-
-url_len <integer>
-  Returns true when the url length matches the values or ranges specified. This
-  may be used to detect abusive requests for instance.
-
-url_port <integer>
-  Applies to the port specified in the absolute URI in an HTTP request. It can
-  be used to prevent access to certain resources. It is useful with option
-  "http_proxy". Note that if the port is not specified in the request, port 80
-  is assumed.
-
-url_reg <regex>
-  Returns true when the URL matches one of the regular expressions. It can be
-  used any time, but it is important to remember that regex matching is slower
-  than other methods. See also "path_reg" and all "url_" criteria.
-
-url_sub <string>
-  Returns true when the URL contains one of the strings. It can be used to
-  detect particular patterns in query strings for example. See also "path_sub".
-
-
-7.6. Pre-defined ACLs
----------------------
-
-Some predefined ACLs are hard-coded so that they do not have to be declared in
-every frontend which needs them. They all have their names in upper case in
-order to avoid confusion. Their equivalence is provided below.
-
-ACL name          Equivalent to                Usage
----------------+-----------------------------+---------------------------------
-FALSE            always_false                  never match
-HTTP             req_proto_http                match if protocol is valid HTTP
-HTTP_1.0         req_ver 1.0                   match HTTP version 1.0
-HTTP_1.1         req_ver 1.1                   match HTTP version 1.1
-HTTP_CONTENT     hdr_val(content-length) gt 0  match an existing content-length
-HTTP_URL_ABS     url_reg ^[^/:]*://            match absolute URL with scheme
-HTTP_URL_SLASH   url_beg /                     match URL beginning with "/"
-HTTP_URL_STAR    url     *                     match URL equal to "*"
-LOCALHOST        src 127.0.0.1/8               match connection from local host
-METH_CONNECT     method  CONNECT               match HTTP CONNECT method
-METH_GET         method  GET HEAD              match HTTP GET or HEAD method
-METH_HEAD        method  HEAD                  match HTTP HEAD method
-METH_OPTIONS     method  OPTIONS               match HTTP OPTIONS method
-METH_POST        method  POST                  match HTTP POST method
-METH_TRACE       method  TRACE                 match HTTP TRACE method
-RDP_COOKIE       req_rdp_cookie_cnt gt 0       match presence of an RDP cookie
-REQ_CONTENT      req_len gt 0                  match data in the request buffer
-TRUE             always_true                   always match
-WAIT_END         wait_end                      wait for end of content analysis
----------------+-----------------------------+---------------------------------
-
-
-7.7. Using ACLs to form conditions
-----------------------------------
-
-Some actions are only performed upon a valid condition. A condition is a
-combination of ACLs with operators. 3 operators are supported :
-
-  - AND (implicit)
-  - OR  (explicit with the "or" keyword or the "||" operator)
-  - Negation with the exclamation mark ("!")
-
-A condition is formed as a disjunctive form:
-
-   [!]acl1 [!]acl2 ... [!]acln  { or [!]acl1 [!]acl2 ... [!]acln } ...
-
-Such conditions are generally used after an "if" or "unless" statement,
-indicating when the condition will trigger the action.
-
-For instance, to block HTTP requests to the "*" URL with methods other than
-"OPTIONS", as well as POST requests without content-length, and GET or HEAD
-requests with a content-length greater than 0, and finally every request which
-is not either GET/HEAD/POST/OPTIONS !
-
-   acl missing_cl hdr_cnt(Content-length) eq 0
-   block if HTTP_URL_STAR !METH_OPTIONS || METH_POST missing_cl
-   block if METH_GET HTTP_CONTENT
-   block unless METH_GET or METH_POST or METH_OPTIONS
-
-To select a different backend for requests to static contents on the "www" site
-and to every request on the "img", "video", "download" and "ftp" hosts :
-
-   acl url_static  path_beg         /static /images /img /css
-   acl url_static  path_end         .gif .png .jpg .css .js
-   acl host_www    hdr_beg(host) -i www
-   acl host_static hdr_beg(host) -i img. video. download. ftp.
-
-   # now use backend "static" for all static-only hosts, and for static urls
-   # of host "www". Use backend "www" for the rest.
-   use_backend static if host_static or host_www url_static
-   use_backend www    if host_www
-
-It is also possible to form rules using "anonymous ACLs". Those are unnamed ACL
-expressions that are built on the fly without needing to be declared. They must
-be enclosed between braces, with a space before and after each brace (because
-the braces must be seen as independant words). Example :
-
-   The following rule :
-
-       acl missing_cl hdr_cnt(Content-length) eq 0
-       block if METH_POST missing_cl
-
-   Can also be written that way :
-
-       block if METH_POST { hdr_cnt(Content-length) eq 0 }
-
-It is generally not recommended to use this construct because it's a lot easier
-to leave errors in the configuration when written that way. However, for very
-simple rules matching only one source IP address for instance, it can make more
-sense to use them than to declare ACLs with random names. Another example of
-good use is the following :
-
-   With named ACLs :
-
-        acl site_dead nbsrv(dynamic) lt 2
-        acl site_dead nbsrv(static)  lt 2
-        monitor fail  if site_dead
-
-   With anonymous ACLs :
-
-        monitor fail if { nbsrv(dynamic) lt 2 } || { nbsrv(static) lt 2 }
-
-See section 4.2 for detailed help on the "block" and "use_backend" keywords.
-
-
-7.8. Pattern extraction
------------------------
-
-The stickiness features relies on pattern extraction in the request and
-response. Sometimes the data needs to be converted first before being stored,
-for instance converted from ASCII to IP or upper case to lower case.
-
-All these operations of data extraction and conversion are defined as
-"pattern extraction rules". A pattern rule always has the same format. It
-begins with a single pattern fetch word, potentially followed by a list of
-arguments within parenthesis then an optional list of transformations. As
-much as possible, the pattern fetch functions use the same name as their
-equivalent used in ACLs.
-
-The list of currently supported pattern fetch functions is the following :
-
-  src          This is the source IPv4 address of the client of the session.
-               It is of type IP and only works with such tables.
-
-  dst          This is the destination IPv4 address of the session on the
-               client side, which is the address the client connected to.
-               It can be useful when running in transparent mode. It is of
-               type IP and only works with such tables.
-
-  dst_port     This is the destination TCP port of the session on the client
-               side, which is the port the client connected to. This might be
-               used when running in transparent mode or when assigning dynamic
-               ports to some clients for a whole application session. It is of
-               type integer and only works with such tables.
-
-  hdr(name)    This extracts the last occurrence of header <name> in an HTTP
-               request and converts it to an IP address. This IP address is
-               then used to match the table. A typical use is with the
-               x-forwarded-for header.
-
-
-The currently available list of transformations include :
-
-  lower        Convert a string pattern to lower case. This can only be placed
-               after a string pattern fetch function or after a conversion
-               function returning a string type. The result is of type string.
-
-  upper        Convert a string pattern to upper case. This can only be placed
-               after a string pattern fetch function or after a conversion
-               function returning a string type. The result is of type string.
-
-  ipmask(mask) Apply a mask to an IPv4 address, and use the result for lookups
-               and storage. This can be used to make all hosts within a
-               certain mask to share the same table entries and as such use
-               the same server. The mask can be passed in dotted form (eg:
-               255.255.255.0) or in CIDR form (eg: 24).
-
-
-8. Logging
-----------
-
-One of HAProxy's strong points certainly lies is its precise logs. It probably
-provides the finest level of information available for such a product, which is
-very important for troubleshooting complex environments. Standard information
-provided in logs include client ports, TCP/HTTP state timers, precise session
-state at termination and precise termination cause, information about decisions
-to direct traffic to a server, and of course the ability to capture arbitrary
-headers.
-
-In order to improve administrators reactivity, it offers a great transparency
-about encountered problems, both internal and external, and it is possible to
-send logs to different sources at the same time with different level filters :
-
-  - global process-level logs (system errors, start/stop, etc..)
-  - per-instance system and internal errors (lack of resource, bugs, ...)
-  - per-instance external troubles (servers up/down, max connections)
-  - per-instance activity (client connections), either at the establishment or
-    at the termination.
-
-The ability to distribute different levels of logs to different log servers
-allow several production teams to interact and to fix their problems as soon
-as possible. For example, the system team might monitor system-wide errors,
-while the application team might be monitoring the up/down for their servers in
-real time, and the security team might analyze the activity logs with one hour
-delay.
-
-
-8.1. Log levels
----------------
-
-TCP and HTTP connections can be logged with information such as the date, time,
-source IP address, destination address, connection duration, response times,
-HTTP request, HTTP return code, number of bytes transmitted, conditions
-in which the session ended, and even exchanged cookies values. For example
-track a particular user's problems. All messages may be sent to up to two
-syslog servers. Check the "log" keyword in section 4.2 for more information
-about log facilities.
-
-
-8.2. Log formats
-----------------
-
-HAProxy supports 4 log formats. Several fields are common between these formats
-and will be detailed in the following sections. A few of them may vary
-slightly with the configuration, due to indicators specific to certain
-options. The supported formats are as follows :
-
-  - the default format, which is very basic and very rarely used. It only
-    provides very basic information about the incoming connection at the moment
-    it is accepted : source IP:port, destination IP:port, and frontend-name.
-    This mode will eventually disappear so it will not be described to great
-    extents.
-
-  - the TCP format, which is more advanced. This format is enabled when "option
-    tcplog" is set on the frontend. HAProxy will then usually wait for the
-    connection to terminate before logging. This format provides much richer
-    information, such as timers, connection counts, queue size, etc... This
-    format is recommended for pure TCP proxies.
-
-  - the HTTP format, which is the most advanced for HTTP proxying. This format
-    is enabled when "option httplog" is set on the frontend. It provides the
-    same information as the TCP format with some HTTP-specific fields such as
-    the request, the status code, and captures of headers and cookies. This
-    format is recommended for HTTP proxies.
-
-  - the CLF HTTP format, which is equivalent to the HTTP format, but with the
-    fields arranged in the same order as the CLF format. In this mode, all
-    timers, captures, flags, etc... appear one per field after the end of the
-    common fields, in the same order they appear in the standard HTTP format.
-
-Next sections will go deeper into details for each of these formats. Format
-specification will be performed on a "field" basis. Unless stated otherwise, a
-field is a portion of text delimited by any number of spaces. Since syslog
-servers are susceptible of inserting fields at the beginning of a line, it is
-always assumed that the first field is the one containing the process name and
-identifier.
-
-Note : Since log lines may be quite long, the log examples in sections below
-       might be broken into multiple lines. The example log lines will be
-       prefixed with 3 closing angle brackets ('>>>') and each time a log is
-       broken into multiple lines, each non-final line will end with a
-       backslash ('\') and the next line will start indented by two characters.
-
-
-8.2.1. Default log format
--------------------------
-
-This format is used when no specific option is set. The log is emitted as soon
-as the connection is accepted. One should note that this currently is the only
-format which logs the request's destination IP and ports.
-
-  Example :
-        listen www
-            mode http
-            log global
-            server srv1 127.0.0.1:8000
-
-    >>> Feb  6 12:12:09 localhost \
-          haproxy[14385]: Connect from 10.0.1.2:33312 to 10.0.3.31:8012 \
-          (www/HTTP)
-
-  Field   Format                                Extract from the example above
-      1   process_name '[' pid ']:'                            haproxy[14385]:
-      2   'Connect from'                                          Connect from
-      3   source_ip ':' source_port                             10.0.1.2:33312
-      4   'to'                                                              to
-      5   destination_ip ':' destination_port                   10.0.3.31:8012
-      6   '(' frontend_name '/' mode ')'                            (www/HTTP)
-
-Detailed fields description :
-  - "source_ip" is the IP address of the client which initiated the connection.
-  - "source_port" is the TCP port of the client which initiated the connection.
-  - "destination_ip" is the IP address the client connected to.
-  - "destination_port" is the TCP port the client connected to.
-  - "frontend_name" is the name of the frontend (or listener) which received
-    and processed the connection.
-  - "mode is the mode the frontend is operating (TCP or HTTP).
-
-It is advised not to use this deprecated format for newer installations as it
-will eventually disappear.
-
-
-8.2.2. TCP log format
----------------------
-
-The TCP format is used when "option tcplog" is specified in the frontend, and
-is the recommended format for pure TCP proxies. It provides a lot of precious
-information for troubleshooting. Since this format includes timers and byte
-counts, the log is normally emitted at the end of the session. It can be
-emitted earlier if "option logasap" is specified, which makes sense in most
-environments with long sessions such as remote terminals. Sessions which match
-the "monitor" rules are never logged. It is also possible not to emit logs for
-sessions for which no data were exchanged between the client and the server, by
-specifying "option dontlognull" in the frontend. Successful connections will
-not be logged if "option dontlog-normal" is specified in the frontend. A few
-fields may slightly vary depending on some configuration options, those are
-marked with a star ('*') after the field name below.
-
-  Example :
-        frontend fnt
-            mode tcp
-            option tcplog
-            log global
-            default_backend bck
-
-        backend bck
-            server srv1 127.0.0.1:8000
-
-    >>> Feb  6 12:12:56 localhost \
-          haproxy[14387]: 10.0.1.2:33313 [06/Feb/2009:12:12:51.443] fnt \
-          bck/srv1 0/0/5007 212 -- 0/0/0/0/3 0/0
-
-  Field   Format                                Extract from the example above
-      1   process_name '[' pid ']:'                            haproxy[14387]:
-      2   client_ip ':' client_port                             10.0.1.2:33313
-      3   '[' accept_date ']'                       [06/Feb/2009:12:12:51.443]
-      4   frontend_name                                                    fnt
-      5   backend_name '/' server_name                                bck/srv1
-      6   Tw '/' Tc '/' Tt*                                           0/0/5007
-      7   bytes_read*                                                      212
-      8   termination_state                                                 --
-      9   actconn '/' feconn '/' beconn '/' srv_conn '/' retries*    0/0/0/0/3
-     10   srv_queue '/' backend_queue                                      0/0
-
-Detailed fields description :
-  - "client_ip" is the IP address of the client which initiated the TCP
-    connection to haproxy. Note that when the connection is accepted on a
-    socket configured with "accept-proxy" and the PROXY protocol is correctly
-    used, then the logs will reflect the forwarded connection's information.
-
-  - "client_port" is the TCP port of the client which initiated the connection.
-
-  - "accept_date" is the exact date when the connection was received by haproxy
-    (which might be very slightly different from the date observed on the
-    network if there was some queuing in the system's backlog). This is usually
-    the same date which may appear in any upstream firewall's log.
-
-  - "frontend_name" is the name of the frontend (or listener) which received
-    and processed the connection.
-
-  - "backend_name" is the name of the backend (or listener) which was selected
-    to manage the connection to the server. This will be the same as the
-    frontend if no switching rule has been applied, which is common for TCP
-    applications.
-
-  - "server_name" is the name of the last server to which the connection was
-    sent, which might differ from the first one if there were connection errors
-    and a redispatch occurred. Note that this server belongs to the backend
-    which processed the request. If the connection was aborted before reaching
-    a server, "<NOSRV>" is indicated instead of a server name.
-
-  - "Tw" is the total time in milliseconds spent waiting in the various queues.
-    It can be "-1" if the connection was aborted before reaching the queue.
-    See "Timers" below for more details.
-
-  - "Tc" is the total time in milliseconds spent waiting for the connection to
-    establish to the final server, including retries. It can be "-1" if the
-    connection was aborted before a connection could be established. See
-    "Timers" below for more details.
-
-  - "Tt" is the total time in milliseconds elapsed between the accept and the
-    last close. It covers all possible processings. There is one exception, if
-    "option logasap" was specified, then the time counting stops at the moment
-    the log is emitted. In this case, a '+' sign is prepended before the value,
-    indicating that the final one will be larger. See "Timers" below for more
-    details.
-
-  - "bytes_read" is the total number of bytes transmitted from the server to
-    the client when the log is emitted. If "option logasap" is specified, the
-    this value will be prefixed with a '+' sign indicating that the final one
-    may be larger. Please note that this value is a 64-bit counter, so log
-    analysis tools must be able to handle it without overflowing.
-
-  - "termination_state" is the condition the session was in when the session
-    ended. This indicates the session state, which side caused the end of
-    session to happen, and for what reason (timeout, error, ...). The normal
-    flags should be "--", indicating the session was closed by either end with
-    no data remaining in buffers. See below "Session state at disconnection"
-    for more details.
-
-  - "actconn" is the total number of concurrent connections on the process when
-    the session was logged. It it useful to detect when some per-process system
-    limits have been reached. For instance, if actconn is close to 512 when
-    multiple connection errors occur, chances are high that the system limits
-    the process to use a maximum of 1024 file descriptors and that all of them
-    are used. See section 3 "Global parameters" to find how to tune the system.
-
-  - "feconn" is the total number of concurrent connections on the frontend when
-    the session was logged. It is useful to estimate the amount of resource
-    required to sustain high loads, and to detect when the frontend's "maxconn"
-    has been reached. Most often when this value increases by huge jumps, it is
-    because there is congestion on the backend servers, but sometimes it can be
-    caused by a denial of service attack.
-
-  - "beconn" is the total number of concurrent connections handled by the
-    backend when the session was logged. It includes the total number of
-    concurrent connections active on servers as well as the number of
-    connections pending in queues. It is useful to estimate the amount of
-    additional servers needed to support high loads for a given application.
-    Most often when this value increases by huge jumps, it is because there is
-    congestion on the backend servers, but sometimes it can be caused by a
-    denial of service attack.
-
-  - "srv_conn" is the total number of concurrent connections still active on
-    the server when the session was logged. It can never exceed the server's
-    configured "maxconn" parameter. If this value is very often close or equal
-    to the server's "maxconn", it means that traffic regulation is involved a
-    lot, meaning that either the server's maxconn value is too low, or that
-    there aren't enough servers to process the load with an optimal response
-    time. When only one of the server's "srv_conn" is high, it usually means
-    that this server has some trouble causing the connections to take longer to
-    be processed than on other servers.
-
-  - "retries" is the number of connection retries experienced by this session
-    when trying to connect to the server. It must normally be zero, unless a
-    server is being stopped at the same moment the connection was attempted.
-    Frequent retries generally indicate either a network problem between
-    haproxy and the server, or a misconfigured system backlog on the server
-    preventing new connections from being queued. This field may optionally be
-    prefixed with a '+' sign, indicating that the session has experienced a
-    redispatch after the maximal retry count has been reached on the initial
-    server. In this case, the server name appearing in the log is the one the
-    connection was redispatched to, and not the first one, though both may
-    sometimes be the same in case of hashing for instance. So as a general rule
-    of thumb, when a '+' is present in front of the retry count, this count
-    should not be attributed to the logged server.
-
-  - "srv_queue" is the total number of requests which were processed before
-    this one in the server queue. It is zero when the request has not gone
-    through the server queue. It makes it possible to estimate the approximate
-    server's response time by dividing the time spent in queue by the number of
-    requests in the queue. It is worth noting that if a session experiences a
-    redispatch and passes through two server queues, their positions will be
-    cumulated. A request should not pass through both the server queue and the
-    backend queue unless a redispatch occurs.
-
-  - "backend_queue" is the total number of requests which were processed before
-    this one in the backend's global queue. It is zero when the request has not
-    gone through the global queue. It makes it possible to estimate the average
-    queue length, which easily translates into a number of missing servers when
-    divided by a server's "maxconn" parameter. It is worth noting that if a
-    session experiences a redispatch, it may pass twice in the backend's queue,
-    and then both positions will be cumulated. A request should not pass
-    through both the server queue and the backend queue unless a redispatch
-    occurs.
-
-
-8.2.3. HTTP log format
-----------------------
-
-The HTTP format is the most complete and the best suited for HTTP proxies. It
-is enabled by when "option httplog" is specified in the frontend. It provides
-the same level of information as the TCP format with additional features which
-are specific to the HTTP protocol. Just like the TCP format, the log is usually
-emitted at the end of the session, unless "option logasap" is specified, which
-generally only makes sense for download sites. A session which matches the
-"monitor" rules will never logged. It is also possible not to log sessions for
-which no data were sent by the client by specifying "option dontlognull" in the
-frontend. Successful connections will not be logged if "option dontlog-normal"
-is specified in the frontend.
-
-Most fields are shared with the TCP log, some being different. A few fields may
-slightly vary depending on some configuration options. Those ones are marked
-with a star ('*') after the field name below.
-
-  Example :
-        frontend http-in
-            mode http
-            option httplog
-            log global
-            default_backend bck
-
-        backend static
-            server srv1 127.0.0.1:8000
-
-    >>> Feb  6 12:14:14 localhost \
-          haproxy[14389]: 10.0.1.2:33317 [06/Feb/2009:12:14:14.655] http-in \
-          static/srv1 10/0/30/69/109 200 2750 - - ---- 1/1/1/1/0 0/0 {1wt.eu} \
-          {} "GET /index.html HTTP/1.1"
-
-  Field   Format                                Extract from the example above
-      1   process_name '[' pid ']:'                            haproxy[14389]:
-      2   client_ip ':' client_port                             10.0.1.2:33317
-      3   '[' accept_date ']'                       [06/Feb/2009:12:14:14.655]
-      4   frontend_name                                                http-in
-      5   backend_name '/' server_name                             static/srv1
-      6   Tq '/' Tw '/' Tc '/' Tr '/' Tt*                       10/0/30/69/109
-      7   status_code                                                      200
-      8   bytes_read*                                                     2750
-      9   captured_request_cookie                                            -
-     10   captured_response_cookie                                           -
-     11   termination_state                                               ----
-     12   actconn '/' feconn '/' beconn '/' srv_conn '/' retries*    1/1/1/1/0
-     13   srv_queue '/' backend_queue                                      0/0
-     14   '{' captured_request_headers* '}'                   {haproxy.1wt.eu}
-     15   '{' captured_response_headers* '}'                                {}
-     16   '"' http_request '"'                      "GET /index.html HTTP/1.1"
-
-
-Detailed fields description :
-  - "client_ip" is the IP address of the client which initiated the TCP
-    connection to haproxy. Note that when the connection is accepted on a
-    socket configured with "accept-proxy" and the PROXY protocol is correctly
-    used, then the logs will reflect the forwarded connection's information.
-
-  - "client_port" is the TCP port of the client which initiated the connection.
-
-  - "accept_date" is the exact date when the TCP connection was received by
-    haproxy (which might be very slightly different from the date observed on
-    the network if there was some queuing in the system's backlog). This is
-    usually the same date which may appear in any upstream firewall's log. This
-    does not depend on the fact that the client has sent the request or not.
-
-  - "frontend_name" is the name of the frontend (or listener) which received
-    and processed the connection.
-
-  - "backend_name" is the name of the backend (or listener) which was selected
-    to manage the connection to the server. This will be the same as the
-    frontend if no switching rule has been applied.
-
-  - "server_name" is the name of the last server to which the connection was
-    sent, which might differ from the first one if there were connection errors
-    and a redispatch occurred. Note that this server belongs to the backend
-    which processed the request. If the request was aborted before reaching a
-    server, "<NOSRV>" is indicated instead of a server name. If the request was
-    intercepted by the stats subsystem, "<STATS>" is indicated instead.
-
-  - "Tq" is the total time in milliseconds spent waiting for the client to send
-    a full HTTP request, not counting data. It can be "-1" if the connection
-    was aborted before a complete request could be received. It should always
-    be very small because a request generally fits in one single packet. Large
-    times here generally indicate network trouble between the client and
-    haproxy. See "Timers" below for more details.
-
-  - "Tw" is the total time in milliseconds spent waiting in the various queues.
-    It can be "-1" if the connection was aborted before reaching the queue.
-    See "Timers" below for more details.
-
-  - "Tc" is the total time in milliseconds spent waiting for the connection to
-    establish to the final server, including retries. It can be "-1" if the
-    request was aborted before a connection could be established. See "Timers"
-    below for more details.
-
-  - "Tr" is the total time in milliseconds spent waiting for the server to send
-    a full HTTP response, not counting data. It can be "-1" if the request was
-    aborted before a complete response could be received. It generally matches
-    the server's processing time for the request, though it may be altered by
-    the amount of data sent by the client to the server. Large times here on
-    "GET" requests generally indicate an overloaded server. See "Timers" below
-    for more details.
-
-  - "Tt" is the total time in milliseconds elapsed between the accept and the
-    last close. It covers all possible processings. There is one exception, if
-    "option logasap" was specified, then the time counting stops at the moment
-    the log is emitted. In this case, a '+' sign is prepended before the value,
-    indicating that the final one will be larger. See "Timers" below for more
-    details.
-
-  - "status_code" is the HTTP status code returned to the client. This status
-    is generally set by the server, but it might also be set by haproxy when
-    the server cannot be reached or when its response is blocked by haproxy.
-
-  - "bytes_read" is the total number of bytes transmitted to the client when
-    the log is emitted. This does include HTTP headers. If "option logasap" is
-    specified, the this value will be prefixed with a '+' sign indicating that
-    the final one may be larger. Please note that this value is a 64-bit
-    counter, so log analysis tools must be able to handle it without
-    overflowing.
-
-  - "captured_request_cookie" is an optional "name=value" entry indicating that
-    the client had this cookie in the request. The cookie name and its maximum
-    length are defined by the "capture cookie" statement in the frontend
-    configuration. The field is a single dash ('-') when the option is not
-    set. Only one cookie may be captured, it is generally used to track session
-    ID exchanges between a client and a server to detect session crossing
-    between clients due to application bugs. For more details, please consult
-    the section "Capturing HTTP headers and cookies" below.
-
-  - "captured_response_cookie" is an optional "name=value" entry indicating
-    that the server has returned a cookie with its response. The cookie name
-    and its maximum length are defined by the "capture cookie" statement in the
-    frontend configuration. The field is a single dash ('-') when the option is
-    not set. Only one cookie may be captured, it is generally used to track
-    session ID exchanges between a client and a server to detect session
-    crossing between clients due to application bugs. For more details, please
-    consult the section "Capturing HTTP headers and cookies" below.
-
-  - "termination_state" is the condition the session was in when the session
-    ended. This indicates the session state, which side caused the end of
-    session to happen, for what reason (timeout, error, ...), just like in TCP
-    logs, and information about persistence operations on cookies in the last
-    two characters. The normal flags should begin with "--", indicating the
-    session was closed by either end with no data remaining in buffers. See
-    below "Session state at disconnection" for more details.
-
-  - "actconn" is the total number of concurrent connections on the process when
-    the session was logged. It it useful to detect when some per-process system
-    limits have been reached. For instance, if actconn is close to 512 or 1024
-    when multiple connection errors occur, chances are high that the system
-    limits the process to use a maximum of 1024 file descriptors and that all
-    of them are used. See section 3 "Global parameters" to find how to tune the
-    system.
-
-  - "feconn" is the total number of concurrent connections on the frontend when
-    the session was logged. It is useful to estimate the amount of resource
-    required to sustain high loads, and to detect when the frontend's "maxconn"
-    has been reached. Most often when this value increases by huge jumps, it is
-    because there is congestion on the backend servers, but sometimes it can be
-    caused by a denial of service attack.
-
-  - "beconn" is the total number of concurrent connections handled by the
-    backend when the session was logged. It includes the total number of
-    concurrent connections active on servers as well as the number of
-    connections pending in queues. It is useful to estimate the amount of
-    additional servers needed to support high loads for a given application.
-    Most often when this value increases by huge jumps, it is because there is
-    congestion on the backend servers, but sometimes it can be caused by a
-    denial of service attack.
-
-  - "srv_conn" is the total number of concurrent connections still active on
-    the server when the session was logged. It can never exceed the server's
-    configured "maxconn" parameter. If this value is very often close or equal
-    to the server's "maxconn", it means that traffic regulation is involved a
-    lot, meaning that either the server's maxconn value is too low, or that
-    there aren't enough servers to process the load with an optimal response
-    time. When only one of the server's "srv_conn" is high, it usually means
-    that this server has some trouble causing the requests to take longer to be
-    processed than on other servers.
-
-  - "retries" is the number of connection retries experienced by this session
-    when trying to connect to the server. It must normally be zero, unless a
-    server is being stopped at the same moment the connection was attempted.
-    Frequent retries generally indicate either a network problem between
-    haproxy and the server, or a misconfigured system backlog on the server
-    preventing new connections from being queued. This field may optionally be
-    prefixed with a '+' sign, indicating that the session has experienced a
-    redispatch after the maximal retry count has been reached on the initial
-    server. In this case, the server name appearing in the log is the one the
-    connection was redispatched to, and not the first one, though both may
-    sometimes be the same in case of hashing for instance. So as a general rule
-    of thumb, when a '+' is present in front of the retry count, this count
-    should not be attributed to the logged server.
-
-  - "srv_queue" is the total number of requests which were processed before
-    this one in the server queue. It is zero when the request has not gone
-    through the server queue. It makes it possible to estimate the approximate
-    server's response time by dividing the time spent in queue by the number of
-    requests in the queue. It is worth noting that if a session experiences a
-    redispatch and passes through two server queues, their positions will be
-    cumulated. A request should not pass through both the server queue and the
-    backend queue unless a redispatch occurs.
-
-  - "backend_queue" is the total number of requests which were processed before
-    this one in the backend's global queue. It is zero when the request has not
-    gone through the global queue. It makes it possible to estimate the average
-    queue length, which easily translates into a number of missing servers when
-    divided by a server's "maxconn" parameter. It is worth noting that if a
-    session experiences a redispatch, it may pass twice in the backend's queue,
-    and then both positions will be cumulated. A request should not pass
-    through both the server queue and the backend queue unless a redispatch
-    occurs.
-
-  - "captured_request_headers" is a list of headers captured in the request due
-    to the presence of the "capture request header" statement in the frontend.
-    Multiple headers can be captured, they will be delimited by a vertical bar
-    ('|'). When no capture is enabled, the braces do not appear, causing a
-    shift of remaining fields. It is important to note that this field may
-    contain spaces, and that using it requires a smarter log parser than when
-    it's not used. Please consult the section "Capturing HTTP headers and
-    cookies" below for more details.
-
-  - "captured_response_headers" is a list of headers captured in the response
-    due to the presence of the "capture response header" statement in the
-    frontend. Multiple headers can be captured, they will be delimited by a
-    vertical bar ('|'). When no capture is enabled, the braces do not appear,
-    causing a shift of remaining fields. It is important to note that this
-    field may contain spaces, and that using it requires a smarter log parser
-    than when it's not used. Please consult the section "Capturing HTTP headers
-    and cookies" below for more details.
-
-  - "http_request" is the complete HTTP request line, including the method,
-    request and HTTP version string. Non-printable characters are encoded (see
-    below the section "Non-printable characters"). This is always the last
-    field, and it is always delimited by quotes and is the only one which can
-    contain quotes. If new fields are added to the log format, they will be
-    added before this field. This field might be truncated if the request is
-    huge and does not fit in the standard syslog buffer (1024 characters). This
-    is the reason why this field must always remain the last one.
-
-
-8.3. Advanced logging options
------------------------------
-
-Some advanced logging options are often looked for but are not easy to find out
-just by looking at the various options. Here is an entry point for the few
-options which can enable better logging. Please refer to the keywords reference
-for more information about their usage.
-
-
-8.3.1. Disabling logging of external tests
-------------------------------------------
-
-It is quite common to have some monitoring tools perform health checks on
-haproxy. Sometimes it will be a layer 3 load-balancer such as LVS or any
-commercial load-balancer, and sometimes it will simply be a more complete
-monitoring system such as Nagios. When the tests are very frequent, users often
-ask how to disable logging for those checks. There are three possibilities :
-
-  - if connections come from everywhere and are just TCP probes, it is often
-    desired to simply disable logging of connections without data exchange, by
-    setting "option dontlognull" in the frontend. It also disables logging of
-    port scans, which may or may not be desired.
-
-  - if the connection come from a known source network, use "monitor-net" to
-    declare this network as monitoring only. Any host in this network will then
-    only be able to perform health checks, and their requests will not be
-    logged. This is generally appropriate to designate a list of equipments
-    such as other load-balancers.
-
-  - if the tests are performed on a known URI, use "monitor-uri" to declare
-    this URI as dedicated to monitoring. Any host sending this request will
-    only get the result of a health-check, and the request will not be logged.
-
-
-8.3.2. Logging before waiting for the session to terminate
-----------------------------------------------------------
-
-The problem with logging at end of connection is that you have no clue about
-what is happening during very long sessions, such as remote terminal sessions
-or large file downloads. This problem can be worked around by specifying
-"option logasap" in the frontend. Haproxy will then log as soon as possible,
-just before data transfer begins. This means that in case of TCP, it will still
-log the connection status to the server, and in case of HTTP, it will log just
-after processing the server headers. In this case, the number of bytes reported
-is the number of header bytes sent to the client. In order to avoid confusion
-with normal logs, the total time field and the number of bytes are prefixed
-with a '+' sign which means that real numbers are certainly larger.
-
-
-8.3.3. Raising log level upon errors
-------------------------------------
-
-Sometimes it is more convenient to separate normal traffic from errors logs,
-for instance in order to ease error monitoring from log files. When the option
-"log-separate-errors" is used, connections which experience errors, timeouts,
-retries, redispatches or HTTP status codes 5xx will see their syslog level
-raised from "info" to "err". This will help a syslog daemon store the log in
-a separate file. It is very important to keep the errors in the normal traffic
-file too, so that log ordering is not altered. You should also be careful if
-you already have configured your syslog daemon to store all logs higher than
-"notice" in an "admin" file, because the "err" level is higher than "notice".
-
-
-8.3.4. Disabling logging of successful connections
---------------------------------------------------
-
-Although this may sound strange at first, some large sites have to deal with
-multiple thousands of logs per second and are experiencing difficulties keeping
-them intact for a long time or detecting errors within them. If the option
-"dontlog-normal" is set on the frontend, all normal connections will not be
-logged. In this regard, a normal connection is defined as one without any
-error, timeout, retry nor redispatch. In HTTP, the status code is checked too,
-and a response with a status 5xx is not considered normal and will be logged
-too. Of course, doing is is really discouraged as it will remove most of the
-useful information from the logs. Do this only if you have no other
-alternative.
-
-
-8.4. Timing events
-------------------
-
-Timers provide a great help in troubleshooting network problems. All values are
-reported in milliseconds (ms). These timers should be used in conjunction with
-the session termination flags. In TCP mode with "option tcplog" set on the
-frontend, 3 control points are reported under the form "Tw/Tc/Tt", and in HTTP
-mode, 5 control points are reported under the form "Tq/Tw/Tc/Tr/Tt" :
-
-  - Tq: total time to get the client request (HTTP mode only). It's the time
-    elapsed between the moment the client connection was accepted and the
-    moment the proxy received the last HTTP header. The value "-1" indicates
-    that the end of headers (empty line) has never been seen. This happens when
-    the client closes prematurely or times out.
-
-  - Tw: total time spent in the queues waiting for a connection slot. It
-    accounts for backend queue as well as the server queues, and depends on the
-    queue size, and the time needed for the server to complete previous
-    requests. The value "-1" means that the request was killed before reaching
-    the queue, which is generally what happens with invalid or denied requests.
-
-  - Tc: total time to establish the TCP connection to the server. It's the time
-    elapsed between the moment the proxy sent the connection request, and the
-    moment it was acknowledged by the server, or between the TCP SYN packet and
-    the matching SYN/ACK packet in return. The value "-1" means that the
-    connection never established.
-
-  - Tr: server response time (HTTP mode only). It's the time elapsed between
-    the moment the TCP connection was established to the server and the moment
-    the server sent its complete response headers. It purely shows its request
-    processing time, without the network overhead due to the data transmission.
-    It is worth noting that when the client has data to send to the server, for
-    instance during a POST request, the time already runs, and this can distort
-    apparent response time. For this reason, it's generally wise not to trust
-    too much this field for POST requests initiated from clients behind an
-    untrusted network. A value of "-1" here means that the last the response
-    header (empty line) was never seen, most likely because the server timeout
-    stroke before the server managed to process the request.
-
-  - Tt: total session duration time, between the moment the proxy accepted it
-    and the moment both ends were closed. The exception is when the "logasap"
-    option is specified. In this case, it only equals (Tq+Tw+Tc+Tr), and is
-    prefixed with a '+' sign. From this field, we can deduce "Td", the data
-    transmission time, by substracting other timers when valid :
-
-        Td = Tt - (Tq + Tw + Tc + Tr)
-
-    Timers with "-1" values have to be excluded from this equation. In TCP
-    mode, "Tq" and "Tr" have to be excluded too. Note that "Tt" can never be
-    negative.
-
-These timers provide precious indications on trouble causes. Since the TCP
-protocol defines retransmit delays of 3, 6, 12... seconds, we know for sure
-that timers close to multiples of 3s are nearly always related to lost packets
-due to network problems (wires, negotiation, congestion). Moreover, if "Tt" is
-close to a timeout value specified in the configuration, it often means that a
-session has been aborted on timeout.
-
-Most common cases :
-
-  - If "Tq" is close to 3000, a packet has probably been lost between the
-    client and the proxy. This is very rare on local networks but might happen
-    when clients are on far remote networks and send large requests. It may
-    happen that values larger than usual appear here without any network cause.
-    Sometimes, during an attack or just after a resource starvation has ended,
-    haproxy may accept thousands of connections in a few milliseconds. The time
-    spent accepting these connections will inevitably slightly delay processing
-    of other connections, and it can happen that request times in the order of
-    a few tens of milliseconds are measured after a few thousands of new
-    connections have been accepted at once. Setting "option http-server-close"
-    may display larger request times since "Tq" also measures the time spent
-    waiting for additional requests.
-
-  - If "Tc" is close to 3000, a packet has probably been lost between the
-    server and the proxy during the server connection phase. This value should
-    always be very low, such as 1 ms on local networks and less than a few tens
-    of ms on remote networks.
-
-  - If "Tr" is nearly always lower than 3000 except some rare values which seem
-    to be the average majored by 3000, there are probably some packets lost
-    between the proxy and the server.
-
-  - If "Tt" is large even for small byte counts, it generally is because
-    neither the client nor the server decides to close the connection, for
-    instance because both have agreed on a keep-alive connection mode. In order
-    to solve this issue, it will be needed to specify "option httpclose" on
-    either the frontend or the backend. If the problem persists, it means that
-    the server ignores the "close" connection mode and expects the client to
-    close. Then it will be required to use "option forceclose". Having the
-    smallest possible 'Tt' is important when connection regulation is used with
-    the "maxconn" option on the servers, since no new connection will be sent
-    to the server until another one is released.
-
-Other noticeable HTTP log cases ('xx' means any value to be ignored) :
-
-  Tq/Tw/Tc/Tr/+Tt  The "option logasap" is present on the frontend and the log
-                   was emitted before the data phase. All the timers are valid
-                   except "Tt" which is shorter than reality.
-
-  -1/xx/xx/xx/Tt   The client was not able to send a complete request in time
-                   or it aborted too early. Check the session termination flags
-                   then "timeout http-request" and "timeout client" settings.
-
-  Tq/-1/xx/xx/Tt   It was not possible to process the request, maybe because
-                   servers were out of order, because the request was invalid
-                   or forbidden by ACL rules. Check the session termination
-                   flags.
-
-  Tq/Tw/-1/xx/Tt   The connection could not establish on the server. Either it
-                   actively refused it or it timed out after Tt-(Tq+Tw) ms.
-                   Check the session termination flags, then check the
-                   "timeout connect" setting. Note that the tarpit action might
-                   return similar-looking patterns, with "Tw" equal to the time
-                   the client connection was maintained open.
-
-  Tq/Tw/Tc/-1/Tt   The server has accepted the connection but did not return
-                   a complete response in time, or it closed its connexion
-                   unexpectedly after Tt-(Tq+Tw+Tc) ms. Check the session
-                   termination flags, then check the "timeout server" setting.
-
-
-8.5. Session state at disconnection
------------------------------------
-
-TCP and HTTP logs provide a session termination indicator in the
-"termination_state" field, just before the number of active connections. It is
-2-characters long in TCP mode, and is extended to 4 characters in HTTP mode,
-each of which has a special meaning :
-
-  - On the first character, a code reporting the first event which caused the
-    session to terminate :
-
-        C : the TCP session was unexpectedly aborted by the client.
-
-        S : the TCP session was unexpectedly aborted by the server, or the
-            server explicitly refused it.
-
-        P : the session was prematurely aborted by the proxy, because of a
-            connection limit enforcement, because a DENY filter was matched,
-            because of a security check which detected and blocked a dangerous
-            error in server response which might have caused information leak
-            (eg: cacheable cookie), or because the response was processed by
-            the proxy (redirect, stats, etc...).
-
-        R : a resource on the proxy has been exhausted (memory, sockets, source
-            ports, ...). Usually, this appears during the connection phase, and
-            system logs should contain a copy of the precise error. If this
-            happens, it must be considered as a very serious anomaly which
-            should be fixed as soon as possible by any means.
-
-        I : an internal error was identified by the proxy during a self-check.
-            This should NEVER happen, and you are encouraged to report any log
-            containing this, because this would almost certainly be a bug. It
-            would be wise to preventively restart the process after such an
-            event too, in case it would be caused by memory corruption.
-
-        c : the client-side timeout expired while waiting for the client to
-            send or receive data.
-
-        s : the server-side timeout expired while waiting for the server to
-            send or receive data.
-
-        - : normal session completion, both the client and the server closed
-            with nothing left in the buffers.
-
-  - on the second character, the TCP or HTTP session state when it was closed :
-
-        R : the proxy was waiting for a complete, valid REQUEST from the client
-            (HTTP mode only). Nothing was sent to any server.
-
-        Q : the proxy was waiting in the QUEUE for a connection slot. This can
-            only happen when servers have a 'maxconn' parameter set. It can
-            also happen in the global queue after a redispatch consecutive to
-            a failed attempt to connect to a dying server. If no redispatch is
-            reported, then no connection attempt was made to any server.
-
-        C : the proxy was waiting for the CONNECTION to establish on the
-            server. The server might at most have noticed a connection attempt.
-
-        H : the proxy was waiting for complete, valid response HEADERS from the
-            server (HTTP only).
-
-        D : the session was in the DATA phase.
-
-        L : the proxy was still transmitting LAST data to the client while the
-            server had already finished. This one is very rare as it can only
-            happen when the client dies while receiving the last packets.
-
-        T : the request was tarpitted. It has been held open with the client
-            during the whole "timeout tarpit" duration or until the client
-            closed, both of which will be reported in the "Tw" timer.
-
-        - : normal session completion after end of data transfer.
-
-  - the third character tells whether the persistence cookie was provided by
-    the client (only in HTTP mode) :
-
-        N : the client provided NO cookie. This is usually the case for new
-            visitors, so counting the number of occurrences of this flag in the
-            logs generally indicate a valid trend for the site frequentation.
-
-        I : the client provided an INVALID cookie matching no known server.
-            This might be caused by a recent configuration change, mixed
-            cookies between HTTP/HTTPS sites, persistence conditionally
-            ignored, or an attack.
-
-        D : the client provided a cookie designating a server which was DOWN,
-            so either "option persist" was used and the client was sent to
-            this server, or it was not set and the client was redispatched to
-            another server.
-
-        V : the client provided a VALID cookie, and was sent to the associated
-            server.
-
-        E : the client provided a valid cookie, but with a last date which was
-            older than what is allowed by the "maxidle" cookie parameter, so
-            the cookie is consider EXPIRED and is ignored. The request will be
-            redispatched just as if there was no cookie.
-
-        O : the client provided a valid cookie, but with a first date which was
-            older than what is allowed by the "maxlife" cookie parameter, so
-            the cookie is consider too OLD and is ignored. The request will be
-            redispatched just as if there was no cookie.
-
-        - : does not apply (no cookie set in configuration).
-
-  - the last character reports what operations were performed on the persistence
-    cookie returned by the server (only in HTTP mode) :
-
-        N : NO cookie was provided by the server, and none was inserted either.
-
-        I : no cookie was provided by the server, and the proxy INSERTED one.
-            Note that in "cookie insert" mode, if the server provides a cookie,
-            it will still be overwritten and reported as "I" here.
-
-        U : the proxy UPDATED the last date in the cookie that was presented by
-            the client. This can only happen in insert mode with "maxidle". It
-            happens everytime there is activity at a different date than the
-            date indicated in the cookie. If any other change happens, such as
-            a redispatch, then the cookie will be marked as inserted instead.
-
-        P : a cookie was PROVIDED by the server and transmitted as-is.
-
-        R : the cookie provided by the server was REWRITTEN by the proxy, which
-            happens in "cookie rewrite" or "cookie prefix" modes.
-
-        D : the cookie provided by the server was DELETED by the proxy.
-
-        - : does not apply (no cookie set in configuration).
-
-The combination of the two first flags gives a lot of information about what
-was happening when the session terminated, and why it did terminate. It can be
-helpful to detect server saturation, network troubles, local system resource
-starvation, attacks, etc...
-
-The most common termination flags combinations are indicated below. They are
-alphabetically sorted, with the lowercase set just after the upper case for
-easier finding and understanding.
-
-  Flags   Reason
-
-     --   Normal termination.
-
-     CC   The client aborted before the connection could be established to the
-          server. This can happen when haproxy tries to connect to a recently
-          dead (or unchecked) server, and the client aborts while haproxy is
-          waiting for the server to respond or for "timeout connect" to expire.
-
-     CD   The client unexpectedly aborted during data transfer. This can be
-          caused by a browser crash, by an intermediate equipment between the
-          client and haproxy which decided to actively break the connection,
-          by network routing issues between the client and haproxy, or by a
-          keep-alive session between the server and the client terminated first
-          by the client.
-
-     cD   The client did not send nor acknowledge any data for as long as the
-          "timeout client" delay. This is often caused by network failures on
-          the client side, or the client simply leaving the net uncleanly.
-
-     CH   The client aborted while waiting for the server to start responding.
-          It might be the server taking too long to respond or the client
-          clicking the 'Stop' button too fast.
-
-     cH   The "timeout client" stroke while waiting for client data during a
-          POST request. This is sometimes caused by too large TCP MSS values
-          for PPPoE networks which cannot transport full-sized packets. It can
-          also happen when client timeout is smaller than server timeout and
-          the server takes too long to respond.
-
-     CQ   The client aborted while its session was queued, waiting for a server
-          with enough empty slots to accept it. It might be that either all the
-          servers were saturated or that the assigned server was taking too
-          long a time to respond.
-
-     CR   The client aborted before sending a full HTTP request. Most likely
-          the request was typed by hand using a telnet client, and aborted
-          too early. The HTTP status code is likely a 400 here. Sometimes this
-          might also be caused by an IDS killing the connection between haproxy
-          and the client.
-
-     cR   The "timeout http-request" stroke before the client sent a full HTTP
-          request. This is sometimes caused by too large TCP MSS values on the
-          client side for PPPoE networks which cannot transport full-sized
-          packets, or by clients sending requests by hand and not typing fast
-          enough, or forgetting to enter the empty line at the end of the
-          request. The HTTP status code is likely a 408 here.
-
-     CT   The client aborted while its session was tarpitted. It is important to
-          check if this happens on valid requests, in order to be sure that no
-          wrong tarpit rules have been written. If a lot of them happen, it
-          might make sense to lower the "timeout tarpit" value to something
-          closer to the average reported "Tw" timer, in order not to consume
-          resources for just a few attackers.
-
-     SC   The server or an equipment between it and haproxy explicitly refused
-          the TCP connection (the proxy received a TCP RST or an ICMP message
-          in return). Under some circumstances, it can also be the network
-          stack telling the proxy that the server is unreachable (eg: no route,
-          or no ARP response on local network). When this happens in HTTP mode,
-          the status code is likely a 502 or 503 here.
-
-     sC   The "timeout connect" stroke before a connection to the server could
-          complete. When this happens in HTTP mode, the status code is likely a
-          503 or 504 here.
-
-     SD   The connection to the server died with an error during the data
-          transfer. This usually means that haproxy has received an RST from
-          the server or an ICMP message from an intermediate equipment while
-          exchanging data with the server. This can be caused by a server crash
-          or by a network issue on an intermediate equipment.
-
-     sD   The server did not send nor acknowledge any data for as long as the
-          "timeout server" setting during the data phase. This is often caused
-          by too short timeouts on L4 equipments before the server (firewalls,
-          load-balancers, ...), as well as keep-alive sessions maintained
-          between the client and the server expiring first on haproxy.
-
-     SH   The server aborted before sending its full HTTP response headers, or
-          it crashed while processing the request. Since a server aborting at
-          this moment is very rare, it would be wise to inspect its logs to
-          control whether it crashed and why. The logged request may indicate a
-          small set of faulty requests, demonstrating bugs in the application.
-          Sometimes this might also be caused by an IDS killing the connection
-          between haproxy and the server.
-
-     sH   The "timeout server" stroke before the server could return its
-          response headers. This is the most common anomaly, indicating too
-          long transactions, probably caused by server or database saturation.
-          The immediate workaround consists in increasing the "timeout server"
-          setting, but it is important to keep in mind that the user experience
-          will suffer from these long response times. The only long term
-          solution is to fix the application.
-
-     sQ   The session spent too much time in queue and has been expired. See
-          the "timeout queue" and "timeout connect" settings to find out how to
-          fix this if it happens too often. If it often happens massively in
-          short periods, it may indicate general problems on the affected
-          servers due to I/O or database congestion, or saturation caused by
-          external attacks.
-
-     PC   The proxy refused to establish a connection to the server because the
-          process' socket limit has been reached while attempting to connect.
-          The global "maxconn" parameter may be increased in the configuration
-          so that it does not happen anymore. This status is very rare and
-          might happen when the global "ulimit-n" parameter is forced by hand.
-
-     PD   The proxy blocked an incorrectly formatted chunked encoded message in
-          a request or a response, after the server has emitted its headers. In
-          most cases, this will indicate an invalid message from the server to
-          the client.
-
-     PH   The proxy blocked the server's response, because it was invalid,
-          incomplete, dangerous (cache control), or matched a security filter.
-          In any case, an HTTP 502 error is sent to the client. One possible
-          cause for this error is an invalid syntax in an HTTP header name
-          containing unauthorized characters. It is also possible but quite
-          rare, that the proxy blocked a chunked-encoding request from the
-          client due to an invalid syntax, before the server responded. In this
-          case, an HTTP 400 error is sent to the client and reported in the
-          logs.
-
-     PR   The proxy blocked the client's HTTP request, either because of an
-          invalid HTTP syntax, in which case it returned an HTTP 400 error to
-          the client, or because a deny filter matched, in which case it
-          returned an HTTP 403 error.
-
-     PT   The proxy blocked the client's request and has tarpitted its
-          connection before returning it a 500 server error. Nothing was sent
-          to the server. The connection was maintained open for as long as
-          reported by the "Tw" timer field.
-
-     RC   A local resource has been exhausted (memory, sockets, source ports)
-          preventing the connection to the server from establishing. The error
-          logs will tell precisely what was missing. This is very rare and can
-          only be solved by proper system tuning.
-
-The combination of the two last flags gives a lot of information about how
-persistence was handled by the client, the server and by haproxy. This is very
-important to troubleshoot disconnections, when users complain they have to
-re-authenticate. The commonly encountered flags are :
-
-     --   Persistence cookie is not enabled.
-
-     NN   No cookie was provided by the client, none was inserted in the
-          response. For instance, this can be in insert mode with "postonly"
-          set on a GET request.
-
-     II   A cookie designating an invalid server was provided by the client,
-          a valid one was inserted in the response. This typically happens when
-          a "server" entry is removed from the configuraton, since its cookie
-          value can be presented by a client when no other server knows it.
-
-     NI   No cookie was provided by the client, one was inserted in the
-          response. This typically happens for first requests from every user
-          in "insert" mode, which makes it an easy way to count real users.
-
-     VN   A cookie was provided by the client, none was inserted in the
-          response. This happens for most responses for which the client has
-          already got a cookie.
-
-     VU   A cookie was provided by the client, with a last visit date which is
-          not completely up-to-date, so an updated cookie was provided in
-          response. This can also happen if there was no date at all, or if
-          there was a date but the "maxidle" parameter was not set, so that the
-          cookie can be switched to unlimited time.
-
-     EI   A cookie was provided by the client, with a last visit date which is
-          too old for the "maxidle" parameter, so the cookie was ignored and a
-          new cookie was inserted in the response.
-
-     OI   A cookie was provided by the client, with a first visit date which is
-          too old for the "maxlife" parameter, so the cookie was ignored and a
-          new cookie was inserted in the response.
-
-     DI   The server designated by the cookie was down, a new server was
-          selected and a new cookie was emitted in the response.
-
-     VI   The server designated by the cookie was not marked dead but could not
-          be reached. A redispatch happened and selected another one, which was
-          then advertised in the response.
-
-
-8.6. Non-printable characters
------------------------------
-
-In order not to cause trouble to log analysis tools or terminals during log
-consulting, non-printable characters are not sent as-is into log files, but are
-converted to the two-digits hexadecimal representation of their ASCII code,
-prefixed by the character '#'. The only characters that can be logged without
-being escaped are comprised between 32 and 126 (inclusive). Obviously, the
-escape character '#' itself is also encoded to avoid any ambiguity ("#23"). It
-is the same for the character '"' which becomes "#22", as well as '{', '|' and
-'}' when logging headers.
-
-Note that the space character (' ') is not encoded in headers, which can cause
-issues for tools relying on space count to locate fields. A typical header
-containing spaces is "User-Agent".
-
-Last, it has been observed that some syslog daemons such as syslog-ng escape
-the quote ('"') with a backslash ('\'). The reverse operation can safely be
-performed since no quote may appear anywhere else in the logs.
-
-
-8.7. Capturing HTTP cookies
----------------------------
-
-Cookie capture simplifies the tracking a complete user session. This can be
-achieved using the "capture cookie" statement in the frontend. Please refer to
-section 4.2 for more details. Only one cookie can be captured, and the same
-cookie will simultaneously be checked in the request ("Cookie:" header) and in
-the response ("Set-Cookie:" header). The respective values will be reported in
-the HTTP logs at the "captured_request_cookie" and "captured_response_cookie"
-locations (see section 8.2.3 about HTTP log format). When either cookie is
-not seen, a dash ('-') replaces the value. This way, it's easy to detect when a
-user switches to a new session for example, because the server will reassign it
-a new cookie. It is also possible to detect if a server unexpectedly sets a
-wrong cookie to a client, leading to session crossing.
-
-  Examples :
-        # capture the first cookie whose name starts with "ASPSESSION"
-        capture cookie ASPSESSION len 32
-
-        # capture the first cookie whose name is exactly "vgnvisitor"
-        capture cookie vgnvisitor= len 32
-
-
-8.8. Capturing HTTP headers
----------------------------
-
-Header captures are useful to track unique request identifiers set by an upper
-proxy, virtual host names, user-agents, POST content-length, referrers, etc. In
-the response, one can search for information about the response length, how the
-server asked the cache to behave, or an object location during a redirection.
-
-Header captures are performed using the "capture request header" and "capture
-response header" statements in the frontend. Please consult their definition in
-section 4.2 for more details.
-
-It is possible to include both request headers and response headers at the same
-time. Non-existent headers are logged as empty strings, and if one header
-appears more than once, only its last occurrence will be logged. Request headers
-are grouped within braces '{' and '}' in the same order as they were declared,
-and delimited with a vertical bar '|' without any space. Response headers
-follow the same representation, but are displayed after a space following the
-request headers block. These blocks are displayed just before the HTTP request
-in the logs.
-
-  Example :
-        # This instance chains to the outgoing proxy
-        listen proxy-out
-            mode http
-            option httplog
-            option logasap
-            log global
-            server cache1 192.168.1.1:3128
-
-            # log the name of the virtual server
-            capture request  header Host len 20
-
-            # log the amount of data uploaded during a POST
-            capture request  header Content-Length len 10
-
-            # log the beginning of the referrer
-            capture request  header Referer len 20
-
-            # server name (useful for outgoing proxies only)
-            capture response header Server len 20
-
-            # logging the content-length is useful with "option logasap"
-            capture response header Content-Length len 10
-
-            # log the expected cache behaviour on the response
-            capture response header Cache-Control len 8
-
-            # the Via header will report the next proxy's name
-            capture response header Via len 20
-
-            # log the URL location during a redirection
-            capture response header Location len 20
-
-    >>> Aug  9 20:26:09 localhost \
-          haproxy[2022]: 127.0.0.1:34014 [09/Aug/2004:20:26:09] proxy-out \
-          proxy-out/cache1 0/0/0/162/+162 200 +350 - - ---- 0/0/0/0/0 0/0 \
-          {fr.adserver.yahoo.co||http://fr.f416.mail.} {|864|private||} \
-          "GET http://fr.adserver.yahoo.com/"
-
-    >>> Aug  9 20:30:46 localhost \
-          haproxy[2022]: 127.0.0.1:34020 [09/Aug/2004:20:30:46] proxy-out \
-          proxy-out/cache1 0/0/0/182/+182 200 +279 - - ---- 0/0/0/0/0 0/0 \
-          {w.ods.org||} {Formilux/0.1.8|3495|||} \
-          "GET http://trafic.1wt.eu/ HTTP/1.1"
-
-    >>> Aug  9 20:30:46 localhost \
-          haproxy[2022]: 127.0.0.1:34028 [09/Aug/2004:20:30:46] proxy-out \
-          proxy-out/cache1 0/0/2/126/+128 301 +223 - - ---- 0/0/0/0/0 0/0 \
-          {www.sytadin.equipement.gouv.fr||http://trafic.1wt.eu/} \
-          {Apache|230|||http://www.sytadin.} \
-          "GET http://www.sytadin.equipement.gouv.fr/ HTTP/1.1"
-
-
-8.9. Examples of logs
----------------------
-
-These are real-world examples of logs accompanied with an explanation. Some of
-them have been made up by hand. The syslog part has been removed for better
-reading. Their sole purpose is to explain how to decipher them.
-
-    >>> haproxy[674]: 127.0.0.1:33318 [15/Oct/2003:08:31:57.130] px-http \
-          px-http/srv1 6559/0/7/147/6723 200 243 - - ---- 5/3/3/1/0 0/0 \
-          "HEAD / HTTP/1.0"
-
-    => long request (6.5s) entered by hand through 'telnet'. The server replied
-       in 147 ms, and the session ended normally ('----')
-
-    >>> haproxy[674]: 127.0.0.1:33319 [15/Oct/2003:08:31:57.149] px-http \
-          px-http/srv1 6559/1230/7/147/6870 200 243 - - ---- 324/239/239/99/0 \
-          0/9 "HEAD / HTTP/1.0"
-
-    => Idem, but the request was queued in the global queue behind 9 other
-       requests, and waited there for 1230 ms.
-
-    >>> haproxy[674]: 127.0.0.1:33320 [15/Oct/2003:08:32:17.654] px-http \
-          px-http/srv1 9/0/7/14/+30 200 +243 - - ---- 3/3/3/1/0 0/0 \
-          "GET /image.iso HTTP/1.0"
-
-    => request for a long data transfer. The "logasap" option was specified, so
-       the log was produced just before transferring data. The server replied in
-       14 ms, 243 bytes of headers were sent to the client, and total time from
-       accept to first data byte is 30 ms.
-
-    >>> haproxy[674]: 127.0.0.1:33320 [15/Oct/2003:08:32:17.925] px-http \
-          px-http/srv1 9/0/7/14/30 502 243 - - PH-- 3/2/2/0/0 0/0 \
-          "GET /cgi-bin/bug.cgi? HTTP/1.0"
-
-    => the proxy blocked a server response either because of an "rspdeny" or
-       "rspideny" filter, or because the response was improperly formatted and
-       not HTTP-compliant, or because it blocked sensitive information which
-       risked being cached. In this case, the response is replaced with a "502
-       bad gateway". The flags ("PH--") tell us that it was haproxy who decided
-       to return the 502 and not the server.
-
-    >>> haproxy[18113]: 127.0.0.1:34548 [15/Oct/2003:15:18:55.798] px-http \
-          px-http/<NOSRV> -1/-1/-1/-1/8490 -1 0 - - CR-- 2/2/2/0/0 0/0 ""
-
-    => the client never completed its request and aborted itself ("C---") after
-       8.5s, while the proxy was waiting for the request headers ("-R--").
-       Nothing was sent to any server.
-
-    >>> haproxy[18113]: 127.0.0.1:34549 [15/Oct/2003:15:19:06.103] px-http \
-         px-http/<NOSRV> -1/-1/-1/-1/50001 408 0 - - cR-- 2/2/2/0/0 0/0 ""
-
-    => The client never completed its request, which was aborted by the
-       time-out ("c---") after 50s, while the proxy was waiting for the request
-       headers ("-R--").  Nothing was sent to any server, but the proxy could
-       send a 408 return code to the client.
-
-    >>> haproxy[18989]: 127.0.0.1:34550 [15/Oct/2003:15:24:28.312] px-tcp \
-          px-tcp/srv1 0/0/5007 0 cD 0/0/0/0/0 0/0
-
-    => This log was produced with "option tcplog". The client timed out after
-       5 seconds ("c----").
-
-    >>> haproxy[18989]: 10.0.0.1:34552 [15/Oct/2003:15:26:31.462] px-http \
-          px-http/srv1 3183/-1/-1/-1/11215 503 0 - - SC-- 205/202/202/115/3 \
-          0/0 "HEAD / HTTP/1.0"
-
-    => The request took 3s to complete (probably a network problem), and the
-       connection to the server failed ('SC--') after 4 attempts of 2 seconds
-       (config says 'retries 3'), and no redispatch (otherwise we would have
-       seen "/+3"). Status code 503 was returned to the client. There were 115
-       connections on this server, 202 connections on this proxy, and 205 on
-       the global process. It is possible that the server refused the
-       connection because of too many already established.
-
-
-9. Statistics and monitoring
-----------------------------
-
-It is possible to query HAProxy about its status. The most commonly used
-mechanism is the HTTP statistics page. This page also exposes an alternative
-CSV output format for monitoring tools. The same format is provided on the
-Unix socket.
-
-
-9.1. CSV format
----------------
-
-The statistics may be consulted either from the unix socket or from the HTTP
-page. Both means provide a CSV format whose fields follow.
-
-  0. pxname: proxy name
-  1. svname: service name (FRONTEND for frontend, BACKEND for backend, any name
-    for server)
-  2. qcur: current queued requests
-  3. qmax: max queued requests
-  4. scur: current sessions
-  5. smax: max sessions
-  6. slim: sessions limit
-  7. stot: total sessions
-  8. bin: bytes in
-  9. bout: bytes out
- 10. dreq: denied requests
- 11. dresp: denied responses
- 12. ereq: request errors
- 13. econ: connection errors
- 14. eresp: response errors (among which srv_abrt)
- 15. wretr: retries (warning)
- 16. wredis: redispatches (warning)
- 17. status: status (UP/DOWN/NOLB/MAINT/MAINT(via)...)
- 18. weight: server weight (server), total weight (backend)
- 19. act: server is active (server), number of active servers (backend)
- 20. bck: server is backup (server), number of backup servers (backend)
- 21. chkfail: number of failed checks
- 22. chkdown: number of UP->DOWN transitions
- 23. lastchg: last status change (in seconds)
- 24. downtime: total downtime (in seconds)
- 25. qlimit: queue limit
- 26. pid: process id (0 for first instance, 1 for second, ...)
- 27. iid: unique proxy id
- 28. sid: service id (unique inside a proxy)
- 29. throttle: warm up status
- 30. lbtot: total number of times a server was selected
- 31. tracked: id of proxy/server if tracking is enabled
- 32. type (0=frontend, 1=backend, 2=server, 3=socket)
- 33. rate: number of sessions per second over last elapsed second
- 34. rate_lim: limit on new sessions per second
- 35. rate_max: max number of new sessions per second
- 36. check_status: status of last health check, one of:
-        UNK     -> unknown
-        INI     -> initializing
-        SOCKERR -> socket error
-        L4OK    -> check passed on layer 4, no upper layers testing enabled
-        L4TMOUT -> layer 1-4 timeout
-        L4CON   -> layer 1-4 connection problem, for example
-                   "Connection refused" (tcp rst) or "No route to host" (icmp)
-        L6OK    -> check passed on layer 6
-        L6TOUT  -> layer 6 (SSL) timeout
-        L6RSP   -> layer 6 invalid response - protocol error
-        L7OK    -> check passed on layer 7
-        L7OKC   -> check conditionally passed on layer 7, for example 404 with
-                   disable-on-404
-        L7TOUT  -> layer 7 (HTTP/SMTP) timeout
-        L7RSP   -> layer 7 invalid response - protocol error
-        L7STS   -> layer 7 response error, for example HTTP 5xx
- 37. check_code: layer5-7 code, if available
- 38. check_duration: time in ms took to finish last health check
- 39. hrsp_1xx: http responses with 1xx code
- 40. hrsp_2xx: http responses with 2xx code
- 41. hrsp_3xx: http responses with 3xx code
- 42. hrsp_4xx: http responses with 4xx code
- 43. hrsp_5xx: http responses with 5xx code
- 44. hrsp_other: http responses with other codes (protocol error)
- 45. hanafail: failed health checks details
- 46. req_rate: HTTP requests per second over last elapsed second
- 47. req_rate_max: max number of HTTP requests per second observed
- 48. req_tot: total number of HTTP requests received
- 49. cli_abrt: number of data transfers aborted by the client
- 50. srv_abrt: number of data transfers aborted by the server (inc. in eresp)
-
-
-9.2. Unix Socket commands
--------------------------
-
-The following commands are supported on the UNIX stats socket ; all of them
-must be terminated by a line feed. The socket supports pipelining, so that it
-is possible to chain multiple commands at once provided they are delimited by
-a semi-colon or a line feed, although the former is more reliable as it has no
-risk of being truncated over the network. The responses themselves will each be
-followed by an empty line, so it will be easy for an external script to match a
-given response with a given request. By default one command line is processed
-then the connection closes, but there is an interactive allowing multiple lines
-to be issued one at a time.
-
-It is important to understand that when multiple haproxy processes are started
-on the same sockets, any process may pick up the request and will output its
-own stats.
-
-clear counters
-  Clear the max values of the statistics counters in each proxy (frontend &
-  backend) and in each server. The cumulated counters are not affected. This
-  can be used to get clean counters after an incident, without having to
-  restart nor to clear traffic counters. This command is restricted and can
-  only be issued on sockets configured for levels "operator" or "admin".
-
-clear counters all
-  Clear all statistics counters in each proxy (frontend & backend) and in each
-  server. This has the same effect as restarting. This command is restricted
-  and can only be issued on sockets configured for level "admin".
-
-disable server <backend>/<server>
-  Mark the server DOWN for maintenance. In this mode, no more checks will be
-  performed on the server until it leaves maintenance.
-  If the server is tracked by other servers, those servers will be set to DOWN
-  during the maintenance.
-
-  In the statistics page, a server DOWN for maintenance will appear with a
-  "MAINT" status, its tracking servers with the "MAINT(via)" one.
-
-  Both the backend and the server may be specified either by their name or by
-  their numeric ID, prefixed with a sharp ('#').
-
-  This command is restricted and can only be issued on sockets configured for
-  level "admin".
-
-enable server <backend>/<server>
-  If the server was previously marked as DOWN for maintenance, this marks the
-  server UP and checks are re-enabled.
-
-  Both the backend and the server may be specified either by their name or by
-  their numeric ID, prefixed with a sharp ('#').
-
-  This command is restricted and can only be issued on sockets configured for
-  level "admin".
-
-get weight <backend>/<server>
-  Report the current weight and the initial weight of server <server> in
-  backend <backend> or an error if either doesn't exist. The initial weight is
-  the one that appears in the configuration file. Both are normally equal
-  unless the current weight has been changed. Both the backend and the server
-  may be specified either by their name or by their numeric ID, prefixed with a
-  sharp ('#').
-
-help
-  Print the list of known keywords and their basic usage. The same help screen
-  is also displayed for unknown commands.
-
-prompt
-  Toggle the prompt at the beginning of the line and enter or leave interactive
-  mode. In interactive mode, the connection is not closed after a command
-  completes. Instead, the prompt will appear again, indicating the user that
-  the interpreter is waiting for a new command. The prompt consists in a right
-  angle bracket followed by a space "> ". This mode is particularly convenient
-  when one wants to periodically check information such as stats or errors.
-  It is also a good idea to enter interactive mode before issuing a "help"
-  command.
-
-quit
-  Close the connection when in interactive mode.
-
-set timeout cli <delay>
-  Change the CLI interface timeout for current connection. This can be useful
-  during long debugging sessions where the user needs to constantly inspect
-  some indicators without being disconnected. The delay is passed in seconds.
-
-set weight <backend>/<server> <weight>[%]
-  Change a server's weight to the value passed in argument. If the value ends
-  with the '%' sign, then the new weight will be relative to the initially
-  configured weight. Relative weights are only permitted between 0 and 100%,
-  and absolute weights are permitted between 0 and 256. Servers which are part
-  of a farm running a static load-balancing algorithm have stricter limitations
-  because the weight cannot change once set. Thus for these servers, the only
-  accepted values are 0 and 100% (or 0 and the initial weight). Changes take
-  effect immediately, though certain LB algorithms require a certain amount of
-  requests to consider changes. A typical usage of this command is to disable
-  a server during an update by setting its weight to zero, then to enable it
-  again after the update by setting it back to 100%. This command is restricted
-  and can only be issued on sockets configured for level "admin". Both the
-  backend and the server may be specified either by their name or by their
-  numeric ID, prefixed with a sharp ('#').
-
-show errors [<iid>]
-  Dump last known request and response errors collected by frontends and
-  backends. If <iid> is specified, the limit the dump to errors concerning
-  either frontend or backend whose ID is <iid>. This command is restricted
-  and can only be issued on sockets configured for levels "operator" or
-  "admin".
-
-  The errors which may be collected are the last request and response errors
-  caused by protocol violations, often due to invalid characters in header
-  names. The report precisely indicates what exact character violated the
-  protocol. Other important information such as the exact date the error was
-  detected, frontend and backend names, the server name (when known), the
-  internal session ID and the source address which has initiated the session
-  are reported too.
-
-  All characters are returned, and non-printable characters are encoded. The
-  most common ones (\t = 9, \n = 10, \r = 13 and \e = 27) are encoded as one
-  letter following a backslash. The backslash itself is encoded as '\\' to
-  avoid confusion. Other non-printable characters are encoded '\xNN' where
-  NN is the two-digits hexadecimal representation of the character's ASCII
-  code.
-
-  Lines are prefixed with the position of their first character, starting at 0
-  for the beginning of the buffer. At most one input line is printed per line,
-  and large lines will be broken into multiple consecutive output lines so that
-  the output never goes beyond 79 characters wide. It is easy to detect if a
-  line was broken, because it will not end with '\n' and the next line's offset
-  will be followed by a '+' sign, indicating it is a continuation of previous
-  line.
-
-  Example :
-    >>> $ echo "show errors" | socat stdio /tmp/sock1
-        [04/Mar/2009:15:46:56.081] backend http-in (#2) : invalid response
-          src 127.0.0.1, session #54, frontend fe-eth0 (#1), server s2 (#1)
-          response length 213 bytes, error at position 23:
-
-          00000  HTTP/1.0 200 OK\r\n
-          00017  header/bizarre:blah\r\n
-          00038  Location: blah\r\n
-          00054  Long-line: this is a very long line which should b
-          00104+ e broken into multiple lines on the output buffer,
-          00154+  otherwise it would be too large to print in a ter
-          00204+ minal\r\n
-          00211  \r\n
-
-    In the example above, we see that the backend "http-in" which has internal
-    ID 2 has blocked an invalid response from its server s2 which has internal
-    ID 1. The request was on session 54 initiated by source 127.0.0.1 and
-    received by frontend fe-eth0 whose ID is 1. The total response length was
-    213 bytes when the error was detected, and the error was at byte 23. This
-    is the slash ('/') in header name "header/bizarre", which is not a valid
-    HTTP character for a header name.
-
-show info
-  Dump info about haproxy status on current process.
-
-show sess
-  Dump all known sessions. Avoid doing this on slow connections as this can
-  be huge. This command is restricted and can only be issued on sockets
-  configured for levels "operator" or "admin".
-
-show sess <id>
-  Display a lot of internal information about the specified session identifier.
-  This identifier is the first field at the beginning of the lines in the dumps
-  of "show sess" (it corresponds to the session pointer). Those information are
-  useless to most users but may be used by haproxy developers to troubleshoot a
-  complex bug. The output format is intentionally not documented so that it can
-  freely evolve depending on demands.
-
-show stat [<iid> <type> <sid>]
-  Dump statistics in the CSV format. By passing <id>, <type> and <sid>, it is
-  possible to dump only selected items :
-    - <iid> is a proxy ID, -1 to dump everything
-    - <type> selects the type of dumpable objects : 1 for frontends, 2 for
-       backends, 4 for servers, -1 for everything. These values can be ORed,
-       for example:
-          1 + 2     = 3   -> frontend + backend.
-          1 + 2 + 4 = 7   -> frontend + backend + server.
-    - <sid> is a server ID, -1 to dump everything from the selected proxy.
-
-  Example :
-    >>> $ echo "show info;show stat" | socat stdio unix-connect:/tmp/sock1
-        Name: HAProxy
-        Version: 1.4-dev2-49
-        Release_date: 2009/09/23
-        Nbproc: 1
-        Process_num: 1
-        (...)
-
-        # pxname,svname,qcur,qmax,scur,smax,slim,stot,bin,bout,dreq,  (...)
-        stats,FRONTEND,,,0,0,1000,0,0,0,0,0,0,,,,,OPEN,,,,,,,,,1,1,0, (...)
-        stats,BACKEND,0,0,0,0,1000,0,0,0,0,0,,0,0,0,0,UP,0,0,0,,0,250,(...)
-        (...)
-        www1,BACKEND,0,0,0,0,1000,0,0,0,0,0,,0,0,0,0,UP,1,1,0,,0,250, (...)
-
-        $
-
-    Here, two commands have been issued at once. That way it's easy to find
-    which process the stats apply to in multi-process mode. Notice the empty
-    line after the information output which marks the end of the first block.
-    A similar empty line appears at the end of the second block (stats) so that
-    the reader knows the output has not been truncated.
-
-
-/*
- * Local variables:
- *  fill-column: 79
- * End:
- */
diff --git a/deps/haproxy-1.4.21/doc/design-thoughts/backends-v0.txt b/deps/haproxy-1.4.21/doc/design-thoughts/backends-v0.txt
deleted file mode 100644
index d350e22..0000000
--- a/deps/haproxy-1.4.21/doc/design-thoughts/backends-v0.txt
+++ /dev/null
@@ -1,27 +0,0 @@
-1 type gnrique "entit", avec les attributs suivants :
-
-  - frontend *f
-  - l7switch *s
-  - backend  *b
-
-des types spcifiques sont simplement des entits avec certains
-de ces champs remplis et pas forcment tous :
-
-  listen   = f [s] b
-  frontend = f [s]
-  l7switch = s
-  backend  = [s] b
-
-Ensuite, les traitements sont valus dans l'ordre :
-  - listen   -> s'il a des rgles de l7, on les value, et potentiellement on branche vers d'autres listen, l7 ou back, ou on travaille avec le back local.
-  - frontend -> s'il a des rgles de l7, on les value, et potentiellement on branche vers d'autres listen, l7 ou back
-  - l7switch -> on value ses rgles, potentiellement on branche vers d'autres listen, l7 ou backends
-  - backend  -> s'il a des rgles l7, on les value (quitte  changer encore de backend) puis on traite.
-
-Les requtes sont traites dans l'ordre des chanages f->s*->b, et les rponses doivent tre
-traites dans l'ordre inverse b->s*->f. Penser aux rcritures de champs Host  l'aller et
-Location en retour.
-
-D'autre part, prvoir des "profils" plutt que des blocs de nouveaux paramtres par dfaut.
-Ca permettra d'avoir plein de jeux de paramtres par dfaut  utiliser dans chacun de ces
-types.
diff --git a/deps/haproxy-1.4.21/doc/design-thoughts/backends.txt b/deps/haproxy-1.4.21/doc/design-thoughts/backends.txt
deleted file mode 100644
index d2474ce..0000000
--- a/deps/haproxy-1.4.21/doc/design-thoughts/backends.txt
+++ /dev/null
@@ -1,125 +0,0 @@
-There has been a lot of confusion during the development because of the
-backends and frontends.
-
-What we want :
-
-- being able to still use a listener as it has always been working
-
-- being able to write a rule stating that we will *change* the backend when we
-  match some pattern. Only one jump is allowed.
-
-- being able to write a "use_filters_from XXX" line stating that we will ignore
-  any filter in the current listener, and that those from XXX will be borrowed
-  instead. A warning would be welcome for options which will silently get
-  masked. This is used to factor configuration.
-
-- being able to write a "use_backend_from XXX" line stating that we will ignore
-  any server and timeout config in the current listener, and that those from
-  XXX will be borrowed instead. A warning would be welcome for options which
-  will silently get masked. This is used to factor configuration.
-
-
-
-Example :
----------
-
-  | # frontend HTTP/80
-  | listen fe_http 1.1.1.1:80
-  |        use_filters_from default_http
-  |        use_backend_from appli1
-  | 
-  | # frontend HTTPS/443
-  | listen fe_https 1.1.1.1:443
-  |        use_filters_from default_https
-  |        use_backend_from appli1
-  | 
-  | # frontend HTTP/8080
-  | listen fe_http-dev 1.1.1.1:8080
-  |        reqadd "X-proto: http"
-  |        reqisetbe "^Host: www1" appli1
-  |        reqisetbe "^Host: www2" appli2
-  |        reqisetbe "^Host: www3" appli-dev
-  |        use_backend_from appli1
-  | 
-  | 
-  | # filters default_http
-  | listen default_http
-  |        reqadd "X-proto: http"
-  |        reqisetbe "^Host: www1" appli1
-  |        reqisetbe "^Host: www2" appli2
-  | 
-  | # filters default_https
-  | listen default_https
-  |        reqadd "X-proto: https"
-  |        reqisetbe "^Host: www1" appli1
-  |        reqisetbe "^Host: www2" appli2
-  | 
-  | 
-  | # backend appli1
-  | listen appli1
-  |        reqidel "^X-appli1:.*"
-  |        reqadd "Via: appli1"
-  |        balance roundrobin
-  |        cookie app1
-  |        server srv1
-  |        server srv2
-  | 
-  | # backend appli2
-  | listen appli2
-  |        reqidel "^X-appli2:.*"
-  |        reqadd "Via: appli2"
-  |        balance roundrobin
-  |        cookie app2
-  |        server srv1
-  |        server srv2
-  | 
-  | # backend appli-dev
-  | listen appli-dev
-  |        reqadd "Via: appli-dev"
-  |        use_backend_from appli2
-  | 
-  | 
-
-
-Now we clearly see multiple things :
-------------------------------------
-
-  - a frontend can EITHER have filters OR reference a use_filter
-
-  - a backend can EITHER have servers OR reference a use_backend
-
-  - we want the evaluation to cross TWO levels per request. When a request is
-    being processed, it keeps track of its "frontend" side (where it came
-    from), and of its "backend" side (where the server-side parameters have
-    been found).
-
-  - the use_{filters|backend} have nothing to do with how the request is
-    decomposed.
-
-
-Conclusion :
-------------
-
-  - a proxy is always its own frontend. It also has 2 parameters :
-    - "fi_prm" : pointer to the proxy holding the filters (itself by default)
-    - "be_prm" : pointer to the proxy holding the servers (itself by default)
-
-  - a request has a frontend (fe) and a backend (be). By default, the backend
-    is initialized to the frontend. Everything related to the client side is
-    accessed through ->fe. Everything related to the server side is accessed
-    through ->be.
-
-  - request filters are first called from ->fe then ->be. Since only the
-    filters can change ->be, it is possible to iterate the filters on ->be
-    only and stop when ->be does not change anymore.
-
-  - response filters are first called from ->be then ->fe IF (fe != be).
-
-
-When we parse the configuration, we immediately configure ->fi and ->be for
-all proxies.
-
-Upon session creation, s->fe and s->be are initialized to the proxy. Filters
-are executed via s->fe->fi_prm and s->be->fi_prm. Servers are found in
-s->be->be_prm.
-
diff --git a/deps/haproxy-1.4.21/doc/design-thoughts/be-fe-changes.txt b/deps/haproxy-1.4.21/doc/design-thoughts/be-fe-changes.txt
deleted file mode 100644
index f242f8a..0000000
--- a/deps/haproxy-1.4.21/doc/design-thoughts/be-fe-changes.txt
+++ /dev/null
@@ -1,74 +0,0 @@
-- PR_O_TRANSP => FE  !!! devra peut-tre changer vu que c'est un complment du mode dispatch.
-- PR_O_NULLNOLOG => FE
-- PR_O_HTTP_CLOSE => FE. !!! mettre BE aussi !!!
-- PR_O_TCP_CLI_KA => FE
-
-- PR_O_FWDFOR => BE.  FE aussi ?
-- PR_O_FORCE_CLO => BE
-- PR_O_PERSIST => BE
-- PR_O_COOK_RW, PR_O_COOK_INS, PR_O_COOK_PFX, PR_O_COOK_POST => BE
-- PR_O_COOK_NOC, PR_O_COOK_IND => BE
-- PR_O_ABRT_CLOSE => BE
-- PR_O_REDISP => BE
-- PR_O_BALANCE, PR_O_BALANCE_RR, PR_O_BALANCE_SH => BE
-- PR_O_CHK_CACHE => BE
-- PR_O_TCP_SRV_KA => BE
-- PR_O_BIND_SRC => BE
-- PR_O_TPXY_MASK => BE
-
-
-- PR_MODE_TCP : BE ct serveur, FE ct client
-
-- nbconn -> fe->nbconn, be->nbconn.
-  Pb: rendre impossible le fait que (fe == be) avant de faire a,
-  sinon on va compter les connexions en double. Ce ne sera possible
-  que lorsque les FE et BE seront des entits distinctes. On va donc
-  commencer par laisser uniquement fe->nbconn (vu que le fe ne change
-  pas), et modifier ceci plus tard, ne serait-ce que pour prendre en
-  compte correctement les minconn/maxconn.
-  => solution : avoir beconn et feconn dans chaque proxy.
-
-- failed_conns, failed_secu (rponses bloques), failed_resp... : be
-  Attention: voir les cas de ERR_SRVCL, il semble que parfois on
-  indique a alors qu'il y a un write error ct client (ex: ligne
-  2044 dans proto_http).
-
-  => be et pas be->beprm
-
-- logs du backup : ->be (idem)
-
-- queue : be
-
-- logs/debug : srv toujours associ  be (ex: proxy->id:srv->id). Rien
-  pour le client pour le moment. D'une manire gnrale, les erreurs
-  provoques ct serveur vont sur BE et celles ct client vont sur
-  FE.
-- logswait & LW_BYTES : FE (puisqu'on veut savoir si on logue tout de suite)
-
-- messages d'erreurs personnaliss (errmsg, ...) -> fe
-
-- monitor_uri -> fe
-- uri_auth  -> (fe->firpm puis be->fiprm). Utilisation de ->be
-
-- req_add, req_exp => fe->fiprm, puis be->fiprm
-- req_cap, rsp_cap -> fe->fiprm
-- rsp_add, rsp_exp => be->fiprm, devrait tre fait ensuite aussi sur fe->fiprm
-- capture_name, capture_namelen : fe->fiprm
-
-  Ce n'est pas la solution idale, mais au moins la capture et configurable
-  par les filtres du FE et ne bouge pas lorsque le BE est rassign. Cela
-  rsoud aussi un pb d'allocation mmoire.
-
-
-- persistance (appsessions, cookiename, ...) -> be
-- stats:scope "." = fe (celui par lequel on arrive)
-  !!!ERREUR!!! => utiliser be pour avoir celui qui a t valid par
-  l'uri_auth.
-
-
---------- corrections  effectuer ---------
-
-- remplacement de headers : parser le header et ventuellement le supprimer puis le(les) rajouter.
-- session->proto.{l4state,l7state,l7substate} pour CLI et SRV
-- errorloc : si dfinie dans backend, la prendre, sinon dans front.
-- logs : faire be sinon fe.
diff --git a/deps/haproxy-1.4.21/doc/design-thoughts/buffers.fig b/deps/haproxy-1.4.21/doc/design-thoughts/buffers.fig
deleted file mode 100644
index be6fac3..0000000
--- a/deps/haproxy-1.4.21/doc/design-thoughts/buffers.fig
+++ /dev/null
@@ -1,1052 +0,0 @@
-#FIG 3.2  Produced by xfig version 3.2.5-alpha5
-Portrait
-Center
-Metric
-A4      
-100.00
-Single
--2
-1200 2
-6 630 900 1620 1395
-5 1 0 1 0 4 51 -1 20 0.000 0 1 0 0 900.000 1125.000 900 900 675 1125 900 1350
-6 900 900 1620 1350
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 900 900 900 1350
-4 0 0 50 -1 16 8 0.0000 4 120 570 1035 1245 descriptor\001
-4 0 0 50 -1 16 8 0.0000 4 105 165 1035 1080 file\001
--6
--6
-6 630 1530 1620 2070
-6 630 1530 1170 2070
-5 1 0 1 0 11 51 -1 20 0.000 0 0 0 0 900.000 1800.000 900 1575 1125 1800 900 2025
-5 1 0 1 0 4 51 -1 20 0.000 0 1 0 0 900.000 1800.000 900 1575 675 1800 900 2025
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 900 1575 900 2025
--6
-4 0 0 50 -1 16 8 0.0000 4 105 360 1260 1710 stream\001
-4 0 0 50 -1 16 8 0.0000 4 105 330 1260 1890 driver\001
--6
-6 675 2340 2070 2610
-6 675 2340 1575 2610
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 1530 2340 1530 2610
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 1485 2340 1485 2610
-2 2 0 1 0 6 51 -1 20 0.000 1 0 -1 0 0 5
-	 675 2340 1575 2340 1575 2610 675 2610 675 2340
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 720 2340 720 2610
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 765 2340 765 2610
--6
-4 0 0 50 -1 16 8 0.0000 4 105 330 1710 2475 buffer\001
--6
-6 2340 2205 3420 2745
-6 2340 2205 2610 2745
-5 1 0 1 0 14 51 -1 20 0.000 0 0 0 0 2475.000 2475.000 2610 2655 2475 2700 2340 2655
-5 1 0 1 0 14 51 -1 20 0.000 0 1 0 0 2475.000 2475.000 2610 2295 2475 2250 2340 2295
-2 2 0 1 14 14 52 -1 20 0.000 2 0 -1 0 0 5
-	 2340 2295 2610 2295 2610 2655 2340 2655 2340 2295
--6
-4 0 0 50 -1 16 8 0.0000 4 105 645 2745 2430 schedulable\001
-4 0 0 50 -1 16 8 0.0000 4 105 225 2745 2595 task\001
--6
-6 4455 900 7200 2070
-6 4455 900 4725 1395
-5 1 0 1 0 11 51 -1 20 0.000 0 0 0 0 4455.000 1125.000 4455 900 4680 1125 4455 1350
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 4455 900 4455 1350
--6
-6 5130 1170 5715 2070
-4 0 0 50 -1 16 8 0.0000 4 105 585 5130 1305 functions :\001
-4 0 0 50 -1 16 6 0.0000 4 75 315 5130 1440 -queue\001
-4 0 0 50 -1 16 6 0.0000 4 90 525 5130 1590 -shutdown\001
-4 0 0 50 -1 16 6 0.0000 4 90 300 5130 1740 -flush\001
-4 0 0 50 -1 16 6 0.0000 4 90 285 5130 1890 -send\001
-4 0 0 50 -1 16 6 0.0000 4 60 270 5130 2040 -recv\001
--6
-6 6030 900 7200 2025
-4 0 0 50 -1 16 8 0.0000 4 105 555 6030 1035 callbacks :\001
-4 0 0 50 -1 16 6 0.0000 4 105 735 6030 1170 -read_complete\001
-4 0 0 50 -1 16 6 0.0000 4 105 780 6030 1320 -write_complete\001
-4 0 0 50 -1 16 6 0.0000 4 105 450 6030 1470 -wake_up\001
-4 0 0 50 -1 16 6 0.0000 4 105 1110 6030 1755 -context (for sessions)\001
-4 0 0 50 -1 16 6 0.0000 4 105 810 6030 1890 -source (=buffer)\001
-4 0 0 50 -1 16 6 0.0000 4 90 525 6030 2025 -condition\001
-4 0 0 50 -1 16 8 0.0000 4 120 1140 6030 1620 args for *_complete :\001
--6
-2 1 0 1 0 -1 50 -1 -1 0.000 1 0 -1 1 0 3
-	0 0 1.00 30.00 45.00
-	 4635 990 4905 990 5985 990
-2 1 0 1 0 -1 50 -1 -1 0.000 1 0 -1 0 1 3
-	0 0 1.00 30.00 45.00
-	 4635 1260 4905 1260 5085 1260
--6
-6 2205 1530 3420 2070
-6 2205 1530 2745 2070
-5 1 0 1 0 11 51 -1 20 0.000 0 1 0 0 2475.000 1800.000 2475 1575 2250 1800 2475 2025
-5 1 0 1 0 11 51 -1 20 0.000 0 0 0 0 2475.000 1800.000 2475 1575 2700 1800 2475 2025
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 2475 1575 2475 2025
--6
-4 0 0 50 -1 16 8 0.0000 4 105 360 2835 1755 stream\001
-4 0 0 50 -1 16 8 0.0000 4 90 555 2835 1935 processor\001
--6
-6 3825 2205 4905 2745
-6 3825 2205 4365 2745
-5 1 0 1 0 11 51 -1 20 0.000 0 0 0 0 4095.000 2475.000 4230 2295 4320 2475 4230 2655
-5 1 0 1 0 11 51 -1 20 0.000 0 1 0 0 4095.000 2475.000 3960 2295 3870 2475 3960 2655
-5 1 0 1 0 14 51 -1 20 0.000 0 0 0 0 4095.000 2475.000 4230 2655 4095 2700 3960 2655
-5 1 0 1 0 14 51 -1 20 0.000 0 1 0 0 4095.000 2475.000 4230 2295 4095 2250 3960 2295
-2 2 0 1 14 14 52 -1 20 0.000 2 0 -1 0 0 5
-	 3960 2295 4230 2295 4230 2655 3960 2655 3960 2295
--6
-4 0 0 50 -1 16 8 0.0000 4 105 240 4455 2430 flow\001
-4 0 0 50 -1 16 8 0.0000 4 120 450 4455 2610 analyzer\001
--6
-6 2250 900 3960 1395
-6 2250 900 2520 1395
-5 1 0 1 0 11 51 -1 20 0.000 0 0 0 0 2250.000 1125.000 2250 900 2475 1125 2250 1350
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 2250 900 2250 1350
--6
-4 0 0 50 -1 16 8 0.0000 4 105 1320 2610 1245 callbacks and functions.\001
-4 0 0 50 -1 16 8 0.0000 4 105 1335 2610 1080 stream interface made of\001
--6
-6 7740 900 8775 3465
-6 7740 900 8640 1170
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 8595 900 8595 1170
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 8550 900 8550 1170
-2 2 0 1 0 6 51 -1 20 0.000 1 0 -1 0 0 5
-	 7740 900 8640 900 8640 1170 7740 1170 7740 900
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 7785 900 7785 1170
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 7830 900 7830 1170
-4 1 0 50 -1 16 6 0.0000 4 105 420 8190 1080 http_req\001
--6
-4 0 0 50 -1 16 8 0.0000 4 105 495 7740 1395 variables\001
-4 0 0 50 -1 16 6 0.0000 4 105 300 7740 1485 -flags\001
-4 0 0 50 -1 16 6 0.0000 4 105 720 7740 1755 -producer_task\001
-4 0 0 50 -1 16 6 0.0000 4 105 735 7740 1845 -consumer_task\001
-4 0 0 50 -1 16 6 0.0000 4 105 780 7740 1665 -write_complete\001
-4 0 0 50 -1 16 6 0.0000 4 105 735 7740 1575 -read_complete\001
-4 0 0 50 -1 16 8 0.0000 4 120 780 7740 2160 internal flags :\001
-4 0 0 50 -1 16 6 0.0000 4 90 960 7740 2295 -SHUTR_PENDING\001
-4 0 0 50 -1 16 6 0.0000 4 90 780 7740 2385 -SHUTR_DONE\001
-4 0 0 50 -1 16 6 0.0000 4 90 975 7740 2475 -SHUTW_PENDING\001
-4 0 0 50 -1 16 6 0.0000 4 90 795 7740 2565 -SHUTW_DONE\001
-4 0 0 50 -1 16 6 0.0000 4 75 450 7740 2655 -HOLDW\001
-4 0 0 50 -1 16 6 0.0000 4 90 585 7740 2745 -READ_EN\001
-4 0 0 50 -1 16 6 0.0000 4 90 600 7740 2835 -WRITE_EN\001
-4 0 0 50 -1 16 6 0.0000 4 105 945 7740 1935 -flow_analyzer_task\001
-4 0 0 50 -1 16 8 0.0000 4 105 540 7740 3015 interface :\001
-4 0 0 50 -1 16 6 0.0000 4 90 780 7740 3150 -1 stream reader\001
-4 0 0 50 -1 16 6 0.0000 4 90 780 7740 3285 -1 stream writer\001
-4 0 0 50 -1 16 6 0.0000 4 105 1020 7740 3420 -0..n stream analyzers\001
--6
-6 3555 3645 5895 6075
-6 3555 3915 4095 4455
-5 1 0 1 0 11 51 -1 20 0.000 0 0 0 0 3825.000 4185.000 3825 3960 4050 4185 3825 4410
-5 1 0 1 0 4 51 -1 20 0.000 0 1 0 0 3825.000 4185.000 3825 3960 3600 4185 3825 4410
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 3825 3960 3825 4410
--6
-6 5355 3915 5895 4455
-5 1 0 1 0 11 51 -1 20 0.000 0 1 0 0 5625.000 4185.000 5625 3960 5400 4185 5625 4410
-5 1 0 1 0 4 51 -1 20 0.000 0 0 0 0 5625.000 4185.000 5625 3960 5850 4185 5625 4410
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 5625 3960 5625 4410
--6
-6 3555 5265 4095 5805
-5 1 0 1 0 11 51 -1 20 0.000 0 0 0 0 3825.000 5535.000 3825 5310 4050 5535 3825 5760
-5 1 0 1 0 4 51 -1 20 0.000 0 1 0 0 3825.000 5535.000 3825 5310 3600 5535 3825 5760
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 3825 5310 3825 5760
--6
-6 5355 5265 5895 5805
-5 1 0 1 0 11 51 -1 20 0.000 0 1 0 0 5625.000 5535.000 5625 5310 5400 5535 5625 5760
-5 1 0 1 0 4 51 -1 20 0.000 0 0 0 0 5625.000 5535.000 5625 5310 5850 5535 5625 5760
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 5625 5310 5625 5760
--6
-6 4455 4590 4995 5130
-5 1 0 1 0 11 51 -1 20 0.000 0 0 0 0 4725.000 4860.000 4860 4680 4950 4860 4860 5040
-5 1 0 1 0 11 51 -1 20 0.000 0 1 0 0 4725.000 4860.000 4590 4680 4500 4860 4590 5040
-5 1 0 1 0 14 51 -1 20 0.000 0 0 0 0 4725.000 4860.000 4860 5040 4725 5085 4590 5040
-5 1 0 1 0 14 51 -1 20 0.000 0 1 0 0 4725.000 4860.000 4860 4680 4725 4635 4590 4680
-2 2 0 1 14 14 52 -1 20 0.000 2 0 -1 0 0 5
-	 4590 4680 4860 4680 4860 5040 4590 5040 4590 4680
--6
-6 4275 5400 5175 5670
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 5130 5400 5130 5670
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 5085 5400 5085 5670
-2 2 0 1 0 6 51 -1 20 0.000 1 0 -1 0 0 5
-	 4275 5400 5175 5400 5175 5670 4275 5670 4275 5400
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 4320 5400 4320 5670
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 4365 5400 4365 5670
-4 1 0 50 -1 16 6 0.0000 4 105 465 4725 5580 http_resp\001
--6
-6 4275 4050 5175 4320
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 5130 4050 5130 4320
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 5085 4050 5085 4320
-2 2 0 1 0 6 51 -1 20 0.000 1 0 -1 0 0 5
-	 4275 4050 5175 4050 5175 4320 4275 4320 4275 4050
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 4320 4050 4320 4320
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 4365 4050 4365 4320
-4 1 0 50 -1 16 6 0.0000 4 105 420 4725 4230 http_req\001
--6
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 5175 4185 5400 4185
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 4050 4185 4275 4185
-2 1 0 1 0 14 50 -1 -1 0.000 1 0 -1 1 1 2
-	0 0 1.00 30.00 45.00
-	0 0 1.00 30.00 45.00
-	 4725 4635 4725 4320
-2 1 0 1 0 14 50 -1 -1 0.000 1 0 -1 1 1 2
-	0 0 1.00 30.00 45.00
-	0 0 1.00 30.00 45.00
-	 4725 5400 4725 5085
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 4275 5535 4050 5535
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 5400 5535 5175 5535
-4 1 0 50 -1 16 6 0.0000 4 90 285 5625 3870 driver\001
-4 1 0 50 -1 16 6 0.0000 4 105 300 5625 3735 output\001
-4 1 0 50 -1 16 6 0.0000 4 90 285 3825 3870 driver\001
-4 1 0 50 -1 16 6 0.0000 4 105 240 3825 3735 input\001
-4 0 0 50 -1 16 6 0.0000 4 90 405 5040 4950 eg: HTTP\001
-4 1 0 50 -1 16 6 0.0000 4 90 285 5625 6075 driver\001
-4 1 0 50 -1 16 6 0.0000 4 90 285 3825 6075 driver\001
-4 1 0 50 -1 16 6 0.0000 4 105 300 3825 5940 output\001
-4 1 0 50 -1 16 6 0.0000 4 105 240 5625 5940 input\001
-4 0 0 50 -1 16 6 0.0000 4 105 690 5040 4815 flow processor\001
--6
-6 6480 4050 8820 5400
-5 1 0 1 0 11 51 -1 20 0.000 0 0 0 0 7650.000 4725.000 7785 4545 7875 4725 7785 4905
-5 1 0 1 0 11 51 -1 20 0.000 0 1 0 0 7650.000 4725.000 7515 4545 7425 4725 7515 4905
-5 1 0 1 0 14 51 -1 20 0.000 0 0 0 0 7650.000 4725.000 7785 4905 7650 4950 7515 4905
-5 1 0 1 0 14 51 -1 20 0.000 0 1 0 0 7650.000 4725.000 7785 4545 7650 4500 7515 4545
-6 6480 4455 7020 4995
-5 1 0 1 0 11 51 -1 20 0.000 0 0 0 0 6750.000 4725.000 6750 4500 6975 4725 6750 4950
-5 1 0 1 0 4 51 -1 20 0.000 0 1 0 0 6750.000 4725.000 6750 4500 6525 4725 6750 4950
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 6750 4500 6750 4950
--6
-6 8280 4455 8820 4995
-5 1 0 1 0 11 51 -1 20 0.000 0 1 0 0 8550.000 4725.000 8550 4500 8325 4725 8550 4950
-5 1 0 1 0 4 51 -1 20 0.000 0 0 0 0 8550.000 4725.000 8550 4500 8775 4725 8550 4950
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 8550 4500 8550 4950
--6
-6 7200 4050 8100 4320
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 8055 4050 8055 4320
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 8010 4050 8010 4320
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 7245 4050 7245 4320
-2 2 0 1 0 6 51 -1 20 0.000 1 0 -1 0 0 5
-	 7200 4050 8100 4050 8100 4320 7200 4320 7200 4050
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 7290 4050 7290 4320
-4 1 0 50 -1 16 6 0.0000 4 105 420 7650 4230 http_req\001
--6
-6 7200 5130 8100 5400
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 8055 5130 8055 5400
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 8010 5130 8010 5400
-2 2 0 1 0 6 51 -1 20 0.000 1 0 -1 0 0 5
-	 7200 5130 8100 5130 8100 5400 7200 5400 7200 5130
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 7245 5130 7245 5400
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 7290 5130 7290 5400
-4 1 0 50 -1 16 6 0.0000 4 105 465 7650 5310 http_resp\001
--6
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 8100 4185 8370 4590
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 6930 4590 7200 4185
-2 1 0 1 0 14 50 -1 -1 0.000 1 0 -1 1 1 2
-	0 0 1.00 30.00 45.00
-	0 0 1.00 30.00 45.00
-	 7650 4500 7650 4320
-2 1 0 1 0 14 50 -1 -1 0.000 1 0 -1 1 1 2
-	0 0 1.00 30.00 45.00
-	0 0 1.00 30.00 45.00
-	 7650 5130 7650 4950
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 7200 5265 6930 4860
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 8370 4860 8100 5265
-2 2 0 1 14 14 52 -1 20 0.000 2 0 -1 0 0 5
-	 7515 4545 7785 4545 7785 4905 7515 4905 7515 4545
-4 1 0 50 -1 16 6 0.0000 4 60 285 6750 4230 server\001
-4 1 0 50 -1 16 6 0.0000 4 90 285 6750 4365 socket\001
-4 1 0 50 -1 16 6 0.0000 4 90 255 8550 4230 client\001
-4 1 0 50 -1 16 6 0.0000 4 90 285 8550 4365 socket\001
-4 1 0 50 -1 16 6 0.0000 4 105 210 7650 4770 http\001
--6
-6 630 4005 2970 5490
-6 630 4680 1170 5220
-5 1 0 1 0 11 51 -1 20 0.000 0 0 0 0 900.000 4950.000 900 4725 1125 4950 900 5175
-5 1 0 1 0 4 51 -1 20 0.000 0 1 0 0 900.000 4950.000 900 4725 675 4950 900 5175
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 900 4725 900 5175
--6
-6 2430 4680 2970 5220
-5 1 0 1 0 11 51 -1 20 0.000 0 1 0 0 2700.000 4950.000 2700 4725 2475 4950 2700 5175
-5 1 0 1 0 4 51 -1 20 0.000 0 0 0 0 2700.000 4950.000 2700 4725 2925 4950 2700 5175
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 2700 4725 2700 5175
--6
-6 1530 4005 2070 4545
-5 1 0 1 0 11 51 -1 20 0.000 0 0 0 0 1800.000 4275.000 1935 4095 2025 4275 1935 4455
-5 1 0 1 0 11 51 -1 20 0.000 0 1 0 0 1800.000 4275.000 1665 4095 1575 4275 1665 4455
-5 1 0 1 0 14 51 -1 20 0.000 0 0 0 0 1800.000 4275.000 1935 4455 1800 4500 1665 4455
-5 1 0 1 0 14 51 -1 20 0.000 0 1 0 0 1800.000 4275.000 1935 4095 1800 4050 1665 4095
-2 2 0 1 14 14 52 -1 20 0.000 2 0 -1 0 0 5
-	 1665 4095 1935 4095 1935 4455 1665 4455 1665 4095
--6
-6 1350 4815 2250 5085
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 2205 4815 2205 5085
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 2160 4815 2160 5085
-2 2 0 1 0 6 51 -1 20 0.000 1 0 -1 0 0 5
-	 1350 4815 2250 4815 2250 5085 1350 5085 1350 4815
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 1395 4815 1395 5085
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 1440 4815 1440 5085
-4 1 0 50 -1 16 6 0.0000 4 105 420 1800 4995 http_req\001
--6
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 2250 4950 2475 4950
-2 1 0 1 0 14 50 -1 -1 0.000 1 0 -1 1 1 2
-	0 0 1.00 30.00 45.00
-	0 0 1.00 30.00 45.00
-	 1800 4815 1800 4500
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 1125 4950 1350 4950
-4 0 0 50 -1 16 6 0.0000 4 105 690 2115 4365 eg: HTTP_REQ\001
-4 1 0 50 -1 16 6 0.0000 4 105 300 2700 5355 output\001
-4 1 0 50 -1 16 6 0.0000 4 90 285 2700 5490 driver\001
-4 1 0 50 -1 16 6 0.0000 4 105 240 900 5355 input\001
-4 1 0 50 -1 16 6 0.0000 4 90 285 900 5490 driver\001
-4 0 0 50 -1 16 6 0.0000 4 105 690 2115 4230 flow processor\001
--6
-6 675 11025 6615 12555
-5 1 0 1 0 11 51 -1 20 0.000 0 0 0 0 3645.000 11790.000 3780 11610 3870 11790 3780 11970
-5 1 0 1 0 11 51 -1 20 0.000 0 1 0 0 3645.000 11790.000 3510 11610 3420 11790 3510 11970
-5 1 0 1 0 14 51 -1 20 0.000 0 0 0 0 3645.000 11790.000 3780 11970 3645 12015 3510 11970
-5 1 0 1 0 14 51 -1 20 0.000 0 1 0 0 3645.000 11790.000 3780 11610 3645 11565 3510 11610
-6 675 11520 1215 12060
-5 1 0 1 0 11 51 -1 20 0.000 0 0 0 0 945.000 11790.000 945 11565 1170 11790 945 12015
-5 1 0 1 0 4 51 -1 20 0.000 0 1 0 0 945.000 11790.000 945 11565 720 11790 945 12015
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 945 11565 945 12015
--6
-6 3195 11115 4095 11385
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 4050 11115 4050 11385
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 4005 11115 4005 11385
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 3240 11115 3240 11385
-2 2 0 1 0 6 51 -1 20 0.000 1 0 -1 0 0 5
-	 3195 11115 4095 11115 4095 11385 3195 11385 3195 11115
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 3285 11115 3285 11385
-4 1 0 50 -1 16 6 0.0000 4 105 420 3645 11295 http_req\001
--6
-6 3195 12195 4095 12465
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 4050 12195 4050 12465
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 4005 12195 4005 12465
-2 2 0 1 0 6 51 -1 20 0.000 1 0 -1 0 0 5
-	 3195 12195 4095 12195 4095 12465 3195 12465 3195 12195
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 3240 12195 3240 12465
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 3285 12195 3285 12465
-4 1 0 50 -1 16 6 0.0000 4 105 465 3645 12375 http_resp\001
--6
-6 4275 11520 4815 12060
-5 1 0 1 0 11 51 -1 20 0.000 0 1 0 0 4545.000 11790.000 4545 11565 4320 11790 4545 12015
-5 1 0 1 0 11 51 -1 20 0.000 0 0 0 0 4545.000 11790.000 4545 11565 4770 11790 4545 12015
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 4545 11565 4545 12015
--6
-6 2475 11520 3015 12060
-5 1 0 1 0 11 51 -1 20 0.000 0 1 0 0 2745.000 11790.000 2745 11565 2520 11790 2745 12015
-5 1 0 1 0 11 51 -1 20 0.000 0 0 0 0 2745.000 11790.000 2745 11565 2970 11790 2745 12015
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 2745 11565 2745 12015
--6
-6 4995 11115 5895 11385
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 5850 11115 5850 11385
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 5805 11115 5805 11385
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 5040 11115 5040 11385
-2 2 0 1 0 6 51 -1 20 0.000 1 0 -1 0 0 5
-	 4995 11115 5895 11115 5895 11385 4995 11385 4995 11115
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 5085 11115 5085 11385
-4 1 0 50 -1 16 6 0.0000 4 105 465 5445 11295 https_req\001
--6
-6 4995 12195 5895 12465
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 5850 12195 5850 12465
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 5805 12195 5805 12465
-2 2 0 1 0 6 51 -1 20 0.000 1 0 -1 0 0 5
-	 4995 12195 5895 12195 5895 12465 4995 12465 4995 12195
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 5040 12195 5040 12465
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 5085 12195 5085 12465
-4 1 0 50 -1 16 6 0.0000 4 105 510 5445 12375 https_resp\001
--6
-6 1395 11115 2295 11385
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 2250 11115 2250 11385
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 2205 11115 2205 11385
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 1440 11115 1440 11385
-2 2 0 1 0 6 51 -1 20 0.000 1 0 -1 0 0 5
-	 1395 11115 2295 11115 2295 11385 1395 11385 1395 11115
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 1485 11115 1485 11385
-4 1 0 50 -1 16 6 0.0000 4 105 465 1845 11295 https_req\001
--6
-6 1395 12195 2295 12465
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 2250 12195 2250 12465
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 2205 12195 2205 12465
-2 2 0 1 0 6 51 -1 20 0.000 1 0 -1 0 0 5
-	 1395 12195 2295 12195 2295 12465 1395 12465 1395 12195
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 1440 12195 1440 12465
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 1485 12195 1485 12465
-4 1 0 50 -1 16 6 0.0000 4 105 510 1845 12375 https_resp\001
--6
-6 6075 11520 6615 12060
-5 1 0 1 0 11 51 -1 20 0.000 0 1 0 0 6345.000 11790.000 6345 11565 6120 11790 6345 12015
-5 1 0 1 0 4 51 -1 20 0.000 0 0 0 0 6345.000 11790.000 6345 11565 6570 11790 6345 12015
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 6345 11565 6345 12015
--6
-6 675 12195 1170 12555
-2 4 0 1 16 17 53 -1 -1 0.000 0 0 7 0 0 5
-	 1170 12555 1170 12195 675 12195 675 12555 1170 12555
-4 1 0 50 -1 16 6 0.0000 4 90 450 900 12420 TCPv4_S\001
--6
-6 6120 12195 6615 12555
-2 4 0 1 16 17 53 -1 -1 0.000 0 0 7 0 0 5
-	 6615 12555 6615 12195 6120 12195 6120 12555 6615 12555
-4 1 0 50 -1 16 6 0.0000 4 90 450 6345 12420 TCPv4_S\001
--6
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 1125 11655 1395 11250
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 1395 12330 1125 11925
-2 1 0 1 0 14 50 -1 -1 0.000 1 0 -1 1 1 2
-	0 0 1.00 30.00 45.00
-	0 0 1.00 30.00 45.00
-	 3645 11565 3645 11385
-2 1 0 1 0 14 50 -1 -1 0.000 1 0 -1 1 1 2
-	0 0 1.00 30.00 45.00
-	0 0 1.00 30.00 45.00
-	 3645 12195 3645 12015
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 4995 12330 4725 11925
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 4725 11655 4995 11250
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 4375 11925 4105 12330
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 4095 11250 4365 11655
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 3195 12330 2925 11925
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 2925 11655 3195 11250
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 2575 11925 2305 12330
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 2295 11250 2565 11655
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 5895 11250 6165 11655
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 6165 11925 5895 12330
-2 2 0 1 14 14 52 -1 20 0.000 2 0 -1 0 0 5
-	 3510 11610 3780 11610 3780 11970 3510 11970 3510 11610
-2 4 0 1 16 17 54 -1 20 0.000 0 0 7 0 0 5
-	 3150 12555 3150 11025 675 11025 675 12555 3150 12555
-2 3 0 1 28 30 53 -1 20 0.000 1 0 -1 0 0 11
-	 6120 11070 5895 11565 5895 12015 6120 12510 4950 12510 4410 12510
-	 4185 12015 4185 11565 4410 11070 4995 11070 6120 11070
-2 4 0 1 16 17 54 -1 20 0.000 0 0 7 0 0 5
-	 6615 12555 6615 11025 4140 11025 4140 12555 6615 12555
-2 3 0 1 28 30 53 -1 20 0.000 0 0 -1 0 0 11
-	 1170 11070 1395 11565 1395 12015 1170 12510 2340 12510 2880 12510
-	 3105 12015 3105 11565 2880 11070 2295 11070 1170 11070
-4 1 0 50 -1 16 6 0.0000 4 60 285 945 11295 server\001
-4 1 0 50 -1 16 6 0.0000 4 90 285 945 11430 socket\001
-4 1 0 50 -1 16 6 0.0000 4 75 210 4545 11430 SSL\001
-4 1 0 50 -1 16 6 0.0000 4 75 210 2745 11430 SSL\001
-4 1 0 50 -1 16 6 0.0000 4 90 255 6345 11295 client\001
-4 1 0 50 -1 16 6 0.0000 4 90 285 6345 11430 socket\001
-4 1 0 50 -1 16 6 0.0000 4 105 210 3645 11835 http\001
--6
-6 630 6750 2970 8100
-6 630 7155 1170 7695
-5 1 0 1 0 11 51 -1 20 0.000 0 0 0 0 900.000 7425.000 900 7200 1125 7425 900 7650
-5 1 0 1 0 4 51 -1 20 0.000 0 1 0 0 900.000 7425.000 900 7200 675 7425 900 7650
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 900 7200 900 7650
--6
-6 2430 7155 2970 7695
-5 1 0 1 0 11 51 -1 20 0.000 0 1 0 0 2700.000 7425.000 2700 7200 2475 7425 2700 7650
-5 1 0 1 0 4 51 -1 20 0.000 0 0 0 0 2700.000 7425.000 2700 7200 2925 7425 2700 7650
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 2700 7200 2700 7650
--6
-6 1350 6750 2250 7020
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 2205 6750 2205 7020
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 2160 6750 2160 7020
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 1395 6750 1395 7020
-2 2 0 1 0 6 51 -1 20 0.000 1 0 -1 0 0 5
-	 1350 6750 2250 6750 2250 7020 1350 7020 1350 6750
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 1440 6750 1440 7020
-4 1 0 50 -1 16 6 0.0000 4 105 420 1800 6930 http_req\001
--6
-6 1305 7020 1845 7830
-5 1 0 1 0 11 51 -1 20 0.000 0 0 0 0 1575.000 7425.000 1710 7245 1800 7425 1710 7605
-5 1 0 1 0 11 51 -1 20 0.000 0 1 0 0 1575.000 7425.000 1440 7245 1350 7425 1440 7605
-5 1 0 1 0 14 51 -1 20 0.000 0 0 0 0 1575.000 7425.000 1710 7605 1575 7650 1440 7605
-5 1 0 1 0 14 51 -1 20 0.000 0 1 0 0 1575.000 7425.000 1710 7245 1575 7200 1440 7245
-2 1 0 1 0 14 50 -1 -1 0.000 1 0 -1 1 1 2
-	0 0 1.00 30.00 45.00
-	0 0 1.00 30.00 45.00
-	 1575 7200 1575 7020
-2 1 0 1 0 14 50 -1 -1 0.000 1 0 -1 1 1 2
-	0 0 1.00 30.00 45.00
-	0 0 1.00 30.00 45.00
-	 1575 7830 1575 7650
-2 2 0 1 14 14 52 -1 20 0.000 2 0 -1 0 0 5
-	 1440 7245 1710 7245 1710 7605 1440 7605 1440 7245
-4 1 0 50 -1 16 6 0.0000 4 105 210 1575 7470 http\001
--6
-6 1755 7020 2295 7830
-5 1 0 1 0 14 51 -1 20 0.000 0 0 0 0 2025.000 7425.000 2160 7605 2025 7650 1890 7605
-5 1 0 1 0 14 51 -1 20 0.000 0 1 0 0 2025.000 7425.000 2160 7245 2025 7200 1890 7245
-5 1 0 1 0 11 51 -1 20 0.000 0 1 0 0 2025.000 7425.000 1890 7245 1800 7425 1890 7605
-5 1 0 1 0 11 51 -1 20 0.000 0 0 0 0 2025.000 7425.000 2160 7245 2250 7425 2160 7605
-2 1 0 1 0 14 50 -1 -1 0.000 1 0 -1 1 1 2
-	0 0 1.00 30.00 45.00
-	0 0 1.00 30.00 45.00
-	 2025 7200 2025 7020
-2 1 0 1 0 14 50 -1 -1 0.000 1 0 -1 1 1 2
-	0 0 1.00 30.00 45.00
-	0 0 1.00 30.00 45.00
-	 2025 7830 2025 7650
-2 2 0 1 14 14 52 -1 20 0.000 2 0 -1 0 0 5
-	 1890 7245 2160 7245 2160 7605 1890 7605 1890 7245
-4 1 0 50 -1 16 6 0.0000 4 105 390 2025 7470 filtering\001
--6
-6 1350 7830 2250 8100
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 2205 7830 2205 8100
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 2160 7830 2160 8100
-2 2 0 1 0 6 51 -1 20 0.000 1 0 -1 0 0 5
-	 1350 7830 2250 7830 2250 8100 1350 8100 1350 7830
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 1395 7830 1395 8100
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 1440 7830 1440 8100
-4 1 0 50 -1 16 6 0.0000 4 105 465 1800 8010 http_resp\001
--6
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 2250 6885 2520 7290
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 1080 7290 1350 6885
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 1350 7965 1080 7560
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 2520 7560 2250 7965
-4 1 0 50 -1 16 6 0.0000 4 60 285 900 6930 server\001
-4 1 0 50 -1 16 6 0.0000 4 90 285 900 7065 socket\001
-4 1 0 50 -1 16 6 0.0000 4 90 255 2700 6930 client\001
-4 1 0 50 -1 16 6 0.0000 4 90 285 2700 7065 socket\001
--6
-6 4680 9000 8820 10530
-5 1 0 1 0 11 51 -1 20 0.000 0 0 0 0 7650.000 9765.000 7785 9585 7875 9765 7785 9945
-5 1 0 1 0 11 51 -1 20 0.000 0 1 0 0 7650.000 9765.000 7515 9585 7425 9765 7515 9945
-5 1 0 1 0 14 51 -1 20 0.000 0 0 0 0 7650.000 9765.000 7785 9945 7650 9990 7515 9945
-5 1 0 1 0 14 51 -1 20 0.000 0 1 0 0 7650.000 9765.000 7785 9585 7650 9540 7515 9585
-6 4680 9495 5220 10035
-5 1 0 1 0 11 51 -1 20 0.000 0 0 0 0 4950.000 9765.000 4950 9540 5175 9765 4950 9990
-5 1 0 1 0 4 51 -1 20 0.000 0 1 0 0 4950.000 9765.000 4950 9540 4725 9765 4950 9990
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 4950 9540 4950 9990
--6
-6 8280 9495 8820 10035
-5 1 0 1 0 11 51 -1 20 0.000 0 1 0 0 8550.000 9765.000 8550 9540 8325 9765 8550 9990
-5 1 0 1 0 4 51 -1 20 0.000 0 0 0 0 8550.000 9765.000 8550 9540 8775 9765 8550 9990
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 8550 9540 8550 9990
--6
-6 7200 9090 8100 9360
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 8055 9090 8055 9360
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 8010 9090 8010 9360
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 7245 9090 7245 9360
-2 2 0 1 0 6 51 -1 20 0.000 1 0 -1 0 0 5
-	 7200 9090 8100 9090 8100 9360 7200 9360 7200 9090
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 7290 9090 7290 9360
-4 1 0 50 -1 16 6 0.0000 4 105 420 7650 9270 http_req\001
--6
-6 7200 10170 8100 10440
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 8055 10170 8055 10440
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 8010 10170 8010 10440
-2 2 0 1 0 6 51 -1 20 0.000 1 0 -1 0 0 5
-	 7200 10170 8100 10170 8100 10440 7200 10440 7200 10170
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 7245 10170 7245 10440
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 7290 10170 7290 10440
-4 1 0 50 -1 16 6 0.0000 4 105 465 7650 10350 http_resp\001
--6
-6 6480 9495 7020 10035
-5 1 0 1 0 11 51 -1 20 0.000 0 1 0 0 6750.000 9765.000 6750 9540 6525 9765 6750 9990
-5 1 0 1 0 11 51 -1 20 0.000 0 0 0 0 6750.000 9765.000 6750 9540 6975 9765 6750 9990
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 6750 9540 6750 9990
--6
-6 5400 10170 6300 10440
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 6255 10170 6255 10440
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 6210 10170 6210 10440
-2 2 0 1 0 6 51 -1 20 0.000 1 0 -1 0 0 5
-	 5400 10170 6300 10170 6300 10440 5400 10440 5400 10170
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 5445 10170 5445 10440
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 5490 10170 5490 10440
-4 1 0 50 -1 16 6 0.0000 4 105 510 5850 10350 https_resp\001
--6
-6 5400 9090 6300 9360
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 6255 9090 6255 9360
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 6210 9090 6210 9360
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 5445 9090 5445 9360
-2 2 0 1 0 6 51 -1 20 0.000 1 0 -1 0 0 5
-	 5400 9090 6300 9090 6300 9360 5400 9360 5400 9090
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 5490 9090 5490 9360
-4 1 0 50 -1 16 6 0.0000 4 105 465 5850 9270 https_req\001
--6
-6 4680 10170 5175 10530
-2 4 0 1 16 17 53 -1 -1 0.000 0 0 7 0 0 5
-	 5175 10530 5175 10170 4680 10170 4680 10530 5175 10530
-4 1 0 50 -1 16 6 0.0000 4 90 450 4905 10395 TCPv4_S\001
--6
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 5130 9630 5400 9225
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 5400 10305 5130 9900
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 8100 9225 8370 9630
-2 1 0 1 0 14 50 -1 -1 0.000 1 0 -1 1 1 2
-	0 0 1.00 30.00 45.00
-	0 0 1.00 30.00 45.00
-	 7650 9540 7650 9360
-2 1 0 1 0 14 50 -1 -1 0.000 1 0 -1 1 1 2
-	0 0 1.00 30.00 45.00
-	0 0 1.00 30.00 45.00
-	 7650 10170 7650 9990
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 7200 10305 6930 9900
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 8370 9900 8100 10305
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 6930 9630 7200 9225
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 6580 9900 6310 10305
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 6300 9225 6570 9630
-2 2 0 1 14 14 52 -1 20 0.000 2 0 -1 0 0 5
-	 7515 9585 7785 9585 7785 9945 7515 9945 7515 9585
-2 4 0 1 16 17 54 -1 20 0.000 0 0 7 0 0 5
-	 7155 10530 7155 9000 4680 9000 4680 10530 7155 10530
-2 3 0 1 28 30 53 -1 20 0.000 1 0 -1 0 0 11
-	 5175 9045 5400 9540 5400 9990 5175 10485 6345 10485 6885 10485
-	 7110 9990 7110 9540 6885 9045 6300 9045 5175 9045
-4 1 0 50 -1 16 6 0.0000 4 60 285 4950 9270 server\001
-4 1 0 50 -1 16 6 0.0000 4 90 285 4950 9405 socket\001
-4 1 0 50 -1 16 6 0.0000 4 90 255 8550 9270 client\001
-4 1 0 50 -1 16 6 0.0000 4 90 285 8550 9405 socket\001
-4 1 0 50 -1 16 6 0.0000 4 75 210 6750 9405 SSL\001
-4 1 0 50 -1 16 6 0.0000 4 105 210 7650 9810 http\001
--6
-6 675 9000 4275 10575
-6 1800 9900 2250 10125
-2 2 0 1 29 30 51 -1 20 0.000 0 0 -1 0 0 5
-	 1800 9900 2250 9900 2250 10125 1800 10125 1800 9900
-4 1 0 50 -1 16 6 0.0000 4 75 210 2025 10035 SSL\001
--6
-6 2700 9900 3150 10125
-2 2 0 1 29 30 51 -1 20 0.000 0 0 -1 0 0 5
-	 2700 9900 3150 9900 3150 10125 2700 10125 2700 9900
-4 1 0 50 -1 16 6 0.0000 4 75 210 2925 10035 SSL\001
--6
-6 3600 9900 4050 10125
-2 2 0 1 29 30 51 -1 20 0.000 0 0 -1 0 0 5
-	 3600 9900 4050 9900 4050 10125 3600 10125 3600 9900
-4 1 0 50 -1 16 6 0.0000 4 75 210 3825 10035 SSL\001
--6
-6 900 9900 1350 10125
-2 2 0 1 29 30 51 -1 20 0.000 0 0 -1 0 0 5
-	 900 9900 1350 9900 1350 10125 900 10125 900 9900
-4 1 0 50 -1 16 6 0.0000 4 75 210 1125 10035 SSL\001
--6
-6 2520 10350 3330 10575
-2 2 0 1 16 17 51 -1 20 0.000 0 0 -1 0 0 5
-	 2520 10350 3330 10350 3330 10575 2520 10575 2520 10350
-4 1 0 50 -1 16 6 0.0000 4 90 510 2925 10485 UNIX_STR\001
--6
-6 1125 9450 1575 9675
-2 2 0 1 9 11 51 -1 20 0.000 0 0 -1 0 0 5
-	 1125 9450 1575 9450 1575 9675 1125 9675 1125 9450
-4 1 0 50 -1 16 6 0.0000 4 90 315 1350 9585 deflate\001
--6
-6 2025 9450 2475 9675
-2 2 0 1 9 11 51 -1 20 0.000 0 0 -1 0 0 5
-	 2025 9450 2475 9450 2475 9675 2025 9675 2025 9450
-4 1 0 50 -1 16 6 0.0000 4 90 315 2250 9585 deflate\001
--6
-6 2925 9450 3375 9675
-2 2 0 1 9 11 51 -1 20 0.000 0 0 -1 0 0 5
-	 2925 9450 3375 9450 3375 9675 2925 9675 2925 9450
-4 1 0 50 -1 16 6 0.0000 4 90 315 3150 9585 deflate\001
--6
-6 3825 9450 4275 9675
-2 2 0 1 9 11 51 -1 20 0.000 0 0 -1 0 0 5
-	 3825 9450 4275 9450 4275 9675 3825 9675 3825 9450
-4 1 0 50 -1 16 6 0.0000 4 90 315 4050 9585 deflate\001
--6
-6 675 10350 1530 10575
-2 2 0 1 16 17 51 -1 20 0.000 0 0 -1 0 0 5
-	 675 10350 1530 10350 1530 10575 675 10575 675 10350
-4 1 0 50 -1 16 6 0.0000 4 75 315 1125 10485 TCPv4\001
--6
-6 1620 10350 2430 10575
-2 2 0 1 16 17 51 -1 20 0.000 0 0 -1 0 0 5
-	 1620 10350 2430 10350 2430 10575 1620 10575 1620 10350
-4 1 0 50 -1 16 6 0.0000 4 75 315 2025 10485 TCPv6\001
--6
-6 3420 10350 4275 10575
-2 2 0 1 16 17 51 -1 20 0.000 0 0 -1 0 0 5
-	 3420 10350 4275 10350 4275 10575 3420 10575 3420 10350
-4 1 0 50 -1 16 6 0.0000 4 75 330 3825 10485 PIPES\001
--6
-6 675 9000 4275 9225
-2 2 0 1 12 14 51 -1 20 0.000 0 0 -1 0 0 5
-	 675 9000 4275 9000 4275 9225 675 9225 675 9000
-4 1 0 50 -1 16 6 0.0000 4 105 1950 2475 9135 HTTP flow analyzer using stream interfaces\001
--6
-2 1 0 1 20 -1 50 -1 -1 0.000 1 0 -1 0 1 2
-	0 0 1.00 30.00 45.00
-	 765 10350 765 9225
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 810 10350 810 9225
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 0 1 2
-	0 0 1.00 30.00 45.00
-	 990 9900 990 9225
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 1035 9900 1035 9225
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 1170 10350 1170 10125
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 0 1 2
-	0 0 1.00 30.00 45.00
-	 1215 9900 1215 9675
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 1260 9900 1260 9675
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 1395 9450 1395 9225
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 0 1 2
-	0 0 1.00 30.00 45.00
-	 1440 10350 1440 9675
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 1485 10350 1485 9675
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 0 1 2
-	0 0 1.00 30.00 45.00
-	 1665 10350 1665 9225
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 1710 10350 1710 9225
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 0 1 2
-	0 0 1.00 30.00 45.00
-	 1890 9900 1890 9225
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 1935 9900 1935 9225
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 2070 10350 2070 10125
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 0 1 2
-	0 0 1.00 30.00 45.00
-	 2115 9900 2115 9675
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 2160 9900 2160 9675
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 2295 9450 2295 9225
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 0 1 2
-	0 0 1.00 30.00 45.00
-	 2340 10350 2340 9675
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 2385 10350 2385 9675
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 0 1 2
-	0 0 1.00 30.00 45.00
-	 2565 10350 2565 9225
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 2610 10350 2610 9225
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 0 1 2
-	0 0 1.00 30.00 45.00
-	 2790 9900 2790 9225
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 2835 9900 2835 9225
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 0 1 2
-	0 0 1.00 30.00 45.00
-	 3015 9900 3015 9675
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 3060 9900 3060 9675
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 2970 10350 2970 10125
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 0 1 2
-	0 0 1.00 30.00 45.00
-	 3240 10350 3240 9675
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 3285 10350 3285 9675
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 3195 9450 3195 9225
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 0 1 2
-	0 0 1.00 30.00 45.00
-	 3465 10350 3465 9225
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 3510 10350 3510 9225
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 0 1 2
-	0 0 1.00 30.00 45.00
-	 3690 9900 3690 9225
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 3735 9900 3735 9225
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 3870 10350 3870 10125
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 0 1 2
-	0 0 1.00 30.00 45.00
-	 3915 9900 3915 9675
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 3960 9900 3960 9675
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 0 1 2
-	0 0 1.00 30.00 45.00
-	 4140 10350 4140 9675
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 4185 10350 4185 9675
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 4095 9450 4095 9225
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 0 1 2
-	0 0 1.00 30.00 45.00
-	 1350 9450 1350 9225
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 0 1 2
-	0 0 1.00 30.00 45.00
-	 2250 9450 2250 9225
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 0 1 2
-	0 0 1.00 30.00 45.00
-	 3150 9450 3150 9225
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 0 1 2
-	0 0 1.00 30.00 45.00
-	 4050 9450 4050 9225
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 0 1 2
-	0 0 1.00 30.00 45.00
-	 3825 10350 3825 10125
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 0 1 2
-	0 0 1.00 30.00 45.00
-	 2925 10350 2925 10125
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 0 1 2
-	0 0 1.00 30.00 45.00
-	 2025 10350 2025 10125
-2 1 0 1 20 14 50 -1 -1 0.000 1 0 -1 0 1 2
-	0 0 1.00 30.00 45.00
-	 1125 10350 1125 10125
--6
-6 3780 6750 6120 8100
-5 1 0 1 0 11 51 -1 20 0.000 0 0 0 0 4725.000 7425.000 4860 7245 4950 7425 4860 7605
-5 1 0 1 0 11 51 -1 20 0.000 0 1 0 0 4725.000 7425.000 4590 7245 4500 7425 4590 7605
-5 1 0 1 0 14 51 -1 20 0.000 0 0 0 0 4725.000 7425.000 4860 7605 4725 7650 4590 7605
-5 1 0 1 0 14 51 -1 20 0.000 0 1 0 0 4725.000 7425.000 4860 7245 4725 7200 4590 7245
-5 1 0 1 0 14 51 -1 20 0.000 0 0 0 0 5175.000 7425.000 5310 7605 5175 7650 5040 7605
-5 1 0 1 0 14 51 -1 20 0.000 0 1 0 0 5175.000 7425.000 5310 7245 5175 7200 5040 7245
-5 1 0 1 0 11 51 -1 20 0.000 0 1 0 0 5175.000 7425.000 5040 7245 4950 7425 5040 7605
-5 1 0 1 0 11 51 -1 20 0.000 0 0 0 0 5175.000 7425.000 5310 7245 5400 7425 5310 7605
-6 3780 7155 4320 7695
-5 1 0 1 0 11 51 -1 20 0.000 0 0 0 0 4050.000 7425.000 4050 7200 4275 7425 4050 7650
-5 1 0 1 0 4 51 -1 20 0.000 0 1 0 0 4050.000 7425.000 4050 7200 3825 7425 4050 7650
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 4050 7200 4050 7650
--6
-6 5580 7155 6120 7695
-5 1 0 1 0 11 51 -1 20 0.000 0 1 0 0 5850.000 7425.000 5850 7200 5625 7425 5850 7650
-5 1 0 1 0 4 51 -1 20 0.000 0 0 0 0 5850.000 7425.000 5850 7200 6075 7425 5850 7650
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 5850 7200 5850 7650
--6
-6 4500 6750 5400 7020
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 5355 6750 5355 7020
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 5310 6750 5310 7020
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 4545 6750 4545 7020
-2 2 0 1 0 6 51 -1 20 0.000 1 0 -1 0 0 5
-	 4500 6750 5400 6750 5400 7020 4500 7020 4500 6750
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 4590 6750 4590 7020
-4 1 0 50 -1 16 6 0.0000 4 105 420 4950 6930 http_req\001
--6
-6 4500 7830 5400 8100
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 5355 7830 5355 8100
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 5310 7830 5310 8100
-2 2 0 1 0 6 51 -1 20 0.000 1 0 -1 0 0 5
-	 4500 7830 5400 7830 5400 8100 4500 8100 4500 7830
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 4545 7830 4545 8100
-2 1 0 1 0 14 50 -1 -1 0.000 0 0 -1 0 0 2
-	 4590 7830 4590 8100
-4 1 0 50 -1 16 6 0.0000 4 105 465 4950 8010 http_resp\001
--6
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 5400 6885 5670 7290
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 4230 7290 4500 6885
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 4500 7965 4230 7560
-2 1 0 1 0 0 50 -1 -1 0.000 1 0 -1 1 0 2
-	0 0 1.00 30.00 45.00
-	 5670 7560 5400 7965
-2 1 0 1 0 14 50 -1 -1 0.000 1 0 -1 1 1 2
-	0 0 1.00 30.00 45.00
-	0 0 1.00 30.00 45.00
-	 4725 7200 4725 7020
-2 2 0 1 14 14 52 -1 20 0.000 2 0 -1 0 0 5
-	 4590 7245 4860 7245 4860 7605 4590 7605 4590 7245
-2 1 0 1 0 14 50 -1 -1 0.000 1 0 -1 1 1 2
-	0 0 1.00 30.00 45.00
-	0 0 1.00 30.00 45.00
-	 5175 7830 5175 7650
-2 2 0 1 14 14 52 -1 20 0.000 2 0 -1 0 0 5
-	 5040 7245 5310 7245 5310 7605 5040 7605 5040 7245
-4 1 0 50 -1 16 6 0.0000 4 60 285 4050 6930 server\001
-4 1 0 50 -1 16 6 0.0000 4 90 285 4050 7065 socket\001
-4 1 0 50 -1 16 6 0.0000 4 90 255 5850 6930 client\001
-4 1 0 50 -1 16 6 0.0000 4 90 285 5850 7065 socket\001
-4 1 0 50 -1 16 6 0.0000 4 105 210 4725 7425 http\001
-4 1 0 50 -1 16 6 0.0000 4 75 150 4725 7515 req\001
-4 1 0 50 -1 16 6 0.0000 4 105 210 5175 7425 http\001
-4 1 0 50 -1 16 6 0.0000 4 75 195 5175 7515 resp\001
--6
-4 0 0 53 -1 19 11 0.0000 4 180 5520 675 8775 Multi-layer protocol encapsulation using intermediate buffers :\001
-4 0 0 53 -1 19 11 0.0000 4 180 4200 675 6525 Multiple protocol processing on the same flow :\001
-4 0 0 53 -1 19 11 0.0000 4 180 2085 675 3600 Principles of operation :\001
diff --git a/deps/haproxy-1.4.21/doc/design-thoughts/config-language.txt b/deps/haproxy-1.4.21/doc/design-thoughts/config-language.txt
deleted file mode 100644
index 510ada6..0000000
--- a/deps/haproxy-1.4.21/doc/design-thoughts/config-language.txt
+++ /dev/null
@@ -1,262 +0,0 @@
-Prvoir des commandes en plusieurs mots cls.
-Par exemple :
-
-  timeout connection XXX
-  connection scale XXX
-
-On doit aussi accepter les prfixes :
-
-  tim co XXX
-  co sca XXX
-
-Prvoir de ranger les combinaisons dans un tableau. On doit mme
-pouvoir effectuer un mapping simplifiant le parseur.
-
-
-Pour les filtres :
-
-
-    <direction> <where> <what> <operator> <pattern> <action> [ <args>* ]
-
-    <direction> = [ req | rsp ]
-    <where>     = [ in | out ]
-    <what>      = [ line | LINE | METH | URI | h(hdr) | H(hdr) | c(cookie) | C(cookie) ]
-    <operator>  = [ == | =~ | =* | =^ | =/ | != | !~ | !* | !^ | !/ ]
-    <pattern>   = "<string>"
-    <action>    = [ allow | permit | deny | delete | replace | switch | add | set | redir ]
-    <args>      = optionnal action args
-
-    exemples:
-
-        req in URI     =^ "/images" switch images
-        req in h(host) =* ".mydomain.com" switch mydomain
-        req in h(host) =~ "localhost(.*)" replace "www\1"
-
-    alternative :
-
-    <direction> <where> <action> [not] <what> [<operator> <pattern> [ <args>* ]]
-
-        req in  switch   URI     =^ "/images" images
-        req in  switch   h(host) =* ".mydomain.com" mydomain
-        req in  replace  h(host) =~ "localhost(.*)" "www\1"
-        req in  delete   h(Connection)
-        req in  deny not line =~ "((GET|HEAD|POST|OPTIONS) /)|(OPTIONS *)"
-        req out set      h(Connection) "close"
-        req out add      line "Server: truc"
-
-
-    <direction> <action> <where> [not] <what> [<operator> <pattern> [ <args>* ]] ';' <action2> <what2>
-
-        req in  switch   URI     =^ "/images/" images ; replace "/"
-        req in  switch   h(host) =* ".mydomain.com" mydomain
-        req in  replace  h(host) =~ "localhost(.*)" "www\1"
-        req in  delete   h(Connection)
-        req in  deny not line =~ "((GET|HEAD|POST|OPTIONS) /)|(OPTIONS *)"
-        req out set      h(Connection) "close"
-        req out add      line == "Server: truc"
-
-
-Extension avec des ACL :
-
-        req in acl(meth_valid)   METH =~ "(GET|POST|HEAD|OPTIONS)"  
-        req in acl(meth_options) METH == "OPTIONS" 
-        req in acl(uri_slash)    URI  =^ "/" 
-        req in acl(uri_star)     URI  == "*" 
-
-        req in deny acl !(meth_options && uri_star || meth_valid && uri_slash)
-
-Peut-tre plus simplement :
-
-        acl meth_valid   METH =~ "(GET|POST|HEAD|OPTIONS)"  
-        acl meth_options METH == "OPTIONS" 
-        acl uri_slash    URI  =^ "/" 
-        acl uri_star     URI  == "*" 
-
-        req in  deny not acl(meth_options uri_star, meth_valid uri_slash)
-
-        req in  switch   URI     =^ "/images/" images ; replace "/"
-        req in  switch   h(host) =* ".mydomain.com" mydomain
-        req in  replace  h(host) =~ "localhost(.*)" "www\1"
-        req in  delete   h(Connection)
-        req in  deny not line =~ "((GET|HEAD|POST|OPTIONS) /)|(OPTIONS *)"
-        req out set      h(Connection) "close"
-        req out add      line == "Server: truc"
-
-Prvoir le cas du "if" pour excuter plusieurs actions :
-
-        req in  if URI =^ "/images/" then replace "/" ; switch images
-
-Utiliser les noms en majuscules/minuscules pour indiquer si on veut prendre
-en compte la casse ou non :
-
-        if uri  =^ "/watch/"       setbe watch   rebase "/watch/" "/"
-        if uri  =* ".jpg"          setbe images
-        if uri  =~ ".*dll.*"       deny
-        if HOST =* ".mydomain.com" setbe mydomain
-        etc...
-
-Another solution would be to have a dedicated keyword to URI remapping. It
-would both rewrite the URI and optionally switch to another backend.
-
-        uriremap "/watch/"  "/"       watch
-        uriremap "/chat/"   "/"       chat
-        uriremap "/event/"  "/event/" event
-
-Or better :
-
-        uriremap "/watch/"  watch  "/"
-        uriremap "/chat/"   chat   "/"
-        uriremap "/event/"  event
-
-For the URI, using a regex is sometimes useful (eg: providing a set of possible prefixes.
-
-
-Sinon, peut-tre que le "switch" peut prendre un paramtre de mapping pour la partie matche :
-
-        req in  switch   URI     =^ "/images/" images:"/"
-
-
-2007/03/31 - Besoins plus prcis.
-
-1) aucune extension de branchement ou autre dans les "listen", c'est trop complexe.
-
-Distinguer les donnes entrantes (in) et sortantes (out).
-
-Le frontend ne voit que les requetes entrantes et les rponses sortantes.
-Le backend voir les requtes in/out et les rponses in/out.
-Le frontend permet les branchements d'ensembles de filtres de requtes vers
-d'autres. Le frontend et les ensembles de filtres de requtes peuvent brancher
-vers un backend.
-
------------+--------+----------+----------+---------+----------+
-  \  Where |        |          |          |         |          |
-   \______ | Listen | Frontend | ReqRules | Backend | RspRules |
-          \|        |          |          |         |          |
-Capability |        |          |          |         |          |
------------+--------+----------+----------+---------+----------+
-Frontend   |    X   |     X    |          |         |          |
------------+--------+----------+----------+---------+----------+
-FiltReqIn  |    X   |     X    |     X    |    X    |          |
------------+--------+----------+----------+---------+----------+
-JumpFiltReq|    X   |     X    |     X    |         |          | \
------------+--------+----------+----------+---------+----------+  > = ReqJump
-SetBackend |    X   |     X    |     X    |         |          | /
------------+--------+----------+----------+---------+----------+
-FiltReqOut |        |          |          |    X    |          |
------------+--------+----------+----------+---------+----------+
-FiltRspIn  |    X   |          |          |    X    |     X    |
------------+--------+----------+----------+---------+----------+
-JumpFiltRsp|        |          |          |    X    |     X    |
------------+--------+----------+----------+---------+----------+
-FiltRspOut |        |     X    |          |    X    |     X    |
------------+--------+----------+----------+---------+----------+
-Backend    |    X   |          |          |    X    |          |
------------+--------+----------+----------+---------+----------+
-
-En conclusion
--------------
-
-Il y a au moins besoin de distinguer 8 fonctionnalits de base :
- - capacit  recevoir des connexions (frontend)
- - capacit  filtrer les requtes entrantes
- - capacit  brancher vers un backend ou un ensemble de rgles de requtes
- - capacit  filtrer les requtes sortantes
- - capacit  filtrer les rponses entrantes
- - capacit  brancher vers un autre ensemble de rgles de rponses
- - capacit  filtrer la rponse sortante
- - capacit  grer des serveurs (backend)
-
-Remarque
---------
- - on a souvent besoin de pouvoir appliquer un petit traitement sur un ensemble
-   host/uri/autre. Le petit traitement peut consister en quelques filtres ainsi
-   qu'une rcriture du couple (host,uri).
-
-
-Proposition : ACL
-
-Syntaxe :
----------
-
-   acl <name> <what> <operator> <value> ...
-
-Ceci crera une acl rfrence sous le nom <name> qui sera valide si
-l'application d'au moins une des valeurs <value> avec l'oprateur <operator>
-sur le sujet <what> est valide.
-
-Oprateurs :
-------------
-
-Toujours 2 caractres :
-
-  [=!][~=*^%/.]
-
-Premier caractre :  
-   '=' : OK si test valide
-   '!' : OK si test chou.
-
-Second caractre :
-   '~' : compare avec une regex
-   '=' : compare chane  chane
-   '*' : compare la fin de la chane (ex: =* ".mydomain.com")
-   '^' : compare le dbut de la chane (ex: =^ "/images/")
-   '%' : recherche une sous-chane
-   '/' : compare avec un mot entier en acceptant le '/' comme dlimiteur
-   '.' : compare avec un mot entier en acceptant el '.' comme dlimiteur
-
-Ensuite on excute une action de manire conditionnelle si l'ensemble des ACLs
-mentionnes sont valides (ou invalides pour celles prcdes d'un "!") :
-
-   <what> <where> <action> on [!]<aclname> ...
-
-
-Exemple :
----------
-
-   acl www_pub host =. www www01 dev preprod
-   acl imghost host =. images
-   acl imgdir   uri =/ img
-   acl imagedir uri =/ images
-   acl msie h(user-agent) =% "MSIE"
-
-   set_host  "images"       on www_pub imgdir 
-   remap_uri "/img"    "/"  on www_pub imgdir
-   remap_uri "/images" "/"  on www_pub imagedir
-   setbe images             on imghost
-   reqdel "Cookie"          on all
-
-
-
-Actions possibles :
-
-   req  {in|out} {append|delete|rem|add|set|rep|mapuri|rewrite|reqline|deny|allow|setbe|tarpit}
-   resp {in|out} {append|delete|rem|add|set|rep|maploc|rewrite|stsline|deny|allow}
-
-   req in append <line>
-   req in delete <line_regex>
-   req in rem <header>
-   req in add <header> <new_value>
-   req in set <header> <new_value>
-   req in rep <header> <old_value> <new_value>
-   req in mapuri  <old_uri_prefix> <new_uri_prefix>
-   req in rewrite <old_uri_regex>  <new_uri>
-   req in reqline <old_req_regex>  <new_req>
-   req in deny
-   req in allow
-   req in tarpit
-   req in setbe <backend>
-
-   resp out maploc <old_location_prefix> <new_loc_prefix>
-   resp out stsline <old_sts_regex> <new_sts_regex>
-
-Les chanes doivent tre dlimites par un mme caractre au dbut et  la fin,
-qui doit tre chapp s'il est prsent dans la chane. Tout ce qui se trouve
-entre le caractre de fin et les premiers espace est considr comme des
-options passes au traitement. Par exemple :
-
-   req in rep host /www/i /www/
-   req in rep connection /keep-alive/i "close"
-
-Il serait pratique de pouvoir effectuer un remap en mme temps qu'un setbe.
-
-Captures: les sparer en in/out. Les rendre conditionnelles ?
diff --git a/deps/haproxy-1.4.21/doc/design-thoughts/cttproxy-changes.txt b/deps/haproxy-1.4.21/doc/design-thoughts/cttproxy-changes.txt
deleted file mode 100644
index 6f34f3d..0000000
--- a/deps/haproxy-1.4.21/doc/design-thoughts/cttproxy-changes.txt
+++ /dev/null
@@ -1,101 +0,0 @@
-Ncessite CAP_NET_ADMIN (12)
-On peut donc aussi mettre CAP_NET_BIND_SERVICE (10) pour autoriser les ports < 1024
-
-
-charger le module :
-# modprobe ip_conntrack hashsize=65536
-# modprobe iptable_tproxy hashsize=65536
-# echo 15 > /proc/sys/net/ipv4/netfilter/ip_conntrack_tcp_timeout_time_wait 
-# echo 30 > /proc/sys/net/ipv4/netfilter/ip_conntrack_tcp_timeout_fin_wait 
-
-
-Si on utilise "usesrc client", alors on rencontre ce problme en cas
-de rutilisation d'un port :
-
-# dmesg
-IP_TPROXY: error applying NAT mapping, hooknum=4 0103000a:e5a2 -> 05000001:d204
-IP_TPROXY: error applying NAT mapping, hooknum=4 0103000a:e5a2 -> 05000001:d204
-
-Solution retenue pour la configuration :
-
-  You have to write "usesrc XXXX" on the "source" line. "XXXX" is either
-  an IP address or the keyword "clientip" to reuse the client's IP with
-  a dynamically allocated port, or "client" to reuse both the client's IP
-  and port (dangerous). But due to the way cttproxy works, the source address
-  is mandatory. Eg:
-
-  backend static
-      source 192.168.1.254 usesrc clientip
-      server static1 192.168.1.10 source 192.168.1.254 usesrc clientip
-
-
----- Anciennes rflexions ----
-
-Il faudrait donc peut-tre toujours avoir un port dynamique, ou bien
-traiter le TIME_WAIT correctement en appliquant natdel => corrige pratiquement
-toujours le problme (mais rduire les timeouts semble important)
-
-
-  source 10.1.2.3 present 10.2.3.4
-  source 10.1.2.3 present same_ip
-  source 10.1.2.3 present same
-  source 10.1.2.3:5000 present same
-
-  source 10.1.2.3 appear_as 10.2.3.4
-  source 10.1.2.3 appear_as same_ip
-  source 10.1.2.3 appear_as same
-  source 10.1.2.3:5000 appear_as same
-
-  source 10.1.2.3 {keepsrc | keepip | usesrc 1.2.3.4}
-
-  source 10.1.2.3 snat { client | clientip | 1.2.3.4 }
-  source 10.1.2.3 extbind same
-  source 10.1.2.3 intercept same
-  source 10.1.2.3 spoof same
-  source 10.1.2.3 showsrc same
-  source 10.1.2.3 usesrc same
-  source 10.1.2.3 setsrc same
-  source 10.1.2.3 withsrc same
-  source 10.1.2.3 usesrc clientip:sameport
-  source 10.1.2.3 alias same
-  source 10.1.2.3 as same
-  source 10.1.2.3 outgoing same
-  source 10.1.2.3 public same
-  source 10.1.2.3:5000 pretend same
-
-  source 10.1.2.3=same
-  source 10.1.2.3=10.2.3.4
-
-  source 10.1.2.3^same
-  source 10.1.2.3^10.2.3.4
-
-  source 10.1.2.3@same
-  source 10.1.2.3@10.2.3.4
-
-  source 10.1.2.3!same
-  source 10.1.2.3!10.2.3.4
-
-  source 10.1.2.3|same
-  source 10.1.2.3|10.2.3.4
-
-  source 10.1.2.3(same)
-  source 10.1.2.3(10.2.3.4)
-
-  source 10.1.2.3~same
-  source 10.1.2.3~10.2.3.4
-
-A l'inverse, si "source" contient l'adresse vue :
-
-  source same bindto 1.2.3.4
-  source 2.3.4.5 bindto 1.2.3.4
-
-Problme: si "bindto" est oubli, le bind sur 2.3.4.5 ne fonctionnera pas.
-
-Pour l'adresse de listen (avec "bind"), il serait bien que l'adresse
-translate apparaisse au mme niveau que l'IP afin que les plages et
-listes continuent de fonctionner par association.
-
-Diffrences entre source et bind :
-  - source: 1 seule IP source, ventuellement un port, plus tard une plage
-  - bind  : liste de (IP source facultatives, port obligatoire, parfois une plage)
-
diff --git a/deps/haproxy-1.4.21/doc/design-thoughts/how-it-works.txt b/deps/haproxy-1.4.21/doc/design-thoughts/how-it-works.txt
deleted file mode 100644
index 2d1cb89..0000000
--- a/deps/haproxy-1.4.21/doc/design-thoughts/how-it-works.txt
+++ /dev/null
@@ -1,60 +0,0 @@
-How it works ?  (unfinished and inexact)
-
-For TCP and HTTP :
-
-- listeners create listening sockets with a READ callback pointing to the
-  protocol-specific accept() function. 
-
-- the protocol-specific accept() function then accept()'s the connection and
-  instantiates a "server TCP socket" (which is dedicated to the client side),
-  and configures it (non_block, get_original_dst, ...).
-
-For TCP :
-- in case of pure TCP, a request buffer is created, as well as a "client TCP
-  socket", which tries to connect to the server.
-
-- once the connection is established, the response buffer is allocated and
-  connected to both ends.
-
-- both sockets are set to "autonomous mode" so that they only wake up their
-  supervising session when they encounter a special condition (error or close).
-
-
-For HTTP :
-- in case of HTTP, a request buffer is created with the "HOLD" flag set and
-  a read limit to support header rewriting (may be this one will be removed
-  eventually because it's better to limit only to the buffer size and report
-  an error when rewritten data overflows)
-
-- a "flow analyzer" is attached to the buffer (or possibly multiple flow
-  analyzers). For the request, the flow analyzer is "http_lb_req". The flow
-  analyzer is a function which gets called when new data is present and
-  blocked. It has a timeout (request timeout). It can also be bypassed on
-  demand.
-
-- when the "http_lb_req" has received the whole request, it creates a client
-  socket with all the parameters needed to try to connect to the server. When
-  the connection establishes, the response buffer is allocated on the fly,
-  put to HOLD mode, and a an "http_lb_resp" flow analyzer is attached to the
-  buffer.
-
-
-For client-side HTTPS :
-
-- the accept() function must completely instantiate a TCP socket + an SSL
-  reader. It is when the SSL session is complete that we call the
-  protocol-specific accept(), and create its buffer.
-
-
-
-
-Conclusions
------------
-
-- we need a generic TCP accept() function with a lot of flags set by the
-  listener, to tell it what info we need to get at the accept() time, and
-  what flags will have to be set on the socket.
-
-- once the TCP accept() function ends, it wakes up the protocol supervisor
-  which is in charge of creating the buffers, etc, switch states, etc...
-
diff --git a/deps/haproxy-1.4.21/doc/design-thoughts/http_load_time.url b/deps/haproxy-1.4.21/doc/design-thoughts/http_load_time.url
deleted file mode 100644
index f178e46..0000000
--- a/deps/haproxy-1.4.21/doc/design-thoughts/http_load_time.url
+++ /dev/null
@@ -1,5 +0,0 @@
-Excellent paper about page load time for keepalive on/off, pipelining,
-multiple host names, etc...
-
-http://www.die.net/musings/page_load_time/
-
diff --git a/deps/haproxy-1.4.21/doc/design-thoughts/sess_par_sec.txt b/deps/haproxy-1.4.21/doc/design-thoughts/sess_par_sec.txt
deleted file mode 100644
index e936374..0000000
--- a/deps/haproxy-1.4.21/doc/design-thoughts/sess_par_sec.txt
+++ /dev/null
@@ -1,13 +0,0 @@
-Graphe des nombres de traitements par seconde unit de temps avec 
-  - un algo linaire et trs peu coteux unitairement (0.01 ut)
-  - un algo en log(2) et 5 fois plus coteux (0.05 ut)
-
-set yrange [0:1]
-plot [0:1000] 1/(1+0.01*x), 1/(1+0.05*log(x+1)/log(2))
-
-Graphe de la latence induite par ces traitements en units de temps :
-
-set yrange [0:1000]
-plot [0:1000] x/(1+0.01*x), x/(1+0.05*log(x+1)/log(2))
-
-
diff --git a/deps/haproxy-1.4.21/doc/gpl.txt b/deps/haproxy-1.4.21/doc/gpl.txt
deleted file mode 100644
index f90922e..0000000
--- a/deps/haproxy-1.4.21/doc/gpl.txt
+++ /dev/null
@@ -1,340 +0,0 @@
-		    GNU GENERAL PUBLIC LICENSE
-		       Version 2, June 1991
-
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.
- 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-License is intended to guarantee your freedom to share and change free
-software--to make sure the software is free for all its users.  This
-General Public License applies to most of the Free Software
-Foundation's software and to any other program whose authors commit to
-using it.  (Some other Free Software Foundation software is covered by
-the GNU Lesser General Public License instead.)  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-this service if you wish), that you receive source code or can get it
-if you want it, that you can change the software or use pieces of it
-in new free programs; and that you know you can do these things.
-
-  To protect your rights, we need to make restrictions that forbid
-anyone to deny you these rights or to ask you to surrender the rights.
-These restrictions translate to certain responsibilities for you if you
-distribute copies of the software, or if you modify it.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must give the recipients all the rights that
-you have.  You must make sure that they, too, receive or can get the
-source code.  And you must show them these terms so they know their
-rights.
-
-  We protect your rights with two steps: (1) copyright the software, and
-(2) offer you this license which gives you legal permission to copy,
-distribute and/or modify the software.
-
-  Also, for each author's protection and ours, we want to make certain
-that everyone understands that there is no warranty for this free
-software.  If the software is modified by someone else and passed on, we
-want its recipients to know that what they have is not the original, so
-that any problems introduced by others will not reflect on the original
-authors' reputations.
-
-  Finally, any free program is threatened constantly by software
-patents.  We wish to avoid the danger that redistributors of a free
-program will individually obtain patent licenses, in effect making the
-program proprietary.  To prevent this, we have made it clear that any
-patent must be licensed for everyone's free use or not licensed at all.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-		    GNU GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License applies to any program or other work which contains
-a notice placed by the copyright holder saying it may be distributed
-under the terms of this General Public License.  The "Program", below,
-refers to any such program or work, and a "work based on the Program"
-means either the Program or any derivative work under copyright law:
-that is to say, a work containing the Program or a portion of it,
-either verbatim or with modifications and/or translated into another
-language.  (Hereinafter, translation is included without limitation in
-the term "modification".)  Each licensee is addressed as "you".
-
-Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running the Program is not restricted, and the output from the Program
-is covered only if its contents constitute a work based on the
-Program (independent of having been made by running the Program).
-Whether that is true depends on what the Program does.
-
-  1. You may copy and distribute verbatim copies of the Program's
-source code as you receive it, in any medium, provided that you
-conspicuously and appropriately publish on each copy an appropriate
-copyright notice and disclaimer of warranty; keep intact all the
-notices that refer to this License and to the absence of any warranty;
-and give any other recipients of the Program a copy of this License
-along with the Program.
-
-You may charge a fee for the physical act of transferring a copy, and
-you may at your option offer warranty protection in exchange for a fee.
-
-  2. You may modify your copy or copies of the Program or any portion
-of it, thus forming a work based on the Program, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) You must cause the modified files to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    b) You must cause any work that you distribute or publish, that in
-    whole or in part contains or is derived from the Program or any
-    part thereof, to be licensed as a whole at no charge to all third
-    parties under the terms of this License.
-
-    c) If the modified program normally reads commands interactively
-    when run, you must cause it, when started running for such
-    interactive use in the most ordinary way, to print or display an
-    announcement including an appropriate copyright notice and a
-    notice that there is no warranty (or else, saying that you provide
-    a warranty) and that users may redistribute the program under
-    these conditions, and telling the user how to view a copy of this
-    License.  (Exception: if the Program itself is interactive but
-    does not normally print such an announcement, your work based on
-    the Program is not required to print an announcement.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Program,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Program, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Program.
-
-In addition, mere aggregation of another work not based on the Program
-with the Program (or with a work based on the Program) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may copy and distribute the Program (or a work based on it,
-under Section 2) in object code or executable form under the terms of
-Sections 1 and 2 above provided that you also do one of the following:
-
-    a) Accompany it with the complete corresponding machine-readable
-    source code, which must be distributed under the terms of Sections
-    1 and 2 above on a medium customarily used for software interchange; or,
-
-    b) Accompany it with a written offer, valid for at least three
-    years, to give any third party, for a charge no more than your
-    cost of physically performing source distribution, a complete
-    machine-readable copy of the corresponding source code, to be
-    distributed under the terms of Sections 1 and 2 above on a medium
-    customarily used for software interchange; or,
-
-    c) Accompany it with the information you received as to the offer
-    to distribute corresponding source code.  (This alternative is
-    allowed only for noncommercial distribution and only if you
-    received the program in object code or executable form with such
-    an offer, in accord with Subsection b above.)
-
-The source code for a work means the preferred form of the work for
-making modifications to it.  For an executable work, complete source
-code means all the source code for all modules it contains, plus any
-associated interface definition files, plus the scripts used to
-control compilation and installation of the executable.  However, as a
-special exception, the source code distributed need not include
-anything that is normally distributed (in either source or binary
-form) with the major components (compiler, kernel, and so on) of the
-operating system on which the executable runs, unless that component
-itself accompanies the executable.
-
-If distribution of executable or object code is made by offering
-access to copy from a designated place, then offering equivalent
-access to copy the source code from the same place counts as
-distribution of the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  4. You may not copy, modify, sublicense, or distribute the Program
-except as expressly provided under this License.  Any attempt
-otherwise to copy, modify, sublicense or distribute the Program is
-void, and will automatically terminate your rights under this License.
-However, parties who have received copies, or rights, from you under
-this License will not have their licenses terminated so long as such
-parties remain in full compliance.
-
-  5. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Program or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Program (or any work based on the
-Program), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Program or works based on it.
-
-  6. Each time you redistribute the Program (or any work based on the
-Program), the recipient automatically receives a license from the
-original licensor to copy, distribute or modify the Program subject to
-these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties to
-this License.
-
-  7. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Program at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Program by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Program.
-
-If any portion of this section is held invalid or unenforceable under
-any particular circumstance, the balance of the section is intended to
-apply and the section as a whole is intended to apply in other
-circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system, which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  8. If the distribution and/or use of the Program is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Program under this License
-may add an explicit geographical distribution limitation excluding
-those countries, so that distribution is permitted only in or among
-countries not thus excluded.  In such case, this License incorporates
-the limitation as if written in the body of this License.
-
-  9. The Free Software Foundation may publish revised and/or new versions
-of the General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Program
-specifies a version number of this License which applies to it and "any
-later version", you have the option of following the terms and conditions
-either of that version or of any later version published by the Free
-Software Foundation.  If the Program does not specify a version number of
-this License, you may choose any version ever published by the Free Software
-Foundation.
-
-  10. If you wish to incorporate parts of the Program into other free
-programs whose distribution conditions are different, write to the author
-to ask for permission.  For software which is copyrighted by the Free
-Software Foundation, write to the Free Software Foundation; we sometimes
-make exceptions for this.  Our decision will be guided by the two goals
-of preserving the free status of all derivatives of our free software and
-of promoting the sharing and reuse of software generally.
-
-			    NO WARRANTY
-
-  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
-FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
-OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
-PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
-OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
-TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
-PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
-REPAIR OR CORRECTION.
-
-  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
-REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
-INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
-OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
-TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
-YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
-PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-	    How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-
-
-Also add information on how to contact you by electronic and paper mail.
-
-If the program is interactive, make it output a short notice like this
-when it starts in an interactive mode:
-
-    Gnomovision version 69, Copyright (C) year name of author
-    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, the commands you use may
-be called something other than `show w' and `show c'; they could even be
-mouse-clicks or menu items--whatever suits your program.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the program, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
-  `Gnomovision' (which makes passes at compilers) written by James Hacker.
-
-  <signature of Ty Coon>, 1 April 1989
-  Ty Coon, President of Vice
-
-This General Public License does not permit incorporating your program into
-proprietary programs.  If your program is a subroutine library, you may
-consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Lesser General
-Public License instead of this License.
diff --git a/deps/haproxy-1.4.21/doc/haproxy-en.txt b/deps/haproxy-1.4.21/doc/haproxy-en.txt
deleted file mode 100644
index 32f52be..0000000
--- a/deps/haproxy-1.4.21/doc/haproxy-en.txt
+++ /dev/null
@@ -1,2828 +0,0 @@
-                           -------------------
-                                 HAProxy
-                            Reference  Manual
-                           -------------------
-                              version 1.3.15
-                              willy tarreau
-                                2008/04/19
-
-
- !!!!  NOTE: THIS DOCUMENT IS OUTDATED  !!!!
-
- Please use "configuration.txt" from the same directory, or download
- an up-to-date version from the following location :
-
-        http://haproxy.1wt.eu/download/1.4/doc/configuration.txt
-
-
-============
-| Abstract |
-============
-
-HAProxy is a TCP/HTTP reverse proxy which is particularly suited for high
-availability environments. Indeed, it can :
-  - route HTTP requests depending on statically assigned cookies ;
-  - spread the load among several servers while assuring server persistence
-    through the use of HTTP cookies ;
-  - switch to backup servers in the event a main one fails ;
-  - accept connections to special ports dedicated to service monitoring ;
-  - stop accepting connections without breaking existing ones ;
-  - add/modify/delete HTTP headers both ways ;
-  - block requests matching a particular pattern ;
-  - hold clients to the right application server depending on application
-    cookies
-  - report detailed status as HTML pages to authenticated users from an URI
-    intercepted from the application.
-
-It needs very little resource. Its event-driven architecture allows it to easily
-handle thousands of simultaneous connections on hundreds of instances without
-risking the system's stability.
-
-====================
-| Start parameters |
-====================
-
-There are only a few command line options :
-
-    -f <configuration file>
-    -n <high limit for the total number of simultaneous connections>
-       = 'maxconn' in 'global' section
-    -N <high limit for the per-listener number of simultaneous connections>
-       = 'maxconn' in 'listen' or 'default' sections
-    -d starts in foregreound with debugging mode enabled
-    -D starts in daemon mode
-    -q disable messages on output
-    -V displays messages on output even when -q or 'quiet' are specified.
-    -c only checks config file and exits with code 0 if no error was found, or
-       exits with code 1 if a syntax error was found.
-    -p <pidfile> asks the process to write down each of its children's
-       pids to this file in daemon mode.
-    -sf specifies a list of pids to send a FINISH signal to after startup.
-    -st specifies a list of pids to send a TERMINATE signal to after startup.
-    -s shows statistics (only if compiled in)
-    -l shows even more statistics (implies '-s')
-    -dk disables use of kqueue()
-    -ds disables use of speculative epoll()
-    -de disables use of epoll()
-    -dp disables use of poll()
-    -db disables background mode (stays in foreground, useful for debugging)
-    -m <megs> enforces a memory usage limit to a maximum of <megs> megabytes.
-
-The maximal number of connections per proxy instance is used as the default
-parameter for each instance for which the 'maxconn' paramter is not set in the
-'listen' section.
-
-The maximal number of total connections limits the number of connections used by
-the whole process if the 'maxconn' parameter is not set in the 'global' section.
-
-The debugging mode has the same effect as the 'debug' option in the 'global'
-section. When the proxy runs in this mode, it dumps every connections,
-disconnections, timestamps, and HTTP headers to stdout. This should NEVER
-be used in an init script since it will prevent the system from starting up.
-
-For debugging, the '-db' option is very useful as it temporarily disables
-daemon mode and multi-process mode. The service can then be stopped by simply
-pressing Ctrl-C, without having to edit the config nor run full debug.
-
-Statistics are only available if compiled in with the 'STATTIME' option. It's
-only used during code optimization phases, and will soon disappear.
-
-The '-st' and '-sf' options are used for hot reconfiguration (see below).
-
-======================
-| Configuration file |
-======================
-
-Structure
-=========
-
-The configuration file parser ignores empty lines, spaces, tabs. Anything
-between a sharp ('#') not following a backslash ('\'), and the end of a line
-constitutes a comment and is ignored too.
-
-The configuration file is segmented in sections. A section begins whenever
-one of these 3 keywords are encountered :
-
-  - 'global'
-  - 'listen'
-  - 'defaults'
-
-Every parameter refer to the section beginning at the last one of these 3
-keywords.
-
-
-1) Global parameters
-====================
-
-Global parameters affect the whole process behaviour. They are all set in the
-'global' section. There may be several 'global' sections if needed, but their
-parameters will only be merged. Allowed parameters in 'global' section include
-the following ones :
-
-  - log <address> <facility> [max_level]
-  - maxconn <number>
-  - uid <user id>
-  - gid <group id>
-  - user <user name>
-  - group <group name>
-  - chroot <directory>
-  - nbproc <number>
-  - daemon
-  - debug
-  - nokqueue
-  - nosepoll
-  - noepoll
-  - nopoll
-  - quiet
-  - pidfile <file>
-  - ulimit-n <number>
-  - stats
-  - tune.maxpollevents <number>
-
-
-1.1) Event logging
-------------------
-Most events are logged : start, stop, servers going up and down, connections and
-errors. Each event generates a syslog message which can be sent to up to 2
-servers. The syntax is :
-
-    log <ip_address> <facility> [max_level]
-
-Connections are logged at level "info". Services initialization and servers
-going up are logged at level "notice", termination signals are logged at
-"warning", and definitive service termination, as well as loss of servers are
-logged at level "alert". The optional parameter <max_level> specifies above
-what level messages should be sent. Level can take one of these 8 values :
-
-    emerg, alert, crit, err, warning, notice, info, debug
-
-For backwards compatibility with versions 1.1.16 and earlier, the default level
-value is "debug" if not specified.
-
-Permitted facilities are :
-    kern, user, mail, daemon, auth, syslog, lpr, news,
-    uucp, cron, auth2, ftp, ntp, audit, alert, cron2,
-    local0, local1, local2, local3, local4, local5, local6, local7
-
-According to RFC3164, messages are truncated to 1024 bytes before being emitted.
-
-Example :
----------
-    global
-        log 192.168.2.200 local3
-        log 127.0.0.1     local4 notice
-
-
-1.2) limiting the number of connections
----------------------------------------
-It is possible and recommended to limit the global number of per-process
-connections using the 'maxconn' global keyword. Since one connection includes
-both a client and a server, it means that the max number of TCP sessions will
-be about the double of this number. It's important to understand this when
-trying to find best values for 'ulimit -n' before starting the proxy. To
-anticipate the number of sockets needed, all these parameters must be counted :
-
-  - 1 socket per incoming connection
-  - 1 socket per outgoing connection
-  - 1 socket per address/port/proxy tuple.
-  - 1 socket per server being health-checked
-  - 1 socket for all logs
-
-In simple configurations where each proxy only listens one one address/port,
-set the limit of file descriptors (ulimit -n) to
-(2 * maxconn + nbproxies + nbservers + 1). Starting with versions 1.1.32/1.2.6,
-it is now possible to set the limit in the configuration using the 'ulimit-n'
-global keyword, provided the proxy is started as root. This puts an end to the
-recurrent problem of ensuring that the system limits are adapted to the proxy
-values. Note that these limits are per-process.
-
-Example :
----------
-    global
-        maxconn 32000
-        ulimit-n 65536
-
-
-1.3) Drop of priviledges
-------------------------
-In order to reduce the risk and consequences of attacks, in the event where a
-yet non-identified vulnerability would be successfully exploited, it's possible
-to lower the process priviledges and even isolate it in a riskless directory.
-
-In the 'global' section, the 'uid' parameter sets a numerical user identifier
-which the process will switch to after binding its listening sockets. The value
-'0', which normally represents the super-user, here indicates that the UID must
-not change during startup. It's the default behaviour. The 'gid' parameter does
-the same for the group identifier. If setting an uid is not possible because of
-deployment constraints, it is possible to set a user name with the 'user'
-keyword followed by a valid user name. The same is true for the gid. It is
-possible to specify a group name after the 'group' keyword.
-
-It is particularly advised against use of generic accounts such as 'nobody'
-because it has the same consequences as using 'root' if other services use
-them.
-
-The 'chroot' parameter makes the process isolate itself in an empty directory
-just before switching its UID. This type of isolation (chroot) can sometimes
-be worked around on certain OS (Linux, Solaris), provided that the attacker
-has gained 'root' priviledges and has the ability to use or create a directory.
-For this reason, it's capital to use a dedicated directory and not to share one
-between several services of different nature. To make isolation more resistant,
-it's recommended to use an empty directory without any right, and to change the
-UID of the process so that it cannot do anything there.
-
-Note: in the event where such a vulnerability would be exploited, it's most
-likely that first attempts would kill the process due to 'Segmentation Fault',
-'Bus Error' or 'Illegal Instruction' signals. Eventhough it's true that
-isolating the server reduces the risks of intrusion, it's sometimes useful to
-find why a process dies, via the analysis of a 'core' file, although very rare
-(the last bug of this sort was fixed in 1.1.9). For security reasons, most
-systems disable the generation of core file when a process changes its UID. So
-the two workarounds are either to start the process from a restricted user
-account, which will not be able to chroot itself, or start it as root and not
-change the UID. In both cases the core will be either in the start or the chroot
-directories. Do not forget to allow core dumps prior to start the process :
-
-# ulimit -c unlimited
-
-Example :
----------
-
-    # with uid/gid
-    global
-        uid     30000
-        gid     30000
-        chroot  /var/chroot/haproxy
-
-    # with user/group
-    global
-        user    haproxy
-        group   public
-        chroot  /var/chroot/haproxy
-
-
-1.4) Startup modes
-------------------
-The service can start in several different modes :
-  - foreground / background
-  - quiet / normal / debug
-
-The default mode is normal, foreground, which means that the program doesn't
-return once started. NEVER EVER use this mode in a system startup script, or
-the system won't boot. It needs to be started in background, so that it
-returns immediately after forking. That's accomplished by the 'daemon' option
-in the 'global' section, which is the equivalent of the '-D' command line
-argument.
-
-The '-db' command line argument overrides the 'daemon' and 'nbproc' global
-options to make the process run in normal, foreground mode.
-
-Moreover, certain alert messages are still sent to the standard output even
-in 'daemon' mode. To make them disappear, simply add the 'quiet' option in the
-'global' section. This option has no command-line equivalent.
-
-Last, the 'debug' mode, enabled with the 'debug' option in the 'global' section,
-and which is equivalent of the '-d' option, allows deep TCP/HTTP analysis, with
-timestamped display of each connection, disconnection, and HTTP headers for both
-ways. This mode is incompatible with 'daemon' and 'quiet' modes for obvious
-reasons.
-
-
-1.5) Increasing the overall processing power
---------------------------------------------
-On multi-processor systems, it may seem to be a shame to use only one processor,
-eventhough the load needed to saturate a recent processor is far above common
-usage. Anyway, for very specific needs, the proxy can start several processes
-between which the operating system will spread the incoming connections. The
-number of processes is controlled by the 'nbproc' parameter in the 'global'
-section. It defaults to 1, and obviously works only in 'daemon' mode. One
-typical usage of this parameter has been to workaround the default per-process
-file-descriptor limit that Solaris imposes to user processes.
-
-Example :
----------
-
-    global
-        daemon
-        quiet
-        nbproc  2
-
-
-1.6) Helping process management
--------------------------------
-Haproxy now supports the notion of pidfile. If the '-p' command line argument,
-or the 'pidfile' global option is followed with a file name, this file will be
-removed, then filled with all children's pids, one per line (only in daemon
-mode). This file is NOT within the chroot, which allows to work with a readonly
- chroot. It will be owned by the user starting the process, and will have
-permissions 0644.
-
-Example :
----------
-
-    global
-        daemon
-        quiet
-        nbproc  2
-        pidfile /var/run/haproxy-private.pid
-
-    # to stop only those processes among others :
-    # kill $(</var/run/haproxy-private.pid)
-
-    # to reload a new configuration with minimal service impact and without
-    # breaking existing sessions :
-    # haproxy -f haproxy.cfg -p /var/run/haproxy-private.pid -sf $(</var/run/haproxy-private.pid)
-
-1.7) Polling mechanisms
------------------------
-Starting from version 1.2.5, haproxy supports the poll() and epoll() polling
-mechanisms. On systems where select() is limited by FD_SETSIZE (like Solaris),
-poll() can be an interesting alternative. Performance tests show that Solaris'
-poll() performance does not decay as fast as the numbers of sockets increase,
-making it a safe solution for high loads. However, Solaris already uses poll()
-to emulate select(), so as long as the number of sockets has no reason to go
-higher than FD_SETSIZE, poll() should not provide any better performance. On
-Linux systems with the epoll() patch (or any 2.6 version), haproxy will use
-epoll() which is extremely fast and non dependant on the number of sockets.
-Tests have shown constant performance from 1 to 20000 simultaneous sessions.
-Version 1.3.9 introduced kqueue() for FreeBSD/OpenBSD, and speculative epoll()
-which consists in trying to perform I/O before queuing the events via syscalls.
-
-In order to optimize latency, it is now possible to limit the number of events
-returned by a single call to poll. The limit is fixed to 200 by default. If a
-smaller latency is seeked, it may be useful to reduce this value by using the
-'tune.maxpollevents' parameter in the 'global' section. Increasing it will
-slightly save CPU cycles in presence of large number of connections.
-
-Haproxy will use kqueue() or speculative epoll() when available, then epoll(),
-and will fall back to poll(), then to select(). However, if for any reason you
-need to disable epoll() or poll() (eg. because of a bug or just to compare
-performance), new global options have been created for this matter : 'nosepoll',
-'nokqueue', 'noepoll' and 'nopoll'.
-
-Example :
----------
-
-    global
-        # use only select()
-        noepoll
-        nopoll
-        tune.maxpollevents 100
-
-Note :
-------
-For the sake of configuration file portability, these options are accepted but
-ignored if the poll() or epoll() mechanisms have not been enabled at compile
-time.
-
-To make debugging easier, the '-de' runtime argument disables epoll support,
-the '-dp' argument disables poll support, '-dk' disables kqueue and '-ds'
-disables speculative epoll(). They are respectively equivalent to 'noepoll',
-'nopoll', 'nokqueue' and 'nosepoll'.
-
-
-2) Declaration of a listening service
-=====================================
-
-Service sections start with the 'listen' keyword :
-
-    listen <instance_name> [ <IP_address>:<port_range>[,...] ]
-
-- <instance_name> is the name of the instance. This name will be reported in
-  logs, so it is good to have it reflect the proxied service. No unicity test
-  is done on this name, and it's not mandatory for it to be unique, but highly
-  recommended.
-
-- <IP_address> is the IP address the proxy binds to. Empty address, '*' and
-  '0.0.0.0' all mean that the proxy listens to all valid addresses on the
-  system.
-
-- <port_range> is either a unique port, or a port range for which the proxy will
-  accept connections for the IP address specified above. This range can be :
-    - a numerical port (ex: '80')
-    - a dash-delimited ports range explicitly stating the lower and upper bounds
-      (ex: '2000-2100') which are included in the range.
-
-  Particular care must be taken against port ranges, because every <addr:port>
-  couple consumes one socket (=a file descriptor), so it's easy to eat lots of
-  descriptors with a simple range. The <addr:port> couple must be used only once
-  among all instances running on a same system. Please note that attaching to
-  ports lower than 1024 need particular priviledges to start the program, which
-  are independant of the 'uid' parameter.
-
-- the <IP_address>:<port_range> couple may be repeated indefinitely to require
-  the proxy to listen to other addresses and/or ports. To achieve this, simply
-  separate them with a coma.
-
-Examples :
----------
-    listen http_proxy :80
-    listen x11_proxy 127.0.0.1:6000-6009
-    listen smtp_proxy 127.0.0.1:25,127.0.0.1:587
-    listen ldap_proxy :389,:663
-
-In the event that all addresses do not fit line width, it's preferable to
-detach secondary addresses on other lines with the 'bind' keyword. If this
-keyword is used, it's not even necessary to specify the first address on the
-'listen' line, which sometimes makes multiple configuration handling easier :
-
-    bind [ <IP_address>:<port_range>[,...] ]
-
-Examples :
-----------
-    listen http_proxy
-        bind :80,:443
-        bind 10.0.0.1:10080,10.0.0.1:10443
-
-
-2.1) Inhibiting a service
--------------------------
-A service may be disabled for maintenance reasons, without needing to comment
-out the whole section, simply by specifying the 'disabled' keyword in the
-section to be disabled :
-
-    listen smtp_proxy 0.0.0.0:25
-        disabled
-
-Note: the 'enabled' keyword allows to enable a service which has been disabled
-      previously by a default configuration.
-
-
-2.2) Modes of operation
------------------------
-A service can work in 3 different distinct modes :
-  - TCP
-  - HTTP
-  - health
-
-TCP mode
---------
-In this mode, the service relays TCP connections as soon as they're established,
-towards one or several servers. No processing is done on the stream. It's only
-an association of source(addr:port) -> destination(addr:port). To use this mode,
-you must specify 'mode tcp' in the 'listen' section. This is the default mode.
-
-Example :
----------
-    listen smtp_proxy 0.0.0.0:25
-        mode tcp
-
-HTTP mode
----------
-In this mode, the service relays TCP connections towards one or several servers,
-when it has enough informations to decide, which normally means that all HTTP
-headers have been read. Some of them may be scanned for a cookie or a pattern
-matching a regex. To use this mode, specify 'mode http' in the 'listen' section.
-
-Example :
----------
-    listen http_proxy 0.0.0.0:80
-        mode http
-
-Health-checking mode
---------------------
-This mode provides a way for external components to check the proxy's health.
-It is meant to be used with intelligent load-balancers which can use send/expect
-scripts to check for all of their servers' availability. This one simply accepts
-the connection, returns the word 'OK' and closes it. If the 'option httpchk' is
-set, then the reply will be 'HTTP/1.0 200 OK' with no data, so that it can be
-tested from a tool which supports HTTP health-checks. To enable it, simply
-specify 'health' as the working mode :
-
-Example :
----------
-    # simple response : 'OK'
-    listen health_check 0.0.0.0:60000
-        mode health
-
-    # HTTP response : 'HTTP/1.0 200 OK'
-    listen http_health_check 0.0.0.0:60001
-        mode health
-        option httpchk
-
-2.2.1 Monitoring
-----------------
-Versions 1.1.32 and 1.2.6 provide a new solution to check the proxy's
-availability without perturbating the service. The 'monitor-net' keyword was
-created to specify a network of equipments which CANNOT use the service for
-anything but health-checks. This is particularly suited to TCP proxies, because
-it prevents the proxy from relaying the monitor's connection to the remote
-server.
-
-When used with TCP, the connection is accepted then closed and nothing is
-logged. This is enough for a front-end load-balancer to detect the service as
-available.
-
-When used with HTTP, the connection is accepted, nothing is logged, the
-following response is sent, then the session is closed : "HTTP/1.0 200 OK".
-This is normally enough for any front-end HTTP load-balancer to detect the
-service as available too, both with TCP and HTTP checks.
-
-Proxies using the "monitor-net" keyword can remove the "option dontlognull", as
-it will make them log empty connections from hosts outside the monitoring
-network.
-
-Example :
----------
-
-    listen tse-proxy
-       bind :3389,:1494,:5900  # TSE, ICA and VNC at once.
-       mode tcp
-       balance roundrobin
-       server tse-farm 192.168.1.10
-       monitor-net 192.168.1.252/31   # L4 load-balancers on .252 and .253
-
-
-When the system executing the checks is located behind a proxy, the monitor-net
-keyword cannot be used because haproxy will always see the proxy's address. To
-overcome this limitation, version 1.2.15 brought the 'monitor-uri' keyword. It
-defines an URI which will not be forwarded nor logged, but for which haproxy
-will immediately send an "HTTP/1.0 200 OK" response. This makes it possible to
-check the validity of the reverse-proxy->haproxy chain with one request. It can
-be used in HTTPS checks in front of an stunnel -> haproxy combination for
-instance. Obviously, this keyword is only valid in HTTP mode, otherwise there
-is no notion of URI. Note that the method and HTTP versions are simply ignored.
-
-Example :
----------
-
-    listen stunnel_backend :8080
-       mode http
-       balance roundrobin
-       server web1 192.168.1.10:80 check
-       server web2 192.168.1.11:80 check
-       monitor-uri /haproxy_test
-
-
-2.3) Limiting the number of simultaneous connections
-----------------------------------------------------
-The 'maxconn' parameter allows a proxy to refuse connections above a certain
-amount of simultaneous ones. When the limit is reached, it simply stops
-listening, but the system may still be accepting them because of the back log
-queue. These connections will be processed later when other ones have freed
-some slots. This provides a serialization effect which helps very fragile
-servers resist to high loads. See further for system limitations.
-
-Example :
----------
-    listen tiny_server 0.0.0.0:80
-        maxconn 10
-
-
-2.4) Soft stop
---------------
-It is possible to stop services without breaking existing connections by the
-sending of the SIGUSR1 signal to the process. All services are then put into
-soft-stop state, which means that they will refuse to accept new connections,
-except for those which have a non-zero value in the 'grace' parameter, in which
-case they will still accept connections for the specified amount of time, in
-milliseconds. This makes it possible to tell a load-balancer that the service
-is failing, while still doing the job during the time it needs to detect it.
-
-Note: active connections are never killed. In the worst case, the user will have
-to wait for all of them to close or to time-out, or simply kill the process
-normally (SIGTERM). The default 'grace' value is '0'.
-
-Example :
----------
-    # enter soft stop after 'killall -USR1 haproxy'
-    # the service will still run 10 seconds after the signal
-    listen http_proxy 0.0.0.0:80
-        mode http
-        grace 10000
-
-    # this port is dedicated to a load-balancer, and must fail immediately
-    listen health_check 0.0.0.0:60000
-        mode health
-        grace 0
-
-
-As of version 1.2.8, a new soft-reconfiguration mechanism has been introduced.
-It is now possible to "pause" all the proxies by sending a SIGTTOU signal to
-the processes. This will disable the listening socket without breaking existing
-connections. After that, sending a SIGTTIN signal to those processes enables
-the listening sockets again. This is very useful to try to load a new
-configuration or even a new version of haproxy without breaking existing
-connections. If the load succeeds, then simply send a SIGUSR1 which will make
-the previous proxies exit immediately once their sessions are closed ; and if
-the load fails, then simply send a SIGTTIN to restore the service immediately.
-Please note that the 'grace' parameter is ignored for SIGTTOU, as well as for
-SIGUSR1 when the process was in the pause mode. Please also note that it would
-be useful to save the pidfile before starting a new instance.
-
-This mechanism fully exploited since 1.2.11 with the '-st' and '-sf' options
-(see below).
-
-2.4.1) Hot reconfiguration
---------------------------
-The '-st' and '-sf' command line options are used to inform previously running
-processes that a configuration is being reloaded. They will receive the SIGTTOU
-signal to ask them to temporarily stop listening to the ports so that the new
-process can grab them. If anything wrong happens, the new process will send
-them a SIGTTIN to tell them to re-listen to the ports and continue their normal
-work. Otherwise, it will either ask them to finish (-sf) their work then softly
-exit, or immediately terminate (-st), breaking existing sessions. A typical use
-of this allows a configuration reload without service interruption :
-
- # haproxy -p /var/run/haproxy.pid -sf $(cat /var/run/haproxy.pid)
-
-
-2.5) Connections expiration time
---------------------------------
-It is possible (and recommended) to configure several time-outs on TCP
-connections. Three independant timers are adjustable with values specified
-in milliseconds. A session will be terminated if either one of these timers
-expire.
-
-  - the time we accept to wait for data from the client, or for the client to
-    accept data : 'clitimeout' :
-
-        # client time-out set to 2mn30.
-        clitimeout  150000
-
-  - the time we accept to wait for data from the server, or for the server to
-    accept data : 'srvtimeout' :
-
-        # server time-out set to 30s.
-        srvtimeout  30000
-
-  - the time we accept to wait for a connection to establish on a server :
-    'contimeout' :
-
-        # we give up if the connection does not complete within 4 seconds
-        contimeout  4000
-
-Notes :
--------
-  - 'contimeout' and 'srvtimeout' have no sense on 'health' mode servers ;
-  - under high loads, or with a saturated or defective network, it's possible
-    that some packets get lost. Since the first TCP retransmit only happens
-    after 3 seconds, a time-out equal to, or lower than 3 seconds cannot
-    compensate for a packet loss. A 4 seconds time-out seems a reasonable
-    minimum which will considerably reduce connection failures.
-  - starting with version 1.3.14, it is possible to specify timeouts in
-    arbitrary time units among { us, ms, s, m, h, d }. For this, the integer
-    value just has to be suffixed with the unit.
-
-2.6) Attempts to reconnect
---------------------------
-After a connection failure to a server, it is possible to retry, potentially
-on another server. This is useful if health-checks are too rare and you don't
-want the clients to see the failures. The number of attempts to reconnect is
-set by the 'retries' paramter.
-
-Example :
----------
-        # we can retry 3 times max after a failure
-        retries 3
-
-Please note that the reconnection attempt may lead to getting the connection
-sent to a new server if the original one died between connection attempts.
-
-
-2.7) Address of the dispatch server (deprecated)
-------------------------------------------------
-The server which will be sent all new connections is defined by the 'dispatch'
-parameter, in the form <address>:<port>. It generally is dedicated to unknown
-connections and will assign them a cookie, in case of HTTP persistence mode,
-or simply is a single server in case of generic TCP proxy. This old mode is only
-provided for backwards compatibility, but doesn't allow to check remote servers
-state, and has a rather limited usage. All new setups should switch to 'balance'
-mode. The principle of the dispatcher is to be able to perform the load
-balancing itself, but work only on new clients so that the server doesn't need
-to be a big machine.
-
-Example :
----------
-           # all new connections go there
-        dispatch 192.168.1.2:80
-
-Note :
-------
-This parameter has no sense for 'health' servers, and is incompatible with
-'balance' mode.
-
-
-2.8) Outgoing source address
-----------------------------
-It is often necessary to bind to a particular address when connecting to some
-remote hosts. This is done via the 'source' parameter which is a per-proxy
-parameter. A newer version may allow to fix different sources to reach different
-servers. The syntax is 'source <address>[:<port>]', where <address> is a valid
-local address (or '0.0.0.0' or '*' or empty to let the system choose), and
-<port> is an optional parameter allowing the user to force the source port for
-very specific needs. If the port is not specified or is '0', the system will
-choose a free port. Note that as of version 1.1.18, the servers health checks
-are also performed from the same source.
-
-Examples :
-----------
-    listen http_proxy *:80
-           # all connections take 192.168.1.200 as source address
-        source 192.168.1.200:0
-
-    listen rlogin_proxy *:513
-           # use address 192.168.1.200 and the reserved port 900 (needs to be root)
-        source 192.168.1.200:900
-
-
-2.9) Setting the cookie name
-----------------------------
-In HTTP mode, it is possible to look for a particular cookie which will contain
-a server identifier which should handle the connection. The cookie name is set
-via the 'cookie' parameter.
-
-Example :
----------
-    listen http_proxy :80
-        mode http
-        cookie SERVERID
-
-It is possible to change the cookie behaviour to get a smarter persistence,
-depending on applications. It is notably possible to delete or modify a cookie
-emitted by a server, insert a cookie identifying the server in an HTTP response
-and even add a header to tell upstream caches not to cache this response.
-
-Examples :
-----------
-
-To remove the cookie for direct accesses (ie when the server matches the one
-which was specified in the client cookie) :
-
-        cookie SERVERID indirect
-
-To replace the cookie value with the one assigned to the server if any (no
-cookie will be created if the server does not provide one, nor if the
-configuration does not provide one). This lets the application put the cookie
-exactly on certain pages (eg: successful authentication) :
-
-        cookie SERVERID rewrite
-
-To create a new cookie and assign the server identifier to it (in this case, all
-servers should be associated with a valid cookie, since no cookie will simply
-delete the cookie from the client's browser) :
-
-        cookie SERVERID insert
-
-To reuse an existing application cookie and prefix it with the server's
-identifier, and remove it in the request, use the 'prefix' option. This allows
-to insert a haproxy in front of an application without risking to break clients
-which does not support more than one cookie :
-
-        cookie JSESSIONID prefix
-
-To insert a cookie and ensure that no upstream cache will store it, add the
-'nocache' option :
-
-        cookie SERVERID insert nocache
-
-To insert a cookie only after a POST request, add 'postonly' after 'insert'.
-This has the advantage that there's no risk of caching, and that all pages
-seen before the POST one can still be cached :
-
-        cookie SERVERID insert postonly
-
-Notes :
------------
-- it is possible to combine 'insert' with 'indirect' or 'rewrite' to adapt to
-  applications which already generate the cookie with an invalid content.
-
-- in the case where 'insert' and 'indirect' are both specified, the cookie is
-  never transmitted to the server, since it wouldn't understand it. This is the
-  most application-transparent mode.
-
-- it is particularly recommended to use 'nocache' in 'insert' mode if any
-  upstream HTTP/1.0 cache is susceptible to cache the result, because this may
-  lead to many clients going to the same server, or even worse, some clients
-  having their server changed while retrieving a page from the cache.
-
-- the 'prefix' mode normally does not need 'indirect', 'nocache', nor
-  'postonly', because just as in the 'rewrite' mode, it relies on the
-  application to know when a cookie can be emitted. However, since it has to
-  fix the cookie name in every subsequent requests, you must ensure that the
-  proxy will be used without any "HTTP keep-alive". Use option "httpclose" if
-  unsure.
-
-- when the application is well known and controlled, the best method is to
-  only add the persistence cookie on a POST form because it's up to the
-  application to select which page it wants the upstream servers to cache. In
-  this case, you would use 'insert postonly indirect'.
-
-
-2.10) Associating a cookie value with a server
-----------------------------------------------
-In HTTP mode, it's possible to associate a cookie value to each server. This
-was initially used in combination with 'dispatch' mode to handle direct accesses
-but it is now the standard way of doing the load balancing. The syntax is :
-
-    server <identifier> <address>:<port> cookie <value>
-
-- <identifier> is any name which can be used to identify the server in the logs.
-- <address>:<port> specifies where the server is bound.
-- <value> is the value to put in or to read from the cookie.
-
-Example : the 'SERVERID' cookie can be either 'server01' or 'server02'
----------
-    listen http_proxy :80
-        mode http
-        cookie SERVERID
-        dispatch 192.168.1.100:80
-        server web1 192.168.1.1:80 cookie server01
-        server web2 192.168.1.2:80 cookie server02
-
-Warning : the syntax has changed since version 1.0 !
----------
-
-
-2.11) Application Cookies
--------------------------
-Since 1.2.4 it is possible to catch the cookie that comes from an
-application server in order to apply "application session stickyness".
-The server's response is searched for 'appsession' cookie, the first
-'len' bytes are used for matching and it is stored for a period of
-'timeout'.
-The syntax is:
-
-    appsession <session_cookie> len <match_length> timeout <holdtime>
-
-- <session_cookie> is the cookie, the server uses for it's session-handling
-- <match_length> how many bytes/characters should be used for matching equal
-                sessions 
-- <holdtime> after this inactivaty time, in ms, the cookie will be deleted 
-             from the sessionstore
-- starting with version 1.3.14, it is possible to specify timeouts in
-  arbitrary time units among { us, ms, s, m, h, d }. For this, the integer
-  value just has to be prefixed with the unit.
-
-The appsession is only per 'listen' section possible.
-
-Example :
----------
-    listen http_lb1 192.168.3.4:80
-       mode    http
-       capture request  header Cookie len 200
-       # Havind a ServerID cookie on the client allows him to reach
-       # the right server even after expiration of the appsession.
-       cookie ServerID insert nocache indirect
-       # Will memorize 52 bytes of the cookie 'JSESSIONID' and keep them
-       # for 3 hours. It will match it in the cookie and the URL field.
-       appsession JSESSIONID len 52 timeout 3h
-       server first1 10.3.9.2:10805 check inter 3000 cookie first
-       server secon1 10.3.9.3:10805 check inter 3000 cookie secon
-       server first1 10.3.9.4:10805 check inter 3000 cookie first
-       server secon2 10.3.9.5:10805 check inter 3000 cookie secon
-       option httpchk GET /test.jsp
-
-
-3) Autonomous load balancer
-===========================
-
-The proxy can perform the load-balancing itself, both in TCP and in HTTP modes.
-This is the most interesting mode which obsoletes the old 'dispatch' mode
-described above. It has advantages such as server health monitoring, multiple
-port binding and port mapping. To use this mode, the 'balance' keyword is used,
-followed by the selected algorithm. Up to version 1.2.11, only 'roundrobin' was
-available, which is also the default value if unspecified. Starting with
-version 1.2.12, a new 'source' keyword appeared. A new 'uri' keyword was added
-in version 1.3.10. In this mode, there will be no dispatch address, but the
-proxy needs at least one server.
-
-Example : same as the last one, with internal load balancer
----------
-
-    listen http_proxy :80
-        mode http
-        cookie SERVERID
-        balance roundrobin
-        server web1 192.168.1.1:80 cookie server01
-        server web2 192.168.1.2:80 cookie server02
-
-
-Since version 1.1.22, it is possible to automatically determine on which port
-the server will get the connection, depending on the port the client connected
-to. Indeed, there now are 4 possible combinations for the server's <port> field:
-
-  - unspecified or '0' :
-    the connection will be sent to the same port as the one on which the proxy
-    received the client connection itself.
-
-  - numerical value (the only one supported in versions earlier than 1.1.22) :
-    the connection will always be sent to the specified port.
-
-  - '+' followed by a numerical value :
-    the connection will be sent to the same port as the one on which the proxy
-    received the connection, plus this value.
-
-  - '-' followed by a numerical value :
-    the connection will be sent to the same port as the one on which the proxy
-    received the connection, minus this value.
-    
-Examples :
-----------
-
-# same as previous example
-
-    listen http_proxy :80
-        mode http
-        cookie SERVERID
-        balance roundrobin
-        server web1 192.168.1.1 cookie server01
-        server web2 192.168.1.2 cookie server02
-
-# simultaneous relaying of ports 80, 81 and 8080-8089
-
-    listen http_proxy :80,:81,:8080-8089
-        mode http
-        cookie SERVERID
-        balance roundrobin
-        server web1 192.168.1.1 cookie server01
-        server web2 192.168.1.2 cookie server02
-
-# relaying of TCP ports 25, 389 and 663 to ports 1025, 1389 and 1663
-
-    listen http_proxy :25,:389,:663
-        mode tcp
-        balance roundrobin
-        server srv1 192.168.1.1:+1000
-        server srv2 192.168.1.2:+1000
-
-As previously stated, version 1.2.12 brought the 'source' keyword. When this
-keyword is used, the client's IP address is hashed and evenly distributed among
-the available servers so that a same source IP will always go to the same
-server as long as there are no change in the number of available servers. This
-can be used for instance to bind HTTP and HTTPS to the same server. It can also
-be used to improve stickyness when one part of the client population does not
-accept cookies. In this case, only those ones will be perturbated should a
-server fail.
-
-NOTE: It is important to consider the fact that many clients surf the net
-      through proxy farms which assign different IP addresses for each
-      request. Others use dialup connections with a different IP at each
-      connection. Thus, the 'source' parameter should be used with extreme
-      care.
-
-Examples :
-----------
-
-# make a same IP go to the same server whatever the service
-
-    listen http_proxy
-        bind :80,:443
-        mode http
-        balance source
-        server web1 192.168.1.1
-        server web2 192.168.1.2
-
-# try to improve client-server binding by using both source IP and cookie :
-
-    listen http_proxy :80
-        mode http
-        cookie SERVERID
-        balance source
-        server web1 192.168.1.1 cookie server01
-        server web2 192.168.1.2 cookie server02
-
-As indicated above, the 'uri' keyword was introduced in version 1.3.10. It is
-useful when load-balancing between reverse proxy-caches, because it will hash
-the URI and use the hash result to select a server, thus optimizing the hit
-rate on the caches, because the same URI will always reach the same cache. This
-keyword is only allowed in HTTP mode.
-
-Example :
----------
-
-# Always send a given URI to the same server
-
-    listen http_proxy
-        bind :3128
-        mode http
-        balance uri
-        server squid1 192.168.1.1
-        server squid2 192.168.1.2
-
-Version 1.3.14 introduced the "balance url_param" method. It consists in
-relying on a parameter passed in the URL to perform a hash. This is mostly
-useful for applications which do not have strict persistence requirements,
-but for which it still provides a performance boost due to local caching.
-Some of these applications may not be able to use a cookie for whatever reason,
-but may be able to look for a parameter passed in the URL. If the parameter is
-missing from the URL, then the 'round robin' method applies.
-
-A modifier may be added to specify that parameters in POST requests may be
-found in the messsage body if the URL lacks a '?' separator character.
-A wait limit may also be applied, if no limit is requested then
-the default value is 48 octets, the minimum is 3.  HAProxy may wait, until 48
-octets are received. If Content-Length is missing, or zero it need not
-wait for more data then the client promissed to send. When Content-Length is
-present, and more than <max_wait>; then waiting is limited and it is assumed this
-will be enough data to search for the presence of a parameter.  If
-Transfer-Encoding: chunked is used (unlikely), then the length of the first chunk
-is the maximum number of bytes to wait for.
-
-balance url_param <param> [check_post [<max_wait>]]
-
-Caveats for using the check_post extension:
-
-  - all POST requests are eligable for consideration, because there is
-    no way to determine if the parameters will be found in the body or
-    entity which may contain binary data. Therefore another method may be
-    required to restrict consideration of POST requests that have no URL
-    parameters in the body. (see acl reqideny http_end)
-
-Limitations on inspecting the entity body of a POST:
-
-  - Content-Encoding is not supported, the parameter search will probably fail;
-    and load balancing will fall back to Round Robin.
-
-  - Expect: 100-continue is not supported, load balancing will fall back to
-    Round Robin.
-
-  - Transfer-Encoding(RFC2616 3.6.1) is only supported in the first chunk. If
-    the entire parameter value is not present in the first chunk, the selection
-    of server is undefined (actually, defined by how little actually appeared in
-    the first chunk).
-
-  - This feature does not support generation of a 100, 411 or 501 response.
-
-  - In some cases, requesting check_post MAY attempt to scan the entire contents
-    of a message body.  Scaning normally terminates when linear white space or
-    control characters are found, indicating the end of what might be a URL parameter
-    list.  This is probably not a concern with SGML type message bodies.
-
-
-Example :
----------
-
-# Hash the "basket_id" argument from the URL to determine the server
-
-    listen http_proxy
-        bind :3128
-        mode http
-        balance url_param basket_id
-        server ebiz1 192.168.1.1
-        server ebiz2 192.168.1.2
-
-
-3.1) Server monitoring
-----------------------
-It is possible to check the servers status by trying to establish TCP
-connections or even sending HTTP requests to them. A server which fails to
-reply to health checks as expected will not be used by the load balancing
-algorithms. To enable monitoring, add the 'check' keyword on a server line.
-It is possible to specify the interval between tests (in milliseconds) with
-the 'inter' parameter, the number of failures supported before declaring that
-the server has fallen down with the 'fall' parameter, and the number of valid
-checks needed for the server to fully get up with the 'rise' parameter. Since
-version 1.1.22, it is also possible to send checks to a different port
-(mandatory when none is specified) with the 'port' parameter. The default
-values are the following ones :
-
-  - inter : 2000
-  - rise  : 2
-  - fall  : 3
-  - port  : default server port
-  - addr  : specific address for the test (default = address server)
-  
-The default mode consists in establishing TCP connections only. But in certain
-types of application failures, it is often that the server continues to accept
-connections because the system does it itself while the application is running
-an endless loop, or is completely stuck. So in version 1.1.16 were introduced
-HTTP health checks which only performed simple lightweight requests and analysed
-the response. Now, as of version 1.1.23, it is possible to change the HTTP
-method, the URI, and the HTTP version string (which even allows to send headers
-with a dirty trick). To enable HTTP health-checks, use 'option httpchk'.
-
-By default, requests use the 'OPTIONS' method because it's very light and easy
-to filter from logs, and does it on '/'. Only HTTP responses 2xx and 3xx are
-considered valid ones, and only if they come before the time to send a new
-request is reached ('inter' parameter). If some servers block this type of
-request, 3 other forms help to forge a request :
-
-  - option httpchk               -> OPTIONS / HTTP/1.0
-  - option httpchk URI           -> OPTIONS <URI> HTTP/1.0
-  - option httpchk METH URI      -> <METH> <URI> HTTP/1.0
-  - option httpchk METH URI VER  -> <METH> <URI> <VER>
-
-Some people are using HAProxy to relay various TCP-based protocols such as
-HTTPS, SMTP or LDAP, with the most common one being HTTPS. One problem commonly
-encountered in data centers is the need to forward the traffic to far remote
-servers while providing server fail-over. Often, TCP-only checks are not enough
-because intermediate firewalls, load balancers or proxies might acknowledge the
-connection before it reaches the real server. The only solution to this problem
-is to send application-level health checks. Since the demand for HTTPS checks
-is high, it has been implemented in 1.2.15 based on SSLv3 Client Hello packets.
-To enable it, use 'option ssl-hello-chk'. It will send SSL CLIENT HELLO packets
-to the servers, announcing support for most common cipher suites. If the server
-responds what looks like a SERVER HELLO or an ALERT (refuses the ciphers) then
-the response is considered as valid. Note that Apache does not generate a log
-when it receives only an HELLO message, which makes this type of message
-perfectly suit this need.
-
-Version 1.3.10 introduced the SMTP health check. By default, it sends
-"HELO localhost" to the servers, and waits for the 250 message. Note that it
-can also send a specific request :
-
-  - option smtpchk                         -> sends "HELO localhost"
-  - option smtpchk EHLO mail.mydomain.com  -> sends this ESMTP greeting
-
-See examples below.
-
-Since version 1.1.17, it is possible to specify backup servers. These servers
-are only sollicited when no other server is available. This may only be useful
-to serve a maintenance page, or define one active and one backup server (seldom
-used in TCP mode). To make a server a backup one, simply add the 'backup' option
-on its line. These servers also support cookies, so if a cookie is specified for
-a backup server, clients assigned to this server will stick to it even when the
-other ones come back. Conversely, if no cookie is assigned to such a server,
-the clients will get their cookies removed (empty cookie = removal), and will
-be balanced against other servers once they come back. Please note that there
-is no load-balancing among backup servers by default. If there are several
-backup servers, the second one will only be used when the first one dies, and
-so on. To force load-balancing between backup servers, specify the 'allbackups'
-option.
-
-Since version 1.1.22, it is possible to send health checks to a different port
-than the service. It is mainly needed in setups where the server does not have
-any predefined port, for instance when the port is deduced from the listening
-port. For this, use the 'port' parameter followed by the port number which must
-respond to health checks. It is also possible to send health checks to a
-different address than the service. It makes it easier to use a dedicated check
-daemon on the servers, for instance, check return contents and stop several
-farms at once in the event of an error anywhere.
-
-Since version 1.1.17, it is also possible to visually check the status of all
-servers at once. For this, you just have to send a SIGHUP signal to the proxy.
-The servers status will be dumped into the logs at the 'notice' level, as well
-as on <stderr> if not closed. For this reason, it's always a good idea to have
-one local log server at the 'notice' level.
-
-Since version 1.1.28 and 1.2.1, if an instance loses all its servers, an
-emergency message will be sent in the logs to inform the administator that an
-immediate action must be taken.
-
-Since version 1.1.30 and 1.2.3, several servers can share the same cookie
-value. This is particularly useful in backup mode, to select alternate paths
-for a given server for example, to provide soft-stop, or to direct the clients
-to a temporary page during an application restart. The principle is that when
-a server is dead, the proxy will first look for another server which shares the
-same cookie value for every client which presents the cookie. If there is no
-standard server for this cookie, it will then look for a backup server which
-shares the same name. Please consult the architecture guide for more information.
-
-Examples :
-----------
-# same setup as in  paragraph 3) with TCP monitoring
-    listen http_proxy 0.0.0.0:80
-        mode http
-        cookie SERVERID
-        balance roundrobin
-        server web1 192.168.1.1:80 cookie server01 check
-        server web2 192.168.1.2:80 cookie server02 check inter 500 rise 1 fall 2
-
-# same with HTTP monitoring via 'OPTIONS / HTTP/1.0'
-    listen http_proxy 0.0.0.0:80
-        mode http
-        cookie SERVERID
-        balance roundrobin
-        option httpchk
-        server web1 192.168.1.1:80 cookie server01 check
-        server web2 192.168.1.2:80 cookie server02 check inter 500 rise 1 fall 2
-
-# same with HTTP monitoring via 'OPTIONS /index.html HTTP/1.0'
-    listen http_proxy 0.0.0.0:80
-        mode http
-        cookie SERVERID
-        balance roundrobin
-        option httpchk /index.html
-        server web1 192.168.1.1:80 cookie server01 check
-        server web2 192.168.1.2:80 cookie server02 check inter 500 rise 1 fall 2
-
-# same with HTTP monitoring via 'HEAD /index.jsp? HTTP/1.1\r\nHost: www'
-    listen http_proxy 0.0.0.0:80
-        mode http
-        cookie SERVERID
-        balance roundrobin
-        option httpchk HEAD /index.jsp? HTTP/1.1\r\nHost:\ www
-        server web1 192.168.1.1:80 cookie server01 check
-        server web2 192.168.1.2:80 cookie server02 check inter 500 rise 1 fall 2
-
-# Load-balancing with 'prefixed cookie' persistence, and soft-stop using an
-# alternate port 81 on the server for health-checks.
-    listen http_proxy 0.0.0.0:80
-        mode http
-        cookie JSESSIONID prefix
-        balance roundrobin
-        option httpchk HEAD /index.jsp? HTTP/1.1\r\nHost:\ www
-        server web1-norm 192.168.1.1:80 cookie s1 check port 81
-        server web2-norm 192.168.1.2:80 cookie s2 check port 81
-        server web1-stop 192.168.1.1:80 cookie s1 check port 80 backup
-        server web2-stop 192.168.1.2:80 cookie s2 check port 80 backup
-
-# automatic insertion of a cookie in the server's response, and automatic
-# deletion of the cookie in the client request, while asking upstream caches
-# not to cache replies.
-    listen web_appl 0.0.0.0:80
-        mode http
-        cookie SERVERID insert nocache indirect
-        balance roundrobin
-        server web1 192.168.1.1:80 cookie server01 check
-        server web2 192.168.1.2:80 cookie server02 check
-
-# same with off-site application backup and local error pages server
-    listen web_appl 0.0.0.0:80
-        mode http
-        cookie SERVERID insert nocache indirect
-        balance roundrobin
-        server web1 192.168.1.1:80 cookie server01 check
-        server web2 192.168.1.2:80 cookie server02 check
-        server web-backup 192.168.2.1:80 cookie server03 check backup
-        server web-excuse 192.168.3.1:80 check backup
-
-# SMTP+TLS relaying with health-checks and backup servers
-
-    listen http_proxy :25,:587
-        mode tcp
-        balance roundrobin
-        server srv1 192.168.1.1 check port 25 inter 30000 rise 1 fall 2
-        server srv2 192.168.1.2 backup
-
-# HTTPS relaying with health-checks and backup servers
-
-    listen http_proxy :443
-        mode tcp
-	option ssl-hello-chk
-        balance roundrobin
-        server srv1 192.168.1.1 check inter 30000 rise 1 fall 2
-        server srv2 192.168.1.2 backup
-
-# Load-balancing using a backup pool (requires haproxy 1.2.9)
-    listen http_proxy 0.0.0.0:80
-        mode http
-        balance roundrobin
-        option httpchk
-        server inst1 192.168.1.1:80 cookie s1 check
-        server inst2 192.168.1.2:80 cookie s2 check
-        server inst3 192.168.1.3:80 cookie s3 check
-        server back1 192.168.1.10:80 check backup
-        server back2 192.168.1.11:80 check backup
-        option allbackups  # all backups will be used
-
-
-3.2) Redistribute connections in case of failure
-------------------------------------------------
-In HTTP mode, if a server designated by a cookie does not respond, the clients
-may definitely stick to it because they cannot flush the cookie, so they will
-not be able to access the service anymore. Specifying 'redispatch' will allow
-the proxy to break their persistence and redistribute them to working servers.
-
-Example :
----------
-    listen http_proxy 0.0.0.0:80
-        mode http
-        cookie SERVERID
-        dispatch 192.168.1.100:80
-        server web1 192.168.1.1:80 cookie server01
-        server web2 192.168.1.2:80 cookie server02
-        redispatch # send back to dispatch in case of connection failure
-
-Up to, and including version 1.1.16, this parameter only applied to connection
-failures. Since version 1.1.17, it also applies to servers which have been
-detected as failed by the health check mechanism. Indeed, a server may be broken
-but still accepting connections, which would not solve every case. But it is
-possible to conserve the old behaviour, that is, make a client insist on trying
-to connect to a server even if it is said to be down, by setting the 'persist'
-option :
-
-    listen http_proxy 0.0.0.0:80
-        mode http
-        option persist
-        cookie SERVERID
-        dispatch 192.168.1.100:80
-        server web1 192.168.1.1:80 cookie server01
-        server web2 192.168.1.2:80 cookie server02
-        redispatch # send back to dispatch in case of connection failure
-
-
-3.3) Assigning different weights to servers
--------------------------------------------
-Sometimes you will need to bring new servers to increase your server farm's
-capacity, but the new server will be either smaller (emergency use of anything
-that fits) or bigger (when investing in new hardware). For this reason, it
-might be wise to be able to send more clients to biggest servers. Till version
-1.2.11, it was necessary to replicate the same server multiple times in the
-configuration. Starting with 1.2.12, the 'weight' option is available. HAProxy
-then computes the most homogenous possible map of servers based on their
-weights so that the load gets distributed as smoothly as possible among them.
-The weight, between 1 and 256, should reflect one server's capacity relative to
-others. Weight 1 represents the lowest frequency and 256 the highest. This way,
-if a server fails, the remaining capacities are still respected.
-
-Example :
----------
-# fair distribution among two opterons and one old pentium3
-
-    listen web_appl 0.0.0.0:80
-        mode http
-        cookie SERVERID insert nocache indirect
-        balance roundrobin
-        server pentium3-800 192.168.1.1:80 cookie server01 weight  8 check
-        server opteron-2.0G 192.168.1.2:80 cookie server02 weight 20 check
-        server opteron-2.4G 192.168.1.3:80 cookie server03 weight 24 check
-        server web-backup1 192.168.2.1:80 cookie server04 check backup
-        server web-excuse 192.168.3.1:80 check backup
-
-Notes :
--------
-  - if unspecified, the default weight is 1
-
-  - the weight does not impact health checks, so it is cleaner to use weights
-    than replicating the same server several times
-
-  - weights also work on backup servers if the 'allbackups' option is used
-
-  - the weights also apply to the source address load balancing
-    ('balance source').
-
-  - whatever the weights, the first server will always be assigned first. This
-    is helpful for troubleshooting.
-
-  - for the purists, the map calculation algorithm gives precedence to first
-    server, so the map is the most uniform when servers are declared in
-    ascending order relative to their weights.
-
-The load distribution will follow exactly this sequence :
-
-        Request|                   1 1 1 1
-        number | 1 2 3 4 5 6 7 8 9 0 1 2 3
-       --------+---------------------------
-        p3-800 | X . . . . . . X . . . . .
-        opt-20 | . X . X . X . . . X . X .
-        opt-24 | . . X . X . X . X . X . X
-
-
-3.4) Limiting the number of concurrent sessions on each server
---------------------------------------------------------------
-Some pre-forked servers such as Apache suffer from too many concurrent
-sessions, because it's very expensive to run hundreds or thousands of
-processes on one system. One solution is to increase the number of servers
-and load-balance between them, but it is a problem when the only goal is
-to resist to short surges.
-
-To solve this problem, a new feature was implemented in HAProxy 1.2.13.
-It's a per-server 'maxconn', associated with a per-server and a per-proxy
-queue. This transforms haproxy into a request buffer between the thousands of
-clients and the few servers. On many circumstances, lowering the maxconn value
-will increase the server's performance and decrease the overall response times
-because the servers will be less congested.
-
-When a request tries to reach any server, the first non-saturated server is
-used, respective to the load balancing algorithm. If all servers are saturated,
-then the request gets queued into the instance's global queue. It will be
-dequeued once a server will have freed a session and all previously queued
-requests have been processed.
-
-If a request references a particular server (eg: source hashing, or persistence
-cookie), and if this server is full, then the request will be queued into the
-server's dedicated queue. This queue has higher priority than the global queue,
-so it's easier for already registered users to enter the site than for new
-users.
-
-For this, the logs have been enhanced to show the number of sessions per
-server, the request's position in the queue and the time spent in the queue.
-This helps doing capacity planning. See the 'logs' section below for more info.
-
-Example :
----------
-    # be nice with P3 which only has 256 MB of RAM.
-    listen web_appl 0.0.0.0:80
-        maxconn 10000
-        mode http
-        cookie SERVERID insert nocache indirect
-        balance roundrobin
-        server pentium3-800 192.168.1.1:80 cookie s1 weight  8 maxconn 100 check
-        server opteron-2.0G 192.168.1.2:80 cookie s2 weight 20 maxconn 300 check
-        server opteron-2.4G 192.168.1.3:80 cookie s3 weight 24 maxconn 300 check
-        server web-backup1 192.168.2.1:80 cookie s4 check maxconn 200 backup
-        server web-excuse 192.168.3.1:80 check backup
-
-
-This was so much efficient at reducing the server's response time that some
-users wanted to use low values to improve their server's performance. However,
-they were not able anymore to handle very large loads because it was not
-possible anymore to saturate the servers. For this reason, version 1.2.14 has
-brought dynamic limitation with the addition of the parameter 'minconn'. When
-this parameter is set along with maxconn, it will enable dynamic limitation
-based on the instance's load. The maximum number of concurrent sessions on a
-server will be proportionnal to the number of sessions on the instance relative
-to its maxconn. A minimum of <minconn> will be allowed whatever the load. This
-will ensure that servers will perform at their best level under normal loads,
-while still handling surges when needed. The dynamic limit is computed like
-this :
-
-    srv.dyn_limit = max(srv.minconn, srv.maxconn * inst.sess / inst.maxconn)
-
-Example :
----------
-    # be nice with P3 which only has 256 MB of RAM.
-    listen web_appl 0.0.0.0:80
-        maxconn 10000
-        mode http
-        cookie SERVERID insert nocache indirect
-        balance roundrobin
-        server pentium3-800 192.168.1.1:80 cookie s1 weight  8 minconn 10 maxconn 100 check
-        server opteron-2.0G 192.168.1.2:80 cookie s2 weight 20 minconn 30 maxconn 300 check
-        server opteron-2.4G 192.168.1.3:80 cookie s3 weight 24 minconn 30 maxconn 300 check
-        server web-backup1 192.168.2.1:80 cookie s4 check maxconn 200 backup
-        server web-excuse 192.168.3.1:80 check backup
-
-In the example above, the server 'pentium3-800' will receive at most 100
-simultaneous sessions when the proxy instance will reach 10000 sessions, and
-will receive only 10 simultaneous sessions when the proxy will be under 1000
-sessions.
-
-It is possible to limit server queue length in order to rebalance excess
-sessions between less busy application servers IF session affinity isn't
-hard functional requirement (for example it just gives huge performance boost
-by keeping server-local caches hot and compact). 'maxqueue' option sets a
-queue limit on a server, as in example below:
-
-... (just the same as in example above)
-        server pentium3-800 192.168.1.1:80 cookie s1 weight  8 minconn 10 maxconn 100 check maxqueue 50
-        server opteron-2.0G 192.168.1.2:80 cookie s2 weight 20 minconn 30 maxconn 300 check maxqueue 200
-        server opteron-2.4G 192.168.1.3:80 cookie s3 weight 24 minconn 30 maxconn 300 check
-
-Absence of 'maxqueue' option means unlimited queue. When queue gets filled
-up to 'maxqueue' client session is moved from server-local queue to a global
-one.
-
-Notes :
--------
-  - The requests will not stay indefinitely in the queue, they follow the
-    'contimeout' parameter, and if a request cannot be dequeued within this
-    timeout because the server is saturated or because the queue is filled,
-    the session will expire with a 503 error.
-
-  - if only <minconn> is specified, it has the same effect as <maxconn>
-
-  - setting too low values for maxconn might improve performance but might also
-    allow slow users to block access to the server for other users.
-
-
-3.5) Dropping aborted requests
-------------------------------
-In presence of very high loads, the servers will take some time to respond. The
-per-proxy's connection queue will inflate, and the response time will increase
-respective to the size of the queue times the average per-session response
-time. When clients will wait for more than a few seconds, they will often hit
-the 'STOP' button on their browser, leaving a useless request in the queue, and
-slowing down other users.
-
-As there is no way to distinguish between a full STOP and a simple
-shutdown(SHUT_WR) on the client side, HTTP agents should be conservative and
-consider that the client might only have closed its output channel while
-waiting for the response. However, this introduces risks of congestion when
-lots of users do the same, and is completely useless nowadays because probably
-no client at all will close the session while waiting for the response. Some
-HTTP agents support this (Squid, Apache, HAProxy), and others do not (TUX, most
-hardware-based load balancers). So the probability for a closed input channel
-to represent a user hitting the 'STOP' button is close to 100%, and it is very
-tempting to be able to abort the session early without polluting the servers.
-
-For this reason, a new option "abortonclose" was introduced in version 1.2.14.
-By default (without the option) the behaviour is HTTP-compliant. But when the
-option is specified, a session with an incoming channel closed will be aborted
-if it's still possible, which means that it's either waiting for a connect() to
-establish or it is queued waiting for a connection slot. This considerably
-reduces the queue size and the load on saturated servers when users are tempted
-to click on STOP, which in turn reduces the response time for other users.
-
-Example :
----------
-    listen web_appl 0.0.0.0:80
-        maxconn 10000
-        mode http
-        cookie SERVERID insert nocache indirect
-        balance roundrobin
-        server web1 192.168.1.1:80 cookie s1 weight 10 maxconn 100 check
-        server web2 192.168.1.2:80 cookie s2 weight 10 maxconn 100 check
-        server web3 192.168.1.3:80 cookie s3 weight 10 maxconn 100 check
-        server bck1 192.168.2.1:80 cookie s4 check maxconn 200 backup
-        option abortonclose
-
-
-4) Additionnal features
-=======================
-
-Other features are available. They are transparent mode, event logging, header
-rewriting/filtering, and the status as an HTML page.
-
-
-4.1) Network features
----------------------
-4.1.1) Transparent mode
------------------------
-In HTTP mode, the 'transparent' keyword allows to intercept sessions which are
-routed through the system hosting the proxy. This mode was implemented as a
-replacement for the 'dispatch' mode, since connections without cookie will be
-sent to the original address while known cookies will be sent to the servers.
-This mode implies that the system can redirect sessions to a local port.
-
-Example :
----------
-    listen http_proxy 0.0.0.0:65000
-        mode http
-        transparent
-        cookie SERVERID
-        server server01 192.168.1.1:80
-        server server02 192.168.1.2:80
-
-    # iptables -t nat -A PREROUTING -i eth0 -p tcp -d 192.168.1.100 \
-      --dport 80 -j REDIRECT --to-ports 65000
-
-Note :
-------
-If the port is left unspecified on the server, the port the client connected to
-will be used. This allows to relay a full port range without using transparent
-mode nor thousands of file descriptors, provided that the system can redirect
-sessions to local ports.
-
-Example :
----------
-    # redirect all ports to local port 65000, then forward to the server on the
-    # original port.
-    listen http_proxy 0.0.0.0:65000
-        mode tcp
-        server server01 192.168.1.1 check port 60000
-        server server02 192.168.1.2 check port 60000
-
-    # iptables -t nat -A PREROUTING -i eth0 -p tcp -d 192.168.1.100 \
-      -j REDIRECT --to-ports 65000
-
-4.1.2) Per-server source address binding
-----------------------------------------
-As of versions 1.1.30 and 1.2.3, it is possible to specify a particular source
-to reach each server. This is useful when reaching backup servers from a
-different LAN, or to use an alternate path to reach the same server. It is also
-usable to provide source load-balancing for outgoing connections. Obviously,
-the same source address is used to send health-checks.
-
-Example :
----------
-    # use a particular source to reach both servers
-    listen http_proxy 0.0.0.0:65000
-        mode http
-        balance roundrobin
-        server server01 192.168.1.1:80 source 192.168.2.13
-        server server02 192.168.1.2:80 source 192.168.2.13
-
-Example :
----------
-    # use a particular source to reach each servers
-    listen http_proxy 0.0.0.0:65000
-        mode http
-        balance roundrobin
-        server server01 192.168.1.1:80 source 192.168.1.1
-        server server02 192.168.2.1:80 source 192.168.2.1
-
-Example :
----------
-    # provide source load-balancing to reach the same proxy through 2 WAN links
-    listen http_proxy 0.0.0.0:65000
-        mode http
-        balance roundrobin
-        server remote-proxy-way1 192.168.1.1:3128 source 192.168.2.1
-        server remote-proxy-way2 192.168.1.1:3128 source 192.168.3.1
-
-Example :
----------
-    # force a TCP connection to bind to a specific port
-    listen http_proxy 0.0.0.0:2000
-        mode tcp
-        balance roundrobin
-        server srv1 192.168.1.1:80 source 192.168.2.1:20
-        server srv2 192.168.1.2:80 source 192.168.2.1:20
-
-4.1.3) TCP keep-alive
----------------------
-With version 1.2.7, it becomes possible to enable TCP keep-alives on both the
-client and server sides. This makes it possible to prevent long sessions from
-expiring on external layer 4 components such as firewalls and load-balancers.
-It also allows the system to terminate dead sessions when no timeout has been
-set (not recommanded). The proxy cannot set the keep-alive probes intervals nor
-maximal count, consult your operating system manual for this. There are 3
-options to enable TCP keep-alive :
-
-	option tcpka	# enables keep-alive both on client and server side
-	option clitcpka	# enables keep-alive only on client side
-	option srvtcpka	# enables keep-alive only on server side
-
-4.1.4) TCP lingering
---------------------
-It is possible to disable the system's lingering of data unacked by the client
-at the end of a session. This is sometimes required when haproxy is used as a
-front-end with lots of unreliable clients, and you observe thousands of sockets
-in the FIN_WAIT state on the machine. This may be used in a frontend to affect
-the client-side connection, as well as in a backend for the server-side
-connection :
-
-	option nolinger	# disables data lingering
-
-
-4.2) Event logging
-------------------
-
-HAProxy's strength certainly lies in its precise logs. It probably provides the
-finest level of information available for such a product, which is very
-important for troubleshooting complex environments. Standard log information
-include client ports, TCP/HTTP state timers, precise session state at
-termination and precise termination cause, information about decisions to
-direct trafic to a server, and of course the ability to capture arbitrary
-headers.
-
-In order to improve administrators reactivity, it offers a great transparency
-about encountered problems, both internal and external, and it is possible to
-send logs to different sources at the same time with different level filters :
-
-  - global process-level logs (system errors, start/stop, etc..)
-  - per-listener system and internal errors (lack of resource, bugs, ...)
-  - per-listener external troubles (servers up/down, max connections)
-  - per-listener activity (client connections), either at the establishment or
-    at the termination.
-
-The ability to distribute different levels of logs to different log servers
-allow several production teams to interact and to fix their problems as soon
-as possible. For example, the system team might monitor system-wide errors,
-while the application team might be monitoring the up/down for their servers in
-real time, and the security team might analyze the activity logs with one hour
-delay.
-
-4.2.1) Log levels
------------------
-TCP and HTTP connections can be logged with informations such as date, time,
-source IP address, destination address, connection duration, response times,
-HTTP request, the HTTP return code, number of bytes transmitted, the conditions
-in which the session ended, and even exchanged cookies values, to track a
-particular user's problems for example. All messages are sent to up to two
-syslog servers. Consult section 1.1 for more info about log facilities. The
-syntax follows :
-
-    log <address_1> <facility_1> [max_level_1]
-    log <address_2> <facility_2> [max_level_2]
-or
-    log global
-
-Note :
-------
-The particular syntax 'log global' means that the same log configuration as the
-'global' section will be used.
-
-Example :
----------
-    listen http_proxy 0.0.0.0:80
-        mode http
-        log 192.168.2.200 local3
-        log 192.168.2.201 local4
-
-4.2.2) Log format
------------------
-By default, connections are logged at the TCP level, as soon as the session
-establishes between the client and the proxy. By enabling the 'tcplog' option,
-the proxy will wait until the session ends to generate an enhanced log
-containing more information such as session duration and its state during the
-disconnection. The number of remaining session after disconnection is also
-indicated (for the server, the listener, and the process).
-
-Example of TCP logging :
-------------------------
-    listen relais-tcp 0.0.0.0:8000
-        mode tcp
-        option tcplog
-        log 192.168.2.200 local3
-
->>> haproxy[18989]: 127.0.0.1:34550 [15/Oct/2003:15:24:28] relais-tcp Srv1 0/0/5007 0 -- 1/1/1 0/0
-  
-    Field  Format                                        Example
-
-        1  process_name '[' pid ']:'                     haproxy[18989]:
-        2  client_ip ':' client_port                     127.0.0.1:34550
-        3  '[' date ']'                                  [15/Oct/2003:15:24:28]
-        4  listener_name                                 relais-tcp
-        5  server_name                                   Srv1
-        6  queue_time '/' connect_time '/' total_time    0/0/5007
-        7  bytes_read                                    0
-        8  termination_state                             --
-        9  srv_conn '/' listener_conn '/' process_conn   1/1/1
-       10  position in srv_queue / listener_queue        0/0
-
-
-Another option, 'httplog', provides more detailed information about HTTP
-contents, such as the request and some cookies. In the event where an external
-component would establish frequent connections to check the service, logs may be
-full of useless lines. So it is possible not to log any session which didn't
-transfer any data, by the setting of the 'dontlognull' option. This only has
-effect on sessions which are established then closed.
-
-Example of HTTP logging :
--------------------------
-    listen http_proxy 0.0.0.0:80
-        mode http
-        option httplog
-        option dontlognull
-        log 192.168.2.200 local3
-
->>> haproxy[674]: 127.0.0.1:33319 [15/Oct/2003:08:31:57] relais-http Srv1 9/0/7/147/723 200 243 - - ---- 34/34/15/8/3 0/0 "HEAD / HTTP/1.0"
-
-More complete example
-    haproxy[18989]: 10.0.0.1:34552 [15/Oct/2003:15:26:31] relais-http Srv1 3183/-1/-1/-1/11215 503 0 - - SC-- 205/202/150/137/+4 0/0 {w.ods.org|Mozilla} {} "HEAD / HTTP/1.0" 
-
-    Field  Format							Example
-  
-        1  process_name  '[' pid ']:'					haproxy[18989]:
-        2  client_ip ':' client_port					10.0.0.1:34552
-        3  '[' date ']'							[15/Oct/2003:15:26:31]
-        4  listener_name						relais-http
-        5  server_name							Srv1
-        6  Tq '/' Tw '/' Tc '/' Tr '/' Tt				3183/-1/-1/-1/11215
-        7  HTTP_return_code						503
-        8  bytes_read							0
-        9  captured_request_cookie					-
-       10  captured_response_cookie					-
-       11  termination_state						SC--
-       12  actconn '/' feconn '/' beconn '/' srv_conn '/' retries 	205/202/150/137/+4
-       13  position in srv_queue / listener_queue			0/0
-       14  '{' captured_request_headers '}'				{w.ods.org|Mozilla}
-       15  '{' captured_response_headers '}'				{}
-       16  '"' HTTP_request '"'						"HEAD / HTTP/1.0"
-  
-Note for log parsers: the URI is ALWAYS the end of the line starting with the
-                      first double quote '"'.
-
-The retries count may have additional '+' sign means that the connection had been
-redispatched from one server to another shortly before retries limit (retries 4
-in above example) was depleted.
-
-The problem when logging at end of connection is that you have no clue about
-what is happening during very long sessions. To workaround this problem, a
-new option 'logasap' has been introduced in 1.1.28/1.2.1. When specified, the
-proxy will log as soon as possible, just before data transfer begins. This means
-that in case of TCP, it will still log the connection status to the server, and
-in case of HTTP, it will log just after processing the server headers. In this
-case, the number of bytes reported is the number of header bytes sent to the
-client.
-
-In order to avoid confusion with normal logs, the total time field and the
-number of bytes are prefixed with a '+' sign which means that real numbers are
-certainly bigger.
-
-Example :
----------
-
-    listen http_proxy 0.0.0.0:80
-        mode http
-        option httplog
-        option dontlognull
-        option logasap
-        log 192.168.2.200 local3
-
->>> haproxy[674]: 127.0.0.1:33320 [15/Oct/2003:08:32:17] relais-http Srv1 9/10/7/14/+30 200 +243 - - ---- 3/1/1/1/0 1/0 "GET /image.iso HTTP/1.0"
-
-4.2.3) Timing events
---------------------
-Timers provide a great help in trouble shooting network problems. All values
-are reported in milliseconds (ms). In HTTP mode, four control points are
-reported under the form 'Tq/Tw/Tc/Tr/Tt' :
-
-  - Tq: total time to get the client request.
-    It's the time elapsed between the moment the client connection was accepted
-    and the moment the proxy received the last HTTP header. The value '-1'
-    indicates that the end of headers (empty line) has never been seen.
-
-  - Tw: total time spent in the queues waiting for a connection slot. It
-    accounts for listener's queue as well as the server's queue, and depends
-    on the queue size, and the time needed for the server to complete previous
-    sessions. The value '-1' means that the request was killed before reaching
-    the queue.
-
-  - Tc: total time to establish the TCP connection to the server.
-    It's the time elapsed between the moment the proxy sent the connection
-    request, and the moment it was acknowledged, or between the TCP SYN packet
-    and the matching SYN/ACK in return. The value '-1' means that the
-    connection never established.
-
-  - Tr: server response time. It's the time elapsed between the moment the
-    TCP connection was established to the server and the moment it send its
-    complete response header. It purely shows its request processing time,
-    without the network overhead due to the data transmission. The value '-1'
-    means that the last the response header (empty line) was never seen.
-
-  - Tt: total session duration time, between the moment the proxy accepted it
-    and the moment both ends were closed. The exception is when the 'logasap'
-    option is specified. In this case, it only equals (Tq+Tw+Tc+Tr), and is
-    prefixed with a '+' sign. From this field, we can deduce Td, the data
-    transmission time, by substracting other timers when valid :
-
-        Td = Tt - (Tq + Tw + Tc + Tr)
-
-    Timers with '-1' values have to be excluded from this equation.
-
-In TCP mode ('option tcplog'), only Tw, Tc and Tt are reported.
-
-These timers provide precious indications on trouble causes. Since the TCP
-protocol defines retransmit delays of 3, 6, 12... seconds, we know for sure
-that timers close to multiples of 3s are nearly always related to packets lost
-due to network problems (wires or negociation). Moreover, if <Tt> is close to
-a timeout value specified in the configuration, it often means that a session
-has been aborted on time-out.
-
-Most common cases :
-
-  - If Tq is close to 3000, a packet has probably been lost between the client
-    and the proxy.
-  - If Tc is close to 3000, a packet has probably been lost between the server
-    and the proxy during the server connection phase. This one should always be
-    very low (less than a few tens).
-  - If Tr is nearly always lower than 3000 except some rare values which seem to
-    be the average majored by 3000, there are probably some packets lost between
-    the proxy and the server.
-  - If Tt is often slightly higher than a time-out, it's often because the
-    client and the server use HTTP keep-alive and the session is maintained
-    after the response ends. Se further for how to disable HTTP keep-alive.
-
-Other cases ('xx' means any value to be ignored) :
-  -1/xx/xx/xx/Tt: the client was not able to send its complete request in time,
-                  or that it aborted it too early.
-  Tq/-1/xx/xx/Tt: it was not possible to process the request, maybe because
-                  servers were out of order.
-  Tq/Tw/-1/xx/Tt: the connection could not establish on the server. Either it
-                  refused it or it timed out after Tt-(Tq+Tw) ms.
-  Tq/Tw/Tc/-1/Tt: the server has accepted the connection but did not return a
-                  complete response in time, or it closed its connexion
-                  unexpectedly, after Tt-(Tq+Tw+Tc) ms.
-
-4.2.4) Session state at disconnection
--------------------------------------
-TCP and HTTP logs provide a session completion indicator in the
-<termination_state> field, just before the number of active
-connections. It is 2-characters long in TCP, and 4-characters long in
-HTTP, each of which has a special meaning :
-
-  - On the first character, a code reporting the first event which caused the
-    session to terminate :
-
-        C : the TCP session was unexpectedly aborted by the client.
-
-        S : the TCP session was unexpectedly aborted by the server, or the
-            server explicitly refused it.
-
-        P : the session was prematurely aborted by the proxy, because of a
-            connection limit enforcement, because a DENY filter was matched,
-            or because of a security check which detected and blocked a
-            dangerous error in server response which might have caused
-            information leak (eg: cacheable cookie).
-
-        R : a resource on the proxy has been exhausted (memory, sockets, source
-            ports, ...). Usually, this appears during the connection phase, and
-            system logs should contain a copy of the precise error.
-
-        I : an internal error was identified by the proxy during a self-check.
-            This should NEVER happen, and you are encouraged to report any log
-            containing this, because this is a bug.
-
-        c : the client-side time-out expired first.
-
-        s : the server-side time-out expired first.
-
-        - : normal session completion.
-
-  - on the second character, the TCP/HTTP session state when it was closed :
-
-        R : waiting for complete REQUEST from the client (HTTP only). Nothing
-            was sent to any server.
-
-        Q : waiting in the QUEUE for a connection slot. This can only happen on
-            servers which have a 'maxconn' parameter set. No connection attempt
-            was made to any server.
-
-        C : waiting for CONNECTION to establish on the server. The server might
-            at most have noticed a connection attempt.
-
-        H : waiting for, receiving and processing server HEADERS (HTTP only).
-
-        D : the session was in the DATA phase.
-
-        L : the proxy was still transmitting LAST data to the client while the
-            server had already finished.
-
-        T : the request was tarpitted. It has been held open on with the client
-            during the whole contimeout duration or untill the client closed.
-
-        - : normal session completion after end of data transfer.
-
-  - the third character tells whether the persistence cookie was provided by
-    the client (only in HTTP mode) :
-
-        N : the client provided NO cookie. This is usually the case on new
-            connections.
-
-        I : the client provided an INVALID cookie matching no known
-            server. This might be caused by a recent configuration change,
-            mixed cookies between HTTP/HTTPS sites, or an attack.
-
-        D : the client provided a cookie designating a server which was DOWN,
-            so either the 'persist' option was used and the client was sent to
-            this server, or it was not set and the client was redispatched to
-            another server.
-
-        V : the client provided a valid cookie, and was sent to the associated
-            server.
-
-        - : does not apply (no cookie set in configuration).
-
-  - the last character reports what operations were performed on the persistence
-    cookie returned by the server (only in HTTP mode) :
-
-        N : NO cookie was provided by the server, and none was inserted either.
-
-        I : no cookie was provided by the server, and the proxy INSERTED one.
-
-        P : a cookie was PROVIDED by the server and transmitted as-is.
-
-        R : the cookie provided by the server was REWRITTEN by the proxy.
-
-        D : the cookie provided by the server was DELETED by the proxy.
-
-        - : does not apply (no cookie set in configuration).
-
-The combination of the two first flags give a lot of information about what was
-happening when the session terminated. It can be helpful to detect server
-saturation, network troubles, local system resource starvation, attacks, etc...
-
-The most common termination flags combinations are indicated here.
-
-   Flags  Reason
-      CR  The client aborted before sending a full request. Most probably the
-          request was done by hand using a telnet client, and aborted early.
-
-      cR  The client timed out before sending a full request. This is sometimes
-          caused by too large TCP MSS values on the client side for PPPoE
-          networks which cannot transport full-sized packets, or by clients
-          sending requests by hand and not typing fast enough.
-
-      SC  The server explicitly refused the connection (the proxy received a
-          TCP RST or an ICMP in return). Under some circumstances, it can
-          also be the network stack telling the proxy that the server is
-          unreachable (eg: no route, or no ARP response on local network).
-
-      sC  The connection to the server did not complete during contimeout.
-
-      PC  The proxy refused to establish a connection to the server because the
-          maxconn limit has been reached. The listener's maxconn parameter may
-          be increased in the proxy configuration, as well as the global
-          maxconn parameter.
-
-      RC  A local resource has been exhausted (memory, sockets, source ports)
-          preventing the connection to the server from establishing. The error
-          logs will tell precisely what was missing. Anyway, this can only be
-          solved by system tuning.
-
-      cH  The client timed out during a POST request. This is sometimes caused
-          by too large TCP MSS values for PPPoE networks which cannot transport
-          full-sized packets.
-
-      CH  The client aborted while waiting for the server to start responding.
-          It might be the server taking too long to respond or the client
-          clicking the 'Stop' button too fast.
-
-      CQ  The client aborted while its session was queued, waiting for a server
-          with enough empty slots to accept it. It might be that either all the
-          servers were saturated or the assigned server taking too long to
-          respond.
-
-      CT  The client aborted while its session was tarpitted.
-
-      sQ  The session spent too much time in queue and has been expired.
-
-      SH  The server aborted before sending its full headers, or it crashed.
-
-      sH  The server failed to reply during the srvtimeout delay, which
-          indicates too long transactions, probably caused by back-end
-          saturation. The only solutions are to fix the problem on the
-          application or to increase the 'srvtimeout' parameter to support
-          longer delays (at the risk of the client giving up anyway).
-      
-      PR  The proxy blocked the client's request, either because of an invalid
-          HTTP syntax, in which case it returned an HTTP 400 error to the
-          client, or because a deny filter matched, in which case it returned
-          an HTTP 403 error.
-
-      PH  The proxy blocked the server's response, because it was invalid,
-          incomplete, dangerous (cache control), or matched a security filter.
-          In any case, an HTTP 502 error is sent to the client.
-
-      PT  The proxy blocked the client's request and has tarpitted its
-          connection before returning it a 500 server error. Nothing was sent
-          to the server.
-
-      cD  The client did not read any data for as long as the clitimeout delay.
-          This is often caused by network failures on the client side.
-
-      CD  The client unexpectedly aborted during data transfer. This is either
-          caused by a browser crash, or by a keep-alive session between the
-          server and the client terminated first by the client.
-
-      sD  The server did nothing during the srvtimeout delay. This is often
-          caused by too short timeouts on L4 equipements before the server
-          (firewalls, load-balancers, ...).
-
-4.2.5) Non-printable characters
--------------------------------
-As of version 1.1.29, non-printable characters are not sent as-is into log
-files, but are converted to their two-digits hexadecimal representation,
-prefixed by the character '#'. The only characters that can now be logged
-without being escaped are between 32 and 126 (inclusive). Obviously, the
-escape character '#' is also encoded to avoid any ambiguity. It is the same for
-the character '"', as well as '{', '|' and '}' when logging headers.
-
-4.2.6) Capturing HTTP headers and cookies
------------------------------------------
-Version 1.1.23 brought cookie capture, and 1.1.29 the header capture. All this
-is performed using the 'capture' keyword.
-
-Cookie capture makes it easy to track a complete user session. The syntax is :
-
-    capture cookie <cookie_prefix> len <capture_length>
-
-This will enable cookie capture from both requests and responses. This way,
-it's easy to detect when a user switches to a new session for example, because
-the server will reassign it a new cookie.
-
-The FIRST cookie whose name starts with <cookie_prefix> will be captured, and
-logged as 'NAME=value', without exceeding <capture_length> characters (64 max).
-When the cookie name is fixed and known, it's preferable to suffix '=' to it to
-ensure that no other cookie will be logged.
-
-Examples :
-----------
-    # capture the first cookie whose name starts with "ASPSESSION"
-    capture cookie ASPSESSION len 32
-
-    # capture the first cookie whose name is exactly "vgnvisitor"
-    capture cookie vgnvisitor= len 32
-
-In the logs, the field preceeding the completion indicator contains the cookie
-value as sent by the server, preceeded by the cookie value as sent by the
-client. Each of these field is replaced with '-' when no cookie was seen or
-when the option is disabled.
-
-Header captures have a different goal. They are useful to track unique request
-identifiers set by a previous proxy, virtual host names, user-agents, POST
-content-length, referrers, etc. In the response, one can search for information
-about the response length, how the server asked the cache to behave, or an
-object location during a redirection. As for cookie captures, it is both
-possible to include request headers and response headers at the same time. The
-syntax is :
-
-    capture request  header <name> len <max length>
-    capture response header <name> len <max length>
-
-Note: Header names are not case-sensitive.
-
-Examples:
----------
-    # keep the name of the virtual server
-    capture request  header Host len 20
-    # keep the amount of data uploaded during a POST
-    capture request  header Content-Length len 10
-
-    # note the expected cache behaviour on the response
-    capture response header Cache-Control len 8
-    # note the URL location during a redirection
-    capture response header Location len 20
-
-Non-existant headers are logged as empty strings, and if one header appears more
-than once, only its last occurence will be kept. Request headers are grouped
-within braces '{' and '}' in the same order as they were declared, and delimited
-with a vertical bar '|' without any space. Response headers follow the same
-representation, but are displayed after a space following the request headers
-block. These blocks are displayed just before the HTTP request in the logs.
-
-Example :
-
-  Config:
-
-    capture request  header Host len 20
-    capture request  header Content-Length len 10
-    capture request  header Referer len 20
-    capture response header Server len 20
-    capture response header Content-Length len 10
-    capture response header Cache-Control len 8
-    capture response header Via len 20
-    capture response header Location len 20
-
-  Log :
-
-    Aug  9 20:26:09 localhost haproxy[2022]: 127.0.0.1:34014 [09/Aug/2004:20:26:09] relais-http netcache 0/0/0/162/+162 200 +350 - - ---- 0/0/0 0/0 {fr.adserver.yahoo.co||http://fr.f416.mail.} {|864|private||} "GET http://fr.adserver.yahoo.com/"
-    Aug  9 20:30:46 localhost haproxy[2022]: 127.0.0.1:34020 [09/Aug/2004:20:30:46] relais-http netcache 0/0/0/182/+182 200 +279 - - ---- 0/0/0 0/0 {w.ods.org||} {Formilux/0.1.8|3495|||} "GET http://w.ods.org/sytadin.html HTTP/1.1" 
-    Aug  9 20:30:46 localhost haproxy[2022]: 127.0.0.1:34028 [09/Aug/2004:20:30:46] relais-http netcache 0/0/2/126/+128 200 +223 - - ---- 0/0/0 0/0 {www.infotrafic.com||http://w.ods.org/syt} {Apache/2.0.40 (Red H|9068|||} "GET http://www.infotrafic.com/images/live/cartesidf/grandes/idf_ne.png HTTP/1.1" 
-
-
-4.2.7) Examples of logs
------------------------
-- haproxy[674]: 127.0.0.1:33319 [15/Oct/2003:08:31:57] relais-http Srv1 6559/0/7/147/6723 200 243 - - ---- 1/3/5 0/0 "HEAD / HTTP/1.0"
-  => long request (6.5s) entered by hand through 'telnet'. The server replied
-     in 147 ms, and the session ended normally ('----')
-
-- haproxy[674]: 127.0.0.1:33319 [15/Oct/2003:08:31:57] relais-http Srv1 6559/1230/7/147/6870 200 243 - - ---- 99/239/324 0/9 "HEAD / HTTP/1.0"
-  => Idem, but the request was queued in the global queue behind 9 other
-     requests, and waited there for 1230 ms.
-
-- haproxy[674]: 127.0.0.1:33320 [15/Oct/2003:08:32:17] relais-http Srv1 9/0/7/14/+30 200 +243 - - ---- 1/3/3 0/0 "GET /image.iso HTTP/1.0"
-  => request for a long data transfer. The 'logasap' option was specified, so
-     the log was produced just before transfering data. The server replied in
-     14 ms, 243 bytes of headers were sent to the client, and total time from
-     accept to first data byte is 30 ms.
-
-- haproxy[674]: 127.0.0.1:33320 [15/Oct/2003:08:32:17] relais-http Srv1 9/0/7/14/30 502 243 - - PH-- 0/2/3 0/0 "GET /cgi-bin/bug.cgi? HTTP/1.0"
-  => the proxy blocked a server response either because of an 'rspdeny' or
-     'rspideny' filter, or because it blocked sensible information which risked
-     being cached. In this case, the response is replaced with a '502 bad
-     gateway'.
-
-- haproxy[18113]: 127.0.0.1:34548 [15/Oct/2003:15:18:55] relais-http <NOSRV> -1/-1/-1/-1/8490 -1 0 - - CR-- 0/2/2 0/0 "" 
-  => the client never completed its request and aborted itself ('C---') after
-     8.5s, while the proxy was waiting for the request headers ('-R--').
-     Nothing was sent to the server.
-
-- haproxy[18113]: 127.0.0.1:34549 [15/Oct/2003:15:19:06] relais-http <NOSRV> -1/-1/-1/-1/50001 408 0 - - cR-- 2/2 0/0 "" 
-  => The client never completed its request, which was aborted by the time-out
-     ('c---') after 50s, while the proxy was waiting for the request headers ('-R--').
-     Nothing was sent to the server, but the proxy could send a 408 return code
-     to the client.
-
-- haproxy[18989]: 127.0.0.1:34550 [15/Oct/2003:15:24:28] relais-tcp Srv1 0/0/5007 0 cD 0/0/0 0/0
-  => This is a 'tcplog' entry. Client-side time-out ('c----') occured after 5s.
-
-- haproxy[18989]: 10.0.0.1:34552 [15/Oct/2003:15:26:31] relais-http Srv1 3183/-1/-1/-1/11215 503 0 - - SC-- 115/202/205 0/0 "HEAD / HTTP/1.0" 
-  => The request took 3s to complete (probably a network problem), and the
-     connection to the server failed ('SC--') after 4 attemps of 2 seconds
-     (config says 'retries 3'), then a 503 error code was sent to the client.
-     There were 115 connections on this server, 202 connections on this proxy,
-     and 205 on the global process. It is possible that the server refused the
-     connection because of too many already established.
-
-
-4.3) HTTP header manipulation
------------------------------
-In HTTP mode, it is possible to rewrite, add or delete some of the request and
-response headers based on regular expressions. It is also possible to block a
-request or a response if a particular header matches a regular expression,
-which is enough to stops most elementary protocol attacks, and to protect
-against information leak from the internal network. But there is a limitation
-to this : since haproxy's HTTP engine knows nothing about keep-alive, only
-headers passed during the first request of a TCP session will be seen. All
-subsequent headers will be considered data only and not analyzed. Furthermore,
-haproxy doesn't touch data contents, it stops at the end of headers.
-
-The syntax is :
-   reqadd    <string>             to add a header to the request
-   reqrep    <search> <replace>   to modify the request
-   reqirep   <search> <replace>   same, but ignoring the case
-   reqdel    <search>             to delete a header in the request
-   reqidel   <search>             same, but ignoring the case
-   reqallow  <search>             definitely allow a request if a header matches <search>
-   reqiallow <search>             same, but ignoring the case
-   reqdeny   <search>             denies a request if a header matches <search>
-   reqideny  <search>             same, but ignoring the case
-   reqpass   <search>             ignore a header matching <search>
-   reqipass  <search>             same, but ignoring the case
-   reqtarpit <search>             tarpit a request matching <search>
-   reqitarpit <search>            same, but ignoring the case
-
-   rspadd   <string>              to add a header to the response
-   rsprep   <search> <replace>    to modify the response
-   rspirep  <search> <replace>    same, but ignoring the case
-   rspdel   <search>              to delete the response
-   rspidel  <search>              same, but ignoring the case
-   rspdeny  <search>              replaces a response with a HTTP 502 if a header matches <search>
-   rspideny <search>              same, but ignoring the case
-
-
-<search> is a POSIX regular expression (regex) which supports grouping through
-parenthesis (without the backslash). Spaces and other delimiters must be
-prefixed with a backslash ('\') to avoid confusion with a field delimiter.
-Other characters may be prefixed with a backslash to change their meaning :
-
-  \t   for a tab
-  \r   for a carriage return (CR)
-  \n   for a new line (LF)
-  \    to mark a space and differentiate it from a delimiter
-  \#   to mark a sharp and differentiate it from a comment
-  \\   to use a backslash in a regex
-  \\\\ to use a backslash in the text (*2 for regex, *2 for haproxy)
-  \xXX to write the ASCII hex code XX as in the C language
-
-
-<replace> contains the string to be used to replace the largest portion of text
-matching the regex. It can make use of the special characters above, and can
-reference a substring delimited by parenthesis in the regex, by the group
-numerical order from 0 to 9 (0 being the entire line). In this case, you would
-write a backslash ('\') immediately followed by one digit indicating the group
-position.
-
-<string> represents the string which will systematically be added after the last
-header line. It can also use special characters above.
-
-Notes :
--------
-  - the first line is considered as a header, which makes it possible to rewrite
-    or filter HTTP requests URIs or response codes.
-  - 'reqrep' is the equivalent of 'cliexp' in version 1.0, and 'rsprep' is the
-    equivalent of 'srvexp' in 1.0. Those names are still supported but
-    deprecated.
-  - for performances reasons, the number of characters added to a request or to
-    a response is limited to 4096 since version 1.1.5 (it was 256 before). This
-    value is easy to modify in the code if needed (#define). If it is too short
-    on occasional uses, it is possible to gain some space by removing some
-    useless headers before adding new ones.
-  - a denied request will generate an "HTTP 403 forbidden" response, while a
-    denied response will generate an "HTTP 502 Bad gateway" response.
-  - a tarpitted request will be held open on the client side for a duration
-    defined in the contimeout parameter, or untill the client aborts. Nothing
-    will be sent to any server. When the timeout is reached, the proxy will
-    reply with a 500 server error response so that the attacker does not
-    suspect it has been tarpitted. The logs may report the 500, but the
-    termination flags will indicate 'PT' in this case.
-
-
-Examples :
-----------
-        ###### a few examples ######
-
-        # rewrite 'online.fr' instead of 'free.fr' for GET and POST requests
-        reqrep        ^(GET\ .*)(.free.fr)(.*) \1.online.fr\3
-        reqrep        ^(POST\ .*)(.free.fr)(.*) \1.online.fr\3
-
-        # force proxy connections to close
-        reqirep       ^Proxy-Connection:.*   Proxy-Connection:\ close
-        # rewrite locations
-        rspirep       ^(Location:\ )([^:]*://[^/]*)(.*) \1\3
-
-        ###### A full configuration being used on production ######
-
-        # Every header should end with a colon followed by one space.
-        reqideny      ^[^:\ ]*[\ ]*$
-
-        # block Apache chunk exploit
-        reqideny      ^Transfer-Encoding:[\ ]*chunked
-        reqideny      ^Host:\ apache-
-
-        # block annoying worms that fill the logs...
-        reqideny      ^[^:\ ]*\ .*(\.|%2e)(\.|%2e)(%2f|%5c|/|\\\\)
-        reqideny      ^[^:\ ]*\ ([^\ ]*\ [^\ ]*\ |.*%00)
-        reqideny      ^[^:\ ]*\ .*<script
-        reqideny      ^[^:\ ]*\ .*/(root\.exe\?|cmd\.exe\?|default\.ida\?)
-
-	# tarpit attacks on the login page.
-        reqtarpit     ^[^:\ ]*\ .*\.php?login=[^0-9]
-
-        # allow other syntactically valid requests, and block any other method
-        reqipass      ^(GET|POST|HEAD|OPTIONS)\ /.*\ HTTP/1\.[01]$
-        reqipass      ^OPTIONS\ \\*\ HTTP/1\.[01]$
-        reqideny      ^[^:\ ]*\ 
-
-        # force connection:close, thus disabling HTTP keep-alive
-        option        httpclose
-
-        # change the server name
-        rspidel       ^Server:\ 
-        rspadd        Server:\ Formilux/0.1.8
-
-
-Also, the 'forwardfor' option creates an HTTP 'X-Forwarded-For' header which
-contains the client's IP address. This is useful to let the final web server
-know what the client address was (eg for statistics on domains). Starting with
-version 1.3.8, it is possible to specify the "except" keyword followed by a
-source IP address or network for which no header will be added. This is very
-useful when another reverse-proxy which already adds the header runs on the
-same machine or in a known DMZ, the most common case being the local use of
-stunnel on the same system.
-
-Last, the 'httpclose' option removes any 'Connection' header both ways, and
-adds a 'Connection: close' header in each direction. This makes it easier to
-disable HTTP keep-alive than the previous 4-rules block.
-
-Example :
----------
-    listen http_proxy 0.0.0.0:80
-        mode http
-        log  global
-        option httplog
-        option dontlognull
-        option forwardfor except 127.0.0.1/8
-        option httpclose
-
-Note that some HTTP servers do not necessarily close the connections when they
-receive the 'Connection: close', and if the client does not close either, then
-the connection will be maintained up to the time-out. This translates into high
-number of simultaneous sessions and high global session times in the logs. To
-workaround this, a new option 'forceclose' appeared in version 1.2.9 to enforce
-the closing of the outgoing server channel as soon as the server begins to
-reply and only if the request buffer is empty. Note that this should NOT be
-used if CONNECT requests are expected between the client and the server. The
-'forceclose' option implies the 'httpclose' option.
-
-Example :
----------
-    listen http_proxy 0.0.0.0:80
-        mode http
-        log  global
-        option httplog
-        option dontlognull
-        option forwardfor
-        option forceclose
-
-
-4.4) Load balancing with persistence
-------------------------------------
-Combining cookie insertion with internal load balancing allows to transparently
-bring persistence to applications. The principle is quite simple :
-  - assign a cookie value to each server
-  - enable the load balancing between servers
-  - insert a cookie into responses resulting from the balancing algorithm
-    (indirect accesses), end ensure that no upstream proxy will cache it.
-  - remove the cookie in the request headers so that the application never sees
-    it.
-
-Example :
----------
-    listen application 0.0.0.0:80
-        mode http
-        cookie SERVERID insert nocache indirect
-        balance roundrobin
-        server srv1 192.168.1.1:80 cookie server01 check
-        server srv2 192.168.1.2:80 cookie server02 check
-
-The other solution brought by versions 1.1.30 and 1.2.3 is to reuse a cookie
-from the server, and prefix the server's name to it. In this case, don't forget
-to force "httpclose" mode so that you can be assured that every subsequent
-request will have its cookie fixed.
-
-    listen application 0.0.0.0:80
-        mode http
-        cookie JSESSIONID prefix
-        balance roundrobin
-        server srv1 192.168.1.1:80 cookie srv1 check
-        server srv2 192.168.1.2:80 cookie srv2 check
-        option httpclose
-
-
-4.5) Protection against information leak from the servers
----------------------------------------------------------
-In versions 1.1.28/1.2.1, a new option 'checkcache' was created. It carefully
-checks 'Cache-control', 'Pragma' and 'Set-cookie' headers in server response
-to check if there's a risk of caching a cookie on a client-side proxy. When this
-option is enabled, the only responses which can be delivered to the client are :
-  - all those without 'Set-Cookie' header ;
-  - all those with a return code other than 200, 203, 206, 300, 301, 410,
-    provided that the server has not set a 'Cache-control: public' header ;
-  - all those that come from a POST request, provided that the server has not
-    set a 'Cache-Control: public' header ;
-  - those with a 'Pragma: no-cache' header
-  - those with a 'Cache-control: private' header
-  - those with a 'Cache-control: no-store' header
-  - those with a 'Cache-control: max-age=0' header
-  - those with a 'Cache-control: s-maxage=0' header
-  - those with a 'Cache-control: no-cache' header
-  - those with a 'Cache-control: no-cache="set-cookie"' header
-  - those with a 'Cache-control: no-cache="set-cookie,' header
-    (allowing other fields after set-cookie)
-
-If a response doesn't respect these requirements, then it will be blocked just
-as if it was from an 'rspdeny' filter, with an "HTTP 502 bad gateway". The
-session state shows "PH--" meaning that the proxy blocked the response during
-headers processing. Additionnaly, an alert will be sent in the logs so that
-admins are told that there's something to be done.
-
-
-4.6) Customizing errors
------------------------
-Some situations can make haproxy return an HTTP error code to the client :
-  - invalid or too long request => HTTP 400
-  - request not completely sent in time => HTTP 408
-  - forbidden request (matches a deny filter) => HTTP 403
-  - internal error in haproxy => HTTP 500
-  - the server returned an invalid or incomplete response => HTTP 502
-  - no server was available to handle the request => HTTP 503
-  - the server failed to reply in time => HTTP 504
-
-A succint error message taken from the RFC accompanies these return codes.
-But depending on the clients knowledge, it may be better to return custom, user
-friendly, error pages. This is made possible in two ways, one involving a
-redirection to a known server, and another one consisting in returning a local
-file.
-
-4.6.1) Relocation
------------------
-An error relocation is achieved using the 'errorloc' command :
-
-    errorloc <HTTP_code> <location>
-
-Instead of generating an HTTP error <HTTP_code> among those above, the proxy
-will return a temporary redirection code (HTTP 302) towards the address
-specified in <location>. This address may be either relative to the site or
-absolute. Since this request will be handled by the client's browser, it's
-mandatory that the returned address be reachable from the outside.
-
-Example :
----------
-    listen application 0.0.0.0:80
-        errorloc 400 /badrequest.html
-        errorloc 403 /forbidden.html
-        errorloc 408 /toolong.html
-        errorloc 500 http://haproxy.domain.net/bugreport.html
-        errorloc 502 http://192.168.114.58/error50x.html
-        errorloc 503 http://192.168.114.58/error50x.html
-        errorloc 504 http://192.168.114.58/error50x.html
-
-Note: RFC2616 says that a client must reuse the same method to fetch the
-Location returned by a 302, which causes problems with the POST method.
-The return code 303 was designed explicitly to force the client to fetch the
-Location URL with the GET method, but there are some browsers pre-dating
-HTTP/1.1 which don't support it. Anyway, most browsers still behave with 302 as
-if it was a 303. In order to allow the user to chose, versions 1.1.31 and 1.2.5
-bring two new keywords to replace 'errorloc' : 'errorloc302' and 'errorloc303'.
-
-They are preffered over errorloc (which still does 302). Consider using
-errorloc303 everytime you know that your clients support HTTP 303 responses..
-
-4.6.2) Local files
-------------------
-Sometimes, it is desirable to change the returned error without resorting to
-redirections. The second method consists in loading local files during startup
-and send them as pure HTTP content upon error. This is what the 'errorfile'
-keyword does.
-
-Warning, there are traps to consider :
- - The files are loaded while parsing configuration, before doing a chroot().
-   Thus, they are relative to the real filesystem. For this reason, it is
-   recommended to pass an absolute path to those files.
-
- - The contents of those files is not HTML, but real HTTP protocol with
-   possible HTML body. So the first line and headers are mandatory. Ideally,
-   every line in the HTTP part should end with CR-LF for maximum compatibility.
-
- - The response is limited to the buffer size (BUSIZE), generally 8 or 16 kB.
-
- - The response should not include references to the local server, in order to
-   avoid infinite loops on the browser in case of local failure.
-
-Example :
----------
-        errorfile 400 /etc/haproxy/errorfiles/400badreq.http
-        errorfile 403 /etc/haproxy/errorfiles/403forbid.http
-        errorfile 503 /etc/haproxy/errorfiles/503sorry.http
-
-
-4.7) Modifying default values
------------------------------
-Version 1.1.22 introduced the notion of default values, which eliminates the
-pain of often repeating common parameters between many instances, such as
-logs, timeouts, modes, etc...
-
-Default values are set in a 'defaults' section. Each of these section clears
-all previously set default parameters, so there may be as many default
-parameters as needed. Only the last one before a 'listen' section will be
-used for this section. The 'defaults' section uses the same syntax as the
-'listen' section, for the supported parameters. The 'defaults' keyword ignores
-everything on its command line, so that fake instance names can be specified
-there for better clarity.
-
-In version 1.1.28/1.2.1, only those parameters can be preset in the 'default'
-section :
-  - log (the first and second one)
-  - mode { tcp, http, health }
-  - balance { roundrobin }
-  - disabled (to disable every further instances)
-  - enabled (to enable every further instances, this is the default)
-  - contimeout, clitimeout, srvtimeout, grace, retries, maxconn
-  - option { redispatch, transparent, keepalive, forwardfor, logasap, httpclose,
-             checkcache, httplog, tcplog, dontlognull, persist, httpchk }
-  - redispatch, redisp, transparent, source { addr:port }
-  - cookie, capture
-  - errorloc
-
-As of 1.1.24, it is not possible to put certain parameters in a 'defaults'
-section, mainly regular expressions and server configurations :
-  - dispatch, server,
-  - req*, rsp*
-
-Last, there's no way yet to change a boolean option from its assigned default
-value. So if an 'option' statement is set in a 'defaults' section, the only
-way to flush it is to redefine a new 'defaults' section without this 'option'.
-
-Examples :
-----------
-    defaults applications TCP
-        log global
-        mode tcp
-        balance roundrobin
-        clitimeout 180000
-        srvtimeout 180000
-        contimeout 4000
-        retries 3
-        redispatch
-
-    listen app_tcp1 10.0.0.1:6000-6063
-        server srv1 192.168.1.1 check port 6000 inter 10000
-        server srv2 192.168.1.2 backup
-
-    listen app_tcp2 10.0.0.2:6000-6063
-        server srv1 192.168.2.1 check port 6000 inter 10000
-        server srv2 192.168.2.2 backup
-    
-    defaults applications HTTP
-        log global
-        mode http
-        option httplog
-        option forwardfor
-        option dontlognull
-        balance roundrobin
-        clitimeout 20000
-        srvtimeout 20000
-        contimeout 4000
-        retries 3
-
-    listen app_http1 10.0.0.1:80-81
-        cookie SERVERID postonly insert indirect
-        capture cookie userid= len 10
-        server srv1 192.168.1.1:+8000 cookie srv1 check port 8080 inter 1000
-        server srv1 192.168.1.2:+8000 cookie srv2 check port 8080 inter 1000
-
-    defaults
-        # this empty section voids all default parameters
-
-
-4.8) Status report in HTML page
--------------------------------
-Starting with 1.2.14, it is possible for HAProxy to intercept requests for a
-particular URI and return a full report of the proxy's activity and servers
-statistics. This is available through the 'stats' keyword, associated to any
-such options :
-
-   - stats enable
-   - stats uri <uri prefix>
-   - stats realm <authentication realm>
-   - stats auth <user:password>
-   - stats scope <proxy_id> | '.'
-
-By default, the status report is disabled. Specifying any combination above
-enables it for the proxy instance referencing it. The easiest solution is to
-use "stats enable" which will enable the report with default parameters :
-
-   - default URI   : "/haproxy?stats"        (CONFIG_STATS_DEFAULT_URI)
-   - default auth  : unspecified (no authentication)
-   - default realm : "HAProxy Statistics"    (CONFIG_STATS_DEFAULT_REALM)
-   - default scope : unspecified (access to all instances)
-
-The "stats uri <uri_prefix>" option allows one to intercept another URI prefix.
-Note that any URI that BEGINS with this string will match. For instance, one
-proxy instance might be dedicated to status page only and would reply to any
-URI.
-
-Example :
----------
-    # catches any URI and returns the status page.
-    listen stats :8080
-        mode http
-        stats uri /
-
-The "stats auth <user:password>" option enables Basic authentication and adds a
-valid user:password combination to the list of authorized accounts. The user
-and password are passed in the configuration file as clear text, and since this
-is HTTP Basic authentication, you should be aware that it transits as clear
-text on the network, so you must not use any sensible account. The list is
-unlimited in order to provide easy accesses to developpers or customers.
-
-The "stats realm <realm>" option defines the "realm" name which is displayed
-in the popup box when the browser asks for a password. It's important to ensure
-that this one is not used by the application, otherwise the browser will try to
-use a cached one from the application. Note that any space in the realm name
-should be escaped with a backslash ('\').
-
-The "stats scope <proxy_id>" option limits the scope of the status report. By
-default, all proxy instances are listed. But under some circumstances, it would
-be better to limit the listing to some proxies or only to the current one. This
-is what this option does. The special proxy name "." (a single dot) references
-the current proxy. The proxy name can be repeated multiple times, even for
-proxies defined later in the configuration or some which do not exist. The name
-is the one which appears after the 'listen' keyword.
-
-Example :
----------
-    # simple application with authenticated embedded status report
-    listen app1 192.168.1.100:80
-        mode http
-        option httpclose
-        balance roundrobin
-        cookie SERVERID postonly insert indirect
-        server srv1 192.168.1.1:8080 cookie srv1 check inter 1000
-        server srv1 192.168.1.2:8080 cookie srv2 check inter 1000
-        stats uri /my_stats
-        stats realm Statistics\ for\ MyApp1-2
-        stats auth guest:guest
-        stats auth admin:AdMiN123
-        stats scope .
-        stats scope app2
-
-    # simple application with anonymous embedded status report
-    listen app2 192.168.2.100:80
-        mode http
-        option httpclose
-        balance roundrobin
-        cookie SERVERID postonly insert indirect
-        server srv1 192.168.2.1:8080 cookie srv1 check inter 1000
-        server srv1 192.168.2.2:8080 cookie srv2 check inter 1000
-        stats uri /my_stats
-        stats realm Statistics\ for\ MyApp2
-        stats scope .
-
-    listen admin_page :8080
-        mode http
-        stats uri /my_stats
-        stats realm Global\ statistics
-        stats auth admin:AdMiN123
-
-Notes :
--------
-  - The 'stats' options can also be specified in the 'defaults' section, in
-    which case it will provide the exact same configuration to all further
-    instances (hence the usefulness of the scope "."). However, if an instance
-    redefines any 'stats' parameter, defaults will not be used for this
-    instance.
-
-  - HTTP Basic authentication is very basic and unsecure from snooping. No
-    sensible password should be used, and be aware that there is no way to
-    remove it from the browser so it will be sent to the whole application
-    upon further accesses.
-
-  - It is very important that the 'option httpclose' is specified, otherwise
-    the proxy will not be able to detect the URI within keep-alive sessions
-    maintained between the browser and the servers, so the stats URI will be
-    forwarded unmodified to the server as if the option was not set.
-
-
-5) Access lists
-===============
-
-With version 1.3.10, a new concept of access lists (acl) was born. As it was
-not necesary to reinvent the wheel, and because even long thoughts lead to
-unsatisfying proposals, it was finally decided that something close to what
-Squid provides would be a good compromise between features and ease of use.
-
-The principle is very simple : acls are declared with a name, a test and a list
-of valid values to check against during the test. Conditions are applied on
-various actions, and those conditions apply a logical AND between acls. The
-condition is then only met if all acls are true.
-
-It is possible to use the reserved keyword "OR" in conditions, and it is
-possible for an acl to be specified multiple times, even with various tests, in
-which case the first one which returns true validates the ACL.
-
-As of 1.3.12, only the following tests have been implemented :
-
-   Layer 3/4 :
-     src       <ipv4_address>[/mask] ... : match IPv4 source address
-     dst       <ipv4_address>[/mask] ... : match IPv4 destination address
-     src_port  <range> ...               : match source port range
-     dst_port  <range> ...               : match destination port range
-     dst_conn  <range> ...               : match #connections on frontend
-
-   Layer 7 :
-     method    <HTTP method> ...  : match HTTP method
-     req_ver   <1.0|1.1> ...      : match HTTP request version
-     resp_ver  <1.0|1.1> ...      : match HTTP response version
-     status    <range> ...        : match HTTP response status code in range
-     url       <string> ... : exact string match on URI
-     url_reg   <regex>  ... : regex string match on URI
-     url_beg   <string> ... : true if URI begins with <string>
-     url_end   <string> ... : true if URI ends with <string>
-     url_sub   <string> ... : true if URI contains <string>
-     url_dir   <string> ... : true if URI contains <string> between slashes
-     url_dom   <string> ... : true if URI contains <string> between slashes or dots
-
-A 'range' is one or two integers which may be prefixed by an operator.
-The syntax is :
-
-  [<op>] <low>[:<high>]
-
-Where <op> can be :
-  'eq' : the tested value must be equal to <low> or within <low>..<high>
-  'le' : the tested value must be lower than or equal to <low>
-  'lt' : the tested value must be lower than <low>
-  'ge' : the tested value must be greater than or equal to <low>
-  'gt' : the tested value must be greater than <low>
-
-When no operator is defined, 'eq' is assumed. Note that when the operator is
-specified, it applies to all subsequent ranges of values until the end of the
-line is reached or another operator is specified. Example :
-
-  acl status_error  status   400:599
-  acl saturated_frt dst_conn ge 1000
-  acl invalid_ports src_port lt 512 ge 65535
-
-Other ones are coming (headers, cookies, time, auth), it's just a matter of
-time. It is also planned to be able to read the patterns from a file, as well
-as to ignore the case for some of them.
-
-The only command supporting a condition right now is the "block" command, which
-blocks a request and returns a 403 if its condition is true (with the "if"
-keyword), or if it is false (with the "unless" keyword).
-
-Example :
----------
-
-    acl options_uris  url *
-    acl meth_option   method OPTIONS
-    acl http_1.1      req_ver 1.1
-    acl allowed_meth  method GET HEAD POST OPTIONS CONNECT
-    acl connect_meth  method CONNECT
-    acl proxy_url     url_beg http://
-
-    # block if reserved URI "*" used with a method other than "OPTIONS"
-    block if options_uris !meth_option
-
-    # block if the OPTIONS method is used with HTTP 1.0
-    block if meth_option !http_1.1
-
-    # allow non-proxy url with anything but the CONNECT method
-    block if !connect_meth !proxy_url
-
-    # block all unknown methods
-    block unless allowed_meth
-
-Note: this documentation is very light but should permit one to start and above
-all it should permit to work on the project without being slowed down too much
-with the doc.
-
-
-=========================
-| System-specific setup |
-=========================
-
-Linux 2.4
-=========
-
--- cut here --
-#!/bin/sh
-# set this to about 256/4M (16384 for 256M machine)
-MAXFILES=16384
-echo $MAXFILES > /proc/sys/fs/file-max
-ulimit -n $MAXFILES
-
-if [ -e /proc/sys/net/ipv4/ip_conntrack_max ]; then
-        echo 65536 > /proc/sys/net/ipv4/ip_conntrack_max
-fi
-
-if [ -e /proc/sys/net/ipv4/netfilter/ip_ct_tcp_timeout_fin_wait ]; then
-        # 30 seconds for fin, 15 for time wait
-        echo 3000 > /proc/sys/net/ipv4/netfilter/ip_ct_tcp_timeout_fin_wait
-        echo 1500 > /proc/sys/net/ipv4/netfilter/ip_ct_tcp_timeout_time_wait
-        echo 0 > /proc/sys/net/ipv4/netfilter/ip_ct_tcp_log_invalid_scale
-        echo 0 > /proc/sys/net/ipv4/netfilter/ip_ct_tcp_log_out_of_window
-fi
-
-echo 1024 60999 > /proc/sys/net/ipv4/ip_local_port_range
-echo 30 > /proc/sys/net/ipv4/tcp_fin_timeout
-echo 4096 > /proc/sys/net/ipv4/tcp_max_syn_backlog
-echo 262144 > /proc/sys/net/ipv4/tcp_max_tw_buckets
-echo 262144 > /proc/sys/net/ipv4/tcp_max_orphans
-echo 300 > /proc/sys/net/ipv4/tcp_keepalive_time
-echo 1 > /proc/sys/net/ipv4/tcp_tw_recycle
-echo 0 > /proc/sys/net/ipv4/tcp_timestamps
-echo 0 > /proc/sys/net/ipv4/tcp_ecn
-echo 1 > /proc/sys/net/ipv4/tcp_sack
-echo 0 > /proc/sys/net/ipv4/tcp_dsack
-
-# auto-tuned on 2.4
-#echo 262143 > /proc/sys/net/core/rmem_max
-#echo 262143 > /proc/sys/net/core/rmem_default
-
-echo 16384 65536 524288 > /proc/sys/net/ipv4/tcp_rmem
-echo 16384 349520 699040 > /proc/sys/net/ipv4/tcp_wmem
-
--- cut here --
-
-
-FreeBSD
-=======
-
-A FreeBSD port of HA-Proxy is now available and maintained, thanks to
-Clement Laforet <sheepkiller@cultdeadsheep.org>.
-
-For more information :
-http://www.freebsd.org/cgi/url.cgi?ports/net/haproxy/pkg-descr
-http://www.freebsd.org/cgi/cvsweb.cgi/ports/net/haproxy/
-http://www.freshports.org/net/haproxy
-
-
--- end --
diff --git a/deps/haproxy-1.4.21/doc/haproxy-fr.txt b/deps/haproxy-1.4.21/doc/haproxy-fr.txt
deleted file mode 100644
index 89df8cb..0000000
--- a/deps/haproxy-1.4.21/doc/haproxy-fr.txt
+++ /dev/null
@@ -1,2891 +0,0 @@
-                           -------------------
-                                 HAProxy
-                           Manuel de rfrence
-                           -------------------
-                              version 1.3.2
-                              willy tarreau
-                                2006/09/03
-
-
- !!!!  NOTE: CE DOCUMENT EST PERIME  !!!!
-
- Veuillez utiliser le fichier "configuration.txt" situ dans le mme
- rpertoire, ou tlcharger une version  jour  l'emplacement ci-dessous :
-
-        http://haproxy.1wt.eu/download/1.4/doc/configuration.txt
-
-
-================
-| Introduction |
-================
-
-HAProxy est un relais TCP/HTTP offrant des facilits d'intgration en
-environnement hautement disponible. En effet, il est capable de :
-  - effectuer un aiguillage statique dfini par des cookies ;
-  - effectuer une rpartition de charge avec cration de cookies pour assurer
-    la persistence de session ; 
-  - fournir une visibilit externe de son tat de sant ;
-  - s'arrter en douceur sans perte brutale de service ;
-  - modifier/ajouter/supprimer des en-ttes dans la requte et la rponse ;
-  - interdire des requtes qui vrifient certaines conditions ;
-  - utiliser des serveurs de secours lorsque les serveurs principaux sont hors
-    d'usage.
-  - maintenir des clients sur le bon serveur serveur d'application en fonction
-    de cookies applicatifs.
-  - fournir des rapports d'tat en HTML  des utilisateurs authentifis, 
-    travers des URI de l'application interceptes.
-
-Il requiert peu de ressources, et son architecture vnementielle mono-
-processus lui permet facilement de grer plusieurs milliers de connexions
-simultanes sur plusieurs relais sans effondrer le systme.
-
-
-===========================
-| Paramtres de lancement |
-===========================
-
-Les options de lancement sont peu nombreuses :
-
-    -f <fichier de configuration>
-    -n <nombre maximal total de connexions simultanes>
-       = 'maxconn' dans la section 'global'
-    -N <nombre maximal de connexions simultanes par instance>
-       = 'maxconn' dans les sections 'listen' ou 'default'
-    -d active le mode debug
-    -D passe en daemon
-    -q dsactive l'affichage de messages sur la sortie standard.
-    -V affiche les messages sur la sortie standard, mme si -q ou 'quiet' sont
-       spcifis.
-    -c vrifie le fichier de configuration puis quitte avec un code de retour 0
-       si aucune erreur n'a t trouve, ou 1 si une erreur de syntaxe a t
-       dtecte.
-    -p <fichier> indique au processus pre qu'il doit crire les PIDs de ses
-       fils dans ce fichier en mode dmon.
-    -sf specifie une liste de PIDs auxquels envoyer un signal FINISH
-    -st specifie une liste de PIDs auxquels envoyer un signal TERMINATE
-    -s affiche les statistiques (si option compile)
-    -l ajoute des informations aux statistiques
-    -dk dsactive l'utilisation de kqueue()
-    -ds dsactive l'utilisation de epoll() speculatif
-    -de dsactive l'utilisation de epoll()
-    -dp dsactive l'utilisation de poll()
-    -db dsactive la mise en arrire-plan (utile pour dbugger)
-    -m <megs> applique une limitation de <megs> Mo d'utilisation mmoire
-
-Le nombre maximal de connexion simultanes par proxy est le paramtre par
-dfaut pour les proxies pour lesquels ce paramtre n'est pas prcis dans le
-fichier de configuration. Il s'agit du paramtre 'maxconn' dans les sections
-'listen'.
-
-Le nombre maximal total de connexions simultanes limite le nombre de
-connexions TCP utilisables  un instant donn par le processus, tous proxies
-confondus. Ce paramtre remplace le paramtre 'maxconn' de la section 'global'.
-
-Le mode debug correspond  l'option 'debug' de la section 'global'. Dans ce
-mode, toutes les connexions, dconnexions, et tous les changes d'en-ttes HTTP
-sont affichs.
-
-Pour debugger, l'option '-db' est trs pratique car elle dsactive
-temporairement le mode daemon et le mode multi-processus. Le service peut alors
-tre arrt par un simple appui sur Ctrl-C, sans avoir  modifier la
-configuration ni  activer le mode debug complet.
-
-Les statistiques ne sont disponibles que si le programme a t compil avec
-l'option "STATTIME". Il s'agit principalement de donnes brutes n'ayant
-d'utilit que lors de benchmarks par exemple, et sont amenes  disparaitre.
-
-Les paramtres '-st' et '-sf' sont utiliss pour la reconfiguration  chaud.
-Voir la section  ce sujet.
-
-============================
-| Fichier de configuration |
-============================
-
-Structure
-=========
-
-L'analyseur du fichier de configuration ignore des lignes vides, les espaces,
-les tabulations, et tout ce qui est compris entre le symbole '#' (s'il n'est
-pas prcd d'un '\'), et la fin de la ligne, ce qui constitue un commentaire.
-
-Le fichier de configuration est dcoup en sections rpres par des mots cls
-tels que :
-
-  - 'global'
-  - 'listen'
-  - 'defaults'
-
-Tous les paramtres font rfrence  la section dfinie par le dernier mot cl
-reconnu.
-
-
-1) Paramtres globaux
-=====================
-
-Il s'agit des paramtres agissant sur le processus, ou bien sur l'ensemble des
-proxies. Ils sont tous spcifis dans la section 'global'. Les paramtres
-supports sont :
-
-  - log <adresse> <catgorie> [niveau_max]
-  - maxconn <nombre>
-  - uid <identifiant>
-  - gid <identifiant>
-  - user <nom d'utilisateur>
-  - group <nom de groupe>
-  - chroot <rpertoire>
-  - nbproc <nombre>
-  - daemon
-  - debug
-  - nokqueue
-  - nosepoll
-  - noepoll
-  - nopoll
-  - quiet
-  - pidfile <fichier>
-  - ulimit-n <nombre>
-  - tune.maxpollevents <nombre>
-
-
-1.1) Journalisation des vnements
-----------------------------------
-La plupart des vnements sont journaliss : dmarrages, arrts, disparition et
-apparition de serveurs, connexions, erreurs. Tous les messages sont envoys en
-syslog vers un ou deux serveurs. La syntaxe est la suivante :
-
-    log <adresse_ip> <catgorie> [niveau_max]
-
-Les connexions sont envoyes en niveau "info". Les dmarrages de service et de
-serveurs seront envoys en "notice", les signaux d'arrts en "warning" et les
-arrts dfinitifs de services et de serveurs en "alert". Ceci est valable aussi
-bien pour les proxies que pour les serveurs tests par les proxies. Le
-paramtre optionnel <niveau_max> dfinit le niveau maximal de traces mises
-parmi les 8 valeurs suivantes  :
-    emerg, alert, crit, err, warning, notice, info, debug
-
-Par compatibilit avec les versions 1.1.16 et antrieures, la valeur par dfaut
-est "debug" si l'option n'est pas prcise.
-
-Les catgories possibles sont :
-    kern, user, mail, daemon, auth, syslog, lpr, news,
-    uucp, cron, auth2, ftp, ntp, audit, alert, cron2,
-    local0, local1, local2, local3, local4, local5, local6, local7
-
-Conformment  la RFC3164, les messages mis sont limits  1024 caractres.
-
-Exemple :
----------
-    global
-        log 192.168.2.200 local3
-        log 127.0.0.1     local4 notice
-
-1.2) limitation du nombre de connexions
----------------------------------------
-Il est possible et conseill de limiter le nombre global de connexions par
-processus  l'aide du mot cl global 'maxconn'. Les connexions sont comprises
-au sens 'acceptation de connexion', donc il faut s'attendre en rgle gnral 
-avoir un peu plus du double de sessions TCP que le maximum de connexions fix.
-C'est important pour fixer le paramtre 'ulimit -n' avant de lancer le proxy.
-Pour comptabiliser le nombre de sockets ncessaires, il faut prendre en compte
-ces paramtres :
-
-  - 1 socket par connexion entrante
-  - 1 socket par connexion sortante
-  - 1 socket par couple adresse/port d'coute par proxy
-  - 1 socket pour chaque serveur en cours de health-check
-  - 1 socket pour les logs (tous serveurs confondus)
-
-Dans le cas o chaque proxy n'coute que sur un couple adresse/port,
-positionner la limite du nombre de descripteurs de fichiers (ulimit -n)  
-(2 * maxconn + nbproxy + nbserveurs + 1). A partir des versions 1.1.32/1.2.6,
-il est possible de spcifier cette limite dans la configuration  l'aide du
-mot-cl global 'ulimit-n',  condition bien entendu que le proxy ait t
-dmarr sous le compte root (ou avec des droits suffisants pour lever le
-nombre de descripteurs de fichiers). Cette solution met un terme au problme
-rcurrent d'incertitude de l'adquation entre les limites systmes lors de la
-dernire relance du proxessus et les limites en nombre de connexions. Noter que
-cette limite s'applique par processus.
-
-Exemple :
----------
-    global
-        maxconn 32000
-        ulimit-n 65536
-
-
-1.3) Diminution des privilges
-------------------------------
-Afin de rduire les risques d'attaques dans le cas o une faille non identifie
-serait exploite, il est possible de diminuer les privilges du processus, et
-de l'isoler dans un rpertoire sans risque.
-
-Dans la section 'global', le paramtre 'uid' permet de spcifier un identifiant
-numrique d'utilisateur. La valeur 0, correspondant normalement au super-
-utilisateur, possde ici une signification particulire car elle indique que
-l'on ne souhaite pas changer cet identifiant et conserver la valeur courante.
-C'est la valeur par dfaut. De la mme manire, le paramtre 'gid' correspond 
-un identifiant de groupe, et utilise par dfaut la valeur 0 pour ne rien
-changer. Dans le cas o il ne serait pas possible de spcifier un identifiant
-numrique pour l'uid, il est possible de spcifier un nom d'utilisateur aprs
-le mot-cl 'user'. De la mme manire, il est possible de prciser un nom de
-groupe aprs le mot-cl 'group'.
-
-Il est particulirement dconseill d'utiliser des comptes gnriques tels que
-'nobody' car cette pratique revient  utiliser 'root' si d'autres processus
-utilisent les mmes identifiants.
-
-Le paramtre 'chroot' autorise  changer la racine du processus une fois le
-programme lanc, de sorte que ni le processus, ni l'un de ses descendants ne
-puissent remonter de nouveau  la racine. Ce type de cloisonnement (chroot) est
-gnralement contournable sur certains OS (Linux, Solaris) pour peu que
-l'attaquant possde des droits 'root' et soit en mesure d'utiliser ou de crer
-un rpertoire. Aussi, il est important d'utiliser un rpertoire spcifique au
-service pour cet usage, et de ne pas mutualiser un mme rpertoire pour
-plusieurs services de nature diffrente. Pour rendre l'isolement plus robuste,
-il est conseill d'utiliser un rpertoire vide, sans aucun droit, et de changer
-l'uid du processus de sorte qu'il ne puisse rien faire dans ledit rpertoire.
-
-Remarque importante :
----------------------
-Dans le cas o une telle faille serait mise en vidence, il est fort probable
-que les premires tentatives de son exploitation provoquent un arrt du
-programme,  cause d'un signal de type 'Segmentation Fault', 'Bus Error' ou
-encore 'Illegal Instruction'. Mme s'il est vrai que faire tourner le serveur
-en environnement limit rduit les risques d'intrusion, il est parfois bien
-utile dans ces circonstances de connatre les conditions d'apparition du
-problme, via l'obtention d'un fichier 'core'. La plupart des systmes, pour
-des raisons de scurit, dsactivent la gnration du fichier 'core' aprs un
-changement d'identifiant pour le processus. Il faudra donc soit lancer le
-processus  partir d'un compte utilisateur aux droits rduits (mais ne pouvant
-pas effectuer le chroot), ou bien le faire en root sans rduction des droits
-(uid 0). Dans ce cas, le fichier se trouvera soit dans le rpertoire de
-lancement, soit dans le rpertoire spcifi aprs l'option 'chroot'. Ne pas
-oublier la commande suivante pour autoriser la gnration du fichier avant de
-lancer le programme :
-
-# ulimit -c unlimited
-
-Exemple :
----------
-
-    # with uid/gid
-    global
-        uid        30000
-        gid        30000
-        chroot  /var/chroot/haproxy
-
-    # with user/group
-    global
-        user    haproxy
-        group   public
-        chroot  /var/chroot/haproxy
-
-
-1.4) Modes de fonctionnement
-----------------------------
-Le service peut fonctionner dans plusieurs modes :
-  - avant- / arrire-plan
-  - silencieux / normal / debug
-
-Le mode par dfaut est normal, avant-plan, c'est  dire que le programme ne
-rend pas la main une fois lanc. Il ne faut surtout pas le lancer comme ceci
-dans un script de dmarrage du systme, sinon le systme ne finirait pas son
-initialisation. Il faut le mettre en arrire-plan, de sorte qu'il rende la main
-au processus appelant. C'est ce que fait l'option 'daemon' de la section
-'global', et qui est l'quivalent du paramtre '-D' de la ligne de commande.
-
-Le paramtre de ligne de commande '-db' inhibe les options globales 'daemon'
-et 'nbproc' pour faire fonctionner le processus en mode normal, avant-plan.
-
-Par ailleurs, certains messages d'alerte sont toujours envoys sur la sortie
-standard, mme en mode 'daemon'. Pour ne plus les voir ailleurs que dans les
-logs, il suffit de passer en mode silencieux par l'ajout de l'option 'quiet'.
-Cette option n'a pas d'quivalent en ligne de commande.
-
-Enfin, le mode 'debug' permet de diagnostiquer les origines de certains
-problmes en affichant les connexions, dconnexions et changes d'en-ttes HTTP
-entre les clients et les serveurs. Ce mode est incompatible avec les options
-'daemon' et 'quiet' pour des raisons de bon sens.
-
-1.5) Accroissement de la capacit de traitement
------------------------------------------------
-Sur des machines multi-processeurs, il peut sembler gch de n'utiliser qu'un
-processeur pour effectuer les tches de relayage, mme si les charges
-ncessaires  saturer un processeur actuel sont bien au-del des ordres de
-grandeur couramment rencontrs. Cependant, pour des besoins particuliers, le
-programme sait dmarrer plusieurs processus se rpartissant la charge de
-travail. Ce nombre de processus est spcifi par le paramtre 'nbproc' de la
-section 'global'. Sa valeur par dfaut est naturellement 1. Ceci ne fonctionne
-qu'en mode 'daemon'. Un usage dj rencontr pour ce paramtre fut de dpasser
-la limite de nombre de descripteurs de fichiers alloue par processus sous
-Solaris.
-
-Exemple :
----------
-
-    global
-        daemon
-        quiet
-        nbproc        2
-
-1.6) Simplification de la gestion des processus
------------------------------------------------
-Haproxy supporte dornavant la notion de fichiers de pid (-> pidfiles). Si le
-paramtre '-p' de ligne de commande, ou l'option globale 'pidfile' sont suivis
-d'un nom de fichier, alors ce fichier sera supprim puis recr et contiendra
-le numro de PID des processus fils,  raison d'un par ligne (valable
-uniquement en mode dmon). Ce fichier n'est PAS relatif au cloisonnement chroot
-afin de rester compatible avec un rpertoire protg en lecture seule. Il
-appartiendra  l'utilisateur ayant lanc le processus, et disposera des droits
-0644.
-
-Exemple :
----------
-
-    global
-        daemon
-        quiet
-        nbproc 2
-        pidfile /var/run/haproxy-private.pid
-
-    # pour stopper seulement ces processus parmi d'autres :
-    # kill $(</var/run/haproxy-private.pid)
-
-    # pour recharger une configuration avec un impact minimal sur le service,
-    # et sans casser les sessions existantes :
-    # haproxy -f haproxy.cfg -p /var/run/haproxy-private.pid -sf $(</var/run/haproxy-private.pid)
-
-1.7) Mcanismes de traitements des vnements
----------------------------------------------
-A partir de la version 1.2.5, haproxy supporte les mcanismes poll() et
-epoll(). Sur les systems o select() est limit par FD_SETSIZE (comme Solaris),
-poll() peut tre une alternative intressante. Des tests de performance
-montrent que les performances de poll() ne dcroissent pas aussi vite que le
-nombre de sockets augmente, ce qui en fait une solution sre pour les fortes
-charges. Cela dit, Soalris utilise dj poll() pour muler select(), donc tant
-que le nombre de sockets ne dpasse pas FD_SETSIZE, poll() ne devrait pas
-apporter de performances supplmentaires. Sur les systmes  base Linux
-incluant le patch epoll() (ou tous les Linux 2.6), haproxy utilisera epoll()
-qui est extrmement rapide indpendamment du nombre de sockets. Les tests sur
-haproxy ont montr une performance constante de 1  40000 sessions simultanes.
-La version 1.3.9 a introduit le support de kqueue() pour FreeBSD/OpenBSD, ainsi
-qu'une variante appele "speculative epoll()" consistant  tenter d'effectuer
-les oprations d'entres/sorties avant de chaner les vnements par les appels
-systme.
-
-Afin d'optimiser la latence, il est dsormais possible de limiter le nombre
-d'vnements remonts  chaque appel. La limite par dfaut est fixe  200. Si
-une latence plus petite est recherche, il peut tre justifi d'abaisser cette
-limite par l'utilisation du paramtre 'tune.maxpollevents' dans la section
-'global'. L'augmenter permettra d'conomiser un peu le processeur en prsence
-de trs grands nombres de connexions simultanes.
-
-Haproxy utilisera kqueue() ou speculative epoll() lorsque ce sera disponible,
-puis epoll(), et se repliera sur poll(), puis en dernier lieu sur select().
-Cependant, si pour une raison quelconque il s'avrait ncessaire de dsactiver
-epoll() ou poll() (p.ex:  cause d'un bug ou juste pour comparer les
-performances), de nouvelles options globales ont t ajoutes dans ce but :
-'nosepoll', 'nokqueue', 'noepoll' et 'nopoll'.
-
-Exemple :
----------
-    global
-        # utiliser seulement select()
-        noepoll
-        nopoll
-        tune.maxpollevents 100
-
-Remarque :
-----------
-Dans le but d'assurer une portabilit maximale des configurations, ces options
-sont acceptes et ignores si les mcanismes poll() ou epoll() n'ont pas t
-activs lors de la compilation.
-
-Afin de simplifier la rsolution de problmes, le paramtre '-de' en ligne de
-commande dsactive epoll(), le paramtre '-dp' dsactive poll(), '-dk' kqueue()
-et '-ds' dsactive speculative epoll(). Ils sont respectivement quivalents 
-'noepoll', 'nopoll', 'nokqueue' et 'nosepoll'.
-
-
-2) Dfinition d'un service en coute
-====================================
-
-Les sections de service dbutent par le mot cl "listen" :
-
-    listen <nom_instance> [ <adresse_IP>:<plage_ports>[,...] ]
-
-- <nom_instance> est le nom de l'instance dcrite. Ce nom sera envoy dans les
-  logs, donc il est souhaitable d'utiliser un nom relatif au service relay.
-  Aucun test n'est effectu concernant l'unicit de ce nom, qui n'est pas
-  obligatoire, mais fortement recommande.
-
-- <adresse_IP> est l'adresse IP sur laquelle le relais attend ses connexions.
-  L'absence d'adresse ainsi que l'adresse 0.0.0.0 signifient que les connexions
-  pourront s'effectuer sur toutes les adresses de la machine.
-
-- <plage_ports> correspond soit  un port, soit  une plage de ports sur
-  lesquels le relais acceptera des connexions pour l'adresse IP spcifie.
-  Cette plage peut tre :
-    - soit un port numrique (ex: '80')
-    - soit une plage constitue de deux valeurs spares par un tiret
-      (ex: '2000-2100') reprsentant les extrmits incluses dans la
-      plage.
-  Il faut faire attention  l'usage des plages, car chaque combinaison
-  <adresse_IP>:<port> consomme une socket, donc un descripteur de fichier.
-  Le couple <adresse_IP>:<port> doit tre unique pour toutes les  instances
-  d'une mme machine. L'attachement  un port infrieur  1024 ncessite un
-  niveau de privilge particulier lors du lancement du programme
-  (indpendamment du paramtre 'uid' de la section 'global').
-
-- le couple <adresse_IP>:<plage_ports> peut tre rpt indfiniment pour
-  demander au relais d'couter galement sur d'autres adresses et/ou d'autres
-  plages de ports. Pour cela, il suffit de sparer les couples par une virgule.
-
-Exemples :
----------
-    listen http_proxy :80
-    listen x11_proxy 127.0.0.1:6000-6009
-    listen smtp_proxy 127.0.0.1:25,127.0.0.1:587
-    listen ldap_proxy :389,:663
-
-Si toutes les adresses ne tiennent pas sur une ligne, il est possible d'en
-rajouter  l'aide du mot cl 'bind'. Dans ce cas, il n'est mme pas ncessaire
-de spcifier la premire adresse sur la ligne listen, ce qui facilite parfois
-l'criture de configurations :
-
-    bind [ <adresse_IP>:<plage_ports>[,...] ]
-
-Exemples :
-----------
-    listen http_proxy
-        bind :80,:443
-        bind 10.0.0.1:10080,10.0.0.1:10443
-
-2.1) Inhibition d'un service
-----------------------------
-Un service peut tre dsactiv pour des besoins de maintenance, sans avoir 
-commenter toute une partie du fichier. Il suffit de positionner le mot cl
-"disabled" dans sa section :
-
-    listen smtp_proxy 0.0.0.0:25
-        disabled
-
-Remarque: le mot cl 'enabled' permet de ractiver un service pralablement
-          dsactiv par le mot cl 'disabled', par exemple  cause d'une
-          configuration par dfaut.
-
-2.2) Mode de fonctionnement
----------------------------
-Un service peut fonctionner dans trois modes diffrents :
-  - TCP
-  - HTTP
-  - tat de sant
-
-Mode TCP
---------
-Dans ce mode, le service relaye, ds leur tablissement, les connexions TCP
-vers un ou plusieurs serveurs. Aucun traitement n'est effectu sur le flux. Il
-s'agit simplement d'une association
-     source<adresse:port> -> destination<adresse:port>.
-Pour l'utiliser, prciser le mode TCP sous la dclaration du relais.
-
-Exemple :
----------
-    listen smtp_proxy 0.0.0.0:25
-        mode tcp
-
-Mode HTTP
----------
-Dans ce mode, le service relaye les connexions TCP vers un ou plusieurs
-serveurs, une fois qu'il dispose d'assez d'informations pour en prendre la
-dcision. Les en-ttes HTTP sont analyss pour y trouver un ventuel cookie, et
-certains d'entre-eux peuvent tre modifis par le biais d'expressions
-rgulires. Pour activer ce mode, prciser le mode HTTP sous la dclaration du
-relais.
-
-Exemple :
----------
-    listen http_proxy 0.0.0.0:80
-        mode http
-
-Mode supervision
-----------------
-Il s'agit d'un mode offrant  un composant externe une visibilit de l'tat de
-sant du service. Il se contente de retourner "OK"  tout client se connectant
-sur son port. Il peut tre utilis avec des rpartiteurs de charge volus pour
-dterminer quels sont les services utilisables. Si l'option 'httpchk' est
-active, alors la rponse changera en 'HTTP/1.0 200 OK' pour satisfaire les
-attentes de composants sachant tester en HTTP. Pour activer ce mode, prciser
-le mode HEALTH sous la dclaration du relais.
-
-Exemple :
----------
-    # rponse simple : 'OK'
-    listen health_check 0.0.0.0:60000
-        mode health
-
-    # rponse HTTP : 'HTTP/1.0 200 OK'
-    listen http_health_check 0.0.0.0:60001
-        mode health
-        option httpchk
-
-
-2.2.1 Supervision
------------------
-Les versions 1.1.32 et 1.2.6 apportent une nouvelle solution pour valider le
-bon fonctionnement du proxy sans perturber le service. Le mot-cl 'monitor-net'
-a t cr dans le butd de spcifier un rseau d'quipements qui ne PEUVENT PAS
-utiliser le service pour autre chose que des tests de fonctionnement. C'est
-particulirement adapt aux proxies TCP, car cela empche le proxy de relayer
-des tablissements de connexion mis par un outil de surveillance.
-
-Lorsque c'est utilis sur un proxy TCP, la connexion est accepte puis referme
-et rien n'est logu. C'est suffisant pour qu'un rpartiteur de charge en amont
-dtecte que le service est disponible.
-
-Lorsque c'est utilis sur un proxy HTTP, la connexion est accepte, rien n'est
-logu, puis la rponse suivante est envoye et la session referme :
-"HTTP/1.0 200 OK". C'est normalement suffisant pour qu'un rpartiteur de charge
-HTTP en amont dtecte le service comme oprationnel, aussi bien  travers des
-tests TCP que HTTP.
-
-Les proxies utilisant le mot-cl 'monitor-net' peuvent accessoirement se passer
-de l'option 'dontlognull', ce qui permettra de loguer les connexions vides
-mises depuis d'autres adresses que celles du rseau de tests.
-
-Exemple :
----------
-
-    listen tse-proxy
-       bind :3389,:1494,:5900  # TSE, ICA and VNC at once.
-       mode tcp
-       balance roundrobin
-       server tse-farm 192.168.1.10
-       monitor-net 192.168.1.252/31   # L4 load-balancers on .252 and .253
-
-
-Lorsque le systme effectuant les tests est situ derrire un proxy, le mot-cl
-'monitor-net' n'est pas utilisable du fait que haproxy verra toujours la mme
-adresse pour le proxy. Pour pallier  cette limitation, la version 1.2.15 a
-apport le mot-cl 'monitor-uri'. Il dfinit une URI qui ne sera ni retransmise
-ni loge, mais pour laquelle haproxy retournera immdiatement une rponse
-"HTTP/1.0 200 OK". Cela rend possibles les tests de validit d'une chane
-reverse-proxy->haproxy en une requte HTTP. Cela peut tre utilis pour valider
-une combinaision de stunnel+haproxy  l'aide de tests HTTPS par exemple. Bien
-entendu, ce mot-cl n'est valide qu'en mode HTTP, sinon il n'y a pas de notion
-d'URI. Noter que la mthode et la version HTTP sont simplement ignores.
-
-Exemple :
----------
-
-    listen stunnel_backend :8080
-       mode http
-       balance roundrobin
-       server web1 192.168.1.10:80 check
-       server web2 192.168.1.11:80 check
-       monitor-uri /haproxy_test
-
-
-2.3) Limitation du nombre de connexions simultanes
----------------------------------------------------
-Le paramtre "maxconn" permet de fixer la limite acceptable en nombre de
-connexions simultanes par proxy. Chaque proxy qui atteint cette valeur cesse
-d'couter jusqu' libration d'une connexion. Voir plus loin concernant les
-limitations lies au systme.
-
-Exemple :
----------
-    listen tiny_server 0.0.0.0:80
-        maxconn 10
-
-
-2.4) Arrt en douceur
----------------------
-Il est possible d'arrter les services en douceur en envoyant un signal
-SIGUSR1 au processus relais. Tous les services seront alors mis en phase
-d'arrt, mais pourront continuer d'accepter des connexions pendant un temps
-dfini par le paramtre 'grace' (en millisecondes). Cela permet par exemple,
-de faire savoir rapidement  un rpartiteur de charge qu'il ne doit plus
-utiliser un relais, tout en continuant d'assurer le service le temps qu'il
-s'en rende compte.
-
-Remarque :
-----------
-Les connexions actives ne sont jamais casses. Dans le pire des cas, il faudra
-attendre en plus leur expiration avant l'arrt total du processus, ou bien tuer
-manuellement le processus par l'envoi d'un signal SIGTERM. La valeur par dfaut
-du paramtre 'grace' est 0 (pas de grce, arrt immdiat de l'coute).
-
-Exemple :
----------
-    # arrter en douceur par 'killall -USR1 haproxy'
-    # le service tournera encore 10 secondes aprs la demande d'arrt
-    listen http_proxy 0.0.0.0:80
-        mode http
-        grace 10000
-
-    # ce port n'est test que par un rpartiteur de charge.
-    listen health_check 0.0.0.0:60000
-        mode health
-        grace 0
-
-A partir de la version 1.2.8, un nouveau mcanisme de reconfiguration  chaud
-a t introduit. Il est dsormais possible de mettre les proxies en "pause" en
-envoyant un signal SIGTTOU aux processus. Cela dsactivera les sockets d'coute
-sans casser les sessions existantes. Suite  cela, l'envoi d'un signal SIGTTIN
-ractivera les sockets d'coute. Ceci est trs pratique pour tenter de charger
-une nouvelle configuration ou mme une nouvelle version de haproxy sans casser
-les connexions existantes. Si le rechargement s'effectue correctement, il ne
-reste plus qu' envoyer un signal SIGUSR1 aux anciens processus, ce qui
-provoquera leur arrt immdiat ds que leurs connexions seront termines ; en
-revanche, si le rechargement choue, il suffit d'envoyer un signal SIGTTIN pour
-remettre les ports en coute et rtablir le service immdiatement. Veuillez
-noter que le paramtre 'grace' est ignor pour le signal SIGTTOU ainsi que le
-signal SIGUSR1 une fois le processus en pause. Aussi, il peut s'avrer trs
-utile de sauver le fichier de pid avant de dmarrer une nouvelle instance.
-
-Ce mcanisme est pleinement exploit  partir de la version 1.2.11 avec les
-options '-st' et '-sf' (voir ci-dessous).
-
-2.4) Reconfiguration  chaud
-----------------------------
-Les paramtres '-st' et '-sf' sont utiliss pour informer des processus
-existants que la configuration va tre recharge. Ils recevront le signal
-SIGTTOU, leur demandant de librer les ports en coute afin que le nouveau
-processus puisse les prendre. Si quoi que ce soit se passe mal, le nouveau
-processus leur enverra un signal SIGTTIN pour leur indiquer qu'ils peuvent
-se remettre en coute et continuer leur travail. En revanche, si la
-configuration se charge correctement, alors ils recevront un signal de demande
-de fin de travail en douceur (-sf), ou de terminaison immdiate (-st) qui
-coupera les sessions en cours. Un usage typique tel que celui-ci permet de
-recharger une configuration sans interruption de service :
-
- # haproxy -p /var/run/haproxy.pid -sf $(cat /var/run/haproxy.pid)
-
-
-2.5) Temps d'expiration des connexions
---------------------------------------
-Il est possible de paramtrer certaines dures d'expiration au niveau des
-connexions TCP. Trois temps indpendants sont configurables et acceptent des
-valeurs en millisecondes. Si l'une de ces trois temporisations est dpasse, la
-session est termine  chaque extrmit.
-
-  - temps d'attente d'une donne de la part du client, ou de la
-    possibilit de lui envoyer des donnes : "clitimeout" :
-
-        # time-out client  2mn30.
-        clitimeout        150000
-
-  - temps d'attente d'une donne de la part du serveur, ou de la
-    possibilit de lui envoyer des donnes : "srvtimeout" :
-
-        # time-out serveur  30s.
-        srvtimeout        30000
-
-  - temps d'attente de l'tablissement d'une connexion vers un serveur
-    "contimeout" :
-
-        # on abandonne si la connexion n'est pas tablie aprs 4 secondes
-        contimeout        4000
-
-Remarques :
------------
-  - "contimeout" et "srvtimeout" n'ont pas d'utilit dans le cas du serveur de
-    type "health".
-  - sous de fortes charges, ou sur un rseau satur ou dfectueux, il est
-    possible de perdre des paquets. Du fait que la premire retransmission
-    TCP n'ait lieu qu'au bout de 3 secoudes, fixer un timeout de connexion
-    infrieur  3 secondes ne permet pas de se rattraper sur la perte
-    de paquets car la session aura t abandonne avant la premire
-    retransmission. Une valeur de 4 secondes rduira considrablement
-    le nombre d'checs de connexion.
-  - A compter de la version 1.3.14, il est possible de spcifier les dures
-    d'expiration dans des units de temps arbitraires  choisir parmi
-    { us, ms, s, m, h, d }. Pour cela, la valeur entire doit tre suffixe
-    de l'unit.
-
-2.6) Tentatives de reconnexion
-------------------------------
-Lors d'un chec de connexion vers un serveur, il est possible de
-retenter (potentiellement vers un autre serveur, en cas de rpartition
-de charge). Le nombre de nouvelles tentatives infructueuses avant
-abandon est fourni par le paramtre "retries".
-
-Exemple :
----------
-        # on essaie encore trois fois maxi
-        retries 3
-
-Il est  noter que la tentative de reconnexion peut amener  utiliser un autre
-serveur si le premier a disparu entre deux tentatives de connexion.
-
-
-2.7) Adresse du serveur
------------------------
-Le serveur vers lequel sont rediriges les nouvelles connexions est dfini par
-le paramtre "dispatch" sous la forme <adresse_ip>:<port>. Il correspond  un
-serveur d'assignation de cookie dans le cas o le service consiste  assurer
-uniquement une persistence HTTP, ou bien simplement au serveur destination dans
-le cas de relayage TCP simple. Cet ancien mode ne permet pas de tester l'tat
-du serveur distant, et il est maintenant recommand d'utiliser de prfrence
-le mode 'balance'.
-
-Exemple :
----------
-           # on envoie toutes les nouvelles connexions ici
-        dispatch 192.168.1.2:80
-
-Remarque :
-----------
-Ce paramtre n'a pas d'utilit pour un serveur en mode 'health', ni en mode
-'balance'.
-
-
-2.8) Adresse de sortie
-----------------------
-Il est possible de forcer l'adresse utilise pour tablir les connexions vers
-les serveurs  l'aide du paramtre "source". Il est mme possible de forcer le
-port, bien que cette fonctionnalit se limite  des usages trs spcifiques.
-C'est particulirement utile en cas d'adressage multiple, et plus gnralement
-pour permettre aux serveurs de trouver le chemin de retour dans des contextes
-de routage difficiles. Si l'adresse est '0.0.0.0' ou '*' ou vide, elle sera
-choisie librement par le systeme. Si le port est '0' ou vide, il sera choisi
-librement par le systme. Il est  noter que depuis la version 1.1.18, les
-tests de bon fonctionnement des serveurs seront aussi effectus  partir de la
-source spcifie par ce paramtre.
-
-Exemples :
-----------
-    listen http_proxy *:80
-           # toutes les connexions prennent l'adresse 192.168.1.200
-        source 192.168.1.200:0
-
-    listen rlogin_proxy *:513
-           # utiliser l'adresse 192.168.1.200 et le port rserv 900
-        source 192.168.1.200:900
-
-
-2.9) Dfinition du nom du cookie
---------------------------------
-En mode HTTP, il est possible de rechercher la valeur d'un cookie pour savoir
-vers quel serveur aiguiller la requte utilisateur. Le nom du cookie est donn
-par le paramtre "cookie".
-
-Exemple :
----------
-    listen http_proxy :80
-        mode http
-        cookie SERVERID
-
-On peut modifier l'utilisation du cookie pour la rendre plus intelligente
-vis--vis des applications relayes. Il est possible, notamment de supprimer ou
-rcrire un cookie retourn par un serveur accd en direct, et d'insrer un
-cookie dans une rponse HTTP adresse  un serveur slectionn en rpartition
-de charge, et mme de signaler aux proxies amont de ne pas cacher le cookie
-insr.
-
-Exemples :
-----------
-
-Pour ne conserver le cookie qu'en accs indirect, donc  travers le
-dispatcheur, et supprimer toutes ses ventuelles occurences lors des accs
-directs :
-
-        cookie SERVERID indirect
-
-Pour remplacer la valeur d'un cookie existant par celle attribue  un serveur,
-lors d'un accs direct :
-
-        cookie SERVERID rewrite
-
-Pour crer un cookie comportant la valeur attribue  un serveur lors d'un
-accs en rpartition de charge interne. Dans ce cas, il est souhaitable que
-tous les serveurs aient un cookie renseign. Un serveur non assign d'un cookie
-retournera un cookie vide (cookie de suppression) :
-
-        cookie SERVERID insert
-
-Pour rutiliser un cookie applicatif et lui prfixer l'identifiant du serveur,
-puis le supprimer dans les requtes suivantes, utiliser l'option 'prefix'. Elle
-permet d'insrer une instance de haproxy devant une application sans risquer
-d'incompatibilits des  des clients qui ne supporteraient pas d'apprendre
-plus d'un cookie :
-
-       cookie JSESSIONID prefix
-
-Pour insrer un cookie, en s'assurant qu'un cache en amont ne le stockera pas,
-ajouter le mot cl 'nocache' aprs 'insert' :
-
-        cookie SERVERID insert nocache
-
-Pour insrer un cookie seulement suite aux requtes de type POST, ajouter le
-mot cl 'postonly' aprs 'insert' :
-
-        cookie SERVERID insert postonly
-
-
-Remarques :
------------
-- Il est possible de combiner 'insert' avec 'indirect' ou 'rewrite' pour
-  s'adapter  des applications gnrant dj le cookie, avec un contenu
-  invalide. Il suffit pour cela de les spcifier sur la mme ligne.
-
-- dans le cas o 'insert' et 'indirect' sont spcifis, le cookie n'est jamais
-  transmis au serveur vu qu'il n'en a pas connaissance et ne pourrait pas le
-  comprendre.
-
-- il est particulirement recommand d'utiliser 'nocache' en mode insertion si
-  des caches peuvent se trouver entre les clients et l'instance du proxy. Dans
-  le cas contraire, un cache HTTP 1.0 pourrait cacher la rponse, incluant le
-  cookie de persistence insr, donc provoquer des changements de serveurs pour
-  des clients partageant le mme cache.
-
-- le mode 'prefix' ne ncessite pas d'utiliser 'indirect', 'nocache', ni
-  'postonly', car tout comme le mode 'rewrite', il s'appuie sur un cookie
-  prsent par l'application qui est cense savoir  quel moment il peut
-  tre mis sans risque. Toutefois, comme il ncessite de rectifier le cookie
-  prsent par le client dans chaque requte ultrieure, il est indispensable
-  de s'assurer que le client et le serveur communiqueront sans "keep-alive
-  HTTP". Dans le doute, il est recommand d'utiliser l'option "httpclose".
-
-- lorsque l'application est bien connue, et que les parties ncessitant de la
-  persistence sont systmatiquement accdes par un formulaire en mode POST,
-  il est plus efficace encore de combiner le mot cl "postonly" avec "insert"
-  et "indirect", car la page d'accueil reste cachable, et c'est l'application
-  qui gre le 'cache-control'.
-
-2.10) Assignation d'un serveur  une valeur de cookie
-----------------------------------------------------
-En mode HTTP, il est possible d'associer des valeurs de cookie  des serveurs
-par le paramtre 'server'. La syntaxe est :
-
-    server <identifiant> <adresse_ip>:<port> cookie <valeur>
-
-- <identifiant> est un nom quelconque de serveur utilis pour l'identifier dans la
-  configuration et les logs.
-- <adresse_ip>:<port> est le couple adresse-port sur lequel le serveur coute.
-- <valeur> est la valeur  reconnatre ou positionner dans le cookie.
-
-Exemple : le cookie SERVERID peut contenir server01 ou server02
----------
-    listen http_proxy :80
-        mode http
-        cookie SERVERID
-        dispatch 192.168.1.100:80
-        server web1 192.168.1.1:80 cookie server01
-        server web2 192.168.1.2:80 cookie server02
-
-Attention : la syntaxe a chang depuis la version 1.0.
------------
-
-3) Rpartiteur de charge autonome
-=================================
-
-Le relais peut effectuer lui-mme la rpartition de charge entre les diffrents
-serveurs dfinis pour un service donn, en mode TCP comme en mode HTTP. Pour
-cela, on prcise le mot cl 'balance' dans la dfinition du service,
-ventuellement suivi du nom d'un algorithme de rpartition. Jusqu' la version
-1.2.11, seul 'roundrobin' tait gr, et c'est aussi la valeur implicite par
-dfaut. Avec la version 1.2.12, le nouveau mot cl 'source' est apparu. La
-version 1.3.10 a galement apport le mot cl 'uri'. Il est vident qu'en cas
-d'utilisation du rpartiteur interne, il ne faudra pas spcifier d'adresse de
-dispatch, et qu'il faudra au moins un serveur.
-
-Exemple : mme que prcdemment en rpartition interne
----------
-
-    listen http_proxy :80
-        mode http
-        cookie SERVERID
-        balance roundrobin
-        server web1 192.168.1.1:80 cookie server01
-        server web2 192.168.1.2:80 cookie server02
-
-Depuis la version 1.1.22, il est possible de dterminer automatiquement le port
-du serveur vers lequel sera envoye la connexion, en fonction du port d'coute
-sur lequel le client s'est connect. En effet, il y a 4 possibilits pour le
-champ <port> de l'adresse serveur :
-
-  - non spcifi ou nul :
-    la connexion sera envoye au serveur sur le mme port que celui sur
-    lequel le relais a reu la connexion.
-
-  - valeur numrique (seul cas support pour les versions antrieures) :
-    le serveur recevra la connexion sur le port dsign.
-
-  - valeur numrique prcde d'un signe '+' :
-    la connexion sera envoye au serveur sur le mme port que celui sur
-    lequel le relais a reu la connexion, auquel on ajoute la valeur dsigne.
-    
-  - valeur numrique prcde d'un signe '-' :
-    la connexion sera envoye au serveur sur le mme port que celui sur
-    lequel le relais a reu la connexion, duquel on soustrait la valeur
-    dsigne.
-    
-Exemples :
-----------
-
-# mme que prcdemment
-
-    listen http_proxy :80
-        mode http
-        cookie SERVERID
-        balance roundrobin
-        server web1 192.168.1.1 cookie server01
-        server web2 192.168.1.2 cookie server02
-
-# relayage simultan des ports 80 et 81 et 8080-8089
-
-    listen http_proxy :80,:81,:8080-8089
-        mode http
-        cookie SERVERID
-        balance roundrobin
-        server web1 192.168.1.1 cookie server01
-        server web2 192.168.1.2 cookie server02
-
-# relayage TCP des ports 25, 389 et 663 vers les ports 1025, 1389 et 1663
-
-    listen http_proxy :25,:389,:663
-        mode tcp
-        balance roundrobin
-        server srv1 192.168.1.1:+1000
-        server srv2 192.168.1.2:+1000
-
-Comme indiqu prcdemment, la version 1.2.12 apporta le nouveau mot cl
-'source'. Lorsque celui-ci est utilis, l'adresse IP du client est hache et
-distribue de manire homogne parmi les serveurs disponibles, de sorte qu'une
-mme adresse IP aille toujours sur le mme serveur tant qu'il n'y a aucun
-changement dans le nombre de serveurs disponibles. Ceci peut tre utilis par
-exemple pour attacher le HTTP et le HTTPS sur un mme serveur pour un mme
-client. Cela peut galement tre utilis pour amliorer la persistance
-lorsqu'une partie de la population des clients n'accepte pas les cookies. Dans
-ce cas, seuls ces derniers seront perturbs par la perte d'un serveur.
-
-NOTE: il est important de prendre en compte le fait que beaucoup d'internautes
-      naviguent  travers des fermes de proxies qui assignent des adresses IP
-      diffrentes  chaque requte. D'autres internautes utilisent des liens 
-      la demande et obtiennent une adresse IP diffrente  chaque connexion. De
-      ce fait, le paramtre 'source' doit tre utilis avec une extrme
-      prcaution.
-
-Exemples :
-----------
-
-# assurer qu'une mme adresse IP ira sur le mme serveur pour tout service
-
-    listen http_proxy
-        bind :80,:443
-        mode http
-        balance source
-        server web1 192.168.1.1
-        server web2 192.168.1.2
-
-# amliorer la persistance par l'utilisation de la source en plus du cookie :
-
-    listen http_proxy :80
-        mode http
-        cookie SERVERID
-        balance source
-        server web1 192.168.1.1 cookie server01
-        server web2 192.168.1.2 cookie server02
-
-De plus, tel qu'indiqu ci-dessus, la version 1.3.10 a introduit le mot cl
-'uri'. Il est trs pratique dans le cas de rpartition de charge entre des
-reverse-proxy-caches, parce qu'il utilisera le rsultat d'un hachage de l'URI
-pour choisir un serveur, ce qui aura pour effet d'optimiser le taux de cache
-du fait que la mme URI sera toujours envoye au mme cache. Ce mot-cl n'est
-autoris qu'en mode HTTP.
-
-Example :
----------
-
-# Envoie toujours une URI donne au mme serveur
-
-    listen http_proxy
-        bind :3128
-        mode http
-        balance uri
-        server squid1 192.168.1.1
-        server squid2 192.168.1.2
-
-La version 1.3.14 a apport une nouvelle mthode 'balance url_param'. Elle
-consiste  se baser sur un paramtre pass dans l'URL pour effectuer un hachage
-utilis pour dterminer le serveur  utiliser. Ceci est principalement utile
-pour des applications n'ayant pas une exigence stricte de persistance, mais
-pour lesquelles elle procure un gain de performance notable dans des
-environnements o il n'est pas toujours possible d'utiliser des cookies. En cas
-d'absence du paramtre dans l'URL, alors une rpartition de type 'round robin'
-est effectue.
-
-Example :
----------
-
-# hache le paramtre "basket_id" dans l'URL pour dterminer le serveur
-
-    listen http_proxy
-        bind :3128
-        mode http
-        balance url_param basket_id
-        server ebiz1 192.168.1.1
-        server ebiz2 192.168.1.2
-
-
-3.1) Surveillance des serveurs
-------------------------------
-Il est possible de tester l'tat des serveurs par tablissement de connexion
-TCP ou par envoi d'une requte HTTP. Un serveur hors d'usage ne sera pas
-utilis dans le processus de rpartition de charge interne. Pour activer la
-surveillance, ajouter le mot cl 'check'  la fin de la dclaration du serveur.
-Il est possible de spcifier l'intervalle (en millisecondes) sparant deux
-tests du serveur par le paramtre "inter", le nombre d'checs accepts par le
-paramtre "fall", et le nombre de succs avant reprise par le paramtre "rise".
-Les paramtres non prciss prennent les valeurs suivantes par dfaut :
-
- - inter : 2000
- - rise  : 2
- - fall  : 3
- - port  : port de connexion du serveur
- - addr  : adresse de connexion du serveur (par defaut: adresse du serveur)
- 
-Le mode par dfaut consiste  tablir des connexions TCP uniquement. Dans
-certains cas de pannes, des serveurs peuvent continuer  accepter les
-connexions sans les traiter. Depuis la version 1.1.16, haproxy est en mesure
-d'envoyer des requtes HTTP courtes et trs peu coteuses. Les versions 1.1.16
-et 1.1.17 utilisent "OPTIONS / HTTP/1.0". Dans les versions 1.1.18  1.1.20,
-les requtes ont t changes en "OPTIONS * HTTP/1.0" pour des raisons de
-contrle d'accs aux ressources. Cependant, cette requte documente dans la
-RFC2068 n'est pas comprise par tous les serveurs. Donc  partir de la version
-1.1.21, la requte par dfaut est revenue  "OPTIONS / HTTP/1.0", mais il est
-possible de paramtrer la partie URI. Les requtes OPTIONS prsentent
-l'avantage d'tre facilement extractibles des logs, et de ne pas induire
-d'accs aux fichiers ct serveur. Seules les rponses 2xx et 3xx sont
-considres valides, les autres (y compris non-rponses) aboutissent  un
-chec. Le temps maximal imparti pour une rponse est gal  l'intervalle entre
-deux tests (paramtre "inter"). Pour activer ce mode, spcifier l'option
-"httpchk", ventuellement suivie d'une mthode et d'une URI. L'option "httpchk"
-accepte donc 4 formes :
-
-  - option httpchk               -> OPTIONS / HTTP/1.0
-  - option httpchk URI           -> OPTIONS <URI> HTTP/1.0
-  - option httpchk METH URI      -> <METH> <URI> HTTP/1.0
-  - option httpchk METH URI VER  -> <METH> <URI> <VER>
-
-HAProxy est souvent utilis pour relayer divers protocoles reposant sur TCP,
-tels que HTTPS, SMTP ou LDAP, le plus commun tant HTTPS. Un problme assez
-couramment rencontr dans les data centers est le besoin de relayer du trafic
-vers des serveurs lointains tout en maintenant la possibilit de basculer sur
-un serveur de secours. Les tests purement TCP ne suffisent pas toujours dans
-ces situations car l'on trouve souvent, dans la chane, des proxies, firewalls
-ou rpartiteurs de charge qui peuvent acquitter la connexion avant qu'elle
-n'atteigne le serveur. La seule solution  ce problme est d'envoyer des tests
-applicatifs. Comme la demande pour les tests HTTPS est leve, ce test a t
-implment en version 1.2.15 sur la base de messages SSLv3 CLIENT HELLO. Pour
-l'activer, utiliser "option ssl-hello-chk". Ceci enverra des messages SSLv3
-CLIENT HELLO aux serveurs, en annonant un support pour la majorit des
-algorithmes de chiffrement. Si en retour, le serveur envoie ce qui ressemble 
-une rponse SSLv3 SERVER HELLO ou ALERT (refus des algorithmes), alors la
-rponse sera considre comme valide. Noter qu'Apache ne produit pas de log
-lorsqu'il reoit des messages HELLO, ce qui en fait un type de message
-parfaitement adapt  ce besoin.
-
-La version 1.3.10 est accompagne d'un nouveau test d'tat pour le SMTP. Par
-dfaut, il consiste  envoyer "HELO localhost" aux serveurs, et  attendre le
-message "250" en retour. Notez qu'il peut aussi envoyer une requte plus
-spcifique :
-
-  - option smtpchk                         -> envoie "HELO localhost"
-  - option smtpchk EHLO mail.mydomain.com  -> envoie ce message ESMTP
-
-Voir les exemples ci-aprs.        
-
-Depuis la version 1.1.17, il est possible de dfinir des serveurs de secours,
-utiliss uniquement lorsqu'aucun des autres serveurs ne fonctionne. Pour cela,
-ajouter le mot cl "backup" sur la ligne de dfinition du serveur. Un serveur
-de secours n'est appel que lorsque tous les serveurs normaux, ainsi que tous
-les serveurs de secours qui le prcdent sont hors d'usage. Il n'y a donc pas
-de rpartition de charge entre des serveurs de secours par dfaut. A partir
-de la version 1.2.9, il est possible de les utiliser simultanment grce 
-l'option 'allbackups'. Ce type de serveurs peut servir  retourner des pages
-d'indisponibilit de service. Dans ce cas, il est prfrable de ne pas affecter
-de cookie, afin que les clients qui le rencontrent n'y soient pas affects
-dfinitivement. Le fait de ne pas mettre de cookie envoie un cookie vide, ce
-qui a pour effet de supprimer un ventuel cookie affect prcdemment.
-
-Depuis la version 1.1.22, il est possible d'envoyer les tests de fonctionnement
-vers un port diffrent de celui de service. C'est ncessaire principalement
-pour les configurations o le serveur n'a pas de port prdfini, par exemple
-lorsqu'il est dduit du port d'acceptation de la connexion. Pour cela, utiliser
-le paramtre 'port' suivi du numro de port devant rpondre aux requtes. Il
-est possible d'envoyer les tests de fonctionnement vers une adresse diffrente 
-de celle de service. Cela permet d'utiliser, sur la machine faisant fonctionner
-HAproxy, un dmon permettant des tests specifiques ( REGEX sur un rsultat et
-basculement de plusieurs fermes en cas d'erreur sur l'une d'elles).
-
-Enfin, depuis la version 1.1.17, il est possible de visualiser rapidement
-l'tat courant de tous les serveurs. Pour cela, il suffit d'envoyer un signal
-SIGHUP au processus proxy. L'tat de tous les serveurs de tous les proxies est
-envoy dans les logs en niveau "notice", ainsi que sur la sortie d'erreurs si
-elle est active. C'est une bonne raison pour avoir au moins un serveur de logs
-local en niveau notice.
-
-Depuis la version 1.1.18 (et 1.2.1), un message d'urgence est envoy dans les
-logs en niveau 'emerg' si tous les serveurs d'une mme instance sont tombs,
-afin de notifier l'administrateur qu'il faut prendre une action immdiate.
-
-Depuis les versions 1.1.30 et 1.2.3, plusieurs serveurs peuvent partager la
-mme valeur de cookie. C'est particulirement utile en mode backup, pour
-slectionner des chemins alternatifs pour un serveur donn, pour mettre en
-oeuvre l'arrt en douceur d'un serveur, ou pour diriger les clients
-temporairement vers une page d'erreur en attendant le redmarrage d'une
-application. Le principe est que lorsqu'un serveur est dtect comme inoprant,
-le proxy cherchera le prochain serveur possdant la mme valeur de cookie pour
-chaque client qui le demandera. S'il ne trouve pas de serveur normal, alors il
-le cherchera parmi les serveurs de backup. Consulter le guide d'architecture
-pour plus d'informations.
-
-Exemples :
-----------
-# conf du paragraphe 3) avec surveillance TCP
-    listen http_proxy 0.0.0.0:80
-        mode http
-        cookie SERVERID
-        balance roundrobin
-        server web1 192.168.1.1:80 cookie server01 check
-        server web2 192.168.1.2:80 cookie server02 check inter 500 rise 1 fall 2
-
-# mme que prcdemment avec surveillance HTTP par 'OPTIONS / HTTP/1.0'
-    listen http_proxy 0.0.0.0:80
-        mode http
-        cookie SERVERID
-        balance roundrobin
-        option httpchk
-        server web1 192.168.1.1:80 cookie server01 check
-        server web2 192.168.1.2:80 cookie server02 check inter 500 rise 1 fall 2
-
-# mme que prcdemment avec surveillance HTTP par 'OPTIONS /index.html HTTP/1.0'
-    listen http_proxy 0.0.0.0:80
-        mode http
-        cookie SERVERID
-        balance roundrobin
-        option httpchk /index.html
-        server web1 192.168.1.1:80 cookie server01 check
-        server web2 192.168.1.2:80 cookie server02 check inter 500 rise 1 fall 2
-
-# idem avec surveillance HTTP par 'HEAD /index.jsp? HTTP/1.1\r\nHost: www'
-    listen http_proxy 0.0.0.0:80
-        mode http
-        cookie SERVERID
-        balance roundrobin
-        option httpchk HEAD /index.jsp? HTTP/1.1\r\nHost:\ www
-        server web1 192.168.1.1:80 cookie server01 check
-        server web2 192.168.1.2:80 cookie server02 check inter 500 rise 1 fall 2
-
-# rpartition avec persistence base sur le prfixe de cookie, et arrt en
-# douceur utilisant un second port (81) juste pour les health-checks.
-    listen http_proxy 0.0.0.0:80
-       mode http
-       cookie JSESSIONID prefix
-       balance roundrobin
-       option httpchk HEAD /index.jsp? HTTP/1.1\r\nHost:\ www
-       server web1-norm 192.168.1.1:80 cookie s1 check port 81
-       server web2-norm 192.168.1.2:80 cookie s2 check port 81
-       server web1-stop 192.168.1.1:80 cookie s1 check port 80 backup
-       server web2-stop 192.168.1.2:80 cookie s2 check port 80 backup
-
-# Insertion automatique de cookie dans la rponse du serveur, et suppression
-# automatique dans la requte, tout en indiquant aux caches de ne pas garder
-# ce cookie.
-    listen web_appl 0.0.0.0:80
-        mode http
-        cookie SERVERID insert nocache indirect
-        balance roundrobin
-        server web1 192.168.1.1:80 cookie server01 check
-        server web2 192.168.1.2:80 cookie server02 check
-
-# idem avec serveur applicatif de secours sur autre site, et serveur de pages d'erreurs
-    listen web_appl 0.0.0.0:80
-        mode http
-        cookie SERVERID insert nocache indirect
-        balance roundrobin
-        server web1 192.168.1.1:80 cookie server01 check
-        server web2 192.168.1.2:80 cookie server02 check
-        server web-backup 192.168.2.1:80 cookie server03 check backup
-        server web-excuse 192.168.3.1:80 check backup
-
-# relayage SMTP+TLS avec test du serveur et serveur de backup
-
-    listen http_proxy :25,:587
-        mode tcp
-        balance roundrobin
-        server srv1 192.168.1.1 check port 25 inter 30000 rise 1 fall 2
-        server srv2 192.168.1.2 backup
-
-# relayage HTTPS avec test du serveur et serveur de backup
-
-    listen http_proxy :443
-        mode tcp
-	option ssl-hello-chk
-        balance roundrobin
-        server srv1 192.168.1.1 check inter 30000 rise 1 fall 2
-        server srv2 192.168.1.2 backup
-
-# Utilisation d'un groupe de serveurs pour le backup (ncessite haproxy 1.2.9)
-    listen http_proxy 0.0.0.0:80
-        mode http
-        balance roundrobin
-        option httpchk
-        server inst1 192.168.1.1:80 cookie s1 check
-        server inst2 192.168.1.2:80 cookie s2 check
-        server inst3 192.168.1.3:80 cookie s3 check
-        server back1 192.168.1.10:80 check backup
-        server back2 192.168.1.11:80 check backup
-        option allbackups  # all backups will be used
-
-
-3.2) Reconnexion vers un rpartiteur en cas d'chec direct
-----------------------------------------------------------
-En mode HTTP, si un serveur dfini par un cookie ne rpond plus, les clients
-seront dfinitivement aiguills dessus  cause de leur cookie, et de ce fait,
-dfinitivement privs de service. La spcification du paramtre 'redispatch'
-autorise dans ce cas  renvoyer les connexions choues vers le rpartiteur
-(externe ou interne) afin d'assigner un nouveau serveur  ces clients.
-
-Exemple :
----------
-    listen http_proxy 0.0.0.0:80
-        mode http
-        cookie SERVERID
-        dispatch 192.168.1.100:80
-        server web1 192.168.1.1:80 cookie server01
-        server web2 192.168.1.2:80 cookie server02
-        redispatch # renvoyer vers dispatch si refus de connexion.
-
-Par dfaut (et dans les versions 1.1.16 et antrieures), le paramtre
-redispatch ne s'applique qu'aux checs de connexion au serveur. Depuis la
-version 1.1.17, il s'applique aussi aux connexions destines  des serveurs
-identifis comme hors d'usage par la surveillance. Si l'on souhaite malgr
-tout qu'un client disposant d'un cookie correspondant  un serveur dfectueux
-tente de s'y connecter, il faut prciser l'option "persist" :
-
-    listen http_proxy 0.0.0.0:80
-        mode http
-        option persist
-        cookie SERVERID
-        dispatch 192.168.1.100:80
-        server web1 192.168.1.1:80 cookie server01
-        server web2 192.168.1.2:80 cookie server02
-        redispatch # renvoyer vers dispatch si serveur HS.
-
-
-3.3) Assignation de poids diffrents  des serveurs
----------------------------------------------------
-Parfois il arrive d'ajouter de nouveaux serveurs pour accrotre la capacit
-d'une ferme de serveur, mais le nouveau serveur est soit beaucoup plus petit
-que les autres (dans le cas d'un ajout d'urgence de matriel de rcupration),
-soit plus puissant (lors d'un investissement dans du matriel neuf). Pour cette
-raison, il semble parfois judicieux de pouvoir envoyer plus de clients vers les
-plus gros serveurs. Jusqu' la version 1.2.11, il tait ncessaire de rpliquer
-plusieurs fois les dfinitions des serveurs pour augmenter leur poids. Depuis
-la version 1.2.12, l'option 'weight' est disponible. HAProxy construit alors
-une vue des serveurs disponibles la plus homogne possible en se basant sur
-leur poids de sorte que la charge se distribue de la manire la plus lisse
-possible. Le poids compris entre 1 et 256 doit reflter la capacit d'un
-serveur par rapport aux autres. Le poids de 1 donne la frquence d'apparition
-la plus faible, et 256 la frquence la plus leve. De cette manire, si un
-serveur disparait, les capacits restantes sont toujours respectes.
-
-
-Exemple :
----------
-# distribution quitable sur 2 opteron and un ancien pentium3
-
-    listen web_appl 0.0.0.0:80
-        mode http
-        cookie SERVERID insert nocache indirect
-        balance roundrobin
-        server pentium3-800 192.168.1.1:80 cookie server01 weight  8 check
-        server opteron-2.0G 192.168.1.2:80 cookie server02 weight 20 check
-        server opteron-2.4G 192.168.1.3:80 cookie server03 weight 24 check
-        server web-backup1 192.168.2.1:80 cookie server04 check backup
-        server web-excuse 192.168.3.1:80 check backup
-
-Notes :
--------
-  - lorsque le poids n'est pas spcifi, la valeur par dfaut est  1
-
-  - le poids n'impacte pas les tests de fonctionnement (health checks), donc il
-    est plus propre d'utiliser les poids que de rpliquer le mme serveur
-    plusieurs fois.
-
-  - les poids s'appliquent galement aux serveurs de backup si l'option
-    'allbackups' est positionne.
-
-  - le poids s'applique aussi  la rpartition selon la source
-    ('balance source').
-
-  - quels que soient les poids, le premier serveur sera toujours assign en
-    premier. Cette rgle facilite les diagnostics.
-
-  - pour les puristes, l'algorithme de calculation de la vue des serveurs donne
-    une priorit aux premiers serveurs, donc la vue est la plus uniforme si les
-    serveurs sont dclars dans l'ordre croissant de leurs poids.
-
-La distribution du trafic suivra exactement le squencement suivant :
-
-        Request|                   1 1 1 1
-        number | 1 2 3 4 5 6 7 8 9 0 1 2 3
-       --------+---------------------------
-        p3-800 | X . . . . . . X . . . . .
-        opt-20 | . X . X . X . . . X . X .
-        opt-24 | . . X . X . X . X . X . X
-
-
-3.4) Limitation du nombre de sessions concurrentes par serveur
---------------------------------------------------------------
-Certains serveurs web multi-processus tels qu'Apache souffrent ds qu'il y a
-trop de sessions concurrentes, parce qu'il est trs coteux de faire
-fonctionner des centaines ou des milliers de processus sur un systme. Une
-solution consiste  augmenter le nombre de serveurs et de rpartir la charge
-entre eux, mais cela pose un problme lorsque le but est uniquement de rsister
- des pics de charge occasionnels.
-
-Pour rsoudre ce problme, une nouvelle fonctionnalit a t implmente dans
-HAProxy 1.2.13. Il s'agit d'une limite "maxconn" par serveur, associe  une
-file d'attente par serveur et par proxy. Ceci transforme HAProxy en un tampon
-entre des milliers de clients et quelques serveurs. Dans bien des cas, le fait
-de diminuer la valeur maxconn amliorera notablement les performances des
-serveurs et diminuera les temps de rponse simplement parce que les serveurs
-seront moins congestionns.
-
-Quand une requte cherche  joindre n'importe quel serveur, le premier serveur
-non satur est utilis, en respectant l'algorithme de rpartition de charge. Si
-tous les serveurs sont saturs, alors la requte sera mise dans la file
-d'attente globale de l'instance. Elle sortira de cette file d'attente lorsque
-toutes les requtes prcdentes auront t libres et qu'un serveur aura t
-libr d'une connexion pour la traiter.
-
-Si une requte fait rfrence  un serveur en particulier (p.ex: hachage d'IP
-source, ou persistance par cookie), et que ce server est satur, alors la
-requte sera mise dans la file d'attente ddie  ce serveur. Cette file
-d'attente est prioritaire sur la file d'attente globale, de sorte qu'il soit
-plus facile d'atteindre le site pour les utilisateurs qui s'y trouvent dj
-que pour les nouveaux utilisateurs.
-
-Pour cela, les logs ont d tre enrichis pour indiquer le nombre de sessions
-par serveur, la position de la requte dans les files d'attentes, et le temps
-pass en file d'attente. Ceci aide considrablement  faire de la prvision de
-capacit. Voir la section 'logs' plus bas pour plus d'informations.
-
-Exemple :
----------
-    # Prendre soin du P3 qui n'a que 256 Mo de RAM.
-    listen web_appl 0.0.0.0:80
-        maxconn 10000
-        mode http
-        cookie SERVERID insert nocache indirect
-        balance roundrobin
-        server pentium3-800 192.168.1.1:80 cookie s1 weight  8 maxconn 100 check
-        server opteron-2.0G 192.168.1.2:80 cookie s2 weight 20 maxconn 300 check
-        server opteron-2.4G 192.168.1.3:80 cookie s3 weight 24 maxconn 300 check
-        server web-backup1 192.168.2.1:80 cookie s4 check maxconn 200 backup
-        server web-excuse 192.168.3.1:80 check backup
-
-Cette option se montra si efficace pour rduire les temps de rponse des
-serveurs que certains utilisateurs voulaient utiliser des valeurs trop basses
-pour amliorer les performances de leurs serveurs. Seulement, ils n'taient
-alors plus en mesure de supporter de trs fortes charges parce qu'il n'tait
-plus possible de les saturer. Pour cette raison, la version 1.2.14 a apport la
-limitation dynamique de connexions avec l'addition du paramtre "minconn".
-Lorsque ce paramtre est associ  "maxconn", il active la limitation dynamique
-base sur la charge de l'instance. Le nombre maximal de sessions concurrentes
-sur un serveur devient alors proportionnel au nombre de sessions de l'instance
-par rapport  son 'maxconn'. Un minimum de <minconn> sessions sera toujours
-permis quelle que soit la charge. Ceci assurera que les serveurs travailleront
-au meilleur de leurs performances sous des charges normales, et qu'ils seront
-tout de mme capables de supporter de fortes pointes lorsque ncessaire. La
-limite dynamique est calcule comme ceci :
-
-    srv.dyn_limit = max(srv.minconn, srv.maxconn * inst.sess / inst.maxconn)
-
-Exemple :
----------
-    # Prendre soin du P3 qui n'a que 256 Mo de RAM.
-    listen web_appl 0.0.0.0:80
-        maxconn 10000
-        mode http
-        cookie SERVERID insert nocache indirect
-        balance roundrobin
-        server pentium3-800 192.168.1.1:80 cookie s1 weight  8 minconn 10 maxconn 100 check
-        server opteron-2.0G 192.168.1.2:80 cookie s2 weight 20 minconn 30 maxconn 300 check
-        server opteron-2.4G 192.168.1.3:80 cookie s3 weight 24 minconn 30 maxconn 300 check
-        server web-backup1 192.168.2.1:80 cookie s4 check maxconn 200 backup
-        server web-excuse 192.168.3.1:80 check backup
-
-Dans l'exemple ci-dessus, le serveur "pentium3-800' recevra au plus 100
-connexions simultanes lorsque l'instance du proxy en atteindra 10000, et
-recevra seulement 10 connexions simultanes tant que le proxy sera sous les 1000
-sessions.
-
-Il est possible de limiter la taille de la file d'attente dans le but de
-redistribuer les connexions destines  un serveur en particulier qui sont trop
-loin pour avoir une chance d'tre servies en un temps raisonnable. Ceci n'est
-acceptable que dans le cas o l'affinit entre le client et le serveur n'est
-pas obligatoire, mais motive uniquement par des raisons de performances, par
-exemple, par l'utilisation d'un cache local au serveur. L'option 'maxqueue'
-permet de prciser la limite par serveur, tel que dans l'exemple ci-dessous :
-
-... (mme exemple que prcdemment)
-        server pentium3-800 192.168.1.1:80 cookie s1 weight  8 minconn 10 maxconn 100 check maxqueue 50
-        server opteron-2.0G 192.168.1.2:80 cookie s2 weight 20 minconn 30 maxconn 300 check maxqueue 200
-        server opteron-2.4G 192.168.1.3:80 cookie s3 weight 24 minconn 30 maxconn 300 check
-
-En l'absence du paramtre 'maxqueue', la file d'un serveur n'a pas de limite
-dfinie. Dans le cas contraire, lorsque la file atteint la limite fixe par
-'maxqueue', les clients sont dplacs vers la file globale.
-
-Notes :
--------
-  - la requte ne restera pas indfiniment en file d'attente, elle est
-    assujtie au paramtre 'contimeout', et si une requte ne peut pas
-    sortir de la file avant ce time-out, soit parce que le serveur est
-    satur, soit parce qu'il y a trop de requtes en file d'attente,
-    alors elle expirera avec une erreur 503.
-
-  - si seul <minconn> est spcifi, il a le mme effet que <maxconn>
-
-  - positionner des valeurs trop basses pour 'maxconn' peut amliorer les
-    performances mais aussi permettre  des utilisateurs trop lents de bloquer
-    un serveur pour les autres utilisateurs.
-
-
-3.5) Abandon des requtes abortes
-----------------------------------
-En prsence de trs fortes charges, les serveurs mettront un certain temps 
-rpondre. La file d'attente du proxy se remplira, et les temps de rponse
-suivront une croissance proportionnelle  la taille de file d'attente fois
-le temps moyen de rponse par session. Lorsque les clients attendront plus de
-quelques secondes, ils cliqueront souvent sur le bouton 'STOP' de leur
-navigateur, laissant des requtes inutiles en file d'attente et ralentissant
-donc les autres utilisateurs.
-
-Comme il n'y a aucun moyen de distinguer un vrai clic sur STOP d'une simple
-fermeture du canal de sortie sur le client (shutdown(SHUT_WR)), les agents HTTP
-doivent tre conservateurs et considrer que le client n'a probablement ferm
-que le canal de sortie en attendant la rponse. Toutefois, ceci introduit des
-risques de congestion lorsque beaucoup d'utilisateurs font de mme, et s'avre
-aujourd'hui compltement inutile car probablement aucun client ne referme la
-session en attendant la rponse. Certains agents HTTP supportent ceci (Squid,
-Apache, HAProxy), et d'autres ne le supportent pas (TUX, et la plupart des
-rpartiteurs de charge matriels). Donc la probabilit pour qu'une notification
-de fermeture d'un canal d'entre ct client reprsente un utilisateur cliquant
-sur 'STOP' est proche de 100%, et il est vraiment tentant d'abandonner la
-requte prmaturment sans polluer les serveurs.
-
-Pour cette raison, une nouvelle option "abortonclose" a t introduite en
-version 1.2.14. Par dfaut (sans l'option), le comportement reste conforme 
-HTTP. Mais lorsque l'option est spcifie, une session dont le canal entrant
-est ferm sera aborte si cela est possible, c'est  dire que la requte est
-soit en file d'attente, soit en tentative de connexion. Ceci rduit
-considrablement la longueur des files d'attentes et la charge sur les serveurs
-saturs lorsque les utilisateurs sont tents de cliquer sur 'STOP', ce qui 
-son tour, rduit les temps de rponse pour les autres utilisateurs.
-
-Exemple :
----------
-    listen web_appl 0.0.0.0:80
-        maxconn 10000
-        mode http
-        cookie SERVERID insert nocache indirect
-        balance roundrobin
-        server web1 192.168.1.1:80 cookie s1 weight 10 maxconn 100 check
-        server web2 192.168.1.2:80 cookie s2 weight 10 maxconn 100 check
-        server web3 192.168.1.3:80 cookie s3 weight 10 maxconn 100 check
-        server bck1 192.168.2.1:80 cookie s4 check maxconn 200 backup
-        option abortonclose
-
-
-4) Fonctionnalits additionnelles
-=================================
-
-D'autres fonctionnalits d'usage moins courant sont disponibles. Il s'agit
-principalement du mode transparent, de la journalisation des connexions, de la
-rcriture des en-ttes, et du statut sous forme de page HTML.
-
-
-4.1) Fonctionnalits rseau
----------------------------
-4.1.1) Fonctionnement en mode transparent
----------------------------------------
-En mode HTTP, le mot cl 'transparent' permet d'intercepter des sessions
-routes  travers la machine hbergeant le proxy. Dans ce mode, on ne prcise
-pas l'adresse de rpartition 'dispatch', car celle-ci est tire de l'adresse
-destination de la session dtourne. Le systme doit permettre de rediriger les
-paquets vers un processus local.
-
-Exemple :
----------
-    listen http_proxy 0.0.0.0:65000
-        mode http
-        transparent
-        cookie SERVERID
-        server server01 192.168.1.1:80
-        server server02 192.168.1.2:80
-
-    # iptables -t nat -A PREROUTING -i eth0 -p tcp -d 192.168.1.100 \
-      --dport 80 -j REDIRECT --to-ports 65000
-
-Remarque :
-----------
-Si le port n'est pas spcifi sur le serveur, c'est le port auquel s'est
-adress le client qui sera utilis. Cela permet de relayer tous les ports TCP
-d'une mme adresse avec une mme instance et sans utiliser directement le mode
-transparent.
-
-Exemple :
----------
-    listen http_proxy 0.0.0.0:65000
-        mode tcp
-        server server01 192.168.1.1 check port 60000
-        server server02 192.168.1.2 check port 60000
-
-    # iptables -t nat -A PREROUTING -i eth0 -p tcp -d 192.168.1.100 \
-      -j REDIRECT --to-ports 65000
-
-
-4.1.2) Choix d'une adresse source par serveur
----------------------------------------------------
-Avec les versions 1.1.30 et 1.2.3, il devient possible de spcifier une adresse
-IP source pour joindre chaque serveur. C'est utile pour joindre des serveurs de
-backup  partir d'un LAN diffrent, ou pour utiliser des chemins alternatifs
-pour joindre le mme serveur. C'est galement utilisable pour faciliter une
-rpartition de charge selon l'adresse IP source pour des connexions sortantes.
-Bien entendu, la mme adresse est utilise pour les health-checks.
-
-Exemple :
----------
-    # utiliser une adresse particulire pour joindre les 2 serveur
-    listen http_proxy 0.0.0.0:65000
-       mode http
-       balance roundrobin
-       server server01 192.168.1.1:80 source 192.168.2.13
-       server server02 192.168.1.2:80 source 192.168.2.13
-
-Exemple :
----------
-    # utiliser une adresse particulire pour joindre chaque serveur
-    listen http_proxy 0.0.0.0:65000
-       mode http
-       balance roundrobin
-       server server01 192.168.1.1:80 source 192.168.1.1
-       server server02 192.168.2.1:80 source 192.168.2.1
-
-Exemple :
----------
-    # faire une rpartition d'adresse sources pour joindre le mme proxy 
-    # travers deux liens WAN 
-    listen http_proxy 0.0.0.0:65000
-       mode http
-       balance roundrobin
-       server remote-proxy-way1 192.168.1.1:3128 source 192.168.2.1
-       server remote-proxy-way2 192.168.1.1:3128 source 192.168.3.1
-
-Exemple :
----------
-    # forcer une connexion TCP  s'attacher  un port particulier
-    listen http_proxy 0.0.0.0:2000
-       mode tcp
-       balance roundrobin
-       server srv1 192.168.1.1:80 source 192.168.2.1:20
-       server srv2 192.168.1.2:80 source 192.168.2.1:20
-
-4.1.3) Maintien de session TCP (keep-alive)
--------------------------------------------
-Avec la version 1.2.7, il devient possible d'activer le maintien de session
-TCP (TCP keep-alive)  la fois ct client et ct serveur. Cela permet
-d'empcher des sessions longues d'expirer sur des quipements de niveau 4
-externes tels que des firewalls ou des rpartiteurs de charge. Cela permet
-aussi au systme de dtecter et terminer des sessions figes lorsqu'aucun
-time-out n'a t positionn (fortement dconseill). Le proxy ne peut pas
-positionner l'intervalle entre les annonces ni le nombre maximal, veuillez
-vous rfrer au manuel du systme d'exploitation pour cela. Il existe 3 options
-pour activer le maintien de session TCP :
-
-	option tcpka	# active le keep-alive ct client et ct serveur
-	option clitcpka	# active le keep-alive ct client
-	option srvtcpka	# active le keep-alive ct serveur
-
-4.1.4) Rmanence des donnes TCP (lingering)
---------------------------------------------
-Il est possible de dsactiver la conservation de donnes non acquittes par un
-client  la fin d'une session. Cela peut parfois s'avrer ncessaire lorsque
-haproxy est utilis en face d'un grand nombre de clients non fiables et qu'un
-nombre lev de sockets en tat FIN_WAIT est observ sur la machine. L'option
-peut tre utilise dans un frontend pour ajuster les connexions vers les
-clients, et dans un backend pour ajuster les connexions vers les serveurs :
-
-	option nolinger	# dsactive la conservation de donnes
-
-
-4.2) Journalisation des connexions
-----------------------------------
-
-L'un des points forts de HAProxy est indniablement la prcision de ses logs.
-Il fournit probablement le plus fin niveau d'information disponible pour un
-tel outil, ce qui est trs important pour les diagnostics en environnements
-complexes. En standard, les informations journalises incluent le port client,
-les chronomtrages des tats TCP/HTTP, des tats de session prcis au moment de
-la terminaison et sa cause, des informations sur les dcisions d'aiguillage du
-trafic vers un serveur, et bien sr la possibilit de capturer des en-ttes
-arbitraires.
-
-Dans le but d'amliorer la ractivit des administrateurs, il offre une grande
-transparence sur les problmes rencontrs,  la fois internes et externes, et
-il est possible d'envoyer les logs vers des serveurs diffrents en mme temps
-avec des niveaux de filtrage diffrents :
-
-  - logs globaux au niveau processus (erreurs systme, arrts/dmarrages, ...)
-  - erreurs systme et internes par instance (manque de ressources, bugs, ...)
-  - problmes externes par instance (arrts/relance serveurs, limites, ...)
-  - activit par instance (connexions clients), aussi bien lors de leur
-    tablissement qu' leur terminaison.
-
-La possibilit de distribuer diffrents niveaux de logs  diffrents serveurs
-permet  plusieurs quipes de production d'intragir et de corriger leurs
-problmes le plus tt possible. Par exemple, l'quipe systme peut surveiller
-occasionnellement les erreurs systme, pendant que l'quipe application
-surveille les alertes d'arrts/dmarrages de ses serveurs en temps rel, et
-que l'quipe scurit analyse l'activit en diffr d'une heure.
-
-
-4.2.1) Niveaux de log
----------------------
-Les connexions TCP et HTTP peuvent donner lieu  une journalisation sommaire ou
-dtaille indiquant, pour chaque connexion, la date, l'heure, l'adresse IP
-source, le serveur destination, la dure de la connexion, les temps de rponse,
-la requte HTTP, le code de retour, la quantit de donnes transmises, et mme
-dans certains cas, la valeur d'un cookie permettant de suivre les sessions.
-Tous les messages sont envoys en syslog vers un ou deux serveurs. Se rfrer 
-la section 1.1 pour plus d'information sur les catgories de logs.  La syntaxe
-est la suivante :
-
-    log <adresse_ip_1> <catgorie_1> [niveau_max_1]
-    log <adresse_ip_2> <catgorie_2> [niveau_max_2]
-ou
-    log global
-
-Remarque :
-----------
-La syntaxe spcifique 'log global' indique que l'on souhaite utiliser les
-paramtres de journalisation dfinis dans la section 'global'.
-
-Exemple :
----------
-    listen http_proxy 0.0.0.0:80
-        mode http
-        log 192.168.2.200 local3
-        log 192.168.2.201 local4
-
-4.2.2) Format des logs
-----------------------
-Par dfaut, les connexions sont journalises au niveau TCP ds l'tablissement
-de la session entre le client et le relais. En prcisant l'option 'tcplog',
-la connexion ne sera journalise qu'en fin de session, ajoutant des prcisions
-sur son tat lors de la dconnexion, ainsi que le temps de connexion et la
-dure totale de la session. Le nombre de sessions restantes aprs la
-dconnexion est galement indiqu (pour le serveur, l'instance et le process).
-
-Exemple de journalisation TCP :
--------------------------------
-    listen relais-tcp 0.0.0.0:8000
-        mode tcp
-        option tcplog
-        log 192.168.2.200 local3
-
->>> haproxy[18989]: 127.0.0.1:34550 [15/Oct/2003:15:24:28] relais-tcp Srv1 0/0/5007 0 -- 1/1/1 0/0
-  
-    Champ  Format / Description                          Exemple
-
-        1  nom_processus '[' pid ']:'                    haproxy[18989]:
-        2  ip_client ':' port_client                     127.0.0.1:34550
-        3  '[' date ']'                                  [15/Oct/2003:15:24:28]
-        4  nom_instance                                  relais-tcp
-        5  nom_serveur                                   Srv1
-        6  temps_file '/' temps_connect '/' temps_total  0/0/5007
-        7  octets lus                                    0
-        8  etat_terminaison                              --
-        9  conn_srv '/' conns_inst '/' conns_processus   1/1/1
-       10  position en file d'attente srv '/' globale    0/0
-
-Une autre option, 'httplog', fournit plus de dtails sur le protocole HTTP,
-notamment la requte et l'tat des cookies. Dans les cas o un mcanisme de
-surveillance effectuant des connexions et dconnexions frquentes, polluerait
-les logs, il suffit d'ajouter l'option 'dontlognull', pour ne plus obtenir une
-ligne de log pour les sessions n'ayant pas donn lieu  un change de donnes
-(requte ou rponse).
-
-Exemple de journalisation HTTP :
---------------------------------
-    listen http_proxy 0.0.0.0:80
-        mode http
-        option httplog
-        option dontlognull
-        log 192.168.2.200 local3
-
->>> haproxy[674]: 127.0.0.1:33319 [15/Oct/2003:08:31:57] relais-http Srv1 9/0/7/147/723 200 243 - - ---- 2/3/3 0/0 "HEAD / HTTP/1.0"
-
-Exemple plus complet :
-
-    haproxy[18989]: 10.0.0.1:34552 [15/Oct/2003:15:26:31] relais-http Srv1 3183/-1/-1/-1/11215 503 0 - - SC-- 137/202/205 0/0 {w.ods.org|Mozilla} {} "HEAD / HTTP/1.0" 
-
-    Champ  Format / Description                          Exemple
-
-        1  nom_processus '[' pid ']:'                    haproxy[18989]:
-        2  ip_client ':' port_client                     10.0.0.1:34552
-        3  '[' date ']'                                  [15/Oct/2003:15:26:31]
-        4  nom_instance                                  relais-http
-        5  nom_serveur                                   Srv1
-        6  Tq '/' Tw '/' Tc '/' Tr '/' Tt                3183/-1/-1/-1/11215
-        7  Code_retour_HTTP                              503
-        8  octets lus                                    0
-        9  cookies_requte_capturs                      -
-       10  cookies_reponse_capturs                      -
-       11  etat_terminaison                              SC--
-       12  conns_srv '/' conns_inst '/' conns_processus  137/202/205
-       13  position file serveur '/' globale             0/0
-       14  '{' entetes_requte_capturs '}'              {w.ods.org|Mozilla}
-       15  '{' entetes_reponse_capturs '}'              {}
-       16  '"' requte_HTTP '"'                          "HEAD / HTTP/1.0"
-  
-Note pour les analyseurs de logs : l'URI est TOUJOURS le dernier champ de la ligne, et
-                                   commence par un guillemet '"'.
-
-Le problme de loguer uniquement en fin de session, c'est qu'il est impossible
-de savoir ce qui se passe durant de gros transferts ou des sessions longues.
-Pour pallier  ce problme, une nouvelle option 'logasap' a t introduite dans
-la version 1.1.28 (1.2.1). Lorsqu'elle est active, le proxy loguera le plus
-tt possible, c'est  dire juste avant que ne dbutent les transferts de
-donnes. Cela signifie, dans le cas du TCP, qu'il loguera toujours le rsultat
-de la connexion vers le serveur, et dans le cas HTTP, qu'il loguera en fin de
-traitement des en-ttes de la rponse du serveur, auquel cas le nombre d'octets
-reprsentera la taille des en-ttes retourns au client.
-
-Afin d'viter toute confusion avec les logs normaux, le temps total de
-transfert et le nombre d'octets transfrs sont prfixs d'un signe '+'
-rappelant que les valeurs relles sont certainement plus leves.
-
-Exemple :
----------
-
-    listen http_proxy 0.0.0.0:80
-        mode http
-        option httplog
-        option dontlognull
-        option logasap
-        log 192.168.2.200 local3
-
->>> haproxy[674]: 127.0.0.1:33320 [15/Oct/2003:08:32:17] relais-http Srv1 9/7/14/+30 200 +243 - - ---- 3/3 "GET /image.iso HTTP/1.0"
-
-
-4.2.3) Chronomtrage des vnements
------------------------------------
-Pour dceler des problmes rseau, les mesures du temps coul entre certains
-vnements sont d'une trs grande utilit. Tous les temps sont mesurs en
-millisecondes (ms). En mode HTTP, quatre points de mesure sont rapports sous
-la forme Tq/Tw/Tc/Tr/Tt :
-
-  - Tq: temps total de rception de la requte HTTP de la part du client.
-    C'est le temps qui s'est coul entre le moment o le client a tabli
-    sa connexion vers le relais, et le moment o ce dernier a reu le dernier
-    en-tte HTTP validant la fin de la requte. Une valeur '-1' ici indique
-    que la requte complte n'a jamais t reue.
-
-  - Tw: temps total pass dans les files d'attente avant d'obtenir une place
-    vers un serveur. Ceci tient compte  la fois de la file d'attente globale
-    et de celle du serveur, et dpend du nombre de requtes dans la file et du
-    temps ncessaire au serveur pour complter les sessions prcdentes. La
-    valeur '-1' indique que la requte a t dtruite avant d'atteindre une
-    file.
-
-  - Tc: temps d'tablissement de la connexion TCP du relais vers le serveur.
-    C'est le temps coul entre le moment ou le relais a initi la demande de
-    connexion vers le serveur, et le moment o ce dernier l'a acquitte, c'est
-     dire le temps entre l'envoi du paquet TCP SYN la rception du SYN/ACK.
-    Une valeur '-1' ici indique que la connexion n'a jamais pu tre tablie
-    vers le serveur.
-
-  - Tr: temps de rponse du serveur. C'est le temps que le serveur a mis pour
-    renvoyer la totalit des en-ttes HTTP  partir du moment o il a acquitt
-    la connexion. Ca reprsente exactement le temps de traitement de la
-    transaction sans le transfert des donnes associes. Une valeur '-1'
-    indique que le serveur n'a pas envoy la totalit de l'en-tte HTTP.
-
-  - Tt: dure de vie totale de la session, entre le moment o la demande de
-    connexion du client a t acquitte et le moment o la connexion a t
-    referme aux deux extrmits (client et serveur). La signification change
-    un peu si l'option 'logasap' est prsente. Dans ce cas, le temps correspond
-    uniquement  (Tq + Tw + Tc + Tr), et se trouve prfix d'un signe '+'. On
-    peut donc dduire Td, le temps de transfert des donnes, en excluant les
-    autres temps :
-
-        Td = Tt - (Tq + Tw + Tc + Tr)
-
-    Les temps rapports  '-1' sont simplement  liminer de cette quation.
-
-En mode TCP ('option tcplog'), seuls les deux indicateurs Tw, Tc et Tt sont
-rapports.
-
-Ces temps fournissent de prcieux renseignement sur des causes probables de
-problmes. Du fait que le protocole TCP dfinisse des temps de retransmission
-de 3 secondes, puis 6, 12, etc..., l'observation de temps proches de multiples
-de 3 secondes indique pratiquement toujours des pertes de paquets lis  un
-problme rseau (cble ou ngociation). De plus, si <Tt> est proche d'une
-valeur de time-out dans la configuration, c'est souvent qu'une session a t
-abandonne sur expiration d'un time-out.
-
-Cas les plus frquents :
-
-  - Si Tq est proche de 3000, un paquet a trs certainement t perdu entre
-    le client et le relais.
-  - Si Tc est proche de 3000, un paquet a trs certainement t perdu entre
-    le relais et le serveur durant la phase de connexion. Cet indicateur
-    devrait normalement toujours tre trs bas (moins de quelques dizaines).
-  - Si Tr est presque toujours infrieur  3000, et que certaines valeurs
-    semblent proches de la valeur moyenne majore de 3000, il y a peut-tre
-    de pertes entre le relais et le serveur.
-  - Si Tt est lgrement suprieur au time-out, c'est souvent parce que le
-    client et le serveur utilisent du keep-alive HTTP entre eux et que la
-    session est maintenue aprs la fin des changes. Voir plus loin pour
-    savoir comment dsactiver le keep-alive HTTP.
-
-Autres cas ('xx' reprsentant une valeur quelconque  ignorer) :
-  -1/xx/xx/xx/Tt: le client n'a pas envoy sa requte dans le temps imparti ou
-                  a referm sa connexion sans complter la requte.
-  Tq/-1/xx/xx/Tt: Il n'tait pas possible de traiter la request, probablement
-                  parce que tous les serveurs taient hors d'usage.
-  Tq/Tw/-1/xx/Tt: la connexion n'a pas pu s'tablir vers le serveur (refus ou
-                  time-out au bout de Tt-(Tq+Tw) ms).
-  Tq/Tw/Tc/-1/Tt: le serveur a accept la connexion mais n'a pas rpondu dans
-                  les temps ou bien a referm sa connexion trop tt, au bout
-                  de Tt-(Tq+Tw+Tc) ms.
-     
-4.2.4) Conditions de dconnexion
---------------------------------
-Les logs TCP et HTTP fournissent un indicateur de compltude de la session dans
-le champ 'etat_terminaison', juste avant le nombre de connexions actives. C'est
-un champ long de 2 caractres en TCP et de 4 caractres en HTTP, chacun ayant
-une signification prcise :
-
-  - sur le premier caractre, un code prcisant le premier vnement qui a caus
-    la terminaison de la session :
-
-        C : fermeture inattendue de la session TCP de la part du client.
-
-        S : fermeture inattendue de la session TCP de la part du serveur, ou
-            refus explicite de connexion de la part de ce dernier.
-
-        P : terminaison prmature des sessions par le proxy, pour cause
-            d'imposition d'une limite sur le nombre de connexions, pour cause
-            de configuration (ex: filtre d'URL), ou parce qu'un contrle de
-            scurit a dtect et bloqu une anomalie dans la rponse du
-            serveur qui aurait pu causer une fuite d'informations (par exemple,
-            un cookie cachable).
-
-        R : une ressource sur le proxy a t puise (mmoire, sockets, ports
-            source, ...). Gnralement, cela arrive au cours de l'tablissement
-            d'une connexion, et les logs systme doivent contenir une copie de
-            l'rreur prcise.
-
-        I : une erreur interne a t identifie par le proxy  la suite d'un
-            auto-contrle. Ceci ne doit JAMAIS arriver, et vous tes encourags
-             remonter n'importe quel log contenant ceci car il s'agira un bug.
-
-        c : le dlai maximal d'attente du client a expir (clitimeout).
-
-        s : le dlai maximal d'attente du serveur a expir (srvtimeout et contimeout)
-
-        - : terminaison normale de session.
-
-  - sur le second caractre, l'tat d'avancement de la session TCP/HTTP lors de
-    la fermeture :
-
-        R : attente d'une REQUETE HTTP complte de la part du client. Rien n'a
-            t transmis au serveur.
-
-        Q : attente en file d'attente (QUEUE) d'une place pour avoir une
-            connexion vers un serveur. Ne peut apparatre que sur un serveur
-            possdant un paramtre 'maxconn'. Aucune connexion n'a t envoye
-            au serveur.
-
-        C : attente de l'tablissement d'une CONNEXION vers le serveur. Le
-            serveur peut au plus avoir vu la tentative de connexion, mais
-            aucune donne n'a t change.
-
-        H : attente, rception ou traitement des en-ttes HTTP ("HEADERS").
-
-        D : transfert des DONNEES du serveur vers le client.
-
-        L : transfert des dernires ("LAST") donnes du proxy vers le client,
-            alors que le serveur a dj fini.
-
-        T : requte bloque en mode "tarpit" par le proxy. Elle a t maintenue
-            ouverte vers le client pendant toute la dure du contimeout ou
-            jusqu' l'abandon de la part du client.
-
-        - : terminaison normale, aprs fin de transfert des donnes.
-
-  - le troisime caractre indique l'ventuelle identification d'un cookie de
-    persistence (uniquement en mode HTTP) :
-
-        N : aucun cookie de persistence n'a t prsent. C'est gnralement le
-            cas sur les NOUVELLES connexions clients.
-
-        I : le client a prsent un cookie INVALIDE ne correspondant  aucun
-            serveur connu. Ceci peut tre d  un changement de configuration
-            rcent,  des mlanges de noms de cookies entre sites HTTP/HTTPS,
-            ou  une attaque.
-
-        D : le client a prsent un cookie correspondant  un serveur hors
-            d'usage ("DOWN"). Suivant l'option 'persist', il a t renvoy vers
-            un autre serveur ou a tout de mme tent de se connecter sur celui
-            correspondant au cookie.
-
-        V : le client a prsent un cookie VALIDE et a pu se connecter au
-            serveur correspondant.
-
-        - : non appliquable (pas de cookie positionn dans la configuration).
-
-  - le dernier caractre indique l'ventuel traitement effectu sur un cookie de
-    persistence retrourn par le serveur (uniquement en mode HTTP) :
-
-        N : aucun cookie de persistance n'a t fourni par le serveur, et aucun
-            n'a t insr.
-
-        I : aucun cookie de persistance n'a t fourni par le serveur, et le
-            proxy en a INSERE un.
-
-        P : un cookie de persistence a t fourni par le serveur et transmis
-            tel quel ("PASSIF").
-
-        R : le cookie retourn par le serveur a t REECRIT par le proxy.
-
-        D : le cookie prsent par le serveur a t DETRUIT par le proxy pour
-            ne pas tre retourn au client.
-
-        - : non appliquable
-
-
-La combinaison des deux premiers indicateurs fournit une grande quantiti
-d'informations sur ce qui se passait lorsque la session s'est termine. Cela
-peut notamment aider  dtecter une saturation de serveur, des troubles rseau,
-des puisements de ressources systme locales, des attaques, etc...
-
-Les combinaisons d'indicateurs les plus frquentes sont numres ici.
-
-   Indic  Raison
-      CR  Le client a abandonn avant d'mettre une requte complte. Il est
-          trs probable que la requte ait t tape  la main dans un client
-          telnet et aborte trop tt.
-
-      cR  Le temps imparti au client a expir avant rception d'une requte
-          complte. Ceci est parfois caus par un paramtre TCP MSS trop lev
-          sur le client pour des rseaux PPPoE sur ADSL qui ne peuvent pas
-          transporter des paquets entiers, ou par des clients qui nvoient des
-          requtes  la main et ne tapent pas assez vite.
-
-      SC  Le serveur a explicitement refus la connexion (le proxy a reu un
-          RST TCP ou un message ICMP en retour). Dans certains cas, cela peut
-          tre la couche rseau qui indique au proxy que le serveur n'est pas
-          joignable (p.ex: pas de route, pas de rponse ARP en local, etc...)
-
-      sC  La connexion au serveur n'a pas pu s'tablir dans le temps imparti.
-
-      PC  Le proxy a refus d'tablir une connexion au serveur parce que le
-          nombre de connexions a atteint la limite 'maxconn' (global ou de
-          l'instance). Le paramtre 'maxconn' de l'instance pourrait tre
-          augment, tout comme le paramtre 'maxconn' global.
-
-      RC  Une ressource locale a t puise (mmoire, sockets, ports source),
-          empchant la connexion au serveur de s'tablir. Les logs d'erreurs
-          diront prcisment ce qui manquait. Dans tous les cas, le seul remde
-          consiste  affiner le paramtrage systme.
-
-      cH  Le temps imparti au client a expir au cours d'une requte POST. Ceci
-          est parfois caus par un paramtre TCP MSS trop lev sur le client
-          pour des rseaux PPPoE sur ADSL qui ne peuvent pas transporter des
-          paquets entiers.
-
-      CH  Le client a abandonn alors qu'il attendait un dbut de rponse de la
-          part du serveur. Cela peut tre caus par le serveur qui mettait trop
-          de temps  rpondre, ou par un client cliquant prcipitamment sur le
-          bouton 'Stop'.
-
-      CQ  Le client a abandonn alors que sa session tait mise en file
-          d'attente pour obtenir un serveur avec suffisamment de connexions
-          libres pour l'accepter. Cela signifie soit que l'ensemble des
-          serveurs taient saturs, soit que le serveur assign a mis trop de
-          temps  rpondre.
-
-      CT  Le client a abandonn alors que sa session tait bloque en mode
-          tarpit.
-
-      sQ  La session a attendu trop longtemps en file d'attente et a t
-          expire.
-
-      SH  Le serveur a abort brutalement alors qu'il devait envoyer ses
-          en-ttes. En gnral, cela indique qu'il a crash.
-
-      sH  Le serveur n'a pas pu rpondre durant le temps imparti, ce qui montre
-          des transactions trop longues, probablement causes par un back-end
-          satur. Les seules solutions sont de corriger le problme sur
-          l'application, d'accrotre le paramtre 'srvtimeout' pour supporter
-          des attentes plus longues au risque que les clients abandonnent 
-          leur tour, ou bien d'ajouter des serveurs.
-      
-      PR  Le proxy a bloqu une requte du client, soit  cause d'une syntaxe
-          HTTP invalide, auquel cas il a renvoy une erreur HTTP 400 au client,
-          soit  cause d'une requte validant un filtre d'interdiction, auquel
-          cas le proxy a renvoy une erreur HTTP 403.
-
-      PH  Le proxy a bloqu la rponse du serveur parce qu'elle tait invalide,
-          incomplte, dangereuse ('cache control'), ou parce qu'elle validait
-          un filtre de scurit. Dans tous les cas, une erreur HTTP 502 est
-          renvoye au client.
-
-      PT  Le proxy a bloqu une requte du client et a maintenu sa connection
-          ouverte avant de lui retourner une erreur "500 server error". Rien
-          n'a t envoy au serveur.
-
-      cD  Le client n'a pas lu de donnes pendant le temps qui lui tait
-          imparti. Ceci est souvent caus par des problmes rseau ct client.
-
-      CD  Le client a abort sa connection de manire inattendue pendant le
-          transfert des donnes. Ceci est provoqu soit par le crash d'un
-          navigateur, ou par une session en HTTP keep-alive entre le serveur
-          et le client termine en premier par le client.
-
-      sD  Le serveur n'a rien fait durant le temps imparti par le paramtre
-          'srvtimeout'. Ceci est souvent caus par des timeouts trop courts
-          sur des quipements de niveau 4 (firewalls, rpartiteurs de charge)
-          situs entre le proxy et le serveur.
-
-4.2.5) Caractres non-imprimables
----------------------------------
-Depuis la version 1.1.29, les caractres non-imprimables ne sont plus envoys
-tels quels dans les lignes de logs, mais inscrits sous la forme de deux chiffres
-hexadcimaux, prfixs du caractre d'chappement '#'. Les seuls caractres
-dornavant logus tels quels sont compris entre 32 et 126. Bien videmment, le
-caractre d'chappement '#' est lui-mme encod afin de lever l'ambiguit. Il en
-est de mme pour le caractre '"', ainsi que les caractres '{', '|' et '}' pour
-les en-ttes.
-
-4.2.6) Capture d'en-ttes HTTP et de cookies
---------------------------------------------
-La version 1.1.23 a apport la capture des cookies, et la version 1.1.29 la
-capture d'en-ttes. Tout ceci est effectu en utilisant le mot-cl 'capture'.
-
-Les captures de cookies facilitent le suivi et la reconstitution d'une session
-utilisateur. La syntaxe est la suivante :
-
-    capture cookie <prfixe_cookie> len <longueur_capture>
-
-Ceci activera la capture de cookies  la fois dans les requtes et dans les
-rponses. De cette manire, il devient facile de dtecter lorsqu'un utilisateur
-bascule sur une nouvelle session par exemple, car le serveur lui rassignera un
-nouveau cookie.
-
-Le premier cookie dont le nom commencera par <prfixe_cookie> sera captur, et
-transmis sous la forme "NOM=valeur", sans toutefois, excder <longueur_capture>
-caractres (64 au maximum). Lorsque le nom du cookie est fixe et connu, on peut
-le suffixer du signe "=" pour s'assurer qu'aucun autre cookie ne prendra sa
-place dans les logs.
-
-Exemples :
-----------
-    # capture du premier cookie dont le nom commence par "ASPSESSION"
-    capture cookie ASPSESSION len 32
-
-    # capture du premier cookie dont le nom est exactement "vgnvisitor"
-    capture cookie vgnvisitor= len 32
-
-Dans les logs, le champ prcdant l'indicateur de compltude contient le cookie
-positionn par le serveur, prcd du cookie positionn par le client. Chacun
-de ces champs est remplac par le signe "-" lorsqu'aucun cookie n'est fourni
-par le client ou le serveur, ou lorsque l'option est dsactive..
-
-Les captures d'en-ttes ont un rle compltement diffrent. Elles sont utiles
-pour suivre un identifiant de requte globalement unique positionn par un
-autre proxy en amont, pour journaliser les noms de serveurs virtuels, les types
-de clients web, la longueur des POST, les 'referrers', etc. Dans la rponse, on
-peut chercher des informations relatives  la longueur annonce de la rponse,
-le fonctionnement attendu du cache, ou encore la localisation d'un objet en cas
-de redirection. Tout comme pour les captures de cookies, il est possible
-d'inclure les en-ttes de requtes et de rponse simultanment. La syntaxe est
-la suivante :
-
-    capture request  header <nom> len <longueur max>
-    capture response header <nom> len <longueur max>
-
-Note: Les noms d'en-ttes ne sont pas sensibles  la casse.
-
-Exemples:
----------
-    # conserver le nom du serveur virtuel accd par le client
-    capture request  header Host len 20
-    # noter la longueur des donnes envoyes dans un POST
-    capture request  header Content-Length len 10
-
-    # noter le fonctionnement attendu du cache par le serveur
-    capture response header Cache-Control len 8
-    # noter l'URL de redirection
-    capture response header Location len 20
-
-Les en-ttes non trouvs sont logus  vide, et si un en-tte apparait plusieurs
-fois, seule la dernire occurence sera conserve. Les en-ttes de requte sont
-regroups entre deux accolades '{' et '}' dans l'ordre de leur dclaration, et
-chacun spars par une barre verticale '|', sans aucun espace. Les en-ttes de
-rponse sont prsents de la mme manire, mais aprs un espace suivant le bloc
-d'en-tte de requte. Le tout prcde la requte HTTP. Exemple :
-
-  Config:
-
-    capture request  header Host len 20
-    capture request  header Content-Length len 10
-    capture request  header Referer len 20
-    capture response header Server len 20
-    capture response header Content-Length len 10
-    capture response header Cache-Control len 8
-    capture response header Via len 20
-    capture response header Location len 20
-
-  Log :
-
-    Aug  9 20:26:09 localhost haproxy[2022]: 127.0.0.1:34014 [09/Aug/2004:20:26:09] relais-http netcache 0/0/0/162/+162 200 +350 - - ---- 0/0/0 0/0 {fr.adserver.yahoo.co||http://fr.f416.mail.} {|864|private||} "GET http://fr.adserver.yahoo.com/"
-    Aug  9 20:30:46 localhost haproxy[2022]: 127.0.0.1:34020 [09/Aug/2004:20:30:46] relais-http netcache 0/0/0/182/+182 200 +279 - - ---- 0/0/0 0/0 {w.ods.org||} {Formilux/0.1.8|3495|||} "GET http://w.ods.org/sytadin.html HTTP/1.1" 
-    Aug  9 20:30:46 localhost haproxy[2022]: 127.0.0.1:34028 [09/Aug/2004:20:30:46] relais-http netcache 0/0/2/126/+128 200 +223 - - ---- 0/0/0 0/0 {www.infotrafic.com||http://w.ods.org/syt} {Apache/2.0.40 (Red H|9068|||} "GET http://www.infotrafic.com/images/live/cartesidf/grandes/idf_ne.png HTTP/1.1" 
-
-4.2.7) Exemples de logs
------------------------
-- haproxy[674]: 127.0.0.1:33319 [15/Oct/2003:08:31:57] relais-http Srv1 6559/0/7/147/6723 200 243 - - ---- 1/3/5  0/0"HEAD / HTTP/1.0"
-  => requte longue (6.5s) saisie  la main avec un client telnet. Le serveur a
-     rpondu en 147 ms et la session s'est termine normalement ('----')
-
-- haproxy[674]: 127.0.0.1:33319 [15/Oct/2003:08:31:57] relais-http Srv1 6559/1230/7/147/6870 200 243 - - ---- 99/239/324 0/9 "HEAD / HTTP/1.0"
-  => Idem, mais la requte a t mise en attente dans la file globale derrire
-     9 autres requtes dj prsentes, et y a attendu 1230 ms.
-
-- haproxy[674]: 127.0.0.1:33320 [15/Oct/2003:08:32:17] relais-http Srv1 9/0/7/14/+30 200 +243 - - ---- 1/3/3 0/0 "GET /image.iso HTTP/1.0"
-  => requte pour un long transfert. L'option 'logasap' tait spcifie donc le
-     log a t gnr juste avant le transfert de donnes. Le serveur a rpondu
-     en 14 ms, 243 octets d'en-ttes ont t transfrs au client, et le temps
-     total entre l'accept() et le premier octet de donne est de 30 ms.
-
-- haproxy[674]: 127.0.0.1:33320 [15/Oct/2003:08:32:17] relais-http Srv1 9/0/7/14/30 502 243 - - PH-- 0/2/3 0/0 "GET /cgi-bin/bug.cgi? HTTP/1.0"
-  => le proxy a bloqu une rponse du serveur soit  cause d'un filtre 'rspdeny'
-     ou 'rspideny', soit parce qu'il a dtect un risque de fuite sensible
-     d'informations risquant d'tre caches. Dans ce cas, la rponse est
-     remplace par '502 bad gateway'.
-
-- haproxy[18113]: 127.0.0.1:34548 [15/Oct/2003:15:18:55] relais-http <NOSRV> -1/-1/-1/-1/8490 -1 0 - - CR-- 0/2/2 0/0 "" 
-  => Le client n'a pas envoy sa requte et a referm la connexion lui-mme
-     ('C---') au bout de 8.5s, alors que le relais attendait l'en-tte ('-R--').
-     Aucune connexion n'a t envoye vers le serveur.
-
-- haproxy[18113]: 127.0.0.1:34549 [15/Oct/2003:15:19:06] relais-http <NOSRV> -1/-1/-1/-1/50001 408 0 - - cR-- 0/2/2 0/0 "" 
-  => Le client n'a pas envoy sa requte et son time-out a expir ('c---') au
-     bout de 50s, alors que le relais attendait l'en-tte ('-R--'). Aucune
-     connexion n'a t envoye vers le serveur, mais le relais a tout de mme
-     pu renvoyer un message 408 au client.
-
-- haproxy[18989]: 127.0.0.1:34550 [15/Oct/2003:15:24:28] relais-tcp Srv1 0/5007 0 cD
-  => log en mode 'tcplog'. Expiration du time-out ct client ('cD') au bout de
-     5s.
-
-- haproxy[18989]: 10.0.0.1:34552 [15/Oct/2003:15:26:31] relais-http Srv1 3183/-1/-1/-1/11215 503 0 - - SC-- 115/202/205 0/0 "HEAD / HTTP/1.0" 
-  => La requte client met 3s  entrer (peut-tre un problme rseau), et la
-     connexion ('SC--') vers le serveur choue au bout de 4 tentatives de 2
-     secondes (retries 3 dans la conf), puis un code 503 est retourn au
-     client. Il y avait 115 connexions sur ce serveur, 202 connexions sur cette
-     instance, et 205 sur l'ensemble des instances pour ce processus. Il est
-     possible que le serveur ait refus la connexion parce qu'il y en avait
-     dj trop d'tablies.
-
-
-4.3) Modification des en-ttes HTTP
-----------------------------------
-En mode HTTP uniquement, il est possible de remplacer certains en-ttes dans la
-requte et/ou la rponse  partir d'expressions rgulires. Il est galement
-possible de bloquer certaines requtes en fonction du contenu des en-ttes ou
-de la requte. Une limitation cependant : les en-ttes fournis au milieu de
-connexions persistentes (keep-alive) ne sont pas vus car ils sont considrs
-comme faisant partie des changes de donnes conscutifs  la premire requte.
-Les donnes ne sont pas affectes, ceci ne s'applique qu'aux en-ttes. 
-
-La syntaxe est :
-   reqadd    <string>             pour ajouter un en-tte dans la requte
-   reqrep    <search> <replace>   pour modifier la requte
-   reqirep   <search> <replace>   idem sans distinction majuscules/minuscules
-   reqdel    <search>             pour supprimer un en-tte dans la requte
-   reqidel   <search>             idem sans distinction majuscules/minuscules
-   reqallow  <search>             autoriser la requte si un en-tte valide <search>
-   reqiallow <search>             idem sans distinction majuscules/minuscules
-   reqdeny   <search>             interdire la requte si un en-tte valide <search>
-   reqideny  <search>             idem sans distinction majuscules/minuscules
-   reqpass   <search>             inhibe ces actions sur les en-ttes validant <search>
-   reqipass  <search>             idem sans distinction majuscules/minuscules
-   reqtarpit <search>             bloquer et maintenir une request validant <search>
-   reqitarpit <search>            idem sans distinction majuscules/minuscules
-
-   rspadd   <string>              pour ajouter un en-tte dans la rponse
-   rsprep   <search> <replace>    pour modifier la rponse
-   rspirep  <search> <replace>    idem sans distinction majuscules/minuscules
-   rspdel   <search>              pour supprimer un en-tte dans la rponse
-   rspidel  <search>              idem sans distinction majuscules/minuscules
-   rspdeny  <search>              remplace la rponse par un HTTP 502 si un
-                                  en-tte valide <search>
-   rspideny <search>              idem sans distinction majuscules/minuscules
-
-
-<search> est une expression rgulire compatible POSIX regexp supportant le
-groupage par parenthses (sans les '\'). Les espaces et autres sparateurs
-doivent tres prcds d'un '\' pour ne pas tre confondus avec la fin de la
-chane. De plus, certains caractres spciaux peuvent tre prcds d'un
-backslach ('\') :
-
-  \t   pour une tabulation
-  \r   pour un retour charriot
-  \n   pour un saut de ligne
-  \    pour diffrencier un espace d'un sparateur
-  \#   pour diffrencier un dise d'un commentaire
-  \\   pour utiliser un backslash dans la regex
-  \\\\ pour utiliser un backslash dans le texte
-  \xXX pour un caractre spcifique XX (comme en C)
-
-
-<replace> contient la chane remplaant la portion vrifie par l'expression.
-Elle peut inclure les caractres spciaux ci-dessus, faire rfrence  un
-groupe dlimit par des parenthses dans l'expression rgulire, par sa
-position numrale. Les positions vont de 0  9, et sont codes par un '\'
-suivi du chiffre dsir (0 dsignant la ligne complte). Il est galement
-possible d'insrer un caractre non imprimable (utile pour le saut de ligne)
-inscrivant '\x' suivi du code hexadcimal de ce caractre (comme en C).
-
-<string> reprsente une chane qui sera ajoute systmatiquement aprs la
-dernire ligne d'en-tte.
-
-Remarques :
------------
-  - la premire ligne de la requte et celle de la rponse sont traites comme
-    des en-ttes, ce qui permet de rcrire des URL et des codes d'erreur.
-  - 'reqrep' est l'quivalent de 'cliexp' en version 1.0, et 'rsprep' celui de
-    'srvexp'. Ces noms sont toujours supports mais dconseills.
-  - pour des raisons de performances, le nombre total de caractres ajouts sur
-    une requte ou une rponse est limit  4096 depuis la version 1.1.5 (cette
-    limite tait  256 auparavant). Cette valeur est modifiable dans le code.
-    Pour un usage temporaire, on peut gagner de la place en supprimant quelques
-    en-ttes inutiles avant les ajouts.
-  - une requte bloque produira une rponse "HTTP 403 forbidden" tandis qu'une
-    rponse bloque produira une rponse "HTTP 502 Bad gateway".
-  - une requte bloque par 'reqtarpit' sera maintenue pendant une dure gale
-    au paramtre 'contimeout', ou jusqu' l'abandon du client. Rien ne sera
-    envoy au serveur. Lorsque le temps allou expire, le proxy rpondra avec
-    une rponse "500 server error" de sorte que l'attaquant ne suspecte pas
-    qu'il ait t bloqu. Les logs rapporteront aussi ce code 500, mais les
-    flags de terminaison indiqueront "PT".
-
-Exemples :
-----------
-        ###### a few examples ######
-
-        # rewrite 'online.fr' instead of 'free.fr' for GET and POST requests
-        reqrep        ^(GET\ .*)(.free.fr)(.*) \1.online.fr\3
-        reqrep        ^(POST\ .*)(.free.fr)(.*) \1.online.fr\3
-
-        # force proxy connections to close
-        reqirep        ^Proxy-Connection:.*        Proxy-Connection:\ close
-        # rewrite locations
-        rspirep        ^(Location:\ )([^:]*://[^/]*)(.*) \1\3
-
-        ###### A full configuration being used on production ######
-
-        # Every header should end with a colon followed by one space.
-        reqideny        ^[^:\ ]*[\ ]*$
-
-        # block Apache chunk exploit
-        reqideny        ^Transfer-Encoding:[\ ]*chunked
-        reqideny        ^Host:\ apache-
-
-        # block annoying worms that fill the logs...
-        reqideny        ^[^:\ ]*\ .*(\.|%2e)(\.|%2e)(%2f|%5c|/|\\\\)
-        reqideny        ^[^:\ ]*\ ([^\ ]*\ [^\ ]*\ |.*%00)
-        reqideny        ^[^:\ ]*\ .*<script
-        reqideny        ^[^:\ ]*\ .*/(root\.exe\?|cmd\.exe\?|default\.ida\?)
-
-	# tarpit attacks on the login page.
-        reqtarpit     ^[^:\ ]*\ .*\.php?login=[^0-9]
-
-        # allow other syntactically valid requests, and block any other method
-        reqipass        ^(GET|POST|HEAD|OPTIONS)\ /.*\ HTTP/1\.[01]$
-        reqipass        ^OPTIONS\ \\*\ HTTP/1\.[01]$
-        reqideny        ^[^:\ ]*\ 
-
-        # force connection:close, thus disabling HTTP keep-alive
-        option                httpclos
-
-        # change the server name
-        rspidel         ^Server:\ 
-        rspadd          Server:\ Formilux/0.1.8
-
-
-De plus, l'option 'forwardfor' ajoute l'adresse IP du client dans un champ
-'X-Forwarded-For' de la requte, ce qui permet  un serveur web final de
-connatre l'adresse IP du client initial. Depuis la version 1.3.8, il est
-possible de prciser le mot-cl "except" suivi d'une adresse ou un rseau
-IP source pour lequel l'entte ne sera pas ajout. C'est trs pratique dans le
-cas o un autre reverse-proxy ajoutant dj l'entte est install sur la mme
-machine ou dans une DMZ connue. Le cas le plus frquent est li  l'utilisation
-de stunnel en local.
-
-Enfin, l'option 'httpclose' apparue dans la version 1.1.28/1.2.1 supprime tout
-en-tte de type 'Connection:' et ajoute 'Connection: close' dans les deux sens.
-Ceci simplifie la dsactivation du keep-alive HTTP par rapport  l'ancienne
-mthode impliquant 4 rgles.
-
-Exemple :
----------
-    listen http_proxy 0.0.0.0:80
-        mode http
-        log  global
-        option httplog
-        option dontlognull
-        option forwardfor except 127.0.0.1/8
-        option httpclose
-
-Notons que certains serveurs HTTP ne referment pas ncessairement la session
-TCP en fin de traitement lorsqu'ils reoivent un entte 'Connection: close',
-ce qui se traduit par des grands nombres de sessions tablies et des temps
-globaux trs longs sur les requtes. Pour contourner ce problme, la version
-1.2.9 apporte une nouvelle option 'forceclose' qui referme la connexion sortant
-vers le serveur ds qu'il commence  rpondre et seulement si le tampon de
-requte est vide. Attention toutefois  ne PAS utiliser cette option si des
-mthodes CONNECT sont attendues entre le client et le serveur. L'option
-'forceclose' implique l'option 'httpclose'.
-
-Exemple :
----------
-    listen http_proxy 0.0.0.0:80
-        mode http
-        log  global
-        option httplog
-        option dontlognull
-        option forwardfor
-        option forceclose
-
-
-4.4) Rpartition avec persistence
----------------------------------
-La combinaison de l'insertion de cookie avec la rpartition de charge interne
-permet d'assurer une persistence dans les sessions HTTP d'une manire
-pratiquement transparente pour les applications. Le principe est simple :
-  - attribuer une valeur d'un cookie  chaque serveur
-  - effectuer une rpartition interne
-  - insrer un cookie dans les rponses issues d'une rpartition uniquement,
-    et faire en sorte que des caches ne mmorisent pas ce cookie.
-  - cacher ce cookie  l'application lors des requtes ultrieures.
-
-Exemple :
----------
-    listen application 0.0.0.0:80
-        mode http
-        cookie SERVERID insert nocache indirect
-        balance roundrobin
-        server srv1 192.168.1.1:80 cookie server01 check
-        server srv2 192.168.1.2:80 cookie server02 check
-
-L'autre solution apporte par les versions 1.1.30 et 1.2.3 est de rutiliser un
-cookie en provenance du serveur et de lui prfixer l'identifiant du serveur.
-Dans ce cas, ne pas oublier de forcer le mode "httpclose" pour empcher le
-client et le serveur de travailler en mode "keep-alive" afin que le proxy
-puisse corriger le nom du cookie dans toutes les futures requtes.
-
-    listen application 0.0.0.0:80
-       mode http
-       cookie JSESSIONID prefix
-       balance roundrobin
-       server srv1 192.168.1.1:80 cookie srv1 check
-       server srv2 192.168.1.2:80 cookie srv2 check
-       option httpclose
-
-
-4.5) Protection contre les fuites d'informations du serveur
------------------------------------------------------------
-Dans les versions 1.1.28 et 1.2.1, une nouvelle option 'checkcache' a t
-cre. Elle sert  inspecter minutieusement les en-ttes 'Cache-control',
-'Pragma', et 'Set-cookie' dans les rponses serveur pour dterminer s'il y a
-un risque de cacher un cookie sur un proxy ct client. Quand cette option est
-active, les seules rponses qui peuvent tre retournes au client sont :
-  - toutes celles qui n'ont pas d'en-tte 'Set-cookie' ;
-  - toutes celles qui ont un code de retour autre que 200, 203, 206, 300, 301, 
-    410, sauf si le serveur a positionn un en-tte 'Cache-control: public' ;
-  - celles qui font suite  une requte POST, sauf si le serveur a positionn
-    un en-tte 'Cache-control: public' ;
-  - celles qui ont un en-tte 'Pragma: no-cache' ;
-  - celles qui ont un en-tte 'Cache-control: private' ; 
-  - celles qui ont un en-tte 'Cache-control: no-store' ; 
-  - celles qui ont un en-tte 'Cache-control: max-age=0' ;
-  - celles qui ont un en-tte 'Cache-control: s-maxage=0' ;
-  - celles qui ont un en-tte 'Cache-control: no-cache' ;
-  - celles qui ont un en-tte 'Cache-control: no-cache="set-cookie"' ;
-  - celles qui ont un en-tte 'Cache-control: no-cache="set-cookie,'
-    (autorisant d'autres champs aprs set-cookie).
-
-Si une rponse ne respecte pas ces pr-requis, alors elle sera bloque de la
-mme manire que s'il s'agissait d'un filtre 'rspdeny', avec en retour un
-message "HTTP 502 bad gateway". L'tat de session montre "PH--" ce qui veut
-dire que c'est le proxy qui a bloqu la rponse durant le traitement des
-en-ttes. De plus, un message d'alerte sera envoy dans les logs de sorte que
-l'administrateur sache qu'il y a une action correctrice  entreprendre.
-
-4.6) Personalisation des erreurs
---------------------------------
-Certaines situations conduisent  retourner une erreur HTTP au client :
-  - requte invalide ou trop longue => code HTTP 400
-  - requte mettant trop de temps  venir => code HTTP 408
-  - requte interdite (bloque par un reqideny) => code HTTP 403
-  - erreur interne du proxy => code HTTP 500
-  - le serveur a retourn une rponse incomplte ou invalide => code HTTP 502
-  - aucun serveur disponible pour cette requte => code HTTP 503
-  - le serveur n'a pas rpondu dans le temps imparti => code HTTP 504
-
-Un message d'erreur succint tir de la RFC accompagne ces codes de retour.
-Cependant, en fonction du type de clientle, on peut prfrer retourner des
-pages personnalises. Ceci est possible de deux manires, l'une reposant sur
-une redirection vers un serveur connu, et l'autre consistant  retourner un
-fichier local.
-
-4.6.1) Redirection
-------------------
-Une redirection d'erreur est assure par le biais de la commande "errorloc" :
-
-    errorloc <code_HTTP> <location>
-
-Au lieu de gnrer une erreur HTTP <code_HTTP> parmi les codes cits ci-dessus,
-le proxy gnrera un code de redirection temporaire (HTTP 302) vers l'adresse
-d'une page prcise dans <location>. Cette adresse peut tre relative au site,
-ou absolue. Comme cette rponse est trate par le navigateur du client
-lui-mme, il est indispensable que l'adresse fournie lui soit accessible.
-
-Exemple :
----------
-    listen application 0.0.0.0:80
-        errorloc 400 /badrequest.html
-        errorloc 403 /forbidden.html
-        errorloc 408 /toolong.html
-        errorloc 500 http://haproxy.domain.net/bugreport.html
-        errorloc 502 http://192.168.114.58/error50x.html
-        errorloc 503 http://192.168.114.58/error50x.html
-        errorloc 504 http://192.168.114.58/error50x.html
-
-Note: la RFC2616 stipule qu'un client doit rutiliser la mme mthode pour
-accder  l'URL de redirection que celle qui l'a retourne, ce qui pose des
-problmes avec les requtes POST. Le code de retour 303 a t cr exprs pour
-rgler ce problme, indiquant au client qu'il doit accder  l'URL retourne
-dans le champ Location avec la mthode GET uniquement. Seulement, certains
-navigateurs antrieurs  HTTP/1.1 ne connaissent pas ce code de retour. De
-plus, la plupart des navigateurs se comportent dj avec le code 302 comme ils
-devraient le faire avec le 303. Donc, dans le but de laisser le choix 
-l'utilisateur, les versions 1.1.31 et 1.2.5 apportent deux nouvelles commandes
-visant  remplacer 'errorloc' : 'errorloc302' et 'errorloc303'.
-
-Leur usage non ambig est recommand  la place de la commande 'errorloc' (qui
-utilise toujours 302). Dans le doute, prfrez l'utilisation de 'errorloc303'
-ds que vous savez que vos clients supportent le code de retour HTTP 303.
-
-4.6.2) Fichiers locaux
-----------------------
-Parfois il est souhaitable de changer l'erreur retourne sans recourir  des
-redirections. La seconde mthode consiste  charger des fichiers locaux lors
-du dmarrage et  les envoyer en guise de pur contenu HTTP en cas d'erreur.
-C'est ce que fait le mot cl 'errorfile'.
-
-Attention, il y a des piges  prendre en compte :
- - les fichiers sont chargs durant l'analyse de la configuration, avant de
-   faire le chroot(). Donc ils sont relatifs au systme de fichiers rel. Pour
-   cette raison, il est recommand de toujours passer un chemin absolu vers ces
-   fichiers.
-
- - le contenu de ces fichiers n'est pas du HTML mais vraiment du protocole HTTP
-   avec potentiellement un corps HTML. Donc la premire ligne et les en-ttes
-   sont obligatoires. Idalement, chaque ligne dans la partie HTTP devrait se
-   terminer par un CR-LF pour un maximum de compatibilit.
-
- - les rponses sont limites  une taille de buffer (BUFSIZE), gnralement 8
-   ou 16 ko.
-
- - les rponses ne devraient pas inclure de rfrences aux serveurs locaux,
-   afin de ne pas risquer de crer des boucles infinies sur le navigateur dans
-   le cas d'une panne locale.
-
-Exemple :
----------
-        errorfile 400 /etc/haproxy/errorfiles/400badreq.http
-        errorfile 403 /etc/haproxy/errorfiles/403forbid.http
-        errorfile 503 /etc/haproxy/errorfiles/503sorry.http
-
-
-4.7) Changement des valeurs par dfaut
---------------------------------------
-Dans la version 1.1.22 est apparue la notion de valeurs par dfaut, ce qui
-vite de rpter des paramtres communs  toutes les instances, tels que les
-timeouts, adresses de log, modes de fonctionnement, etc.
-
-Les valeurs par dfaut sont positionnes dans la dernire section 'defaults'
-prcdent l'instance qui les utilisera. On peut donc mettre autant de sections
-'defaults' que l'on veut. Il faut juste se rappeler que la prsence d'une telle
-section implique une annulation de tous les paramtres par dfaut positionns
-prcdemment, dans le but de les remplacer.
-
-La section 'defaults' utilise la mme syntaxe que la section 'listen', aux
-paramtres prs qui ne sont pas supports. Le mot cl 'defaults' peut accepter
-un commentaire en guise paramtre.
-
-Dans la version 1.1.28/1.2.1, seuls les paramtres suivants peuvent tre
-positionns dans une section 'defaults' :
-  - log (le premier et le second)
-  - mode { tcp, http, health }
-  - balance { roundrobin }
-  - disabled (pour dsactiver toutes les instances qui suivent)
-  - enabled (pour faire l'opration inverse, mais c'est le cas par dfaut)
-  - contimeout, clitimeout, srvtimeout, grace, retries, maxconn
-  - option { redispatch, transparent, keepalive, forwardfor, logasap, httpclose,
-             checkcache, httplog, tcplog, dontlognull, persist, httpchk }
-  - redispatch, redisp, transparent, source { addr:port }
-  - cookie, capture
-  - errorloc
-
-Ne sont pas supports dans cette version, les adresses de dispatch et les
-configurations de serveurs, ainsi que tous les filtres bass sur les
-expressions rgulires :
-  - dispatch, server,
-  - req*, rsp*
-
-Enfin, il n'y a pas le moyen, pour le moment, d'invalider un paramtre boolen
-positionn par dfaut. Donc si une option est spcifie dans les paramtres par
-dfaut, le seul moyen de la dsactiver pour une instance, c'est de changer les
-paramtres par dfaut avant la dclaration de l'instance.
-
-Exemples :
-----------
-    defaults applications TCP
-        log global
-        mode tcp
-        balance roundrobin
-        clitimeout 180000
-        srvtimeout 180000
-        contimeout 4000
-        retries 3
-        redispatch
-
-    listen app_tcp1 10.0.0.1:6000-6063
-        server srv1 192.168.1.1 check port 6000 inter 10000
-        server srv2 192.168.1.2 backup
-
-    listen app_tcp2 10.0.0.2:6000-6063
-        server srv1 192.168.2.1 check port 6000 inter 10000
-        server srv2 192.168.2.2 backup
-    
-    defaults applications HTTP
-        log global
-        mode http
-        option httplog
-        option forwardfor
-        option dontlognull
-        balance roundrobin
-        clitimeout 20000
-        srvtimeout 20000
-        contimeout 4000
-        retries 3
-
-    listen app_http1 10.0.0.1:80-81
-        cookie SERVERID postonly insert indirect
-        capture cookie userid= len 10
-        server srv1 192.168.1.1:+8000 cookie srv1 check port 8080 inter 1000
-        server srv1 192.168.1.2:+8000 cookie srv2 check port 8080 inter 1000
-
-    defaults
-        # section vide qui annule tous les paramtes par dfaut.
-
-
-4.8) Rapport d'tat sous forme de page HTML
--------------------------------------------
-Avec la version 1.2.14, il devient possible pour haproxy d'interceptre des
-requtes pour une URI particulire et de retourner un rapport complet d'tat de
-l'activit du proxy, et des statistiques sur les serveurs. Ceci est disponible
-via le mot cl "stats" associ  n'importe laquelle de ces options :
-
-   - stats enable
-   - stats uri <uri prefix>
-   - stats realm <authentication realm>
-   - stats auth <user:password>
-   - stats scope <proxy_id> | '.'
-
-
-Par dfaut, le rapport est dsactiv. Le fait de spcifier une des combinaision
-ci-dessus active le rapport pour l'instance de proxy qui le rfrence. La
-solution la plus simple est d'utiliser "stats enable" qui activera le rapport
-avec les paramtres par dfaut suivant :
-
-   - default URI   : "/haproxy?stats"        (CONFIG_STATS_DEFAULT_URI)
-   - default auth  : non spcifi (pas d'authentication)
-   - default realm : "HAProxy Statistics"    (CONFIG_STATS_DEFAULT_REALM)
-   - default scope : non specifi (accs  toutes les instances)
-
-L'option "stats uri <uri_prefix>" permet d'intercepter un autre prfixe d'URI
-que celui par dfaut. Noter que n'importe quelle URI qui COMMENCE avec cette
-chane sera valide. Par exemple, une instance pourrait tre ddie  la page
-d'tat seulement et rpondre  toute URI.
-
-Example :
----------
-    # intercepte n'importe quelle URI et retourne la page d'tat.
-    listen stats :8080
-        mode http
-        stats uri /
-
-
-L'option "stats auth <user:password>" active l'authentification "Basic" et
-ajoute un couple "user:password" valide  la liste des comptes autoriss.
-L'utilisateur <user> et le mot de passe <password> doivent tre prciss
-en clair dans le fichier de configuration, et comme ceci est de
-l'authentification HTTP "Basic", il faut tre conscient qu'ils transitent en
-clair sur le rseau, donc il ne faut pas utiliser de compte sensible. La liste
-est illimite dans le but de pouvoir fournir des accs facilement  des
-dveloppeurs ou  des clients.
-
-L'option "stats realm <realm>" dfinit le "domaine" ("realm") de validit du
-mot de passe qui sera prsent dans la bote de dialogue du navigateur
-lorsqu'il demandera un compte utilisateur et un mot de passe. Il est important
-de s'assurer que celui-ci soit diffrent de ceux utiliss par l'application,
-autrement le navigateur tentera d'en utiliser un cach depuis l'application.
-Noter que les espaces dans le nom de "realm" doivent tre protgs par un
-backslash ('\').
-
-L'option "stats scope <proxy_id>" limite la porte du rapport d'tat. Par
-dfaut, toutes les instances proxy sont listes. Mais dans certaines
-circonstances, il serait prfrable de ne lister que certains proxies ou
-simplement le proxy courant. C'est ce que fait cette option. Le nom spcial "."
-(un simple point) rfrence le proxy courant. Cette option peut tre rpte
-autant de fois que ncessaire pour autoriser d'autres proxies, mme pour des
-noms rfrencs plus loin dans la configuration ou bien des noms qui n'existent
-pas encore. Le nom prcis est celui qui apparait aprs le mot cl "listen".
-
-Exemple :
----------
-    # simple application embarquant la page d'tat authentifie
-    listen app1 192.168.1.100:80
-        mode http
-        option httpclose
-        balance roundrobin
-        cookie SERVERID postonly insert indirect
-        server srv1 192.168.1.1:8080 cookie srv1 check inter 1000
-        server srv1 192.168.1.2:8080 cookie srv2 check inter 1000
-        stats uri /my_stats
-        stats realm Statistics\ for\ MyApp1-2
-        stats auth guest:guest
-        stats auth admin:AdMiN123
-        stats scope .
-        stats scope app2
-
-    # simple application embarquant la page d'tat sans authentification
-    listen app2 192.168.2.100:80
-        mode http
-        option httpclose
-        balance roundrobin
-        cookie SERVERID postonly insert indirect
-        server srv1 192.168.2.1:8080 cookie srv1 check inter 1000
-        server srv1 192.168.2.2:8080 cookie srv2 check inter 1000
-        stats uri /my_stats
-        stats realm Statistics\ for\ MyApp2
-        stats scope .
-
-    listen admin_page :8080
-        mode http
-        stats uri /my_stats
-        stats realm Global\ statistics
-        stats auth admin:AdMiN123
-
-Notes :
--------
-  - les options "stats" peuvent aussi tre spcifies dans une section
-    "defaults", auquel cas la mme configuration exactement sera fournie 
-    toutes les instances suivantes, d'o l'utilit du scope ".". Toutefois, si
-    une instance redfinit n'importe quel paramtre "stats", alors les dfauts
-    ne lui seront pas appliqus.
-
-  - l'authentification "Basic" est trs simpliste et non scurise contre la
-    capture rseau. Aucun mot de passe sensible ne doit tre utilis, et il
-    est bon de savoir qu'il n'existe pas de moyen de le supprimer du navigateur
-    aprs usage, donc il sera envoy tel quel  l'application au cours des
-    accs successifs.
-
-  - Il est trs important de prciser l'option "httpclose", sinon le proxy ne
-    sera pas en mesure de dtecter les URI dans les sessions keep-alive
-    maintenues entre le navigateur et les serveurs, donc les URI de stats
-    seront transmises telles quelles aux serveurs comme si l'option n'tait
-    pas prcise.
-
-
-5) Listes d'accs
-=================
-
-Avec la version 1.3.10, un nouveau concept de listes d'accs (ACL) a vu le
-jour. Comme il n'tait pas ncessaire de rinventer la roue, et du fait que
-toutes les rflexions passes aboutissaient  des propositions non
-satisfaisantes, il a finalement t dcid que quelque chose de proche de ce
-que Squid offre serait un bon compromis entre une richesse fonctionnelle et une
-facilit d'utilisation
-
-Le principe est trs simple : les ACLs sont dclares avec un nom, un test et
-une liste de valeurs valides  tester. Des conditions sont appliques sur
-diverses actions, et ces conditions effectuent un ET logique entre les ACLs. La
-condition n'est donc valide que si toutes les ACLs sont vraies.
-
-Il est galement possible d'utiliser le mot rserv "OR" dans les conditions,
-et il est possible pour une ACL d'tre spcifie plusieurs fois, mme avec des
-tests diffrents, auquel cas le premier test russi validera l'ACL.
-
-Au stade de la version 1.3.12, seuls les tests suivants ont t implments :
-
-   Niveaux 3/4 :
-     src       <ipv4_address>[/mask] ... : match IPv4 source address
-     dst       <ipv4_address>[/mask] ... : match IPv4 destination address
-     src_port  <range> ...               : match source port range
-     dst_port  <range> ...               : match destination port range
-     dst_conn  <range> ...               : match #connections on frontend
-
-   Niveau 7 :
-     method    <HTTP method> ...  : match HTTP method
-     req_ver   <1.0|1.1> ...      : match HTTP request version
-     resp_ver  <1.0|1.1> ...      : match HTTP response version
-     status    <range> ...        : match HTTP response status code in range
-     url       <string> ... : exact string match on URI
-     url_reg   <regex>  ... : regex string match on URI
-     url_beg   <string> ... : true if URI begins with <string>
-     url_end   <string> ... : true if URI ends with <string>
-     url_sub   <string> ... : true if URI contains <string>
-     url_dir   <string> ... : true if URI contains <string> between slashes
-     url_dom   <string> ... : true if URI contains <string> between slashes or dots
-
-Une plage ('range') est constitue d'un ou deux entiers qui peuvent tre
-prfixs d'un oprateur. La syntaxe est :
-
-  [<op>] <min>[:<max>]
-
-Avec <op> pouvant tre :
-  'eq' : la valeur doit galer <min> ou tre comprise entre <min> et <max>
-  'le' : la valeur doit tre infrieure ou gale  <min>
-  'lt' : la valeur doit tre strictement infrieure  <min>
-  'ge' : la valeur doit tre suprieure ou gale  <min>
-  'gt' : la valeur doit tre strictement suprieure  <min>
-
-Lorsqu'aucun oprateur n'est dfini, 'eq' est employ. Noter que lorsqu'un
-oprateur est spcifi, il s'applique  toutes les plages de valeurs suivantes
-jusqu' la fin de la ligne ou bien jusqu' ce qu'un nouvel oprateur soit
-prcis. Exemple :
-
-  acl status_error  status   400:599
-  acl saturated_frt dst_conn ge 1000
-  acl invalid_ports src_port lt 512 ge 65535
-
-D'autres tests arrivent (enttes, cookies, heure, authentification), c'est
-juste une question de temps. Il est aussi prvu de permettre de lire les
-valeurs depuis un fichier, ainsi que d'ignorer la casse pour certains tests.
-
-La seule commande supportant les conditions d'ACL  ce jour est la nouvelle
-commande "block" qui bloque une requte et retourne un statut 403 si sa
-condition est valide (cas du "if") ou invalide (cas du "unless").
-
-Exemple :
----------
-
-    acl options_uris  url *
-    acl meth_option   method OPTIONS
-    acl http_1.1      req_ver 1.1
-    acl allowed_meth  method GET HEAD POST OPTIONS CONNECT
-    acl connect_meth  method CONNECT
-    acl proxy_url     url_beg http://
-
-    # block if reserved URI "*" used with a method other than "OPTIONS"
-    block if options_uris !meth_option
-
-    # block if the OPTIONS method is used with HTTP 1.0
-    block if meth_option !http_1.1
-
-    # allow non-proxy url with anything but the CONNECT method
-    block if !connect_meth !proxy_url
-
-    # block all unknown methods
-    block unless allowed_meth
-
-Note: Cette documentation est embryonnaire mais doit permettre de dmarrer et
-surtout d'avancer sur le projet sans tre trop ralenti par la documentation.
-
-
-=======================
-| Paramtrage systme |
-=======================
-
-Sous Linux 2.4
-==============
-
--- cut here --
-#!/bin/sh
-# set this to about 256/4M (16384 for 256M machine)
-MAXFILES=16384
-echo $MAXFILES > /proc/sys/fs/file-max
-ulimit -n $MAXFILES
-
-if [ -e /proc/sys/net/ipv4/ip_conntrack_max ]; then
-        echo 65536 > /proc/sys/net/ipv4/ip_conntrack_max
-fi
-
-if [ -e /proc/sys/net/ipv4/netfilter/ip_ct_tcp_timeout_fin_wait ]; then
-        # 30 seconds for fin, 15 for time wait
-        echo 3000 > /proc/sys/net/ipv4/netfilter/ip_ct_tcp_timeout_fin_wait
-        echo 1500 > /proc/sys/net/ipv4/netfilter/ip_ct_tcp_timeout_time_wait
-        echo 0 > /proc/sys/net/ipv4/netfilter/ip_ct_tcp_log_invalid_scale
-        echo 0 > /proc/sys/net/ipv4/netfilter/ip_ct_tcp_log_out_of_window
-fi
-
-echo 1024 60999 > /proc/sys/net/ipv4/ip_local_port_range
-echo 30 > /proc/sys/net/ipv4/tcp_fin_timeout
-echo 4096 > /proc/sys/net/ipv4/tcp_max_syn_backlog
-echo 262144 > /proc/sys/net/ipv4/tcp_max_tw_buckets
-echo 262144 > /proc/sys/net/ipv4/tcp_max_orphans
-echo 300 > /proc/sys/net/ipv4/tcp_keepalive_time
-echo 1 > /proc/sys/net/ipv4/tcp_tw_recycle
-echo 0 > /proc/sys/net/ipv4/tcp_timestamps
-echo 0 > /proc/sys/net/ipv4/tcp_ecn
-echo 1 > /proc/sys/net/ipv4/tcp_sack
-echo 0 > /proc/sys/net/ipv4/tcp_dsack
-
-# auto-tuned on 2.4
-#echo 262143 > /proc/sys/net/core/rmem_max
-#echo 262143 > /proc/sys/net/core/rmem_default
-
-echo 16384 65536 524288 > /proc/sys/net/ipv4/tcp_rmem
-echo 16384 349520 699040 > /proc/sys/net/ipv4/tcp_wmem
-
--- cut here --
-
-Sous FreeBSD
-============
-
-Un port de HA-Proxy sous FreeBSD est dsormais disponible, grce 
-Clement Laforet <sheepkiller@cultdeadsheep.org>.
-
-Pour plus d'informations :
-http://www.freebsd.org/cgi/url.cgi?ports/net/haproxy/pkg-descr
-http://www.freebsd.org/cgi/cvsweb.cgi/ports/net/haproxy/
-http://www.freshports.org/net/haproxy
-
-
--- fin --
diff --git a/deps/haproxy-1.4.21/doc/haproxy.1 b/deps/haproxy-1.4.21/doc/haproxy.1
deleted file mode 100644
index 001de15..0000000
--- a/deps/haproxy-1.4.21/doc/haproxy.1
+++ /dev/null
@@ -1,174 +0,0 @@
-.TH HAPROXY 1 "17 August 2007" 
-
-.SH NAME
-
-HAProxy \- fast and reliable http reverse proxy and load balancer
-
-.SH SYNOPSIS
-
-haproxy \-f <configuration\ file> [\-n\ maxconn] [\-N\ maxconn] [\-d] [\-D] [\-q] [\-V] [\-c] [\-p\ <pidfile>] [\-s] [\-l] [\-dk] [\-ds] [\-de] [\-dp] [\-db] [\-m\ <megs>] [{\-sf|\-st}\ pidlist...] 
-
-.SH DESCRIPTION
-
-HAProxy is a TCP/HTTP reverse proxy which is particularly suited for
-high availability environments. Indeed, it can:
- \- route HTTP requests depending on statically assigned cookies ;
- \- spread the load among several servers while assuring server
-   persistence through the use of HTTP cookies ;
- \- switch to backup servers in the event a main one fails ;
- \- accept connections to special ports dedicated to service
-   monitoring ;
- \- stop accepting connections without breaking existing ones ;
- \- add/modify/delete HTTP headers both ways ;
- \- block requests matching a particular pattern ;
- \- hold clients to the right application server depending on
-   application cookies
- \- report detailed status as HTML pages to authenticated users from an
-   URI intercepted from the application.
-
-It needs very little resource. Its event-driven architecture allows it
-to easily handle thousands of simultaneous connections on hundreds of
-instances without risking the system's stability.
-
-.SH OPTIONS
-
-.TP
-\fB\-f <configuration file>\fP
-Specify configuration file path.
-
-.TP
-\fB\-n <maxconn>\fP
-Set the high limit for the total number of simultaneous connections.
-
-.TP
-\fB\-N <maxconn>\fP
-Set the high limit for the per-listener number of simultaneous connections.
-
-.TP
-\fB\-d\fP
-Start in foregreound with debugging mode enabled.
-When the proxy runs in this mode, it dumps every connections,
-disconnections, timestamps, and HTTP headers to stdout. This should
-NEVER be used in an init script since it will prevent the system from
-starting up.
-
-.TP
-\fB\-D\fP
-Start in daemon mode.
-
-.TP
-\fB\-q\fP
-Disable messages on output.
-
-.TP
-\fB\-V\fP
-Displays messages on output even when \-q or 'quiet' are specified. Some
-information about pollers and config file are displayed during startup.
-
-.TP
-\fB\-c\fP
-Only checks config file and exits with code 0 if no error was found, or
-exits with code 1 if a syntax error was found.
-
-.TP
-\fB\-p <pidfile>\fP
-Ask the process to write down each of its children's pids to this file
-in daemon mode.
-
-.TP
-\fB\-s\fP
-Show statistics (only if compiled in).
-Statistics are only available if compiled in with the 'STATTIME' option.
-It's only used during code optimization phases, and will soon disappear.
-
-.TP
-\fB\-l\fP
-Show even more statistics (implies '\-s').
-
-.TP
-\fB\-dk\fP
-Disable use of kqueue(). kqueue() is available only on BSD systems.
-
-.TP
-\fB\-ds\fP
-Disable use of speculative epoll(). epoll() is available only on Linux 2.6
-and some custom Linux 2.4 systems.
-
-.TP
-\fB\-de\fP
-Disable use of epoll(). epoll() is available only on Linux 2.6
-and some custom Linux 2.4 systems.
-
-.TP
-\fB\-dp\fP
-Disables use of poll(). select() might be used instead.
-
-.TP
-\fB\-db\fP
-Disables background mode (stays in foreground, useful for debugging).
-For debugging, the '\-db' option is very useful as it temporarily
-disables daemon mode and multi-process mode. The service can then be
-stopped by simply pressing Ctrl-C, without having to edit the config nor
-run full debug.
-
-.TP
-\fB\-m <megs>\fP
-Enforce a memory usage limit to a maximum of <megs> megabytes.
-
-.TP
-\fB\-sf <pidlist>\fP
-Send FINISH signal to the pids in pidlist after startup. The processes
-which receive this signal will wait for all sessions to finish before
-exiting. This option must be specified last, followed by any number of
-PIDs. Technically speaking, \fBSIGTTOU\fP and \fBSIGUSR1\fP are sent.
-
-.TP
-\fB\-st <pidlist>\fP
-Send TERMINATE signal to the pids in pidlist after startup. The processes
-which receive this signal will wait immediately terminate, closing all
-active sessions. This option must be specified last, followed by any number
-of PIDs. Technically speaking, \fBSIGTTOU\fP and \fBSIGTERM\fP are sent.
-
-.SH LOGGING
-Since HAProxy can run inside a chroot, it cannot reliably access /dev/log.
-For this reason, it uses the UDP protocol to send its logs to the server,
-even if it is the local server. People who experience trouble receiving
-logs should ensure that their syslog daemon listens to the UDP socket.
-Several Linux distributions which ship with syslogd from the sysklogd
-package have UDP disabled by default. The \fB\-r\fP option must be passed
-to the daemon in order to enable UDP.
-
-.SH SIGNALS
-Some signals have a special meaning for the haproxy daemon. Generally, they are used between daemons and need not be used by the administrator.
-.TP
-\- \fBSIGUSR1\fP
-Tells the daemon to stop all proxies and exit once all sessions are closed. It is often referred to as the "soft-stop" signal.
-.TP
-\- \fBSIGTTOU\fP
-Tells the daemon to stop listening to all sockets. Used internally by \fB\-sf\fP and \fB\-st\fP.
-.TP
-\- \fBSIGTTIN\fP
-Tells the daemon to restart listening to all sockets after a \fBSIGTTOU\fP. Used internally when there was a problem during hot reconfiguration.
-.TP
-\- \fBSIGINT\fP and \fBSIGTERM\fP
-Both signals can be used to quickly stop the daemon.
-.TP
-\- \fBSIGHUP\fP
-Dumps the status of all proxies and servers into the logs. Mostly used for trouble-shooting purposes.
-.TP
-\- \fBSIGQUIT\fP
-Dumps information about memory pools into the logs. Mostly used for debugging purposes.
-.TP
-\- \fBSIGPIPE\fP
-This signal is intercepted and ignored on systems without \fBMSG_NOSIGNAL\fP.
-
-.SH SEE ALSO
-
-A much better documentation can be found in haproxy-en.txt. On debian
-systems, you can find this file in
-/usr/share/doc/haproxy/haproxy-en.txt.gz.
-
-.SH AUTHOR
-
-HAProxy was written by Willy Tarreau. This man page was written by Arnaud Cornet and Willy Tarreau.
-
diff --git a/deps/haproxy-1.4.21/doc/internals/connect-status.txt b/deps/haproxy-1.4.21/doc/internals/connect-status.txt
deleted file mode 100644
index 70bbcc5..0000000
--- a/deps/haproxy-1.4.21/doc/internals/connect-status.txt
+++ /dev/null
@@ -1,28 +0,0 @@
-Normally, we should use getsockopt(fd, SOL_SOCKET, SO_ERROR) on a pending
-connect() to detect whether the connection correctly established or not.
-
-Unfortunately, getsockopt() does not report the status of a pending connection,
-which means that it returns 0 if the connection is still pending. This has to
-be expected, because as the name implies it, it only returns errors.
-
-With the speculative I/O, a new problem was introduced : if we pretend the
-socket was indicated as ready and we go to the socket's write() function,
-a pending connection will then inevitably be identified as established.
-
-In fact, there are solutions to this issue :
-
-  - send() returns -EAGAIN if it cannot write, so that as long as there are
-    pending data in the buffer, we'll be informed about the status of the
-    connection
-
-  - connect() on an already pending connection will return -1 with errno set to
-    one of the following values :
-      - EALREADY : connection already in progress
-      - EISCONN  : connection already established
-      - anything else will indicate an error.
-
-=> So instead of using getsockopt() on a pending connection with no data, we
-   will switch to connect(). This implies that the connection address must be
-   known within the socket's write() function.
-
-
diff --git a/deps/haproxy-1.4.21/doc/internals/connection-header.txt b/deps/haproxy-1.4.21/doc/internals/connection-header.txt
deleted file mode 100644
index 99e4549..0000000
--- a/deps/haproxy-1.4.21/doc/internals/connection-header.txt
+++ /dev/null
@@ -1,196 +0,0 @@
-2010/01/16 - Connection header adjustments depending on the transaction mode.
-
-
-HTTP transactions supports 5 possible modes :
-
-   WANT_TUN             : default, nothing changed
-   WANT_TUN + httpclose : headers set for close in both dirs
-   WANT_KAL             : keep-alive desired in both dirs
-   WANT_SCL             : want close with the server and KA with the client
-   WANT_CLO             : want close on both sides.
-
-When only WANT_TUN is set, nothing is changed nor analysed, so for commodity
-below, we'll refer to WANT_TUN+httpclose as WANT_TUN.
-
-The mode is adjusted in 3 steps :
-   - configuration sets initial mode
-   - request headers set required request mode
-   - response headers set the final mode
-
-
-1) Adjusting the initial mode via the configuration
-
-   option httpclose         => TUN
-   option http-keep-alive   => KAL
-   option http-server-close => SCL
-   option forceclose        => CLO
-
-Note that option httpclose combined with any other option is equivalent to
-forceclose.
-
-
-2) Adjusting the request mode once the request is parsed
-
-If we cannot determine the body length from the headers, we set the mode to CLO
-but later we'll switch to tunnel mode once forwarding the body. That way, all
-parties are informed of the correct mode.
-
-Depending on the request version and request Connection header, we may have to
-adjust the current transaction mode and to update the connection header.
-
-mode   req_ver  req_hdr    new_mode   hdr_change
-TUN    1.0         -        TUN        -
-TUN    1.0        ka        TUN       del_ka
-TUN    1.0       close      TUN       del_close
-TUN    1.0       both       TUN       del_ka, del_close
-
-TUN    1.1         -        TUN       add_close
-TUN    1.1        ka        TUN       del_ka, add_close
-TUN    1.1       close      TUN        -
-TUN    1.1       both       TUN       del_ka
-
-KAL    1.0         -        CLO        -
-KAL    1.0        ka        KAL        -
-KAL    1.0       close      CLO       del_close
-KAL    1.0       both       CLO       del_ka, del_close
-
-KAL    1.1         -        KAL        -
-KAL    1.1        ka        KAL       del_ka
-KAL    1.1       close      CLO        -
-KAL    1.1       both       CLO       del_ka
-
-SCL    1.0         -        CLO        -
-SCL    1.0        ka        SCL       del_ka
-SCL    1.0       close      CLO       del_close
-SCL    1.0       both       CLO       del_ka, del_close
-
-SCL    1.1         -        SCL       add_close
-SCL    1.1        ka        SCL       del_ka, add_close
-SCL    1.1       close      CLO        -
-SCL    1.1       both       CLO       del_ka
-
-CLO    1.0         -        CLO        -
-CLO    1.0        ka        CLO       del_ka
-CLO    1.0       close      CLO       del_close
-CLO    1.0       both       CLO       del_ka, del_close
-
-CLO    1.1         -        CLO       add_close
-CLO    1.1        ka        CLO       del_ka, add_close
-CLO    1.1       close      CLO        -
-CLO    1.1       both       CLO       del_ka
-
-=> Summary:
-   - KAL and SCL are only possible with the same requests :
-     - 1.0 + ka
-     - 1.1 + ka or nothing
-
-   - CLO is assumed for any non-TUN request which contains at least a close
-     header, as well as for any 1.0 request without a keep-alive header.
-
-   - del_ka is set whenever we want a CLO or SCL or TUN and req contains a KA,
-     or when the req is 1.1 and contains a KA.
-
-   - del_close is set whenever a 1.0 request contains a close.
-
-   - add_close is set whenever a 1.1 request must be switched to TUN, SCL, CLO
-     and did not have a close hdr.
-
-Note that the request processing is performed in two passes, one with the
-frontend's config and a second one with the backend's config. It is only
-possible to "raise" the mode between them, so during the second pass, we have
-no reason to re-add a header that we previously removed. As an exception, the
-TUN mode is converted to CLO once combined because in fact it's an httpclose
-option set on a TUN mode connection :
-
-                    BE (2)
-            | TUN  KAL  SCL  CLO
-        ----+----+----+----+----
-        TUN | TUN  CLO  CLO  CLO
-            +
-        KAL | CLO  KAL  SCL  CLO
-    FE      +
-    (1) SCL | CLO  SCL  SCL  CLO
-            +
-        CLO | CLO  CLO  CLO  CLO
-
-
-3) Adjusting the final mode once the response is parsed
-
-This part becomes trickier. It is possible that the server responds with a
-version that the client does not necessarily understand. Obviously, 1.1 clients
-are asusmed to understand 1.0 responses. The problematic case is a 1.0 client
-receiving a 1.1 response without any Connection header. Some 1.0 clients might
-know that in 1.1 this means "keep-alive" while others might ignore the version
-and assume a "close". Since we know the version on both sides, we may have to
-adjust some responses to remove any ambiguous case. That's the reason why the
-following table considers both the request and the response version. If the
-response length cannot be determined, we switch to CLO mode.
-
-mode   res_ver res_hdr    req_ver  new_mode   hdr_change
-TUN    1.0        -       any       TUN        -
-TUN    1.0       ka       any       TUN       del_ka
-TUN    1.0      close     any       TUN       del_close
-TUN    1.0      both      any       TUN       del_ka, del_close
-
-TUN    1.1        -       any       TUN       add_close
-TUN    1.1       ka       any       TUN       del_ka, add_close
-TUN    1.1      close     any       TUN        -
-TUN    1.1      both      any       TUN       del_ka
-
-KAL    1.0        -       any       SCL       add_ka
-KAL    1.0       ka       any       KAL        -
-KAL    1.0      close     any       SCL       del_close, add_ka
-KAL    1.0      both      any       SCL       del_close
-
-KAL    1.1        -       1.0       KAL       add_ka
-KAL    1.1        -       1.1       KAL        -
-KAL    1.1       ka       1.0       KAL        -
-KAL    1.1       ka       1.1       KAL       del_ka
-KAL    1.1      close     1.0       SCL       del_close, add_ka
-KAL    1.1      close     1.1       SCL       del_close
-KAL    1.1      both      1.0       SCL       del_close
-KAL    1.1      both      1.1       SCL       del_ka, del_close
-
-SCL    1.0        -       any       SCL       add_ka
-SCL    1.0       ka       any       SCL        -
-SCL    1.0      close     any       SCL       del_close, add_ka
-SCL    1.0      both      any       SCL       del_close
-
-SCL    1.1        -       1.0       SCL       add_ka
-SCL    1.1        -       1.1       SCL        -
-SCL    1.1       ka       1.0       SCL        -
-SCL    1.1       ka       1.1       SCL       del_ka
-SCL    1.1      close     1.0       SCL       del_close, add_ka
-SCL    1.1      close     1.1       SCL       del_close
-SCL    1.1      both      1.0       SCL       del_close
-SCL    1.1      both      1.1       SCL       del_ka, del_close
-
-CLO    1.0        -       any       CLO        -
-CLO    1.0       ka       any       CLO       del_ka
-CLO    1.0      close     any       CLO       del_close
-CLO    1.0      both      any       CLO       del_ka, del_close
-
-CLO    1.1        -       any       CLO       add_close
-CLO    1.1       ka       any       CLO       del_ka, add_close
-CLO    1.1      close     any       CLO        -
-CLO    1.1      both      any       CLO       del_ka
-
-=> in summary :
-  - the header operations do not depend on the initial mode, they only depend
-    on versions and current connection header(s).
-
-  - both CLO and TUN modes work similarly, they need to set a close mode on the
-    reponse. A 1.1 response will exclusively need the close header, while a 1.0
-    response will have it removed. Any keep-alive header is always removed when
-    found.
-
-  - a KAL request where the server wants to close turns into an SCL response so
-    that we release the server but still maintain the connection to the client.
-
-  - the KAL and SCL modes work the same way as we need to set keep-alive on the
-    response. So a 1.0 response will only have the keep-alive header with any
-    close header removed. A 1.1 response will have the keep-alive header added
-    for 1.0 requests and the close header removed for all requests.
-
-Note that the SCL and CLO modes will automatically cause the server connection
-to be closed at the end of the data transfer.
diff --git a/deps/haproxy-1.4.21/doc/internals/connection-scale.txt b/deps/haproxy-1.4.21/doc/internals/connection-scale.txt
deleted file mode 100644
index 7c3d902..0000000
--- a/deps/haproxy-1.4.21/doc/internals/connection-scale.txt
+++ /dev/null
@@ -1,44 +0,0 @@
-Problme des connexions simultanes avec un backend
-
-Pour chaque serveur, 3 cas possibles :
-
-  - pas de limite (par dfaut)
-  - limite statique (maxconn)
-  - limite dynamique (maxconn/(ratio de px->conn), avec minconn)
-
-On a donc besoin d'une limite sur le proxy dans le cas de la limite
-dynamique, afin de fixer un seuil et un ratio. Ce qui compte, c'est
-le point aprs lequel on passe d'un rgime linaire  un rgime
-satur.
-
-On a donc 3 phases :
-
-  - rgime minimal  (0..srv->minconn)
-  - rgime linaire (srv->minconn..srv->maxconn)
-  - rgime satur (srv->maxconn..)
-
-Le minconn pourrait aussi ressortir du serveur ?
-En pratique, on veut :
-  - un max par serveur
-  - un seuil global auquel les serveurs appliquent le max
-  - un seuil minimal en-dessous duquel le nb de conn est
-    maintenu. Cette limite a un sens par serveur (jamais moins de X conns)
-    mais aussi en global (pas la peine de faire du dynamique en dessous de
-    X conns  rpartir). La difficult en global, c'est de savoir comment
-    on calcule le nombre min associ  chaque serveur, vu que c'est un ratio
-    dfini  partir du max.
-
-Ca revient  peu prs  la mme chose que de faire 2 tats :
-
-  - rgime linaire avec un offset (srv->minconn..srv->maxconn)
-  - rgime satur (srv->maxconn..)
-
-Sauf que dans ce cas, le min et le max sont bien par serveur, et le seuil est
-global et correspond  la limite de connexions au-del de laquel on veut
-tourner  plein rgime sur l'ensemble des serveurs. On peut donc parler de
-passage en mode "full", "saturated", "optimal". On peut galement parler de
-la fin de la partie "scalable", "dynamique".
-
-=> fullconn 1000 par exemple ?
-
-
diff --git a/deps/haproxy-1.4.21/doc/internals/header-parser-speed.txt b/deps/haproxy-1.4.21/doc/internals/header-parser-speed.txt
deleted file mode 100644
index 285e2fa..0000000
--- a/deps/haproxy-1.4.21/doc/internals/header-parser-speed.txt
+++ /dev/null
@@ -1,92 +0,0 @@
-TEST 3:
-
-  printf "GET /\r\nbla: truc\r\n\r\n"
-
-
-NO SPEEDUP :
-
-WHL: hdr_st=0x00, hdr_used=1 hdr_tail=0 hdr_last=1, h=0x8071080, lr=0x8071080, r=0x8071094
-WHL: hdr_st=0x01, hdr_used=1 hdr_tail=0 hdr_last=1, h=0x8071080, lr=0x8071080, r=0x8071094
-WHL: hdr_st=0x32, hdr_used=1 hdr_tail=0 hdr_last=1, h=0x8071080, lr=0x8071086, r=0x8071094
-WHL: hdr_st=0x03, hdr_used=2 hdr_tail=1 hdr_last=2, h=0x8071087, lr=0x8071087, r=0x8071094
-WHL: hdr_st=0x34, hdr_used=2 hdr_tail=1 hdr_last=2, h=0x8071087, lr=0x8071091, r=0x8071094
-WHL: hdr_st=0x03, hdr_used=3 hdr_tail=2 hdr_last=3, h=0x8071092, lr=0x8071092, r=0x8071094
-WHL: hdr_st=0x34, hdr_used=3 hdr_tail=2 hdr_last=3, h=0x8071092, lr=0x8071093, r=0x8071094
-WHL: hdr_st=0x06, hdr_used=3 hdr_tail=2 hdr_last=3, h=0x8071092, lr=0x8071093, r=0x8071094
-END: hdr_st=0x06, hdr_used=3 hdr_tail=2 hdr_last=3, h=0x8071092, lr=0x8071094, r=0x8071094
-=> 9 trans
-
-
-FULL SPEEDUP :
-
-WHL: hdr_st=0x00, hdr_used=1 hdr_tail=0 hdr_last=1, h=0x806a770, lr=0x806a770, r=0x806a784
-WHL: hdr_st=0x32, hdr_used=1 hdr_tail=0 hdr_last=1, h=0x806a770, lr=0x806a776, r=0x806a784
-WHL: hdr_st=0x03, hdr_used=2 hdr_tail=1 hdr_last=2, h=0x806a777, lr=0x806a777, r=0x806a784
-WHL: hdr_st=0x34, hdr_used=2 hdr_tail=1 hdr_last=2, h=0x806a777, lr=0x806a781, r=0x806a784
-WHL: hdr_st=0x26, hdr_used=3 hdr_tail=2 hdr_last=3, h=0x806a782, lr=0x806a783, r=0x806a784
-END: hdr_st=0x06, hdr_used=3 hdr_tail=2 hdr_last=3, h=0x806a782, lr=0x806a784, r=0x806a784
-=> 6 trans
-
-
-
-TEST 4:
-
-
-  printf "GET /\nbla: truc\n\n"
-
-
-NO SPEEDUP :
-
-WHL: hdr_st=0x00, hdr_used=1 hdr_tail=0 hdr_last=1, h=0x80750d0, lr=0x80750d0, r=0x80750e1
-WHL: hdr_st=0x01, hdr_used=1 hdr_tail=0 hdr_last=1, h=0x80750d0, lr=0x80750d0, r=0x80750e1
-WHL: hdr_st=0x02, hdr_used=1 hdr_tail=0 hdr_last=1, h=0x80750d0, lr=0x80750d5, r=0x80750e1
-WHL: hdr_st=0x03, hdr_used=2 hdr_tail=1 hdr_last=2, h=0x80750d6, lr=0x80750d6, r=0x80750e1
-WHL: hdr_st=0x04, hdr_used=2 hdr_tail=1 hdr_last=2, h=0x80750d6, lr=0x80750df, r=0x80750e1
-WHL: hdr_st=0x03, hdr_used=3 hdr_tail=2 hdr_last=3, h=0x80750e0, lr=0x80750e0, r=0x80750e1
-WHL: hdr_st=0x04, hdr_used=3 hdr_tail=2 hdr_last=3, h=0x80750e0, lr=0x80750e0, r=0x80750e1
-WHL: hdr_st=0x06, hdr_used=3 hdr_tail=2 hdr_last=3, h=0x80750e0, lr=0x80750e0, r=0x80750e1
-END: hdr_st=0x06, hdr_used=3 hdr_tail=2 hdr_last=3, h=0x80750e0, lr=0x80750e1, r=0x80750e1
-=> 9 trans
-
-
-FULL SPEEDUP :
-
-WHL: hdr_st=0x00, hdr_used=1 hdr_tail=0 hdr_last=1, h=0x8072010, lr=0x8072010, r=0x8072021
-WHL: hdr_st=0x03, hdr_used=2 hdr_tail=1 hdr_last=2, h=0x8072016, lr=0x8072016, r=0x8072021
-END: hdr_st=0x06, hdr_used=3 hdr_tail=2 hdr_last=3, h=0x8072020, lr=0x8072021, r=0x8072021
-=> 3 trans
-
-
-TEST 5:
-
-
-  printf "GET /\r\nbla: truc\r\n  truc2\r\n\r\n"
-
-
-NO SPEEDUP :
-
-WHL: hdr_st=0x00, hdr_used=1 hdr_tail=0 hdr_last=1, h=0x8071080, lr=0x8071080, r=0x807109d
-WHL: hdr_st=0x01, hdr_used=1 hdr_tail=0 hdr_last=1, h=0x8071080, lr=0x8071080, r=0x807109d
-WHL: hdr_st=0x32, hdr_used=1 hdr_tail=0 hdr_last=1, h=0x8071080, lr=0x8071086, r=0x807109d
-WHL: hdr_st=0x03, hdr_used=2 hdr_tail=1 hdr_last=2, h=0x8071087, lr=0x8071087, r=0x807109d
-WHL: hdr_st=0x34, hdr_used=2 hdr_tail=1 hdr_last=2, h=0x8071087, lr=0x8071091, r=0x807109d
-WHL: hdr_st=0x05, hdr_used=2 hdr_tail=1 hdr_last=2, h=0x8071087, lr=0x8071092, r=0x807109d
-WHL: hdr_st=0x03, hdr_used=2 hdr_tail=1 hdr_last=2, h=0x8071087, lr=0x8071094, r=0x807109d
-WHL: hdr_st=0x34, hdr_used=2 hdr_tail=1 hdr_last=2, h=0x8071087, lr=0x807109a, r=0x807109d
-WHL: hdr_st=0x03, hdr_used=3 hdr_tail=2 hdr_last=3, h=0x807109b, lr=0x807109b, r=0x807109d
-WHL: hdr_st=0x34, hdr_used=3 hdr_tail=2 hdr_last=3, h=0x807109b, lr=0x807109c, r=0x807109d
-WHL: hdr_st=0x06, hdr_used=3 hdr_tail=2 hdr_last=3, h=0x807109b, lr=0x807109c, r=0x807109d
-END: hdr_st=0x06, hdr_used=3 hdr_tail=2 hdr_last=3, h=0x807109b, lr=0x807109d, r=0x807109d
-=> 12 trans
-
-
-FULL SPEEDUP :
-
-WHL: hdr_st=0x00, hdr_used=1 hdr_tail=0 hdr_last=1, h=0x806dfc0, lr=0x806dfc0, r=0x806dfdd
-WHL: hdr_st=0x32, hdr_used=1 hdr_tail=0 hdr_last=1, h=0x806dfc0, lr=0x806dfc6, r=0x806dfdd
-WHL: hdr_st=0x03, hdr_used=2 hdr_tail=1 hdr_last=2, h=0x806dfc7, lr=0x806dfc7, r=0x806dfdd
-WHL: hdr_st=0x34, hdr_used=2 hdr_tail=1 hdr_last=2, h=0x806dfc7, lr=0x806dfd1, r=0x806dfdd
-WHL: hdr_st=0x34, hdr_used=2 hdr_tail=1 hdr_last=2, h=0x806dfc7, lr=0x806dfda, r=0x806dfdd
-WHL: hdr_st=0x26, hdr_used=3 hdr_tail=2 hdr_last=3, h=0x806dfdb, lr=0x806dfdc, r=0x806dfdd
-END: hdr_st=0x06, hdr_used=3 hdr_tail=2 hdr_last=3, h=0x806dfdb, lr=0x806dfdd, r=0x806dfdd
-=> 7 trans
diff --git a/deps/haproxy-1.4.21/doc/internals/header-tree.txt b/deps/haproxy-1.4.21/doc/internals/header-tree.txt
deleted file mode 100644
index 9a97361..0000000
--- a/deps/haproxy-1.4.21/doc/internals/header-tree.txt
+++ /dev/null
@@ -1,124 +0,0 @@
-2007/03/30 - Header storage in trees
-
-This documentation describes how to store headers in radix trees, providing
-fast access to any known position, while retaining the ability to grow/reduce
-any arbitrary header without having to recompute all positions.
-
-Principle :
-  We have a radix tree represented in an integer array, which represents the
-  total number of bytes used by all headers whose position is below it. This
-  ensures that we can compute any header's position in O(log(N)) where N is
-  the number of headers.
-
-Example with N=16 :
-
-   +-----------------------+
-   |                       |
-   +-----------+           +-----------+
-   |           |           |           |
-   +-----+     +-----+     +-----+     +-----+
-   |     |     |     |     |     |     |     |
-   +--+  +--+  +--+  +--+  +--+  +--+  +--+  +--+
-   |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |
-
-   0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
-
-   To reach header 6, we have to compute hdr[0]+hdr[4]+hdr[6]
-
-   With this method, it becomes easy to grow any header and update the array.
-   To achieve this, we have to replace one after the other all bits on the
-   right with one 1 followed by zeroes, and update the position if it's higher
-   than current position, and stop when it's above number of stored headers.
-
-   For instance, if we want to grow hdr[6], we proceed like this :
-
-   6 = 0110 (BIN)
-
-   Let's consider the values to update :
-
-   (bit 0) : (0110 & ~0001) | 0001 = 0111 = 7 >  6 => update
-   (bit 1) : (0110 & ~0011) | 0010 = 0110 = 6 <= 6 => leave it
-   (bit 2) : (0110 & ~0111) | 0100 = 0100 = 4 <= 6 => leave it
-   (bit 4) : (0110 & ~1111) | 1000 = 1000 = 8 >  6 => update
-   (bit 5) : larger than array size, stop.
-
-
-It's easy to walk through the tree too. We only have one iteration per bit
-changing from X to the ancestor, and one per bit from the ancestor to Y.
-The ancestor is found while walking. To go from X to Y :
-
-   pos = pos(X)
-
-   while (Y != X) {
-     if (Y > X) {
-       // walk from Y to ancestor
-       pos += hdr[Y]
-       Y &= (Y - 1)
-     } else {
-       // walk from X to ancestor
-       pos -= hdr[X]
-       X &= (X - 1)
-     }
-   }
-
-However, it is not trivial anymore to linearly walk the tree. We have to move
-from a known place to another known place, but a jump to next entry costs the
-same as a jump to a random place.
-
-Other caveats :
-  - it is not possible to remove a header, it is only possible to empty it.
-  - it is not possible to insert a header, as that would imply a renumbering.
-  => this means that a "defrag" function is required. Headers should preferably
-     be added, then should be stuffed on top of destroyed ones, then only
-     inserted if absolutely required.
-
-
-When we have this, we can then focus on a 32-bit header descriptor which would
-look like this :
-
-{
-  unsigned line_len :13; /* total line length, including CRLF */
-  unsigned name_len  :6; /* header name length, max 63 chars */
-  unsigned sp1       :5; /* max spaces before value : 31 */
-  unsigned sp2       :8; /* max spaces after value : 255 */
-}
-
-Example :
-
-  Connection:      close           \r\n
-  <---------+-----+-----+-------------> line_len
-  <-------->|     |     |               name_len
-            <----->     |               sp1
-                        <-------------> sp2
-Rem:
-  - if there are more than 31 spaces before the value, the buffer will have to
-    be moved before being registered
-
-  - if there are more than 255  spaces after the value, the buffer will have to
-    be moved before being registered
-
-  - we can use the empty header name as an indicator for a deleted header
-
-  - it would be wise to format a new request before sending lots of random
-    spaces to the servers.
-
-  - normal clients do not send such crap, so those operations *may* reasonably
-    be more expensive than the rest provided that other ones are very fast.
-
-It would be handy to have the following macros :
-
-  hdr_eon(hdr)  => end of name
-  hdr_sov(hdr)  => start of value
-  hdr_eof(hdr)  => end of value
-  hdr_vlen(hdr) => length of value
-  hdr_hlen(hdr) => total header length
-
-
-A 48-bit encoding would look like this :
-
-  Connection:      close           \r\n
-  <---------+------+---+--------------> eoh = 16 bits
-  <-------->|      |   |                eon = 8 bits
-  <--------------->|   |                sov = 8 bits
-                   <--->                vlen = 16 bits
-
diff --git a/deps/haproxy-1.4.21/doc/internals/http-cookies.txt b/deps/haproxy-1.4.21/doc/internals/http-cookies.txt
deleted file mode 100644
index 6d65c54..0000000
--- a/deps/haproxy-1.4.21/doc/internals/http-cookies.txt
+++ /dev/null
@@ -1,45 +0,0 @@
-2010/08/31 - HTTP Cookies - Theory and reality
-
-HTTP cookies are not uniformly supported across browsers, which makes it very
-hard to build a widely compatible implementation. At least four conflicting
-documents exist to describe how cookies should be handled, and browsers
-generally don't respect any but a sensibly selected mix of them :
-
-  - Netscape's original spec (also mirrored at Curl's site among others) :
-    http://web.archive.org/web/20070805052634/http://wp.netscape.com/newsref/std/cookie_spec.html
-    http://curl.haxx.se/rfc/cookie_spec.html
-
-    Issues: uses an unquoted "Expires" field that includes a comma.
-
-  - RFC 2109 :
-    http://www.ietf.org/rfc/rfc2109.txt
-
-    Issues: specifies use of "Max-Age" (not universally implemented) and does
-            not talk about "Expires" (generally supported). References quoted
-            strings, not generally supported (eg: MSIE). Stricter than browsers
-            about domains. Ambiguous about allowed spaces in values and attrs.
-
-  - RFC 2965 :
-    http://www.ietf.org/rfc/rfc2965.txt
-
-    Issues: same as RFC2109 + describes Set-Cookie2 which only Opera supports.
-
-  - Current internet draft :
-    https://datatracker.ietf.org/wg/httpstate/charter/
-
-    Issues: as of -p10, does not explain how the Set-Cookie2 header must be
-            emitted/handled, while suggesting a stricter approach for Cookie.
-            Documents reality and as such reintroduces the widely used unquoted
-            "Expires" attribute with its error-prone syntax. States that a
-            server should not emit more than one cookie per Set-Cookie header,
-            which is incompatible with HTTP which says that multiple headers
-            are allowed only if they can be folded.
-
-See also the following URL for a browser * feature matrix :
-   http://code.google.com/p/browsersec/wiki/Part2#Same-origin_policy_for_cookies
-
-In short, MSIE and Safari neither support quoted strings nor max-age, which
-make it mandatory to continue to send an unquoted Expires value (maybe the
-day of week could be omitted though). Only Safari supports comma-separated
-lists of Set-Cookie headers. Support for cross-domains is not uniform either.
-
diff --git a/deps/haproxy-1.4.21/doc/internals/http-docs.txt b/deps/haproxy-1.4.21/doc/internals/http-docs.txt
deleted file mode 100644
index 4ed2480..0000000
--- a/deps/haproxy-1.4.21/doc/internals/http-docs.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-Many interesting RFC and drafts linked to from this site :
-
-  http://www.web-cache.com/Writings/protocols-standards.html
-
-
diff --git a/deps/haproxy-1.4.21/doc/internals/http-parsing.txt b/deps/haproxy-1.4.21/doc/internals/http-parsing.txt
deleted file mode 100644
index fd41b6e..0000000
--- a/deps/haproxy-1.4.21/doc/internals/http-parsing.txt
+++ /dev/null
@@ -1,239 +0,0 @@
---- Relevant portions of RFC2616 ---
-
-OCTET               = <any 8-bit sequence of data>
-CHAR                = <any US-ASCII character (octets 0 - 127)>
-UPALPHA             = <any US-ASCII uppercase letter "A".."Z">
-LOALPHA             = <any US-ASCII lowercase letter "a".."z">
-ALPHA               = UPALPHA | LOALPHA
-DIGIT               = <any US-ASCII digit "0".."9">
-CTL                 = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
-CR                  = <US-ASCII CR, carriage return (13)>
-LF                  = <US-ASCII LF, linefeed (10)>
-SP                  = <US-ASCII SP, space (32)>
-HT                  = <US-ASCII HT, horizontal-tab (9)>
-<">                 = <US-ASCII double-quote mark (34)>
-CRLF                = CR LF
-LWS                 = [CRLF] 1*( SP | HT )
-TEXT                = <any OCTET except CTLs, but including LWS>
-HEX                 = "A" | "B" | "C" | "D" | "E" | "F"
-                      | "a" | "b" | "c" | "d" | "e" | "f" | DIGIT
-separators          = "(" | ")" | "<" | ">" | "@"
-                    | "," | ";" | ":" | "\" | <">
-                    | "/" | "[" | "]" | "?" | "="
-                    | "{" | "}" | SP | HT
-token               = 1*<any CHAR except CTLs or separators>
-
-quoted-pair         = "\" CHAR
-ctext               = <any TEXT excluding "(" and ")">
-qdtext              = <any TEXT except <">>
-quoted-string       = ( <"> *(qdtext | quoted-pair ) <"> )
-comment             = "(" *( ctext | quoted-pair | comment ) ")"
-
-
-
-
-
-4 HTTP Message
-4.1 Message Types
-
-HTTP messages consist of requests from client to server and responses from
-server to client. Request (section 5) and Response (section 6) messages use the
-generic message format of RFC 822 [9] for transferring entities (the payload of
-the message). Both types of message consist of :
-
-  - a start-line
-  - zero or more header fields (also known as "headers")
-  - an empty line (i.e., a line with nothing preceding the CRLF) indicating the
-    end of the header fields
-  - and possibly a message-body.
-
-
-HTTP-message        = Request | Response
-
-start-line          = Request-Line | Status-Line
-generic-message     = start-line
-                      *(message-header CRLF)
-                      CRLF
-                      [ message-body ]
-
-In the interest of robustness, servers SHOULD ignore any empty line(s) received
-where a Request-Line is expected. In other words, if the server is reading the
-protocol stream at the beginning of a message and receives a CRLF first, it
-should ignore the CRLF.
-
-
-4.2 Message headers
-
-- Each header field consists of a name followed by a colon (":") and the field
-  value.
-- Field names are case-insensitive.
-- The field value MAY be preceded by any amount of LWS, though a single SP is
-  preferred.
-- Header fields can be extended over multiple lines by preceding each extra
-  line with at least one SP or HT.
-
-
-message-header      = field-name ":" [ field-value ]
-field-name          = token
-field-value         = *( field-content | LWS )
-field-content       = <the OCTETs making up the field-value and consisting of
-                       either *TEXT or combinations of token, separators, and
-                       quoted-string>
-
-
-The field-content does not include any leading or trailing LWS occurring before
-the first non-whitespace character of the field-value or after the last
-non-whitespace character of the field-value. Such leading or trailing LWS MAY
-be removed without changing the semantics of the field value. Any LWS that
-occurs between field-content MAY be replaced with a single SP before
-interpreting the field value or forwarding the message downstream.
-
-
-=> format des headers = 1*(CHAR & !ctl & !sep) ":" *(OCTET & (!ctl | LWS))
-=> les regex de matching de headers s'appliquent sur field-content, et peuvent
-   utiliser field-value comme espace de travail (mais de prfrence aprs le
-   premier SP).
-
-(19.3) The line terminator for message-header fields is the sequence CRLF.
-However, we recommend that applications, when parsing such headers, recognize
-a single LF as a line terminator and ignore the leading CR.
-
-
-
-
-
-message-body    = entity-body
-                | <entity-body encoded as per Transfer-Encoding>
-
-
-
-5 Request
-
-Request         = Request-Line
-                  *(( general-header
-                    | request-header
-                    | entity-header ) CRLF)
-                  CRLF
-                  [ message-body ]
-
-
-
-5.1 Request line
-
-The elements are separated by SP characters. No CR or LF is allowed except in
-the final CRLF sequence.
-
-Request-Line = Method SP Request-URI SP HTTP-Version CRLF
-
-(19.3) Clients SHOULD be tolerant in parsing the Status-Line and servers
-tolerant when parsing the Request-Line. In particular, they SHOULD accept any
-amount of SP or HT characters between fields, even though only a single SP is
-required.
-
-4.5 General headers
-Apply to MESSAGE.
-
-general-header  = Cache-Control
-                | Connection
-                | Date
-                | Pragma
-                | Trailer
-                | Transfer-Encoding
-                | Upgrade
-                | Via
-                | Warning
-
-General-header field names can be extended reliably only in combination with a
-change in the protocol version. However, new or experimental header fields may
-be given the semantics of general header fields if all parties in the
-communication recognize them to be general-header fields. Unrecognized header
-fields are treated as entity-header fields.
-
-
-
-
-5.3 Request Header Fields
-
-The request-header fields allow the client to pass additional information about
-the request, and about the client itself, to the server. These fields act as
-request modifiers, with semantics equivalent to the parameters on a programming
-language method invocation.
-
-request-header  = Accept
-                | Accept-Charset
-                | Accept-Encoding
-                | Accept-Language
-                | Authorization
-                | Expect
-                | From
-                | Host
-                | If-Match
-                | If-Modified-Since
-                | If-None-Match
-                | If-Range
-                | If-Unmodified-Since
-                | Max-Forwards
-                | Proxy-Authorization
-                | Range
-                | Referer
-                | TE
-                | User-Agent
-
-Request-header field names can be extended reliably only in combination with a
-change in the protocol version. However, new or experimental header fields MAY
-be given the semantics of request-header fields if all parties in the
-communication recognize them to be request-header fields. Unrecognized header
-fields are treated as entity-header fields.
-
-
-
-7.1 Entity header fields
-
-Entity-header fields define metainformation about the entity-body or, if no
-body is present, about the resource identified by the request. Some of this
-metainformation is OPTIONAL; some might be REQUIRED by portions of this
-specification.
-
-entity-header   = Allow
-                | Content-Encoding
-                | Content-Language
-                | Content-Length
-                | Content-Location
-                | Content-MD5
-                | Content-Range
-                | Content-Type
-                | Expires
-                | Last-Modified
-                | extension-header
-extension-header = message-header
-
-The extension-header mechanism allows additional entity-header fields to be
-defined without changing the protocol, but these fields cannot be assumed to be
-recognizable by the recipient. Unrecognized header fields SHOULD be ignored by
-the recipient and MUST be forwarded by transparent proxies.
-
----- The correct way to do it ----
-
-- one http_session
-  It is basically any transport session on which we talk HTTP. It may be TCP,
-  SSL over TCP, etc... It knows a way to talk to the client, either the socket
-  file descriptor or a direct access to the client-side buffer. It should hold
-  information about the last accessed server so that we can guarantee that the
-  same server can be used during a whole session if needed. A first version
-  without optimal support for HTTP pipelining will have the client buffers tied
-  to the http_session. It may be possible that it is not sufficient for full
-  pipelining, but this will need further study. The link from the buffers to
-  the backend should be managed by the http transaction (http_txn), provided
-  that they are serialized. Each http_session, has 0 to N http_txn. Each
-  http_txn belongs to one and only one http_session.
-
-- each http_txn has 1 request message (http_req), and 0 or 1 response message
-  (http_rtr). Each of them has 1 and only one http_txn. An http_txn holds
-  informations such as the HTTP method, the URI, the HTTP version, the
-  transfer-encoding, the HTTP status, the authorization, the req and rtr
-  content-length, the timers, logs, etc... The backend and server which process
-  the request are also known from the http_txn.
-
-- both request and response messages hold header and parsing informations, such
-  as the parsing state, start of headers, start of message, captures, etc...
-
diff --git a/deps/haproxy-1.4.21/doc/internals/naming.txt b/deps/haproxy-1.4.21/doc/internals/naming.txt
deleted file mode 100644
index 0c3d5b5..0000000
--- a/deps/haproxy-1.4.21/doc/internals/naming.txt
+++ /dev/null
@@ -1,54 +0,0 @@
-Naming rules for manipulated objects and structures.
-
-Previously, there were ambiguities between sessions, transactions and requests,
-as well as in the way responses are noted ("resp", "rep", "rsp").
-
-Here is a proposal for a better naming scheme.
-
-The "session" is above the transport level, which means at ISO layer 5.
-We can talk about "http sessions" when we consider the entity which lives
-between the accept() and the close(), or the connect() and the close().
-
-=> This demonstrates that it is not possible to have the same http session from
-   the client to the server.
-
-A session can carry one or multiple "transactions", which are each composed of
-one "request" and zero or one "response". Both "request" and "response" are
-described in RFC2616 as "HTTP messages". RFC2616 also seldom references the
-word "transaction" without explicitly defining it.
-
-An "HTTP message" is composed of a "start line" which can be either a
-"request line" or a "status line", followed by a number of "message headers"
-which can be either "request headers" or "response headers", and an "entity",
-itself composed of "entity headers" and an "entity body".Most probably,
-"message headers" and "entity headers" will always be processed together as
-"headers", while the "entity body" will design the payload.
-
-We must try to always use the same abbreviations when naming objects. Here are
-a few common ones :
-
-  - txn : transaction
-  - req : request
-  - rtr : response to request
-  - msg : message
-  - hdr : header
-  - ent : entity
-  - bdy : body
-  - sts : status
-  - stt : state
-  - idx : index
-  - cli : client
-  - srv : server
-  - svc : service
-  - ses : session
-  - tsk : task
-
-Short names for unions or cascaded structs :
-  - sl  : start line
-  - sl.rq : request line
-  - sl.st : status line
-  - cl  : client
-  - px  : proxy
-  - sv  : server
-  - st  : state / status
-
diff --git a/deps/haproxy-1.4.21/doc/internals/repartition-be-fe-fi.txt b/deps/haproxy-1.4.21/doc/internals/repartition-be-fe-fi.txt
deleted file mode 100644
index 261d073..0000000
--- a/deps/haproxy-1.4.21/doc/internals/repartition-be-fe-fi.txt
+++ /dev/null
@@ -1,20 +0,0 @@
-- session : ajouter ->fiprm et ->beprm comme raccourcis
-- px->maxconn: ne s'applique qu'au FE. Pour le BE, on utilise fullconn,
-  initialis par dfaut  la mme chose que maxconn.
-
-
-     \ from:   proxy       session       server           actuellement
-field \
-rules          px->fiprm   sess->fiprm   -
-srv,cookies    px->beprm   sess->beprm   srv->px
-options(log)   px->        sess->fe      -
-options(fe)    px->        sess->fe      -
-options(be)    px->beprm   sess->beprm   srv->px
-captures       px->        sess->fe      -                ->fiprm
-
-
-logs           px->        sess->fe      srv->px
-errorloc       px->        sess->beprm|fe -
-maxconn        px->        sess->fe       -               ->be
-fullconn       px->        sess->beprm   srv->px          -
-
diff --git a/deps/haproxy-1.4.21/doc/internals/stats-v2.txt b/deps/haproxy-1.4.21/doc/internals/stats-v2.txt
deleted file mode 100644
index 7d2ae76..0000000
--- a/deps/haproxy-1.4.21/doc/internals/stats-v2.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-
-         Qcur  Qmax  Scur  Smax  Slim  Scum   Fin   Fout   Bin   Bout  Ereq  Econ  Ersp  Sts   Wght  Act   Bck   EChk  Down
-Frontend   -     -     X   maxX    Y   totX    I     O      I     O      Q     -     -     -     -     -     -     -     -
-Server     X   maxX    X   maxX    Y   totX    I     O      I     O      -     C     R     S     W     A     B     E     D
-Server     X   maxX    X   maxX    Y   totX    I     O      I     O      -     C     R     S     W     A     B     E     D
-Server     X   maxX    X   maxX    Y   totX    I     O      I     O      -     C     R     S     W     A     B     E     D
-Backend    X   maxX    X   maxX    Y   totX    I     O      I     O      -     C     R     S   totW  totA  totB  totE  totD
-
diff --git a/deps/haproxy-1.4.21/doc/internals/stream-sock-states.fig b/deps/haproxy-1.4.21/doc/internals/stream-sock-states.fig
deleted file mode 100644
index d5bf7f0..0000000
--- a/deps/haproxy-1.4.21/doc/internals/stream-sock-states.fig
+++ /dev/null
@@ -1,430 +0,0 @@
-#FIG 3.2
-Portrait
-Center
-Metric
-A4      
-100.00
-Single
--2
-1200 2
-0 32 #8e8e8e
-6 2295 1260 2430 1395
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 2363 1328 68 68 2430 1328 2295 1328
-4 1 0 50 -1 18 5 0.0000 4 60 45 2363 1361 1\001
--6
-6 1845 2295 1980 2430
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 1913 2363 68 68 1980 2363 1845 2363
-4 1 0 50 -1 18 5 0.0000 4 60 45 1913 2396 2\001
--6
-6 2475 2340 2610 2475
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 2543 2408 68 68 2610 2408 2475 2408
-4 1 0 50 -1 18 5 0.0000 4 60 45 2543 2441 9\001
--6
-6 2835 2610 2970 2745
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 2903 2678 68 68 2970 2678 2835 2678
-4 1 0 50 -1 18 5 0.0000 4 60 45 2903 2711 7\001
--6
-6 3195 2025 3330 2160
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 3263 2093 68 68 3330 2093 3195 2093
-4 1 0 50 -1 18 5 0.0000 4 60 45 3263 2126 8\001
--6
-6 2745 2160 2880 2295
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 2813 2228 68 68 2880 2228 2745 2228
-4 1 0 50 -1 18 5 0.0000 4 60 45 2813 2261 6\001
--6
-6 990 2700 1125 2835
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 1058 2768 68 68 1125 2768 990 2768
-4 1 0 50 -1 18 5 0.0000 4 60 90 1058 2801 13\001
--6
-6 1305 2970 1440 3105
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 1373 3038 68 68 1440 3038 1305 3038
-4 1 0 50 -1 18 5 0.0000 4 60 90 1373 3071 12\001
--6
-6 3105 1710 3240 1845
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 3173 1778 68 68 3240 1778 3105 1778
-4 1 0 50 -1 18 5 0.0000 4 60 90 3173 1811 15\001
--6
-6 4275 1260 4410 1395
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 4343 1328 68 68 4410 1328 4275 1328
-4 1 0 50 -1 18 5 0.0000 4 60 45 4343 1361 1\001
--6
-6 4275 1440 4410 1575
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 4343 1508 68 68 4410 1508 4275 1508
-4 1 0 50 -1 18 5 0.0000 4 60 45 4343 1541 2\001
--6
-6 4275 1620 4410 1755
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 4343 1688 68 68 4410 1688 4275 1688
-4 1 0 50 -1 18 5 0.0000 4 60 45 4343 1721 3\001
--6
-6 4275 1800 4410 1935
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 4343 1868 68 68 4410 1868 4275 1868
-4 1 0 50 -1 18 5 0.0000 4 60 45 4343 1901 4\001
--6
-6 3240 2835 3375 2970
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 3308 2903 68 68 3375 2903 3240 2903
-4 1 0 50 -1 18 5 0.0000 4 60 90 3308 2936 16\001
--6
-6 2835 3015 2970 3150
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 2903 3083 68 68 2970 3083 2835 3083
-4 1 0 50 -1 18 5 0.0000 4 60 90 2903 3116 17\001
--6
-6 2295 3195 2430 3330
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 2363 3263 68 68 2430 3263 2295 3263
-4 1 0 50 -1 18 5 0.0000 4 60 45 2363 3296 3\001
--6
-6 2295 4815 2430 4950
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 2363 4883 68 68 2430 4883 2295 4883
-4 1 0 50 -1 18 5 0.0000 4 60 45 2363 4916 5\001
--6
-6 1440 4815 1620 4995
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 1508 4883 68 68 1575 4883 1440 4883
-4 1 0 50 -1 18 5 0.0000 4 60 90 1508 4916 19\001
--6
-6 1800 3960 1980 4140
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 1868 4028 68 68 1935 4028 1800 4028
-4 1 0 50 -1 18 5 0.0000 4 60 90 1868 4061 18\001
--6
-6 4275 1980 4410 2115
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 4343 2048 68 68 4410 2048 4275 2048
-4 1 0 50 -1 18 5 0.0000 4 60 45 4343 2081 5\001
--6
-6 4275 2340 4410 2475
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 4343 2408 68 68 4410 2408 4275 2408
-4 1 0 50 -1 18 5 0.0000 4 60 45 4343 2441 6\001
--6
-6 4275 2520 4410 2655
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 4343 2588 68 68 4410 2588 4275 2588
-4 1 0 50 -1 18 5 0.0000 4 60 45 4343 2621 7\001
--6
-6 4275 2700 4410 2835
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 4343 2768 68 68 4410 2768 4275 2768
-4 1 0 50 -1 18 5 0.0000 4 60 45 4343 2801 8\001
--6
-6 4275 2880 4410 3015
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 4343 2948 68 68 4410 2948 4275 2948
-4 1 0 50 -1 18 5 0.0000 4 60 45 4343 2981 9\001
--6
-6 4275 3060 4410 3195
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 4343 3128 68 68 4410 3128 4275 3128
-4 1 0 50 -1 18 5 0.0000 4 60 90 4343 3161 10\001
--6
-6 4275 3240 4410 3375
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 4343 3308 68 68 4410 3308 4275 3308
-4 1 0 50 -1 18 5 0.0000 4 60 90 4343 3341 11\001
--6
-6 4275 3420 4410 3555
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 4343 3488 68 68 4410 3488 4275 3488
-4 1 0 50 -1 18 5 0.0000 4 60 90 4343 3521 12\001
--6
-6 4275 3600 4410 3735
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 4343 3668 68 68 4410 3668 4275 3668
-4 1 0 50 -1 18 5 0.0000 4 60 90 4343 3701 13\001
--6
-6 4275 3960 4410 4095
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 4343 4028 68 68 4410 4028 4275 4028
-4 1 0 50 -1 18 5 0.0000 4 60 90 4343 4061 15\001
--6
-6 4275 4140 4410 4275
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 4343 4208 68 68 4410 4208 4275 4208
-4 1 0 50 -1 18 5 0.0000 4 60 90 4343 4241 16\001
--6
-6 4275 4320 4410 4455
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 4343 4388 68 68 4410 4388 4275 4388
-4 1 0 50 -1 18 5 0.0000 4 60 90 4343 4421 17\001
--6
-6 4275 3780 4455 3960
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 4343 3848 68 68 4410 3848 4275 3848
-4 1 0 50 -1 18 5 0.0000 4 60 90 4343 3881 14\001
--6
-6 4275 4590 4455 4770
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 4343 4658 68 68 4410 4658 4275 4658
-4 1 0 50 -1 18 5 0.0000 4 60 90 4343 4691 18\001
--6
-6 4275 4770 4455 4950
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 4343 4838 68 68 4410 4838 4275 4838
-4 1 0 50 -1 18 5 0.0000 4 60 90 4343 4871 19\001
--6
-6 4275 4950 4455 5130
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 4343 5018 68 68 4410 5018 4275 5018
-4 1 0 50 -1 18 5 0.0000 4 60 90 4343 5051 20\001
--6
-6 2295 5670 2475 5850
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 2363 5738 68 68 2430 5738 2295 5738
-4 1 0 50 -1 18 5 0.0000 4 60 90 2363 5771 20\001
--6
-6 1170 3690 1350 3870
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 1238 3758 68 68 1305 3758 1170 3758
-4 1 0 50 -1 18 5 0.0000 4 60 90 1238 3791 11\001
--6
-6 1530 3555 1710 3735
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 1598 3623 68 68 1665 3623 1530 3623
-4 1 0 50 -1 18 5 0.0000 4 60 90 1598 3656 10\001
--6
-6 720 4095 900 4275
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 788 4163 68 68 855 4163 720 4163
-4 1 0 50 -1 18 5 0.0000 4 60 90 788 4196 14\001
--6
-6 855 3645 1035 3825
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 923 3713 68 68 990 3713 855 3713
-4 1 0 50 -1 18 5 0.0000 4 60 90 923 3746 21\001
--6
-6 4275 5130 4455 5310
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 4343 5198 68 68 4410 5198 4275 5198
-4 1 0 50 -1 18 5 0.0000 4 60 90 4343 5231 21\001
--6
-6 2295 4140 2430 4275
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 2363 4208 68 68 2430 4208 2295 4208
-4 1 0 50 -1 18 5 0.0000 4 60 45 2363 4241 4\001
--6
-6 2475 3870 2655 4050
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 2543 3938 68 68 2610 3938 2475 3938
-4 1 0 50 -1 18 5 0.0000 4 60 90 2543 3971 22\001
--6
-6 4275 5310 4455 5490
-1 4 0 1 0 7 50 -1 -1 0.000 1 0.0000 4343 5378 68 68 4410 5378 4275 5378
-4 1 0 50 -1 18 5 0.0000 4 60 90 4343 5411 22\001
--6
-1 2 0 1 0 6 50 -1 20 0.000 1 0.0000 1350 4612 225 112 1125 4612 1575 4612
-1 2 0 1 0 6 50 -1 20 0.000 1 0.0000 2250 5422 225 112 2025 5422 2475 5422
-1 2 0 1 0 6 50 -1 20 0.000 1 0.0000 2250 1912 225 112 2025 1912 2475 1912
-1 2 0 1 0 7 50 -1 20 0.000 1 0.0000 1125 3487 225 112 900 3487 1350 3487
-1 2 0 1 0 7 50 -1 20 0.000 1 0.0000 2250 3712 225 112 2025 3712 2475 3712
-1 2 0 1 0 7 50 -1 20 0.000 1 0.0000 2250 4612 225 112 2025 4612 2475 4612
-1 2 0 1 0 7 50 -1 20 0.000 1 0.0000 2250 6187 225 112 2025 6187 2475 6187
-1 2 0 1 0 7 50 -1 20 0.000 1 0.0000 2250 2812 225 112 2025 2812 2475 2812
-1 2 0 1 0 7 50 -1 20 0.000 1 0.0000 3375 2362 225 112 3150 2362 3600 2362
-1 2 0 1 0 7 50 -1 20 0.000 1 0.0000 2250 1012 225 112 2025 1012 2475 1012
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 60.00 120.00
-	 2250 1125 2250 1800
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 60.00 120.00
-	 2250 4725 2250 5310
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 60.00 120.00
-	 2250 5535 2250 6075
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 8550 5805 4500 5805
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 3
-	 6885 5900 6930 5990 6975 5810
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 3
-	 7605 5890 7650 5980 7695 5800
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 8550 6030 4500 6030
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 8550 6255 4500 6255
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 8550 6480 4500 6480
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 3
-	 6885 6570 6930 6660 6975 6480
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 3
-	 7605 6570 7650 6660 7695 6480
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 3
-	 7965 6570 8010 6660 8055 6480
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 5310 5589 5310 6921
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 5670 5589 5670 6921
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 6030 5589 6030 6921
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 6390 5589 6390 6921
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 6750 5589 6750 6921
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 7110 5589 7110 6921
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 7470 5589 7470 6921
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 7830 5589 7830 6921
-2 1 0 2 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 4950 5589 4950 6921
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 8190 5589 8190 6921
-2 2 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 5
-	 4500 5580 8550 5580 8550 6930 4500 6930 4500 5580
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 8550 6705 4500 6705
-3 0 0 1 0 7 50 -1 -1 0.000 0 1 0 4
-	1 1 1.00 60.00 120.00
-	 2475 2835 3150 3375 3150 5625 2475 6120
-	 0.000 1.000 1.000 0.000
-3 0 0 1 0 7 50 -1 -1 0.000 0 1 0 4
-	1 1 1.00 60.00 120.00
-	 2250 2700 2475 2475 2475 2250 2250 2025
-	 0.000 1.000 1.000 0.000
-3 0 0 1 0 7 50 -1 -1 0.000 0 1 0 3
-	1 1 1.00 60.00 120.00
-	 3375 2250 2925 2025 2475 1935
-	 0.000 1.000 0.000
-3 0 0 1 0 7 50 -1 -1 0.000 0 1 0 3
-	1 1 1.00 60.00 120.00
-	 3375 2475 3375 2700 2475 2835
-	 0.000 1.000 0.000
-3 0 0 1 0 7 50 -1 -1 0.000 0 1 0 4
-	1 1 1.00 60.00 120.00
-	 3420 2475 3420 4320 3150 5850 2475 6165
-	 0.000 1.000 1.000 0.000
-3 0 0 1 0 7 50 -1 -1 0.000 0 1 0 3
-	1 1 1.00 60.00 120.00
-	 1125 3375 1125 2925 2025 2790
-	 0.000 1.000 0.000
-3 0 0 1 0 7 50 -1 -1 0.000 0 1 0 3
-	1 1 1.00 60.00 120.00
-	 1125 3375 1125 2250 2025 1935
-	 0.000 1.000 0.000
-3 0 0 1 0 7 50 -1 -1 0.000 0 1 0 6
-	1 1 1.00 60.00 120.00
-	 2475 1890 3825 1800 3825 2520 3825 4500 3150 6075 2475 6210
-	 0.000 1.000 1.000 1.000 1.000 0.000
-3 0 0 1 0 7 50 -1 -1 0.000 0 1 0 4
-	1 1 1.00 60.00 120.00
-	 2250 2025 2025 2250 2025 2475 2250 2700
-	 0.000 1.000 1.000 0.000
-3 0 0 1 0 7 50 -1 -1 0.000 0 1 0 2
-	1 1 1.00 60.00 120.00
-	 2250 3825 2250 4500
-	 0.000 0.000
-3 0 0 1 0 7 50 -1 -1 0.000 0 1 0 3
-	1 1 1.00 60.00 120.00
-	 2475 1980 2880 2115 3150 2340
-	 0.000 1.000 0.000
-3 0 0 1 0 7 50 -1 -1 0.000 0 1 0 2
-	1 1 1.00 60.00 120.00
-	 2250 2925 2250 3600
-	 0.000 0.000
-3 0 0 1 0 7 50 -1 -1 0.000 0 1 0 4
-	1 1 1.00 60.00 120.00
-	 2205 3825 2070 4140 1622 4221 1440 4500
-	 0.000 1.000 1.000 0.000
-3 0 0 1 0 7 50 -1 -1 0.000 0 1 0 4
-	1 1 1.00 60.00 120.00
-	 1350 4725 1350 4950 1485 5760 2025 6165
-	 0.000 1.000 1.000 0.000
-3 0 0 1 0 7 50 -1 -1 0.000 0 1 0 7
-	1 1 1.00 60.00 120.00
-	 1125 4590 720 4455 675 4050 675 3600 675 2250 1350 1800
-	 2025 1935
-	 0.000 1.000 1.000 1.000 1.000 1.000 0.000
-3 0 0 1 0 7 50 -1 -1 0.000 0 1 0 3
-	1 1 1.00 60.00 120.00
-	 1260 4500 1125 4320 1125 3600
-	 0.000 1.000 0.000
-3 0 0 1 0 7 50 -1 -1 0.000 0 1 0 4
-	1 1 1.00 60.00 120.00
-	 1350 4500 1440 3645 1575 3330 2070 2880
-	 0.000 1.000 1.000 0.000
-3 0 0 1 32 7 51 -1 -1 0.000 0 1 0 5
-	1 1 1.00 60.00 120.00
-	 1035 3600 990 4365 990 5040 1395 5895 2025 6210
-	 0.000 1.000 1.000 1.000 0.000
-3 0 0 1 32 7 51 -1 -1 0.000 0 1 0 5
-	1 1 1.00 60.00 120.00
-	 2340 3825 2385 4005 2925 4275 2655 4815 2295 5310
-	 0.000 1.000 1.000 1.000 0.000
-4 0 0 50 -1 14 6 0.0000 4 75 2880 4500 1710 ASS-CON: ssui(): connect_server() == SN_ERR_NONE\001
-4 0 0 50 -1 14 6 0.0000 4 60 540 4500 1350 INI-REQ: \001
-4 0 0 50 -1 14 6 0.0000 4 75 3720 4500 1530 REQ-ASS: prepare_conn_request(): srv_redispatch_connect() == 0\001
-4 0 4 50 -1 14 10 0.0000 4 90 90 2475 2700 4\001
-4 0 4 50 -1 14 10 0.0000 4 90 90 1620 4500 6\001
-4 0 0 50 -1 14 6 0.0000 4 75 3360 4500 1890 CON-EST: sess_update_st_con_tcp(): !timeout && !conn_err\001
-4 0 0 50 -1 14 6 0.0000 4 75 2460 4500 3510 TAR-ASS: ssui(): SI_FL_EXP && SN_ASSIGNED\001
-4 0 0 50 -1 14 6 0.0000 4 75 3420 4500 2970 ASS-REQ: connect_server: conn_retries == 0 && PR_O_REDISP\001
-4 0 0 50 -1 14 6 0.0000 4 75 2460 4500 2610 QUE-REQ: ssui(): !pend_pos && SN_ASSIGNED\001
-4 0 0 50 -1 14 6 0.0000 4 75 2520 4500 2790 QUE-REQ: ssui(): !pend_pos && !SN_ASSIGNED\001
-4 0 0 50 -1 14 6 0.0000 4 75 3300 4500 4230 QUE-CLO: ssui(): pend_pos && (SI_FL_EXP || req_aborted)\001
-4 0 0 50 -1 14 6 0.0000 4 75 2520 4500 3690 TAR-REQ: ssui(): SI_FL_EXP && !SN_ASSIGNED\001
-4 0 0 50 -1 14 6 0.0000 4 75 3960 4500 4545 ASS-CLO: PR_O_REDISP && SN_REDIRECTABLE && perform_http_redirect()\001
-4 0 0 50 -1 14 6 0.0000 4 75 4440 4500 2430 REQ-QUE: prepare_conn_request(): srv_redispatch_connect() != 0 (SI_ST_QUE)\001
-4 0 0 50 -1 14 6 0.0000 4 75 4200 4500 4050 REQ-CLO: prepare_conn_request(): srv_redispatch_connect() != 0 (error)\001
-4 0 0 50 -1 14 6 0.0000 4 75 4320 4500 4410 ASS-CLO: ssui(): connect_server() == SN_ERR_INTERNAL || conn_retries < 0\001
-4 0 0 50 -1 14 6 0.0000 4 75 3120 4500 4680 CON-CER: sess_update_st_con_tcp(): timeout/SI_FL_ERR\001
-4 0 0 50 -1 14 6 0.0000 4 75 3600 4500 4860 CER-CLO: sess_update_st_cer(): (ERR/EXP) && conn_retries < 0\001
-4 0 0 50 -1 14 6 0.0000 4 75 4200 4500 3870 CER-REQ: sess_update_st_cer(): timeout && !conn_retries && PR_O_REDISP\001
-4 0 0 50 -1 14 6 0.0000 4 75 3600 4500 3330 CER-TAR: sess_update_st_cer(): conn_err && conn_retries >= 0\001
-4 0 0 50 -1 14 6 0.0000 4 75 4620 4500 3150 CER-ASS: sess_update_st_cer(): timeout && (conn_retries >= 0 || !PR_O_REDISP)\001
-4 0 4 50 -1 14 10 0.0000 4 90 90 1305 3375 3\001
-4 0 4 50 -1 14 10 0.0000 4 90 90 2430 4500 7\001
-4 0 4 50 -1 14 10 0.0000 4 90 90 2430 3600 5\001
-4 0 4 50 -1 14 10 0.0000 4 90 90 3555 2250 2\001
-4 0 4 50 -1 14 10 0.0000 4 90 90 2430 1800 1\001
-4 0 4 50 -1 14 10 0.0000 4 90 90 2430 900 0\001
-4 0 4 50 -1 14 10 0.0000 4 90 90 2430 5310 8\001
-4 0 0 50 -1 14 6 0.0000 4 75 3000 4500 2070 EST-DIS: stream_sock_read/write/shutr/shutw: close\001
-4 0 0 50 -1 14 6 0.0000 4 75 1980 4500 2250 EST-DIS: process_session(): error\001
-4 0 0 50 -1 14 6 0.0000 4 75 2100 4500 5040 DIS-CLO: process_session(): cleanup\001
-4 1 0 50 -1 14 10 0.0000 4 90 270 2250 5490 DIS\001
-4 1 0 50 -1 14 10 0.0000 4 90 270 1350 4680 CER\001
-4 1 0 50 -1 14 10 0.0000 4 105 270 2250 1980 REQ\001
-4 1 0 50 -1 14 10 0.0000 4 90 270 1125 3555 TAR\001
-4 1 0 50 -1 14 10 0.0000 4 90 270 2250 2880 ASS\001
-4 1 0 50 -1 14 10 0.0000 4 105 270 3375 2430 QUE\001
-4 1 0 50 -1 14 10 0.0000 4 90 270 2250 3780 CON\001
-4 1 0 50 -1 14 10 0.0000 4 90 270 2250 4680 EST\001
-4 1 0 50 -1 14 10 0.0000 4 90 270 2250 6255 CLO\001
-4 1 0 50 -1 14 10 0.0000 4 90 270 2250 1080 INI\001
-4 0 0 50 -1 14 6 0.0000 4 75 2820 4500 5220 TAR-CLO: sess_update_stream_int(): client abort\001
-4 0 4 50 -1 14 10 0.0000 4 90 90 2385 6075 9\001
-4 0 0 50 -1 14 6 0.0000 4 75 2820 4500 5400 CON-DIS: sess_update_st_con_tcp(): client abort\001
-4 1 0 50 -1 14 8 0.0000 4 15 75 5130 5985 -\001
-4 1 0 50 -1 14 8 0.0000 4 15 75 5490 5985 -\001
-4 1 0 50 -1 14 8 0.0000 4 15 75 5850 5985 -\001
-4 1 0 50 -1 14 8 0.0000 4 15 75 6210 5985 -\001
-4 1 0 50 -1 14 8 0.0000 4 15 75 6570 5985 -\001
-4 1 0 50 -1 14 8 0.0000 4 15 75 7290 5985 -\001
-4 1 0 50 -1 14 8 0.0000 4 15 75 8010 5985 -\001
-4 1 0 50 -1 16 7 0.0000 4 75 90 4725 5985 fd\001
-4 1 0 50 -1 14 8 0.0000 4 75 225 5130 5760 INI\001
-4 1 0 50 -1 16 7 0.0000 4 75 240 4725 5760 state\001
-4 1 0 50 -1 14 8 0.0000 4 90 225 5490 5760 REQ\001
-4 1 0 50 -1 14 8 0.0000 4 90 225 5850 5760 QUE\001
-4 1 0 50 -1 14 8 0.0000 4 75 225 6210 5760 TAR\001
-4 1 0 50 -1 14 8 0.0000 4 75 225 6570 5760 ASS\001
-4 1 0 50 -1 14 8 0.0000 4 75 225 6930 5760 CON\001
-4 1 0 50 -1 14 8 0.0000 4 75 225 7290 5760 CER\001
-4 1 0 50 -1 14 8 0.0000 4 75 225 7650 5760 EST\001
-4 1 0 50 -1 14 8 0.0000 4 75 75 8010 6210 X\001
-4 1 0 50 -1 14 8 0.0000 4 75 75 5850 6210 0\001
-4 1 0 50 -1 14 8 0.0000 4 75 75 5130 6210 0\001
-4 1 0 50 -1 16 7 0.0000 4 75 225 4725 6210 ERR\001
-4 1 0 50 -1 16 7 0.0000 4 75 225 4725 6435 EXP\001
-4 1 0 50 -1 14 8 0.0000 4 75 75 8010 6435 X\001
-4 1 0 50 -1 14 8 0.0000 4 75 75 5490 6210 X\001
-4 1 0 50 -1 14 8 0.0000 4 75 75 6210 6210 X\001
-4 1 0 50 -1 14 8 0.0000 4 75 75 6570 6210 X\001
-4 1 0 50 -1 14 8 0.0000 4 75 75 6570 6435 X\001
-4 1 0 50 -1 14 8 0.0000 4 75 75 5490 6435 X\001
-4 1 0 50 -1 14 8 0.0000 4 75 75 5130 6435 0\001
-4 1 0 50 -1 14 8 0.0000 4 75 75 5850 6435 0\001
-4 1 0 50 -1 14 8 0.0000 4 75 75 6210 6435 0\001
-4 1 0 50 -1 14 8 0.0000 4 75 75 7290 6435 X\001
-4 1 0 50 -1 14 8 0.0000 4 75 75 6930 6435 X\001
-4 1 0 50 -1 14 8 0.0000 4 75 75 7290 6210 X\001
-4 1 0 50 -1 14 8 0.0000 4 75 75 6930 6210 X\001
-4 1 0 50 -1 14 8 0.0000 4 75 75 7650 6210 X\001
-4 1 0 50 -1 14 8 0.0000 4 75 75 7650 6435 X\001
-4 1 0 50 -1 16 7 0.0000 4 60 240 4725 6660 sess\001
-4 1 0 50 -1 14 8 0.0000 4 75 225 8370 5760 CLO\001
-4 1 0 50 -1 14 8 0.0000 4 75 225 8010 5760 DIS\001
-4 1 0 50 -1 14 8 0.0000 4 15 75 8370 5985 -\001
-4 1 0 50 -1 14 8 0.0000 4 75 75 8370 6210 X\001
-4 1 0 50 -1 14 8 0.0000 4 75 75 8370 6435 X\001
-4 1 0 50 -1 14 8 0.0000 4 15 75 5130 6660 -\001
-4 1 0 50 -1 14 8 0.0000 4 15 75 5490 6660 -\001
-4 1 0 50 -1 14 8 0.0000 4 15 75 5850 6660 -\001
-4 1 0 50 -1 14 8 0.0000 4 15 75 6210 6660 -\001
-4 1 0 50 -1 14 8 0.0000 4 15 75 6570 6660 -\001
-4 1 0 50 -1 14 8 0.0000 4 15 75 7290 6660 -\001
-4 1 0 50 -1 14 8 0.0000 4 15 75 8370 6660 -\001
-4 0 0 50 -1 16 6 0.0000 4 90 5010 675 7335 Note: states painted yellow above are transient ; process_session() will never leave a stream interface in any of those upon return.\001
-4 1 0 50 -1 16 7 0.0000 4 75 285 4725 6840 SHUT\001
-4 1 0 50 -1 14 8 0.0000 4 75 75 7650 6840 0\001
-4 1 0 50 -1 14 8 0.0000 4 75 75 8010 6840 1\001
-4 1 0 50 -1 14 8 0.0000 4 75 75 8370 6840 1\001
-4 1 0 50 -1 14 8 0.0000 4 15 75 7290 6840 -\001
-4 1 0 50 -1 14 8 0.0000 4 75 75 6930 6840 0\001
-4 1 0 50 -1 14 8 0.0000 4 75 75 6570 6840 0\001
-4 1 0 50 -1 14 8 0.0000 4 75 75 6210 6840 0\001
-4 1 0 50 -1 14 8 0.0000 4 75 75 5850 6840 0\001
-4 1 0 50 -1 14 8 0.0000 4 75 75 5490 6840 0\001
-4 1 0 50 -1 14 8 0.0000 4 75 75 5130 6840 0\001
diff --git a/deps/haproxy-1.4.21/doc/internals/todo.cttproxy b/deps/haproxy-1.4.21/doc/internals/todo.cttproxy
deleted file mode 100644
index ad5bc99..0000000
--- a/deps/haproxy-1.4.21/doc/internals/todo.cttproxy
+++ /dev/null
@@ -1,5 +0,0 @@
-  - check TPROXY_VERSION if lstchk_tproxy
-  - check capabilities for CAP_NET_ADMIN if lstchk_tproxy
-  - add capabilities support to the global conf (cap_bind_service)
-  - add support for non-local listen address
-
diff --git a/deps/haproxy-1.4.21/doc/lgpl.txt b/deps/haproxy-1.4.21/doc/lgpl.txt
deleted file mode 100644
index 5ab7695..0000000
--- a/deps/haproxy-1.4.21/doc/lgpl.txt
+++ /dev/null
@@ -1,504 +0,0 @@
-		  GNU LESSER GENERAL PUBLIC LICENSE
-		       Version 2.1, February 1999
-
- Copyright (C) 1991, 1999 Free Software Foundation, Inc.
- 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-[This is the first released version of the Lesser GPL.  It also counts
- as the successor of the GNU Library Public License, version 2, hence
- the version number 2.1.]
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-Licenses are intended to guarantee your freedom to share and change
-free software--to make sure the software is free for all its users.
-
-  This license, the Lesser General Public License, applies to some
-specially designated software packages--typically libraries--of the
-Free Software Foundation and other authors who decide to use it.  You
-can use it too, but we suggest you first think carefully about whether
-this license or the ordinary General Public License is the better
-strategy to use in any particular case, based on the explanations below.
-
-  When we speak of free software, we are referring to freedom of use,
-not price.  Our General Public Licenses are designed to make sure that
-you have the freedom to distribute copies of free software (and charge
-for this service if you wish); that you receive source code or can get
-it if you want it; that you can change the software and use pieces of
-it in new free programs; and that you are informed that you can do
-these things.
-
-  To protect your rights, we need to make restrictions that forbid
-distributors to deny you these rights or to ask you to surrender these
-rights.  These restrictions translate to certain responsibilities for
-you if you distribute copies of the library or if you modify it.
-
-  For example, if you distribute copies of the library, whether gratis
-or for a fee, you must give the recipients all the rights that we gave
-you.  You must make sure that they, too, receive or can get the source
-code.  If you link other code with the library, you must provide
-complete object files to the recipients, so that they can relink them
-with the library after making changes to the library and recompiling
-it.  And you must show them these terms so they know their rights.
-
-  We protect your rights with a two-step method: (1) we copyright the
-library, and (2) we offer you this license, which gives you legal
-permission to copy, distribute and/or modify the library.
-
-  To protect each distributor, we want to make it very clear that
-there is no warranty for the free library.  Also, if the library is
-modified by someone else and passed on, the recipients should know
-that what they have is not the original version, so that the original
-author's reputation will not be affected by problems that might be
-introduced by others.
-
-  Finally, software patents pose a constant threat to the existence of
-any free program.  We wish to make sure that a company cannot
-effectively restrict the users of a free program by obtaining a
-restrictive license from a patent holder.  Therefore, we insist that
-any patent license obtained for a version of the library must be
-consistent with the full freedom of use specified in this license.
-
-  Most GNU software, including some libraries, is covered by the
-ordinary GNU General Public License.  This license, the GNU Lesser
-General Public License, applies to certain designated libraries, and
-is quite different from the ordinary General Public License.  We use
-this license for certain libraries in order to permit linking those
-libraries into non-free programs.
-
-  When a program is linked with a library, whether statically or using
-a shared library, the combination of the two is legally speaking a
-combined work, a derivative of the original library.  The ordinary
-General Public License therefore permits such linking only if the
-entire combination fits its criteria of freedom.  The Lesser General
-Public License permits more lax criteria for linking other code with
-the library.
-
-  We call this license the "Lesser" General Public License because it
-does Less to protect the user's freedom than the ordinary General
-Public License.  It also provides other free software developers Less
-of an advantage over competing non-free programs.  These disadvantages
-are the reason we use the ordinary General Public License for many
-libraries.  However, the Lesser license provides advantages in certain
-special circumstances.
-
-  For example, on rare occasions, there may be a special need to
-encourage the widest possible use of a certain library, so that it becomes
-a de-facto standard.  To achieve this, non-free programs must be
-allowed to use the library.  A more frequent case is that a free
-library does the same job as widely used non-free libraries.  In this
-case, there is little to gain by limiting the free library to free
-software only, so we use the Lesser General Public License.
-
-  In other cases, permission to use a particular library in non-free
-programs enables a greater number of people to use a large body of
-free software.  For example, permission to use the GNU C Library in
-non-free programs enables many more people to use the whole GNU
-operating system, as well as its variant, the GNU/Linux operating
-system.
-
-  Although the Lesser General Public License is Less protective of the
-users' freedom, it does ensure that the user of a program that is
-linked with the Library has the freedom and the wherewithal to run
-that program using a modified version of the Library.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.  Pay close attention to the difference between a
-"work based on the library" and a "work that uses the library".  The
-former contains code derived from the library, whereas the latter must
-be combined with the library in order to run.
-
-		  GNU LESSER GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License Agreement applies to any software library or other
-program which contains a notice placed by the copyright holder or
-other authorized party saying it may be distributed under the terms of
-this Lesser General Public License (also called "this License").
-Each licensee is addressed as "you".
-
-  A "library" means a collection of software functions and/or data
-prepared so as to be conveniently linked with application programs
-(which use some of those functions and data) to form executables.
-
-  The "Library", below, refers to any such software library or work
-which has been distributed under these terms.  A "work based on the
-Library" means either the Library or any derivative work under
-copyright law: that is to say, a work containing the Library or a
-portion of it, either verbatim or with modifications and/or translated
-straightforwardly into another language.  (Hereinafter, translation is
-included without limitation in the term "modification".)
-
-  "Source code" for a work means the preferred form of the work for
-making modifications to it.  For a library, complete source code means
-all the source code for all modules it contains, plus any associated
-interface definition files, plus the scripts used to control compilation
-and installation of the library.
-
-  Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running a program using the Library is not restricted, and output from
-such a program is covered only if its contents constitute a work based
-on the Library (independent of the use of the Library in a tool for
-writing it).  Whether that is true depends on what the Library does
-and what the program that uses the Library does.
-  
-  1. You may copy and distribute verbatim copies of the Library's
-complete source code as you receive it, in any medium, provided that
-you conspicuously and appropriately publish on each copy an
-appropriate copyright notice and disclaimer of warranty; keep intact
-all the notices that refer to this License and to the absence of any
-warranty; and distribute a copy of this License along with the
-Library.
-
-  You may charge a fee for the physical act of transferring a copy,
-and you may at your option offer warranty protection in exchange for a
-fee.
-
-  2. You may modify your copy or copies of the Library or any portion
-of it, thus forming a work based on the Library, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) The modified work must itself be a software library.
-
-    b) You must cause the files modified to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    c) You must cause the whole of the work to be licensed at no
-    charge to all third parties under the terms of this License.
-
-    d) If a facility in the modified Library refers to a function or a
-    table of data to be supplied by an application program that uses
-    the facility, other than as an argument passed when the facility
-    is invoked, then you must make a good faith effort to ensure that,
-    in the event an application does not supply such function or
-    table, the facility still operates, and performs whatever part of
-    its purpose remains meaningful.
-
-    (For example, a function in a library to compute square roots has
-    a purpose that is entirely well-defined independent of the
-    application.  Therefore, Subsection 2d requires that any
-    application-supplied function or table used by this function must
-    be optional: if the application does not supply it, the square
-    root function must still compute square roots.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Library,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Library, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote
-it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Library.
-
-In addition, mere aggregation of another work not based on the Library
-with the Library (or with a work based on the Library) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may opt to apply the terms of the ordinary GNU General Public
-License instead of this License to a given copy of the Library.  To do
-this, you must alter all the notices that refer to this License, so
-that they refer to the ordinary GNU General Public License, version 2,
-instead of to this License.  (If a newer version than version 2 of the
-ordinary GNU General Public License has appeared, then you can specify
-that version instead if you wish.)  Do not make any other change in
-these notices.
-
-  Once this change is made in a given copy, it is irreversible for
-that copy, so the ordinary GNU General Public License applies to all
-subsequent copies and derivative works made from that copy.
-
-  This option is useful when you wish to copy part of the code of
-the Library into a program that is not a library.
-
-  4. You may copy and distribute the Library (or a portion or
-derivative of it, under Section 2) in object code or executable form
-under the terms of Sections 1 and 2 above provided that you accompany
-it with the complete corresponding machine-readable source code, which
-must be distributed under the terms of Sections 1 and 2 above on a
-medium customarily used for software interchange.
-
-  If distribution of object code is made by offering access to copy
-from a designated place, then offering equivalent access to copy the
-source code from the same place satisfies the requirement to
-distribute the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  5. A program that contains no derivative of any portion of the
-Library, but is designed to work with the Library by being compiled or
-linked with it, is called a "work that uses the Library".  Such a
-work, in isolation, is not a derivative work of the Library, and
-therefore falls outside the scope of this License.
-
-  However, linking a "work that uses the Library" with the Library
-creates an executable that is a derivative of the Library (because it
-contains portions of the Library), rather than a "work that uses the
-library".  The executable is therefore covered by this License.
-Section 6 states terms for distribution of such executables.
-
-  When a "work that uses the Library" uses material from a header file
-that is part of the Library, the object code for the work may be a
-derivative work of the Library even though the source code is not.
-Whether this is true is especially significant if the work can be
-linked without the Library, or if the work is itself a library.  The
-threshold for this to be true is not precisely defined by law.
-
-  If such an object file uses only numerical parameters, data
-structure layouts and accessors, and small macros and small inline
-functions (ten lines or less in length), then the use of the object
-file is unrestricted, regardless of whether it is legally a derivative
-work.  (Executables containing this object code plus portions of the
-Library will still fall under Section 6.)
-
-  Otherwise, if the work is a derivative of the Library, you may
-distribute the object code for the work under the terms of Section 6.
-Any executables containing that work also fall under Section 6,
-whether or not they are linked directly with the Library itself.
-
-  6. As an exception to the Sections above, you may also combine or
-link a "work that uses the Library" with the Library to produce a
-work containing portions of the Library, and distribute that work
-under terms of your choice, provided that the terms permit
-modification of the work for the customer's own use and reverse
-engineering for debugging such modifications.
-
-  You must give prominent notice with each copy of the work that the
-Library is used in it and that the Library and its use are covered by
-this License.  You must supply a copy of this License.  If the work
-during execution displays copyright notices, you must include the
-copyright notice for the Library among them, as well as a reference
-directing the user to the copy of this License.  Also, you must do one
-of these things:
-
-    a) Accompany the work with the complete corresponding
-    machine-readable source code for the Library including whatever
-    changes were used in the work (which must be distributed under
-    Sections 1 and 2 above); and, if the work is an executable linked
-    with the Library, with the complete machine-readable "work that
-    uses the Library", as object code and/or source code, so that the
-    user can modify the Library and then relink to produce a modified
-    executable containing the modified Library.  (It is understood
-    that the user who changes the contents of definitions files in the
-    Library will not necessarily be able to recompile the application
-    to use the modified definitions.)
-
-    b) Use a suitable shared library mechanism for linking with the
-    Library.  A suitable mechanism is one that (1) uses at run time a
-    copy of the library already present on the user's computer system,
-    rather than copying library functions into the executable, and (2)
-    will operate properly with a modified version of the library, if
-    the user installs one, as long as the modified version is
-    interface-compatible with the version that the work was made with.
-
-    c) Accompany the work with a written offer, valid for at
-    least three years, to give the same user the materials
-    specified in Subsection 6a, above, for a charge no more
-    than the cost of performing this distribution.
-
-    d) If distribution of the work is made by offering access to copy
-    from a designated place, offer equivalent access to copy the above
-    specified materials from the same place.
-
-    e) Verify that the user has already received a copy of these
-    materials or that you have already sent this user a copy.
-
-  For an executable, the required form of the "work that uses the
-Library" must include any data and utility programs needed for
-reproducing the executable from it.  However, as a special exception,
-the materials to be distributed need not include anything that is
-normally distributed (in either source or binary form) with the major
-components (compiler, kernel, and so on) of the operating system on
-which the executable runs, unless that component itself accompanies
-the executable.
-
-  It may happen that this requirement contradicts the license
-restrictions of other proprietary libraries that do not normally
-accompany the operating system.  Such a contradiction means you cannot
-use both them and the Library together in an executable that you
-distribute.
-
-  7. You may place library facilities that are a work based on the
-Library side-by-side in a single library together with other library
-facilities not covered by this License, and distribute such a combined
-library, provided that the separate distribution of the work based on
-the Library and of the other library facilities is otherwise
-permitted, and provided that you do these two things:
-
-    a) Accompany the combined library with a copy of the same work
-    based on the Library, uncombined with any other library
-    facilities.  This must be distributed under the terms of the
-    Sections above.
-
-    b) Give prominent notice with the combined library of the fact
-    that part of it is a work based on the Library, and explaining
-    where to find the accompanying uncombined form of the same work.
-
-  8. You may not copy, modify, sublicense, link with, or distribute
-the Library except as expressly provided under this License.  Any
-attempt otherwise to copy, modify, sublicense, link with, or
-distribute the Library is void, and will automatically terminate your
-rights under this License.  However, parties who have received copies,
-or rights, from you under this License will not have their licenses
-terminated so long as such parties remain in full compliance.
-
-  9. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Library or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Library (or any work based on the
-Library), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Library or works based on it.
-
-  10. Each time you redistribute the Library (or any work based on the
-Library), the recipient automatically receives a license from the
-original licensor to copy, distribute, link with or modify the Library
-subject to these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties with
-this License.
-
-  11. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Library at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Library by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Library.
-
-If any portion of this section is held invalid or unenforceable under any
-particular circumstance, the balance of the section is intended to apply,
-and the section as a whole is intended to apply in other circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  12. If the distribution and/or use of the Library is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Library under this License may add
-an explicit geographical distribution limitation excluding those countries,
-so that distribution is permitted only in or among countries not thus
-excluded.  In such case, this License incorporates the limitation as if
-written in the body of this License.
-
-  13. The Free Software Foundation may publish revised and/or new
-versions of the Lesser General Public License from time to time.
-Such new versions will be similar in spirit to the present version,
-but may differ in detail to address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Library
-specifies a version number of this License which applies to it and
-"any later version", you have the option of following the terms and
-conditions either of that version or of any later version published by
-the Free Software Foundation.  If the Library does not specify a
-license version number, you may choose any version ever published by
-the Free Software Foundation.
-
-  14. If you wish to incorporate parts of the Library into other free
-programs whose distribution conditions are incompatible with these,
-write to the author to ask for permission.  For software which is
-copyrighted by the Free Software Foundation, write to the Free
-Software Foundation; we sometimes make exceptions for this.  Our
-decision will be guided by the two goals of preserving the free status
-of all derivatives of our free software and of promoting the sharing
-and reuse of software generally.
-
-			    NO WARRANTY
-
-  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
-WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
-EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
-OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
-KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
-LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
-THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
-WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
-AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
-FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
-CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
-LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
-RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
-FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
-SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
-DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-           How to Apply These Terms to Your New Libraries
-
-  If you develop a new library, and you want it to be of the greatest
-possible use to the public, we recommend making it free software that
-everyone can redistribute and change.  You can do so by permitting
-redistribution under these terms (or, alternatively, under the terms of the
-ordinary General Public License).
-
-  To apply these terms, attach the following notices to the library.  It is
-safest to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least the
-"copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the library's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-
-Also add information on how to contact you by electronic and paper mail.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the library, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the
-  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
-
-  <signature of Ty Coon>, 1 April 1990
-  Ty Coon, President of Vice
-
-That's all there is to it!
-
-
diff --git a/deps/haproxy-1.4.21/doc/queuing.fig b/deps/haproxy-1.4.21/doc/queuing.fig
deleted file mode 100644
index 8d57504..0000000
--- a/deps/haproxy-1.4.21/doc/queuing.fig
+++ /dev/null
@@ -1,192 +0,0 @@
-#FIG 3.2
-Portrait
-Center
-Metric
-A4      
-100.00
-Single
--2
-1200 2
-6 900 4770 1575 5220
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 3
-	 900 4770 1125 4995 1125 5220
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 3
-	 1575 4770 1350 4995 1350 5220
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 1170 4995 1170 5220
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 1215 4995 1215 5220
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 1260 4995 1260 5220
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 1305 4995 1305 5220
-2 3 0 1 7 7 52 -1 20 0.000 2 0 -1 0 0 7
-	 900 4770 1125 4995 1125 5220 1350 5220 1350 4995 1575 4770
-	 900 4770
--6
-6 2250 4770 2925 5220
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 3
-	 2250 4770 2475 4995 2475 5220
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 3
-	 2925 4770 2700 4995 2700 5220
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 2520 4995 2520 5220
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 2565 4995 2565 5220
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 2610 4995 2610 5220
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 2655 4995 2655 5220
-2 3 0 1 7 7 52 -1 20 0.000 2 0 -1 0 0 7
-	 2250 4770 2475 4995 2475 5220 2700 5220 2700 4995 2925 4770
-	 2250 4770
--6
-6 1710 3420 2115 3870
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 1710 3780 2115 3780
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 1710 3825 2115 3825
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 1710 3735 2115 3735
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 1710 3690 2115 3690
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 1710 3645 2115 3645
-2 1 0 1 0 6 51 -1 20 0.000 0 0 -1 0 0 4
-	 1710 3420 1710 3870 2115 3870 2115 3420
--6
-1 2 0 1 0 7 51 -1 20 0.000 1 0.0000 1935 2182 450 113 1485 2182 2385 2182
-1 2 0 1 0 7 51 -1 20 0.000 0 0.0000 2790 3082 450 113 2340 3082 3240 3082
-1 2 0 1 0 7 51 -1 20 0.000 1 0.0000 1935 1367 450 113 1485 1367 2385 1367
-1 2 0 1 0 7 51 -1 20 0.000 1 0.0000 1035 3082 450 113 585 3082 1485 3082
-2 1 2 1 0 2 53 -1 -1 3.000 0 0 -1 0 0 2
-	 2745 3870 3015 3870
-2 1 2 1 0 2 53 -1 -1 3.000 0 0 -1 0 0 2
-	 2745 4320 3015 4320
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 60.00 60.00
-	 2970 5085 2745 5085
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 60.00 60.00
-	 2205 5085 2430 5085
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 60.00 60.00
-	 1620 5085 1395 5085
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 1 0 2
-	1 1 1.00 60.00 60.00
-	 855 5085 1080 5085
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 1 0 3
-	0 0 1.00 60.00 60.00
-	 1890 3870 1440 4320 1440 4770
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 1 0 3
-	0 0 1.00 60.00 60.00
-	 1935 3870 2385 4320 2385 4770
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 1 0 2
-	0 0 1.00 60.00 60.00
-	 2610 4320 2610 4770
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 1 0 2
-	0 0 1.00 60.00 60.00
-	 2835 3195 2835 4770
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 1 0 3
-	0 0 1.00 60.00 60.00
-	 2745 3195 2610 3330 2610 3870
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 1 0 2
-	0 0 1.00 60.00 60.00
-	 1935 2295 1935 3420
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 1 0 3
-	0 0 1.00 60.00 60.00
-	 1080 3195 1215 3330 1215 3870
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 1 0 3
-	0 0 1.00 60.00 60.00
-	 1890 2295 1035 2745 1035 2970
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 1 0 3
-	0 0 1.00 60.00 60.00
-	 1980 2295 2790 2745 2790 2970
-2 1 0 1 0 2 50 -1 -1 0.000 0 0 -1 1 0 2
-	0 0 1.00 60.00 60.00
-	 1935 1485 1935 2070
-2 1 1 1 0 2 50 -1 -1 4.000 0 0 -1 1 0 5
-	0 0 1.00 60.00 60.00
-	 810 5220 450 5220 450 2160 1080 2160 1485 2160
-2 1 1 1 0 2 50 -1 -1 4.000 0 0 -1 1 0 5
-	0 0 1.00 60.00 60.00
-	 3060 5220 3375 5220 3375 2160 2655 2160 2385 2160
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 1 0 2
-	0 0 1.00 60.00 60.00
-	 1215 4320 1215 4770
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 1 0 2
-	0 0 1.00 60.00 60.00
-	 990 3195 990 4770
-2 1 0 1 0 2 50 -1 -1 0.000 0 0 -1 1 0 2
-	0 0 1.00 60.00 60.00
-	 1935 855 1935 1260
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 1 0 3
-	0 0 1.00 60.00 60.00
-	 1620 1440 900 2025 900 2970
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 1 0 3
-	0 0 1.00 60.00 60.00
-	 2205 1440 2925 2025 2925 2970
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 1125 4230 1350 4230
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 1125 4275 1350 4275
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 1125 4185 1350 4185
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 1125 4140 1350 4140
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 1125 4095 1350 4095
-2 1 0 1 0 3 51 -1 20 0.000 0 0 -1 0 0 4
-	 1125 3870 1125 4320 1350 4320 1350 3870
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 2700 4230 2475 4230
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 2700 4275 2475 4275
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 2700 4185 2475 4185
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 2700 4140 2475 4140
-2 1 0 1 0 3 51 -1 20 0.000 0 0 -1 0 0 4
-	 2700 3870 2700 4320 2475 4320 2475 3870
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 1125 4050 1350 4050
-2 1 0 1 0 7 50 -1 -1 0.000 0 0 -1 0 0 2
-	 1125 4005 1350 4005
-2 1 0 1 0 2 53 -1 -1 0.000 0 0 -1 1 1 2
-	0 0 1.00 60.00 60.00
-	0 0 1.00 60.00 60.00
-	 900 3870 900 4320
-2 1 2 1 0 2 53 -1 -1 3.000 0 0 -1 0 0 2
-	 855 3870 1125 3870
-2 1 2 1 0 2 53 -1 -1 3.000 0 0 -1 0 0 2
-	 855 4320 1125 4320
-2 1 0 1 0 2 53 -1 -1 0.000 0 0 -1 1 1 2
-	0 0 1.00 60.00 60.00
-	0 0 1.00 60.00 60.00
-	 2970 3870 2970 4320
-4 0 0 53 -1 16 7 0.0000 4 75 195 1260 3510 Yes\001
-4 2 0 53 -1 16 7 0.0000 4 75 135 945 3510 No\001
-4 2 0 53 -1 16 7 0.0000 4 75 195 2565 3510 Yes\001
-4 0 0 53 -1 16 7 0.0000 4 75 135 2880 3510 No\001
-4 1 0 50 -1 16 6 0.0000 4 75 210 1935 4140 global\001
-4 1 0 50 -1 16 6 0.0000 4 60 225 1935 4230 queue\001
-4 1 0 50 -1 16 8 1.5708 4 120 1005 405 4680 Redispatch on error\001
-4 1 0 53 -1 14 6 1.5708 4 60 480 2205 3645 maxqueue\001
-4 1 0 50 -1 18 8 0.0000 4 90 165 1935 2205 LB\001
-4 1 0 53 -1 16 7 1.5708 4 90 870 2070 2880 server, all are full.\001
-4 1 0 50 -1 18 8 0.0000 4 90 360 1935 1395 cookie\001
-4 1 0 50 -1 16 10 0.0000 4 135 1200 1935 765 Incoming request\001
-4 1 0 53 -1 16 7 1.5708 4 75 480 1890 1755 no cookie\001
-4 1 0 53 -1 16 7 1.5708 4 75 600 1890 2880 no available\001
-4 0 0 53 -1 16 7 5.6200 4 75 735 2340 1530 SRV2 selected\001
-4 1 0 50 -1 16 10 0.0000 4 105 405 1260 5445 SRV1\001
-4 1 0 50 -1 16 10 0.0000 4 105 405 2610 5445 SRV2\001
-4 2 0 53 -1 16 7 0.4712 4 75 735 1665 2385 SRV1 selected\001
-4 0 0 53 -1 16 7 5.8119 4 75 735 2205 2385 SRV2 selected\001
-4 2 0 53 -1 16 7 0.6632 4 75 735 1485 1530 SRV1 selected\001
-4 0 0 53 -1 14 6 0.0000 4 45 420 2880 5040 maxconn\001
-4 1 0 50 -1 16 8 1.5708 4 120 1005 3510 4680 Redispatch on error\001
-4 1 0 50 -1 18 8 0.0000 4 90 615 2790 3105 SRV2 full ?\001
-4 1 0 50 -1 18 8 0.0000 4 90 615 1035 3105 SRV1 full ?\001
-4 1 0 53 -1 14 6 1.5708 4 60 480 855 4095 maxqueue\001
-4 1 0 53 -1 14 6 1.5708 4 60 480 3105 4095 maxqueue\001
diff --git a/deps/haproxy-1.4.21/ebtree/compiler.h b/deps/haproxy-1.4.21/ebtree/compiler.h
deleted file mode 100644
index 7281f09..0000000
--- a/deps/haproxy-1.4.21/ebtree/compiler.h
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * ebtree/compiler.h
- * This files contains some compiler-specific settings.
- *
- * Copyright (C) 2000-2009 Willy Tarreau - w@1wt.eu
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#include <common/compiler.h>
-
diff --git a/deps/haproxy-1.4.21/ebtree/eb32tree.c b/deps/haproxy-1.4.21/ebtree/eb32tree.c
deleted file mode 100644
index f504105..0000000
--- a/deps/haproxy-1.4.21/ebtree/eb32tree.c
+++ /dev/null
@@ -1,218 +0,0 @@
-/*
- * Elastic Binary Trees - exported functions for operations on 32bit nodes.
- * Version 6.0
- * (C) 2002-2010 - Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-/* Consult eb32tree.h for more details about those functions */
-
-#include "eb32tree.h"
-
-REGPRM2 struct eb32_node *eb32_insert(struct eb_root *root, struct eb32_node *new)
-{
-	return __eb32_insert(root, new);
-}
-
-REGPRM2 struct eb32_node *eb32i_insert(struct eb_root *root, struct eb32_node *new)
-{
-	return __eb32i_insert(root, new);
-}
-
-REGPRM2 struct eb32_node *eb32_lookup(struct eb_root *root, u32 x)
-{
-	return __eb32_lookup(root, x);
-}
-
-REGPRM2 struct eb32_node *eb32i_lookup(struct eb_root *root, s32 x)
-{
-	return __eb32i_lookup(root, x);
-}
-
-/*
- * Find the last occurrence of the highest key in the tree <root>, which is
- * equal to or less than <x>. NULL is returned is no key matches.
- */
-REGPRM2 struct eb32_node *eb32_lookup_le(struct eb_root *root, u32 x)
-{
-	struct eb32_node *node;
-	eb_troot_t *troot;
-
-	troot = root->b[EB_LEFT];
-	if (unlikely(troot == NULL))
-		return NULL;
-
-	while (1) {
-		if ((eb_gettag(troot) == EB_LEAF)) {
-			/* We reached a leaf, which means that the whole upper
-			 * parts were common. We will return either the current
-			 * node or its next one if the former is too small.
-			 */
-			node = container_of(eb_untag(troot, EB_LEAF),
-					    struct eb32_node, node.branches);
-			if (node->key <= x)
-				return node;
-			/* return prev */
-			troot = node->node.leaf_p;
-			break;
-		}
-		node = container_of(eb_untag(troot, EB_NODE),
-				    struct eb32_node, node.branches);
-
-		if (node->node.bit < 0) {
-			/* We're at the top of a dup tree. Either we got a
-			 * matching value and we return the rightmost node, or
-			 * we don't and we skip the whole subtree to return the
-			 * prev node before the subtree. Note that since we're
-			 * at the top of the dup tree, we can simply return the
-			 * prev node without first trying to escape from the
-			 * tree.
-			 */
-			if (node->key <= x) {
-				troot = node->node.branches.b[EB_RGHT];
-				while (eb_gettag(troot) != EB_LEAF)
-					troot = (eb_untag(troot, EB_NODE))->b[EB_RGHT];
-				return container_of(eb_untag(troot, EB_LEAF),
-						    struct eb32_node, node.branches);
-			}
-			/* return prev */
-			troot = node->node.node_p;
-			break;
-		}
-
-		if (((x ^ node->key) >> node->node.bit) >= EB_NODE_BRANCHES) {
-			/* No more common bits at all. Either this node is too
-			 * small and we need to get its highest value, or it is
-			 * too large, and we need to get the prev value.
-			 */
-			if ((node->key >> node->node.bit) < (x >> node->node.bit)) {
-				troot = node->node.branches.b[EB_RGHT];
-				return eb32_entry(eb_walk_down(troot, EB_RGHT), struct eb32_node, node);
-			}
-
-			/* Further values will be too high here, so return the prev
-			 * unique node (if it exists).
-			 */
-			troot = node->node.node_p;
-			break;
-		}
-		troot = node->node.branches.b[(x >> node->node.bit) & EB_NODE_BRANCH_MASK];
-	}
-
-	/* If we get here, it means we want to report previous node before the
-	 * current one which is not above. <troot> is already initialised to
-	 * the parent's branches.
-	 */
-	while (eb_gettag(troot) == EB_LEFT) {
-		/* Walking up from left branch. We must ensure that we never
-		 * walk beyond root.
-		 */
-		if (unlikely(eb_clrtag((eb_untag(troot, EB_LEFT))->b[EB_RGHT]) == NULL))
-			return NULL;
-		troot = (eb_root_to_node(eb_untag(troot, EB_LEFT)))->node_p;
-	}
-	/* Note that <troot> cannot be NULL at this stage */
-	troot = (eb_untag(troot, EB_RGHT))->b[EB_LEFT];
-	node = eb32_entry(eb_walk_down(troot, EB_RGHT), struct eb32_node, node);
-	return node;
-}
-
-/*
- * Find the first occurrence of the lowest key in the tree <root>, which is
- * equal to or greater than <x>. NULL is returned is no key matches.
- */
-REGPRM2 struct eb32_node *eb32_lookup_ge(struct eb_root *root, u32 x)
-{
-	struct eb32_node *node;
-	eb_troot_t *troot;
-
-	troot = root->b[EB_LEFT];
-	if (unlikely(troot == NULL))
-		return NULL;
-
-	while (1) {
-		if ((eb_gettag(troot) == EB_LEAF)) {
-			/* We reached a leaf, which means that the whole upper
-			 * parts were common. We will return either the current
-			 * node or its next one if the former is too small.
-			 */
-			node = container_of(eb_untag(troot, EB_LEAF),
-					    struct eb32_node, node.branches);
-			if (node->key >= x)
-				return node;
-			/* return next */
-			troot = node->node.leaf_p;
-			break;
-		}
-		node = container_of(eb_untag(troot, EB_NODE),
-				    struct eb32_node, node.branches);
-
-		if (node->node.bit < 0) {
-			/* We're at the top of a dup tree. Either we got a
-			 * matching value and we return the leftmost node, or
-			 * we don't and we skip the whole subtree to return the
-			 * next node after the subtree. Note that since we're
-			 * at the top of the dup tree, we can simply return the
-			 * next node without first trying to escape from the
-			 * tree.
-			 */
-			if (node->key >= x) {
-				troot = node->node.branches.b[EB_LEFT];
-				while (eb_gettag(troot) != EB_LEAF)
-					troot = (eb_untag(troot, EB_NODE))->b[EB_LEFT];
-				return container_of(eb_untag(troot, EB_LEAF),
-						    struct eb32_node, node.branches);
-			}
-			/* return next */
-			troot = node->node.node_p;
-			break;
-		}
-
-		if (((x ^ node->key) >> node->node.bit) >= EB_NODE_BRANCHES) {
-			/* No more common bits at all. Either this node is too
-			 * large and we need to get its lowest value, or it is too
-			 * small, and we need to get the next value.
-			 */
-			if ((node->key >> node->node.bit) > (x >> node->node.bit)) {
-				troot = node->node.branches.b[EB_LEFT];
-				return eb32_entry(eb_walk_down(troot, EB_LEFT), struct eb32_node, node);
-			}
-
-			/* Further values will be too low here, so return the next
-			 * unique node (if it exists).
-			 */
-			troot = node->node.node_p;
-			break;
-		}
-		troot = node->node.branches.b[(x >> node->node.bit) & EB_NODE_BRANCH_MASK];
-	}
-
-	/* If we get here, it means we want to report next node after the
-	 * current one which is not below. <troot> is already initialised
-	 * to the parent's branches.
-	 */
-	while (eb_gettag(troot) != EB_LEFT)
-		/* Walking up from right branch, so we cannot be below root */
-		troot = (eb_root_to_node(eb_untag(troot, EB_RGHT)))->node_p;
-
-	/* Note that <troot> cannot be NULL at this stage */
-	troot = (eb_untag(troot, EB_LEFT))->b[EB_RGHT];
-	if (eb_clrtag(troot) == NULL)
-		return NULL;
-
-	node = eb32_entry(eb_walk_down(troot, EB_LEFT), struct eb32_node, node);
-	return node;
-}
diff --git a/deps/haproxy-1.4.21/ebtree/eb32tree.h b/deps/haproxy-1.4.21/ebtree/eb32tree.h
deleted file mode 100644
index c8d5243..0000000
--- a/deps/haproxy-1.4.21/ebtree/eb32tree.h
+++ /dev/null
@@ -1,487 +0,0 @@
-/*
- * Elastic Binary Trees - macros and structures for operations on 32bit nodes.
- * Version 6.0
- * (C) 2002-2010 - Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _EB32TREE_H
-#define _EB32TREE_H
-
-#include "ebtree.h"
-
-
-/* Return the structure of type <type> whose member <member> points to <ptr> */
-#define eb32_entry(ptr, type, member) container_of(ptr, type, member)
-
-#define EB32_ROOT	EB_ROOT
-#define EB32_TREE_HEAD	EB_TREE_HEAD
-
-/* These types may sometimes already be defined */
-typedef unsigned int u32;
-typedef   signed int s32;
-
-/* This structure carries a node, a leaf, and a key. It must start with the
- * eb_node so that it can be cast into an eb_node. We could also have put some
- * sort of transparent union here to reduce the indirection level, but the fact
- * is, the end user is not meant to manipulate internals, so this is pointless.
- */
-struct eb32_node {
-	struct eb_node node; /* the tree node, must be at the beginning */
-	u32 key;
-};
-
-/*
- * Exported functions and macros.
- * Many of them are always inlined because they are extremely small, and
- * are generally called at most once or twice in a program.
- */
-
-/* Return leftmost node in the tree, or NULL if none */
-static inline struct eb32_node *eb32_first(struct eb_root *root)
-{
-	return eb32_entry(eb_first(root), struct eb32_node, node);
-}
-
-/* Return rightmost node in the tree, or NULL if none */
-static inline struct eb32_node *eb32_last(struct eb_root *root)
-{
-	return eb32_entry(eb_last(root), struct eb32_node, node);
-}
-
-/* Return next node in the tree, or NULL if none */
-static inline struct eb32_node *eb32_next(struct eb32_node *eb32)
-{
-	return eb32_entry(eb_next(&eb32->node), struct eb32_node, node);
-}
-
-/* Return previous node in the tree, or NULL if none */
-static inline struct eb32_node *eb32_prev(struct eb32_node *eb32)
-{
-	return eb32_entry(eb_prev(&eb32->node), struct eb32_node, node);
-}
-
-/* Return next node in the tree, skipping duplicates, or NULL if none */
-static inline struct eb32_node *eb32_next_unique(struct eb32_node *eb32)
-{
-	return eb32_entry(eb_next_unique(&eb32->node), struct eb32_node, node);
-}
-
-/* Return previous node in the tree, skipping duplicates, or NULL if none */
-static inline struct eb32_node *eb32_prev_unique(struct eb32_node *eb32)
-{
-	return eb32_entry(eb_prev_unique(&eb32->node), struct eb32_node, node);
-}
-
-/* Delete node from the tree if it was linked in. Mark the node unused. Note
- * that this function relies on a non-inlined generic function: eb_delete.
- */
-static inline void eb32_delete(struct eb32_node *eb32)
-{
-	eb_delete(&eb32->node);
-}
-
-/*
- * The following functions are not inlined by default. They are declared
- * in eb32tree.c, which simply relies on their inline version.
- */
-REGPRM2 struct eb32_node *eb32_lookup(struct eb_root *root, u32 x);
-REGPRM2 struct eb32_node *eb32i_lookup(struct eb_root *root, s32 x);
-REGPRM2 struct eb32_node *eb32_lookup_le(struct eb_root *root, u32 x);
-REGPRM2 struct eb32_node *eb32_lookup_ge(struct eb_root *root, u32 x);
-REGPRM2 struct eb32_node *eb32_insert(struct eb_root *root, struct eb32_node *new);
-REGPRM2 struct eb32_node *eb32i_insert(struct eb_root *root, struct eb32_node *new);
-
-/*
- * The following functions are less likely to be used directly, because their
- * code is larger. The non-inlined version is preferred.
- */
-
-/* Delete node from the tree if it was linked in. Mark the node unused. */
-static forceinline void __eb32_delete(struct eb32_node *eb32)
-{
-	__eb_delete(&eb32->node);
-}
-
-/*
- * Find the first occurence of a key in the tree <root>. If none can be
- * found, return NULL.
- */
-static forceinline struct eb32_node *__eb32_lookup(struct eb_root *root, u32 x)
-{
-	struct eb32_node *node;
-	eb_troot_t *troot;
-	u32 y;
-	int node_bit;
-
-	troot = root->b[EB_LEFT];
-	if (unlikely(troot == NULL))
-		return NULL;
-
-	while (1) {
-		if ((eb_gettag(troot) == EB_LEAF)) {
-			node = container_of(eb_untag(troot, EB_LEAF),
-					    struct eb32_node, node.branches);
-			if (node->key == x)
-				return node;
-			else
-				return NULL;
-		}
-		node = container_of(eb_untag(troot, EB_NODE),
-				    struct eb32_node, node.branches);
-		node_bit = node->node.bit;
-
-		y = node->key ^ x;
-		if (!y) {
-			/* Either we found the node which holds the key, or
-			 * we have a dup tree. In the later case, we have to
-			 * walk it down left to get the first entry.
-			 */
-			if (node_bit < 0) {
-				troot = node->node.branches.b[EB_LEFT];
-				while (eb_gettag(troot) != EB_LEAF)
-					troot = (eb_untag(troot, EB_NODE))->b[EB_LEFT];
-				node = container_of(eb_untag(troot, EB_LEAF),
-						    struct eb32_node, node.branches);
-			}
-			return node;
-		}
-
-		if ((y >> node_bit) >= EB_NODE_BRANCHES)
-			return NULL; /* no more common bits */
-
-		troot = node->node.branches.b[(x >> node_bit) & EB_NODE_BRANCH_MASK];
-	}
-}
-
-/*
- * Find the first occurence of a signed key in the tree <root>. If none can
- * be found, return NULL.
- */
-static forceinline struct eb32_node *__eb32i_lookup(struct eb_root *root, s32 x)
-{
-	struct eb32_node *node;
-	eb_troot_t *troot;
-	u32 key = x ^ 0x80000000;
-	u32 y;
-	int node_bit;
-
-	troot = root->b[EB_LEFT];
-	if (unlikely(troot == NULL))
-		return NULL;
-
-	while (1) {
-		if ((eb_gettag(troot) == EB_LEAF)) {
-			node = container_of(eb_untag(troot, EB_LEAF),
-					    struct eb32_node, node.branches);
-			if (node->key == (u32)x)
-				return node;
-			else
-				return NULL;
-		}
-		node = container_of(eb_untag(troot, EB_NODE),
-				    struct eb32_node, node.branches);
-		node_bit = node->node.bit;
-
-		y = node->key ^ x;
-		if (!y) {
-			/* Either we found the node which holds the key, or
-			 * we have a dup tree. In the later case, we have to
-			 * walk it down left to get the first entry.
-			 */
-			if (node_bit < 0) {
-				troot = node->node.branches.b[EB_LEFT];
-				while (eb_gettag(troot) != EB_LEAF)
-					troot = (eb_untag(troot, EB_NODE))->b[EB_LEFT];
-				node = container_of(eb_untag(troot, EB_LEAF),
-						    struct eb32_node, node.branches);
-			}
-			return node;
-		}
-
-		if ((y >> node_bit) >= EB_NODE_BRANCHES)
-			return NULL; /* no more common bits */
-
-		troot = node->node.branches.b[(key >> node_bit) & EB_NODE_BRANCH_MASK];
-	}
-}
-
-/* Insert eb32_node <new> into subtree starting at node root <root>.
- * Only new->key needs be set with the key. The eb32_node is returned.
- * If root->b[EB_RGHT]==1, the tree may only contain unique keys.
- */
-static forceinline struct eb32_node *
-__eb32_insert(struct eb_root *root, struct eb32_node *new) {
-	struct eb32_node *old;
-	unsigned int side;
-	eb_troot_t *troot, **up_ptr;
-	u32 newkey; /* caching the key saves approximately one cycle */
-	eb_troot_t *root_right;
-	eb_troot_t *new_left, *new_rght;
-	eb_troot_t *new_leaf;
-	int old_node_bit;
-
-	side = EB_LEFT;
-	troot = root->b[EB_LEFT];
-	root_right = root->b[EB_RGHT];
-	if (unlikely(troot == NULL)) {
-		/* Tree is empty, insert the leaf part below the left branch */
-		root->b[EB_LEFT] = eb_dotag(&new->node.branches, EB_LEAF);
-		new->node.leaf_p = eb_dotag(root, EB_LEFT);
-		new->node.node_p = NULL; /* node part unused */
-		return new;
-	}
-
-	/* The tree descent is fairly easy :
-	 *  - first, check if we have reached a leaf node
-	 *  - second, check if we have gone too far
-	 *  - third, reiterate
-	 * Everywhere, we use <new> for the node node we are inserting, <root>
-	 * for the node we attach it to, and <old> for the node we are
-	 * displacing below <new>. <troot> will always point to the future node
-	 * (tagged with its type). <side> carries the side the node <new> is
-	 * attached to below its parent, which is also where previous node
-	 * was attached. <newkey> carries the key being inserted.
-	 */
-	newkey = new->key;
-
-	while (1) {
-		if (eb_gettag(troot) == EB_LEAF) {
-			/* insert above a leaf */
-			old = container_of(eb_untag(troot, EB_LEAF),
-					    struct eb32_node, node.branches);
-			new->node.node_p = old->node.leaf_p;
-			up_ptr = &old->node.leaf_p;
-			break;
-		}
-
-		/* OK we're walking down this link */
-		old = container_of(eb_untag(troot, EB_NODE),
-				    struct eb32_node, node.branches);
-		old_node_bit = old->node.bit;
-
-		/* Stop going down when we don't have common bits anymore. We
-		 * also stop in front of a duplicates tree because it means we
-		 * have to insert above.
-		 */
-
-		if ((old_node_bit < 0) || /* we're above a duplicate tree, stop here */
-		    (((new->key ^ old->key) >> old_node_bit) >= EB_NODE_BRANCHES)) {
-			/* The tree did not contain the key, so we insert <new> before the node
-			 * <old>, and set ->bit to designate the lowest bit position in <new>
-			 * which applies to ->branches.b[].
-			 */
-			new->node.node_p = old->node.node_p;
-			up_ptr = &old->node.node_p;
-			break;
-		}
-
-		/* walk down */
-		root = &old->node.branches;
-		side = (newkey >> old_node_bit) & EB_NODE_BRANCH_MASK;
-		troot = root->b[side];
-	}
-
-	new_left = eb_dotag(&new->node.branches, EB_LEFT);
-	new_rght = eb_dotag(&new->node.branches, EB_RGHT);
-	new_leaf = eb_dotag(&new->node.branches, EB_LEAF);
-
-	/* We need the common higher bits between new->key and old->key.
-	 * What differences are there between new->key and the node here ?
-	 * NOTE that bit(new) is always < bit(root) because highest
-	 * bit of new->key and old->key are identical here (otherwise they
-	 * would sit on different branches).
-	 */
-
-	// note that if EB_NODE_BITS > 1, we should check that it's still >= 0
-	new->node.bit = flsnz(new->key ^ old->key) - EB_NODE_BITS;
-
-	if (new->key == old->key) {
-		new->node.bit = -1; /* mark as new dup tree, just in case */
-
-		if (likely(eb_gettag(root_right))) {
-			/* we refuse to duplicate this key if the tree is
-			 * tagged as containing only unique keys.
-			 */
-			return old;
-		}
-
-		if (eb_gettag(troot) != EB_LEAF) {
-			/* there was already a dup tree below */
-			struct eb_node *ret;
-			ret = eb_insert_dup(&old->node, &new->node);
-			return container_of(ret, struct eb32_node, node);
-		}
-		/* otherwise fall through */
-	}
-
-	if (new->key >= old->key) {
-		new->node.branches.b[EB_LEFT] = troot;
-		new->node.branches.b[EB_RGHT] = new_leaf;
-		new->node.leaf_p = new_rght;
-		*up_ptr = new_left;
-	}
-	else {
-		new->node.branches.b[EB_LEFT] = new_leaf;
-		new->node.branches.b[EB_RGHT] = troot;
-		new->node.leaf_p = new_left;
-		*up_ptr = new_rght;
-	}
-
-	/* Ok, now we are inserting <new> between <root> and <old>. <old>'s
-	 * parent is already set to <new>, and the <root>'s branch is still in
-	 * <side>. Update the root's leaf till we have it. Note that we can also
-	 * find the side by checking the side of new->node.node_p.
-	 */
-
-	root->b[side] = eb_dotag(&new->node.branches, EB_NODE);
-	return new;
-}
-
-/* Insert eb32_node <new> into subtree starting at node root <root>, using
- * signed keys. Only new->key needs be set with the key. The eb32_node
- * is returned. If root->b[EB_RGHT]==1, the tree may only contain unique keys.
- */
-static forceinline struct eb32_node *
-__eb32i_insert(struct eb_root *root, struct eb32_node *new) {
-	struct eb32_node *old;
-	unsigned int side;
-	eb_troot_t *troot, **up_ptr;
-	int newkey; /* caching the key saves approximately one cycle */
-	eb_troot_t *root_right;
-	eb_troot_t *new_left, *new_rght;
-	eb_troot_t *new_leaf;
-	int old_node_bit;
-
-	side = EB_LEFT;
-	troot = root->b[EB_LEFT];
-	root_right = root->b[EB_RGHT];
-	if (unlikely(troot == NULL)) {
-		/* Tree is empty, insert the leaf part below the left branch */
-		root->b[EB_LEFT] = eb_dotag(&new->node.branches, EB_LEAF);
-		new->node.leaf_p = eb_dotag(root, EB_LEFT);
-		new->node.node_p = NULL; /* node part unused */
-		return new;
-	}
-
-	/* The tree descent is fairly easy :
-	 *  - first, check if we have reached a leaf node
-	 *  - second, check if we have gone too far
-	 *  - third, reiterate
-	 * Everywhere, we use <new> for the node node we are inserting, <root>
-	 * for the node we attach it to, and <old> for the node we are
-	 * displacing below <new>. <troot> will always point to the future node
-	 * (tagged with its type). <side> carries the side the node <new> is
-	 * attached to below its parent, which is also where previous node
-	 * was attached. <newkey> carries a high bit shift of the key being
-	 * inserted in order to have negative keys stored before positive
-	 * ones.
-	 */
-	newkey = new->key + 0x80000000;
-
-	while (1) {
-		if (eb_gettag(troot) == EB_LEAF) {
-			old = container_of(eb_untag(troot, EB_LEAF),
-					    struct eb32_node, node.branches);
-			new->node.node_p = old->node.leaf_p;
-			up_ptr = &old->node.leaf_p;
-			break;
-		}
-
-		/* OK we're walking down this link */
-		old = container_of(eb_untag(troot, EB_NODE),
-				    struct eb32_node, node.branches);
-		old_node_bit = old->node.bit;
-
-		/* Stop going down when we don't have common bits anymore. We
-		 * also stop in front of a duplicates tree because it means we
-		 * have to insert above.
-		 */
-
-		if ((old_node_bit < 0) || /* we're above a duplicate tree, stop here */
-		    (((new->key ^ old->key) >> old_node_bit) >= EB_NODE_BRANCHES)) {
-			/* The tree did not contain the key, so we insert <new> before the node
-			 * <old>, and set ->bit to designate the lowest bit position in <new>
-			 * which applies to ->branches.b[].
-			 */
-			new->node.node_p = old->node.node_p;
-			up_ptr = &old->node.node_p;
-			break;
-		}
-
-		/* walk down */
-		root = &old->node.branches;
-		side = (newkey >> old_node_bit) & EB_NODE_BRANCH_MASK;
-		troot = root->b[side];
-	}
-
-	new_left = eb_dotag(&new->node.branches, EB_LEFT);
-	new_rght = eb_dotag(&new->node.branches, EB_RGHT);
-	new_leaf = eb_dotag(&new->node.branches, EB_LEAF);
-
-	/* We need the common higher bits between new->key and old->key.
-	 * What differences are there between new->key and the node here ?
-	 * NOTE that bit(new) is always < bit(root) because highest
-	 * bit of new->key and old->key are identical here (otherwise they
-	 * would sit on different branches).
-	 */
-
-	// note that if EB_NODE_BITS > 1, we should check that it's still >= 0
-	new->node.bit = flsnz(new->key ^ old->key) - EB_NODE_BITS;
-
-	if (new->key == old->key) {
-		new->node.bit = -1; /* mark as new dup tree, just in case */
-
-		if (likely(eb_gettag(root_right))) {
-			/* we refuse to duplicate this key if the tree is
-			 * tagged as containing only unique keys.
-			 */
-			return old;
-		}
-
-		if (eb_gettag(troot) != EB_LEAF) {
-			/* there was already a dup tree below */
-			struct eb_node *ret;
-			ret = eb_insert_dup(&old->node, &new->node);
-			return container_of(ret, struct eb32_node, node);
-		}
-		/* otherwise fall through */
-	}
-
-	if ((s32)new->key >= (s32)old->key) {
-		new->node.branches.b[EB_LEFT] = troot;
-		new->node.branches.b[EB_RGHT] = new_leaf;
-		new->node.leaf_p = new_rght;
-		*up_ptr = new_left;
-	}
-	else {
-		new->node.branches.b[EB_LEFT] = new_leaf;
-		new->node.branches.b[EB_RGHT] = troot;
-		new->node.leaf_p = new_left;
-		*up_ptr = new_rght;
-	}
-
-	/* Ok, now we are inserting <new> between <root> and <old>. <old>'s
-	 * parent is already set to <new>, and the <root>'s branch is still in
-	 * <side>. Update the root's leaf till we have it. Note that we can also
-	 * find the side by checking the side of new->node.node_p.
-	 */
-
-	root->b[side] = eb_dotag(&new->node.branches, EB_NODE);
-	return new;
-}
-
-#endif /* _EB32_TREE_H */
diff --git a/deps/haproxy-1.4.21/ebtree/eb64tree.c b/deps/haproxy-1.4.21/ebtree/eb64tree.c
deleted file mode 100644
index 3d18fb2..0000000
--- a/deps/haproxy-1.4.21/ebtree/eb64tree.c
+++ /dev/null
@@ -1,218 +0,0 @@
-/*
- * Elastic Binary Trees - exported functions for operations on 64bit nodes.
- * Version 6.0
- * (C) 2002-2010 - Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-/* Consult eb64tree.h for more details about those functions */
-
-#include "eb64tree.h"
-
-REGPRM2 struct eb64_node *eb64_insert(struct eb_root *root, struct eb64_node *new)
-{
-	return __eb64_insert(root, new);
-}
-
-REGPRM2 struct eb64_node *eb64i_insert(struct eb_root *root, struct eb64_node *new)
-{
-	return __eb64i_insert(root, new);
-}
-
-REGPRM2 struct eb64_node *eb64_lookup(struct eb_root *root, u64 x)
-{
-	return __eb64_lookup(root, x);
-}
-
-REGPRM2 struct eb64_node *eb64i_lookup(struct eb_root *root, s64 x)
-{
-	return __eb64i_lookup(root, x);
-}
-
-/*
- * Find the last occurrence of the highest key in the tree <root>, which is
- * equal to or less than <x>. NULL is returned is no key matches.
- */
-REGPRM2 struct eb64_node *eb64_lookup_le(struct eb_root *root, u64 x)
-{
-	struct eb64_node *node;
-	eb_troot_t *troot;
-
-	troot = root->b[EB_LEFT];
-	if (unlikely(troot == NULL))
-		return NULL;
-
-	while (1) {
-		if ((eb_gettag(troot) == EB_LEAF)) {
-			/* We reached a leaf, which means that the whole upper
-			 * parts were common. We will return either the current
-			 * node or its next one if the former is too small.
-			 */
-			node = container_of(eb_untag(troot, EB_LEAF),
-					    struct eb64_node, node.branches);
-			if (node->key <= x)
-				return node;
-			/* return prev */
-			troot = node->node.leaf_p;
-			break;
-		}
-		node = container_of(eb_untag(troot, EB_NODE),
-				    struct eb64_node, node.branches);
-
-		if (node->node.bit < 0) {
-			/* We're at the top of a dup tree. Either we got a
-			 * matching value and we return the rightmost node, or
-			 * we don't and we skip the whole subtree to return the
-			 * prev node before the subtree. Note that since we're
-			 * at the top of the dup tree, we can simply return the
-			 * prev node without first trying to escape from the
-			 * tree.
-			 */
-			if (node->key <= x) {
-				troot = node->node.branches.b[EB_RGHT];
-				while (eb_gettag(troot) != EB_LEAF)
-					troot = (eb_untag(troot, EB_NODE))->b[EB_RGHT];
-				return container_of(eb_untag(troot, EB_LEAF),
-						    struct eb64_node, node.branches);
-			}
-			/* return prev */
-			troot = node->node.node_p;
-			break;
-		}
-
-		if (((x ^ node->key) >> node->node.bit) >= EB_NODE_BRANCHES) {
-			/* No more common bits at all. Either this node is too
-			 * small and we need to get its highest value, or it is
-			 * too large, and we need to get the prev value.
-			 */
-			if ((node->key >> node->node.bit) < (x >> node->node.bit)) {
-				troot = node->node.branches.b[EB_RGHT];
-				return eb64_entry(eb_walk_down(troot, EB_RGHT), struct eb64_node, node);
-			}
-
-			/* Further values will be too high here, so return the prev
-			 * unique node (if it exists).
-			 */
-			troot = node->node.node_p;
-			break;
-		}
-		troot = node->node.branches.b[(x >> node->node.bit) & EB_NODE_BRANCH_MASK];
-	}
-
-	/* If we get here, it means we want to report previous node before the
-	 * current one which is not above. <troot> is already initialised to
-	 * the parent's branches.
-	 */
-	while (eb_gettag(troot) == EB_LEFT) {
-		/* Walking up from left branch. We must ensure that we never
-		 * walk beyond root.
-		 */
-		if (unlikely(eb_clrtag((eb_untag(troot, EB_LEFT))->b[EB_RGHT]) == NULL))
-			return NULL;
-		troot = (eb_root_to_node(eb_untag(troot, EB_LEFT)))->node_p;
-	}
-	/* Note that <troot> cannot be NULL at this stage */
-	troot = (eb_untag(troot, EB_RGHT))->b[EB_LEFT];
-	node = eb64_entry(eb_walk_down(troot, EB_RGHT), struct eb64_node, node);
-	return node;
-}
-
-/*
- * Find the first occurrence of the lowest key in the tree <root>, which is
- * equal to or greater than <x>. NULL is returned is no key matches.
- */
-REGPRM2 struct eb64_node *eb64_lookup_ge(struct eb_root *root, u64 x)
-{
-	struct eb64_node *node;
-	eb_troot_t *troot;
-
-	troot = root->b[EB_LEFT];
-	if (unlikely(troot == NULL))
-		return NULL;
-
-	while (1) {
-		if ((eb_gettag(troot) == EB_LEAF)) {
-			/* We reached a leaf, which means that the whole upper
-			 * parts were common. We will return either the current
-			 * node or its next one if the former is too small.
-			 */
-			node = container_of(eb_untag(troot, EB_LEAF),
-					    struct eb64_node, node.branches);
-			if (node->key >= x)
-				return node;
-			/* return next */
-			troot = node->node.leaf_p;
-			break;
-		}
-		node = container_of(eb_untag(troot, EB_NODE),
-				    struct eb64_node, node.branches);
-
-		if (node->node.bit < 0) {
-			/* We're at the top of a dup tree. Either we got a
-			 * matching value and we return the leftmost node, or
-			 * we don't and we skip the whole subtree to return the
-			 * next node after the subtree. Note that since we're
-			 * at the top of the dup tree, we can simply return the
-			 * next node without first trying to escape from the
-			 * tree.
-			 */
-			if (node->key >= x) {
-				troot = node->node.branches.b[EB_LEFT];
-				while (eb_gettag(troot) != EB_LEAF)
-					troot = (eb_untag(troot, EB_NODE))->b[EB_LEFT];
-				return container_of(eb_untag(troot, EB_LEAF),
-						    struct eb64_node, node.branches);
-			}
-			/* return next */
-			troot = node->node.node_p;
-			break;
-		}
-
-		if (((x ^ node->key) >> node->node.bit) >= EB_NODE_BRANCHES) {
-			/* No more common bits at all. Either this node is too
-			 * large and we need to get its lowest value, or it is too
-			 * small, and we need to get the next value.
-			 */
-			if ((node->key >> node->node.bit) > (x >> node->node.bit)) {
-				troot = node->node.branches.b[EB_LEFT];
-				return eb64_entry(eb_walk_down(troot, EB_LEFT), struct eb64_node, node);
-			}
-
-			/* Further values will be too low here, so return the next
-			 * unique node (if it exists).
-			 */
-			troot = node->node.node_p;
-			break;
-		}
-		troot = node->node.branches.b[(x >> node->node.bit) & EB_NODE_BRANCH_MASK];
-	}
-
-	/* If we get here, it means we want to report next node after the
-	 * current one which is not below. <troot> is already initialised
-	 * to the parent's branches.
-	 */
-	while (eb_gettag(troot) != EB_LEFT)
-		/* Walking up from right branch, so we cannot be below root */
-		troot = (eb_root_to_node(eb_untag(troot, EB_RGHT)))->node_p;
-
-	/* Note that <troot> cannot be NULL at this stage */
-	troot = (eb_untag(troot, EB_LEFT))->b[EB_RGHT];
-	if (eb_clrtag(troot) == NULL)
-		return NULL;
-
-	node = eb64_entry(eb_walk_down(troot, EB_LEFT), struct eb64_node, node);
-	return node;
-}
diff --git a/deps/haproxy-1.4.21/ebtree/eb64tree.h b/deps/haproxy-1.4.21/ebtree/eb64tree.h
deleted file mode 100644
index bcb1ec2..0000000
--- a/deps/haproxy-1.4.21/ebtree/eb64tree.h
+++ /dev/null
@@ -1,572 +0,0 @@
-/*
- * Elastic Binary Trees - macros and structures for operations on 64bit nodes.
- * Version 6.0
- * (C) 2002-2010 - Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _EB64TREE_H
-#define _EB64TREE_H
-
-#include "ebtree.h"
-
-
-/* Return the structure of type <type> whose member <member> points to <ptr> */
-#define eb64_entry(ptr, type, member) container_of(ptr, type, member)
-
-#define EB64_ROOT	EB_ROOT
-#define EB64_TREE_HEAD	EB_TREE_HEAD
-
-/* These types may sometimes already be defined */
-typedef unsigned long long u64;
-typedef   signed long long s64;
-
-/* This structure carries a node, a leaf, and a key. It must start with the
- * eb_node so that it can be cast into an eb_node. We could also have put some
- * sort of transparent union here to reduce the indirection level, but the fact
- * is, the end user is not meant to manipulate internals, so this is pointless.
- */
-struct eb64_node {
-	struct eb_node node; /* the tree node, must be at the beginning */
-	u64 key;
-};
-
-/*
- * Exported functions and macros.
- * Many of them are always inlined because they are extremely small, and
- * are generally called at most once or twice in a program.
- */
-
-/* Return leftmost node in the tree, or NULL if none */
-static inline struct eb64_node *eb64_first(struct eb_root *root)
-{
-	return eb64_entry(eb_first(root), struct eb64_node, node);
-}
-
-/* Return rightmost node in the tree, or NULL if none */
-static inline struct eb64_node *eb64_last(struct eb_root *root)
-{
-	return eb64_entry(eb_last(root), struct eb64_node, node);
-}
-
-/* Return next node in the tree, or NULL if none */
-static inline struct eb64_node *eb64_next(struct eb64_node *eb64)
-{
-	return eb64_entry(eb_next(&eb64->node), struct eb64_node, node);
-}
-
-/* Return previous node in the tree, or NULL if none */
-static inline struct eb64_node *eb64_prev(struct eb64_node *eb64)
-{
-	return eb64_entry(eb_prev(&eb64->node), struct eb64_node, node);
-}
-
-/* Return next node in the tree, skipping duplicates, or NULL if none */
-static inline struct eb64_node *eb64_next_unique(struct eb64_node *eb64)
-{
-	return eb64_entry(eb_next_unique(&eb64->node), struct eb64_node, node);
-}
-
-/* Return previous node in the tree, skipping duplicates, or NULL if none */
-static inline struct eb64_node *eb64_prev_unique(struct eb64_node *eb64)
-{
-	return eb64_entry(eb_prev_unique(&eb64->node), struct eb64_node, node);
-}
-
-/* Delete node from the tree if it was linked in. Mark the node unused. Note
- * that this function relies on a non-inlined generic function: eb_delete.
- */
-static inline void eb64_delete(struct eb64_node *eb64)
-{
-	eb_delete(&eb64->node);
-}
-
-/*
- * The following functions are not inlined by default. They are declared
- * in eb64tree.c, which simply relies on their inline version.
- */
-REGPRM2 struct eb64_node *eb64_lookup(struct eb_root *root, u64 x);
-REGPRM2 struct eb64_node *eb64i_lookup(struct eb_root *root, s64 x);
-REGPRM2 struct eb64_node *eb64_lookup_le(struct eb_root *root, u64 x);
-REGPRM2 struct eb64_node *eb64_lookup_ge(struct eb_root *root, u64 x);
-REGPRM2 struct eb64_node *eb64_insert(struct eb_root *root, struct eb64_node *new);
-REGPRM2 struct eb64_node *eb64i_insert(struct eb_root *root, struct eb64_node *new);
-
-/*
- * The following functions are less likely to be used directly, because their
- * code is larger. The non-inlined version is preferred.
- */
-
-/* Delete node from the tree if it was linked in. Mark the node unused. */
-static forceinline void __eb64_delete(struct eb64_node *eb64)
-{
-	__eb_delete(&eb64->node);
-}
-
-/*
- * Find the first occurence of a key in the tree <root>. If none can be
- * found, return NULL.
- */
-static forceinline struct eb64_node *__eb64_lookup(struct eb_root *root, u64 x)
-{
-	struct eb64_node *node;
-	eb_troot_t *troot;
-	u64 y;
-
-	troot = root->b[EB_LEFT];
-	if (unlikely(troot == NULL))
-		return NULL;
-
-	while (1) {
-		if ((eb_gettag(troot) == EB_LEAF)) {
-			node = container_of(eb_untag(troot, EB_LEAF),
-					    struct eb64_node, node.branches);
-			if (node->key == x)
-				return node;
-			else
-				return NULL;
-		}
-		node = container_of(eb_untag(troot, EB_NODE),
-				    struct eb64_node, node.branches);
-
-		y = node->key ^ x;
-		if (!y) {
-			/* Either we found the node which holds the key, or
-			 * we have a dup tree. In the later case, we have to
-			 * walk it down left to get the first entry.
-			 */
-			if (node->node.bit < 0) {
-				troot = node->node.branches.b[EB_LEFT];
-				while (eb_gettag(troot) != EB_LEAF)
-					troot = (eb_untag(troot, EB_NODE))->b[EB_LEFT];
-				node = container_of(eb_untag(troot, EB_LEAF),
-						    struct eb64_node, node.branches);
-			}
-			return node;
-		}
-
-		if ((y >> node->node.bit) >= EB_NODE_BRANCHES)
-			return NULL; /* no more common bits */
-
-		troot = node->node.branches.b[(x >> node->node.bit) & EB_NODE_BRANCH_MASK];
-	}
-}
-
-/*
- * Find the first occurence of a signed key in the tree <root>. If none can
- * be found, return NULL.
- */
-static forceinline struct eb64_node *__eb64i_lookup(struct eb_root *root, s64 x)
-{
-	struct eb64_node *node;
-	eb_troot_t *troot;
-	u64 key = x ^ (1ULL << 63);
-	u64 y;
-
-	troot = root->b[EB_LEFT];
-	if (unlikely(troot == NULL))
-		return NULL;
-
-	while (1) {
-		if ((eb_gettag(troot) == EB_LEAF)) {
-			node = container_of(eb_untag(troot, EB_LEAF),
-					    struct eb64_node, node.branches);
-			if (node->key == (u64)x)
-				return node;
-			else
-				return NULL;
-		}
-		node = container_of(eb_untag(troot, EB_NODE),
-				    struct eb64_node, node.branches);
-
-		y = node->key ^ x;
-		if (!y) {
-			/* Either we found the node which holds the key, or
-			 * we have a dup tree. In the later case, we have to
-			 * walk it down left to get the first entry.
-			 */
-			if (node->node.bit < 0) {
-				troot = node->node.branches.b[EB_LEFT];
-				while (eb_gettag(troot) != EB_LEAF)
-					troot = (eb_untag(troot, EB_NODE))->b[EB_LEFT];
-				node = container_of(eb_untag(troot, EB_LEAF),
-						    struct eb64_node, node.branches);
-			}
-			return node;
-		}
-
-		if ((y >> node->node.bit) >= EB_NODE_BRANCHES)
-			return NULL; /* no more common bits */
-
-		troot = node->node.branches.b[(key >> node->node.bit) & EB_NODE_BRANCH_MASK];
-	}
-}
-
-/* Insert eb64_node <new> into subtree starting at node root <root>.
- * Only new->key needs be set with the key. The eb64_node is returned.
- * If root->b[EB_RGHT]==1, the tree may only contain unique keys.
- */
-static forceinline struct eb64_node *
-__eb64_insert(struct eb_root *root, struct eb64_node *new) {
-	struct eb64_node *old;
-	unsigned int side;
-	eb_troot_t *troot;
-	u64 newkey; /* caching the key saves approximately one cycle */
-	eb_troot_t *root_right;
-	int old_node_bit;
-
-	side = EB_LEFT;
-	troot = root->b[EB_LEFT];
-	root_right = root->b[EB_RGHT];
-	if (unlikely(troot == NULL)) {
-		/* Tree is empty, insert the leaf part below the left branch */
-		root->b[EB_LEFT] = eb_dotag(&new->node.branches, EB_LEAF);
-		new->node.leaf_p = eb_dotag(root, EB_LEFT);
-		new->node.node_p = NULL; /* node part unused */
-		return new;
-	}
-
-	/* The tree descent is fairly easy :
-	 *  - first, check if we have reached a leaf node
-	 *  - second, check if we have gone too far
-	 *  - third, reiterate
-	 * Everywhere, we use <new> for the node node we are inserting, <root>
-	 * for the node we attach it to, and <old> for the node we are
-	 * displacing below <new>. <troot> will always point to the future node
-	 * (tagged with its type). <side> carries the side the node <new> is
-	 * attached to below its parent, which is also where previous node
-	 * was attached. <newkey> carries the key being inserted.
-	 */
-	newkey = new->key;
-
-	while (1) {
-		if (unlikely(eb_gettag(troot) == EB_LEAF)) {
-			eb_troot_t *new_left, *new_rght;
-			eb_troot_t *new_leaf, *old_leaf;
-
-			old = container_of(eb_untag(troot, EB_LEAF),
-					    struct eb64_node, node.branches);
-
-			new_left = eb_dotag(&new->node.branches, EB_LEFT);
-			new_rght = eb_dotag(&new->node.branches, EB_RGHT);
-			new_leaf = eb_dotag(&new->node.branches, EB_LEAF);
-			old_leaf = eb_dotag(&old->node.branches, EB_LEAF);
-
-			new->node.node_p = old->node.leaf_p;
-
-			/* Right here, we have 3 possibilities :
-			   - the tree does not contain the key, and we have
-			     new->key < old->key. We insert new above old, on
-			     the left ;
-
-			   - the tree does not contain the key, and we have
-			     new->key > old->key. We insert new above old, on
-			     the right ;
-
-			   - the tree does contain the key, which implies it
-			     is alone. We add the new key next to it as a
-			     first duplicate.
-
-			   The last two cases can easily be partially merged.
-			*/
-			 
-			if (new->key < old->key) {
-				new->node.leaf_p = new_left;
-				old->node.leaf_p = new_rght;
-				new->node.branches.b[EB_LEFT] = new_leaf;
-				new->node.branches.b[EB_RGHT] = old_leaf;
-			} else {
-				/* we may refuse to duplicate this key if the tree is
-				 * tagged as containing only unique keys.
-				 */
-				if ((new->key == old->key) && eb_gettag(root_right))
-					return old;
-
-				/* new->key >= old->key, new goes the right */
-				old->node.leaf_p = new_left;
-				new->node.leaf_p = new_rght;
-				new->node.branches.b[EB_LEFT] = old_leaf;
-				new->node.branches.b[EB_RGHT] = new_leaf;
-
-				if (new->key == old->key) {
-					new->node.bit = -1;
-					root->b[side] = eb_dotag(&new->node.branches, EB_NODE);
-					return new;
-				}
-			}
-			break;
-		}
-
-		/* OK we're walking down this link */
-		old = container_of(eb_untag(troot, EB_NODE),
-				    struct eb64_node, node.branches);
-		old_node_bit = old->node.bit;
-
-		/* Stop going down when we don't have common bits anymore. We
-		 * also stop in front of a duplicates tree because it means we
-		 * have to insert above.
-		 */
-
-		if ((old_node_bit < 0) || /* we're above a duplicate tree, stop here */
-		    (((new->key ^ old->key) >> old_node_bit) >= EB_NODE_BRANCHES)) {
-			/* The tree did not contain the key, so we insert <new> before the node
-			 * <old>, and set ->bit to designate the lowest bit position in <new>
-			 * which applies to ->branches.b[].
-			 */
-			eb_troot_t *new_left, *new_rght;
-			eb_troot_t *new_leaf, *old_node;
-
-			new_left = eb_dotag(&new->node.branches, EB_LEFT);
-			new_rght = eb_dotag(&new->node.branches, EB_RGHT);
-			new_leaf = eb_dotag(&new->node.branches, EB_LEAF);
-			old_node = eb_dotag(&old->node.branches, EB_NODE);
-
-			new->node.node_p = old->node.node_p;
-
-			if (new->key < old->key) {
-				new->node.leaf_p = new_left;
-				old->node.node_p = new_rght;
-				new->node.branches.b[EB_LEFT] = new_leaf;
-				new->node.branches.b[EB_RGHT] = old_node;
-			}
-			else if (new->key > old->key) {
-				old->node.node_p = new_left;
-				new->node.leaf_p = new_rght;
-				new->node.branches.b[EB_LEFT] = old_node;
-				new->node.branches.b[EB_RGHT] = new_leaf;
-			}
-			else {
-				struct eb_node *ret;
-				ret = eb_insert_dup(&old->node, &new->node);
-				return container_of(ret, struct eb64_node, node);
-			}
-			break;
-		}
-
-		/* walk down */
-		root = &old->node.branches;
-#if BITS_PER_LONG >= 64
-		side = (newkey >> old_node_bit) & EB_NODE_BRANCH_MASK;
-#else
-		side = newkey;
-		side >>= old_node_bit;
-		if (old_node_bit >= 32) {
-			side = newkey >> 32;
-			side >>= old_node_bit & 0x1F;
-		}
-		side &= EB_NODE_BRANCH_MASK;
-#endif
-		troot = root->b[side];
-	}
-
-	/* Ok, now we are inserting <new> between <root> and <old>. <old>'s
-	 * parent is already set to <new>, and the <root>'s branch is still in
-	 * <side>. Update the root's leaf till we have it. Note that we can also
-	 * find the side by checking the side of new->node.node_p.
-	 */
-
-	/* We need the common higher bits between new->key and old->key.
-	 * What differences are there between new->key and the node here ?
-	 * NOTE that bit(new) is always < bit(root) because highest
-	 * bit of new->key and old->key are identical here (otherwise they
-	 * would sit on different branches).
-	 */
-	// note that if EB_NODE_BITS > 1, we should check that it's still >= 0
-	new->node.bit = fls64(new->key ^ old->key) - EB_NODE_BITS;
-	root->b[side] = eb_dotag(&new->node.branches, EB_NODE);
-
-	return new;
-}
-
-/* Insert eb64_node <new> into subtree starting at node root <root>, using
- * signed keys. Only new->key needs be set with the key. The eb64_node
- * is returned. If root->b[EB_RGHT]==1, the tree may only contain unique keys.
- */
-static forceinline struct eb64_node *
-__eb64i_insert(struct eb_root *root, struct eb64_node *new) {
-	struct eb64_node *old;
-	unsigned int side;
-	eb_troot_t *troot;
-	u64 newkey; /* caching the key saves approximately one cycle */
-	eb_troot_t *root_right;
-	int old_node_bit;
-
-	side = EB_LEFT;
-	troot = root->b[EB_LEFT];
-	root_right = root->b[EB_RGHT];
-	if (unlikely(troot == NULL)) {
-		/* Tree is empty, insert the leaf part below the left branch */
-		root->b[EB_LEFT] = eb_dotag(&new->node.branches, EB_LEAF);
-		new->node.leaf_p = eb_dotag(root, EB_LEFT);
-		new->node.node_p = NULL; /* node part unused */
-		return new;
-	}
-
-	/* The tree descent is fairly easy :
-	 *  - first, check if we have reached a leaf node
-	 *  - second, check if we have gone too far
-	 *  - third, reiterate
-	 * Everywhere, we use <new> for the node node we are inserting, <root>
-	 * for the node we attach it to, and <old> for the node we are
-	 * displacing below <new>. <troot> will always point to the future node
-	 * (tagged with its type). <side> carries the side the node <new> is
-	 * attached to below its parent, which is also where previous node
-	 * was attached. <newkey> carries a high bit shift of the key being
-	 * inserted in order to have negative keys stored before positive
-	 * ones.
-	 */
-	newkey = new->key ^ (1ULL << 63);
-
-	while (1) {
-		if (unlikely(eb_gettag(troot) == EB_LEAF)) {
-			eb_troot_t *new_left, *new_rght;
-			eb_troot_t *new_leaf, *old_leaf;
-
-			old = container_of(eb_untag(troot, EB_LEAF),
-					    struct eb64_node, node.branches);
-
-			new_left = eb_dotag(&new->node.branches, EB_LEFT);
-			new_rght = eb_dotag(&new->node.branches, EB_RGHT);
-			new_leaf = eb_dotag(&new->node.branches, EB_LEAF);
-			old_leaf = eb_dotag(&old->node.branches, EB_LEAF);
-
-			new->node.node_p = old->node.leaf_p;
-
-			/* Right here, we have 3 possibilities :
-			   - the tree does not contain the key, and we have
-			     new->key < old->key. We insert new above old, on
-			     the left ;
-
-			   - the tree does not contain the key, and we have
-			     new->key > old->key. We insert new above old, on
-			     the right ;
-
-			   - the tree does contain the key, which implies it
-			     is alone. We add the new key next to it as a
-			     first duplicate.
-
-			   The last two cases can easily be partially merged.
-			*/
-			 
-			if ((s64)new->key < (s64)old->key) {
-				new->node.leaf_p = new_left;
-				old->node.leaf_p = new_rght;
-				new->node.branches.b[EB_LEFT] = new_leaf;
-				new->node.branches.b[EB_RGHT] = old_leaf;
-			} else {
-				/* we may refuse to duplicate this key if the tree is
-				 * tagged as containing only unique keys.
-				 */
-				if ((new->key == old->key) && eb_gettag(root_right))
-					return old;
-
-				/* new->key >= old->key, new goes the right */
-				old->node.leaf_p = new_left;
-				new->node.leaf_p = new_rght;
-				new->node.branches.b[EB_LEFT] = old_leaf;
-				new->node.branches.b[EB_RGHT] = new_leaf;
-
-				if (new->key == old->key) {
-					new->node.bit = -1;
-					root->b[side] = eb_dotag(&new->node.branches, EB_NODE);
-					return new;
-				}
-			}
-			break;
-		}
-
-		/* OK we're walking down this link */
-		old = container_of(eb_untag(troot, EB_NODE),
-				    struct eb64_node, node.branches);
-		old_node_bit = old->node.bit;
-
-		/* Stop going down when we don't have common bits anymore. We
-		 * also stop in front of a duplicates tree because it means we
-		 * have to insert above.
-		 */
-
-		if ((old_node_bit < 0) || /* we're above a duplicate tree, stop here */
-		    (((new->key ^ old->key) >> old_node_bit) >= EB_NODE_BRANCHES)) {
-			/* The tree did not contain the key, so we insert <new> before the node
-			 * <old>, and set ->bit to designate the lowest bit position in <new>
-			 * which applies to ->branches.b[].
-			 */
-			eb_troot_t *new_left, *new_rght;
-			eb_troot_t *new_leaf, *old_node;
-
-			new_left = eb_dotag(&new->node.branches, EB_LEFT);
-			new_rght = eb_dotag(&new->node.branches, EB_RGHT);
-			new_leaf = eb_dotag(&new->node.branches, EB_LEAF);
-			old_node = eb_dotag(&old->node.branches, EB_NODE);
-
-			new->node.node_p = old->node.node_p;
-
-			if ((s64)new->key < (s64)old->key) {
-				new->node.leaf_p = new_left;
-				old->node.node_p = new_rght;
-				new->node.branches.b[EB_LEFT] = new_leaf;
-				new->node.branches.b[EB_RGHT] = old_node;
-			}
-			else if ((s64)new->key > (s64)old->key) {
-				old->node.node_p = new_left;
-				new->node.leaf_p = new_rght;
-				new->node.branches.b[EB_LEFT] = old_node;
-				new->node.branches.b[EB_RGHT] = new_leaf;
-			}
-			else {
-				struct eb_node *ret;
-				ret = eb_insert_dup(&old->node, &new->node);
-				return container_of(ret, struct eb64_node, node);
-			}
-			break;
-		}
-
-		/* walk down */
-		root = &old->node.branches;
-#if BITS_PER_LONG >= 64
-		side = (newkey >> old_node_bit) & EB_NODE_BRANCH_MASK;
-#else
-		side = newkey;
-		side >>= old_node_bit;
-		if (old_node_bit >= 32) {
-			side = newkey >> 32;
-			side >>= old_node_bit & 0x1F;
-		}
-		side &= EB_NODE_BRANCH_MASK;
-#endif
-		troot = root->b[side];
-	}
-
-	/* Ok, now we are inserting <new> between <root> and <old>. <old>'s
-	 * parent is already set to <new>, and the <root>'s branch is still in
-	 * <side>. Update the root's leaf till we have it. Note that we can also
-	 * find the side by checking the side of new->node.node_p.
-	 */
-
-	/* We need the common higher bits between new->key and old->key.
-	 * What differences are there between new->key and the node here ?
-	 * NOTE that bit(new) is always < bit(root) because highest
-	 * bit of new->key and old->key are identical here (otherwise they
-	 * would sit on different branches).
-	 */
-	// note that if EB_NODE_BITS > 1, we should check that it's still >= 0
-	new->node.bit = fls64(new->key ^ old->key) - EB_NODE_BITS;
-	root->b[side] = eb_dotag(&new->node.branches, EB_NODE);
-
-	return new;
-}
-
-#endif /* _EB64_TREE_H */
diff --git a/deps/haproxy-1.4.21/ebtree/ebimtree.c b/deps/haproxy-1.4.21/ebtree/ebimtree.c
deleted file mode 100644
index eb58b2e..0000000
--- a/deps/haproxy-1.4.21/ebtree/ebimtree.c
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Elastic Binary Trees - exported functions for Indirect Multi-Byte data nodes.
- * Version 6.0
- * (C) 2002-2010 - Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-/* Consult ebimtree.h for more details about those functions */
-
-#include "ebpttree.h"
-#include "ebimtree.h"
-
-/* Find the first occurence of a key of <len> bytes in the tree <root>.
- * If none can be found, return NULL.
- */
-REGPRM3 struct ebpt_node *
-ebim_lookup(struct eb_root *root, const void *x, unsigned int len)
-{
-	return __ebim_lookup(root, x, len);
-}
-
-/* Insert ebpt_node <new> into subtree starting at node root <root>.
- * Only new->key needs be set with the key. The ebpt_node is returned.
- * If root->b[EB_RGHT]==1, the tree may only contain unique keys. The
- * len is specified in bytes.
- */
-REGPRM3 struct ebpt_node *
-ebim_insert(struct eb_root *root, struct ebpt_node *new, unsigned int len)
-{
-	return __ebim_insert(root, new, len);
-}
diff --git a/deps/haproxy-1.4.21/ebtree/ebimtree.h b/deps/haproxy-1.4.21/ebtree/ebimtree.h
deleted file mode 100644
index 7fb3f42..0000000
--- a/deps/haproxy-1.4.21/ebtree/ebimtree.h
+++ /dev/null
@@ -1,305 +0,0 @@
-/*
- * Elastic Binary Trees - macros for Indirect Multi-Byte data nodes.
- * Version 6.0.5
- * (C) 2002-2011 - Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#include <string.h>
-#include "ebtree.h"
-#include "ebpttree.h"
-
-/* These functions and macros rely on Pointer nodes and use the <key> entry as
- * a pointer to an indirect key. Most operations are performed using ebpt_*.
- */
-
-/* The following functions are not inlined by default. They are declared
- * in ebimtree.c, which simply relies on their inline version.
- */
-REGPRM3 struct ebpt_node *ebim_lookup(struct eb_root *root, const void *x, unsigned int len);
-REGPRM3 struct ebpt_node *ebim_insert(struct eb_root *root, struct ebpt_node *new, unsigned int len);
-
-/* Find the first occurence of a key of a least <len> bytes matching <x> in the
- * tree <root>. The caller is responsible for ensuring that <len> will not exceed
- * the common parts between the tree's keys and <x>. In case of multiple matches,
- * the leftmost node is returned. This means that this function can be used to
- * lookup string keys by prefix if all keys in the tree are zero-terminated. If
- * no match is found, NULL is returned. Returns first node if <len> is zero.
- */
-static forceinline struct ebpt_node *
-__ebim_lookup(struct eb_root *root, const void *x, unsigned int len)
-{
-	struct ebpt_node *node;
-	eb_troot_t *troot;
-	int pos, side;
-	int node_bit;
-
-	troot = root->b[EB_LEFT];
-	if (unlikely(troot == NULL))
-		goto ret_null;
-
-	if (unlikely(len == 0))
-		goto walk_down;
-
-	pos = 0;
-	while (1) {
-		if (eb_gettag(troot) == EB_LEAF) {
-			node = container_of(eb_untag(troot, EB_LEAF),
-					    struct ebpt_node, node.branches);
-			if (memcmp(node->key + pos, x, len) != 0)
-				goto ret_null;
-			else
-				goto ret_node;
-		}
-		node = container_of(eb_untag(troot, EB_NODE),
-				    struct ebpt_node, node.branches);
-
-		node_bit = node->node.bit;
-		if (node_bit < 0) {
-			/* We have a dup tree now. Either it's for the same
-			 * value, and we walk down left, or it's a different
-			 * one and we don't have our key.
-			 */
-			if (memcmp(node->key + pos, x, len) != 0)
-				goto ret_null;
-			else
-				goto walk_left;
-		}
-
-		/* OK, normal data node, let's walk down. We check if all full
-		 * bytes are equal, and we start from the last one we did not
-		 * completely check. We stop as soon as we reach the last byte,
-		 * because we must decide to go left/right or abort.
-		 */
-		node_bit = ~node_bit + (pos << 3) + 8; // = (pos<<3) + (7 - node_bit)
-		if (node_bit < 0) {
-			/* This surprizing construction gives better performance
-			 * because gcc does not try to reorder the loop. Tested to
-			 * be fine with 2.95 to 4.2.
-			 */
-			while (1) {
-				if (*(unsigned char*)(node->key + pos++) ^ *(unsigned char*)(x++))
-					goto ret_null; /* more than one full byte is different */
-				if (--len == 0)
-					goto walk_left; /* return first node if all bytes matched */
-				node_bit += 8;
-				if (node_bit >= 0)
-					break;
-			}
-		}
-
-		/* here we know that only the last byte differs, so node_bit < 8.
-		 * We have 2 possibilities :
-		 *   - more than the last bit differs => return NULL
-		 *   - walk down on side = (x[pos] >> node_bit) & 1
-		 */
-		side = *(unsigned char *)x >> node_bit;
-		if (((*(unsigned char*)(node->key + pos) >> node_bit) ^ side) > 1)
-			goto ret_null;
-		side &= 1;
-		troot = node->node.branches.b[side];
-	}
- walk_left:
-	troot = node->node.branches.b[EB_LEFT];
- walk_down:
-	while (eb_gettag(troot) != EB_LEAF)
-		troot = (eb_untag(troot, EB_NODE))->b[EB_LEFT];
-	node = container_of(eb_untag(troot, EB_LEAF),
-			    struct ebpt_node, node.branches);
- ret_node:
-	return node;
- ret_null:
-	return NULL;
-}
-
-/* Insert ebpt_node <new> into subtree starting at node root <root>.
- * Only new->key needs be set with the key. The ebpt_node is returned.
- * If root->b[EB_RGHT]==1, the tree may only contain unique keys. The
- * len is specified in bytes.
- */
-static forceinline struct ebpt_node *
-__ebim_insert(struct eb_root *root, struct ebpt_node *new, unsigned int len)
-{
-	struct ebpt_node *old;
-	unsigned int side;
-	eb_troot_t *troot;
-	eb_troot_t *root_right;
-	int diff;
-	int bit;
-	int old_node_bit;
-
-	side = EB_LEFT;
-	troot = root->b[EB_LEFT];
-	root_right = root->b[EB_RGHT];
-	if (unlikely(troot == NULL)) {
-		/* Tree is empty, insert the leaf part below the left branch */
-		root->b[EB_LEFT] = eb_dotag(&new->node.branches, EB_LEAF);
-		new->node.leaf_p = eb_dotag(root, EB_LEFT);
-		new->node.node_p = NULL; /* node part unused */
-		return new;
-	}
-
-	len <<= 3;
-
-	/* The tree descent is fairly easy :
-	 *  - first, check if we have reached a leaf node
-	 *  - second, check if we have gone too far
-	 *  - third, reiterate
-	 * Everywhere, we use <new> for the node node we are inserting, <root>
-	 * for the node we attach it to, and <old> for the node we are
-	 * displacing below <new>. <troot> will always point to the future node
-	 * (tagged with its type). <side> carries the side the node <new> is
-	 * attached to below its parent, which is also where previous node
-	 * was attached.
-	 */
-
-	bit = 0;
-	while (1) {
-		if (unlikely(eb_gettag(troot) == EB_LEAF)) {
-			eb_troot_t *new_left, *new_rght;
-			eb_troot_t *new_leaf, *old_leaf;
-
-			old = container_of(eb_untag(troot, EB_LEAF),
-					    struct ebpt_node, node.branches);
-
-			new_left = eb_dotag(&new->node.branches, EB_LEFT);
-			new_rght = eb_dotag(&new->node.branches, EB_RGHT);
-			new_leaf = eb_dotag(&new->node.branches, EB_LEAF);
-			old_leaf = eb_dotag(&old->node.branches, EB_LEAF);
-
-			new->node.node_p = old->node.leaf_p;
-
-			/* Right here, we have 3 possibilities :
-			 * - the tree does not contain the key, and we have
-			 *   new->key < old->key. We insert new above old, on
-			 *   the left ;
-			 *
-			 * - the tree does not contain the key, and we have
-			 *   new->key > old->key. We insert new above old, on
-			 *   the right ;
-			 *
-			 * - the tree does contain the key, which implies it
-			 *   is alone. We add the new key next to it as a
-			 *   first duplicate.
-			 *
-			 * The last two cases can easily be partially merged.
-			 */
-			bit = equal_bits(new->key, old->key, bit, len);
-			diff = cmp_bits(new->key, old->key, bit);
-
-			if (diff < 0) {
-				new->node.leaf_p = new_left;
-				old->node.leaf_p = new_rght;
-				new->node.branches.b[EB_LEFT] = new_leaf;
-				new->node.branches.b[EB_RGHT] = old_leaf;
-			} else {
-				/* we may refuse to duplicate this key if the tree is
-				 * tagged as containing only unique keys.
-				 */
-				if (diff == 0 && eb_gettag(root_right))
-					return old;
-
-				/* new->key >= old->key, new goes the right */
-				old->node.leaf_p = new_left;
-				new->node.leaf_p = new_rght;
-				new->node.branches.b[EB_LEFT] = old_leaf;
-				new->node.branches.b[EB_RGHT] = new_leaf;
-
-				if (diff == 0) {
-					new->node.bit = -1;
-					root->b[side] = eb_dotag(&new->node.branches, EB_NODE);
-					return new;
-				}
-			}
-			break;
-		}
-
-		/* OK we're walking down this link */
-		old = container_of(eb_untag(troot, EB_NODE),
-				   struct ebpt_node, node.branches);
-		old_node_bit = old->node.bit;
-
-		/* Stop going down when we don't have common bits anymore. We
-		 * also stop in front of a duplicates tree because it means we
-		 * have to insert above. Note: we can compare more bits than
-		 * the current node's because as long as they are identical, we
-		 * know we descend along the correct side.
-		 */
-		if (old_node_bit < 0) {
-			/* we're above a duplicate tree, we must compare till the end */
-			bit = equal_bits(new->key, old->key, bit, len);
-			goto dup_tree;
-		}
-		else if (bit < old_node_bit) {
-			bit = equal_bits(new->key, old->key, bit, old_node_bit);
-		}
-
-		if (bit < old_node_bit) { /* we don't have all bits in common */
-			/* The tree did not contain the key, so we insert <new> before the node
-			 * <old>, and set ->bit to designate the lowest bit position in <new>
-			 * which applies to ->branches.b[].
-			 */
-			eb_troot_t *new_left, *new_rght;
-			eb_troot_t *new_leaf, *old_node;
-
-		dup_tree:
-			new_left = eb_dotag(&new->node.branches, EB_LEFT);
-			new_rght = eb_dotag(&new->node.branches, EB_RGHT);
-			new_leaf = eb_dotag(&new->node.branches, EB_LEAF);
-			old_node = eb_dotag(&old->node.branches, EB_NODE);
-
-			new->node.node_p = old->node.node_p;
-
-			diff = cmp_bits(new->key, old->key, bit);
-			if (diff < 0) {
-				new->node.leaf_p = new_left;
-				old->node.node_p = new_rght;
-				new->node.branches.b[EB_LEFT] = new_leaf;
-				new->node.branches.b[EB_RGHT] = old_node;
-			}
-			else if (diff > 0) {
-				old->node.node_p = new_left;
-				new->node.leaf_p = new_rght;
-				new->node.branches.b[EB_LEFT] = old_node;
-				new->node.branches.b[EB_RGHT] = new_leaf;
-			}
-			else {
-				struct eb_node *ret;
-				ret = eb_insert_dup(&old->node, &new->node);
-				return container_of(ret, struct ebpt_node, node);
-			}
-			break;
-		}
-
-		/* walk down */
-		root = &old->node.branches;
-		side = (((unsigned char *)new->key)[old_node_bit >> 3] >> (~old_node_bit & 7)) & 1;
-		troot = root->b[side];
-	}
-
-	/* Ok, now we are inserting <new> between <root> and <old>. <old>'s
-	 * parent is already set to <new>, and the <root>'s branch is still in
-	 * <side>. Update the root's leaf till we have it. Note that we can also
-	 * find the side by checking the side of new->node.node_p.
-	 */
-
-	/* We need the common higher bits between new->key and old->key.
-	 * This number of bits is already in <bit>.
-	 */
-	new->node.bit = bit;
-	root->b[side] = eb_dotag(&new->node.branches, EB_NODE);
-	return new;
-}
diff --git a/deps/haproxy-1.4.21/ebtree/ebistree.c b/deps/haproxy-1.4.21/ebtree/ebistree.c
deleted file mode 100644
index 1b8c912..0000000
--- a/deps/haproxy-1.4.21/ebtree/ebistree.c
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Elastic Binary Trees - exported functions for Indirect String data nodes.
- * Version 6.0
- * (C) 2002-2010 - Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-/* Consult ebistree.h for more details about those functions */
-
-#include "ebistree.h"
-#include "ebimtree.h"
-
-/* Find the first occurence of a zero-terminated string <x> in the tree <root>.
- * It's the caller's reponsibility to use this function only on trees which
- * only contain zero-terminated strings. If none can be found, return NULL.
- */
-REGPRM2 struct ebpt_node *ebis_lookup(struct eb_root *root, const char *x)
-{
-	return __ebis_lookup(root, x);
-}
-
-/* Find the first occurence of a length <len> string <x> in the tree <root>.
- * It's the caller's reponsibility to use this function only on trees which
- * only contain zero-terminated strings, and that no null character is present
- * in string <x> in the first <len> chars. If none can be found, return NULL.
- */
-REGPRM3 struct ebpt_node *ebis_lookup_len(struct eb_root *root, const char *x, unsigned int len)
-{
-	struct ebpt_node *node;
-
-	node = ebim_lookup(root, x, len);
-	if (!node || ((const char *)node->key)[len] != 0)
-		return NULL;
-	return node;
-}
-
-/* Insert ebpt_node <new> into subtree starting at node root <root>. Only
- * new->key needs be set with the zero-terminated string key. The ebpt_node is
- * returned. If root->b[EB_RGHT]==1, the tree may only contain unique keys. The
- * caller is responsible for properly terminating the key with a zero.
- */
-REGPRM2 struct ebpt_node *ebis_insert(struct eb_root *root, struct ebpt_node *new)
-{
-	return __ebis_insert(root, new);
-}
diff --git a/deps/haproxy-1.4.21/ebtree/ebistree.h b/deps/haproxy-1.4.21/ebtree/ebistree.h
deleted file mode 100644
index a637681..0000000
--- a/deps/haproxy-1.4.21/ebtree/ebistree.h
+++ /dev/null
@@ -1,309 +0,0 @@
-/*
- * Elastic Binary Trees - macros to manipulate Indirect String data nodes.
- * Version 6.0
- * (C) 2002-2010 - Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-/* These functions and macros rely on Multi-Byte nodes */
-
-#include <string.h>
-#include "ebtree.h"
-#include "ebpttree.h"
-
-/* These functions and macros rely on Pointer nodes and use the <key> entry as
- * a pointer to an indirect key. Most operations are performed using ebpt_*.
- */
-
-/* The following functions are not inlined by default. They are declared
- * in ebistree.c, which simply relies on their inline version.
- */
-REGPRM2 struct ebpt_node *ebis_lookup(struct eb_root *root, const char *x);
-REGPRM3 struct ebpt_node *ebis_lookup_len(struct eb_root *root, const char *x, unsigned int len);
-REGPRM2 struct ebpt_node *ebis_insert(struct eb_root *root, struct ebpt_node *new);
-
-/* Find the first occurence of a zero-terminated string <x> in the tree <root>.
- * It's the caller's reponsibility to use this function only on trees which
- * only contain zero-terminated strings. If none can be found, return NULL.
- */
-static forceinline struct ebpt_node *__ebis_lookup(struct eb_root *root, const void *x)
-{
-	struct ebpt_node *node;
-	eb_troot_t *troot;
-	int bit;
-	int node_bit;
-
-	troot = root->b[EB_LEFT];
-	if (unlikely(troot == NULL))
-		return NULL;
-
-	bit = 0;
-	while (1) {
-		if ((eb_gettag(troot) == EB_LEAF)) {
-			node = container_of(eb_untag(troot, EB_LEAF),
-					    struct ebpt_node, node.branches);
-			if (strcmp(node->key, x) == 0)
-				return node;
-			else
-				return NULL;
-		}
-		node = container_of(eb_untag(troot, EB_NODE),
-				    struct ebpt_node, node.branches);
-		node_bit = node->node.bit;
-
-		if (node_bit < 0) {
-			/* We have a dup tree now. Either it's for the same
-			 * value, and we walk down left, or it's a different
-			 * one and we don't have our key.
-			 */
-			if (strcmp(node->key, x) != 0)
-				return NULL;
-
-			troot = node->node.branches.b[EB_LEFT];
-			while (eb_gettag(troot) != EB_LEAF)
-				troot = (eb_untag(troot, EB_NODE))->b[EB_LEFT];
-			node = container_of(eb_untag(troot, EB_LEAF),
-					    struct ebpt_node, node.branches);
-			return node;
-		}
-
-		/* OK, normal data node, let's walk down but don't compare data
-		 * if we already reached the end of the key.
-		 */
-		if (likely(bit >= 0)) {
-			bit = string_equal_bits(x, node->key, bit);
-			if (likely(bit < node_bit)) {
-				if (bit >= 0)
-					return NULL; /* no more common bits */
-
-				/* bit < 0 : we reached the end of the key. If we
-				 * are in a tree with unique keys, we can return
-				 * this node. Otherwise we have to walk it down
-				 * and stop comparing bits.
-				 */
-				if (eb_gettag(root->b[EB_RGHT]))
-					return node;
-			}
-			/* if the bit is larger than the node's, we must bound it
-			 * because we might have compared too many bytes with an
-			 * inappropriate leaf. For a test, build a tree from "0",
-			 * "WW", "W", "S" inserted in this exact sequence and lookup
-			 * "W" => "S" is returned without this assignment.
-			 */
-			else
-				bit = node_bit;
-		}
-
-		troot = node->node.branches.b[(((unsigned char*)x)[node_bit >> 3] >>
-					       (~node_bit & 7)) & 1];
-	}
-}
-
-/* Insert ebpt_node <new> into subtree starting at node root <root>. Only
- * new->key needs be set with the zero-terminated string key. The ebpt_node is
- * returned. If root->b[EB_RGHT]==1, the tree may only contain unique keys. The
- * caller is responsible for properly terminating the key with a zero.
- */
-static forceinline struct ebpt_node *
-__ebis_insert(struct eb_root *root, struct ebpt_node *new)
-{
-	struct ebpt_node *old;
-	unsigned int side;
-	eb_troot_t *troot;
-	eb_troot_t *root_right;
-	int diff;
-	int bit;
-	int old_node_bit;
-
-	side = EB_LEFT;
-	troot = root->b[EB_LEFT];
-	root_right = root->b[EB_RGHT];
-	if (unlikely(troot == NULL)) {
-		/* Tree is empty, insert the leaf part below the left branch */
-		root->b[EB_LEFT] = eb_dotag(&new->node.branches, EB_LEAF);
-		new->node.leaf_p = eb_dotag(root, EB_LEFT);
-		new->node.node_p = NULL; /* node part unused */
-		return new;
-	}
-
-	/* The tree descent is fairly easy :
-	 *  - first, check if we have reached a leaf node
-	 *  - second, check if we have gone too far
-	 *  - third, reiterate
-	 * Everywhere, we use <new> for the node node we are inserting, <root>
-	 * for the node we attach it to, and <old> for the node we are
-	 * displacing below <new>. <troot> will always point to the future node
-	 * (tagged with its type). <side> carries the side the node <new> is
-	 * attached to below its parent, which is also where previous node
-	 * was attached.
-	 */
-
-	bit = 0;
-	while (1) {
-		if (unlikely(eb_gettag(troot) == EB_LEAF)) {
-			eb_troot_t *new_left, *new_rght;
-			eb_troot_t *new_leaf, *old_leaf;
-
-			old = container_of(eb_untag(troot, EB_LEAF),
-					    struct ebpt_node, node.branches);
-
-			new_left = eb_dotag(&new->node.branches, EB_LEFT);
-			new_rght = eb_dotag(&new->node.branches, EB_RGHT);
-			new_leaf = eb_dotag(&new->node.branches, EB_LEAF);
-			old_leaf = eb_dotag(&old->node.branches, EB_LEAF);
-
-			new->node.node_p = old->node.leaf_p;
-
-			/* Right here, we have 3 possibilities :
-			 * - the tree does not contain the key, and we have
-			 *   new->key < old->key. We insert new above old, on
-			 *   the left ;
-			 *
-			 * - the tree does not contain the key, and we have
-			 *   new->key > old->key. We insert new above old, on
-			 *   the right ;
-			 *
-			 * - the tree does contain the key, which implies it
-			 *   is alone. We add the new key next to it as a
-			 *   first duplicate.
-			 *
-			 * The last two cases can easily be partially merged.
-			 */
-			if (bit >= 0)
-				bit = string_equal_bits(new->key, old->key, bit);
-
-			if (bit < 0) {
-				/* key was already there */
-
-				/* we may refuse to duplicate this key if the tree is
-				 * tagged as containing only unique keys.
-				 */
-				if (eb_gettag(root_right))
-					return old;
-
-				/* new arbitrarily goes to the right and tops the dup tree */
-				old->node.leaf_p = new_left;
-				new->node.leaf_p = new_rght;
-				new->node.branches.b[EB_LEFT] = old_leaf;
-				new->node.branches.b[EB_RGHT] = new_leaf;
-				new->node.bit = -1;
-				root->b[side] = eb_dotag(&new->node.branches, EB_NODE);
-				return new;
-			}
-
-			diff = cmp_bits(new->key, old->key, bit);
-			if (diff < 0) {
-				/* new->key < old->key, new takes the left */
-				new->node.leaf_p = new_left;
-				old->node.leaf_p = new_rght;
-				new->node.branches.b[EB_LEFT] = new_leaf;
-				new->node.branches.b[EB_RGHT] = old_leaf;
-			} else {
-				/* new->key > old->key, new takes the right */
-				old->node.leaf_p = new_left;
-				new->node.leaf_p = new_rght;
-				new->node.branches.b[EB_LEFT] = old_leaf;
-				new->node.branches.b[EB_RGHT] = new_leaf;
-			}
-			break;
-		}
-
-		/* OK we're walking down this link */
-		old = container_of(eb_untag(troot, EB_NODE),
-				   struct ebpt_node, node.branches);
-		old_node_bit = old->node.bit;
-
-		/* Stop going down when we don't have common bits anymore. We
-		 * also stop in front of a duplicates tree because it means we
-		 * have to insert above. Note: we can compare more bits than
-		 * the current node's because as long as they are identical, we
-		 * know we descend along the correct side.
-		 */
-		if (bit >= 0 && (bit < old_node_bit || old_node_bit < 0))
-			bit = string_equal_bits(new->key, old->key, bit);
-
-		if (unlikely(bit < 0)) {
-			/* Perfect match, we must only stop on head of dup tree
-			 * or walk down to a leaf.
-			 */
-			if (old_node_bit < 0) {
-				/* We know here that string_equal_bits matched all
-				 * bits and that we're on top of a dup tree, then
-				 * we can perform the dup insertion and return.
-				 */
-				struct eb_node *ret;
-				ret = eb_insert_dup(&old->node, &new->node);
-				return container_of(ret, struct ebpt_node, node);
-			}
-			/* OK so let's walk down */
-		}
-		else if (bit < old_node_bit || old_node_bit < 0) {
-			/* The tree did not contain the key, or we stopped on top of a dup
-			 * tree, possibly containing the key. In the former case, we insert
-			 * <new> before the node <old>, and set ->bit to designate the lowest
-			 * bit position in <new> which applies to ->branches.b[]. In the later
-			 * case, we add the key to the existing dup tree. Note that we cannot
-			 * enter here if we match an intermediate node's key that is not the
-			 * head of a dup tree.
-			 */
-			eb_troot_t *new_left, *new_rght;
-			eb_troot_t *new_leaf, *old_node;
-
-			new_left = eb_dotag(&new->node.branches, EB_LEFT);
-			new_rght = eb_dotag(&new->node.branches, EB_RGHT);
-			new_leaf = eb_dotag(&new->node.branches, EB_LEAF);
-			old_node = eb_dotag(&old->node.branches, EB_NODE);
-
-			new->node.node_p = old->node.node_p;
-
-			/* we can never match all bits here */
-			diff = cmp_bits(new->key, old->key, bit);
-			if (diff < 0) {
-				new->node.leaf_p = new_left;
-				old->node.node_p = new_rght;
-				new->node.branches.b[EB_LEFT] = new_leaf;
-				new->node.branches.b[EB_RGHT] = old_node;
-			}
-			else {
-				old->node.node_p = new_left;
-				new->node.leaf_p = new_rght;
-				new->node.branches.b[EB_LEFT] = old_node;
-				new->node.branches.b[EB_RGHT] = new_leaf;
-			}
-			break;
-		}
-
-		/* walk down */
-		root = &old->node.branches;
-		side = (((unsigned char *)new->key)[old_node_bit >> 3] >> (~old_node_bit & 7)) & 1;
-		troot = root->b[side];
-	}
-
-	/* Ok, now we are inserting <new> between <root> and <old>. <old>'s
-	 * parent is already set to <new>, and the <root>'s branch is still in
-	 * <side>. Update the root's leaf till we have it. Note that we can also
-	 * find the side by checking the side of new->node.node_p.
-	 */
-
-	/* We need the common higher bits between new->key and old->key.
-	 * This number of bits is already in <bit>.
-	 * NOTE: we can't get here whit bit < 0 since we found a dup !
-	 */
-	new->node.bit = bit;
-	root->b[side] = eb_dotag(&new->node.branches, EB_NODE);
-	return new;
-}
-
diff --git a/deps/haproxy-1.4.21/ebtree/ebmbtree.c b/deps/haproxy-1.4.21/ebtree/ebmbtree.c
deleted file mode 100644
index 156f0e2..0000000
--- a/deps/haproxy-1.4.21/ebtree/ebmbtree.c
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Elastic Binary Trees - exported functions for Multi-Byte data nodes.
- * Version 6.0
- * (C) 2002-2010 - Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-/* Consult ebmbtree.h for more details about those functions */
-
-#include "ebmbtree.h"
-
-/* Find the first occurence of a key of <len> bytes in the tree <root>.
- * If none can be found, return NULL.
- */
-REGPRM3 struct ebmb_node *
-ebmb_lookup(struct eb_root *root, const void *x, unsigned int len)
-{
-	return __ebmb_lookup(root, x, len);
-}
-
-/* Insert ebmb_node <new> into subtree starting at node root <root>.
- * Only new->key needs be set with the key. The ebmb_node is returned.
- * If root->b[EB_RGHT]==1, the tree may only contain unique keys. The
- * len is specified in bytes.
- */
-REGPRM3 struct ebmb_node *
-ebmb_insert(struct eb_root *root, struct ebmb_node *new, unsigned int len)
-{
-	return __ebmb_insert(root, new, len);
-}
-
-/* Find the first occurence of the longest prefix matching a key <x> in the
- * tree <root>. It's the caller's responsibility to ensure that key <x> is at
- * least as long as the keys in the tree. If none can be found, return NULL.
- */
-REGPRM2 struct ebmb_node *
-ebmb_lookup_longest(struct eb_root *root, const void *x)
-{
-	return __ebmb_lookup_longest(root, x);
-}
-
-/* Find the first occurence of a prefix matching a key <x> of <pfx> BITS in the
- * tree <root>. If none can be found, return NULL.
- */
-REGPRM3 struct ebmb_node *
-ebmb_lookup_prefix(struct eb_root *root, const void *x, unsigned int pfx)
-{
-	return __ebmb_lookup_prefix(root, x, pfx);
-}
-
-/* Insert ebmb_node <new> into a prefix subtree starting at node root <root>.
- * Only new->key and new->pfx need be set with the key and its prefix length.
- * Note that bits between <pfx> and <len> are theorically ignored and should be
- * zero, as it is not certain yet that they will always be ignored everywhere
- * (eg in bit compare functions).
- * The ebmb_node is returned.
- * If root->b[EB_RGHT]==1, the tree may only contain unique keys. The
- * len is specified in bytes.
- */
-REGPRM3 struct ebmb_node *
-ebmb_insert_prefix(struct eb_root *root, struct ebmb_node *new, unsigned int len)
-{
-	return __ebmb_insert_prefix(root, new, len);
-}
diff --git a/deps/haproxy-1.4.21/ebtree/ebmbtree.h b/deps/haproxy-1.4.21/ebtree/ebmbtree.h
deleted file mode 100644
index 8baac2e..0000000
--- a/deps/haproxy-1.4.21/ebtree/ebmbtree.h
+++ /dev/null
@@ -1,789 +0,0 @@
-/*
- * Elastic Binary Trees - macros and structures for Multi-Byte data nodes.
- * Version 6.0.5
- * (C) 2002-2011 - Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _EBMBTREE_H
-#define _EBMBTREE_H
-
-#include <string.h>
-#include "ebtree.h"
-
-/* Return the structure of type <type> whose member <member> points to <ptr> */
-#define ebmb_entry(ptr, type, member) container_of(ptr, type, member)
-
-#define EBMB_ROOT	EB_ROOT
-#define EBMB_TREE_HEAD	EB_TREE_HEAD
-
-/* This structure carries a node, a leaf, and a key. It must start with the
- * eb_node so that it can be cast into an eb_node. We could also have put some
- * sort of transparent union here to reduce the indirection level, but the fact
- * is, the end user is not meant to manipulate internals, so this is pointless.
- * The 'node.bit' value here works differently from scalar types, as it contains
- * the number of identical bits between the two branches.
- */
-struct ebmb_node {
-	struct eb_node node; /* the tree node, must be at the beginning */
-	unsigned char key[0]; /* the key, its size depends on the application */
-};
-
-/*
- * Exported functions and macros.
- * Many of them are always inlined because they are extremely small, and
- * are generally called at most once or twice in a program.
- */
-
-/* Return leftmost node in the tree, or NULL if none */
-static forceinline struct ebmb_node *ebmb_first(struct eb_root *root)
-{
-	return ebmb_entry(eb_first(root), struct ebmb_node, node);
-}
-
-/* Return rightmost node in the tree, or NULL if none */
-static forceinline struct ebmb_node *ebmb_last(struct eb_root *root)
-{
-	return ebmb_entry(eb_last(root), struct ebmb_node, node);
-}
-
-/* Return next node in the tree, or NULL if none */
-static forceinline struct ebmb_node *ebmb_next(struct ebmb_node *ebmb)
-{
-	return ebmb_entry(eb_next(&ebmb->node), struct ebmb_node, node);
-}
-
-/* Return previous node in the tree, or NULL if none */
-static forceinline struct ebmb_node *ebmb_prev(struct ebmb_node *ebmb)
-{
-	return ebmb_entry(eb_prev(&ebmb->node), struct ebmb_node, node);
-}
-
-/* Return next node in the tree, skipping duplicates, or NULL if none */
-static forceinline struct ebmb_node *ebmb_next_unique(struct ebmb_node *ebmb)
-{
-	return ebmb_entry(eb_next_unique(&ebmb->node), struct ebmb_node, node);
-}
-
-/* Return previous node in the tree, skipping duplicates, or NULL if none */
-static forceinline struct ebmb_node *ebmb_prev_unique(struct ebmb_node *ebmb)
-{
-	return ebmb_entry(eb_prev_unique(&ebmb->node), struct ebmb_node, node);
-}
-
-/* Delete node from the tree if it was linked in. Mark the node unused. Note
- * that this function relies on a non-inlined generic function: eb_delete.
- */
-static forceinline void ebmb_delete(struct ebmb_node *ebmb)
-{
-	eb_delete(&ebmb->node);
-}
-
-/* The following functions are not inlined by default. They are declared
- * in ebmbtree.c, which simply relies on their inline version.
- */
-REGPRM3 struct ebmb_node *ebmb_lookup(struct eb_root *root, const void *x, unsigned int len);
-REGPRM3 struct ebmb_node *ebmb_insert(struct eb_root *root, struct ebmb_node *new, unsigned int len);
-REGPRM2 struct ebmb_node *ebmb_lookup_longest(struct eb_root *root, const void *x);
-REGPRM3 struct ebmb_node *ebmb_lookup_prefix(struct eb_root *root, const void *x, unsigned int pfx);
-REGPRM3 struct ebmb_node *ebmb_insert_prefix(struct eb_root *root, struct ebmb_node *new, unsigned int len);
-
-/* The following functions are less likely to be used directly, because their
- * code is larger. The non-inlined version is preferred.
- */
-
-/* Delete node from the tree if it was linked in. Mark the node unused. */
-static forceinline void __ebmb_delete(struct ebmb_node *ebmb)
-{
-	__eb_delete(&ebmb->node);
-}
-
-/* Find the first occurence of a key of a least <len> bytes matching <x> in the
- * tree <root>. The caller is responsible for ensuring that <len> will not exceed
- * the common parts between the tree's keys and <x>. In case of multiple matches,
- * the leftmost node is returned. This means that this function can be used to
- * lookup string keys by prefix if all keys in the tree are zero-terminated. If
- * no match is found, NULL is returned. Returns first node if <len> is zero.
- */
-static forceinline struct ebmb_node *__ebmb_lookup(struct eb_root *root, const void *x, unsigned int len)
-{
-	struct ebmb_node *node;
-	eb_troot_t *troot;
-	int pos, side;
-	int node_bit;
-
-	troot = root->b[EB_LEFT];
-	if (unlikely(troot == NULL))
-		goto ret_null;
-
-	if (unlikely(len == 0))
-		goto walk_down;
-
-	pos = 0;
-	while (1) {
-		if (eb_gettag(troot) == EB_LEAF) {
-			node = container_of(eb_untag(troot, EB_LEAF),
-					    struct ebmb_node, node.branches);
-			if (memcmp(node->key + pos, x, len) != 0)
-				goto ret_null;
-			else
-				goto ret_node;
-		}
-		node = container_of(eb_untag(troot, EB_NODE),
-				    struct ebmb_node, node.branches);
-
-		node_bit = node->node.bit;
-		if (node_bit < 0) {
-			/* We have a dup tree now. Either it's for the same
-			 * value, and we walk down left, or it's a different
-			 * one and we don't have our key.
-			 */
-			if (memcmp(node->key + pos, x, len) != 0)
-				goto ret_null;
-			else
-				goto walk_left;
-		}
-
-		/* OK, normal data node, let's walk down. We check if all full
-		 * bytes are equal, and we start from the last one we did not
-		 * completely check. We stop as soon as we reach the last byte,
-		 * because we must decide to go left/right or abort.
-		 */
-		node_bit = ~node_bit + (pos << 3) + 8; // = (pos<<3) + (7 - node_bit)
-		if (node_bit < 0) {
-			/* This surprizing construction gives better performance
-			 * because gcc does not try to reorder the loop. Tested to
-			 * be fine with 2.95 to 4.2.
-			 */
-			while (1) {
-				if (node->key[pos++] ^ *(unsigned char*)(x++))
-					goto ret_null;  /* more than one full byte is different */
-				if (--len == 0)
-					goto walk_left; /* return first node if all bytes matched */
-				node_bit += 8;
-				if (node_bit >= 0)
-					break;
-			}
-		}
-
-		/* here we know that only the last byte differs, so node_bit < 8.
-		 * We have 2 possibilities :
-		 *   - more than the last bit differs => return NULL
-		 *   - walk down on side = (x[pos] >> node_bit) & 1
-		 */
-		side = *(unsigned char *)x >> node_bit;
-		if (((node->key[pos] >> node_bit) ^ side) > 1)
-			goto ret_null;
-		side &= 1;
-		troot = node->node.branches.b[side];
-	}
- walk_left:
-	troot = node->node.branches.b[EB_LEFT];
- walk_down:
-	while (eb_gettag(troot) != EB_LEAF)
-		troot = (eb_untag(troot, EB_NODE))->b[EB_LEFT];
-	node = container_of(eb_untag(troot, EB_LEAF),
-			    struct ebmb_node, node.branches);
- ret_node:
-	return node;
- ret_null:
-	return NULL;
-}
-
-/* Insert ebmb_node <new> into subtree starting at node root <root>.
- * Only new->key needs be set with the key. The ebmb_node is returned.
- * If root->b[EB_RGHT]==1, the tree may only contain unique keys. The
- * len is specified in bytes. It is absolutely mandatory that this length
- * is the same for all keys in the tree. This function cannot be used to
- * insert strings.
- */
-static forceinline struct ebmb_node *
-__ebmb_insert(struct eb_root *root, struct ebmb_node *new, unsigned int len)
-{
-	struct ebmb_node *old;
-	unsigned int side;
-	eb_troot_t *troot, **up_ptr;
-	eb_troot_t *root_right;
-	int diff;
-	int bit;
-	eb_troot_t *new_left, *new_rght;
-	eb_troot_t *new_leaf;
-	int old_node_bit;
-
-	side = EB_LEFT;
-	troot = root->b[EB_LEFT];
-	root_right = root->b[EB_RGHT];
-	if (unlikely(troot == NULL)) {
-		/* Tree is empty, insert the leaf part below the left branch */
-		root->b[EB_LEFT] = eb_dotag(&new->node.branches, EB_LEAF);
-		new->node.leaf_p = eb_dotag(root, EB_LEFT);
-		new->node.node_p = NULL; /* node part unused */
-		return new;
-	}
-
-	/* The tree descent is fairly easy :
-	 *  - first, check if we have reached a leaf node
-	 *  - second, check if we have gone too far
-	 *  - third, reiterate
-	 * Everywhere, we use <new> for the node node we are inserting, <root>
-	 * for the node we attach it to, and <old> for the node we are
-	 * displacing below <new>. <troot> will always point to the future node
-	 * (tagged with its type). <side> carries the side the node <new> is
-	 * attached to below its parent, which is also where previous node
-	 * was attached.
-	 */
-
-	bit = 0;
-	while (1) {
-		if (unlikely(eb_gettag(troot) == EB_LEAF)) {
-			/* insert above a leaf */
-			old = container_of(eb_untag(troot, EB_LEAF),
-					    struct ebmb_node, node.branches);
-			new->node.node_p = old->node.leaf_p;
-			up_ptr = &old->node.leaf_p;
-			goto check_bit_and_break;
-		}
-
-		/* OK we're walking down this link */
-		old = container_of(eb_untag(troot, EB_NODE),
-				   struct ebmb_node, node.branches);
-		old_node_bit = old->node.bit;
-
-		if (unlikely(old->node.bit < 0)) {
-			/* We're above a duplicate tree, so we must compare the whole value */
-			new->node.node_p = old->node.node_p;
-			up_ptr = &old->node.node_p;
-		check_bit_and_break:
-			bit = equal_bits(new->key, old->key, bit, len << 3);
-			break;
-		}
-
-		/* Stop going down when we don't have common bits anymore. We
-		 * also stop in front of a duplicates tree because it means we
-		 * have to insert above. Note: we can compare more bits than
-		 * the current node's because as long as they are identical, we
-		 * know we descend along the correct side.
-		 */
-
-		bit = equal_bits(new->key, old->key, bit, old_node_bit);
-		if (unlikely(bit < old_node_bit)) {
-			/* The tree did not contain the key, so we insert <new> before the
-			 * node <old>, and set ->bit to designate the lowest bit position in
-			 * <new> which applies to ->branches.b[].
-			 */
-			new->node.node_p = old->node.node_p;
-			up_ptr = &old->node.node_p;
-			break;
-		}
-		/* we don't want to skip bits for further comparisons, so we must limit <bit>.
-		 * However, since we're going down around <old_node_bit>, we know it will be
-		 * properly matched, so we can skip this bit.
-		 */
-		bit = old_node_bit + 1;
-
-		/* walk down */
-		root = &old->node.branches;
-		side = old_node_bit & 7;
-		side ^= 7;
-		side = (new->key[old_node_bit >> 3] >> side) & 1;
-		troot = root->b[side];
-	}
-
-	new_left = eb_dotag(&new->node.branches, EB_LEFT);
-	new_rght = eb_dotag(&new->node.branches, EB_RGHT);
-	new_leaf = eb_dotag(&new->node.branches, EB_LEAF);
-
-	/* Note: we can compare more bits than
-	 * the current node's because as long as they are identical, we
-	 * know we descend along the correct side.
-	 */
-	new->node.bit = bit;
-	diff = cmp_bits(new->key, old->key, bit);
-	if (diff == 0) {
-		new->node.bit = -1; /* mark as new dup tree, just in case */
-
-		if (likely(eb_gettag(root_right))) {
-			/* we refuse to duplicate this key if the tree is
-			 * tagged as containing only unique keys.
-			 */
-			return old;
-		}
-
-		if (eb_gettag(troot) != EB_LEAF) {
-			/* there was already a dup tree below */
-			struct eb_node *ret;
-			ret = eb_insert_dup(&old->node, &new->node);
-			return container_of(ret, struct ebmb_node, node);
-		}
-		/* otherwise fall through */
-	}
-
-	if (diff >= 0) {
-		new->node.branches.b[EB_LEFT] = troot;
-		new->node.branches.b[EB_RGHT] = new_leaf;
-		new->node.leaf_p = new_rght;
-		*up_ptr = new_left;
-	}
-	else if (diff < 0) {
-		new->node.branches.b[EB_LEFT] = new_leaf;
-		new->node.branches.b[EB_RGHT] = troot;
-		new->node.leaf_p = new_left;
-		*up_ptr = new_rght;
-	}
-
-	/* Ok, now we are inserting <new> between <root> and <old>. <old>'s
-	 * parent is already set to <new>, and the <root>'s branch is still in
-	 * <side>. Update the root's leaf till we have it. Note that we can also
-	 * find the side by checking the side of new->node.node_p.
-	 */
-
-	root->b[side] = eb_dotag(&new->node.branches, EB_NODE);
-	return new;
-}
-
-
-/* Find the first occurence of the longest prefix matching a key <x> in the
- * tree <root>. It's the caller's responsibility to ensure that key <x> is at
- * least as long as the keys in the tree. If none can be found, return NULL.
- */
-static forceinline struct ebmb_node *__ebmb_lookup_longest(struct eb_root *root, const void *x)
-{
-	struct ebmb_node *node;
-	eb_troot_t *troot, *cover;
-	int pos, side;
-	int node_bit;
-
-	troot = root->b[EB_LEFT];
-	if (unlikely(troot == NULL))
-		return NULL;
-
-	cover = NULL;
-	pos = 0;
-	while (1) {
-		if ((eb_gettag(troot) == EB_LEAF)) {
-			node = container_of(eb_untag(troot, EB_LEAF),
-					    struct ebmb_node, node.branches);
-			if (check_bits(x - pos, node->key, pos, node->node.pfx))
-				goto not_found;
-
-			return node;
-		}
-		node = container_of(eb_untag(troot, EB_NODE),
-				    struct ebmb_node, node.branches);
-
-		node_bit = node->node.bit;
-		if (node_bit < 0) {
-			/* We have a dup tree now. Either it's for the same
-			 * value, and we walk down left, or it's a different
-			 * one and we don't have our key.
-			 */
-			if (check_bits(x - pos, node->key, pos, node->node.pfx))
-				goto not_found;
-
-			troot = node->node.branches.b[EB_LEFT];
-			while (eb_gettag(troot) != EB_LEAF)
-				troot = (eb_untag(troot, EB_NODE))->b[EB_LEFT];
-			node = container_of(eb_untag(troot, EB_LEAF),
-					    struct ebmb_node, node.branches);
-			return node;
-		}
-
-		node_bit >>= 1; /* strip cover bit */
-		node_bit = ~node_bit + (pos << 3) + 8; // = (pos<<3) + (7 - node_bit)
-		if (node_bit < 0) {
-			/* This uncommon construction gives better performance
-			 * because gcc does not try to reorder the loop. Tested to
-			 * be fine with 2.95 to 4.2.
-			 */
-			while (1) {
-				x++; pos++;
-				if (node->key[pos-1] ^ *(unsigned char*)(x-1))
-					goto not_found; /* more than one full byte is different */
-				node_bit += 8;
-				if (node_bit >= 0)
-					break;
-			}
-		}
-
-		/* here we know that only the last byte differs, so 0 <= node_bit <= 7.
-		 * We have 2 possibilities :
-		 *   - more than the last bit differs => data does not match
-		 *   - walk down on side = (x[pos] >> node_bit) & 1
-		 */
-		side = *(unsigned char *)x >> node_bit;
-		if (((node->key[pos] >> node_bit) ^ side) > 1)
-			goto not_found;
-
-		if (!(node->node.bit & 1)) {
-			/* This is a cover node, let's keep a reference to it
-			 * for later. The covering subtree is on the left, and
-			 * the covered subtree is on the right, so we have to
-			 * walk down right.
-			 */
-			cover = node->node.branches.b[EB_LEFT];
-			troot = node->node.branches.b[EB_RGHT];
-			continue;
-		}
-		side &= 1;
-		troot = node->node.branches.b[side];
-	}
-
- not_found:
-	/* Walk down last cover tre if it exists. It does not matter if cover is NULL */
-	return ebmb_entry(eb_walk_down(cover, EB_LEFT), struct ebmb_node, node);
-}
-
-
-/* Find the first occurence of a prefix matching a key <x> of <pfx> BITS in the
- * tree <root>. It's the caller's responsibility to ensure that key <x> is at
- * least as long as the keys in the tree. If none can be found, return NULL.
- */
-static forceinline struct ebmb_node *__ebmb_lookup_prefix(struct eb_root *root, const void *x, unsigned int pfx)
-{
-	struct ebmb_node *node;
-	eb_troot_t *troot;
-	int pos, side;
-	int node_bit;
-
-	troot = root->b[EB_LEFT];
-	if (unlikely(troot == NULL))
-		return NULL;
-
-	pos = 0;
-	while (1) {
-		if ((eb_gettag(troot) == EB_LEAF)) {
-			node = container_of(eb_untag(troot, EB_LEAF),
-					    struct ebmb_node, node.branches);
-			if (node->node.pfx != pfx)
-				return NULL;
-			if (check_bits(x - pos, node->key, pos, node->node.pfx))
-				return NULL;
-			return node;
-		}
-		node = container_of(eb_untag(troot, EB_NODE),
-				    struct ebmb_node, node.branches);
-
-		node_bit = node->node.bit;
-		if (node_bit < 0) {
-			/* We have a dup tree now. Either it's for the same
-			 * value, and we walk down left, or it's a different
-			 * one and we don't have our key.
-			 */
-			if (node->node.pfx != pfx)
-				return NULL;
-			if (check_bits(x - pos, node->key, pos, node->node.pfx))
-				return NULL;
-
-			troot = node->node.branches.b[EB_LEFT];
-			while (eb_gettag(troot) != EB_LEAF)
-				troot = (eb_untag(troot, EB_NODE))->b[EB_LEFT];
-			node = container_of(eb_untag(troot, EB_LEAF),
-					    struct ebmb_node, node.branches);
-			return node;
-		}
-
-		node_bit >>= 1; /* strip cover bit */
-		node_bit = ~node_bit + (pos << 3) + 8; // = (pos<<3) + (7 - node_bit)
-		if (node_bit < 0) {
-			/* This uncommon construction gives better performance
-			 * because gcc does not try to reorder the loop. Tested to
-			 * be fine with 2.95 to 4.2.
-			 */
-			while (1) {
-				x++; pos++;
-				if (node->key[pos-1] ^ *(unsigned char*)(x-1))
-					return NULL; /* more than one full byte is different */
-				node_bit += 8;
-				if (node_bit >= 0)
-					break;
-			}
-		}
-
-		/* here we know that only the last byte differs, so 0 <= node_bit <= 7.
-		 * We have 2 possibilities :
-		 *   - more than the last bit differs => data does not match
-		 *   - walk down on side = (x[pos] >> node_bit) & 1
-		 */
-		side = *(unsigned char *)x >> node_bit;
-		if (((node->key[pos] >> node_bit) ^ side) > 1)
-			return NULL;
-
-		if (!(node->node.bit & 1)) {
-			/* This is a cover node, it may be the entry we're
-			 * looking for. We already know that it matches all the
-			 * bits, let's compare prefixes and descend the cover
-			 * subtree if they match.
-			 */
-			if ((unsigned short)node->node.bit >> 1 == pfx)
-				troot = node->node.branches.b[EB_LEFT];
-			else
-				troot = node->node.branches.b[EB_RGHT];
-			continue;
-		}
-		side &= 1;
-		troot = node->node.branches.b[side];
-	}
-}
-
-
-/* Insert ebmb_node <new> into a prefix subtree starting at node root <root>.
- * Only new->key and new->pfx need be set with the key and its prefix length.
- * Note that bits between <pfx> and <len> are theorically ignored and should be
- * zero, as it is not certain yet that they will always be ignored everywhere
- * (eg in bit compare functions).
- * The ebmb_node is returned.
- * If root->b[EB_RGHT]==1, the tree may only contain unique keys. The
- * len is specified in bytes.
- */
-static forceinline struct ebmb_node *
-__ebmb_insert_prefix(struct eb_root *root, struct ebmb_node *new, unsigned int len)
-{
-	struct ebmb_node *old;
-	unsigned int side;
-	eb_troot_t *troot, **up_ptr;
-	eb_troot_t *root_right;
-	int diff;
-	int bit;
-	eb_troot_t *new_left, *new_rght;
-	eb_troot_t *new_leaf;
-	int old_node_bit;
-
-	side = EB_LEFT;
-	troot = root->b[EB_LEFT];
-	root_right = root->b[EB_RGHT];
-	if (unlikely(troot == NULL)) {
-		/* Tree is empty, insert the leaf part below the left branch */
-		root->b[EB_LEFT] = eb_dotag(&new->node.branches, EB_LEAF);
-		new->node.leaf_p = eb_dotag(root, EB_LEFT);
-		new->node.node_p = NULL; /* node part unused */
-		return new;
-	}
-
-	len <<= 3;
-	if (len > new->node.pfx)
-		len = new->node.pfx;
-
-	/* The tree descent is fairly easy :
-	 *  - first, check if we have reached a leaf node
-	 *  - second, check if we have gone too far
-	 *  - third, reiterate
-	 * Everywhere, we use <new> for the node node we are inserting, <root>
-	 * for the node we attach it to, and <old> for the node we are
-	 * displacing below <new>. <troot> will always point to the future node
-	 * (tagged with its type). <side> carries the side the node <new> is
-	 * attached to below its parent, which is also where previous node
-	 * was attached.
-	 */
-
-	bit = 0;
-	while (1) {
-		if (unlikely(eb_gettag(troot) == EB_LEAF)) {
-			/* Insert above a leaf. Note that this leaf could very
-			 * well be part of a cover node.
-			 */
-			old = container_of(eb_untag(troot, EB_LEAF),
-					    struct ebmb_node, node.branches);
-			new->node.node_p = old->node.leaf_p;
-			up_ptr = &old->node.leaf_p;
-			goto check_bit_and_break;
-		}
-
-		/* OK we're walking down this link */
-		old = container_of(eb_untag(troot, EB_NODE),
-				   struct ebmb_node, node.branches);
-		old_node_bit = old->node.bit;
-		/* Note that old_node_bit can be :
-		 *   < 0    : dup tree
-		 *   = 2N   : cover node for N bits
-		 *   = 2N+1 : normal node at N bits
-		 */
-
-		if (unlikely(old_node_bit < 0)) {
-			/* We're above a duplicate tree, so we must compare the whole value */
-			new->node.node_p = old->node.node_p;
-			up_ptr = &old->node.node_p;
-		check_bit_and_break:
-			/* No need to compare everything if the leaves are shorter than the new one. */
-			if (len > old->node.pfx)
-				len = old->node.pfx;
-			bit = equal_bits(new->key, old->key, bit, len);
-			break;
-		}
-
-		/* WARNING: for the two blocks below, <bit> is counted in half-bits */
-
-		bit = equal_bits(new->key, old->key, bit, old_node_bit >> 1);
-		bit = (bit << 1) + 1; // assume comparisons with normal nodes
-
-		/* we must always check that our prefix is larger than the nodes
-		 * we visit, otherwise we have to stop going down. The following
-		 * test is able to stop before both normal and cover nodes.
-		 */
-		if (bit >= (new->node.pfx << 1) && (new->node.pfx << 1) < old_node_bit) {
-			/* insert cover node here on the left */
-			new->node.node_p = old->node.node_p;
-			up_ptr = &old->node.node_p;
-			new->node.bit = new->node.pfx << 1;
-			diff = -1;
-			goto insert_above;
-		}
-
-		if (unlikely(bit < old_node_bit)) {
-			/* The tree did not contain the key, so we insert <new> before the
-			 * node <old>, and set ->bit to designate the lowest bit position in
-			 * <new> which applies to ->branches.b[]. We know that the bit is not
-			 * greater than the prefix length thanks to the test above.
-			 */
-			new->node.node_p = old->node.node_p;
-			up_ptr = &old->node.node_p;
-			new->node.bit = bit;
-			diff = cmp_bits(new->key, old->key, bit >> 1);
-			goto insert_above;
-		}
-
-		if (!(old_node_bit & 1)) {
-			/* if we encounter a cover node with our exact prefix length, it's
-			 * necessarily the same value, so we insert there as a duplicate on
-			 * the left. For that, we go down on the left and the leaf detection
-			 * code will finish the job.
-			 */
-			if ((new->node.pfx << 1) == old_node_bit) {
-				root = &old->node.branches;
-				side = EB_LEFT;
-				troot = root->b[side];
-				continue;
-			}
-
-			/* cover nodes are always walked through on the right */
-			side = EB_RGHT;
-			bit = old_node_bit >> 1; /* recheck that bit */
-			root = &old->node.branches;
-			troot = root->b[side];
-			continue;
-		}
-
-		/* we don't want to skip bits for further comparisons, so we must limit <bit>.
-		 * However, since we're going down around <old_node_bit>, we know it will be
-		 * properly matched, so we can skip this bit.
-		 */
-		old_node_bit >>= 1;
-		bit = old_node_bit + 1;
-
-		/* walk down */
-		root = &old->node.branches;
-		side = old_node_bit & 7;
-		side ^= 7;
-		side = (new->key[old_node_bit >> 3] >> side) & 1;
-		troot = root->b[side];
-	}
-
-	/* Right here, we have 4 possibilities :
-	 * - the tree does not contain any leaf matching the
-	 *   key, and we have new->key < old->key. We insert
-	 *   new above old, on the left ;
-	 *
-	 * - the tree does not contain any leaf matching the
-	 *   key, and we have new->key > old->key. We insert
-	 *   new above old, on the right ;
-	 *
-	 * - the tree does contain the key with the same prefix
-	 *   length. We add the new key next to it as a first
-	 *   duplicate (since it was alone).
-	 *
-	 * The last two cases can easily be partially merged.
-	 *
-	 * - the tree contains a leaf matching the key, we have
-	 *   to insert above it as a cover node. The leaf with
-	 *   the shortest prefix becomes the left subtree and
-	 *   the leaf with the longest prefix becomes the right
-	 *   one. The cover node gets the min of both prefixes
-	 *   as its new bit.
-	 */
-
-	/* first we want to ensure that we compare the correct bit, which means
-	 * the largest common to both nodes.
-	 */
-	if (bit > new->node.pfx)
-		bit = new->node.pfx;
-	if (bit > old->node.pfx)
-		bit = old->node.pfx;
-
-	new->node.bit = (bit << 1) + 1; /* assume normal node by default */
-
-	/* if one prefix is included in the second one, we don't compare bits
-	 * because they won't necessarily match, we just proceed with a cover
-	 * node insertion.
-	 */
-	diff = 0;
-	if (bit < old->node.pfx && bit < new->node.pfx)
-		diff = cmp_bits(new->key, old->key, bit);
-
-	if (diff == 0) {
-		/* Both keys match. Either it's a duplicate entry or we have to
-		 * put the shortest prefix left and the largest one right below
-		 * a new cover node. By default, diff==0 means we'll be inserted
-		 * on the right.
-		 */
-		new->node.bit--; /* anticipate cover node insertion */
-		if (new->node.pfx == old->node.pfx) {
-			new->node.bit = -1; /* mark as new dup tree, just in case */
-
-			if (unlikely(eb_gettag(root_right))) {
-				/* we refuse to duplicate this key if the tree is
-				 * tagged as containing only unique keys.
-				 */
-				return old;
-			}
-
-			if (eb_gettag(troot) != EB_LEAF) {
-				/* there was already a dup tree below */
-				struct eb_node *ret;
-				ret = eb_insert_dup(&old->node, &new->node);
-				return container_of(ret, struct ebmb_node, node);
-			}
-			/* otherwise fall through to insert first duplicate */
-		}
-		/* otherwise we just rely on the tests below to select the right side */
-		else if (new->node.pfx < old->node.pfx)
-			diff = -1; /* force insertion to left side */
-	}
-
- insert_above:
-	new_left = eb_dotag(&new->node.branches, EB_LEFT);
-	new_rght = eb_dotag(&new->node.branches, EB_RGHT);
-	new_leaf = eb_dotag(&new->node.branches, EB_LEAF);
-
-	if (diff >= 0) {
-		new->node.branches.b[EB_LEFT] = troot;
-		new->node.branches.b[EB_RGHT] = new_leaf;
-		new->node.leaf_p = new_rght;
-		*up_ptr = new_left;
-	}
-	else {
-		new->node.branches.b[EB_LEFT] = new_leaf;
-		new->node.branches.b[EB_RGHT] = troot;
-		new->node.leaf_p = new_left;
-		*up_ptr = new_rght;
-	}
-
-	root->b[side] = eb_dotag(&new->node.branches, EB_NODE);
-	return new;
-}
-
-
-
-#endif /* _EBMBTREE_H */
-
diff --git a/deps/haproxy-1.4.21/ebtree/ebpttree.c b/deps/haproxy-1.4.21/ebtree/ebpttree.c
deleted file mode 100644
index d0ca15f..0000000
--- a/deps/haproxy-1.4.21/ebtree/ebpttree.c
+++ /dev/null
@@ -1,208 +0,0 @@
-/*
- * Elastic Binary Trees - exported functions for operations on pointer nodes.
- * Version 6.0
- * (C) 2002-2010 - Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-/* Consult ebpttree.h for more details about those functions */
-
-#include "ebpttree.h"
-
-REGPRM2 struct ebpt_node *ebpt_insert(struct eb_root *root, struct ebpt_node *new)
-{
-	return __ebpt_insert(root, new);
-}
-
-REGPRM2 struct ebpt_node *ebpt_lookup(struct eb_root *root, void *x)
-{
-	return __ebpt_lookup(root, x);
-}
-
-/*
- * Find the last occurrence of the highest key in the tree <root>, which is
- * equal to or less than <x>. NULL is returned is no key matches.
- */
-REGPRM2 struct ebpt_node *ebpt_lookup_le(struct eb_root *root, void *x)
-{
-	struct ebpt_node *node;
-	eb_troot_t *troot;
-
-	troot = root->b[EB_LEFT];
-	if (unlikely(troot == NULL))
-		return NULL;
-
-	while (1) {
-		if ((eb_gettag(troot) == EB_LEAF)) {
-			/* We reached a leaf, which means that the whole upper
-			 * parts were common. We will return either the current
-			 * node or its next one if the former is too small.
-			 */
-			node = container_of(eb_untag(troot, EB_LEAF),
-					    struct ebpt_node, node.branches);
-			if (node->key <= x)
-				return node;
-			/* return prev */
-			troot = node->node.leaf_p;
-			break;
-		}
-		node = container_of(eb_untag(troot, EB_NODE),
-				    struct ebpt_node, node.branches);
-
-		if (node->node.bit < 0) {
-			/* We're at the top of a dup tree. Either we got a
-			 * matching value and we return the rightmost node, or
-			 * we don't and we skip the whole subtree to return the
-			 * prev node before the subtree. Note that since we're
-			 * at the top of the dup tree, we can simply return the
-			 * prev node without first trying to escape from the
-			 * tree.
-			 */
-			if (node->key <= x) {
-				troot = node->node.branches.b[EB_RGHT];
-				while (eb_gettag(troot) != EB_LEAF)
-					troot = (eb_untag(troot, EB_NODE))->b[EB_RGHT];
-				return container_of(eb_untag(troot, EB_LEAF),
-						    struct ebpt_node, node.branches);
-			}
-			/* return prev */
-			troot = node->node.node_p;
-			break;
-		}
-
-		if ((((ptr_t)x ^ (ptr_t)node->key) >> node->node.bit) >= EB_NODE_BRANCHES) {
-			/* No more common bits at all. Either this node is too
-			 * small and we need to get its highest value, or it is
-			 * too large, and we need to get the prev value.
-			 */
-			if (((ptr_t)node->key >> node->node.bit) < ((ptr_t)x >> node->node.bit)) {
-				troot = node->node.branches.b[EB_RGHT];
-				return ebpt_entry(eb_walk_down(troot, EB_RGHT), struct ebpt_node, node);
-			}
-
-			/* Further values will be too high here, so return the prev
-			 * unique node (if it exists).
-			 */
-			troot = node->node.node_p;
-			break;
-		}
-		troot = node->node.branches.b[((ptr_t)x >> node->node.bit) & EB_NODE_BRANCH_MASK];
-	}
-
-	/* If we get here, it means we want to report previous node before the
-	 * current one which is not above. <troot> is already initialised to
-	 * the parent's branches.
-	 */
-	while (eb_gettag(troot) == EB_LEFT) {
-		/* Walking up from left branch. We must ensure that we never
-		 * walk beyond root.
-		 */
-		if (unlikely(eb_clrtag((eb_untag(troot, EB_LEFT))->b[EB_RGHT]) == NULL))
-			return NULL;
-		troot = (eb_root_to_node(eb_untag(troot, EB_LEFT)))->node_p;
-	}
-	/* Note that <troot> cannot be NULL at this stage */
-	troot = (eb_untag(troot, EB_RGHT))->b[EB_LEFT];
-	node = ebpt_entry(eb_walk_down(troot, EB_RGHT), struct ebpt_node, node);
-	return node;
-}
-
-/*
- * Find the first occurrence of the lowest key in the tree <root>, which is
- * equal to or greater than <x>. NULL is returned is no key matches.
- */
-REGPRM2 struct ebpt_node *ebpt_lookup_ge(struct eb_root *root, void *x)
-{
-	struct ebpt_node *node;
-	eb_troot_t *troot;
-
-	troot = root->b[EB_LEFT];
-	if (unlikely(troot == NULL))
-		return NULL;
-
-	while (1) {
-		if ((eb_gettag(troot) == EB_LEAF)) {
-			/* We reached a leaf, which means that the whole upper
-			 * parts were common. We will return either the current
-			 * node or its next one if the former is too small.
-			 */
-			node = container_of(eb_untag(troot, EB_LEAF),
-					    struct ebpt_node, node.branches);
-			if (node->key >= x)
-				return node;
-			/* return next */
-			troot = node->node.leaf_p;
-			break;
-		}
-		node = container_of(eb_untag(troot, EB_NODE),
-				    struct ebpt_node, node.branches);
-
-		if (node->node.bit < 0) {
-			/* We're at the top of a dup tree. Either we got a
-			 * matching value and we return the leftmost node, or
-			 * we don't and we skip the whole subtree to return the
-			 * next node after the subtree. Note that since we're
-			 * at the top of the dup tree, we can simply return the
-			 * next node without first trying to escape from the
-			 * tree.
-			 */
-			if (node->key >= x) {
-				troot = node->node.branches.b[EB_LEFT];
-				while (eb_gettag(troot) != EB_LEAF)
-					troot = (eb_untag(troot, EB_NODE))->b[EB_LEFT];
-				return container_of(eb_untag(troot, EB_LEAF),
-						    struct ebpt_node, node.branches);
-			}
-			/* return next */
-			troot = node->node.node_p;
-			break;
-		}
-
-		if ((((ptr_t)x ^ (ptr_t)node->key) >> node->node.bit) >= EB_NODE_BRANCHES) {
-			/* No more common bits at all. Either this node is too
-			 * large and we need to get its lowest value, or it is too
-			 * small, and we need to get the next value.
-			 */
-			if (((ptr_t)node->key >> node->node.bit) > ((ptr_t)x >> node->node.bit)) {
-				troot = node->node.branches.b[EB_LEFT];
-				return ebpt_entry(eb_walk_down(troot, EB_LEFT), struct ebpt_node, node);
-			}
-
-			/* Further values will be too low here, so return the next
-			 * unique node (if it exists).
-			 */
-			troot = node->node.node_p;
-			break;
-		}
-		troot = node->node.branches.b[((ptr_t)x >> node->node.bit) & EB_NODE_BRANCH_MASK];
-	}
-
-	/* If we get here, it means we want to report next node after the
-	 * current one which is not below. <troot> is already initialised
-	 * to the parent's branches.
-	 */
-	while (eb_gettag(troot) != EB_LEFT)
-		/* Walking up from right branch, so we cannot be below root */
-		troot = (eb_root_to_node(eb_untag(troot, EB_RGHT)))->node_p;
-
-	/* Note that <troot> cannot be NULL at this stage */
-	troot = (eb_untag(troot, EB_LEFT))->b[EB_RGHT];
-	if (eb_clrtag(troot) == NULL)
-		return NULL;
-
-	node = ebpt_entry(eb_walk_down(troot, EB_LEFT), struct ebpt_node, node);
-	return node;
-}
diff --git a/deps/haproxy-1.4.21/ebtree/ebpttree.h b/deps/haproxy-1.4.21/ebtree/ebpttree.h
deleted file mode 100644
index b040c35..0000000
--- a/deps/haproxy-1.4.21/ebtree/ebpttree.h
+++ /dev/null
@@ -1,165 +0,0 @@
-/*
- * Elastic Binary Trees - macros and structures for operations on pointer nodes.
- * Version 6.0
- * (C) 2002-2010 - Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _EBPTTREE_H
-#define _EBPTTREE_H
-
-#include "ebtree.h"
-#include "eb32tree.h"
-#include "eb64tree.h"
-
-
-/* Return the structure of type <type> whose member <member> points to <ptr> */
-#define ebpt_entry(ptr, type, member) container_of(ptr, type, member)
-
-#define EBPT_ROOT	EB_ROOT
-#define EBPT_TREE_HEAD	EB_TREE_HEAD
-
-/* on *almost* all platforms, a pointer can be cast into a size_t which is unsigned */
-#ifndef PTR_INT_TYPE
-#define PTR_INT_TYPE	size_t
-#endif
-
-typedef PTR_INT_TYPE ptr_t;
-
-/* This structure carries a node, a leaf, and a key. It must start with the
- * eb_node so that it can be cast into an eb_node. We could also have put some
- * sort of transparent union here to reduce the indirection level, but the fact
- * is, the end user is not meant to manipulate internals, so this is pointless.
- * Internally, it is automatically cast as an eb32_node or eb64_node.
- */
-struct ebpt_node {
-	struct eb_node node; /* the tree node, must be at the beginning */
-	void *key;
-};
-
-/*
- * Exported functions and macros.
- * Many of them are always inlined because they are extremely small, and
- * are generally called at most once or twice in a program.
- */
-
-/* Return leftmost node in the tree, or NULL if none */
-static forceinline struct ebpt_node *ebpt_first(struct eb_root *root)
-{
-	return ebpt_entry(eb_first(root), struct ebpt_node, node);
-}
-
-/* Return rightmost node in the tree, or NULL if none */
-static forceinline struct ebpt_node *ebpt_last(struct eb_root *root)
-{
-	return ebpt_entry(eb_last(root), struct ebpt_node, node);
-}
-
-/* Return next node in the tree, or NULL if none */
-static forceinline struct ebpt_node *ebpt_next(struct ebpt_node *ebpt)
-{
-	return ebpt_entry(eb_next(&ebpt->node), struct ebpt_node, node);
-}
-
-/* Return previous node in the tree, or NULL if none */
-static forceinline struct ebpt_node *ebpt_prev(struct ebpt_node *ebpt)
-{
-	return ebpt_entry(eb_prev(&ebpt->node), struct ebpt_node, node);
-}
-
-/* Return next node in the tree, skipping duplicates, or NULL if none */
-static forceinline struct ebpt_node *ebpt_next_unique(struct ebpt_node *ebpt)
-{
-	return ebpt_entry(eb_next_unique(&ebpt->node), struct ebpt_node, node);
-}
-
-/* Return previous node in the tree, skipping duplicates, or NULL if none */
-static forceinline struct ebpt_node *ebpt_prev_unique(struct ebpt_node *ebpt)
-{
-	return ebpt_entry(eb_prev_unique(&ebpt->node), struct ebpt_node, node);
-}
-
-/* Delete node from the tree if it was linked in. Mark the node unused. Note
- * that this function relies on a non-inlined generic function: eb_delete.
- */
-static forceinline void ebpt_delete(struct ebpt_node *ebpt)
-{
-	eb_delete(&ebpt->node);
-}
-
-/*
- * The following functions are inlined but derived from the integer versions.
- */
-static forceinline struct ebpt_node *ebpt_lookup(struct eb_root *root, void *x)
-{
-	if (sizeof(void *) == 4)
-		return (struct ebpt_node *)eb32_lookup(root, (u32)(PTR_INT_TYPE)x);
-	else
-		return (struct ebpt_node *)eb64_lookup(root, (u64)(PTR_INT_TYPE)x);
-}
-
-static forceinline struct ebpt_node *ebpt_lookup_le(struct eb_root *root, void *x)
-{
-	if (sizeof(void *) == 4)
-		return (struct ebpt_node *)eb32_lookup_le(root, (u32)(PTR_INT_TYPE)x);
-	else
-		return (struct ebpt_node *)eb64_lookup_le(root, (u64)(PTR_INT_TYPE)x);
-}
-
-static forceinline struct ebpt_node *ebpt_lookup_ge(struct eb_root *root, void *x)
-{
-	if (sizeof(void *) == 4)
-		return (struct ebpt_node *)eb32_lookup_ge(root, (u32)(PTR_INT_TYPE)x);
-	else
-		return (struct ebpt_node *)eb64_lookup_ge(root, (u64)(PTR_INT_TYPE)x);
-}
-
-static forceinline struct ebpt_node *ebpt_insert(struct eb_root *root, struct ebpt_node *new)
-{
-	if (sizeof(void *) == 4)
-		return (struct ebpt_node *)eb32_insert(root, (struct eb32_node *)new);
-	else
-		return (struct ebpt_node *)eb64_insert(root, (struct eb64_node *)new);
-}
-
-/*
- * The following functions are less likely to be used directly, because
- * their code is larger. The non-inlined version is preferred.
- */
-
-/* Delete node from the tree if it was linked in. Mark the node unused. */
-static forceinline void __ebpt_delete(struct ebpt_node *ebpt)
-{
-	__eb_delete(&ebpt->node);
-}
-
-static forceinline struct ebpt_node *__ebpt_lookup(struct eb_root *root, void *x)
-{
-	if (sizeof(void *) == 4)
-		return (struct ebpt_node *)__eb32_lookup(root, (u32)(PTR_INT_TYPE)x);
-	else
-		return (struct ebpt_node *)__eb64_lookup(root, (u64)(PTR_INT_TYPE)x);
-}
-
-static forceinline struct ebpt_node *__ebpt_insert(struct eb_root *root, struct ebpt_node *new)
-{
-	if (sizeof(void *) == 4)
-		return (struct ebpt_node *)__eb32_insert(root, (struct eb32_node *)new);
-	else
-		return (struct ebpt_node *)__eb64_insert(root, (struct eb64_node *)new);
-}
-
-#endif /* _EBPT_TREE_H */
diff --git a/deps/haproxy-1.4.21/ebtree/ebsttree.c b/deps/haproxy-1.4.21/ebtree/ebsttree.c
deleted file mode 100644
index a98b0f3..0000000
--- a/deps/haproxy-1.4.21/ebtree/ebsttree.c
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * Elastic Binary Trees - exported functions for String data nodes.
- * Version 6.0
- * (C) 2002-2010 - Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-/* Consult ebsttree.h for more details about those functions */
-
-#include "ebsttree.h"
-
-/* Find the first occurence of a zero-terminated string <x> in the tree <root>.
- * It's the caller's reponsibility to use this function only on trees which
- * only contain zero-terminated strings. If none can be found, return NULL.
- */
-REGPRM2 struct ebmb_node *ebst_lookup(struct eb_root *root, const char *x)
-{
-	return __ebst_lookup(root, x);
-}
-
-/* Find the first occurence of a length <len> string <x> in the tree <root>.
- * It's the caller's reponsibility to use this function only on trees which
- * only contain zero-terminated strings, and that no null character is present
- * in string <x> in the first <len> chars. If none can be found, return NULL.
- */
-REGPRM3 struct ebmb_node *ebst_lookup_len(struct eb_root *root, const char *x, unsigned int len)
-{
-	struct ebmb_node *node;
-
-	node = ebmb_lookup(root, x, len);
-	if (!node || node->key[len] != 0)
-		return NULL;
-	return node;
-}
-
-/* Insert ebmb_node <new> into subtree starting at node root <root>. Only
- * new->key needs be set with the zero-terminated string key. The ebmb_node is
- * returned. If root->b[EB_RGHT]==1, the tree may only contain unique keys. The
- * caller is responsible for properly terminating the key with a zero.
- */
-REGPRM2 struct ebmb_node *ebst_insert(struct eb_root *root, struct ebmb_node *new)
-{
-	return __ebst_insert(root, new);
-}
diff --git a/deps/haproxy-1.4.21/ebtree/ebsttree.h b/deps/haproxy-1.4.21/ebtree/ebsttree.h
deleted file mode 100644
index 121ada7..0000000
--- a/deps/haproxy-1.4.21/ebtree/ebsttree.h
+++ /dev/null
@@ -1,309 +0,0 @@
-/*
- * Elastic Binary Trees - macros to manipulate String data nodes.
- * Version 6.0
- * (C) 2002-2010 - Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-/* These functions and macros rely on Multi-Byte nodes */
-
-#ifndef _EBSTTREE_H
-#define _EBSTTREE_H
-
-#include "ebtree.h"
-#include "ebmbtree.h"
-
-/* The following functions are not inlined by default. They are declared
- * in ebsttree.c, which simply relies on their inline version.
- */
-REGPRM2 struct ebmb_node *ebst_lookup(struct eb_root *root, const char *x);
-REGPRM3 struct ebmb_node *ebst_lookup_len(struct eb_root *root, const char *x, unsigned int len);
-REGPRM2 struct ebmb_node *ebst_insert(struct eb_root *root, struct ebmb_node *new);
-
-/* Find the first occurence of a zero-terminated string <x> in the tree <root>.
- * It's the caller's reponsibility to use this function only on trees which
- * only contain zero-terminated strings. If none can be found, return NULL.
- */
-static forceinline struct ebmb_node *__ebst_lookup(struct eb_root *root, const void *x)
-{
-	struct ebmb_node *node;
-	eb_troot_t *troot;
-	int bit;
-	int node_bit;
-
-	troot = root->b[EB_LEFT];
-	if (unlikely(troot == NULL))
-		return NULL;
-
-	bit = 0;
-	while (1) {
-		if ((eb_gettag(troot) == EB_LEAF)) {
-			node = container_of(eb_untag(troot, EB_LEAF),
-					    struct ebmb_node, node.branches);
-			if (strcmp((char *)node->key, x) == 0)
-				return node;
-			else
-				return NULL;
-		}
-		node = container_of(eb_untag(troot, EB_NODE),
-				    struct ebmb_node, node.branches);
-		node_bit = node->node.bit;
-
-		if (node_bit < 0) {
-			/* We have a dup tree now. Either it's for the same
-			 * value, and we walk down left, or it's a different
-			 * one and we don't have our key.
-			 */
-			if (strcmp((char *)node->key, x) != 0)
-				return NULL;
-
-			troot = node->node.branches.b[EB_LEFT];
-			while (eb_gettag(troot) != EB_LEAF)
-				troot = (eb_untag(troot, EB_NODE))->b[EB_LEFT];
-			node = container_of(eb_untag(troot, EB_LEAF),
-					    struct ebmb_node, node.branches);
-			return node;
-		}
-
-		/* OK, normal data node, let's walk down but don't compare data
-		 * if we already reached the end of the key.
-		 */
-		if (likely(bit >= 0)) {
-			bit = string_equal_bits(x, node->key, bit);
-			if (likely(bit < node_bit)) {
-				if (bit >= 0)
-					return NULL; /* no more common bits */
-
-				/* bit < 0 : we reached the end of the key. If we
-				 * are in a tree with unique keys, we can return
-				 * this node. Otherwise we have to walk it down
-				 * and stop comparing bits.
-				 */
-				if (eb_gettag(root->b[EB_RGHT]))
-					return node;
-			}
-			/* if the bit is larger than the node's, we must bound it
-			 * because we might have compared too many bytes with an
-			 * inappropriate leaf. For a test, build a tree from "0",
-			 * "WW", "W", "S" inserted in this exact sequence and lookup
-			 * "W" => "S" is returned without this assignment.
-			 */
-			else
-				bit = node_bit;
-		}
-
-		troot = node->node.branches.b[(((unsigned char*)x)[node_bit >> 3] >>
-					       (~node_bit & 7)) & 1];
-	}
-}
-
-/* Insert ebmb_node <new> into subtree starting at node root <root>. Only
- * new->key needs be set with the zero-terminated string key. The ebmb_node is
- * returned. If root->b[EB_RGHT]==1, the tree may only contain unique keys. The
- * caller is responsible for properly terminating the key with a zero.
- */
-static forceinline struct ebmb_node *
-__ebst_insert(struct eb_root *root, struct ebmb_node *new)
-{
-	struct ebmb_node *old;
-	unsigned int side;
-	eb_troot_t *troot;
-	eb_troot_t *root_right;
-	int diff;
-	int bit;
-	int old_node_bit;
-
-	side = EB_LEFT;
-	troot = root->b[EB_LEFT];
-	root_right = root->b[EB_RGHT];
-	if (unlikely(troot == NULL)) {
-		/* Tree is empty, insert the leaf part below the left branch */
-		root->b[EB_LEFT] = eb_dotag(&new->node.branches, EB_LEAF);
-		new->node.leaf_p = eb_dotag(root, EB_LEFT);
-		new->node.node_p = NULL; /* node part unused */
-		return new;
-	}
-
-	/* The tree descent is fairly easy :
-	 *  - first, check if we have reached a leaf node
-	 *  - second, check if we have gone too far
-	 *  - third, reiterate
-	 * Everywhere, we use <new> for the node node we are inserting, <root>
-	 * for the node we attach it to, and <old> for the node we are
-	 * displacing below <new>. <troot> will always point to the future node
-	 * (tagged with its type). <side> carries the side the node <new> is
-	 * attached to below its parent, which is also where previous node
-	 * was attached.
-	 */
-
-	bit = 0;
-	while (1) {
-		if (unlikely(eb_gettag(troot) == EB_LEAF)) {
-			eb_troot_t *new_left, *new_rght;
-			eb_troot_t *new_leaf, *old_leaf;
-
-			old = container_of(eb_untag(troot, EB_LEAF),
-					    struct ebmb_node, node.branches);
-
-			new_left = eb_dotag(&new->node.branches, EB_LEFT);
-			new_rght = eb_dotag(&new->node.branches, EB_RGHT);
-			new_leaf = eb_dotag(&new->node.branches, EB_LEAF);
-			old_leaf = eb_dotag(&old->node.branches, EB_LEAF);
-
-			new->node.node_p = old->node.leaf_p;
-
-			/* Right here, we have 3 possibilities :
-			 * - the tree does not contain the key, and we have
-			 *   new->key < old->key. We insert new above old, on
-			 *   the left ;
-			 *
-			 * - the tree does not contain the key, and we have
-			 *   new->key > old->key. We insert new above old, on
-			 *   the right ;
-			 *
-			 * - the tree does contain the key, which implies it
-			 *   is alone. We add the new key next to it as a
-			 *   first duplicate.
-			 *
-			 * The last two cases can easily be partially merged.
-			 */
-			if (bit >= 0)
-				bit = string_equal_bits(new->key, old->key, bit);
-
-			if (bit < 0) {
-				/* key was already there */
-
-				/* we may refuse to duplicate this key if the tree is
-				 * tagged as containing only unique keys.
-				 */
-				if (eb_gettag(root_right))
-					return old;
-
-				/* new arbitrarily goes to the right and tops the dup tree */
-				old->node.leaf_p = new_left;
-				new->node.leaf_p = new_rght;
-				new->node.branches.b[EB_LEFT] = old_leaf;
-				new->node.branches.b[EB_RGHT] = new_leaf;
-				new->node.bit = -1;
-				root->b[side] = eb_dotag(&new->node.branches, EB_NODE);
-				return new;
-			}
-
-			diff = cmp_bits(new->key, old->key, bit);
-			if (diff < 0) {
-				/* new->key < old->key, new takes the left */
-				new->node.leaf_p = new_left;
-				old->node.leaf_p = new_rght;
-				new->node.branches.b[EB_LEFT] = new_leaf;
-				new->node.branches.b[EB_RGHT] = old_leaf;
-			} else {
-				/* new->key > old->key, new takes the right */
-				old->node.leaf_p = new_left;
-				new->node.leaf_p = new_rght;
-				new->node.branches.b[EB_LEFT] = old_leaf;
-				new->node.branches.b[EB_RGHT] = new_leaf;
-			}
-			break;
-		}
-
-		/* OK we're walking down this link */
-		old = container_of(eb_untag(troot, EB_NODE),
-				   struct ebmb_node, node.branches);
-		old_node_bit = old->node.bit;
-
-		/* Stop going down when we don't have common bits anymore. We
-		 * also stop in front of a duplicates tree because it means we
-		 * have to insert above. Note: we can compare more bits than
-		 * the current node's because as long as they are identical, we
-		 * know we descend along the correct side.
-		 */
-		if (bit >= 0 && (bit < old_node_bit || old_node_bit < 0))
-			bit = string_equal_bits(new->key, old->key, bit);
-
-		if (unlikely(bit < 0)) {
-			/* Perfect match, we must only stop on head of dup tree
-			 * or walk down to a leaf.
-			 */
-			if (old_node_bit < 0) {
-				/* We know here that string_equal_bits matched all
-				 * bits and that we're on top of a dup tree, then
-				 * we can perform the dup insertion and return.
-				 */
-				struct eb_node *ret;
-				ret = eb_insert_dup(&old->node, &new->node);
-				return container_of(ret, struct ebmb_node, node);
-			}
-			/* OK so let's walk down */
-		}
-		else if (bit < old_node_bit || old_node_bit < 0) {
-			/* The tree did not contain the key, or we stopped on top of a dup
-			 * tree, possibly containing the key. In the former case, we insert
-			 * <new> before the node <old>, and set ->bit to designate the lowest
-			 * bit position in <new> which applies to ->branches.b[]. In the later
-			 * case, we add the key to the existing dup tree. Note that we cannot
-			 * enter here if we match an intermediate node's key that is not the
-			 * head of a dup tree.
-			 */
-			eb_troot_t *new_left, *new_rght;
-			eb_troot_t *new_leaf, *old_node;
-
-			new_left = eb_dotag(&new->node.branches, EB_LEFT);
-			new_rght = eb_dotag(&new->node.branches, EB_RGHT);
-			new_leaf = eb_dotag(&new->node.branches, EB_LEAF);
-			old_node = eb_dotag(&old->node.branches, EB_NODE);
-
-			new->node.node_p = old->node.node_p;
-
-			/* we can never match all bits here */
-			diff = cmp_bits(new->key, old->key, bit);
-			if (diff < 0) {
-				new->node.leaf_p = new_left;
-				old->node.node_p = new_rght;
-				new->node.branches.b[EB_LEFT] = new_leaf;
-				new->node.branches.b[EB_RGHT] = old_node;
-			}
-			else {
-				old->node.node_p = new_left;
-				new->node.leaf_p = new_rght;
-				new->node.branches.b[EB_LEFT] = old_node;
-				new->node.branches.b[EB_RGHT] = new_leaf;
-			}
-			break;
-		}
-
-		/* walk down */
-		root = &old->node.branches;
-		side = (new->key[old_node_bit >> 3] >> (~old_node_bit & 7)) & 1;
-		troot = root->b[side];
-	}
-
-	/* Ok, now we are inserting <new> between <root> and <old>. <old>'s
-	 * parent is already set to <new>, and the <root>'s branch is still in
-	 * <side>. Update the root's leaf till we have it. Note that we can also
-	 * find the side by checking the side of new->node.node_p.
-	 */
-
-	/* We need the common higher bits between new->key and old->key.
-	 * This number of bits is already in <bit>.
-	 * NOTE: we can't get here whit bit < 0 since we found a dup !
-	 */
-	new->node.bit = bit;
-	root->b[side] = eb_dotag(&new->node.branches, EB_NODE);
-	return new;
-}
-
-#endif /* _EBSTTREE_H */
-
diff --git a/deps/haproxy-1.4.21/ebtree/ebtree.c b/deps/haproxy-1.4.21/ebtree/ebtree.c
deleted file mode 100644
index 1bcd46b..0000000
--- a/deps/haproxy-1.4.21/ebtree/ebtree.c
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Elastic Binary Trees - exported generic functions
- * Version 6.0
- * (C) 2002-2010 - Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#include "ebtree.h"
-
-void eb_delete(struct eb_node *node)
-{
-	__eb_delete(node);
-}
-
-/* used by insertion primitives */
-REGPRM1 struct eb_node *eb_insert_dup(struct eb_node *sub, struct eb_node *new)
-{
-	return __eb_insert_dup(sub, new);
-}
diff --git a/deps/haproxy-1.4.21/ebtree/ebtree.h b/deps/haproxy-1.4.21/ebtree/ebtree.h
deleted file mode 100644
index 7aaca90..0000000
--- a/deps/haproxy-1.4.21/ebtree/ebtree.h
+++ /dev/null
@@ -1,866 +0,0 @@
-/*
- * Elastic Binary Trees - generic macros and structures.
- * Version 6.0.1
- * (C) 2002-2010 - Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- *
- * Short history :
- *
- * 2007/09/28: full support for the duplicates tree => v3
- * 2007/07/08: merge back cleanups from kernel version.
- * 2007/07/01: merge into Linux Kernel (try 1).
- * 2007/05/27: version 2: compact everything into one single struct
- * 2007/05/18: adapted the structure to support embedded nodes
- * 2007/05/13: adapted to mempools v2.
- */
-
-
-
-/*
-  General idea:
-  -------------
-  In a radix binary tree, we may have up to 2N-1 nodes for N keys if all of
-  them are leaves. If we find a way to differentiate intermediate nodes (later
-  called "nodes") and final nodes (later called "leaves"), and we associate
-  them by two, it is possible to build sort of a self-contained radix tree with
-  intermediate nodes always present. It will not be as cheap as the ultree for
-  optimal cases as shown below, but the optimal case almost never happens :
-
-  Eg, to store 8, 10, 12, 13, 14 :
-
-             ultree          this theorical tree
-
-               8                   8
-              / \                 / \
-             10 12               10 12
-               /  \                /  \
-              13  14              12  14
-                                 / \
-                                12 13
-
-   Note that on real-world tests (with a scheduler), is was verified that the
-   case with data on an intermediate node never happens. This is because the
-   data spectrum is too large for such coincidences to happen. It would require
-   for instance that a task has its expiration time at an exact second, with
-   other tasks sharing that second. This is too rare to try to optimize for it.
-
-   What is interesting is that the node will only be added above the leaf when
-   necessary, which implies that it will always remain somewhere above it. So
-   both the leaf and the node can share the exact value of the leaf, because
-   when going down the node, the bit mask will be applied to comparisons. So we
-   are tempted to have one single key shared between the node and the leaf.
-
-   The bit only serves the nodes, and the dups only serve the leaves. So we can
-   put a lot of information in common. This results in one single entity with
-   two branch pointers and two parent pointers, one for the node part, and one
-   for the leaf part :
-
-              node's         leaf's
-              parent         parent
-                |              |
-              [node]         [leaf]
-               / \
-           left   right
-         branch   branch
-
-   The node may very well refer to its leaf counterpart in one of its branches,
-   indicating that its own leaf is just below it :
-
-              node's
-              parent
-                |
-              [node]
-               / \
-           left  [leaf]
-         branch
-
-   Adding keys in such a tree simply consists in inserting nodes between
-   other nodes and/or leaves :
-
-                [root]
-                  |
-               [node2]
-                 / \
-          [leaf1]   [node3]
-                      / \
-               [leaf2]   [leaf3]
-
-   On this diagram, we notice that [node2] and [leaf2] have been pulled away
-   from each other due to the insertion of [node3], just as if there would be
-   an elastic between both parts. This elastic-like behaviour gave its name to
-   the tree : "Elastic Binary Tree", or "EBtree". The entity which associates a
-   node part and a leaf part will be called an "EB node".
-
-   We also notice on the diagram that there is a root entity required to attach
-   the tree. It only contains two branches and there is nothing above it. This
-   is an "EB root". Some will note that [leaf1] has no [node1]. One property of
-   the EBtree is that all nodes have their branches filled, and that if a node
-   has only one branch, it does not need to exist. Here, [leaf1] was added
-   below [root] and did not need any node.
-
-   An EB node contains :
-     - a pointer to the node's parent (node_p)
-     - a pointer to the leaf's parent (leaf_p)
-     - two branches pointing to lower nodes or leaves (branches)
-     - a bit position (bit)
-     - an optional key.
-
-   The key here is optional because it's used only during insertion, in order
-   to classify the nodes. Nothing else in the tree structure requires knowledge
-   of the key. This makes it possible to write type-agnostic primitives for
-   everything, and type-specific insertion primitives. This has led to consider
-   two types of EB nodes. The type-agnostic ones will serve as a header for the
-   other ones, and will simply be called "struct eb_node". The other ones will
-   have their type indicated in the structure name. Eg: "struct eb32_node" for
-   nodes carrying 32 bit keys.
-
-   We will also node that the two branches in a node serve exactly the same
-   purpose as an EB root. For this reason, a "struct eb_root" will be used as
-   well inside the struct eb_node. In order to ease pointer manipulation and
-   ROOT detection when walking upwards, all the pointers inside an eb_node will
-   point to the eb_root part of the referenced EB nodes, relying on the same
-   principle as the linked lists in Linux.
-
-   Another important point to note, is that when walking inside a tree, it is
-   very convenient to know where a node is attached in its parent, and what
-   type of branch it has below it (leaf or node). In order to simplify the
-   operations and to speed up the processing, it was decided in this specific
-   implementation to use the lowest bit from the pointer to designate the side
-   of the upper pointers (left/right) and the type of a branch (leaf/node).
-   This practise is not mandatory by design, but an implementation-specific
-   optimisation permitted on all platforms on which data must be aligned. All
-   known 32 bit platforms align their integers and pointers to 32 bits, leaving
-   the two lower bits unused. So, we say that the pointers are "tagged". And
-   since they designate pointers to root parts, we simply call them
-   "tagged root pointers", or "eb_troot" in the code.
-
-   Duplicate keys are stored in a special manner. When inserting a key, if
-   the same one is found, then an incremental binary tree is built at this
-   place from these keys. This ensures that no special case has to be written
-   to handle duplicates when walking through the tree or when deleting entries.
-   It also guarantees that duplicates will be walked in the exact same order
-   they were inserted. This is very important when trying to achieve fair
-   processing distribution for instance.
-
-   Algorithmic complexity can be derived from 3 variables :
-     - the number of possible different keys in the tree : P
-     - the number of entries in the tree : N
-     - the number of duplicates for one key : D
-
-   Note that this tree is deliberately NOT balanced. For this reason, the worst
-   case may happen with a small tree (eg: 32 distinct keys of one bit). BUT,
-   the operations required to manage such data are so much cheap that they make
-   it worth using it even under such conditions. For instance, a balanced tree
-   may require only 6 levels to store those 32 keys when this tree will
-   require 32. But if per-level operations are 5 times cheaper, it wins.
-
-   Minimal, Maximal and Average times are specified in number of operations.
-   Minimal is given for best condition, Maximal for worst condition, and the
-   average is reported for a tree containing random keys. An operation
-   generally consists in jumping from one node to the other.
-
-   Complexity :
-     - lookup              : min=1, max=log(P), avg=log(N)
-     - insertion from root : min=1, max=log(P), avg=log(N)
-     - insertion of dups   : min=1, max=log(D), avg=log(D)/2 after lookup
-     - deletion            : min=1, max=1,      avg=1
-     - prev/next           : min=1, max=log(P), avg=2 :
-       N/2 nodes need 1 hop  => 1*N/2
-       N/4 nodes need 2 hops => 2*N/4
-       N/8 nodes need 3 hops => 3*N/8
-       ...
-       N/x nodes need log(x) hops => log2(x)*N/x
-       Total cost for all N nodes : sum[i=1..N](log2(i)*N/i) = N*sum[i=1..N](log2(i)/i)
-       Average cost across N nodes = total / N = sum[i=1..N](log2(i)/i) = 2
-
-   This design is currently limited to only two branches per node. Most of the
-   tree descent algorithm would be compatible with more branches (eg: 4, to cut
-   the height in half), but this would probably require more complex operations
-   and the deletion algorithm would be problematic.
-
-   Useful properties :
-     - a node is always added above the leaf it is tied to, and never can get
-       below nor in another branch. This implies that leaves directly attached
-       to the root do not use their node part, which is indicated by a NULL
-       value in node_p. This also enhances the cache efficiency when walking
-       down the tree, because when the leaf is reached, its node part will
-       already have been visited (unless it's the first leaf in the tree).
-
-     - pointers to lower nodes or leaves are stored in "branch" pointers. Only
-       the root node may have a NULL in either branch, it is not possible for
-       other branches. Since the nodes are attached to the left branch of the
-       root, it is not possible to see a NULL left branch when walking up a
-       tree. Thus, an empty tree is immediately identified by a NULL left
-       branch at the root. Conversely, the one and only way to identify the
-       root node is to check that it right branch is NULL. Note that the
-       NULL pointer may have a few low-order bits set.
-
-     - a node connected to its own leaf will have branch[0|1] pointing to
-       itself, and leaf_p pointing to itself.
-
-     - a node can never have node_p pointing to itself.
-
-     - a node is linked in a tree if and only if it has a non-null leaf_p.
-
-     - a node can never have both branches equal, except for the root which can
-       have them both NULL.
-
-     - deletion only applies to leaves. When a leaf is deleted, its parent must
-       be released too (unless it's the root), and its sibling must attach to
-       the grand-parent, replacing the parent. Also, when a leaf is deleted,
-       the node tied to this leaf will be removed and must be released too. If
-       this node is different from the leaf's parent, the freshly released
-       leaf's parent will be used to replace the node which must go. A released
-       node will never be used anymore, so there's no point in tracking it.
-
-     - the bit index in a node indicates the bit position in the key which is
-       represented by the branches. That means that a node with (bit == 0) is
-       just above two leaves. Negative bit values are used to build a duplicate
-       tree. The first node above two identical leaves gets (bit == -1). This
-       value logarithmically decreases as the duplicate tree grows. During
-       duplicate insertion, a node is inserted above the highest bit value (the
-       lowest absolute value) in the tree during the right-sided walk. If bit
-       -1 is not encountered (highest < -1), we insert above last leaf.
-       Otherwise, we insert above the node with the highest value which was not
-       equal to the one of its parent + 1.
-
-     - the "eb_next" primitive walks from left to right, which means from lower
-       to higher keys. It returns duplicates in the order they were inserted.
-       The "eb_first" primitive returns the left-most entry.
-
-     - the "eb_prev" primitive walks from right to left, which means from
-       higher to lower keys. It returns duplicates in the opposite order they
-       were inserted. The "eb_last" primitive returns the right-most entry.
-
-     - a tree which has 1 in the lower bit of its root's right branch is a
-       tree with unique nodes. This means that when a node is inserted with
-       a key which already exists will not be inserted, and the previous
-       entry will be returned.
-
- */
-
-#ifndef _EBTREE_H
-#define _EBTREE_H
-
-#include <stdlib.h>
-#include "compiler.h"
-
-static inline int flsnz8_generic(unsigned int x)
-{
-	int ret = 0;
-	if (x >> 4) { x >>= 4; ret += 4; }
-	return ret + ((0xFFFFAA50U >> (x << 1)) & 3) + 1;
-}
-
-/* Note: we never need to run fls on null keys, so we can optimize the fls
- * function by removing a conditional jump.
- */
-#if defined(__i386__) || defined(__x86_64__)
-/* this code is similar on 32 and 64 bit */
-static inline int flsnz(int x)
-{
-	int r;
-	__asm__("bsrl %1,%0\n"
-	        : "=r" (r) : "rm" (x));
-	return r+1;
-}
-
-static inline int flsnz8(unsigned char x)
-{
-	int r;
-	__asm__("movzbl %%al, %%eax\n"
-		"bsrl %%eax,%0\n"
-	        : "=r" (r) : "a" (x));
-	return r+1;
-}
-
-#else
-// returns 1 to 32 for 1<<0 to 1<<31. Undefined for 0.
-#define flsnz(___a) ({ \
-	register int ___x, ___bits = 0; \
-	___x = (___a); \
-	if (___x & 0xffff0000) { ___x &= 0xffff0000; ___bits += 16;} \
-	if (___x & 0xff00ff00) { ___x &= 0xff00ff00; ___bits +=  8;} \
-	if (___x & 0xf0f0f0f0) { ___x &= 0xf0f0f0f0; ___bits +=  4;} \
-	if (___x & 0xcccccccc) { ___x &= 0xcccccccc; ___bits +=  2;} \
-	if (___x & 0xaaaaaaaa) { ___x &= 0xaaaaaaaa; ___bits +=  1;} \
-	___bits + 1; \
-	})
-
-static inline int flsnz8(unsigned int x)
-{
-	return flsnz8_generic(x);
-}
-
-
-#endif
-
-static inline int fls64(unsigned long long x)
-{
-	unsigned int h;
-	unsigned int bits = 32;
-
-	h = x >> 32;
-	if (!h) {
-		h = x;
-		bits = 0;
-	}
-	return flsnz(h) + bits;
-}
-
-#define fls_auto(x) ((sizeof(x) > 4) ? fls64(x) : flsnz(x))
-
-/* Linux-like "container_of". It returns a pointer to the structure of type
- * <type> which has its member <name> stored at address <ptr>.
- */
-#ifndef container_of
-#define container_of(ptr, type, name) ((type *)(((void *)(ptr)) - ((long)&((type *)0)->name)))
-#endif
-
-/* Number of bits per node, and number of leaves per node */
-#define EB_NODE_BITS          1
-#define EB_NODE_BRANCHES      (1 << EB_NODE_BITS)
-#define EB_NODE_BRANCH_MASK   (EB_NODE_BRANCHES - 1)
-
-/* Be careful not to tweak those values. The walking code is optimized for NULL
- * detection on the assumption that the following values are intact.
- */
-#define EB_LEFT     0
-#define EB_RGHT     1
-#define EB_LEAF     0
-#define EB_NODE     1
-
-/* Tags to set in root->b[EB_RGHT] :
- * - EB_NORMAL is a normal tree which stores duplicate keys.
- * - EB_UNIQUE is a tree which stores unique keys.
- */
-#define EB_NORMAL   0
-#define EB_UNIQUE   1
-
-/* This is the same as an eb_node pointer, except that the lower bit embeds
- * a tag. See eb_dotag()/eb_untag()/eb_gettag(). This tag has two meanings :
- *  - 0=left, 1=right to designate the parent's branch for leaf_p/node_p
- *  - 0=link, 1=leaf  to designate the branch's type for branch[]
- */
-typedef void eb_troot_t;
-
-/* The eb_root connects the node which contains it, to two nodes below it, one
- * of which may be the same node. At the top of the tree, we use an eb_root
- * too, which always has its right branch NULL (+/1 low-order bits).
- */
-struct eb_root {
-	eb_troot_t    *b[EB_NODE_BRANCHES]; /* left and right branches */
-};
-
-/* The eb_node contains the two parts, one for the leaf, which always exists,
- * and one for the node, which remains unused in the very first node inserted
- * into the tree. This structure is 20 bytes per node on 32-bit machines. Do
- * not change the order, benchmarks have shown that it's optimal this way.
- */
-struct eb_node {
-	struct eb_root branches; /* branches, must be at the beginning */
-	eb_troot_t    *node_p;  /* link node's parent */
-	eb_troot_t    *leaf_p;  /* leaf node's parent */
-	short int      bit;     /* link's bit position. */
-	short unsigned int pfx; /* data prefix length, always related to leaf */
-};
-
-/* Return the structure of type <type> whose member <member> points to <ptr> */
-#define eb_entry(ptr, type, member) container_of(ptr, type, member)
-
-/* The root of a tree is an eb_root initialized with both pointers NULL.
- * During its life, only the left pointer will change. The right one will
- * always remain NULL, which is the way we detect it.
- */
-#define EB_ROOT						\
-	(struct eb_root) {				\
-		.b = {[0] = NULL, [1] = NULL },		\
-	}
-
-#define EB_ROOT_UNIQUE					\
-	(struct eb_root) {				\
-		.b = {[0] = NULL, [1] = (void *)1 },	\
-	}
-
-#define EB_TREE_HEAD(name)				\
-	struct eb_root name = EB_ROOT
-
-
-/***************************************\
- * Private functions. Not for end-user *
-\***************************************/
-
-/* Converts a root pointer to its equivalent eb_troot_t pointer,
- * ready to be stored in ->branch[], leaf_p or node_p. NULL is not
- * conserved. To be used with EB_LEAF, EB_NODE, EB_LEFT or EB_RGHT in <tag>.
- */
-static inline eb_troot_t *eb_dotag(const struct eb_root *root, const int tag)
-{
-	return (eb_troot_t *)((void *)root + tag);
-}
-
-/* Converts an eb_troot_t pointer pointer to its equivalent eb_root pointer,
- * for use with pointers from ->branch[], leaf_p or node_p. NULL is conserved
- * as long as the tree is not corrupted. To be used with EB_LEAF, EB_NODE,
- * EB_LEFT or EB_RGHT in <tag>.
- */
-static inline struct eb_root *eb_untag(const eb_troot_t *troot, const int tag)
-{
-	return (struct eb_root *)((void *)troot - tag);
-}
-
-/* returns the tag associated with an eb_troot_t pointer */
-static inline int eb_gettag(eb_troot_t *troot)
-{
-	return (unsigned long)troot & 1;
-}
-
-/* Converts a root pointer to its equivalent eb_troot_t pointer and clears the
- * tag, no matter what its value was.
- */
-static inline struct eb_root *eb_clrtag(const eb_troot_t *troot)
-{
-	return (struct eb_root *)((unsigned long)troot & ~1UL);
-}
-
-/* Returns a pointer to the eb_node holding <root> */
-static inline struct eb_node *eb_root_to_node(struct eb_root *root)
-{
-	return container_of(root, struct eb_node, branches);
-}
-
-/* Walks down starting at root pointer <start>, and always walking on side
- * <side>. It either returns the node hosting the first leaf on that side,
- * or NULL if no leaf is found. <start> may either be NULL or a branch pointer.
- * The pointer to the leaf (or NULL) is returned.
- */
-static inline struct eb_node *eb_walk_down(eb_troot_t *start, unsigned int side)
-{
-	/* A NULL pointer on an empty tree root will be returned as-is */
-	while (eb_gettag(start) == EB_NODE)
-		start = (eb_untag(start, EB_NODE))->b[side];
-	/* NULL is left untouched (root==eb_node, EB_LEAF==0) */
-	return eb_root_to_node(eb_untag(start, EB_LEAF));
-}
-
-/* This function is used to build a tree of duplicates by adding a new node to
- * a subtree of at least 2 entries. It will probably never be needed inlined,
- * and it is not for end-user.
- */
-static forceinline struct eb_node *
-__eb_insert_dup(struct eb_node *sub, struct eb_node *new)
-{
-	struct eb_node *head = sub;
-	
-	eb_troot_t *new_left = eb_dotag(&new->branches, EB_LEFT);
-	eb_troot_t *new_rght = eb_dotag(&new->branches, EB_RGHT);
-	eb_troot_t *new_leaf = eb_dotag(&new->branches, EB_LEAF);
-
-	/* first, identify the deepest hole on the right branch */
-	while (eb_gettag(head->branches.b[EB_RGHT]) != EB_LEAF) {
-		struct eb_node *last = head;
-		head = container_of(eb_untag(head->branches.b[EB_RGHT], EB_NODE),
-				    struct eb_node, branches);
-		if (head->bit > last->bit + 1)
-			sub = head;     /* there's a hole here */
-	}
-
-	/* Here we have a leaf attached to (head)->b[EB_RGHT] */
-	if (head->bit < -1) {
-		/* A hole exists just before the leaf, we insert there */
-		new->bit = -1;
-		sub = container_of(eb_untag(head->branches.b[EB_RGHT], EB_LEAF),
-				   struct eb_node, branches);
-		head->branches.b[EB_RGHT] = eb_dotag(&new->branches, EB_NODE);
-
-		new->node_p = sub->leaf_p;
-		new->leaf_p = new_rght;
-		sub->leaf_p = new_left;
-		new->branches.b[EB_LEFT] = eb_dotag(&sub->branches, EB_LEAF);
-		new->branches.b[EB_RGHT] = new_leaf;
-		return new;
-	} else {
-		int side;
-		/* No hole was found before a leaf. We have to insert above
-		 * <sub>. Note that we cannot be certain that <sub> is attached
-		 * to the right of its parent, as this is only true if <sub>
-		 * is inside the dup tree, not at the head.
-		 */
-		new->bit = sub->bit - 1; /* install at the lowest level */
-		side = eb_gettag(sub->node_p);
-		head = container_of(eb_untag(sub->node_p, side), struct eb_node, branches);
-		head->branches.b[side] = eb_dotag(&new->branches, EB_NODE);
-					
-		new->node_p = sub->node_p;
-		new->leaf_p = new_rght;
-		sub->node_p = new_left;
-		new->branches.b[EB_LEFT] = eb_dotag(&sub->branches, EB_NODE);
-		new->branches.b[EB_RGHT] = new_leaf;
-		return new;
-	}
-}
-
-
-/**************************************\
- * Public functions, for the end-user *
-\**************************************/
-
-/* Return non-zero if the tree is empty, otherwise zero */
-static inline int eb_is_empty(struct eb_root *root)
-{
-	return !root->b[EB_LEFT];
-}
-
-/* Return the first leaf in the tree starting at <root>, or NULL if none */
-static inline struct eb_node *eb_first(struct eb_root *root)
-{
-	return eb_walk_down(root->b[0], EB_LEFT);
-}
-
-/* Return the last leaf in the tree starting at <root>, or NULL if none */
-static inline struct eb_node *eb_last(struct eb_root *root)
-{
-	return eb_walk_down(root->b[0], EB_RGHT);
-}
-
-/* Return previous leaf node before an existing leaf node, or NULL if none. */
-static inline struct eb_node *eb_prev(struct eb_node *node)
-{
-	eb_troot_t *t = node->leaf_p;
-
-	while (eb_gettag(t) == EB_LEFT) {
-		/* Walking up from left branch. We must ensure that we never
-		 * walk beyond root.
-		 */
-		if (unlikely(eb_clrtag((eb_untag(t, EB_LEFT))->b[EB_RGHT]) == NULL))
-			return NULL;
-		t = (eb_root_to_node(eb_untag(t, EB_LEFT)))->node_p;
-	}
-	/* Note that <t> cannot be NULL at this stage */
-	t = (eb_untag(t, EB_RGHT))->b[EB_LEFT];
-	return eb_walk_down(t, EB_RGHT);
-}
-
-/* Return next leaf node after an existing leaf node, or NULL if none. */
-static inline struct eb_node *eb_next(struct eb_node *node)
-{
-	eb_troot_t *t = node->leaf_p;
-
-	while (eb_gettag(t) != EB_LEFT)
-		/* Walking up from right branch, so we cannot be below root */
-		t = (eb_root_to_node(eb_untag(t, EB_RGHT)))->node_p;
-
-	/* Note that <t> cannot be NULL at this stage */
-	t = (eb_untag(t, EB_LEFT))->b[EB_RGHT];
-	if (eb_clrtag(t) == NULL)
-		return NULL;
-	return eb_walk_down(t, EB_LEFT);
-}
-
-/* Return previous leaf node before an existing leaf node, skipping duplicates,
- * or NULL if none. */
-static inline struct eb_node *eb_prev_unique(struct eb_node *node)
-{
-	eb_troot_t *t = node->leaf_p;
-
-	while (1) {
-		if (eb_gettag(t) != EB_LEFT) {
-			node = eb_root_to_node(eb_untag(t, EB_RGHT));
-			/* if we're right and not in duplicates, stop here */
-			if (node->bit >= 0)
-				break;
-			t = node->node_p;
-		}
-		else {
-			/* Walking up from left branch. We must ensure that we never
-			 * walk beyond root.
-			 */
-			if (unlikely(eb_clrtag((eb_untag(t, EB_LEFT))->b[EB_RGHT]) == NULL))
-				return NULL;
-			t = (eb_root_to_node(eb_untag(t, EB_LEFT)))->node_p;
-		}
-	}
-	/* Note that <t> cannot be NULL at this stage */
-	t = (eb_untag(t, EB_RGHT))->b[EB_LEFT];
-	return eb_walk_down(t, EB_RGHT);
-}
-
-/* Return next leaf node after an existing leaf node, skipping duplicates, or
- * NULL if none.
- */
-static inline struct eb_node *eb_next_unique(struct eb_node *node)
-{
-	eb_troot_t *t = node->leaf_p;
-
-	while (1) {
-		if (eb_gettag(t) == EB_LEFT) {
-			if (unlikely(eb_clrtag((eb_untag(t, EB_LEFT))->b[EB_RGHT]) == NULL))
-				return NULL;	/* we reached root */
-			node = eb_root_to_node(eb_untag(t, EB_LEFT));
-			/* if we're left and not in duplicates, stop here */
-			if (node->bit >= 0)
-				break;
-			t = node->node_p;
-		}
-		else {
-			/* Walking up from right branch, so we cannot be below root */
-			t = (eb_root_to_node(eb_untag(t, EB_RGHT)))->node_p;
-		}
-	}
-
-	/* Note that <t> cannot be NULL at this stage */
-	t = (eb_untag(t, EB_LEFT))->b[EB_RGHT];
-	if (eb_clrtag(t) == NULL)
-		return NULL;
-	return eb_walk_down(t, EB_LEFT);
-}
-
-
-/* Removes a leaf node from the tree if it was still in it. Marks the node
- * as unlinked.
- */
-static forceinline void __eb_delete(struct eb_node *node)
-{
-	__label__ delete_unlink;
-	unsigned int pside, gpside, sibtype;
-	struct eb_node *parent;
-	struct eb_root *gparent;
-
-	if (!node->leaf_p)
-		return;
-
-	/* we need the parent, our side, and the grand parent */
-	pside = eb_gettag(node->leaf_p);
-	parent = eb_root_to_node(eb_untag(node->leaf_p, pside));
-
-	/* We likely have to release the parent link, unless it's the root,
-	 * in which case we only set our branch to NULL. Note that we can
-	 * only be attached to the root by its left branch.
-	 */
-
-	if (eb_clrtag(parent->branches.b[EB_RGHT]) == NULL) {
-		/* we're just below the root, it's trivial. */
-		parent->branches.b[EB_LEFT] = NULL;
-		goto delete_unlink;
-	}
-
-	/* To release our parent, we have to identify our sibling, and reparent
-	 * it directly to/from the grand parent. Note that the sibling can
-	 * either be a link or a leaf.
-	 */
-
-	gpside = eb_gettag(parent->node_p);
-	gparent = eb_untag(parent->node_p, gpside);
-
-	gparent->b[gpside] = parent->branches.b[!pside];
-	sibtype = eb_gettag(gparent->b[gpside]);
-
-	if (sibtype == EB_LEAF) {
-		eb_root_to_node(eb_untag(gparent->b[gpside], EB_LEAF))->leaf_p =
-			eb_dotag(gparent, gpside);
-	} else {
-		eb_root_to_node(eb_untag(gparent->b[gpside], EB_NODE))->node_p =
-			eb_dotag(gparent, gpside);
-	}
-	/* Mark the parent unused. Note that we do not check if the parent is
-	 * our own node, but that's not a problem because if it is, it will be
-	 * marked unused at the same time, which we'll use below to know we can
-	 * safely remove it.
-	 */
-	parent->node_p = NULL;
-
-	/* The parent node has been detached, and is currently unused. It may
-	 * belong to another node, so we cannot remove it that way. Also, our
-	 * own node part might still be used. so we can use this spare node
-	 * to replace ours if needed.
-	 */
-
-	/* If our link part is unused, we can safely exit now */
-	if (!node->node_p)
-		goto delete_unlink;
-
-	/* From now on, <node> and <parent> are necessarily different, and the
-	 * <node>'s node part is in use. By definition, <parent> is at least
-	 * below <node>, so keeping its key for the bit string is OK.
-	 */
-
-	parent->node_p = node->node_p;
-	parent->branches = node->branches;
-	parent->bit = node->bit;
-
-	/* We must now update the new node's parent... */
-	gpside = eb_gettag(parent->node_p);
-	gparent = eb_untag(parent->node_p, gpside);
-	gparent->b[gpside] = eb_dotag(&parent->branches, EB_NODE);
-
-	/* ... and its branches */
-	for (pside = 0; pside <= 1; pside++) {
-		if (eb_gettag(parent->branches.b[pside]) == EB_NODE) {
-			eb_root_to_node(eb_untag(parent->branches.b[pside], EB_NODE))->node_p =
-				eb_dotag(&parent->branches, pside);
-		} else {
-			eb_root_to_node(eb_untag(parent->branches.b[pside], EB_LEAF))->leaf_p =
-				eb_dotag(&parent->branches, pside);
-		}
-	}
- delete_unlink:
-	/* Now the node has been completely unlinked */
-	node->leaf_p = NULL;
-	return; /* tree is not empty yet */
-}
-
-/* Compare blocks <a> and <b> byte-to-byte, from bit <ignore> to bit <len-1>.
- * Return the number of equal bits between strings, assuming that the first
- * <ignore> bits are already identical. It is possible to return slightly more
- * than <len> bits if <len> does not stop on a byte boundary and we find exact
- * bytes. Note that parts or all of <ignore> bits may be rechecked. It is only
- * passed here as a hint to speed up the check.
- */
-static forceinline int equal_bits(const unsigned char *a,
-				  const unsigned char *b,
-				  int ignore, int len)
-{
-	for (ignore >>= 3, a += ignore, b += ignore, ignore <<= 3;
-	     ignore < len; ) {
-		unsigned char c;
-
-		a++; b++;
-		ignore += 8;
-		c = b[-1] ^ a[-1];
-
-		if (c) {
-			/* OK now we know that old and new differ at byte <ptr> and that <c> holds
-			 * the bit differences. We have to find what bit is differing and report
-			 * it as the number of identical bits. Note that low bit numbers are
-			 * assigned to high positions in the byte, as we compare them as strings.
-			 */
-			ignore -= flsnz8(c);
-			break;
-		}
-	}
-	return ignore;
-}
-
-/* check that the two blocks <a> and <b> are equal on <len> bits. If it is known
- * they already are on some bytes, this number of equal bytes to be skipped may
- * be passed in <skip>. It returns 0 if they match, otherwise non-zero.
- */
-static forceinline int check_bits(const unsigned char *a,
-				  const unsigned char *b,
-				  int skip,
-				  int len)
-{
-	int bit, ret;
-
-	/* This uncommon construction gives the best performance on x86 because
-	 * it makes heavy use multiple-index addressing and parallel instructions,
-	 * and it prevents gcc from reordering the loop since it is already
-	 * properly oriented. Tested to be fine with 2.95 to 4.2.
-	 */
-	bit = ~len + (skip << 3) + 9; // = (skip << 3) + (8 - len)
-	ret = a[skip] ^ b[skip];
-	if (unlikely(bit >= 0))
-		return ret >> bit;
-	while (1) {
-		skip++;
-		if (ret)
-			return ret;
-		ret = a[skip] ^ b[skip];
-		bit += 8;
-		if (bit >= 0)
-			return ret >> bit;
-	}
-}
-
-
-/* Compare strings <a> and <b> byte-to-byte, from bit <ignore> to the last 0.
- * Return the number of equal bits between strings, assuming that the first
- * <ignore> bits are already identical. Note that parts or all of <ignore> bits
- * may be rechecked. It is only passed here as a hint to speed up the check.
- * The caller is responsible for not passing an <ignore> value larger than any
- * of the two strings. However, referencing any bit from the trailing zero is
- * permitted. Equal strings are reported as a negative number of bits, which
- * indicates the end was reached.
- */
-static forceinline int string_equal_bits(const unsigned char *a,
-					 const unsigned char *b,
-					 int ignore)
-{
-	int beg;
-	unsigned char c;
-
-	beg = ignore >> 3;
-
-	/* skip known and identical bits. We stop at the first different byte
-	 * or at the first zero we encounter on either side.
-	 */
-	while (1) {
-		unsigned char d;
-
-		c = a[beg];
-		d = b[beg];
-		beg++;
-
-		c ^= d;
-		if (c)
-			break;
-		if (!d)
-			return -1;
-	}
-	/* OK now we know that a and b differ at byte <beg>, or that both are zero.
-	 * We have to find what bit is differing and report it as the number of
-	 * identical bits. Note that low bit numbers are assigned to high positions
-	 * in the byte, as we compare them as strings.
-	 */
-	return (beg << 3) - flsnz8(c);
-}
-
-static forceinline int cmp_bits(const unsigned char *a, const unsigned char *b, unsigned int pos)
-{
-	unsigned int ofs;
-	unsigned char bit_a, bit_b;
-
-	ofs = pos >> 3;
-	pos = ~pos & 7;
-
-	bit_a = (a[ofs] >> pos) & 1;
-	bit_b = (b[ofs] >> pos) & 1;
-
-	return bit_a - bit_b; /* -1: a<b; 0: a=b; 1: a>b */
-}
-
-static forceinline int get_bit(const unsigned char *a, unsigned int pos)
-{
-	unsigned int ofs;
-
-	ofs = pos >> 3;
-	pos = ~pos & 7;
-	return (a[ofs] >> pos) & 1;
-}
-
-/* These functions are declared in ebtree.c */
-void eb_delete(struct eb_node *node);
-REGPRM1 struct eb_node *eb_insert_dup(struct eb_node *sub, struct eb_node *new);
-
-#endif /* _EB_TREE_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/examples/acl-content-sw.cfg b/deps/haproxy-1.4.21/examples/acl-content-sw.cfg
deleted file mode 100644
index 1872789..0000000
--- a/deps/haproxy-1.4.21/examples/acl-content-sw.cfg
+++ /dev/null
@@ -1,130 +0,0 @@
-# This sample configuration makes extensive use of the ACLs. It requires
-# HAProxy version 1.3.12 minimum.
-
-global
-	log	   loghost   local0
-	log	   localhost local0 err
-	maxconn	   250
-	uid	   71
-	gid	   71
-	chroot	   /var/empty
-	pidfile	   /var/run/haproxy.pid
-	daemon
-	quiet
-
-frontend http-in
-	bind       :80
-	mode       http
-	log        global
-	clitimeout 30000
-	option     httplog
-	option     dontlognull
-	#option    logasap
-	option     httpclose
-	maxconn    100
-
-	capture request  header Host           len 20
-	capture request  header User-Agent     len 16
-	capture request  header Content-Length len 10
-	capture request  header Referer        len 20
-	capture response header Content-Length len 10
-
-	# block any unwanted source IP addresses or networks
-	acl forbidden_src src      0.0.0.0/7 224.0.0.0/3
-	acl forbidden_src src_port 0:1023
-	block if forbidden_src
-
-	# block requests beginning with http:// on wrong domains
-	acl dangerous_pfx  url_beg -i  http://
-	acl valid_pfx      url_reg -i ^http://[^/]*1wt\.eu/
-	block if dangerous_pfx !valid_pfx
-
-	# block apache chunk exploit, ...
-	acl forbidden_hdrs hdr_sub(transfer-encoding) -i chunked
-	acl forbidden_hdrs hdr_beg(host)              -i apache- localhost
-
-	# ... some HTTP content smugling and other various things
-	acl forbidden_hdrs hdr_cnt(host) gt 1
-	acl forbidden_hdrs hdr_cnt(content-length) gt 1
-	acl forbidden_hdrs hdr_val(content-length) lt 0
-	acl forbidden_hdrs hdr_cnt(proxy-authorization) gt 0
-	block if forbidden_hdrs
-
-	# block annoying worms that fill the logs...
-	acl forbidden_uris url_reg -i .*(\.|%2e)(\.|%2e)(%2f|%5c|/|\\\\)
-	acl forbidden_uris url_sub -i %00 <script xmlrpc.php
-	acl forbidden_uris path_end -i /root.exe /cmd.exe /default.ida /awstats.pl .asp .dll
-
-	# block other common attacks (awstats, manual discovery...)
-	acl forbidden_uris path_dir -i chat main.php read_dump.php viewtopic.php phpbb sumthin horde _vti_bin MSOffice
-	acl forbidden_uris url_reg -i (\.php\?temppath=|\.php\?setmodules=|[=:]http://)
-	block if forbidden_uris
-
-	# we rewrite the "options" request so that it only tries '*', and we
-	# only report GET, HEAD, POST and OPTIONS as valid methods
-	reqirep		^OPTIONS\ /.*HTTP/1\.[01]$ OPTIONS\ \\*\ HTTP/1.0
-	rspirep		^Allow:\ .* Allow:\ GET,\ HEAD,\ POST,\ OPTIONS
-
-	acl host_demo   hdr_beg(host) -i demo.
-	acl host_www2   hdr_beg(host) -i www2.
-
-	use_backend	demo   if host_demo
-	use_backend	www2   if host_www2
-	default_backend	www
-
-backend www
-	mode	http
-	source	192.168.21.2:0
-	balance roundrobin
-	cookie SERVERID
-	server www1 192.168.12.2:80 check inter 30000 rise 2 fall 3 maxconn 10
-	server back 192.168.11.2:80 check inter 30000 rise 2 fall 5 backup cookie back maxconn 8
-
-	# long timeout to support connection queueing
-	contimeout	20000
-	srvtimeout	20000
-	fullconn 100
-	redispatch
-	retries	3
-
-	option httpchk HEAD /
-	option forwardfor
-	option checkcache
-	option httpclose
-
-	# allow other syntactically valid requests, and block any other method
-        acl valid_method method GET HEAD POST OPTIONS
-        block if !valid_method
-        block if HTTP_URL_STAR !METH_OPTIONS
-        block if !HTTP_URL_SLASH !HTTP_URL_STAR !HTTP_URL_ABS
-
-	# remove unnecessary precisions on the server version. Let's say
-	# it's an apache under Unix on the Formilux Distro.
-	rspidel		^Server:\ 
-	rspadd		Server:\ Apache\ (Unix;\ Formilux/0.1.8)
-
-defaults non_standard_bck
-	mode	http
-	source	192.168.21.2:0
-	option forwardfor
-	option httpclose
-	balance roundrobin
-	fullconn 100
-	contimeout	20000
-	srvtimeout	20000
-	retries	2
-
-backend www2
-	server www2 192.168.22.2:80 maxconn 10
-
-# end of defaults
-defaults none
-
-backend demo
-	mode http
-	balance roundrobin
-	stats enable
-	stats uri /
-	stats scope http-in
-	stats scope www
-	stats scope demo
diff --git a/deps/haproxy-1.4.21/examples/auth.cfg b/deps/haproxy-1.4.21/examples/auth.cfg
deleted file mode 100644
index 08d0034..0000000
--- a/deps/haproxy-1.4.21/examples/auth.cfg
+++ /dev/null
@@ -1,134 +0,0 @@
-global
-#	chroot /var/empty/
-#	uid 451
-#	gid 451
-	log 192.168.131.214:8514 local4 debug
-	maxconn 8192
-
-defaults
-	timeout connect		3500
-	timeout queue		11000
-	timeout tarpit		12000
-	timeout client		30000
-	timeout http-request	40000
-	timeout http-keep-alive	5000
-	timeout server		40000
-	timeout check		7000
-
-	option	contstats
-	option	log-health-checks
-
-################################
-userlist customer1
-	group adm users tiger,xdb
-	group dev users scott,tiger
-	group uat users boss,xdb,tiger
-	user scott insecure-password cat
-	user tiger insecure-password dog
-	user xdb insecure-password hello
-	user boss password $6$k6y3o.eP$JlKBx9za966ud67qe45NSQYf8Nw.XFuk8QVRevoLh1XPCQDCBPjcU2JtGBSS0MOQW2PFxHSwRv6J.C0/D7cV91
-
-userlist customer1alt
-	group adm
-	group dev
-	group uat
-	user scott insecure-password cat groups dev
-	user tiger insecure-password dog groups adm,dev,uat
-	user xdb insecure-password hello groups adm,uat
-	user boss password $6$k6y3o.eP$JlKBx9za966ud67qe45NSQYf8Nw.XFuk8QVRevoLh1XPCQDCBPjcU2JtGBSS0MOQW2PFxHSwRv6J.C0/D7cV91 groups uat
-
-# Both customer1 and customer1alt userlist are functionally identical
-
-frontend c1
-	bind 127.101.128.1:8080
-	log global
-	mode http
-
-	acl host_stats	hdr_beg(host) -i stats.local
-	acl host_dev	hdr_beg(host) -i dev.local
-	acl host_uat	hdr_beg(host) -i uat.local
-
-	acl auth_uat	http_auth_group(customer1) uat
-
-	# auth for host_uat checked in frontend, use realm "uat"
-	http-request	auth realm uat if host_uat !auth_uat
-
-	use_backend	c1stats if host_stats
-	use_backend	c1dev	if host_dev
-	use_backend	c1uat	if host_uat
-
-backend c1uat
-	mode http
-	log global
-
-	server s6 192.168.152.206:80
-	server s7 192.168.152.207:80
-
-backend c1dev
-	mode http
-	log global
-
-	# require users from customer1 assigned to group dev
-	acl auth_ok	http_auth_group(customer1) dev
-
-	# auth checked in backend, use default realm (c1dev)
-	http-request auth if !auth_ok
-
-	server s6 192.168.152.206:80
-	server s7 192.168.152.207:80
-
-backend c1stats
-	mode http
-	log global
-
-	# stats auth checked in backend, use default realm (Stats)
-	acl nagios	src 192.168.126.31
-	acl guests	src 192.168.162.0/24
-	acl auth_ok	http_auth_group(customer1) adm
-
-	stats enable
-	stats refresh 60
-	stats uri /
-	stats scope c1
-	stats scope c1stats
-
-	# unconditionally deny guests, without checking auth or asking for a username/password
-	stats http-request deny if guests
-
-	# allow nagios without password, allow authenticated users
-	stats http-request allow if nagios
-	stats http-request allow if auth_ok
-
-	# ask for a username/password
-	stats http-request auth realm Stats
-
-
-################################
-userlist customer2
-	user peter insecure-password peter
-	user monica insecure-password monica
-
-frontend c2
-	bind 127.201.128.1:8080
-	log global
-	mode http
-
-	acl auth_ok http_auth(customer2)
-	acl host_b1 hdr(host) -i b1.local
-
-	http-request auth unless auth_ok
-
-	use_backend	c2b1 if host_b1
-	default_backend	c2b0
-
-backend c2b1
-	mode http
-	log global
-
-	server s1 192.168.152.201:80
-
-backend c2b0
-	mode http
-	log global
-
-	server s1 192.168.152.201:80
diff --git a/deps/haproxy-1.4.21/examples/build.cfg b/deps/haproxy-1.4.21/examples/build.cfg
deleted file mode 100644
index 2dd7527..0000000
--- a/deps/haproxy-1.4.21/examples/build.cfg
+++ /dev/null
@@ -1,25 +0,0 @@
-#!/bin/sh
-
-# build script for formilux >0.1.8
-
-PATCH_LIST=
-FILE_LIST=
-
-function do_compile_only {
-    $FLXMAKE CPU_OPTS="-march=$arch -mcpu=$cpu -Os -mpreferred-stack-boundary=2 -momit-leaf-frame-pointer -malign-jumps=0" \
-	     TARGET=linux24
-}
-
-function do_prepack {
-    mkdir -p $ROOTDIR/sbin/init.d ; cp examples/init.haproxy.flx0 $ROOTDIR/sbin/init.d/haproxy
-    mkdir -p $ROOTDIR/usr/sbin ; cp haproxy $ROOTDIR/usr/sbin
-    mkdir -p $ROOTDIR/usr/share/examples/$PKGRADIX/$PKGRADIX-$PKGVER/etc/haproxy/
-    cp examples/haproxy.cfg $ROOTDIR/usr/share/examples/$PKGRADIX/$PKGRADIX-$PKGVER/etc/haproxy/haproxy.cfg
-    cp examples/rc.highsock $ROOTDIR/usr/share/examples/$PKGRADIX/$PKGRADIX-$PKGVER/etc/rc.highsock
-    cp examples/config.rc.haproxy $ROOTDIR/usr/share/examples/$PKGRADIX/$PKGRADIX-$PKGVER/etc/config.rc.haproxy
-    mkdir -p $ROOTDIR/usr/share/$PKGRADIX/$PKGRADIX-$PKGVER
-    cp doc/haproxy.txt $ROOTDIR/usr/share/$PKGRADIX/$PKGRADIX-$PKGVER
-    ln -s ../../examples/$PKGRADIX/$PKGRADIX-$PKGVER $ROOTDIR/usr/share/$PKGRADIX/$PKGRADIX-$PKGVER/examples
-    cp examples/debug2ansi examples/debug2html examples/debugfind $ROOTDIR/usr/share/$PKGRADIX/$PKGRADIX-$PKGVER/
-    set_default_perm $ROOTDIR
-}
diff --git a/deps/haproxy-1.4.21/examples/check b/deps/haproxy-1.4.21/examples/check
deleted file mode 100755
index d7e01d2..0000000
--- a/deps/haproxy-1.4.21/examples/check
+++ /dev/null
@@ -1,540 +0,0 @@
-#!/usr/bin/perl
-###################################################################################################################
-# $Id:: check 20 2007-02-23 14:26:44Z fabrice                     $
-# $Revision:: 20                                                  $
-###################################################################################################################
-# Authors : Fabrice Dulaunoy <fabrice@dulaunoy.com>
-#
-# Copyright (C) 2006-2007 Fabrice Dulaunoy <fabrice@dulaunoy.com>
-#
-# This program is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the
-# Free Software Foundation; either version 2 of the License, or (at your
-# option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
-#
-# This program is distributed in the hope that it will be useful, but
-# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# for more details.
-###################################################################################################################
-#
-###################################################################################################################
-
-use strict;
-
-package MyPackage;
-use Config::General;
-use Getopt::Std;
-use LWP::UserAgent;
-use URI;
-use File::Basename;
-
-# CVS VSERSION
-#my $VERSION = do { my @rev = ( q$Revision: 20 $ =~ /\d+/g ); sprintf "%d." . "%d" x $#rev, @rev };
-# SVN VERSION
-my $VERSION = sprintf "1.%02d", '$Revision: 20 $ ' =~ /(\d+)/;
-
-my %option;
-
-getopts( "vHhc:", \%option );
-
-if ( $option{ h } )
-{
-    print "Usage: $0 [options ...]\n\n";
-    print "Where options include:\n";
-    print "\t -h \t\t\tthis help (what else ?)\n";
-    print "\t -H \t\t\tshow a sample config file\n";
-    print "\t -v \t\t\tprint version and exit\n";
-    print "\t -c file \t\tuse config file (default /etc/check.conf)\n";
-    print "\n\t This is a small program parsing the config file \n";
-    print "\t and checking one or more condition on one or more  servers\n";
-    print "\t these condition could be \n";
-    print "\t\t HTTP return code list (with optinal Host Header and optional Basic Authentication) \n";
-    print "\t\t a regex over a HTTP GET  (with optinal Host Header and optional Basic Authentication)\n";
-    print "\t\t a regex over a FTP GET ( with optional Basic Authentication)\n";
-    print "\t\t a TCP open port\n";
-    print "\t the result state is an AND over all tests  \n";
-    print "\t this result could be \n";
-    print "\t\t a simple HTTP return state  (\"200 OK\" or \"503 Service Unavailable\"  \n";
-    print "\t\t a HTML page with a status OK or NOK for each test\n";
-    print "\t\t a HTML page with a staus OK or NOK for each test in a row of a TABLE\n";
-    print "\n\t The natural complement of this tools is the poll_check tool\n";
-    print "\t The result code of this tools is designed to fit the HAPROXY requirement (test over a port not related to the WEB server)\n";
-}
-
-if ( $option{ H } )
-{
-    print "\t A sample config file could be:\n";
-    print <<'EOF';
-    
-			###########################################################
-			# listening port ( default 9898 )
-			port 9899
-			
-			# on which IP to bind (default 127.0.0.1 ) * = all IP
-			host 10.2.1.1
-			
-			# which client addr is allow ( default 127.0.0.0/8 )
-			#cidr_allow = 0.0.0.0/0 
-			
-			# verbosity from 0 to 4 (default 0 = no log )
-			log_level = 1
-			
-			# daemonize (default 0 = no )
-			daemon = 1
-			
-			# content put a HTML content after header
-			# (default 0 = no content 1 = html 2 = table )
-			content = 2
-			
-			# reparse the config file at each request ( default 0 = no )
-			# only SIGHUP reread the config file)
-			reparse = 1
-			
-			# pid_file  (default /var/run/check.pid )
-			# $$$ = basename of config file
-			# $$ = PID
-			pid_file=/var/run/CHECK_$$$.pid
-			
-			# log_file  (default /var/log/check.log )
-			# $$$ = basename of config file
-			# $$ = PID
-			log_file=/var/log/CHECK_$$$.log
-			
-			# number of servers to keep running (default = 5)
-			min_servers = 2
-			
-			# number of servers to have waiting for requests (default = 2)
-			min_spare_servers = 1
-			
-			# maximum number of servers to have waiting for requests (default = 10)
-			max_spare_servers =1
-			
-			# number of servers (default = 50)
-			max_servers = 2
-			
-   			
-			###########################################################
-			# a server to check
-			# type could be get , regex or tcp
-			#
-			# get = do a http or ftp get and check the result code with
-			# the list, coma separated, provided ( default = 200,201 )
-			# hostheader is optional and send to the server if provided
-			#
-			# regex = do a http or ftp get and check the content result 
-			# with regex provided
-			# hostheader is optional and send to the server if provided
-			#
-			# tcp = test if the tcp port provided is open
-			#
-			###########################################################
-			
-			<realserver>
-				url=http://127.0.0.1:80/apache2-default/index.html
-				type = get
-				code=200,201
-				hostheader = www.test.com
-			</realserver>
-			
-			
-			<realserver>
-				url=http://127.0.0.1:82/apache2-default/index.html
-				type = get
-				code=200,201
-				hostheader = www.myhost.com
-			</realserver>
-			
-			<realserver>
-				url=	 http://10.2.2.1
-				type = regex
-				regex= /qdAbm/
-			</realserver>
-			
-			<realserver>
-				type = tcp
-				url = 10.2.2.1
-				port =80
-			</realserver>
-			
-			<realserver>
-				type = get
-				url = ftp://USER:PASSWORD@10.2.3.1
-				code=200,201
-			</realserver>
-			###########################################################
-
-
-
-EOF
-
-}
-
-if ( $option{ h } || $option{ H } )
-{
-    exit;
-}
-
-if ( $option{ v } ) { print "$VERSION\n"; exit; }
-
-use vars qw(@ISA);
-use Net::Server::PreFork;
-@ISA = qw(Net::Server::PreFork);
-
-my $port;
-my $host;
-my $reparse;
-my $cidr_allow;
-my $log_level;
-my $log_file;
-my $pid_file;
-my $daemon;
-my $min_servers;
-my $min_spare_servers;
-my $max_spare_servers;
-my $max_servers;
-my $html_content;
-
-my $conf_file = $option{ c } || "/etc/check.conf";
-my $pwd = $ENV{ PWD };
-$conf_file =~ s/^\./$pwd/;
-$conf_file =~ s/^([^\/])/$pwd\/$1/;
-my $basename = basename( $conf_file, ( '.conf' ) );
-my $CONF = parse_conf( $conf_file );
-
-my $reparse_one = 0;
-
-$SIG{ HUP } = sub { $reparse_one = 1; };
-
-my @TEST;
-my $test_list = $CONF->{ realserver };
-if ( ref( $test_list ) eq "ARRAY" )
-{
-    @TEST = @{ $test_list };
-}
-else
-{
-    @TEST = ( $test_list );
-}
-
-my $server = MyPackage->new(
-    {
-        port                => $port,
-        host                => $host,
-        cidr_allow          => $cidr_allow,
-        log_level           => $log_level,
-        child_communication => 1,
-        setsid              => $daemon,
-        log_file            => $log_file,
-        pid_file            => $pid_file,
-        min_servers         => $min_servers,
-        min_spare_servers   => $min_spare_servers,
-        max_spare_servers   => $max_spare_servers,
-        max_servers         => $max_servers,
-    }
-);
-
-$server->run();
-exit;
-
-sub process_request
-{
-    my $self = shift;
-    if ( $reparse || $reparse_one )
-    {
-        $CONF = parse_conf( $conf_file );
-    }
-    my $result;
-    my @TEST;
-    my $test_list = $CONF->{ realserver };
-
-    if ( ref( $test_list ) eq "ARRAY" )
-    {
-        @TEST = @{ $test_list };
-    }
-    else
-    {
-        @TEST = ( $test_list );
-    }
-
-    my $allow_code;
-    my $test_item;
-    my $html_data;
-    foreach my $test ( @TEST )
-    {
-        my $uri;
-        my $authority;
-        my $URL = $test->{ url };
-        $uri       = URI->new( $URL );
-        $authority = $uri->authority;
-
-        if ( exists $test->{ type } )
-        {
-            if ( $test->{ type } =~ /get/i )
-            {
-                my $allow_code = $test->{ code } || '200,201';
-                $test_item++;
-                my $host = $test->{ hostheader } || $authority;
-                my $res = get( $URL, $allow_code, $host );
-                if ( $html_content == 1 )
-                {
-                    if ( $res )
-                    {
-                        $html_data .= "GET OK $URL<br>\r\n";
-                    }
-                    else
-                    {
-                        $html_data .= "GET NOK $URL<br>\r\n";
-                    }
-                }
-                if ( $html_content == 2 )
-                {
-                    if ( $res )
-                    {
-                        $html_data .= "<tr><td>GET</td><td>OK</td><td>$URL</td></tr>\r\n";
-                    }
-                    else
-                    {
-                        $html_data .= "<tr><td>GET</td><td>NOK</td><td>$URL</td></tr>\r\n";
-                    }
-                }
-                $result += $res;
-            }
-            if ( $test->{ type } =~ /regex/i )
-            {
-                my $regex = $test->{ regex };
-                $test_item++;
-                my $host = $test->{ hostheader } || $authority;
-                my $res = regex( $URL, $regex, $host );
-                if ( $html_content == 1 )
-                {
-                    if ( $res )
-                    {
-                        $html_data .= "REGEX OK $URL<br>\r\n";
-                    }
-                    else
-                    {
-                        $html_data .= "REGEX NOK $URL<br>\r\n";
-                    }
-                }
-                if ( $html_content == 2 )
-                {
-                    if ( $res )
-                    {
-                        $html_data .= "<tr><td>REGEX</td><td>OK</td><td>$URL</td></tr>\r\n";
-                    }
-                    else
-                    {
-                        $html_data .= "<tr><td>REGEX</td><td>NOK</td><td>$URL</td></tr>\r\n";
-                    }
-                }
-                $result += $res;
-            }
-            if ( $test->{ type } =~ /tcp/i )
-            {
-                $test_item++;
-                my $PORT = $test->{ port } || 80;
-                my $res = TCP( $URL, $PORT );
-                if ( $html_content == 1 )
-                {
-                    if ( $res )
-                    {
-                        $html_data .= "TCP OK  $URL<br>\r\n";
-                    }
-                    else
-                    {
-                        $html_data .= "TCP NOK $URL<br>\r\n";
-                    }
-                }
-                if ( $html_content == 2 )
-                {
-                    if ( $res )
-                    {
-                        $html_data .= "<tr><td>TCP</td><td>OK</td><td>$URL</td></tr>\r\n";
-                    }
-                    else
-                    {
-                        $html_data .= "<tr><td>TCP</td><td>NOK</td><td>$URL</td></tr>\r\n";
-                    }
-                }
-                $result += $res;
-            }
-        }
-    }
-
-    my $len;
-    if ( $html_content == 1 )
-    {
-        $html_data = "\r\n<html><body>\r\n$html_data</body></html>\r\n";
-        $len       = ( length( $html_data ) ) - 2;
-    }
-    if ( $html_content == 2 )
-    {
-        $html_data = "\r\n<table align='center' border='1' >\r\n$html_data</table>\r\n";
-        $len       = ( length( $html_data ) ) - 2;
-    }
-
-    if ( $result != $test_item )
-    {
-        my $header = "HTTP/1.0 503 Service Unavailable\r\n";
-        if ( $html_content )
-        {
-            $header .= "Content-Length: $len\r\nContent-Type: text/html; charset=iso-8859-1\r\n";
-        }
-        print $header . $html_data;
-        return;
-    }
-    my $header = "HTTP/1.0 200 OK\r\n";
-    if ( $html_content )
-    {
-        $header .= "Content-Length: $len\r\nContent-Type: text/html; charset=iso-8859-1\r\n";
-    }
-    print $header. $html_data;
-}
-
-1;
-
-##########################################################
-##########################################################
-# function to REGEX on a GET from URL
-#	arg: 	uri
-#		regex to test (with extra parameter like perl e.g.  /\bweb\d{2,3}/i )
-#		IP
-#		port (optionnal: default=80)
-#	ret:	0 if no reply
-#		1 if reply
-##########################################################
-##########################################################
-sub regex
-{
-    my $url   = shift;
-    my $regex = shift;
-    my $host  = shift;
-
-    $regex =~ /\/(.*)\/(.*)/;
-    my $reg = $1;
-    my $ext = $2;
-    my %options;
-    $options{ 'agent' }   = "LB_REGEX_PROBE/$VERSION";
-    $options{ 'timeout' } = 10;
-    my $ua = LWP::UserAgent->new( %options );
-    my $response = $ua->get( $url, "Host" => $host );
-    if ( $response->is_success )
-    {
-        my $html = $response->content;
-        if ( $ext =~ /i/ )
-        {
-            if ( $html =~ /$reg/si )
-            {
-                return 1;
-            }
-        }
-        else
-        {
-            if ( $html =~ /$reg/s )
-            {
-                return 1;
-            }
-        }
-    }
-    return 0;
-}
-
-##########################################################
-##########################################################
-# function to GET an URL (HTTP or FTP) ftp://FTPTest:6ccount4F@brice!@172.29.0.146
-#	arg: 	uri
-#		allowed code (comma seaparated)
-#		IP
-#		port (optionnal: default=80)
-#	ret:	0 if not the expected vcode
-#		1 if the expected code is returned
-##########################################################
-##########################################################
-sub get
-{
-    my $url  = shift;
-    my $code = shift;
-    my $host = shift;
-
-    $code =~ s/\s*//g;
-    my %codes = map { $_ => $_ } split /,/, $code;
-    my %options;
-    $options{ 'agent' }   = "LB_HTTP_PROBE/$VERSION";
-    $options{ 'timeout' } = 10;
-    my $ua = LWP::UserAgent->new( %options );
-    my $response = $ua->get( $url, "Host" => $host );
-    if ( $response->is_success )
-    {
-        my $rc = $response->{ _rc };
-        if ( defined $codes{ $rc } )
-        {
-            return 1;
-        }
-    }
-    return 0;
-}
-
-##########################################################
-##########################################################
-# function to test a port on a host
-#	arg: 	hostip
-#		port
-#		timeout
-#	ret:	0 if not open
-#		1 if open
-##########################################################
-##########################################################
-sub TCP
-{
-    use IO::Socket::PortState qw(check_ports);
-    my $remote_host = shift;
-    my $remote_port = shift;
-    my $timeout     = shift;
-
-    my %porthash = ( tcp => { $remote_port => { name => 'to_test', } } );
-    check_ports( $remote_host, $timeout, \%porthash );
-    return $porthash{ tcp }{ $remote_port }{ open };
-}
-
-##############################################
-# parse config file
-# IN: 	File PATH
-# Out:	Ref to a hash with config data
-##############################################
-sub parse_conf
-{
-    my $file = shift;
-
-    my $conf = new Config::General(
-        -ConfigFile        => $file,
-        -ExtendedAccess    => 1,
-        -AllowMultiOptions => "yes"
-    );
-    my %config = $conf->getall;
-    $port              = $config{ port }              || 9898;
-    $host              = $config{ host }              || '127.0.0.1';
-    $reparse           = $config{ reparse }           || 0;
-    $cidr_allow        = $config{ cidr_allow }        || '127.0.0.0/8';
-    $log_level         = $config{ log_level }         || 0;
-    $log_file          = $config{ log_file }          || "/var/log/check.log";
-    $pid_file          = $config{ pid_file }          || "/var/run/check.pid";
-    $daemon            = $config{ daemon }            || 0;
-    $min_servers       = $config{ min_servers }       || 5;
-    $min_spare_servers = $config{ min_spare_servers } || 2;
-    $max_spare_servers = $config{ max_spare_servers } || 10;
-    $max_servers       = $config{ max_servers }       || 50;
-    $html_content      = $config{ content }           || 0;
-
-    $pid_file =~ s/\$\$\$/$basename/g;
-    $pid_file =~ s/\$\$/$$/g;
-    $log_file =~ s/\$\$\$/$basename/g;
-    $log_file =~ s/\$\$/$$/g;
-
-    if ( !( keys %{ $config{ realserver } } ) )
-    {
-        die "No farm to test\n";
-    }
-    return ( \%config );
-}
-
diff --git a/deps/haproxy-1.4.21/examples/check.conf b/deps/haproxy-1.4.21/examples/check.conf
deleted file mode 100644
index 48e8ba1..0000000
--- a/deps/haproxy-1.4.21/examples/check.conf
+++ /dev/null
@@ -1,93 +0,0 @@
-
-# listening port ( default 9898 )
-port 9899
-
-# on which IP to bind (default 127.0.0.1 ) * = all IP
-#host 10.2.1.1
-
-# which client addr is allow ( default 127.0.0.0/8 )
-#cidr_allow = 0.0.0.0/0 
-
-# verbosity from 0 to 4 (default 0 = no log )
-log_level = 1
-
-# daemonize (default 0 = no )
-daemon = 1
-
-# content put a HTML content after header
-# (default 0 = no content 1 = html 2 = table )
-content = 2
-
-# reparse the config file at each request ( default 0 = no )
-# only SIGHUP reread the config file)
-reparse = 1
-
-# pid_file  (default /var/run/check.pid )
-# $$$ = basename of config file
-# $$ = PID
-pid_file=/var/run/CHECK_$$$.pid
-
-# log_file  (default /var/log/check.log )
-# $$$ = basename of config file
-# $$ = PID
-log_file=/var/log/CHECK_$$$.log
-
-# number of servers to keep running (default = 5)
-min_servers = 2
-
-# number of servers to have waiting for requests (default = 2)
-min_spare_servers = 1
-
-# maximum number of servers to have waiting for requests (default = 10)
-max_spare_servers =1
-
-# number of servers (default = 50)
-max_servers = 2
-
-
-###########################################################
-# a server to check
-# type could be get , regex or tcp
-
-# get = do a http or ftp get and check the result code with
-# the list, coma separated, provided ( default = 200,201 )
-# hostheader is optional and send to the server if provided
-
-# regex = do a http or ftp get and check the content result 
-# with regex provided
-# hostheader is optional and send to the server if provided
-
-# tcp = test if the tcp port provided is open
-
-#<realserver>
-#	url=http://127.0.0.1:80/apache2-default/index.html
-#	type = get
-#	code=200,201
-#	hostheader = www.test.com
-#</realserver>
-
-
-#<realserver>
-#	url=http://127.0.0.1:82/apache2-default/index.html
-#	type = get
-#	code=200,201
-#	hostheader = www.myhost.com
-#</realserver>
-
-<realserver>
-	url=	 http://10.2.2.1
-	type = regex
-	regex= /qdAbm/
-</realserver>
-
-<realserver>
-	type = tcp
-	url = 10.2.2.1
-	port =80
-</realserver>
-
-#<realserver>
-#	type = get
-#	url = ftp://FTPuser:FTPpassword@10.2.3.1
-#	code=200,201
-#</realserver>
diff --git a/deps/haproxy-1.4.21/examples/config.rc.haproxy b/deps/haproxy-1.4.21/examples/config.rc.haproxy
deleted file mode 100644
index 5340495..0000000
--- a/deps/haproxy-1.4.21/examples/config.rc.haproxy
+++ /dev/null
@@ -1,6 +0,0 @@
-service haproxy ext
-	config /etc/haproxy/haproxy-ext.cfg
-
-service haproxy int
-	config /etc/haproxy/haproxy-int.cfg
-
diff --git a/deps/haproxy-1.4.21/examples/content-sw-sample.cfg b/deps/haproxy-1.4.21/examples/content-sw-sample.cfg
deleted file mode 100644
index 8eef3ab..0000000
--- a/deps/haproxy-1.4.21/examples/content-sw-sample.cfg
+++ /dev/null
@@ -1,75 +0,0 @@
-#
-# This is a sample configuration
-# haproxy >= 1.3.4 required.
-#
-# It listens on 192.168.1.10:80, and directs all requests for Host 'img' or
-# URIs starting with /img or /css to a dedicated group of servers. URIs
-# starting with /admin/stats are directed to a backend dedicated to statistics.
-#
-
-global
-        maxconn         10000
-        log             127.0.0.1 local0
-        uid             200
-        gid             200
-        chroot          /var/empty
-        daemon
-
-
-# The public 'www' address in the DMZ
-frontend public
-	bind		192.168.1.10:80
-        mode            http
-	log		global
-        option		httplog
-        option          dontlognull
-        option		httpclose
-	monitor-uri	/monitoruri
-        maxconn		8000
-	clitimeout	30000
-
-	# Host: will use a specific keyword soon
-	reqisetbe	^Host:\ img		static
-
-	# The URI will use a specific keyword soon
-	reqisetbe	^[^\ ]*\ /(img|css)/	static
-	reqisetbe	^[^\ ]*\ /admin/stats	stats
-
-	default_backend	dynamic
-
-
-# The static backend backend for 'Host: img', /img and /css.
-backend static
-	mode		http
-	balance		roundrobin
-        contimeout      5000
-        srvtimeout      5000
-	redispatch
-	retries		2
-	option		httpchk HEAD /favicon.ico
-        server		statsrv1 192.168.1.8:80 check inter 1000
-        server		statsrv2 192.168.1.9:80 check inter 1000
-
-
-backend dynamic
-	mode		http
-	balance		roundrobin
-	contimeout	30000
-	srvtimeout	30000
-	redispatch
-	retries		2
-	option		httpchk HEAD /login.php
-	cookie		DYNSRV insert indirect nocache
-	fullconn	4000 # the servers will be used at full load above this number of connections
-        server		dynsrv1 192.168.1.1:80 minconn 50 maxconn 500 cookie s1 check inter 1000
-        server		dynsrv2 192.168.1.2:80 minconn 50 maxconn 500 cookie s2 check inter 1000
-        server		dynsrv3 192.168.1.3:80 minconn 50 maxconn 500 cookie s3 check inter 1000
-        server		dynsrv4 192.168.1.4:80 minconn 50 maxconn 500 cookie s4 check inter 1000
-
-
-backend stats
-        log             global
-        mode            http
-        stats           uri /
-        balance         roundrobin
-
diff --git a/deps/haproxy-1.4.21/examples/cttproxy-src.cfg b/deps/haproxy-1.4.21/examples/cttproxy-src.cfg
deleted file mode 100644
index 541f431..0000000
--- a/deps/haproxy-1.4.21/examples/cttproxy-src.cfg
+++ /dev/null
@@ -1,63 +0,0 @@
-#
-# test tproxy
-
-#
-# ip a a 2.0.0.1/16 dev eth0
-# ip a a 1.0.0.1/16 dev eth1
-# ip li set eth1 up
-# 
-# sudo rmmod -r iptable_tproxy
-# modprobe ip_conntrack hashsize=65536
-# modprobe iptable_tproxy hashsize=65536
-
-
-# or :
-# sudo insmod net/ipv4/netfilter/ip_conntrack.o hashsize=65536;sudo insmod net/ipv4/netfilter/iptable_nat.o;sudo insmod net/ipv4/netfilter/iptable_tproxy.o hashsize=65536
-
-
-# This is a test configuration.
-# It must load-balance across active servers. Check local apache logs to
-# verify :
-#
-#  tail /var/log/apache/access_log
-
-
-global
-	maxconn		10000
-
-listen  sample1
-        mode            http
-        option		httplog
-        option          dontlognull
-        retries         1
-        redispatch
-        contimeout      5000
-        clitimeout      5000
-        srvtimeout      5000
-        maxconn 40000
-        bind 1.0.0.1:8081
-        balance roundrobin
-        server  srv1 10.0.3.2:80 cookie s0 source 10.0.3.1 usesrc 1.0.0.3
-        #server  srv1 10.0.3.2:80 cookie s0 source 10.0.3.1 usesrc client
-        #server  srv1 10.0.3.2:80 cookie s0 source 127.0.0.1 usesrc clientip
-        #server  srv1 10.0.3.2:80 cookie s0 source 10.0.3.1 usesrc client check inter 1000
-	option  httpclose
-	#errorloc 503 /503
-
-listen  sample1
-        mode            http
-        option		httplog
-        option          dontlognull
-        retries         1
-        redispatch
-        contimeout      5000
-        clitimeout      5000
-        srvtimeout      5000
-        maxconn 40000
-        bind 1.0.0.1:8082
-        balance roundrobin
-        server  srv1 10.0.3.2:80 cookie s0 source 10.0.3.1
-        #server  srv1 10.0.3.2:80 cookie s0 source 10.0.3.1 usesrc client check inter 1000
-        option  httpclose
-	#errorloc 503 /503
-
diff --git a/deps/haproxy-1.4.21/examples/debug2ansi b/deps/haproxy-1.4.21/examples/debug2ansi
deleted file mode 100644
index 6ba345d..0000000
--- a/deps/haproxy-1.4.21/examples/debug2ansi
+++ /dev/null
@@ -1,2 +0,0 @@
-#!/bin/sh
-tr -d '\015' | sed -e 's,\(: Cookie:.*$\),'$'\e''\[35m\1'$'\e''\[0m,gi' -e 's,\(: Set-Cookie:.*$\),'$'\e''\[31m\1'$'\e''\[0m,gi' -e 's,\(^[^:]*:[^:]*srvhdr.*\)$,'$'\e''\[32m\1'$'\e''\[0m,i' -e 's,\(^[^:]*:[^:]*clihdr.*\)$,'$'\e''\[34m\1'$'\e''\[0m,i'
diff --git a/deps/haproxy-1.4.21/examples/debug2html b/deps/haproxy-1.4.21/examples/debug2html
deleted file mode 100644
index 866b761..0000000
--- a/deps/haproxy-1.4.21/examples/debug2html
+++ /dev/null
@@ -1,2 +0,0 @@
-#!/bin/sh
-(echo '<html><body><pre>'; tr -d '\015' | sed -e 's,\(: Cookie:.*$\),<font color="#e000c0">\1</font>,gi' -e 's,\(: Set-Cookie:.*$\),<font color="#e0a000">\1</font>,gi' -e 's,\(^[^:]*:[^:]*srvhdr.*\)$,<font color="#00a000">\1</font>,i' -e 's,\(^[^:]*:[^:]*clihdr.*\)$,<font color="#0000c0">\1</font>,i' -e 's,\(^.*\)$,<tt>\1</tt>,' ; echo '</pre></body></html>')
diff --git a/deps/haproxy-1.4.21/examples/debugfind b/deps/haproxy-1.4.21/examples/debugfind
deleted file mode 100644
index 88e9760..0000000
--- a/deps/haproxy-1.4.21/examples/debugfind
+++ /dev/null
@@ -1,8 +0,0 @@
-#!/bin/bash
-if [ $# -lt 2 ]; then
-	echo "Usage: $0 regex debug_file > extracted_file"
-	exit 1
-fi
-word=$1
-file=$2
-exec grep $(for i in $(grep $word $file |cut -f1 -d: | sort -u ) ; do echo -n '\('$i':\)\|'; done; echo '^$') $file
diff --git a/deps/haproxy-1.4.21/examples/errorfiles/400.http b/deps/haproxy-1.4.21/examples/errorfiles/400.http
deleted file mode 100644
index e223e38..0000000
--- a/deps/haproxy-1.4.21/examples/errorfiles/400.http
+++ /dev/null
@@ -1,9 +0,0 @@
-HTTP/1.0 400 Bad request
-Cache-Control: no-cache
-Connection: close
-Content-Type: text/html
-
-<html><body><h1>400 Bad request</h1>
-Your browser sent an invalid request.
-</body></html>
-
diff --git a/deps/haproxy-1.4.21/examples/errorfiles/403.http b/deps/haproxy-1.4.21/examples/errorfiles/403.http
deleted file mode 100644
index a67e807..0000000
--- a/deps/haproxy-1.4.21/examples/errorfiles/403.http
+++ /dev/null
@@ -1,9 +0,0 @@
-HTTP/1.0 403 Forbidden
-Cache-Control: no-cache
-Connection: close
-Content-Type: text/html
-
-<html><body><h1>403 Forbidden</h1>
-Request forbidden by administrative rules.
-</body></html>
-
diff --git a/deps/haproxy-1.4.21/examples/errorfiles/408.http b/deps/haproxy-1.4.21/examples/errorfiles/408.http
deleted file mode 100644
index aafb130..0000000
--- a/deps/haproxy-1.4.21/examples/errorfiles/408.http
+++ /dev/null
@@ -1,9 +0,0 @@
-HTTP/1.0 408 Request Time-out
-Cache-Control: no-cache
-Connection: close
-Content-Type: text/html
-
-<html><body><h1>408 Request Time-out</h1>
-Your browser didn't send a complete request in time.
-</body></html>
-
diff --git a/deps/haproxy-1.4.21/examples/errorfiles/500.http b/deps/haproxy-1.4.21/examples/errorfiles/500.http
deleted file mode 100644
index bb121e8..0000000
--- a/deps/haproxy-1.4.21/examples/errorfiles/500.http
+++ /dev/null
@@ -1,9 +0,0 @@
-HTTP/1.0 500 Server Error
-Cache-Control: no-cache
-Connection: close
-Content-Type: text/html
-
-<html><body><h1>500 Server Error</h1>
-An internal server error occured.
-</body></html>
-
diff --git a/deps/haproxy-1.4.21/examples/errorfiles/502.http b/deps/haproxy-1.4.21/examples/errorfiles/502.http
deleted file mode 100644
index 94b35d4..0000000
--- a/deps/haproxy-1.4.21/examples/errorfiles/502.http
+++ /dev/null
@@ -1,9 +0,0 @@
-HTTP/1.0 502 Bad Gateway
-Cache-Control: no-cache
-Connection: close
-Content-Type: text/html
-
-<html><body><h1>502 Bad Gateway</h1>
-The server returned an invalid or incomplete response.
-</body></html>
-
diff --git a/deps/haproxy-1.4.21/examples/errorfiles/503.http b/deps/haproxy-1.4.21/examples/errorfiles/503.http
deleted file mode 100644
index 48fde58..0000000
--- a/deps/haproxy-1.4.21/examples/errorfiles/503.http
+++ /dev/null
@@ -1,9 +0,0 @@
-HTTP/1.0 503 Service Unavailable
-Cache-Control: no-cache
-Connection: close
-Content-Type: text/html
-
-<html><body><h1>503 Service Unavailable</h1>
-No server is available to handle this request.
-</body></html>
-
diff --git a/deps/haproxy-1.4.21/examples/errorfiles/504.http b/deps/haproxy-1.4.21/examples/errorfiles/504.http
deleted file mode 100644
index f925184..0000000
--- a/deps/haproxy-1.4.21/examples/errorfiles/504.http
+++ /dev/null
@@ -1,9 +0,0 @@
-HTTP/1.0 504 Gateway Time-out
-Cache-Control: no-cache
-Connection: close
-Content-Type: text/html
-
-<html><body><h1>504 Gateway Time-out</h1>
-The server didn't respond in time.
-</body></html>
-
diff --git a/deps/haproxy-1.4.21/examples/errorfiles/README b/deps/haproxy-1.4.21/examples/errorfiles/README
deleted file mode 100644
index a882632..0000000
--- a/deps/haproxy-1.4.21/examples/errorfiles/README
+++ /dev/null
@@ -1,9 +0,0 @@
-These files are default error files that can be customized
-if necessary. They are complete HTTP responses, so that
-everything is possible, including using redirects or setting
-special headers.
-
-They can be used with the 'errorfile' keyword like this :
-
-    errorfile 503 /etc/haproxy/errors/503.http
-
diff --git a/deps/haproxy-1.4.21/examples/examples.cfg b/deps/haproxy-1.4.21/examples/examples.cfg
deleted file mode 100644
index 3499e7b..0000000
--- a/deps/haproxy-1.4.21/examples/examples.cfg
+++ /dev/null
@@ -1,154 +0,0 @@
-global
-	log	127.0.0.1 local0
-#	log	127.0.0.1 local1
-	maxconn	4000
-	ulimit-n 8000
-	uid	0
-	gid	0
-#	chroot	/tmp
-#	nbproc	2
-#	daemon
-#	debug
-#	quiet
-
-listen proxy1 0.0.0.0:8000
-	mode	http
-#	source	127.0.0.2:0
-#	log	127.0.0.1 local0
-#	log	127.0.0.1 local1
-	log global
-	#mode	tcp
-        cookie SERVERID insert indirect
-	balance roundrobin
-	#dispatch 127.0.0.1:3130
-	#dispatch 127.0.0.1:31300
-	#dispatch 127.0.0.1:80
-	#dispatch 127.0.0.1:22
-	option httpchk
-	server test 10.1.1.2:80 cookie cookie1 check inter 300
-#	server nc 127.0.0.1:8080 cookie cookie1 check inter 300
-#	server tuxlocal0 10.101.23.9:80 cookie cookie1 check
-#	server tuxlocal1 127.0.0.1:80 cookie cookie1 check
-#	server tuxlocal2 127.0.0.1:80 cookie cookie2 check
-#	server tuxlocal3 127.0.0.1:80 cookie cookie3 check
-#	server tuxlocal4 127.0.0.1:80 cookie cookie4 check
-#	server vax 10.101.14.1:80 cookie cookie1 check
-	#server tuxceleron 10.101.0.1:80 cookie cookie2 check
-	#server telnet 127.0.0.1:23
-	#server ssh 127.0.0.1:22
-	#server local 127.0.0.1:3130 cookie cookie3 check
-	#server ko 127.0.0.1:0 cookie cookie3 check
-	#server local 127.0.0.1:8001 cookie cookie3 check
-	#server local 127.0.0.1:3130
-	#server celeron 10.101.0.1:80 cookie srv1
-	#server celeron 10.101.0.1:31300
-	#server local 10.101.23.9:31300
-	contimeout	3000
-	clitimeout	150000
-	srvtimeout	150000
-	maxconn 60000
-	redispatch
-	retries	3
-	grace 3000
-	#rsprep	^Server.* Server:\ IIS
-	#rspdel	^Server.*
-	#rspadd Set-Cookie:\ mycookie=0;\ path=/
-	#rsprep ^(Date:\ )([^,]*)(,\ )(.*) LaDate\ est:\ \4\ (\2)
-	# force connection:close
-	#reqidel ^Connection:
-	#rspidel ^Connection:
-	#reqadd	Connection:\ close
-	#rspadd	Connection:\ close
-	# processing options
-	#option	keepalive
-	option	forwardfor
-	option httplog
-	option dontlognull
-#	reqirep ^(Test:\ ) \0_toto_\1_toto
-#	reqidel ^X-Forwarded-for:
-#	reqirep ^(GET|POST)\ .* \0
-#	reqirep ^(Host:|Connection:|User-agent:|Cookie:)\ .* \0
-#	reqideny ^
-	
-listen proxy1 0.0.0.0:8001
-	mode	http
-	#mode	tcp
-	dispatch 127.0.0.1:80
-	#dispatch 127.0.0.1:31300
-	#dispatch 127.0.0.1:80
-	#dispatch 127.0.0.1:22
-	#server tuxlocal 127.0.0.1:80 cookie cookie1 check
-	#server tuxceleron 10.101.0.1:80 cookie cookie2 check
-	#server telnet 127.0.0.1:23
-	#server ssh 127.0.0.1:22
-	#server local 127.0.0.1:3130 cookie cookie3 check
-	#server local 127.0.0.1:3130
-	#server celeron 10.101.0.1:80 cookie srv1
-	#server celeron 10.101.0.1:31300
-	#server local 10.101.23.9:31300
-	contimeout	3000
-	clitimeout	150000
-	srvtimeout	150000
-	maxconn 60000
-	redispatch
-	retries	3
-	grace 3000
-	#rsprep	^Server.* Server:\ IIS
-	#rspdel	^Server.*
-	rspadd Set-Cookie:\ SERVERID=12345678;\ path=/
-	#rsprep ^(Date:\ )([^,]*)(,\ )(.*) LaDate\ est:\ \4\ (\2)
-	
-listen proxy1 0.0.0.0:3128
-	disabled
-	mode	http
-        cookie SERVERID insert indirect
-	#dispatch 127.0.0.1:8080
-	server srv1 127.0.0.1:8080
- 	#server srv2 192.168.12.3:8080
-	contimeout	3000
-	clitimeout	450000
-	srvtimeout	450000
-	maxconn 60000
-	redispatch
-	retries	3
-	grace 3000
-	rspdel ^Via:.*
-	monitor-net	192.168.12.252/30
-	
-
-listen proxy2 0.0.0.0:3129
-	disabled
-	mode	http
-	transparent
-#	dispatch 127.0.0.1:80
-	contimeout	3000
-	clitimeout	150000
-	srvtimeout	150000
-	maxconn 60000
-	retries	3
-	grace 3000
-
-#	log	10.101.11.1 local1
-#	log	10.101.11.1 local2
-
-#	cliexp	^(.*ASPSESSIONID.*=)(.*) \1FENICGGCBECLFFEEOAEAIFGF
-#	cliexp	^(GET.*)(.free.fr)(.*) \1.online.fr\3
-#	cliexp	^(POST.*)(.free.fr)(.*) \1.online.fr\3
-#	cliexp	^Proxy-Connection:.*	Proxy-Connection:\ close
-#	srvexp	^(Location:\ )([^:]*://[^/]*)(.*) \1\3
-
-listen health 0.0.0.0:3130
-	mode	health
-	clitimeout	1500
-	srvtimeout	1500
-	maxconn 6000
-	grace 0
-
-
-listen health 0.0.0.0:31300
-	mode	health
-	option  httpchk
-	clitimeout	1500
-	srvtimeout	1500
-	maxconn 6000
-	grace 0
diff --git a/deps/haproxy-1.4.21/examples/haproxy.cfg b/deps/haproxy-1.4.21/examples/haproxy.cfg
deleted file mode 100644
index 1c71d61..0000000
--- a/deps/haproxy-1.4.21/examples/haproxy.cfg
+++ /dev/null
@@ -1,80 +0,0 @@
-# this config needs haproxy-1.1.28 or haproxy-1.2.1
-
-global
-	log 127.0.0.1	local0
-	log 127.0.0.1	local1 notice
-	#log loghost	local0 info
-	maxconn 4096
-	chroot /usr/share/haproxy
-	uid 99
-	gid 99
-	daemon
-	#debug
-	#quiet
-
-defaults
-	log	global
-	mode	http
-	option	httplog
-	option	dontlognull
-	retries	3
-	redispatch
-	maxconn	2000
-	contimeout	5000
-	clitimeout	50000
-	srvtimeout	50000
-
-listen	appli1-rewrite 0.0.0.0:10001
-	cookie	SERVERID rewrite
-	balance	roundrobin
-	server	app1_1 192.168.34.23:8080 cookie app1inst1 check inter 2000 rise 2 fall 5
-	server	app1_2 192.168.34.32:8080 cookie app1inst2 check inter 2000 rise 2 fall 5
-	server	app1_3 192.168.34.27:8080 cookie app1inst3 check inter 2000 rise 2 fall 5
-	server	app1_4 192.168.34.42:8080 cookie app1inst4 check inter 2000 rise 2 fall 5
-
-listen	appli2-insert 0.0.0.0:10002
-	option	httpchk
-	balance	roundrobin
-	cookie	SERVERID insert indirect nocache
-	server	inst1 192.168.114.56:80 cookie server01 check inter 2000 fall 3
-	server	inst2 192.168.114.56:81 cookie server02 check inter 2000 fall 3
-	capture cookie vgnvisitor= len 32
-
-	option	httpclose		# disable keep-alive
-	rspidel ^Set-cookie:\ IP=	# do not let this cookie tell our internal IP address
-	
-listen	appli3-relais 0.0.0.0:10003
-	dispatch 192.168.135.17:80
-
-listen	appli4-backup 0.0.0.0:10004
-	option	httpchk /index.html
-	option	persist
-	balance	roundrobin
-	server	inst1 192.168.114.56:80 check inter 2000 fall 3
-	server	inst2 192.168.114.56:81 check inter 2000 fall 3 backup
-
-listen	ssl-relay 0.0.0.0:8443
-	option	ssl-hello-chk
-	balance	source
-	server	inst1 192.168.110.56:443 check inter 2000 fall 3
-	server	inst2 192.168.110.57:443 check inter 2000 fall 3
-	server	back1 192.168.120.58:443 backup
-
-listen	appli5-backup 0.0.0.0:10005
-	option	httpchk *
-	balance	roundrobin
-	cookie	SERVERID insert indirect nocache
-	server	inst1 192.168.114.56:80 cookie server01 check inter 2000 fall 3
-	server	inst2 192.168.114.56:81 cookie server02 check inter 2000 fall 3
-	server	inst3 192.168.114.57:80 backup check inter 2000 fall 3
-	capture cookie ASPSESSION len 32
-	srvtimeout	20000
-
-	option	httpclose		# disable keep-alive
-	option  checkcache		# block response if set-cookie & cacheable
-
-	rspidel ^Set-cookie:\ IP=	# do not let this cookie tell our internal IP address
-	
-	errorloc	502	http://192.168.114.58/error502.html
-	errorfile	503	/etc/haproxy/errors/503.http
-
diff --git a/deps/haproxy-1.4.21/examples/haproxy.init b/deps/haproxy-1.4.21/examples/haproxy.init
deleted file mode 100644
index 942d959..0000000
--- a/deps/haproxy-1.4.21/examples/haproxy.init
+++ /dev/null
@@ -1,123 +0,0 @@
-#!/bin/sh
-#
-# chkconfig: - 85 15
-# description: HA-Proxy is a TCP/HTTP reverse proxy which is particularly suited \
-#              for high availability environments.
-# processname: haproxy
-# config: /etc/haproxy/haproxy.cfg
-# pidfile: /var/run/haproxy.pid
-
-# Script Author: Simon Matter <simon.matter@invoca.ch>
-# Version: 2004060600
-
-# Source function library.
-if [ -f /etc/init.d/functions ]; then
-  . /etc/init.d/functions
-elif [ -f /etc/rc.d/init.d/functions ] ; then
-  . /etc/rc.d/init.d/functions
-else
-  exit 0
-fi
-
-# Source networking configuration.
-. /etc/sysconfig/network
-
-# Check that networking is up.
-[ ${NETWORKING} = "no" ] && exit 0
-
-# This is our service name
-BASENAME=`basename $0`
-if [ -L $0 ]; then
-  BASENAME=`find $0 -name $BASENAME -printf %l`
-  BASENAME=`basename $BASENAME`
-fi
-
-[ -f /etc/$BASENAME/$BASENAME.cfg ] || exit 1
-
-RETVAL=0
-
-start() {
-  /usr/sbin/$BASENAME -c -q -f /etc/$BASENAME/$BASENAME.cfg
-  if [ $? -ne 0 ]; then
-    echo "Errors found in configuration file, check it with '$BASENAME check'."
-    return 1
-  fi
-
-  echo -n "Starting $BASENAME: "
-  daemon /usr/sbin/$BASENAME -D -f /etc/$BASENAME/$BASENAME.cfg -p /var/run/$BASENAME.pid
-  RETVAL=$?
-  echo
-  [ $RETVAL -eq 0 ] && touch /var/lock/subsys/$BASENAME
-  return $RETVAL
-}
-
-stop() {
-  echo -n "Shutting down $BASENAME: "
-  killproc $BASENAME -USR1
-  RETVAL=$?
-  echo
-  [ $RETVAL -eq 0 ] && rm -f /var/lock/subsys/$BASENAME
-  [ $RETVAL -eq 0 ] && rm -f /var/run/$BASENAME.pid
-  return $RETVAL
-}
-
-restart() {
-  /usr/sbin/$BASENAME -c -q -f /etc/$BASENAME/$BASENAME.cfg
-  if [ $? -ne 0 ]; then
-    echo "Errors found in configuration file, check it with '$BASENAME check'."
-    return 1
-  fi
-  stop
-  start
-}
-
-reload() {
-  /usr/sbin/$BASENAME -c -q -f /etc/$BASENAME/$BASENAME.cfg
-  if [ $? -ne 0 ]; then
-    echo "Errors found in configuration file, check it with '$BASENAME check'."
-    return 1
-  fi
-  /usr/sbin/$BASENAME -D -f /etc/$BASENAME/$BASENAME.cfg -p /var/run/$BASENAME.pid -sf $(cat /var/run/$BASENAME.pid)
-}
-
-check() {
-  /usr/sbin/$BASENAME -c -q -V -f /etc/$BASENAME/$BASENAME.cfg
-}
-
-rhstatus() {
-  status $BASENAME
-}
-
-condrestart() {
-  [ -e /var/lock/subsys/$BASENAME ] && restart || :
-}
-
-# See how we were called.
-case "$1" in
-  start)
-    start
-    ;;
-  stop)
-    stop
-    ;;
-  restart)
-    restart
-    ;;
-  reload)
-    reload
-    ;;
-  condrestart)
-    condrestart
-    ;;
-  status)
-    rhstatus
-    ;;
-  check)
-    check
-    ;;
-  *)
-    echo $"Usage: $BASENAME {start|stop|restart|reload|condrestart|status|check}"
-    exit 1
-esac
- 
-exit $?
diff --git a/deps/haproxy-1.4.21/examples/haproxy.spec b/deps/haproxy-1.4.21/examples/haproxy.spec
deleted file mode 100644
index a1e8389..0000000
--- a/deps/haproxy-1.4.21/examples/haproxy.spec
+++ /dev/null
@@ -1,291 +0,0 @@
-Summary: HA-Proxy is a TCP/HTTP reverse proxy for high availability environments
-Name: haproxy
-Version: 1.4.21
-Release: 1
-License: GPL
-Group: System Environment/Daemons
-URL: http://haproxy.1wt.eu/
-Source0: http://haproxy.1wt.eu/download/1.4/src/%{name}-%{version}.tar.gz
-BuildRoot: %{_tmppath}/%{name}-%{version}-root
-BuildRequires: pcre-devel
-Requires: /sbin/chkconfig, /sbin/service
-
-%description
-HA-Proxy is a TCP/HTTP reverse proxy which is particularly suited for high
-availability environments. Indeed, it can:
-- route HTTP requests depending on statically assigned cookies
-- spread the load among several servers while assuring server persistence
-  through the use of HTTP cookies
-- switch to backup servers in the event a main one fails
-- accept connections to special ports dedicated to service monitoring
-- stop accepting connections without breaking existing ones
-- add/modify/delete HTTP headers both ways
-- block requests matching a particular pattern
-
-It needs very little resource. Its event-driven architecture allows it to easily
-handle thousands of simultaneous connections on hundreds of instances without
-risking the system's stability.
-
-%prep
-%setup -q
-
-# We don't want any perl dependecies in this RPM:
-%define __perl_requires /bin/true
-
-%build
-%{__make} USE_PCRE=1 DEBUG="" ARCH=%{_target_cpu} TARGET=linux26
-
-%install
-[ "%{buildroot}" != "/" ] && %{__rm} -rf %{buildroot}
- 
-%{__install} -d %{buildroot}%{_sbindir}
-%{__install} -d %{buildroot}%{_sysconfdir}/rc.d/init.d
-%{__install} -d %{buildroot}%{_sysconfdir}/%{name}
-%{__install} -d %{buildroot}%{_mandir}/man1/
-
-%{__install} -s %{name} %{buildroot}%{_sbindir}/
-%{__install} -c -m 644 examples/%{name}.cfg %{buildroot}%{_sysconfdir}/%{name}/
-%{__install} -c -m 755 examples/%{name}.init %{buildroot}%{_sysconfdir}/rc.d/init.d/%{name}
-%{__install} -c -m 755 doc/%{name}.1 %{buildroot}%{_mandir}/man1/
- 
-%clean
-[ "%{buildroot}" != "/" ] && %{__rm} -rf %{buildroot}
- 
-%post
-/sbin/chkconfig --add %{name}
-
-%preun
-if [ $1 = 0 ]; then
-  /sbin/service %{name} stop >/dev/null 2>&1 || :
-  /sbin/chkconfig --del %{name}
-fi
-
-%postun
-if [ "$1" -ge "1" ]; then
-  /sbin/service %{name} condrestart >/dev/null 2>&1 || :
-fi
-
-%files
-%defattr(-,root,root)
-%doc CHANGELOG TODO examples/*.cfg doc/haproxy-en.txt doc/haproxy-fr.txt doc/architecture.txt doc/configuration.txt
-%doc %{_mandir}/man1/%{name}.1*
-
-%attr(0755,root,root) %{_sbindir}/%{name}
-%dir %{_sysconfdir}/%{name}
-%attr(0644,root,root) %config(noreplace) %{_sysconfdir}/%{name}/%{name}.cfg
-%attr(0755,root,root) %config %{_sysconfdir}/rc.d/init.d/%{name}
-
-%changelog
-* Mon May 21 2012 Willy Tarreau <w@1wt.eu>
-- updated to 1.4.21
-
-* Sat Mar 10 2012 Willy Tarreau <w@1wt.eu>
-- updated to 1.4.20
-
-* Sun Jan  8 2012 Willy Tarreau <w@1wt.eu>
-- updated to 1.4.19
-
-* Fri Sep 16 2011 Willy Tarreau <w@1wt.eu>
-- updated to 1.4.18
-
-* Mon Sep  5 2011 Willy Tarreau <w@1wt.eu>
-- updated to 1.4.17
-
-* Thu Aug  4 2011 Willy Tarreau <w@1wt.eu>
-- updated to 1.4.16
-
-* Fri Apr  8 2011 Willy Tarreau <w@1wt.eu>
-- updated to 1.4.15
-
-* Tue Mar 29 2011 Willy Tarreau <w@1wt.eu>
-- updated to 1.4.14
-
-* Wed Mar  9 2011 Willy Tarreau <w@1wt.eu>
-- updated to 1.4.13
-
-* Tue Mar  8 2011 Willy Tarreau <w@1wt.eu>
-- updated to 1.4.12
-
-* Thu Feb 10 2011 Willy Tarreau <w@1wt.eu>
-- updated to 1.4.11
-
-* Mon Nov 29 2010 Willy Tarreau <w@1wt.eu>
-- updated to 1.4.10
-
-* Fri Oct 29 2010 Willy Tarreau <w@1wt.eu>
-- updated to 1.4.9
-
-* Wed Jun 16 2010 Willy Tarreau <w@1wt.eu>
-- updated to 1.4.8
-
-* Mon Jun  7 2010 Willy Tarreau <w@1wt.eu>
-- updated to 1.4.7
-
-* Sun May 16 2010 Willy Tarreau <w@1wt.eu>
-- updated to 1.4.6
-
-* Thu May 13 2010 Willy Tarreau <w@1wt.eu>
-- updated to 1.4.5
-
-* Wed Apr  7 2010 Willy Tarreau <w@1wt.eu>
-- updated to 1.4.4
-
-* Tue Mar 30 2010 Willy Tarreau <w@1wt.eu>
-- updated to 1.4.3
-
-* Wed Mar 17 2010 Willy Tarreau <w@1wt.eu>
-- updated to 1.4.2
-
-* Thu Mar  4 2010 Willy Tarreau <w@1wt.eu>
-- updated to 1.4.1
-
-* Fri Feb 26 2010 Willy Tarreau <w@1wt.eu>
-- updated to 1.4.0
-
-* Tue Feb  2 2010 Willy Tarreau <w@1wt.eu>
-- updated to 1.4-rc1
-
-* Mon Jan 25 2010 Willy Tarreau <w@1wt.eu>
-- updated to 1.4-dev8
-
-* Mon Jan 25 2010 Willy Tarreau <w@1wt.eu>
-- updated to 1.4-dev7
-
-* Fri Jan  8 2010 Willy Tarreau <w@1wt.eu>
-- updated to 1.4-dev6
-
-* Sun Jan  3 2010 Willy Tarreau <w@1wt.eu>
-- updated to 1.4-dev5
-
-* Mon Oct 12 2009 Willy Tarreau <w@1wt.eu>
-- updated to 1.4-dev4
-
-* Thu Sep 24 2009 Willy Tarreau <w@1wt.eu>
-- updated to 1.4-dev3
-
-* Sun Aug  9 2009 Willy Tarreau <w@1wt.eu>
-- updated to 1.4-dev2
-
-* Wed Jul 29 2009 Willy Tarreau <w@1wt.eu>
-- updated to 1.4-dev1
-
-* Tue Jun 09 2009 Willy Tarreau <w@1wt.eu>
-- updated to 1.4-dev0
-
-* Sun May 10 2009 Willy Tarreau <w@1wt.eu>
-- updated to 1.3.18
-
-* Sun Mar 29 2009 Willy Tarreau <w@1wt.eu>
-- updated to 1.3.17
-
-* Sun Mar 22 2009 Willy Tarreau <w@1wt.eu>
-- updated to 1.3.16
-
-* Sat Apr 19 2008 Willy Tarreau <w@1wt.eu>
-- updated to 1.3.15
-
-* Wed Dec  5 2007 Willy Tarreau <w@1wt.eu>
-- updated to 1.3.14
-
-* Thu Oct 18 2007 Willy Tarreau <w@1wt.eu>
-- updated to 1.3.13
-
-* Sun Jun 17 2007 Willy Tarreau <w@1wt.eu>
-- updated to 1.3.12
-
-* Sun Jun  3 2007 Willy Tarreau <w@1wt.eu>
-- updated to 1.3.11.4
-
-* Mon May 14 2007 Willy Tarreau <w@1wt.eu>
-- updated to 1.3.11.3
-
-* Mon May 14 2007 Willy Tarreau <w@1wt.eu>
-- updated to 1.3.11.2
-
-* Mon May 14 2007 Willy Tarreau <w@1wt.eu>
-- updated to 1.3.11.1
-
-* Mon May 14 2007 Willy Tarreau <w@1wt.eu>
-- updated to 1.3.11
-
-* Thu May 10 2007 Willy Tarreau <w@1wt.eu>
-- updated to 1.3.10.2
-
-* Tue May 09 2007 Willy Tarreau <w@1wt.eu>
-- updated to 1.3.10.1
-
-* Tue May 08 2007 Willy Tarreau <w@1wt.eu>
-- updated to 1.3.10
-
-* Sun Apr 15 2007 Willy Tarreau <w@1wt.eu>
-- updated to 1.3.9
-
-* Tue Apr 03 2007 Willy Tarreau <w@1wt.eu>
-- updated to 1.3.8.2
-
-* Sun Apr 01 2007 Willy Tarreau <w@1wt.eu>
-- updated to 1.3.8.1
-
-* Sun Mar 25 2007 Willy Tarreau <w@1wt.eu>
-- updated to 1.3.8
-
-* Wed Jan 26 2007 Willy Tarreau <w@1wt.eu>
-- updated to 1.3.7
-
-* Wed Jan 22 2007 Willy Tarreau <w@1wt.eu>
-- updated to 1.3.6
-
-* Wed Jan 07 2007 Willy Tarreau <w@1wt.eu>
-- updated to 1.3.5
-
-* Wed Jan 02 2007 Willy Tarreau <w@1wt.eu>
-- updated to 1.3.4
-
-* Wed Oct 15 2006 Willy Tarreau <w@1wt.eu>
-- updated to 1.3.3
-
-* Wed Sep 03 2006 Willy Tarreau <w@1wt.eu>
-- updated to 1.3.2
-
-* Wed Jul 09 2006 Willy Tarreau <w@1wt.eu>
-- updated to 1.3.1
-
-* Wed May 21 2006 Willy Tarreau <willy@w.ods.org>
-- updated to 1.2.14
-
-* Wed May 01 2006 Willy Tarreau <willy@w.ods.org>
-- updated to 1.2.13
-
-* Wed Apr 15 2006 Willy Tarreau <willy@w.ods.org>
-- updated to 1.2.12
-
-* Wed Mar 30 2006 Willy Tarreau <willy@w.ods.org>
-- updated to 1.2.11.1
-
-* Wed Mar 19 2006 Willy Tarreau <willy@w.ods.org>
-- updated to 1.2.10
-
-* Wed Mar 15 2006 Willy Tarreau <willy@w.ods.org>
-- updated to 1.2.9
-
-* Sat Jan 22 2005 Willy Tarreau <willy@w.ods.org>
-- updated to 1.2.3 (1.1.30)
-
-* Sun Nov 14 2004 Willy Tarreau <w@w.ods.org>
-- updated to 1.1.29
-- fixed path to config and init files
-- statically linked PCRE to increase portability to non-pcre systems
-
-* Sun Jun  6 2004 Willy Tarreau <willy@w.ods.org>
-- updated to 1.1.28
-- added config check support to the init script
-
-* Tue Oct 28 2003 Simon Matter <simon.matter@invoca.ch>
-- updated to 1.1.27
-- added pid support to the init script
-
-* Wed Oct 22 2003 Simon Matter <simon.matter@invoca.ch>
-- updated to 1.1.26
-
-* Thu Oct 16 2003 Simon Matter <simon.matter@invoca.ch>
-- initial build
diff --git a/deps/haproxy-1.4.21/examples/haproxy.vim b/deps/haproxy-1.4.21/examples/haproxy.vim
deleted file mode 100644
index 728a1c5..0000000
--- a/deps/haproxy-1.4.21/examples/haproxy.vim
+++ /dev/null
@@ -1,164 +0,0 @@
-" Vim syntax file
-" Language:    HAproxy
-" Maintainer:  Bruno Michel <brmichel@free.fr>
-" Last Change: Mar 30, 2007
-" Version:     0.3
-" URL:         http://haproxy.1wt.eu/
-" URL:         http://vim.sourceforge.net/scripts/script.php?script_id=1845
-
-" It is suggested to add the following line to $HOME/.vimrc :
-"    au BufRead,BufNewFile haproxy* set ft=haproxy
-
-" For version 5.x: Clear all syntax items
-" For version 6.x: Quit when a syntax file was already loaded
-if version < 600
-	syntax clear
-elseif exists("b:current_syntax")
-	finish
-endif
-
-if version >= 600
-	setlocal iskeyword=_,-,a-z,A-Z,48-57
-else
-	set iskeyword=_,-,a-z,A-Z,48-57
-endif
-
-
-" Escaped chars
-syn match   hapEscape    +\\\(\\\| \|n\|r\|t\|#\|x\x\x\)+
-
-" Comments
-syn match   hapComment   /#.*$/ contains=hapTodo
-syn keyword hapTodo      contained TODO FIXME XXX
-syn case ignore
-
-" Sections
-syn match   hapSection   /^\s*\(global\|defaults\)/
-syn match   hapSection   /^\s*\(listen\|frontend\|backend\|ruleset\)/         skipwhite nextgroup=hapSectLabel
-syn match   hapSectLabel /\S\+/                                               skipwhite nextgroup=hapIp1 contained
-syn match   hapIp1       /\(\d\{1,3}\.\d\{1,3}\.\d\{1,3}\.\d\{1,3}\)\?:\d\{1,5}/        nextgroup=hapIp2 contained
-syn match   hapIp2       /,\(\d\{1,3}\.\d\{1,3}\.\d\{1,3}\.\d\{1,3}\)\?:\d\{1,5}/hs=s+1 nextgroup=hapIp2 contained
-
-" Parameters
-syn keyword hapParam     chroot cliexp clitimeout contimeout
-syn keyword hapParam     daemon debug disabled
-syn keyword hapParam     enabled
-syn keyword hapParam     fullconn
-syn keyword hapParam     gid grace group
-syn keyword hapParam     maxconn monitor-uri
-syn keyword hapParam     nbproc noepoll nopoll
-syn keyword hapParam     pidfile
-syn keyword hapParam     quiet
-syn keyword hapParam     redispatch retries
-syn keyword hapParam     reqallow  reqdel  reqdeny  reqpass  reqtarpit  skipwhite nextgroup=hapRegexp
-syn keyword hapParam     reqiallow reqidel reqideny reqipass reqitarpit skipwhite nextgroup=hapRegexp
-syn keyword hapParam     rspdel  rspdeny    skipwhite nextgroup=hapRegexp
-syn keyword hapParam     rspidel rspideny   skipwhite nextgroup=hapRegexp
-syn keyword hapParam     reqsetbe reqisetbe skipwhite nextgroup=hapRegexp2
-syn keyword hapParam     reqadd reqiadd rspadd rspiadd
-syn keyword hapParam     server source srvexp srvtimeout
-syn keyword hapParam     uid ulimit-n user
-syn keyword hapParam     reqrep reqirep rsprep rspirep    skipwhite nextgroup=hapRegexp
-syn keyword hapParam     errorloc errorloc302 errorloc303 skipwhite nextgroup=hapStatus
-syn keyword hapParam     default_backend                  skipwhite nextgroup=hapSectLabel
-syn keyword hapParam     appsession  skipwhite nextgroup=hapAppSess
-syn keyword hapParam     bind        skipwhite nextgroup=hapIp1
-syn keyword hapParam     balance     skipwhite nextgroup=hapBalance
-syn keyword hapParam     cookie      skipwhite nextgroup=hapCookieNam
-syn keyword hapParam     capture     skipwhite nextgroup=hapCapture
-syn keyword hapParam     dispatch    skipwhite nextgroup=hapIpPort
-syn keyword hapParam     source      skipwhite nextgroup=hapIpPort
-syn keyword hapParam     mode        skipwhite nextgroup=hapMode
-syn keyword hapParam     monitor-net skipwhite nextgroup=hapIPv4Mask
-syn keyword hapParam     option      skipwhite nextgroup=hapOption
-syn keyword hapParam     stats       skipwhite nextgroup=hapStats
-syn keyword hapParam     server      skipwhite nextgroup=hapServerN
-syn keyword hapParam     source      skipwhite nextgroup=hapServerEOL
-syn keyword hapParam     log         skipwhite nextgroup=hapGLog,hapLogIp
-
-" Options and additional parameters
-syn keyword hapAppSess   contained len timeout
-syn keyword hapBalance   contained roundrobin source
-syn keyword hapLen       contained len
-syn keyword hapGLog      contained global
-syn keyword hapMode      contained http tcp health
-syn keyword hapOption    contained abortonclose allbackups checkcache clitcpka dontlognull forceclose forwardfor
-syn keyword hapOption    contained httpchk httpclose httplog keepalive logasap persist srvtcpka ssl-hello-chk
-syn keyword hapOption    contained tcplog tcpka tcpsplice
-syn keyword hapOption    contained except skipwhite nextgroup=hapIPv4Mask
-syn keyword hapStats     contained uri realm auth scope enable
-syn keyword hapLogFac    contained kern user mail daemon auth syslog lpr news nextgroup=hapLogLvl skipwhite
-syn keyword hapLogFac    contained uucp cron auth2 ftp ntp audit alert cron2  nextgroup=hapLogLvl skipwhite
-syn keyword hapLogFac    contained local0 local1 local2 local3 local4 local5 local6 local7 nextgroup=hapLogLvl skipwhite
-syn keyword hapLogLvl    contained emerg alert crit err warning notice info debug
-syn keyword hapCookieKey contained rewrite insert nocache postonly indirect prefix nextgroup=hapCookieKey skipwhite
-syn keyword hapCapture   contained cookie nextgroup=hapNameLen skipwhite
-syn keyword hapCapture   contained request response nextgroup=hapHeader skipwhite
-syn keyword hapHeader    contained header nextgroup=hapNameLen skipwhite
-syn keyword hapSrvKey    contained backup cookie check inter rise fall port source minconn maxconn weight usesrc
-syn match   hapStatus    contained /\d\{3}/
-syn match   hapIPv4Mask  contained /\d\{1,3}\.\d\{1,3}\.\d\{1,3}\.\d\{1,3}\(\/\d\{1,2}\)\?/
-syn match   hapLogIp     contained /\d\{1,3}\.\d\{1,3}\.\d\{1,3}\.\d\{1,3}/   nextgroup=hapLogFac skipwhite
-syn match   hapIpPort    contained /\d\{1,3}\.\d\{1,3}\.\d\{1,3}\.\d\{1,3}:\d\{1,5}/
-syn match   hapServerAd  contained /\d\{1,3}\.\d\{1,3}\.\d\{1,3}\.\d\{1,3}\(:[+-]\?\d\{1,5}\)\?/ nextgroup=hapSrvEOL skipwhite
-syn match   hapNameLen   contained /\S\+/ nextgroup=hapLen       skipwhite
-syn match   hapCookieNam contained /\S\+/ nextgroup=hapCookieKey skipwhite
-syn match   hapServerN   contained /\S\+/ nextgroup=hapServerAd  skipwhite
-syn region  hapSrvEOL    contained start=/\S/ end=/$/ contains=hapSrvKey
-syn region  hapRegexp    contained start=/\S/ end=/\(\s\|$\)/ skip=/\\ / nextgroup=hapRegRepl skipwhite
-syn region  hapRegRepl   contained start=/\S/ end=/$/ contains=hapComment,hapEscape,hapBackRef
-syn region  hapRegexp2   contained start=/\S/ end=/\(\s\|$\)/ skip=/\\ / nextgroup=hapSectLabel skipwhite
-syn match   hapBackref   contained /\\\d/
-
-
-" Transparent is a Vim keyword, so we need a regexp to match it
-syn match   hapParam     +transparent+
-syn match   hapOption    +transparent+ contained
-
-
-" Define the default highlighting.
-" For version 5.7 and earlier: only when not done already
-" For version 5.8 and later: only when an item doesn't have highlighting yet
-if version < 508
-	command -nargs=+ HiLink hi link <args>
-else
-	command -nargs=+ HiLink hi def link <args>
-endif
-
-HiLink      hapEscape    SpecialChar
-HiLink      hapBackRef   Special
-HiLink      hapComment   Comment
-HiLink      hapTodo      Todo
-HiLink      hapSection   Constant
-HiLink      hapSectLabel Identifier
-HiLink      hapParam     Keyword
-
-HiLink      hapRegexp    String
-HiLink      hapRegexp2   hapRegexp
-HiLink      hapIp1       Number
-HiLink      hapIp2       hapIp1
-HiLink      hapLogIp     hapIp1
-HiLink      hapIpPort    hapIp1
-HiLink      hapIPv4Mask  hapIp1
-HiLink      hapServerAd  hapIp1
-HiLink      hapStatus    Number
-
-HiLink      hapOption    Operator
-HiLink      hapAppSess   hapOption
-HiLink      hapBalance   hapOption
-HiLink      hapCapture   hapOption
-HiLink      hapCookieKey hapOption
-HiLink      hapHeader    hapOption
-HiLink      hapGLog      hapOption
-HiLink      hapLogFac    hapOption
-HiLink      hapLogLvl    hapOption
-HiLink      hapMode      hapOption
-HiLink      hapStats     hapOption
-HiLink      hapLen       hapOption
-HiLink      hapSrvKey    hapOption
-
-
-delcommand HiLink
-
-let b:current_syntax = "haproxy"
-" vim: ts=8
diff --git a/deps/haproxy-1.4.21/examples/init.haproxy b/deps/haproxy-1.4.21/examples/init.haproxy
deleted file mode 100644
index 295d50a..0000000
--- a/deps/haproxy-1.4.21/examples/init.haproxy
+++ /dev/null
@@ -1,55 +0,0 @@
-#!/bin/sh
-#
-# config.rc sample with defaults :
-# service haproxy
-#   config /etc/haproxy/haproxy.cfg
-#   maxconn 1024
-#
-config="/etc/haproxy/haproxy.cfg"
-maxconn=1024
-
-bin=/usr/sbin/haproxy
-cmdline='$bin -D'
-
-. $ROOT/sbin/init.d/default 
-
-if [ -e "$config" ]; then
-   maintfd=`grep '^\([^#]*\)\(listen\|server\)' $config|wc -l`
-else
-   maintfd=0
-fi
-
-maxfd=$[$maxconn*2 + $maintfd]
-if [ $maxfd -lt 100 ]; then
-   maxfd=100;
-fi
-cmdline="$cmdline -n $maxconn -f $config"
-ulimit -n $maxfd
-
-# to get a core when needed, uncomment the following :
-# cd /var/tmp
-# ulimit -c unlimited
-
-# soft stop
-function do_stop {
-   pids=`pidof -o $$ -- $PNAME`
-   if [ ! -z "$pids" ]; then
-      echo "Asking $PNAME to terminate gracefully..."
-      kill -USR1 $pids
-      echo "(use kill $pids to stop immediately)."
-   fi
-}
-
-# dump status
-function do_status {
-   pids=`pidof -o $$ -- $PNAME`
-   if [ ! -z "$pids" ]; then
-      echo "Dumping $PNAME status in logs."
-      kill -HUP $pids
-   else
-      echo "Process $PNAME is not running."
-   fi
-}
-
-main $*
-
diff --git a/deps/haproxy-1.4.21/examples/init.haproxy.flx0 b/deps/haproxy-1.4.21/examples/init.haproxy.flx0
deleted file mode 100644
index a7edd9c..0000000
--- a/deps/haproxy-1.4.21/examples/init.haproxy.flx0
+++ /dev/null
@@ -1,29 +0,0 @@
-#!/bin/bash
-
-. `dirname $0`/functions
-
-option	config		standard_option	/etc/haproxy/haproxy.cfg
-option	bin		reserved_option	/usr/sbin/haproxy
-option	cmdline		reserved_option	'$bin -f ${opt_config} -p ${pidfile} -D -q'
-
-function do_help {
-    echo "Usage: ${0##*/} <status|start|stop|help|conf>"
-    echo "List of config.rc options (name, type, default value, current value) :"
-    echo
-    echo "   - config ; def=/etc/haproxy/haproxy.cfg ; cur=$opt_confdir"
-    echo
-    exit 1 
-}
-
-# reads the configuration file and checks its syntax.
-function do_conf {
-    $bin -c -V -q -f ${opt_config}
-}
-
-# assign default values to options and variables before parsing the cfg file
-function fct_begin_section {
-    pidfile="/var/run/haproxy${2:+-$2}.pid"
-}
-
-load_config
-
diff --git a/deps/haproxy-1.4.21/examples/linux-2.4.21-40.EL-custom.diff b/deps/haproxy-1.4.21/examples/linux-2.4.21-40.EL-custom.diff
deleted file mode 100644
index a96c800..0000000
--- a/deps/haproxy-1.4.21/examples/linux-2.4.21-40.EL-custom.diff
+++ /dev/null
@@ -1,138 +0,0 @@
-diff -urN linux-2.4.21-40.EL/arch/i386/config.in linux-2.4.21-40.EL-epoll/arch/i386/config.in
---- linux-2.4.21-40.EL/arch/i386/config.in	2006-03-17 09:34:24.000000000 +0100
-+++ linux-2.4.21-40.EL-epoll/arch/i386/config.in	2006-03-17 09:34:42.000000000 +0100
-@@ -380,6 +380,7 @@
- tristate 'Kernel support for MISC binaries' CONFIG_BINFMT_MISC
- 
- bool 'Kernel .config support' CONFIG_IKCONFIG
-+bool 'Support for epoll' CONFIG_EPOLL
- 
- tristate 'System call auditing' CONFIG_AUDIT
- 
-diff -urN linux-2.4.21-40.EL/arch/i386/kernel/entry.S linux-2.4.21-40.EL-epoll/arch/i386/kernel/entry.S
---- linux-2.4.21-40.EL/arch/i386/kernel/entry.S	2006-03-17 09:34:24.000000000 +0100
-+++ linux-2.4.21-40.EL-epoll/arch/i386/kernel/entry.S	2006-03-17 09:34:42.000000000 +0100
-@@ -816,9 +816,15 @@
- 	.long SYMBOL_NAME(sys_ni_syscall)	/* sys_free_hugepages */
- 	.long SYMBOL_NAME(sys_exit_group)
- 	.long SYMBOL_NAME(sys_lookup_dcookie)
-+#ifdef CONFIG_EPOLL
-+	.long SYMBOL_NAME(sys_epoll_create)
-+	.long SYMBOL_NAME(sys_epoll_ctl)	/* 255 */
-+	.long SYMBOL_NAME(sys_epoll_wait)
-+#else
- 	.long SYMBOL_NAME(sys_ni_syscall)	/* sys_epoll_create */
- 	.long SYMBOL_NAME(sys_ni_syscall)	/* sys_epoll_ctl 255 */
- 	.long SYMBOL_NAME(sys_ni_syscall)	/* sys_epoll_wait */
-+#endif /* CONFIG_EPOLL */
-  	.long sys_remap_file_pages
-  	.long SYMBOL_NAME(sys_set_tid_address)
-  	.long SYMBOL_NAME(sys_ni_syscall)	/* sys_timer_create */
-diff -urN linux-2.4.21-40.EL/configs/kernel-2.4.21-athlon.config linux-2.4.21-40.EL-epoll/configs/kernel-2.4.21-athlon.config
---- linux-2.4.21-40.EL/configs/kernel-2.4.21-athlon.config	2006-03-17 09:34:24.000000000 +0100
-+++ linux-2.4.21-40.EL-epoll/configs/kernel-2.4.21-athlon.config	2006-03-17 09:34:42.000000000 +0100
-@@ -1575,7 +1575,7 @@
- CONFIG_QUOTA=y
- # CONFIG_QFMT_V1 is not set
- CONFIG_QFMT_V2=y
--# CONFIG_EPOLL is not set
-+CONFIG_EPOLL=y
- 
- # CONFIG_QIFACE_COMPAT is not set
- CONFIG_AFS_FS=m
-diff -urN linux-2.4.21-40.EL/configs/kernel-2.4.21-athlon-smp.config linux-2.4.21-40.EL-epoll/configs/kernel-2.4.21-athlon-smp.config
---- linux-2.4.21-40.EL/configs/kernel-2.4.21-athlon-smp.config	2006-03-17 09:34:24.000000000 +0100
-+++ linux-2.4.21-40.EL-epoll/configs/kernel-2.4.21-athlon-smp.config	2006-03-17 09:34:42.000000000 +0100
-@@ -1575,7 +1575,7 @@
- CONFIG_QUOTA=y
- # CONFIG_QFMT_V1 is not set
- CONFIG_QFMT_V2=y
--# CONFIG_EPOLL is not set
-+CONFIG_EPOLL=y
- 
- # CONFIG_QIFACE_COMPAT is not set
- CONFIG_AFS_FS=m
-diff -urN linux-2.4.21-40.EL/configs/kernel-2.4.21-i386.config linux-2.4.21-40.EL-epoll/configs/kernel-2.4.21-i386.config
---- linux-2.4.21-40.EL/configs/kernel-2.4.21-i386.config	2006-03-17 09:34:24.000000000 +0100
-+++ linux-2.4.21-40.EL-epoll/configs/kernel-2.4.21-i386.config	2006-03-17 09:34:42.000000000 +0100
-@@ -1575,7 +1575,7 @@
- CONFIG_QUOTA=y
- # CONFIG_QFMT_V1 is not set
- CONFIG_QFMT_V2=y
--# CONFIG_EPOLL is not set
-+CONFIG_EPOLL=y
- 
- # CONFIG_QIFACE_COMPAT is not set
- # CONFIG_AFS_FS is not set
-diff -urN linux-2.4.21-40.EL/configs/kernel-2.4.21-i586.config linux-2.4.21-40.EL-epoll/configs/kernel-2.4.21-i586.config
---- linux-2.4.21-40.EL/configs/kernel-2.4.21-i586.config	2006-03-17 09:34:24.000000000 +0100
-+++ linux-2.4.21-40.EL-epoll/configs/kernel-2.4.21-i586.config	2006-03-17 09:34:42.000000000 +0100
-@@ -1575,7 +1575,7 @@
- CONFIG_QUOTA=y
- # CONFIG_QFMT_V1 is not set
- CONFIG_QFMT_V2=y
--# CONFIG_EPOLL is not set
-+CONFIG_EPOLL=y
- 
- # CONFIG_QIFACE_COMPAT is not set
- CONFIG_AFS_FS=m
-diff -urN linux-2.4.21-40.EL/configs/kernel-2.4.21-i586-smp.config linux-2.4.21-40.EL-epoll/configs/kernel-2.4.21-i586-smp.config
---- linux-2.4.21-40.EL/configs/kernel-2.4.21-i586-smp.config	2006-03-17 09:34:24.000000000 +0100
-+++ linux-2.4.21-40.EL-epoll/configs/kernel-2.4.21-i586-smp.config	2006-03-17 09:34:42.000000000 +0100
-@@ -1575,7 +1575,7 @@
- CONFIG_QUOTA=y
- # CONFIG_QFMT_V1 is not set
- CONFIG_QFMT_V2=y
--# CONFIG_EPOLL is not set
-+CONFIG_EPOLL=y
- 
- # CONFIG_QIFACE_COMPAT is not set
- CONFIG_AFS_FS=m
-diff -urN linux-2.4.21-40.EL/configs/kernel-2.4.21-i686.config linux-2.4.21-40.EL-epoll/configs/kernel-2.4.21-i686.config
---- linux-2.4.21-40.EL/configs/kernel-2.4.21-i686.config	2006-03-17 09:34:24.000000000 +0100
-+++ linux-2.4.21-40.EL-epoll/configs/kernel-2.4.21-i686.config	2006-03-17 09:34:42.000000000 +0100
-@@ -1575,7 +1575,7 @@
- CONFIG_QUOTA=y
- # CONFIG_QFMT_V1 is not set
- CONFIG_QFMT_V2=y
--# CONFIG_EPOLL is not set
-+CONFIG_EPOLL=y
- 
- # CONFIG_QIFACE_COMPAT is not set
- CONFIG_AFS_FS=m
-diff -urN linux-2.4.21-40.EL/configs/kernel-2.4.21-i686-hugemem.config linux-2.4.21-40.EL-epoll/configs/kernel-2.4.21-i686-hugemem.config
---- linux-2.4.21-40.EL/configs/kernel-2.4.21-i686-hugemem.config	2006-03-17 09:34:24.000000000 +0100
-+++ linux-2.4.21-40.EL-epoll/configs/kernel-2.4.21-i686-hugemem.config	2006-03-17 09:34:42.000000000 +0100
-@@ -1575,7 +1575,7 @@
- CONFIG_QUOTA=y
- # CONFIG_QFMT_V1 is not set
- CONFIG_QFMT_V2=y
--# CONFIG_EPOLL is not set
-+CONFIG_EPOLL=y
- 
- # CONFIG_QIFACE_COMPAT is not set
- CONFIG_AFS_FS=m
-diff -urN linux-2.4.21-40.EL/configs/kernel-2.4.21-i686-smp.config linux-2.4.21-40.EL-epoll/configs/kernel-2.4.21-i686-smp.config
---- linux-2.4.21-40.EL/configs/kernel-2.4.21-i686-smp.config	2006-03-17 09:34:24.000000000 +0100
-+++ linux-2.4.21-40.EL-epoll/configs/kernel-2.4.21-i686-smp.config	2006-03-17 09:34:42.000000000 +0100
-@@ -1575,7 +1575,7 @@
- CONFIG_QUOTA=y
- # CONFIG_QFMT_V1 is not set
- CONFIG_QFMT_V2=y
--# CONFIG_EPOLL is not set
-+CONFIG_EPOLL=y
- 
- # CONFIG_QIFACE_COMPAT is not set
- CONFIG_AFS_FS=m
-diff -urN linux-2.4.21-40.EL/Makefile linux-2.4.21-40.EL-epoll/Makefile
---- linux-2.4.21-40.EL/Makefile	2006-03-17 09:34:24.000000000 +0100
-+++ linux-2.4.21-40.EL-epoll/Makefile	2006-03-17 09:34:55.000000000 +0100
-@@ -1,7 +1,7 @@
- VERSION = 2
- PATCHLEVEL = 4
- SUBLEVEL = 21
--EXTRAVERSION = -40.ELcustom
-+EXTRAVERSION = -40.EL-epoll
- 
- KERNELRELEASE=$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
- 
diff --git a/deps/haproxy-1.4.21/examples/option-http_proxy.cfg b/deps/haproxy-1.4.21/examples/option-http_proxy.cfg
deleted file mode 100644
index 8f73c3b..0000000
--- a/deps/haproxy-1.4.21/examples/option-http_proxy.cfg
+++ /dev/null
@@ -1,53 +0,0 @@
-#
-# demo config for Proxy mode
-# 
-
-global
-        maxconn         20000
-	ulimit-n	16384
-        log             127.0.0.1 local0
-        uid             200
-        gid             200
-        chroot          /var/empty
-	nbproc		4
-        daemon
-
-frontend test-proxy
-	bind		192.168.200.10:8080
-        mode            http
-        log             global
-        option          httplog
-        option          dontlognull
-        option          httpclose
-        option          nolinger
-        option          http_proxy
-        maxconn         8000
-        clitimeout      30000
-
-	# layer3: Valid users
-	acl allow_host src 192.168.200.150/32
-	block if !allow_host
-
-	# layer7: prevent private network relaying
-	acl forbidden_dst url_ip 192.168.0.0/24
-	acl forbidden_dst url_ip 172.16.0.0/12
-	acl forbidden_dst url_ip 10.0.0.0/8
-	block if forbidden_dst
-
-	default_backend test-proxy-srv
-
-
-backend test-proxy-srv
-	mode            http
-	contimeout      5000
-	srvtimeout      5000
-	retries         2
-	option          nolinger
-	option          http_proxy
-
-	# layer7: Only GET method is valid
-	acl valid_method        method GET
-	block if !valid_method
-
-	# layer7: protect bad reply
-	rspdeny ^Content-Type:[\ ]*audio/mp3
diff --git a/deps/haproxy-1.4.21/examples/rc.highsock b/deps/haproxy-1.4.21/examples/rc.highsock
deleted file mode 100644
index d85935a..0000000
--- a/deps/haproxy-1.4.21/examples/rc.highsock
+++ /dev/null
@@ -1,38 +0,0 @@
-#!/bin/sh
-# set this to about 256/4M (16384 for 256M machine)
-MAXFILES=16384
-echo $MAXFILES > /proc/sys/fs/file-max
-ulimit -n $MAXFILES
-
-if [ -e /proc/sys/net/ipv4/ip_conntrack_max ]; then
-	echo 65536 > /proc/sys/net/ipv4/ip_conntrack_max
-fi
-
-if [ -e /proc/sys/net/ipv4/netfilter/ip_conntrack_tcp_timeout_fin_wait ]; then
-	# 30 seconds for fin, 15 for time wait
-	echo 3000 > /proc/sys/net/ipv4/netfilter/ip_conntrack_tcp_timeout_fin_wait
-	echo 1500 > /proc/sys/net/ipv4/netfilter/ip_conntrack_tcp_timeout_time_wait
-	echo 0 > /proc/sys/net/ipv4/netfilter/ip_conntrack_tcp_log_invalid_scale
-	echo 0 > /proc/sys/net/ipv4/netfilter/ip_conntrack_tcp_log_out_of_window
-fi
-
-echo 1024 60999 > /proc/sys/net/ipv4/ip_local_port_range
-#echo 32768 > /proc/sys/net/ipv4/ip_queue_maxlen
-echo 30 > /proc/sys/net/ipv4/tcp_fin_timeout
-echo 4096 > /proc/sys/net/ipv4/tcp_max_syn_backlog
-echo 262144 > /proc/sys/net/ipv4/tcp_max_tw_buckets
-echo 262144 > /proc/sys/net/ipv4/tcp_max_orphans
-echo 300 > /proc/sys/net/ipv4/tcp_keepalive_time
-echo 1 > /proc/sys/net/ipv4/tcp_tw_recycle
-echo 0 > /proc/sys/net/ipv4/tcp_timestamps
-echo 0 > /proc/sys/net/ipv4/tcp_ecn
-echo 0 > /proc/sys/net/ipv4/tcp_sack
-echo 0 > /proc/sys/net/ipv4/tcp_dsack
-
-# auto-tuned on 2.4
-#echo 262143 > /proc/sys/net/core/rmem_max
-#echo 262143 > /proc/sys/net/core/rmem_default
-
-echo 16384 65536 524288 > /proc/sys/net/ipv4/tcp_rmem
-echo 16384 349520 699040 > /proc/sys/net/ipv4/tcp_wmem
-
diff --git a/deps/haproxy-1.4.21/examples/stats_haproxy.sh b/deps/haproxy-1.4.21/examples/stats_haproxy.sh
deleted file mode 100644
index 25f23d3..0000000
--- a/deps/haproxy-1.4.21/examples/stats_haproxy.sh
+++ /dev/null
@@ -1,78 +0,0 @@
-#!/bin/bash
-
-## contrib by prizee.com
-
-socket='/var/run/haproxy.stat'
-
-if ! type socat >/dev/null 2>&1 ; then
-    echo "can't find socat in PATH" 1>&2
-    exit 1
-fi
-
-printUsage ()
-{
-    echo -e "Usage : $(basename $0) [options] -s section
---section -s section\t: section to use ( --list format)
-Options :
---socket -S [socket]\t: socket to use (default: /var/run/haproxy.stat)
---list -l\t\t: print available sections
---help -h\t\t: print this  message"
-}
-
-getRawStat ()
-{
-    if [ ! -S $socket ] ; then
-	echo "$socket socket unavailable" 1>&2
-	exit 1
-    fi
-
-    if ! printf "show stat\n" | socat unix-connect:${socket} stdio | grep -v "^#" ; then
-	echo "cannot read $socket" 1>&2
-	exit 1
-    fi
-}
-
-getStat ()
-{
-    stats=$(getRawStat | grep $1 | awk -F "," '{print $5" "$8}')
-    export cumul=$(echo $stats | cut -d " " -f2)
-    export current=$(echo $stats | cut -d " " -f1)
-}
-
-showList ()
-{
-    getRawStat | awk -F "," '{print $1","$2}'
-}
-
-set -- `getopt -u -l socket:,section:,list,help -- s:S:lh "$@"`
-
-while true ; do
-    case $1 in
-	--socket|-S) socket=$2 ; shift 2 ;;
-	--section|-s) section=$2 ; shift 2 ;;
-	--help|-h) printUsage ; exit 0 ;;
-	--list|-l) showList ; exit 0 ;;
-	--) break ;;
-    esac
-done
-
-if [ "$section" = "" ] ; then
-    echo "section not specified, run '$(basename $0) --list' to know available sections" 1>&2
-    printUsage
-    exit 1
-fi
-
-cpt=0
-totalrate=0
-while true ; do
-    getStat $section
-    if [ "$cpt" -gt "0" ] ; then
-	sessionrate=$(($cumul-$oldcumul))
-	totalrate=$(($totalrate+$sessionrate))
-	averagerate=$(($totalrate/$cpt))
-	printf "$sessionrate sessions/s (avg: $averagerate )\t$current concurrent sessions\n"
-    fi
-    oldcumul=$cumul
-    sleep 1
-    cpt=$(($cpt+1))
-done
diff --git a/deps/haproxy-1.4.21/examples/tarpit.cfg b/deps/haproxy-1.4.21/examples/tarpit.cfg
deleted file mode 100644
index e5c9298..0000000
--- a/deps/haproxy-1.4.21/examples/tarpit.cfg
+++ /dev/null
@@ -1,72 +0,0 @@
-# This configuration is an example of how to use connection tarpitting based
-# on invalid requests.
-
-global
-        daemon
-        log 127.0.0.1 local0
-
-listen  frontend 0.0.0.0:80
-        mode    http
-        option  httplog
-        log     global
-        maxconn 10000
-
-	# do not log requests with no data
-        option  dontlognull
-
-	# log as soon as the server starts to respond, an do not wait for the
-	# end of the data transfer.
-        option  logasap
-
-	# disable keep-alive
-        option  httpclose
-
-	# load balancing mode set to round-robin
-        balance roundrobin
-
-        # the maxconn 150 below means 150 connections maximum will be used
-        # on apache, the remaining ones will be queued.
-	server  apache1 127.0.0.1:80 maxconn 150
-
-        # use short timeouts for client and server
-        clitimeout      20000
-        srvtimeout      20000
-
-	# the connect timeout should be large because it will also be used
-	# to define the queue timeout and the tarpit timeout. It generally
-	# is a good idea to set it to the same value as both above, and it
-	# will improve performance when dealing with thousands of connections.
-        contimeout      20000
-
-	# retry only once when a valid connection fails because the server
-	# is overloaded.
-        retries 1
-
-        # You might want to enable this option if the attacks start
-        # targetting valid URLs.
-        # option abortonclose
-
-	# not needed anymore.
-	#capture request header X-Forwarded-For len 15
-
-	# and add a new 'X-Forwarded-For: IP'	
-        option  forwardfor
-
-	# how to access the status reporting web interface
-        stats uri /stat
-        stats auth stat:stat
-
-	# Request header and URI processing begins here.
-
-	# rename the 'X-Forwarded-For:' header as 'X-Forwarded-For2:'
-        reqirep ^(X-Forwarded-For:)(.*) X-Forwarded-For2:\2
-
-	#### Now check the URI for requests we want to tarpit ###
-	# We do not analyze headers, we just focus on the request
-	reqpass ^[^:\ ]*:
-
-	# Tarpit those URIs for any method
-        reqtarpit  ^[^:\ ]*\ /invalid_req1
-        reqtarpit  ^[^:\ ]*\ /cgi-bin/.*\.pl\?
-        reqitarpit ^[^:\ ]*\ /.*\.(dll|exe|asp)
-
diff --git a/deps/haproxy-1.4.21/examples/test-section-kw.cfg b/deps/haproxy-1.4.21/examples/test-section-kw.cfg
deleted file mode 100644
index f1bece7..0000000
--- a/deps/haproxy-1.4.21/examples/test-section-kw.cfg
+++ /dev/null
@@ -1,26 +0,0 @@
-# This is a test configuration. It must produce errors with the correct
-# section types.
-
-# out of section keyword
-#keyword_out
-
-global
-	# unknown keyword in section 'global'
-	#keyword_glob
-
-defaults
-	# unknown keyword in section 'global'
-	#keyword_def
-
-listen  listen1
-	# unknown keyword in section 'listen'
-	#keyword_lis
-
-frontend front1
-	# unknown keyword in section 'frontend'
-	#keyword_frt
-
-backend back1
-	# unknown keyword in section 'backend'
-	#keyword_bck
-
diff --git a/deps/haproxy-1.4.21/examples/url-switching.cfg b/deps/haproxy-1.4.21/examples/url-switching.cfg
deleted file mode 100644
index 3d3d86b..0000000
--- a/deps/haproxy-1.4.21/examples/url-switching.cfg
+++ /dev/null
@@ -1,120 +0,0 @@
-#
-# This configuration can be used as an example of how URL-switching may be
-# implemented with current haproxy versions.
-#
-# Right now (version 1.2), haproxy can only select a server based on the cookie
-# provided by the client. While this may sound limitated, it is yet possible to
-# combine this feature to rewrites to provide full URL-switching capabilities.
-#
-# For this, we have to chain 3 levels :
-#  - front-end : will match the expected URIs and assign a cookie accordingly ;
-#                it uses regexps and could match on anything else (Host:,
-#                cookies, ...)
-#  - switch    : will select a back-end depending on the cookie above
-#  - back-ends : will perform the load balancing between multiple servers for
-#                the same group. Note that this level can be omitted if there
-#                is only one server for each backend.
-#
-# Logging is performed at the lower level (back-ends) so that local server
-# problems can be identified quickly with the timers. The client's IP is
-# propagated in the X-Forwarded-For: header.
-#
-
-global
-	daemon
-	maxconn 6000      # warning: this has to be 3 times the expected value!
-	log 192.168.0.1 local0
-
-defaults
-	mode	http
-	balance roundrobin
-	option	dontlognull
-	option	httpclose
-	retries	1
-	redispatch
-	maxconn		2000
-	contimeout	5000
-	clitimeout	50000
-	srvtimeout	50000
-
-#
-# This is the instance the client connects to.
-#
-listen	frontend 10.20.30.40:80
-	option forwardfor		# add 'X-Forwarded-For: IP'
-
-	# remove an eventual 'backend' cookie the client might have sent
-	reqidel ^Cookie:\ backend=
-
-	# add cookie 'backend=2' for any HTTP method followed by
-	#  '/img' only or '/img/' followed by anything.
-	reqirep ^[^:\ ]*\ /img[/\ ].* \0\nCookie:\ backend=2
-
-	# add cookie 'backend=3' for any HTTP method followed by
-	#  '/home' only or '/home/' followed by anything.
-	reqirep ^[^:\ ]*\ /home[/\ ].*   \0\nCookie:\ backend=3
-
-	# send everything to next stage
-	server	switch 127.0.0.2:8000
-
-
-#
-# This instance is only seen by the 'frontend' instance above. It receives all
-# of its traffic.
-#
-listen switch 127.0.0.2:8000
-	# cookie name 'backend' inserted by the 'frontend' instance above
-	cookie backend
-
-	# default server 'backend1' gets the default traffic.
-	server backend1 127.0.0.3:8001
-
-	# those servers get traffic only if their cookie is present because
-	# they are tagged 'backup'.
-	server backend2 127.0.0.3:8002 cookie 2 backup
-	server backend3 127.0.0.3:8003 cookie 3 backup
-
-#
-# Backend 1 for dynamic contents.
-# It is made of 4 apache servers which we can test thanks to a CGI script.
-#
-listen	backend1 127.0.0.3:8001
-	log	global
-	option	httplog
-	capture request header X-Forwarded-For len 15
-	option	httpchk /cgi-bin/testhost.pl
-	server	apache1 192.168.1.1:80 maxconn 100 check inter 2000 fall 3
-	server	apache2 192.168.1.2:80 maxconn 100 check inter 2000 fall 3
-	server	apache3 192.168.1.3:80 maxconn 100 check inter 2000 fall 3
-	server	apache4 192.168.1.4:80 maxconn 100 check inter 2000 fall 3
-
-#
-# backend 2 for images (/img).
-# It is made of 3 Tux servers which we test by requesting the /img/logo.png
-# file which should be present when file-systems are mounted.
-#
-listen	backend2 127.0.0.3:8002
-	log	global
-	option	httplog
-	capture request header X-Forwarded-For len 15
-	option	httpchk /img/logo.png
-	server	tux5 192.168.1.5:80 check inter 2000 fall 3
-	server	tux6 192.168.1.6:80 check inter 2000 fall 3
-	server	tux7 192.168.1.7:80 check inter 2000 fall 3
-
-#
-# backend 3 for home directories (/home). These are the same machines as for
-# dynamic content, except that a different server is bound to another port.
-# We test the service by checking that the file "/home/webmaster/started"
-# exists.
-#
-listen	backend3 127.0.0.3:8003
-	log	global
-	option	httplog
-	capture request header X-Forwarded-For len 15
-	option	httpchk /home/webmaster/started
-	server	light1 192.168.1.1:8080 check inter 2000 fall 3
-	server	light2 192.168.1.2:8080 check inter 2000 fall 3
-	server	light3 192.168.1.3:8080 check inter 2000 fall 3
-	server	light4 192.168.1.4:8080 check inter 2000 fall 3
-
diff --git a/deps/haproxy-1.4.21/haproxy-1.4.x-sendproxy.patch b/deps/haproxy-1.4.21/haproxy-1.4.x-sendproxy.patch
deleted file mode 100644
index 26906d4..0000000
--- a/deps/haproxy-1.4.21/haproxy-1.4.x-sendproxy.patch
+++ /dev/null
@@ -1,441 +0,0 @@
---- a/doc/configuration.txt
-+++ b/doc/configuration.txt
-@@ -1337,6 +1337,7 @@ bind [<address>]:<port_range> [, ...] tr
- bind [<address>]:<port_range> [, ...] id <id>
- bind [<address>]:<port_range> [, ...] name <name>
- bind [<address>]:<port_range> [, ...] defer-accept
-+bind [<address>]:<port_range> [, ...] accept-proxy
-   Define one or several listening addresses and/or ports in a frontend.
-   May be used in sections :   defaults | frontend | listen | backend
-                                   no   |    yes   |   yes  |   no
-@@ -1417,6 +1418,19 @@ bind [<address>]:<port_range> [, ...] de
-                   with front firewalls which would see an established
-                   connection while the proxy will only see it in SYN_RECV.
- 
-+    accept-proxy  is an optional keyword which enforces use of the PROXY
-+                  protocol over any connection accepted by this listener. The
-+                  PROXY protocol dictates the layer 3/4 addresses of the
-+                  incoming connection to be used everywhere an address is used,
-+                  with the only exception of "tcp-request connection" rules
-+                  which will only see the real connection address. Logs will
-+                  reflect the addresses indicated in the protocol, unless it is
-+                  violated, in which case the real address will still be used.
-+                  This keyword combined with support from external components
-+                  can be used as an efficient and reliable alternative to the
-+                  X-Forwarded-For mechanism which is not always reliable and
-+                  not even always usable.
-+
-   It is possible to specify a list of address:port combinations delimited by
-   commas. The frontend will then listen on all of these addresses. There is no
-   fixed limit to the number of addresses and ports which can be listened on in
-@@ -1427,8 +1441,10 @@ bind [<address>]:<port_range> [, ...] de
-         listen http_proxy
-             bind :80,:443
-             bind 10.0.0.1:10080,10.0.0.1:10443
-+            bind 127.0.0.1:8443 accept-proxy
- 
--  See also : "source".
-+  See also : "source", "option forwardfor" and the PROXY protocol
-+             documentation.
- 
- 
- bind-process [ all | odd | even | <number 1-32> ] ...
-@@ -7215,7 +7231,9 @@ marked with a star ('*') after the field
- 
- Detailed fields description :
-   - "client_ip" is the IP address of the client which initiated the TCP
--    connection to haproxy.
-+    connection to haproxy. Note that when the connection is accepted on a
-+    socket configured with "accept-proxy" and the PROXY protocol is correctly
-+    used, then the logs will reflect the forwarded connection's information.
- 
-   - "client_port" is the TCP port of the client which initiated the connection.
- 
-@@ -7388,7 +7406,9 @@ with a star ('*') after the field name b
- 
- Detailed fields description :
-   - "client_ip" is the IP address of the client which initiated the TCP
--    connection to haproxy.
-+    connection to haproxy. Note that when the connection is accepted on a
-+    socket configured with "accept-proxy" and the PROXY protocol is correctly
-+    used, then the logs will reflect the forwarded connection's information.
- 
-   - "client_port" is the TCP port of the client which initiated the connection.
- 
---- a/include/common/standard.h
-+++ b/include/common/standard.h
-@@ -269,6 +269,28 @@ static inline unsigned int __strl2uic(co
- 	return i;
- }
- 
-+/* This function reads an unsigned integer from the string pointed to by <s>
-+ * and returns it. The <s> pointer is adjusted to point to the first unread
-+ * char. The function automatically stops at <end>.
-+ */
-+static inline unsigned int __read_uint(const char **s, const char *end)
-+{
-+	const char *ptr = *s;
-+	unsigned int i = 0;
-+	unsigned int j, k;
-+
-+	while (ptr < end) {
-+		j = *ptr - '0';
-+		k = i * 10;
-+		if (j > 9)
-+			break;
-+		i = k + j;
-+		ptr++;
-+	}
-+	*s = ptr;
-+	return i;
-+}
-+
- extern unsigned int str2ui(const char *s);
- extern unsigned int str2uic(const char *s);
- extern unsigned int strl2ui(const char *s, int len);
-@@ -276,6 +298,7 @@ extern unsigned int strl2uic(const char 
- extern int strl2ic(const char *s, int len);
- extern int strl2irc(const char *s, int len, int *ret);
- extern int strl2llrc(const char *s, int len, long long *ret);
-+extern unsigned int read_uint(const char **s, const char *end);
- unsigned int inetaddr_host(const char *text);
- unsigned int inetaddr_host_lim(const char *text, const char *stop);
- unsigned int inetaddr_host_lim_ret(const char *text, char *stop, const char **ret);
---- a/include/proto/client.h
-+++ b/include/proto/client.h
-@@ -25,6 +25,7 @@
- #include <common/config.h>
- #include <types/session.h>
- 
-+int frontend_decode_proxy_request(struct session *s, struct buffer *req, int an_bit);
- void get_frt_addr(struct session *s);
- int event_accept(int fd);
- 
---- a/include/types/buffers.h
-+++ b/include/types/buffers.h
-@@ -135,16 +135,16 @@
-  * The field is blanked by buffer_init() and only by analysers themselves
-  * afterwards.
-  */
--#define AN_REQ_INSPECT          0x00000001  /* inspect request contents */
--#define AN_REQ_WAIT_HTTP        0x00000002  /* wait for an HTTP request */
--#define AN_REQ_HTTP_PROCESS_FE  0x00000004  /* process the frontend's HTTP part */
--#define AN_REQ_SWITCHING_RULES  0x00000008  /* apply the switching rules */
--#define AN_REQ_HTTP_PROCESS_BE  0x00000010  /* process the backend's HTTP part */
--#define AN_REQ_HTTP_INNER       0x00000020  /* inner processing of HTTP request */
--#define AN_REQ_HTTP_TARPIT      0x00000040  /* wait for end of HTTP tarpit */
--#define AN_REQ_HTTP_BODY        0x00000080  /* inspect HTTP request body */
--#define AN_REQ_STICKING_RULES   0x00000100  /* table persistence matching */
--/* unused: 0x200 */
-+#define AN_REQ_DECODE_PROXY     0x00000001  /* take the proxied address from a 'PROXY' line */
-+#define AN_REQ_INSPECT          0x00000002  /* inspect request contents */
-+#define AN_REQ_WAIT_HTTP        0x00000004  /* wait for an HTTP request */
-+#define AN_REQ_HTTP_PROCESS_FE  0x00000008  /* process the frontend's HTTP part */
-+#define AN_REQ_SWITCHING_RULES  0x00000010  /* apply the switching rules */
-+#define AN_REQ_HTTP_PROCESS_BE  0x00000020  /* process the backend's HTTP part */
-+#define AN_REQ_HTTP_INNER       0x00000040  /* inner processing of HTTP request */
-+#define AN_REQ_HTTP_TARPIT      0x00000080  /* wait for end of HTTP tarpit */
-+#define AN_REQ_HTTP_BODY        0x00000100  /* inspect HTTP request body */
-+#define AN_REQ_STICKING_RULES   0x00000200  /* table persistence matching */
- #define AN_REQ_PRST_RDP_COOKIE  0x00000400  /* persistence on rdp cookie */
- #define AN_REQ_HTTP_XFER_BODY   0x00000800  /* forward request body */
- 
---- a/include/types/protocols.h
-+++ b/include/types/protocols.h
-@@ -72,6 +72,7 @@
- #define LI_O_FOREIGN	0x0002	/* permit listening on foreing addresses */
- #define LI_O_NOQUICKACK	0x0004	/* disable quick ack of immediate data (linux) */
- #define LI_O_DEF_ACCEPT	0x0008	/* wait up to 1 second for data before accepting */
-+#define LI_O_ACC_PROXY  0x0010  /* find the proxied address in the first request line */
- 
- /* The listener will be directly referenced by the fdtab[] which holds its
-  * socket. The listener provides the protocol-specific accept() function to
---- a/src/cfgparse.c
-+++ b/src/cfgparse.c
-@@ -1466,6 +1466,16 @@ int cfg_parse_listen(const char *file, i
- #endif
- 			}
- 
-+			if (!strcmp(args[cur_arg], "accept-proxy")) { /* expect a 'PROXY' line first */
-+				struct listener *l;
-+
-+				for (l = curproxy->listen; l != last_listen; l = l->next)
-+					l->options |= LI_O_ACC_PROXY;
-+
-+				cur_arg ++;
-+				continue;
-+			}
-+
- 			if (!strcmp(args[cur_arg], "name")) {
- 				struct listener *l;
- 
-@@ -1518,7 +1528,7 @@ int cfg_parse_listen(const char *file, i
- 				continue;
- 			}
- 
--			Alert("parsing [%s:%d] : '%s' only supports the 'transparent', 'defer-accept', 'name', 'id', 'mss' and 'interface' options.\n",
-+			Alert("parsing [%s:%d] : '%s' only supports the 'transparent', 'accept-proxy', 'defer-accept', 'name', 'id', 'mss' and 'interface' options.\n",
- 			      file, linenum, args[0]);
- 			err_code |= ERR_ALERT | ERR_FATAL;
- 			goto out;
-@@ -5731,6 +5741,9 @@ out_uri_auth_compat:
- 			listener->handler = process_session;
- 			listener->analysers |= curproxy->fe_req_ana;
- 
-+			if (listener->options & LI_O_ACC_PROXY)
-+				listener->analysers |= AN_REQ_DECODE_PROXY;
-+
- 			/* smart accept mode is automatic in HTTP mode */
- 			if ((curproxy->options2 & PR_O2_SMARTACC) ||
- 			    (curproxy->mode == PR_MODE_HTTP &&
---- a/src/client.c
-+++ b/src/client.c
-@@ -22,6 +22,7 @@
- 
- #include <common/compat.h>
- #include <common/config.h>
-+#include <common/debug.h>
- #include <common/time.h>
- 
- #include <types/global.h>
-@@ -43,6 +44,191 @@
- #include <proto/task.h>
- 
- 
-+/* This analyser tries to fetch a line from the request buffer which looks like :
-+ *
-+ *   "PROXY" <SP> PROTO <SP> SRC3 <SP> DST3 <SP> SRC4 <SP> <DST4> "\r\n"
-+ *
-+ * There must be exactly one space between each field. Fields are :
-+ *  - PROTO : layer 4 protocol, which must be "TCP4" or "TCP6".
-+ *  - SRC3  : layer 3 (eg: IP) source address in standard text form
-+ *  - DST3  : layer 3 (eg: IP) destination address in standard text form
-+ *  - SRC4  : layer 4 (eg: TCP port) source address in standard text form
-+ *  - DST4  : layer 4 (eg: TCP port) destination address in standard text form
-+ *
-+ * This line MUST be at the beginning of the buffer and MUST NOT wrap.
-+ *
-+ * Once the data is fetched, the values are set in the session's field and data
-+ * are removed from the buffer. The function returns zero if it needs to wait
-+ * for more data (max: timeout_client), or 1 if it has finished and removed itself.
-+ */
-+int frontend_decode_proxy_request(struct session *s, struct buffer *req, int an_bit)
-+{
-+	char *line = req->data;
-+	char *end = req->data + req->l;
-+	int len;
-+
-+	DPRINTF(stderr,"[%u] %s: session=%p b=%p, exp(r,w)=%u,%u bf=%08x bl=%d analysers=%02x\n",
-+		now_ms, __FUNCTION__,
-+		s,
-+		req,
-+		req->rex, req->wex,
-+		req->flags,
-+		req->l,
-+		req->analysers);
-+
-+	if (req->flags & (BF_READ_ERROR|BF_READ_TIMEOUT))
-+		goto fail;
-+
-+	len = MIN(req->l, 6);
-+	if (!len)
-+		goto missing;
-+
-+	/* Decode a possible proxy request, fail early if it does not match */
-+	if (strncmp(line, "PROXY ", len) != 0)
-+		goto fail;
-+
-+	line += 6;
-+	if (req->l < 18) /* shortest possible line */
-+		goto missing;
-+
-+	if (!memcmp(line, "TCP4 ", 5) != 0) {
-+		u32 src3, dst3, sport, dport;
-+
-+		line += 5;
-+
-+		src3 = inetaddr_host_lim_ret(line, end, &line);
-+		if (line == end)
-+			goto missing;
-+		if (*line++ != ' ')
-+			goto fail;
-+
-+		dst3 = inetaddr_host_lim_ret(line, end, &line);
-+		if (line == end)
-+			goto missing;
-+		if (*line++ != ' ')
-+			goto fail;
-+
-+		sport = read_uint((const char **)&line, end);
-+		if (line == end)
-+			goto missing;
-+		if (*line++ != ' ')
-+			goto fail;
-+
-+		dport = read_uint((const char **)&line, end);
-+		if (line > end - 2)
-+			goto missing;
-+		if (*line++ != '\r')
-+			goto fail;
-+		if (*line++ != '\n')
-+			goto fail;
-+
-+		/* update the session's addresses and mark them set */
-+		((struct sockaddr_in *)&s->cli_addr)->sin_family      = AF_INET;
-+		((struct sockaddr_in *)&s->cli_addr)->sin_addr.s_addr = htonl(src3);
-+		((struct sockaddr_in *)&s->cli_addr)->sin_port        = htons(sport);
-+
-+		((struct sockaddr_in *)&s->frt_addr)->sin_family      = AF_INET;
-+		((struct sockaddr_in *)&s->frt_addr)->sin_addr.s_addr = htonl(dst3);
-+		((struct sockaddr_in *)&s->frt_addr)->sin_port        = htons(dport);
-+		s->flags |= SN_FRT_ADDR_SET;
-+
-+	}
-+	else if (!memcmp(line, "TCP6 ", 5) != 0) {
-+		u32 sport, dport;
-+		char *src_s;
-+		char *dst_s, *sport_s, *dport_s;
-+		struct in6_addr src3, dst3;
-+
-+		line+=5;
-+
-+		src_s = line;
-+		dst_s = sport_s = dport_s = NULL;
-+		while (1) {
-+			if (line > end - 2) {
-+				goto missing;
-+			}
-+			else if (*line == '\r') {
-+				*line = 0;
-+				line++;
-+				if (*line++ != '\n')
-+					goto fail;
-+				break;
-+			}
-+
-+			if (*line == ' ') {
-+				*line = 0;
-+				if (!dst_s)
-+					dst_s = line+1;
-+				else if (!sport_s)
-+					sport_s = line+1;
-+				else if (!dport_s)
-+					dport_s = line+1;
-+			}
-+			line++;
-+		}
-+
-+		if (!dst_s || !sport_s || !dport_s)
-+			goto fail;
-+
-+		sport = read_uint((const char **)&sport_s,dport_s-1);
-+		if ( *sport_s != 0 )
-+			goto fail;
-+
-+		dport = read_uint((const char **)&dport_s,line-2);
-+		if ( *dport_s != 0 )
-+			goto fail;
-+
-+		if (inet_pton(AF_INET6, src_s, (void *)&src3) != 1)
-+			goto fail;
-+
-+		if (inet_pton(AF_INET6, dst_s, (void *)&dst3) != 1)
-+			goto fail;
-+
-+		/* update the session's addresses and mark them set */
-+		((struct sockaddr_in6 *)&s->cli_addr)->sin6_family      = AF_INET6;
-+		memcpy(&((struct sockaddr_in6 *)&s->cli_addr)->sin6_addr, &src3, sizeof(struct in6_addr));
-+		((struct sockaddr_in6 *)&s->cli_addr)->sin6_port        = htons(sport);
-+
-+		((struct sockaddr_in6 *)&s->frt_addr)->sin6_family      = AF_INET6;
-+		memcpy(&((struct sockaddr_in6 *)&s->frt_addr)->sin6_addr, &dst3, sizeof(struct in6_addr));
-+		((struct sockaddr_in6 *)&s->frt_addr)->sin6_port        = htons(dport);
-+		s->flags |= SN_FRT_ADDR_SET;
-+	}
-+	else {
-+		goto fail;
-+	}
-+
-+	/* remove the PROXY line from the request */
-+	len = line - req->data;
-+	buffer_replace2(req, req->data, line, NULL, 0);
-+	req->total -= len; /* don't count the header line */
-+
-+	req->analysers &= ~an_bit;
-+	return 1;
-+
-+ missing:
-+	if (!(req->flags & (BF_SHUTR|BF_FULL))) {
-+		buffer_dont_connect(s->req);
-+		return 0;
-+	}
-+	/* missing data and buffer is either full or shutdown => fail */
-+
-+ fail:
-+	buffer_abort(req);
-+	buffer_abort(s->rep);
-+	req->analysers = 0;
-+
-+	s->fe->counters.failed_req++;
-+	if (s->listener->counters)
-+		s->listener->counters->failed_req++;
-+
-+	if (!(s->flags & SN_ERR_MASK))
-+		s->flags |= SN_ERR_PRXCOND;
-+	if (!(s->flags & SN_FINST_MASK))
-+		s->flags |= SN_FINST_R;
-+	return 0;
-+}
-+
- /* Retrieves the original destination address used by the client, and sets the
-  * SN_FRT_ADDR_SET flag.
-  */
---- a/src/proto_http.c
-+++ b/src/proto_http.c
-@@ -4087,7 +4087,8 @@ void http_end_txn_clean_session(struct s
- 	if (s->rep->lr >= s->rep->data + s->rep->size)
- 		s->rep->lr -= s->req->size;
- 
--	s->req->analysers |= s->fe->fe_req_ana;
-+	s->req->analysers = s->fe->fe_req_ana;
-+	s->req->analysers &= ~AN_REQ_DECODE_PROXY;
- 	s->rep->analysers = 0;
- 
- 	http_silent_debug(__LINE__, s);
-@@ -7624,7 +7625,6 @@ void http_reset_txn(struct session *s)
- 	http_init_txn(s);
- 
- 	s->be = s->fe;
--	s->req->analysers = s->listener->analysers;
- 	s->logs.logwait = s->fe->to_log;
- 	s->srv = s->prev_srv = s->srv_conn = NULL;
- 	/* re-init store persistence */
---- a/src/session.c
-+++ b/src/session.c
-@@ -1055,6 +1055,12 @@ resync_stream_interface:
- 			while (ana_list && max_loops--) {
- 				/* Warning! ensure that analysers are always placed in ascending order! */
- 
-+				if (ana_list & AN_REQ_DECODE_PROXY) {
-+					if (!frontend_decode_proxy_request(s, s->req, AN_REQ_DECODE_PROXY))
-+						break;
-+					UPDATE_ANALYSERS(s->req->analysers, ana_list, ana_back, AN_REQ_DECODE_PROXY);
-+				}
-+
- 				if (ana_list & AN_REQ_INSPECT) {
- 					if (!tcp_inspect_request(s, s->req, AN_REQ_INSPECT))
- 						break;
---- a/src/standard.c
-+++ b/src/standard.c
-@@ -569,6 +569,11 @@ unsigned int strl2uic(const char *s, int
- 	return __strl2uic(s, len);
- }
- 
-+unsigned int read_uint(const char **s, const char *end)
-+{
-+	return __read_uint(s, end);
-+}
-+
- /* This one is 7 times faster than strtol() on athlon with checks.
-  * It returns the value of the number composed of all valid digits read,
-  * and can process negative numbers too.
diff --git a/deps/haproxy-1.4.21/include/common/appsession.h b/deps/haproxy-1.4.21/include/common/appsession.h
deleted file mode 100644
index 6c12926..0000000
--- a/deps/haproxy-1.4.21/include/common/appsession.h
+++ /dev/null
@@ -1,53 +0,0 @@
-#ifndef _COMMON_APPSESS_H
-#define _COMMON_APPSESS_H
-
-/*
- * The time between two calls of appsession_refresh in ms.
- */
-#define TBLCHKINT 5000
-
-#include <sys/time.h>
-
-#include <common/config.h>
-#include <common/memory.h>
-
-#include <types/task.h>
-
-typedef struct appsessions {
-	char *sessid;
-	char *serverid;
-	int   expire;		/* next expiration time for this application session (in tick) */
-	unsigned long int request_count;
-	struct list hash_list;
-} appsess;
-
-extern struct pool_head *pool2_appsess;
-
-struct app_pool {
-	struct pool_head *sessid;
-	struct pool_head *serverid;
-};
-
-extern struct app_pool apools;
-extern int have_appsession;
-
-
-/* Callback for hash_lookup */
-int match_str(const void *key1, const void *key2);
-
-/* Callback for destroy */
-void destroy(appsess *data);
-
-struct task *appsession_refresh(struct task *t);
-int appsession_task_init(void);
-int appsession_init(void);
-void appsession_cleanup(void);
-
-#endif /* _COMMON_APPSESS_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/common/base64.h b/deps/haproxy-1.4.21/include/common/base64.h
deleted file mode 100644
index 2f52ac7..0000000
--- a/deps/haproxy-1.4.21/include/common/base64.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * include/common/base64.h
- * Ascii to Base64 conversion as described in RFC1421.
- *
- * Copyright 2006-2010 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#ifndef _COMMON_BASE64_H
-#define _COMMON_BASE64_H
-
-#include <common/config.h>
-
-int a2base64(char *in, int ilen, char *out, int olen);
-int base64dec(const char *in, size_t ilen, char *out, size_t olen);
-const char *s30tob64(int in, char *out);
-int b64tos30(const char *in);
-
-extern const char base64tab[];
-
-#endif /* _COMMON_BASE64_H */
diff --git a/deps/haproxy-1.4.21/include/common/cfgparse.h b/deps/haproxy-1.4.21/include/common/cfgparse.h
deleted file mode 100644
index a67f0d1..0000000
--- a/deps/haproxy-1.4.21/include/common/cfgparse.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
-  include/common/cfgparse.h
-  Configuration parsing functions.
-
-  Copyright (C) 2000-2008 Willy Tarreau - w@1wt.eu
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _COMMON_CFGPARSE_H
-#define _COMMON_CFGPARSE_H
-
-#include <common/compat.h>
-#include <common/config.h>
-#include <common/mini-clist.h>
-
-#include <types/proxy.h>
-
-/* configuration sections */
-#define CFG_NONE	0
-#define CFG_GLOBAL	1
-#define CFG_LISTEN	2
-#define CFG_USERLIST	3
-
-struct cfg_keyword {
-	int section;                            /* section type for this keyword */
-	const char *kw;                         /* the keyword itself */
-	int (*parse)(                           /* 0=OK, <0=Alert, >0=Warning */
-		     char **args,               /* command line and arguments */
-		     int section_type,          /* current section CFG_{GLOBAL|LISTEN} */
-		     struct proxy *curpx,       /* current proxy (NULL in GLOBAL) */
-		     struct proxy *defpx,       /* default proxy (NULL in GLOBAL) */
-		     char *err,                 /* error message buffer (do not add '\n') */
-		     int errlen);               /* error buffer size, '\0' included */
-};
-
-/* A keyword list. It is a NULL-terminated array of keywords. It embeds a
- * struct list in order to be linked to other lists, allowing it to easily
- * be declared where it is needed, and linked without duplicating data nor
- * allocating memory.
- */
-struct cfg_kw_list {
-	struct list list;
-	struct cfg_keyword kw[VAR_ARRAY];
-};
-
-
-extern int cfg_maxpconn;
-extern int cfg_maxconn;
-
-int cfg_parse_global(const char *file, int linenum, char **args, int inv);
-int cfg_parse_listen(const char *file, int linenum, char **args, int inv);
-int readcfgfile(const char *file);
-void cfg_register_keywords(struct cfg_kw_list *kwl);
-void cfg_unregister_keywords(struct cfg_kw_list *kwl);
-void init_default_instance();
-int check_config_validity();
-
-#endif /* _COMMON_CFGPARSE_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/common/compat.h b/deps/haproxy-1.4.21/include/common/compat.h
deleted file mode 100644
index 9eecdfb..0000000
--- a/deps/haproxy-1.4.21/include/common/compat.h
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
-  include/common/compat.h
-  Operating system compatibility interface.
-
-  Copyright (C) 2000-2008 Willy Tarreau - w@1wt.eu
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _COMMON_COMPAT_H
-#define _COMMON_COMPAT_H
-
-/* This is needed on Linux for Netfilter includes */
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <common/config.h>
-#include <common/standard.h>
-
-#ifndef BITS_PER_INT
-#define BITS_PER_INT    (8*sizeof(int))
-#endif
-
-/* this is for libc5 for example */
-#ifndef TCP_NODELAY
-#define TCP_NODELAY     1
-#endif
-
-#ifndef SHUT_RD
-#define SHUT_RD	        0
-#endif
-
-#ifndef SHUT_WR
-#define SHUT_WR	        1
-#endif
-
-/* only Linux defines it */
-#ifndef MSG_NOSIGNAL
-#define MSG_NOSIGNAL	0
-#endif
-
-/* AIX does not define MSG_DONTWAIT. We'll define it to zero, and test it
- * wherever appropriate.
- */
-#ifndef MSG_DONTWAIT
-#define MSG_DONTWAIT	0
-#endif
-
-/* Only Linux defines MSG_MORE */
-#ifndef MSG_MORE
-#define MSG_MORE	0
-#endif
-
-#if defined(TPROXY) && defined(NETFILTER)
-#include <linux/types.h>
-#include <linux/netfilter_ipv6.h>
-#include <linux/netfilter_ipv4.h>
-#endif
-
-/* On Linux, IP_TRANSPARENT and/or IP_FREEBIND generally require a kernel patch */
-#if defined(CONFIG_HAP_LINUX_TPROXY)
-#if !defined(IP_FREEBIND)
-#define IP_FREEBIND 15
-#endif /* !IP_FREEBIND */
-#if !defined(IP_TRANSPARENT)
-#define IP_TRANSPARENT 19
-#endif /* !IP_TRANSPARENT */
-#endif /* CONFIG_HAP_LINUX_TPROXY */
-
-/* We'll try to enable SO_REUSEPORT on Linux 2.4 and 2.6 if not defined.
- * There are two families of values depending on the architecture. Those
- * are at least valid on Linux 2.4 and 2.6, reason why we'll rely on the
- * NETFILTER define.
- */
-#if !defined(SO_REUSEPORT) && defined(NETFILTER)
-#if    (SO_REUSEADDR == 2)
-#define SO_REUSEPORT 15
-#elif  (SO_REUSEADDR == 0x0004)
-#define SO_REUSEPORT 0x0200
-#endif /* SO_REUSEADDR */
-#endif /* SO_REUSEPORT */
-
-#if defined(__dietlibc__)
-#include <strings.h>
-#endif
-
-#endif /* _COMMON_COMPAT_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/common/compiler.h b/deps/haproxy-1.4.21/include/common/compiler.h
deleted file mode 100644
index 03d82ae..0000000
--- a/deps/haproxy-1.4.21/include/common/compiler.h
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * include/common/compiler.h
- * This files contains some compiler-specific settings.
- *
- * Copyright (C) 2000-2009 Willy Tarreau - w@1wt.eu
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _COMMON_COMPILER_H
-#define _COMMON_COMPILER_H
-
-
-/*
- * Gcc before 3.0 needs [0] to declare a variable-size array
- */
-#ifndef VAR_ARRAY
-#if  __GNUC__  < 3
-#define VAR_ARRAY	0
-#else
-#define VAR_ARRAY
-#endif
-#endif
-
-
-/* Support passing function parameters in registers. For this, the
- * CONFIG_REGPARM macro has to be set to the maximal number of registers
- * allowed. Some functions have intentionally received a regparm lower than
- * their parameter count, it is in order to avoid register clobbering where
- * they are called.
- */
-#ifndef REGPRM1
-#if CONFIG_REGPARM >= 1 && __GNUC__ >= 3
-#define REGPRM1	__attribute__((regparm(1)))
-#else
-#define REGPRM1
-#endif
-#endif
-
-#ifndef REGPRM2
-#if CONFIG_REGPARM >= 2 && __GNUC__ >= 3
-#define REGPRM2	__attribute__((regparm(2)))
-#else
-#define REGPRM2 REGPRM1
-#endif
-#endif
-
-#ifndef REGPRM3
-#if CONFIG_REGPARM >= 3 && __GNUC__ >= 3
-#define REGPRM3	__attribute__((regparm(3)))
-#else
-#define REGPRM3 REGPRM2
-#endif
-#endif
-
-
-/* By default, gcc does not inline large chunks of code, but we want it to
- * respect our choices.
- */
-#if !defined(forceinline)
-#if __GNUC__ < 3
-#define forceinline inline
-#else
-#define forceinline inline __attribute__((always_inline))
-#endif
-#endif
-
-
-/*
- * Gcc >= 3 provides the ability for the programme to give hints to the
- * compiler about what branch of an if is most likely to be taken. This
- * helps the compiler produce the most compact critical paths, which is
- * generally better for the cache and to reduce the number of jumps.
- */
-#if !defined(likely)
-#if __GNUC__ < 3
-#define __builtin_expect(x,y) (x)
-#define likely(x) (x)
-#define unlikely(x) (x)
-#elif __GNUC__ < 4
-/* gcc 3.x does the best job at this */
-#define likely(x) (__builtin_expect((x) != 0, 1))
-#define unlikely(x) (__builtin_expect((x) != 0, 0))
-#else
-/* GCC 4.x is stupid, it performs the comparison then compares it to 1,
- * so we cheat in a dirty way to prevent it from doing this. This will
- * only work with ints and booleans though.
- */
-#define likely(x) (x)
-#define unlikely(x) (__builtin_expect((unsigned long)(x), 0))
-#endif
-#endif
-
-
-#endif /* _COMMON_COMPILER_H */
diff --git a/deps/haproxy-1.4.21/include/common/config.h b/deps/haproxy-1.4.21/include/common/config.h
deleted file mode 100644
index 5833cfc..0000000
--- a/deps/haproxy-1.4.21/include/common/config.h
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * include/common/config.h
- * This files contains most of the user-configurable settings.
- *
- * Copyright (C) 2000-2009 Willy Tarreau - w@1wt.eu
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _COMMON_CONFIG_H
-#define _COMMON_CONFIG_H
-
-#include <common/compiler.h>
-#include <common/defaults.h>
-
-/* this reduces the number of calls to select() by choosing appropriate
- * sheduler precision in milliseconds. It should be near the minimum
- * time that is needed by select() to collect all events. All timeouts
- * are rounded up by adding this value prior to pass it to select().
- */
-#define SCHEDULER_RESOLUTION    9
-
-/* CONFIG_HAP_MEM_OPTIM
- * This enables use of memory pools instead of malloc()/free(). There
- * is no reason to disable it, except perhaps for rare debugging.
- */
-#ifndef   CONFIG_HAP_NO_MEM_OPTIM
-#  define CONFIG_HAP_MEM_OPTIM
-#endif /* CONFIG_HAP_NO_MEM_OPTIM */
-
-/* CONFIG_HAP_MALLOC / CONFIG_HAP_CALLOC / CONFIG_HAP_FREE
- * This macro allows to replace the malloc function with another one.
- */
-#ifdef CONFIG_HAP_MALLOC
-#define MALLOC	CONFIG_HAP_MALLOC
-#else
-#define MALLOC	malloc
-#endif
-
-#ifdef CONFIG_HAP_CALLOC
-#define CALLOC	CONFIG_HAP_CALLOC
-#else
-#define CALLOC	calloc
-#endif
-
-#ifdef CONFIG_HAP_FREE
-#define FREE	CONFIG_HAP_FREE
-#else
-#define FREE	free
-#endif
-
-
-/* CONFIG_HAP_INLINE_FD_SET
- * This makes use of inline FD_* macros instead of calling equivalent
- * functions. Benchmarks on a Pentium-M show that using functions is
- * generally twice as fast. So it's better to keep this option unset.
- */
-//#undef  CONFIG_HAP_INLINE_FD_SET
-
-#endif /* _COMMON_CONFIG_H */
diff --git a/deps/haproxy-1.4.21/include/common/debug.h b/deps/haproxy-1.4.21/include/common/debug.h
deleted file mode 100644
index fe05a44..0000000
--- a/deps/haproxy-1.4.21/include/common/debug.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
-  include/common/debug.h
-  This files contains some macros to help debugging.
-
-  Copyright (C) 2000-2006 Willy Tarreau - w@1wt.eu
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _COMMON_DEBUG_H
-#define _COMMON_DEBUG_H
-
-#include <common/config.h>
-
-#ifdef DEBUG_FULL
-#define DPRINTF(x...) fprintf(x)
-#else
-#define DPRINTF(x...)
-#endif
-
-#ifdef DEBUG_FSM
-#define FSM_PRINTF(x...) fprintf(x)
-#else
-#define FSM_PRINTF(x...)
-#endif
-
-/* This abort is more efficient than abort() because it does not mangle the
- * stack and stops at the exact location we need.
- */
-#define ABORT_NOW() (*(int*)0=0)
-
-/* this one is provided for easy code tracing.
- * Usage: TRACE(sess||0, fmt, args...);
- *        TRACE(sess, "");
- */
-#define TRACE(sess, fmt, args...) do {                            \
-	fprintf(stderr,                                           \
-		"%d.%06d [%s:%d %s] [sess %p(%x)] " fmt "\n",      \
-		(int)now.tv_sec, (int)now.tv_usec,                \
-		__FILE__, __LINE__, __FUNCTION__,                 \
-		sess, sess?((struct session *)sess)->uniq_id:~0U, \
-		##args);                                           \
-        } while (0)
-
-
-#endif /* _COMMON_DEBUG_H */
diff --git a/deps/haproxy-1.4.21/include/common/defaults.h b/deps/haproxy-1.4.21/include/common/defaults.h
deleted file mode 100644
index 96e0f61..0000000
--- a/deps/haproxy-1.4.21/include/common/defaults.h
+++ /dev/null
@@ -1,197 +0,0 @@
-/*
- * include/common/defaults.h
- * Miscellaneous default values.
- *
- * Copyright (C) 2000-2010 Willy Tarreau - w@1wt.eu
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _COMMON_DEFAULTS_H
-#define _COMMON_DEFAULTS_H
-
-/*
- * BUFSIZE defines the size of a read and write buffer. It is the maximum
- * amount of bytes which can be stored by the proxy for each session. However,
- * when reading HTTP headers, the proxy needs some spare space to add or rewrite
- * headers if needed. The size of this spare is defined with MAXREWRITE. So it
- * is not possible to process headers longer than BUFSIZE-MAXREWRITE bytes. By
- * default, BUFSIZE=16384 bytes and MAXREWRITE=BUFSIZE/2, so the maximum length
- * of headers accepted is 8192 bytes, which is in line with Apache's limits.
- */
-#ifndef BUFSIZE
-#define BUFSIZE	        16384
-#endif
-
-// reserved buffer space for header rewriting
-#ifndef MAXREWRITE
-#define MAXREWRITE      (BUFSIZE / 2)
-#endif
-
-#define REQURI_LEN      1024
-#define CAPTURE_LEN     64
-
-// maximum line size when parsing config
-#ifndef LINESIZE
-#define LINESIZE	2048
-#endif
-
-// max # args on a configuration line
-#define MAX_LINE_ARGS   64
-
-// max # args on a stats socket
-#define MAX_STATS_ARGS  16
-
-// max # of matches per regexp
-#define	MAX_MATCH       10
-
-// max # of headers in one HTTP request or response
-// By default, about 100 headers per 8 kB.
-#ifndef MAX_HTTP_HDR
-#define MAX_HTTP_HDR    ((BUFSIZE+79)/80)
-#endif
-
-// max # of headers in history when looking for header #-X
-#ifndef MAX_HDR_HISTORY
-#define MAX_HDR_HISTORY 10
-#endif
-
-// max # of loops we can perform around a read() which succeeds.
-// It's very frequent that the system returns a few TCP segments at a time.
-#ifndef MAX_READ_POLL_LOOPS
-#define MAX_READ_POLL_LOOPS 4
-#endif
-
-// minimum number of bytes read at once above which we don't try to read
-// more, in order not to risk facing an EAGAIN. Most often, if we read
-// at least 10 kB, we can consider that the system has tried to read a
-// full buffer and got multiple segments (>1 MSS for jumbo frames, >7 MSS
-// for normal frames) did not bother truncating the last segment.
-#ifndef MIN_RECV_AT_ONCE_ENOUGH
-#define MIN_RECV_AT_ONCE_ENOUGH (7*1448)
-#endif
-
-// same, but for writes. Generally, it's enough to write twice: one time for
-// first half of the buffer, and a second time for the last half after a
-// wrap-around.
-#ifndef MAX_WRITE_POLL_LOOPS
-#define MAX_WRITE_POLL_LOOPS 2
-#endif
-
-// the number of bytes returned by a read below which we will not try to
-// poll the socket again. Generally, return values below the MSS are worthless
-// to try again.
-#ifndef MIN_RET_FOR_READ_LOOP
-#define MIN_RET_FOR_READ_LOOP 1460
-#endif
-
-// The minimum number of bytes to be forwarded that is worth trying to splice.
-// Below 4kB, it's not worth allocating pipes nor pretending to zero-copy.
-#ifndef MIN_SPLICE_FORWARD
-#define MIN_SPLICE_FORWARD 4096
-#endif
-
-// the max number of events returned in one call to poll/epoll. Too small a
-// value will cause lots of calls, and too high a value may cause high latency.
-#ifndef MAX_POLL_EVENTS
-#define MAX_POLL_EVENTS 200
-#endif
-
-// cookie delimitor in "prefix" mode. This character is inserted between the
-// persistence cookie and the original value. The '~' is allowed by RFC2965,
-// and should not be too common in server names.
-#ifndef COOKIE_DELIM
-#define COOKIE_DELIM    '~'
-#endif
-
-// this delimitor is used between a server's name and a last visit date in
-// cookies exchanged with the client.
-#ifndef COOKIE_DELIM_DATE
-#define COOKIE_DELIM_DATE       '|'
-#endif
-
-#define CONN_RETRIES    3
-
-#define	CHK_CONNTIME    2000
-#define	DEF_CHKINTR     2000
-#define DEF_FALLTIME    3
-#define DEF_RISETIME    2
-#define DEF_CHECK_REQ   "OPTIONS / HTTP/1.0\r\n"
-#define DEF_SMTP_CHECK_REQ   "HELO localhost\r\n"
-#define DEF_LDAP_CHECK_REQ   "\x30\x0c\x02\x01\x01\x60\x07\x02\x01\x03\x04\x00\x80\x00"
-
-#define DEF_HANA_ONERR		HANA_ONERR_FAILCHK
-#define DEF_HANA_ERRLIMIT	10
-
-// X-Forwarded-For header default
-#define DEF_XFORWARDFOR_HDR	"X-Forwarded-For"
-
-// X-Original-To header default
-#define DEF_XORIGINALTO_HDR	"X-Original-To"
-
-/* Default connections limit.
- *
- * A system limit can be enforced at build time in order to avoid using haproxy
- * beyond reasonable system limits. For this, just define SYSTEM_MAXCONN to the
- * absolute limit accepted by the system. If the configuration specifies a
- * higher value, it will be capped to SYSTEM_MAXCONN and a warning will be
- * emitted. The only way to override this limit will be to set it via the
- * command-line '-n' argument.
- */
-#ifndef SYSTEM_MAXCONN
-#ifndef DEFAULT_MAXCONN
-#define DEFAULT_MAXCONN 2000
-#endif
-#else
-#undef  DEFAULT_MAXCONN
-#define DEFAULT_MAXCONN SYSTEM_MAXCONN
-#endif
-
-/* Minimum check interval for spread health checks. Servers with intervals
- * greater than or equal to this value will have their checks spread apart
- * and will be considered when searching the minimal interval.
- * Others will be ignored for the minimal interval and will have their checks
- * scheduled on a different basis.
- */
-#ifndef SRV_CHK_INTER_THRES
-#define SRV_CHK_INTER_THRES 1000
-#endif
-
-/* Specifies the string used to report the version and release date on the
- * statistics page. May be defined to the empty string ("") to permanently
- * disable the feature.
- */
-#ifndef STATS_VERSION_STRING
-#define STATS_VERSION_STRING " version " HAPROXY_VERSION ", released " HAPROXY_DATE
-#endif
-
-/* Maximum signal queue size, and also number of different signals we can
- * handle.
- */
-#ifndef MAX_SIGNAL
-#define MAX_SIGNAL 256
-#endif
-
-/* Maximum host name length */
-#ifndef MAX_HOSTNAME_LEN
-#define MAX_HOSTNAME_LEN	32
-#endif
-
-/* Maximum health check description length */
-#ifndef HCHK_DESC_LEN
-#define HCHK_DESC_LEN	128
-#endif
-
-#endif /* _COMMON_DEFAULTS_H */
diff --git a/deps/haproxy-1.4.21/include/common/epoll.h b/deps/haproxy-1.4.21/include/common/epoll.h
deleted file mode 100644
index 10f7fa9..0000000
--- a/deps/haproxy-1.4.21/include/common/epoll.h
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
-  include/common/epoll.h
-  epoll definitions for older libc.
-
-  Copyright (C) 2000-2006 Willy Tarreau - w@1wt.eu
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-/*
- * Those constants were found both in glibc and in the Linux kernel.
- * They are provided here because the epoll() syscall is featured in
- * some kernels but in not often included in the glibc, so it needs
- * just a basic definition.
- */
-
-#ifndef _COMMON_EPOLL_H
-#define _COMMON_EPOLL_H
-
-#include <sys/types.h>
-#include <linux/unistd.h>
-
-#include <common/config.h>
-
-/* epoll_ctl() commands */
-#ifndef EPOLL_CTL_ADD
-#define EPOLL_CTL_ADD 1
-#define EPOLL_CTL_DEL 2
-#define EPOLL_CTL_MOD 3
-#endif
-
-/* events types (bit fields) */
-#ifndef EPOLLIN
-#define EPOLLIN 1
-#define EPOLLPRI 2
-#define EPOLLOUT 4
-#define EPOLLERR 8
-#define EPOLLHUP 16
-#define EPOLLONESHOT (1 << 30)
-#define EPOLLET (1 << 31)
-#endif
-
-struct epoll_event {
-	uint32_t events;
-	union {
-		void *ptr;
-		int fd;
-		uint32_t u32;
-		uint64_t u64;
-	} data;
-};
-
-
-#if defined(__powerpc__) || defined(__powerpc64__)
-#define __NR_epoll_create 236
-#define __NR_epoll_ctl    237
-#define __NR_epoll_wait   238
-#elif defined(__sparc__) || defined(__sparc64__)
-#define __NR_epoll_create 193
-#define __NR_epoll_ctl    194
-#define __NR_epoll_wait   195
-#elif defined(__x86_64__)
-#define __NR_epoll_create 213
-#define __NR_epoll_ctl    214
-#define __NR_epoll_wait   215
-#elif defined(__alpha__)
-#define __NR_epoll_create 407
-#define __NR_epoll_ctl    408
-#define __NR_epoll_wait   409
-#elif defined (__i386__)
-#define __NR_epoll_create 254
-#define __NR_epoll_ctl    255
-#define __NR_epoll_wait   256
-#else
-#warning unsupported architecture, guessing __NR_epoll_create=254 like x86...
-#define __NR_epoll_create 254
-#define __NR_epoll_ctl    255
-#define __NR_epoll_wait   256
-#endif
-
-/* Those are our self-defined functions */
-static int epoll_create(int size);
-static int epoll_ctl(int epfd, int op, int fd, struct epoll_event * event);
-static int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
-
-#endif /* _COMMON_EPOLL_H */
-
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/common/errors.h b/deps/haproxy-1.4.21/include/common/errors.h
deleted file mode 100644
index 449f2a8..0000000
--- a/deps/haproxy-1.4.21/include/common/errors.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
-  include/common/errors.h
-  Global error macros and constants
-
-  Copyright (C) 2000-2007 Willy Tarreau - w@1wt.eu
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _COMMON_ERRORS_H
-#define _COMMON_ERRORS_H
-
-/* These flags may be used in various functions which are called from within
- * loops (eg: to start all listeners from all proxies). They provide enough
- * information to let the caller decide what to do. ERR_WARN and ERR_ALERT
- * do not indicate any error, just that a message has been put in a shared
- * buffer in order to be displayed by the caller.
- */
-#define ERR_NONE	0x00	/* no error, no message returned */
-#define ERR_RETRYABLE	0x01	/* retryable error, may be cumulated */
-#define ERR_FATAL	0x02	/* fatal error, may be cumulated */
-#define ERR_ABORT	0x04	/* it's preferable to end any possible loop */
-#define ERR_WARN	0x08	/* a warning message has been returned */
-#define ERR_ALERT	0x10	/* an alert message has been returned */
-
-#define ERR_CODE	(ERR_RETRYABLE|ERR_FATAL|ERR_ABORT)	/* mask */
-
-#endif /* _COMMON_ERRORS_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/common/memory.h b/deps/haproxy-1.4.21/include/common/memory.h
deleted file mode 100644
index 765351c..0000000
--- a/deps/haproxy-1.4.21/include/common/memory.h
+++ /dev/null
@@ -1,209 +0,0 @@
-/*
-  include/common/memory.h
-  Memory management definitions..
-
-  Copyright (C) 2000-2008 Willy Tarreau - w@1wt.eu
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _COMMON_MEMORY_H
-#define _COMMON_MEMORY_H
-
-#include <stdlib.h>
-
-#include <common/config.h>
-#include <common/mini-clist.h>
-
-/*
- * Returns a pointer to an area of <__len> bytes taken from the pool <pool> or
- * dynamically allocated. In the first case, <__pool> is updated to point to
- * the next element in the list.
- */
-#define pool_alloc_from(__pool, __len)                      \
-({                                                          \
-        void *__p;                                          \
-        if ((__p = (__pool)) == NULL)                       \
-                __p = malloc(((__len) >= sizeof (void *)) ? \
-                      (__len) : sizeof(void *));            \
-        else {                                              \
-                __pool = *(void **)(__pool);                \
-        }                                                   \
-        __p;                                                \
-})
-
-/*
- * Puts a memory area back to the corresponding pool.
- * Items are chained directly through a pointer that
- * is written in the beginning of the memory area, so
- * there's no need for any carrier cell. This implies
- * that each memory area is at least as big as one
- * pointer.
- */
-#define pool_free_to(__pool, __ptr)             \
-({                                              \
-        *(void **)(__ptr) = (void *)(__pool);   \
-        __pool = (void *)(__ptr);               \
-})
-
-
-#ifdef  CONFIG_HAP_MEM_OPTIM
-/*
- * Returns a pointer to type <type> taken from the
- * pool <pool_type> or dynamically allocated. In the
- * first case, <pool_type> is updated to point to the
- * next element in the list.
- */
-#define pool_alloc(type)                                \
-({                                                      \
-        void *__p;                                      \
-        if ((__p = pool_##type) == NULL)                \
-                __p = malloc(sizeof_##type);            \
-        else {                                          \
-                pool_##type = *(void **)pool_##type;	\
-        }                                               \
-        __p;                                            \
-})
-
-/*
- * Puts a memory area back to the corresponding pool.
- * Items are chained directly through a pointer that
- * is written in the beginning of the memory area, so
- * there's no need for any carrier cell. This implies
- * that each memory area is at least as big as one
- * pointer.
- */
-#define pool_free(type, ptr)                            \
-({                                                      \
-        *(void **)ptr = (void *)pool_##type;            \
-        pool_##type = (void *)ptr;                      \
-})
-
-#else
-#define pool_alloc(type) (calloc(1,sizeof_##type))
-#define pool_free(type, ptr) (free(ptr))
-#endif	/* CONFIG_HAP_MEM_OPTIM */
-
-/*
- * This function destroys a pull by freeing it completely.
- * This should be called only under extreme circumstances.
- */
-static inline void pool_destroy(void **pool)
-{
-	void *temp, *next;
-	next = pool;
-	while (next) {
-		temp = next;
-		next = *(void **)temp;
-		free(temp);
-	}
-}
-
-
-/******* pools version 2 ********/
-
-#define MEM_F_SHARED	0x1
-
-struct pool_head {
-	void **free_list;
-	struct list list;	/* list of all known pools */
-	unsigned int used;	/* how many chunks are currently in use */
-	unsigned int allocated;	/* how many chunks have been allocated */
-	unsigned int limit;	/* hard limit on the number of chunks */
-	unsigned int minavail;	/* how many chunks are expected to be used */
-	unsigned int size;	/* chunk size */
-	unsigned int flags;	/* MEM_F_* */
-	unsigned int users;	/* number of pools sharing this zone */
-	char name[12];		/* name of the pool */
-};
-
-
-/* Allocate a new entry for pool <pool>, and return it for immediate use.
- * NULL is returned if no memory is available for a new creation.
- */
-void *pool_refill_alloc(struct pool_head *pool);
-
-/* Try to find an existing shared pool with the same characteristics and
- * returns it, otherwise creates this one. NULL is returned if no memory
- * is available for a new creation.
- */
-struct pool_head *create_pool(char *name, unsigned int size, unsigned int flags);
-
-/* Dump statistics on pools usage.
- */
-void dump_pools(void);
-
-/*
- * This function frees whatever can be freed in pool <pool>.
- */
-void pool_flush2(struct pool_head *pool);
-
-/*
- * This function frees whatever can be freed in all pools, but respecting
- * the minimum thresholds imposed by owners.
- */
-void pool_gc2();
-
-/*
- * This function destroys a pull by freeing it completely.
- * This should be called only under extreme circumstances.
- */
-void *pool_destroy2(struct pool_head *pool);
-
-/*
- * Returns a pointer to type <type> taken from the
- * pool <pool_type> or dynamically allocated. In the
- * first case, <pool_type> is updated to point to the
- * next element in the list.
- */
-#define pool_alloc2(pool)                                       \
-({                                                              \
-        void *__p;                                              \
-        if ((__p = pool->free_list) == NULL)                    \
-                __p = pool_refill_alloc(pool);                  \
-        else {                                                  \
-                pool->free_list = *(void **)pool->free_list;    \
-                pool->used++;                                   \
-        }                                                       \
-        __p;                                                    \
-})
-
-/*
- * Puts a memory area back to the corresponding pool.
- * Items are chained directly through a pointer that
- * is written in the beginning of the memory area, so
- * there's no need for any carrier cell. This implies
- * that each memory area is at least as big as one
- * pointer. Just like with the libc's free(), nothing
- * is done if <ptr> is NULL.
- */
-#define pool_free2(pool, ptr)                           \
-({                                                      \
-        if (likely((ptr) != NULL)) {                    \
-                *(void **)ptr = (void *)pool->free_list;\
-                pool->free_list = (void *)ptr;          \
-                pool->used--;                           \
-        }                                               \
-})
-
-
-#endif /* _COMMON_MEMORY_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/common/mini-clist.h b/deps/haproxy-1.4.21/include/common/mini-clist.h
deleted file mode 100644
index e89ffe0..0000000
--- a/deps/haproxy-1.4.21/include/common/mini-clist.h
+++ /dev/null
@@ -1,202 +0,0 @@
-/*
- * list.h : list manipulation macros and structures.
- * Copyright 2002-2010 Willy Tarreau <w@1wt.eu>
- *
- */
-
-#ifndef _COMMON_MINI_CLIST_H
-#define _COMMON_MINI_CLIST_H
-
-#include <common/config.h>
-
-/* these are circular or bidirectionnal lists only. Each list pointer points to
- * another list pointer in a structure, and not the structure itself. The
- * pointer to the next element MUST be the first one so that the list is easily
- * cast as a single linked list or pointer.
- */
-struct list {
-    struct list *n;	/* next */
-    struct list *p;	/* prev */
-};
-
-/* a back-ref is a pointer to a target list entry. It is used to detect when an
- * element being deleted is currently being tracked by another user. The best
- * example is a user dumping the session table. The table does not fit in the
- * output buffer so we have to set a mark on a session and go on later. But if
- * that marked session gets deleted, we don't want the user's pointer to go in
- * the wild. So we can simply link this user's request to the list of this
- * session's users, and put a pointer to the list element in ref, that will be
- * used as the mark for next iteration.
- */
-struct bref {
-	struct list users;
-	struct list *ref; /* pointer to the target's list entry */
-};
-
-/* a word list is a generic list with a pointer to a string in each element. */
-struct wordlist {
-	struct list list;
-	char *s;
-};
-
-/* this is the same as above with an additional pointer to a condition. */
-struct cond_wordlist {
-	struct list list;
-	void *cond;
-	char *s;
-};
-
-/* First undefine some macros which happen to also be defined on OpenBSD,
- * in sys/queue.h, used by sys/event.h
- */
-#undef LIST_HEAD
-#undef LIST_INIT
-#undef LIST_NEXT
-
-#define LIST_HEAD(a)	((void *)(&(a)))
-
-#define LIST_INIT(l) ((l)->n = (l)->p = (l))
-
-#define LIST_HEAD_INIT(l) { &l, &l }
-
-/* dual linked lists :
- * Start = (struct list *) pointer to the next elem's prev list entry
- * For each element :
- *   - prev = pointer to previous element's next (or start). Cannot be NULL
- *   - next = pointer to next element's prev. NULL = end.
- *
- */
-
-/* adds an element at the beginning of a dual-linked list ; returns the element */
-#define DLIST_ADD(lh, el) ({ typeof(el) __ret = (el); __ret->n = (void *)(lh); __ret->p = (void *)&(lh); if (likely(__ret->n != NULL)) __ret->n->p = __ret; (lh) = (typeof(lh))&__ret->n; __ret; })
-
-/* removes an element from a dual-linked list and returns it */
-#define DLIST_DEL(el) ({ typeof(el) __ret = (el); if (likely(__ret->n != NULL)) __ret->n->p = __ret->p; __ret->p->n = __ret->n; __ret; })
-
-/*
- * iterates through a list of items of type "<struct_type>" which are
- * linked via a "struct list" member named <struct_member>. The head of the
- * list is stored at a location designed by <list_head>, which should be a
- * "struct list *". A variable <end_item> of type "<struct_type>" will
- * be used as temporary end of list pointer. It can be derived from <list_head>
- * since this one is only used before. <list_head> will be modified except for
- * foreach_dlist_item_cst which is slightly slower.
- * Major difference between FOREACH_ITEM is that it stops at NULL.
- * Example: foreach_dlist_item(cur_node, args, struct node *, list) { ... };
- *          foreach_dlist_item_cst(cur_node, &node->args, struct node *, list) { ... };
- */
-#define foreach_dlist_item_cst(iterator, list_head, struct_type, struct_member)	\
-	for ((iterator) = LIST_ELEM(&(list_head), struct_type, struct_member.n);	\
-	     ((iterator)->struct_member.n != NULL) && \
-             (((iterator) = LIST_ELEM((iterator)->struct_member.n, struct_type, struct_member.n)), 1);\
-	     )
-
-#define foreach_dlist_item(iterator, var_list_head, struct_type, struct_member)	\
-	while ((var_list_head != NULL) &&			\
-	       ((var_list_head=((iterator)=LIST_ELEM(var_list_head, struct_type, struct_member.n))->struct_member.n), 1))
-
-/*
- * Like foreach_dlist_item, except that this one only operates on the head of
- * the list. It's to the inner instructions to iterate the list head. If not,
- * this will be an endless loop.
- */
-#define while_dlist_item(iterator, var_list_head, struct_type, struct_member)	\
-	while ((var_list_head != NULL) &&			\
-	       (((iterator)=LIST_ELEM(var_list_head, struct_type, struct_member.n)),1))
-
-
-/****** circular lists ********/
-
-/* adds an element at the beginning of a list ; returns the element */
-#define LIST_ADD(lh, el) ({ (el)->n = (lh)->n; (el)->n->p = (lh)->n = (el); (el)->p = (lh); (el); })
-
-/* adds an element at the end of a list ; returns the element */
-#define LIST_ADDQ(lh, el) ({ (el)->p = (lh)->p; (el)->p->n = (lh)->p = (el); (el)->n = (lh); (el); })
-
-/* removes an element from a list and returns it */
-#define LIST_DEL(el) ({ typeof(el) __ret = (el); (el)->n->p = (el)->p; (el)->p->n = (el)->n; (__ret); })
-
-/* returns a pointer of type <pt> to a structure containing a list head called
- * <el> at address <lh>. Note that <lh> can be the result of a function or macro
- * since it's used only once.
- * Example: LIST_ELEM(cur_node->args.next, struct node *, args)
- */
-#define LIST_ELEM(lh, pt, el) ((pt)(((void *)(lh)) - ((void *)&((pt)NULL)->el)))
-
-/* checks if the list head <lh> is empty or not */
-#define LIST_ISEMPTY(lh) ((lh)->n == (lh))
-
-/* returns a pointer of type <pt> to a structure following the element
- * which contains list head <lh>, which is known as element <el> in
- * struct pt.
- * Example: LIST_NEXT(args, struct node *, list)
- */
-#define LIST_NEXT(lh, pt, el) (LIST_ELEM((lh)->n, pt, el))
-
-
-/* returns a pointer of type <pt> to a structure preceeding the element
- * which contains list head <lh>, which is known as element <el> in
- * struct pt.
- */
-#define LIST_PREV(lh, pt, el) (LIST_ELEM((lh)->p, pt, el))
-
-/*
- * DEPRECATED !!!  Use list_for_each_entry() below instead !
- *
- * iterates through a list of items of type "<struct_type>" which are
- * linked via a "struct list" member named <struct_member>. The head of the
- * list is stored at a location designed by <list_head>, which should be a
- * "struct list *". A variable <end_item> of type "<struct_type>" will
- * be used as temporary end of list pointer. It can be derived from <list_head>
- * since this one is only used before.
- * Example: FOREACH_ITEM(cur_node, &node->args, node, struct node *, neigh) { ... };
- */
-#define FOREACH_ITEM(iterator, list_head, end_item, struct_type, struct_member) \
-	iterator = end_item = LIST_ELEM(list_head, struct_type, struct_member); \
-	while (((iterator) = LIST_ELEM((iterator)->struct_member.n, 		\
-			     struct_type, struct_member)) != (end_item))
-
-/*
- * DEPRECATED !!!  Use list_for_each_entry_safe() below instead !
- *
- * idem except that this one is safe against deletion, but it needs a backup
- * pointer of the element after the iterator.
- * Example: FOREACH_ITEM_SAFE(cur_node, backup, &node->args, node, struct node *, neigh) { ... };
- */
-#define FOREACH_ITEM_SAFE(iterator, backup, list_head, end_item, struct_type, struct_member) \
-	end_item = LIST_ELEM(list_head, struct_type, struct_member); \
-	iterator = LIST_ELEM((end_item)->struct_member.n, struct_type, struct_member); \
-	if ((iterator) != (end_item)) \
-		backup = LIST_ELEM((iterator)->struct_member.n, struct_type, struct_member); \
-	for ( ; (iterator) != (end_item); (iterator) = (backup),   \
-		backup = LIST_ELEM((iterator)->struct_member.n, struct_type, struct_member))
-
-/*
- * Simpler FOREACH_ITEM macro inspired from Linux sources.
- * Iterates <item> through a list of items of type "typeof(*item)" which are
- * linked via a "struct list" member named <member>. A pointer to the head of
- * the list is passed in <list_head>. No temporary variable is needed. Note
- * that <item> must not be modified during the loop.
- * Example: list_for_each_entry(cur_acl, known_acl, list) { ... };
- */ 
-#define list_for_each_entry(item, list_head, member)                      \
-	for (item = LIST_ELEM((list_head)->n, typeof(item), member);     \
-	     &item->member != (list_head);                                \
-	     item = LIST_ELEM(item->member.n, typeof(item), member))
-
-/*
- * Simpler FOREACH_ITEM_SAFE macro inspired from Linux sources.
- * Iterates <item> through a list of items of type "typeof(*item)" which are
- * linked via a "struct list" member named <member>. A pointer to the head of
- * the list is passed in <list_head>. A temporary variable <back> of same type
- * as <item> is needed so that <item> may safely be deleted if needed.
- * Example: list_for_each_entry_safe(cur_acl, tmp, known_acl, list) { ... };
- */ 
-#define list_for_each_entry_safe(item, back, list_head, member)           \
-	for (item = LIST_ELEM((list_head)->n, typeof(item), member),     \
-	     back = LIST_ELEM(item->member.n, typeof(item), member);     \
-	     &item->member != (list_head);                                \
-	     item = back, back = LIST_ELEM(back->member.n, typeof(back), member))
-
-
-#endif /* _COMMON_MINI_CLIST_H */
diff --git a/deps/haproxy-1.4.21/include/common/rbtree.h b/deps/haproxy-1.4.21/include/common/rbtree.h
deleted file mode 100644
index 107e8d2..0000000
--- a/deps/haproxy-1.4.21/include/common/rbtree.h
+++ /dev/null
@@ -1,150 +0,0 @@
-/*
-  Red Black Trees
-  (C) 1999  Andrea Arcangeli <andrea@suse.de>
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-
-  linux/include/linux/rbtree.h
-
-  To use rbtrees you'll have to implement your own insert and search cores.
-  This will avoid us to use callbacks and to drop drammatically performances.
-  I know it's not the cleaner way,  but in C (not in C++) to get
-  performances and genericity...
-
-  Some example of insert and search follows here. The search is a plain
-  normal search over an ordered tree. The insert instead must be implemented
-  int two steps: as first thing the code must insert the element in
-  order as a red leaf in the tree, then the support library function
-  rb_insert_color() must be called. Such function will do the
-  not trivial work to rebalance the rbtree if necessary.
-
------------------------------------------------------------------------
-static inline struct page * rb_search_page_cache(struct inode * inode,
-						 unsigned long offset)
-{
-	struct rb_node * n = inode->i_rb_page_cache.rb_node;
-	struct page * page;
-
-	while (n)
-	{
-		page = rb_entry(n, struct page, rb_page_cache);
-
-		if (offset < page->offset)
-			n = n->rb_left;
-		else if (offset > page->offset)
-			n = n->rb_right;
-		else
-			return page;
-	}
-	return NULL;
-}
-
-static inline struct page * __rb_insert_page_cache(struct inode * inode,
-						   unsigned long offset,
-						   struct rb_node * node)
-{
-	struct rb_node ** p = &inode->i_rb_page_cache.rb_node;
-	struct rb_node * parent = NULL;
-	struct page * page;
-
-	while (*p)
-	{
-		parent = *p;
-		page = rb_entry(parent, struct page, rb_page_cache);
-
-		if (offset < page->offset)
-			p = &(*p)->rb_left;
-		else if (offset > page->offset)
-			p = &(*p)->rb_right;
-		else
-			return page;
-	}
-
-	rb_link_node(node, parent, p);
-
-	return NULL;
-}
-
-static inline struct page * rb_insert_page_cache(struct inode * inode,
-						 unsigned long offset,
-						 struct rb_node * node)
-{
-	struct page * ret;
-	if ((ret = __rb_insert_page_cache(inode, offset, node)))
-		goto out;
-	rb_insert_color(node, &inode->i_rb_page_cache);
- out:
-	return ret;
-}
------------------------------------------------------------------------
-*/
-
-#ifndef	_LINUX_RBTREE_H
-#define	_LINUX_RBTREE_H
-
-/*
-#include <linux/kernel.h>
-#include <linux/stddef.h>
-*/
-
-struct rb_node
-{
-	struct rb_node *rb_parent;
-	int rb_color;
-#define	RB_RED		0
-#define	RB_BLACK	1
-	struct rb_node *rb_right;
-	struct rb_node *rb_left;
-};
-
-struct rb_root
-{
-	struct rb_node *rb_node;
-};
-
-// Copy from linux kernel 2.6 source (kernel.h, stddef.h)
-#define container_of(ptr, type, member) ({      \
-	const typeof( ((type *)0)->member ) *__mptr = (ptr);  \
-	(type *)( (char *)__mptr - offsetof(type,member) );})
-#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
-
-
-#define RB_ROOT	(struct rb_root) { NULL, }
-#define	rb_entry(ptr, type, member) container_of(ptr, type, member)
-
-extern void rb_insert_color(struct rb_node *, struct rb_root *);
-extern void rb_erase(struct rb_node *, struct rb_root *);
-
-/* Find logical next and previous nodes in a tree */
-extern struct rb_node *rb_next(struct rb_node *);
-extern struct rb_node *rb_prev(struct rb_node *);
-extern struct rb_node *rb_first(struct rb_root *);
-extern struct rb_node *rb_last(struct rb_root *);
-
-/* Fast replacement of a single node without remove/rebalance/add/rebalance */
-extern void rb_replace_node(struct rb_node *victim, struct rb_node *new,
-			    struct rb_root *root);
-
-static inline void rb_link_node(struct rb_node * node, struct rb_node * parent,
-				struct rb_node ** rb_link)
-{
-	node->rb_parent = parent;
-	node->rb_color = RB_RED;
-	node->rb_left = node->rb_right = NULL;
-
-	*rb_link = node;
-}
-
-#endif	/* _LINUX_RBTREE_H */
diff --git a/deps/haproxy-1.4.21/include/common/regex.h b/deps/haproxy-1.4.21/include/common/regex.h
deleted file mode 100644
index 60c7f42..0000000
--- a/deps/haproxy-1.4.21/include/common/regex.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * include/common/regex.h
- * This file defines everything related to regular expressions.
- *
- * Copyright (C) 2000-2010 Willy Tarreau - w@1wt.eu
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _COMMON_REGEX_H
-#define _COMMON_REGEX_H
-
-#include <common/config.h>
-
-#ifdef USE_PCRE
-#include <pcre.h>
-#include <pcreposix.h>
-#else
-#include <regex.h>
-#endif
-
-/* what to do when a header matches a regex */
-#define ACT_ALLOW	0	/* allow the request */
-#define ACT_REPLACE	1	/* replace the matching header */
-#define ACT_REMOVE	2	/* remove the matching header */
-#define ACT_DENY	3	/* deny the request */
-#define ACT_PASS	4	/* pass this header without allowing or denying the request */
-#define ACT_TARPIT	5	/* tarpit the connection matching this request */
-#define ACT_SETBE	6	/* switch the backend */
-
-struct hdr_exp {
-    struct hdr_exp *next;
-    const regex_t *preg;		/* expression to look for */
-    int action;				/* ACT_ALLOW, ACT_REPLACE, ACT_REMOVE, ACT_DENY */
-    const char *replace;		/* expression to set instead */
-    void *cond;				/* a possible condition or NULL */
-};
-
-extern regmatch_t pmatch[MAX_MATCH];
-
-int exp_replace(char *dst, char *src, const char *str,	const regmatch_t *matches);
-const char *check_replace_string(const char *str);
-const char *chain_regex(struct hdr_exp **head, const regex_t *preg,
-			int action, const char *replace, void *cond);
-
-#endif /* _COMMON_REGEX_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/common/sessionhash.h b/deps/haproxy-1.4.21/include/common/sessionhash.h
deleted file mode 100644
index da5fde0..0000000
--- a/deps/haproxy-1.4.21/include/common/sessionhash.h
+++ /dev/null
@@ -1,62 +0,0 @@
-#ifndef SESSION_HASH_H
-#define SESSION_HASH_H
-
-/*
- * HashTable functions.
- *
- * Copyright 2007 Arnaud Cornet
- *
- * This file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License, version 2.1 as published by the Free Software Foundation.
- *
- */
-
-#include <common/appsession.h>
-
-#ifndef TABLESHIFT
-#define TABLESHIFT 11
-#endif
-#define TABLESIZE (1UL << TABLESHIFT)
-#define TABLEMASK (TABLESIZE - 1)
-
-/*
- * quick and dirty AppSession hash table, using sessid as key
- */
-
-struct appsession_hash
-{
-	struct list *table;
-	void (*destroy)(appsess *);
-};
-
-unsigned int appsession_hash_f(char *);
-int appsession_hash_init(struct appsession_hash *hash,
-		void(*destroy)(appsess*));
-void appsession_hash_insert(struct appsession_hash *hash,
-		struct appsessions *session);
-struct appsessions *appsession_hash_lookup(struct appsession_hash *hash,
-		char *key);
-void appsession_hash_remove(struct appsession_hash *hash,
-		struct appsessions *session);
-
-void appsession_hash_destroy(struct appsession_hash *hash);
-#if defined(DEBUG_HASH)
-void appsession_hash_dump(struct appsession_hash *hash);
-#endif
-
-/*
- * Iterates <item> through a hashtable of items of type "typeof(*item)"
- * A pointer to the appsession_hash is passed in <hash>. The hash table
- * internaly uses <list_head> member of the struct. A temporary variable <back>
- * of same type as <item> is needed so that <item> may safely be deleted if
- * needed.  <idx> is a variable containing <item>'s current bucket index in the
- * hash table.
- * Example: as_hash_for_each_entry_safe(idx, item, tmp, &hash, hash_list)
- * { ... }
- */
-#define as_hash_for_each_entry_safe(idx, item, back, hash, member) \
-	 for (idx = 0; idx < TABLESIZE; idx++)                          \
-		list_for_each_entry_safe(item, back, &((hash)->table[idx]), member)
-
-#endif /* SESSION_HASH_H */
diff --git a/deps/haproxy-1.4.21/include/common/standard.h b/deps/haproxy-1.4.21/include/common/standard.h
deleted file mode 100644
index 1df3d08..0000000
--- a/deps/haproxy-1.4.21/include/common/standard.h
+++ /dev/null
@@ -1,412 +0,0 @@
-/*
- * include/common/standard.h
- * This files contains some general purpose functions and macros.
- *
- * Copyright (C) 2000-2010 Willy Tarreau - w@1wt.eu
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _COMMON_STANDARD_H
-#define _COMMON_STANDARD_H
-
-#include <limits.h>
-#include <string.h>
-#include <time.h>
-#include <sys/types.h>
-#include <netinet/in.h>
-#include <common/config.h>
-#include <eb32tree.h>
-#include <proto/fd.h>
-
-/****** string-specific macros and functions ******/
-/* if a > max, then bound <a> to <max>. The macro returns the new <a> */
-#define UBOUND(a, max)	({ typeof(a) b = (max); if ((a) > b) (a) = b; (a); })
-
-/* if a < min, then bound <a> to <min>. The macro returns the new <a> */
-#define LBOUND(a, min)	({ typeof(a) b = (min); if ((a) < b) (a) = b; (a); })
-
-/* returns 1 only if only zero or one bit is set in X, which means that X is a
- * power of 2, and 0 otherwise */
-#define POWEROF2(x) (((x) & ((x)-1)) == 0)
-
-/*
- * copies at most <size-1> chars from <src> to <dst>. Last char is always
- * set to 0, unless <size> is 0. The number of chars copied is returned
- * (excluding the terminating zero).
- * This code has been optimized for size and speed : on x86, it's 45 bytes
- * long, uses only registers, and consumes only 4 cycles per char.
- */
-extern int strlcpy2(char *dst, const char *src, int size);
-
-/*
- * This function simply returns a locally allocated string containing
- * the ascii representation for number 'n' in decimal.
- */
-extern char itoa_str[][171];
-extern char *ultoa_r(unsigned long n, char *buffer, int size);
-extern const char *ulltoh_r(unsigned long long n, char *buffer, int size);
-static inline const char *ultoa(unsigned long n)
-{
-	return ultoa_r(n, itoa_str[0], sizeof(itoa_str[0]));
-}
-
-/* Fast macros to convert up to 10 different parameters inside a same call of
- * expression.
- */
-#define U2A0(n) ({ ultoa_r((n), itoa_str[0], sizeof(itoa_str[0])); })
-#define U2A1(n) ({ ultoa_r((n), itoa_str[1], sizeof(itoa_str[1])); })
-#define U2A2(n) ({ ultoa_r((n), itoa_str[2], sizeof(itoa_str[2])); })
-#define U2A3(n) ({ ultoa_r((n), itoa_str[3], sizeof(itoa_str[3])); })
-#define U2A4(n) ({ ultoa_r((n), itoa_str[4], sizeof(itoa_str[4])); })
-#define U2A5(n) ({ ultoa_r((n), itoa_str[5], sizeof(itoa_str[5])); })
-#define U2A6(n) ({ ultoa_r((n), itoa_str[6], sizeof(itoa_str[6])); })
-#define U2A7(n) ({ ultoa_r((n), itoa_str[7], sizeof(itoa_str[7])); })
-#define U2A8(n) ({ ultoa_r((n), itoa_str[8], sizeof(itoa_str[8])); })
-#define U2A9(n) ({ ultoa_r((n), itoa_str[9], sizeof(itoa_str[9])); })
-
-/* The same macros provide HTML encoding of numbers */
-#define U2H0(n) ({ ulltoh_r((n), itoa_str[0], sizeof(itoa_str[0])); })
-#define U2H1(n) ({ ulltoh_r((n), itoa_str[1], sizeof(itoa_str[1])); })
-#define U2H2(n) ({ ulltoh_r((n), itoa_str[2], sizeof(itoa_str[2])); })
-#define U2H3(n) ({ ulltoh_r((n), itoa_str[3], sizeof(itoa_str[3])); })
-#define U2H4(n) ({ ulltoh_r((n), itoa_str[4], sizeof(itoa_str[4])); })
-#define U2H5(n) ({ ulltoh_r((n), itoa_str[5], sizeof(itoa_str[5])); })
-#define U2H6(n) ({ ulltoh_r((n), itoa_str[6], sizeof(itoa_str[6])); })
-#define U2H7(n) ({ ulltoh_r((n), itoa_str[7], sizeof(itoa_str[7])); })
-#define U2H8(n) ({ ulltoh_r((n), itoa_str[8], sizeof(itoa_str[8])); })
-#define U2H9(n) ({ ulltoh_r((n), itoa_str[9], sizeof(itoa_str[9])); })
-
-/*
- * This function simply returns a locally allocated string containing the ascii
- * representation for number 'n' in decimal, unless n is 0 in which case it
- * returns the alternate string (or an empty string if the alternate string is
- * NULL). It use is intended for limits reported in reports, where it's
- * desirable not to display anything if there is no limit. Warning! it shares
- * the same vector as ultoa_r().
- */
-extern const char *limit_r(unsigned long n, char *buffer, int size, const char *alt);
-
-/* Fast macros to convert up to 10 different parameters inside a same call of
- * expression. Warning! they share the same vectors as U2A*!
- */
-#define LIM2A0(n, alt) ({ limit_r((n), itoa_str[0], sizeof(itoa_str[0]), (alt)); })
-#define LIM2A1(n, alt) ({ limit_r((n), itoa_str[1], sizeof(itoa_str[1]), (alt)); })
-#define LIM2A2(n, alt) ({ limit_r((n), itoa_str[2], sizeof(itoa_str[2]), (alt)); })
-#define LIM2A3(n, alt) ({ limit_r((n), itoa_str[3], sizeof(itoa_str[3]), (alt)); })
-#define LIM2A4(n, alt) ({ limit_r((n), itoa_str[4], sizeof(itoa_str[4]), (alt)); })
-#define LIM2A5(n, alt) ({ limit_r((n), itoa_str[5], sizeof(itoa_str[5]), (alt)); })
-#define LIM2A6(n, alt) ({ limit_r((n), itoa_str[6], sizeof(itoa_str[6]), (alt)); })
-#define LIM2A7(n, alt) ({ limit_r((n), itoa_str[7], sizeof(itoa_str[7]), (alt)); })
-#define LIM2A8(n, alt) ({ limit_r((n), itoa_str[8], sizeof(itoa_str[8]), (alt)); })
-#define LIM2A9(n, alt) ({ limit_r((n), itoa_str[9], sizeof(itoa_str[9]), (alt)); })
-
-/*
- * Returns non-zero if character <s> is a hex digit (0-9, a-f, A-F), else zero.
- */
-extern int ishex(char s);
-
-/*
- * Return integer equivalent of character <c> for a hex digit (0-9, a-f, A-F),
- * otherwise -1.
- */
-extern int hex2i(int c);
-
-/*
- * Checks <name> for invalid characters. Valid chars are [A-Za-z0-9_:.-]. If an
- * invalid character is found, a pointer to it is returned. If everything is
- * fine, NULL is returned.
- */
-extern const char *invalid_char(const char *name);
-
-/*
- * Checks <domainname> for invalid characters. Valid chars are [A-Za-z0-9_.-].
- * If an invalid character is found, a pointer to it is returned.
- * If everything is fine, NULL is returned.
- */
-extern const char *invalid_domainchar(const char *name);
-
-/*
- * converts <str> to a struct sockaddr_un* which is locally allocated.
- * The format is "/path", where "/path" is a path to a UNIX domain socket.
- */
-struct sockaddr_un *str2sun(const char *str);
-
-/*
- * converts <str> to a struct sockaddr_in* which is locally allocated.
- * The format is "addr:port", where "addr" can be a dotted IPv4 address,
- * a host name, or empty or "*" to indicate INADDR_ANY.
- */
-struct sockaddr_in *str2sa(char *str);
-
-/*
- * converts <str> to a struct sockaddr_in* which is locally allocated, and a
- * port range consisting in two integers. The low and high end are always set
- * even if the port is unspecified, in which case (0,0) is returned. The low
- * port is set in the sockaddr_in. Thus, it is enough to check the size of the
- * returned range to know if an array must be allocated or not. The format is
- * "addr[:port[-port]]", where "addr" can be a dotted IPv4 address, a host
- * name, or empty or "*" to indicate INADDR_ANY.
- */
-struct sockaddr_in *str2sa_range(char *str, int *low, int *high);
-
-/* converts <str> to a struct in_addr containing a network mask. It can be
- * passed in dotted form (255.255.255.0) or in CIDR form (24). It returns 1
- * if the conversion succeeds otherwise non-zero.
- */
-int str2mask(const char *str, struct in_addr *mask);
-
-/*
- * converts <str> to two struct in_addr* which must be pre-allocated.
- * The format is "addr[/mask]", where "addr" cannot be empty, and mask
- * is optionnal and either in the dotted or CIDR notation.
- * Note: "addr" can also be a hostname. Returns 1 if OK, 0 if error.
- */
-int str2net(const char *str, struct in_addr *addr, struct in_addr *mask);
-
-/*
- * Parse IP address found in url.
- */
-int url2ip(const char *addr, struct in_addr *dst);
-
-/*
- * Resolve destination server from URL. Convert <str> to a sockaddr_in*.
- */
-int url2sa(const char *url, int ulen, struct sockaddr_in *addr);
-
-/* will try to encode the string <string> replacing all characters tagged in
- * <map> with the hexadecimal representation of their ASCII-code (2 digits)
- * prefixed by <escape>, and will store the result between <start> (included)
- * and <stop> (excluded), and will always terminate the string with a '\0'
- * before <stop>. The position of the '\0' is returned if the conversion
- * completes. If bytes are missing between <start> and <stop>, then the
- * conversion will be incomplete and truncated. If <stop> <= <start>, the '\0'
- * cannot even be stored so we return <start> without writing the 0.
- * The input string must also be zero-terminated.
- */
-extern const char hextab[];
-char *encode_string(char *start, char *stop,
-		    const char escape, const fd_set *map,
-		    const char *string);
-
-/* Decode an URL-encoded string in-place. The resulting string might
- * be shorter. If some forbidden characters are found, the conversion is
- * aborted, the string is truncated before the issue and non-zero is returned,
- * otherwise the operation returns non-zero indicating success.
- */
-int url_decode(char *string);
-
-/* This one is 6 times faster than strtoul() on athlon, but does
- * no check at all.
- */
-static inline unsigned int __str2ui(const char *s)
-{
-	unsigned int i = 0;
-	while (*s) {
-		i = i * 10 - '0';
-		i += (unsigned char)*s++;
-	}
-	return i;
-}
-
-/* This one is 5 times faster than strtoul() on athlon with checks.
- * It returns the value of the number composed of all valid digits read.
- */
-static inline unsigned int __str2uic(const char *s)
-{
-	unsigned int i = 0;
-	unsigned int j;
-	while (1) {
-		j = (*s++) - '0';
-		if (j > 9)
-			break;
-		i *= 10;
-		i += j;
-	}
-	return i;
-}
-
-/* This one is 28 times faster than strtoul() on athlon, but does
- * no check at all!
- */
-static inline unsigned int __strl2ui(const char *s, int len)
-{
-	unsigned int i = 0;
-	while (len-- > 0) {
-		i = i * 10 - '0';
-		i += (unsigned char)*s++;
-	}
-	return i;
-}
-
-/* This one is 7 times faster than strtoul() on athlon with checks.
- * It returns the value of the number composed of all valid digits read.
- */
-static inline unsigned int __strl2uic(const char *s, int len)
-{
-	unsigned int i = 0;
-	unsigned int j, k;
-
-	while (len-- > 0) {
-		j = (*s++) - '0';
-		k = i * 10;
-		if (j > 9)
-			break;
-		i = k + j;
-	}
-	return i;
-}
-
-/* This function reads an unsigned integer from the string pointed to by <s>
- * and returns it. The <s> pointer is adjusted to point to the first unread
- * char. The function automatically stops at <end>.
- */
-static inline unsigned int __read_uint(const char **s, const char *end)
-{
-	const char *ptr = *s;
-	unsigned int i = 0;
-	unsigned int j, k;
-
-	while (ptr < end) {
-		j = *ptr - '0';
-		k = i * 10;
-		if (j > 9)
-			break;
-		i = k + j;
-		ptr++;
-	}
-	*s = ptr;
-	return i;
-}
-
-extern unsigned int str2ui(const char *s);
-extern unsigned int str2uic(const char *s);
-extern unsigned int strl2ui(const char *s, int len);
-extern unsigned int strl2uic(const char *s, int len);
-extern int strl2ic(const char *s, int len);
-extern int strl2irc(const char *s, int len, int *ret);
-extern int strl2llrc(const char *s, int len, long long *ret);
-extern unsigned int read_uint(const char **s, const char *end);
-unsigned int inetaddr_host(const char *text);
-unsigned int inetaddr_host_lim(const char *text, const char *stop);
-unsigned int inetaddr_host_lim_ret(const char *text, char *stop, const char **ret);
-
-static inline char *cut_crlf(char *s) {
-
-	while (*s != '\r' || *s == '\n') {
-		char *p = s++;
-
-		if (!*p)
-			return p;
-	}
-
-	*s++ = 0;
-
-	return s;
-}
-
-static inline char *ltrim(char *s, char c) {
-
-	if (c)
-		while (*s == c)
-			s++;
-
-	return s;
-}
-
-static inline char *rtrim(char *s, char c) {
-
-	char *p = s + strlen(s);
-
-	while (p-- > s)
-		if (*p == c)
-			*p = '\0';
-		else
-			break;
-
-	return s;
-}
-
-static inline char *alltrim(char *s, char c) {
-
-	rtrim(s, c);
-
-	return ltrim(s, c);
-}
-
-/* This function converts the time_t value <now> into a broken out struct tm
- * which must be allocated by the caller. It is highly recommended to use this
- * function intead of localtime() because that one requires a time_t* which
- * is not always compatible with tv_sec depending on OS/hardware combinations.
- */
-static inline void get_localtime(const time_t now, struct tm *tm)
-{
-	localtime_r(&now, tm);
-}
-
-/* This function converts the time_t value <now> into a broken out struct tm
- * which must be allocated by the caller. It is highly recommended to use this
- * function intead of gmtime() because that one requires a time_t* which
- * is not always compatible with tv_sec depending on OS/hardware combinations.
- */
-static inline void get_gmtime(const time_t now, struct tm *tm)
-{
-	gmtime_r(&now, tm);
-}
-
-/* This function parses a time value optionally followed by a unit suffix among
- * "d", "h", "m", "s", "ms" or "us". It converts the value into the unit
- * expected by the caller. The computation does its best to avoid overflows.
- * The value is returned in <ret> if everything is fine, and a NULL is returned
- * by the function. In case of error, a pointer to the error is returned and
- * <ret> is left untouched.
- */
-extern const char *parse_time_err(const char *text, unsigned *ret, unsigned unit_flags);
-extern const char *parse_size_err(const char *text, unsigned *ret);
-
-/* unit flags to pass to parse_time_err */
-#define TIME_UNIT_US   0x0000
-#define TIME_UNIT_MS   0x0001
-#define TIME_UNIT_S    0x0002
-#define TIME_UNIT_MIN  0x0003
-#define TIME_UNIT_HOUR 0x0004
-#define TIME_UNIT_DAY  0x0005
-#define TIME_UNIT_MASK 0x0007
-
-/* Multiply the two 32-bit operands and shift the 64-bit result right 32 bits.
- * This is used to compute fixed ratios by setting one of the operands to
- * (2^32*ratio).
- */
-static inline unsigned int mul32hi(unsigned int a, unsigned int b)
-{
-	return ((unsigned long long)a * b) >> 32;
-}
-
-/* copies at most <n> characters from <src> and always terminates with '\0' */
-char *my_strndup(const char *src, int n);
-
-/* This function returns the first unused key greater than or equal to <key> in
- * ID tree <root>. Zero is returned if no place is found.
- */
-unsigned int get_next_id(struct eb_root *root, unsigned int key);
-
-/* This function compares a sample word possibly followed by blanks to another
- * clean word. The compare is case-insensitive. 1 is returned if both are equal,
- * otherwise zero. This intends to be used when checking HTTP headers for some
- * values.
- */
-int word_match(const char *sample, int slen, const char *word, int wlen);
-
-#endif /* _COMMON_STANDARD_H */
diff --git a/deps/haproxy-1.4.21/include/common/template.h b/deps/haproxy-1.4.21/include/common/template.h
deleted file mode 100644
index c9e48bf..0000000
--- a/deps/haproxy-1.4.21/include/common/template.h
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
-  include/common/template.h
-  This file serves as a template for future include files.
-
-  Copyright (C) 2000-2006 Willy Tarreau - w@1wt.eu
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _COMMON_TEMPLATE_H
-#define _COMMON_TEMPLATE_H
-
-#include <common/config.h>
-
-#endif /* _COMMON_TEMPLATE_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/common/ticks.h b/deps/haproxy-1.4.21/include/common/ticks.h
deleted file mode 100644
index de29b31..0000000
--- a/deps/haproxy-1.4.21/include/common/ticks.h
+++ /dev/null
@@ -1,154 +0,0 @@
-/*
-  include/common/ticks.h
-  Functions and macros for manipulation of expiration timers
-
-  Copyright (C) 2000-2009 Willy Tarreau - w@1wt.eu
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-/*
- * Using a mix of milliseconds and timeval for internal timers is expensive and
- * overkill, because we don't need such a precision to compute timeouts.
- * So we're converting them to "ticks".
- *
- * A tick is a representation of a date relative to another one, and is
- * measured in milliseconds. The natural usage is to represent an absolute date
- * relative to the current date. Since it is not practical to update all values
- * each time the current date changes, instead we use the absolute date rounded
- * down to fit in a tick. We then have to compare a tick to the current date to
- * know whether it is in the future or in the past. If a tick is below the
- * current date, it is in the past. If it is above, it is in the future. The
- * values will wrap so we can't compare that easily, instead we check the sign
- * of the difference between a tick and the current date.
- *
- * Proceeding like this allows us to manipulate dates that are stored in
- * scalars with enough precision and range. For this reason, we store ticks in
- * 32-bit integers. This is enough to handle dates that are between 24.85 days
- * in the past and as much in the future.
- * 
- * We must both support absolute dates (well in fact, dates relative to now+/-
- * 24 days), and intervals (for timeouts). Both types need an "eternity" magic
- * value. For optimal code generation, we'll use zero as the magic value
- * indicating that an expiration timer or a timeout is not set. We have to
- * check that we don't return this value when adding timeouts to <now>. If a
- * computation returns 0, we must increase it to 1 (which will push the timeout
- * 1 ms further). For this reason, timeouts must not be added by hand but via
- * the dedicated tick_add() function.
- */
-
-#ifndef _COMMON_TICKS_H
-#define _COMMON_TICKS_H
-
-#include <common/config.h>
-#include <common/standard.h>
-
-#define TICK_ETERNITY   0
-
-/* right now, ticks are milliseconds. Both negative ms and negative ticks
- * indicate eternity.
- */
-#define MS_TO_TICKS(ms) (ms)
-#define TICKS_TO_MS(tk) (tk)
-
-/* return 1 if tick is set, otherwise 0 */
-static inline int tick_isset(int expire)
-{
-	return expire != 0;
-}
-
-/* Add <timeout> to <now>, and return the resulting expiration date.
- * <timeout> will not be checked for null values.
- */
-static inline int tick_add(int now, int timeout)
-{
-	now += timeout;
-	if (unlikely(!now))
-		now++;    /* unfortunate value */
-	return now;
-}
-
-/* add <timeout> to <now> if it is set, otherwise set it to eternity.
- * Return the resulting expiration date.
- */
-static inline int tick_add_ifset(int now, int timeout)
-{
-	if (!timeout)
-		return TICK_ETERNITY;
-	return tick_add(now, timeout);
-}
-
-/* return 1 if timer <t1> is before <t2>, none of which can be infinite. */
-static inline int tick_is_lt(int t1, int t2)
-{
-	return (t1 - t2) < 0;
-}
-
-/* return 1 if timer <t1> is before or equal to <t2>, none of which can be infinite. */
-static inline int tick_is_le(int t1, int t2)
-{
-	return (t1 - t2) <= 0;
-}
-
-/* return 1 if timer <timer> is expired at date <now>, otherwise zero */
-static inline int tick_is_expired(int timer, int now)
-{
-	if (unlikely(!tick_isset(timer)))
-		return 0;
-	if (unlikely((timer - now) <= 0))
-		return 1;
-	return 0;
-}
-
-/* return the first one of the two timers, both of which may be infinite */
-static inline int tick_first(int t1, int t2)
-{
-	if (!tick_isset(t1))
-		return t2;
-	if (!tick_isset(t2))
-		return t1;
-	if ((t1 - t2) <= 0)
-		return t1;
-	else
-		return t2;
-}
-
-/* return the first one of the two timers, where only the first one may be infinite */
-static inline int tick_first_2nz(int t1, int t2)
-{
-	if (!tick_isset(t1))
-		return t2;
-	if ((t1 - t2) <= 0)
-		return t1;
-	else
-		return t2;
-}
-
-/* return the number of ticks remaining from <now> to <exp>, or zero if expired */
-static inline int tick_remain(int now, int exp)
-{
-	if (tick_is_expired(exp, now))
-		return 0;
-	return exp - now;
-}
-
-#endif /* _COMMON_TICKS_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/common/time.h b/deps/haproxy-1.4.21/include/common/time.h
deleted file mode 100644
index abc1ccf..0000000
--- a/deps/haproxy-1.4.21/include/common/time.h
+++ /dev/null
@@ -1,526 +0,0 @@
-/*
-  include/common/time.h
-  Time calculation functions and macros.
-
-  Copyright (C) 2000-2008 Willy Tarreau - w@1wt.eu
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _COMMON_TIME_H
-#define _COMMON_TIME_H
-
-#include <stdlib.h>
-#include <sys/time.h>
-#include <common/config.h>
-#include <common/standard.h>
-
-#define SEC 1
-#define MINUTE (60 * SEC)
-#define HOUR (60 * MINUTE)
-#define DAY (24 * HOUR)
-
-/* eternity when exprimed in timeval */
-#ifndef TV_ETERNITY
-#define TV_ETERNITY     (~0UL)
-#endif
-
-/* eternity when exprimed in ms */
-#ifndef TV_ETERNITY_MS
-#define TV_ETERNITY_MS  (-1)
-#endif
-
-#define TIME_ETERNITY   (TV_ETERNITY_MS)
-
-/* we want to be able to detect time jumps. Fix the maximum wait time to a low
- * value so that we know the time has changed if we wait longer.
- */
-#define MAX_DELAY_MS    1000
-
-
-/* returns the lowest delay amongst <old> and <new>, and respects TIME_ETERNITY */
-#define MINTIME(old, new)	(((new)<0)?(old):(((old)<0||(new)<(old))?(new):(old)))
-#define SETNOW(a)		(*a=now)
-
-extern unsigned int   curr_sec_ms;      /* millisecond of current second (0..999) */
-extern unsigned int   curr_sec_ms_scaled;  /* millisecond of current second (0..2^32-1) */
-extern unsigned int   now_ms;           /* internal date in milliseconds (may wrap) */
-extern struct timeval now;              /* internal date is a monotonic function of real clock */
-extern struct timeval date;             /* the real current date */
-extern struct timeval start_date;       /* the process's start date */
-
-
-/**** exported functions *************************************************/
-
-
-/*
- * adds <ms> ms to <from>, set the result to <tv> and returns a pointer <tv>
- */
-REGPRM3 struct timeval *tv_ms_add(struct timeval *tv, const struct timeval *from, int ms);
-
-/*
- * compares <tv1> and <tv2> modulo 1ms: returns 0 if equal, -1 if tv1 < tv2, 1 if tv1 > tv2
- * Must not be used when either argument is eternity. Use tv_ms_cmp2() for that.
- */
-REGPRM2 int tv_ms_cmp(const struct timeval *tv1, const struct timeval *tv2);
-
-/*
- * compares <tv1> and <tv2> modulo 1 ms: returns 0 if equal, -1 if tv1 < tv2, 1 if tv1 > tv2,
- * assuming that TV_ETERNITY is greater than everything.
- */
-REGPRM2 int tv_ms_cmp2(const struct timeval *tv1, const struct timeval *tv2);
-
-/**** general purpose functions and macros *******************************/
-
-
-/* tv_now: sets <tv> to the current time */
-REGPRM1 static inline struct timeval *tv_now(struct timeval *tv)
-{
-	gettimeofday(tv, NULL);
-	return tv;
-}
-
-/* tv_udpate_date: sets <date> to system time, and sets <now> to something as
- * close as possible to real time, following a monotonic function. The main
- * principle consists in detecting backwards and forwards time jumps and adjust
- * an offset to correct them. This function should be called only once after
- * each poll. The poll's timeout should be passed in <max_wait>, and the return
- * value in <interrupted> (a non-zero value means that we have not expired the
- * timeout).
- */
-REGPRM2 void tv_update_date(int max_wait, int interrupted);
-
-/*
- * sets a struct timeval to its highest value so that it can never happen
- * note that only tv_usec is necessary to detect it since a tv_usec > 999999
- * is normally not possible.
- */
-REGPRM1 static inline struct timeval *tv_eternity(struct timeval *tv)
-{
-	tv->tv_sec = tv->tv_usec = TV_ETERNITY;
-	return tv;
-}
-
-/*
- * sets a struct timeval to 0
- *
- */
-REGPRM1 static inline struct timeval *tv_zero(struct timeval *tv) {
-	tv->tv_sec = tv->tv_usec = 0;
-	return tv;
-}
-
-/*
- * returns non null if tv is [eternity], otherwise 0.
- */
-#define tv_iseternity(tv)       ((tv)->tv_usec == TV_ETERNITY)
-
-/*
- * returns 0 if tv is [eternity], otherwise non-zero.
- */
-#define tv_isset(tv)       ((tv)->tv_usec != TV_ETERNITY)
-
-/*
- * returns non null if tv is [0], otherwise 0.
- */
-#define tv_iszero(tv)           (((tv)->tv_sec | (tv)->tv_usec) == 0)
-
-/*
- * Converts a struct timeval to a number of milliseconds.
- */
-REGPRM1 static inline unsigned long __tv_to_ms(const struct timeval *tv)
-{
-	unsigned long ret;
-
-	ret  = tv->tv_sec * 1000;
-	ret += tv->tv_usec / 1000;
-	return ret;
-}
-
-/*
- * Converts a struct timeval to a number of milliseconds.
- */
-REGPRM2 static inline struct timeval * __tv_from_ms(struct timeval *tv, unsigned long ms)
-{
-	tv->tv_sec = ms / 1000;
-	tv->tv_usec = (ms % 1000) * 1000;
-	return tv;
-}
-
-/* Return a number of 1024Hz ticks between 0 and 1023 for input number of
- * usecs between 0 and 999999. This function has been optimized to remove
- * any divide and multiply, as it is completely optimized away by the compiler
- * on CPUs which don't have a fast multiply. Its avg error rate is 305 ppm,
- * which is almost twice as low as a direct usec to ms conversion. This version
- * also has the benefit of returning 1024 for 1000000.
- */
-REGPRM1 static inline unsigned int __usec_to_1024th(unsigned int usec)
-{
-	return (usec * 1073 + 742516) >> 20;
-}
-
-
-/**** comparison functions and macros ***********************************/
-
-
-/* tv_cmp: compares <tv1> and <tv2> : returns 0 if equal, -1 if tv1 < tv2, 1 if tv1 > tv2. */
-REGPRM2 static inline int __tv_cmp(const struct timeval *tv1, const struct timeval *tv2)
-{
-	if ((unsigned)tv1->tv_sec < (unsigned)tv2->tv_sec)
-		return -1;
-	else if ((unsigned)tv1->tv_sec > (unsigned)tv2->tv_sec)
-		return 1;
-	else if ((unsigned)tv1->tv_usec < (unsigned)tv2->tv_usec)
-		return -1;
-	else if ((unsigned)tv1->tv_usec > (unsigned)tv2->tv_usec)
-		return 1;
-	else
-		return 0;
-}
-
-/* tv_iseq: compares <tv1> and <tv2> : returns 1 if tv1 == tv2, otherwise 0 */
-#define tv_iseq __tv_iseq
-REGPRM2 static inline int __tv_iseq(const struct timeval *tv1, const struct timeval *tv2)
-{
-	return ((unsigned)tv1->tv_sec  == (unsigned)tv2->tv_sec) &&
-		((unsigned)tv1->tv_usec == (unsigned)tv2->tv_usec);
-}
-
-/* tv_isgt: compares <tv1> and <tv2> : returns 1 if tv1 > tv2, otherwise 0 */
-#define tv_isgt _tv_isgt
-REGPRM2 int _tv_isgt(const struct timeval *tv1, const struct timeval *tv2);
-REGPRM2 static inline int __tv_isgt(const struct timeval *tv1, const struct timeval *tv2)
-{
-	return
-		((unsigned)tv1->tv_sec  == (unsigned)tv2->tv_sec) ?
-		((unsigned)tv1->tv_usec >  (unsigned)tv2->tv_usec) :
-		((unsigned)tv1->tv_sec  >  (unsigned)tv2->tv_sec);
-}
-
-/* tv_isge: compares <tv1> and <tv2> : returns 1 if tv1 >= tv2, otherwise 0 */
-#define tv_isge __tv_isge
-REGPRM2 static inline int __tv_isge(const struct timeval *tv1, const struct timeval *tv2)
-{
-	return
-		((unsigned)tv1->tv_sec  == (unsigned)tv2->tv_sec) ?
-		((unsigned)tv1->tv_usec >= (unsigned)tv2->tv_usec) :
-		((unsigned)tv1->tv_sec  >  (unsigned)tv2->tv_sec);
-}
-
-/* tv_islt: compares <tv1> and <tv2> : returns 1 if tv1 < tv2, otherwise 0 */
-#define tv_islt __tv_islt
-REGPRM2 static inline int __tv_islt(const struct timeval *tv1, const struct timeval *tv2)
-{
-	return
-		((unsigned)tv1->tv_sec  == (unsigned)tv2->tv_sec) ?
-		((unsigned)tv1->tv_usec <  (unsigned)tv2->tv_usec) :
-		((unsigned)tv1->tv_sec  <  (unsigned)tv2->tv_sec);
-}
-
-/* tv_isle: compares <tv1> and <tv2> : returns 1 if tv1 <= tv2, otherwise 0 */
-#define tv_isle _tv_isle
-REGPRM2 int _tv_isle(const struct timeval *tv1, const struct timeval *tv2);
-REGPRM2 static inline int __tv_isle(const struct timeval *tv1, const struct timeval *tv2)
-{
-	return
-		((unsigned)tv1->tv_sec  == (unsigned)tv2->tv_sec) ?
-		((unsigned)tv1->tv_usec <= (unsigned)tv2->tv_usec) :
-		((unsigned)tv1->tv_sec  <  (unsigned)tv2->tv_sec);
-}
-
-/*
- * compares <tv1> and <tv2> modulo 1ms: returns 0 if equal, -1 if tv1 < tv2, 1 if tv1 > tv2
- * Must not be used when either argument is eternity. Use tv_ms_cmp2() for that.
- */
-#define tv_ms_cmp _tv_ms_cmp
-REGPRM2 int _tv_ms_cmp(const struct timeval *tv1, const struct timeval *tv2);
-REGPRM2 static inline int __tv_ms_cmp(const struct timeval *tv1, const struct timeval *tv2)
-{
-	if ((unsigned)tv1->tv_sec == (unsigned)tv2->tv_sec) {
-		if ((unsigned)tv2->tv_usec >= (unsigned)tv1->tv_usec + 1000)
-			return -1;
-		else if ((unsigned)tv1->tv_usec >= (unsigned)tv2->tv_usec + 1000)
-			return 1;
-		else
-			return 0;
-	}
-	else if (((unsigned)tv2->tv_sec > (unsigned)tv1->tv_sec + 1) ||
-		 (((unsigned)tv2->tv_sec == (unsigned)tv1->tv_sec + 1) &&
-		  ((unsigned)tv2->tv_usec + 1000000 >= (unsigned)tv1->tv_usec + 1000)))
-		return -1;
-	else if (((unsigned)tv1->tv_sec > (unsigned)tv2->tv_sec + 1) ||
-		 (((unsigned)tv1->tv_sec == (unsigned)tv2->tv_sec + 1) &&
-		  ((unsigned)tv1->tv_usec + 1000000 >= (unsigned)tv2->tv_usec + 1000)))
-		return 1;
-	else
-		return 0;
-}
-
-/*
- * compares <tv1> and <tv2> modulo 1 ms: returns 0 if equal, -1 if tv1 < tv2, 1 if tv1 > tv2,
- * assuming that TV_ETERNITY is greater than everything.
- */
-#define tv_ms_cmp2 _tv_ms_cmp2
-REGPRM2 int _tv_ms_cmp2(const struct timeval *tv1, const struct timeval *tv2);
-REGPRM2 static inline int __tv_ms_cmp2(const struct timeval *tv1, const struct timeval *tv2)
-{
-	if (tv_iseternity(tv1))
-		if (tv_iseternity(tv2))
-			return 0; /* same */
-		else
-			return 1; /* tv1 later than tv2 */
-	else if (tv_iseternity(tv2))
-		return -1; /* tv2 later than tv1 */
-	return tv_ms_cmp(tv1, tv2);
-}
-
-/*
- * compares <tv1> and <tv2> modulo 1 ms: returns 1 if tv1 <= tv2, 0 if tv1 > tv2,
- * assuming that TV_ETERNITY is greater than everything. Returns 0 if tv1 is
- * TV_ETERNITY, and always assumes that tv2 != TV_ETERNITY. Designed to replace
- * occurrences of (tv_ms_cmp2(tv,now) <= 0).
- */
-#define tv_ms_le2 _tv_ms_le2
-REGPRM2 int _tv_ms_le2(const struct timeval *tv1, const struct timeval *tv2);
-REGPRM2 static inline int __tv_ms_le2(const struct timeval *tv1, const struct timeval *tv2)
-{
-	if (likely((unsigned)tv1->tv_sec > (unsigned)tv2->tv_sec + 1))
-		return 0;
-
-	if (likely((unsigned)tv1->tv_sec < (unsigned)tv2->tv_sec))
-		return 1;
-
-	if (likely((unsigned)tv1->tv_sec == (unsigned)tv2->tv_sec)) {
-		if ((unsigned)tv2->tv_usec >= (unsigned)tv1->tv_usec + 1000)
-			return 1;
-		else
-			return 0;
-	}
-
-	if (unlikely(((unsigned)tv1->tv_sec == (unsigned)tv2->tv_sec + 1) &&
-		     ((unsigned)tv1->tv_usec + 1000000 >= (unsigned)tv2->tv_usec + 1000)))
-		return 0;
-	else
-		return 1;
-}
-
-
-/**** operators **********************************************************/
-
-
-/*
- * Returns the time in ms elapsed between tv1 and tv2, assuming that tv1<=tv2.
- * Must not be used when either argument is eternity.
- */
-#define tv_ms_elapsed __tv_ms_elapsed
-REGPRM2 unsigned long _tv_ms_elapsed(const struct timeval *tv1, const struct timeval *tv2);
-REGPRM2 static inline unsigned long __tv_ms_elapsed(const struct timeval *tv1, const struct timeval *tv2)
-{
-	unsigned long ret;
-
-	ret  = ((signed long)(tv2->tv_sec  - tv1->tv_sec))  * 1000;
-	ret += ((signed long)(tv2->tv_usec - tv1->tv_usec)) / 1000;
-	return ret;
-}
-
-/*
- * returns the remaining time between tv1=now and event=tv2
- * if tv2 is passed, 0 is returned.
- * Must not be used when either argument is eternity.
- */
-
-#define tv_ms_remain __tv_ms_remain
-REGPRM2 unsigned long _tv_ms_remain(const struct timeval *tv1, const struct timeval *tv2);
-REGPRM2 static inline unsigned long __tv_ms_remain(const struct timeval *tv1, const struct timeval *tv2)
-{
-	if (tv_ms_cmp(tv1, tv2) >= 0)
-		return 0; /* event elapsed */
-
-	return __tv_ms_elapsed(tv1, tv2);
-}
-
-/*
- * returns the remaining time between tv1=now and event=tv2
- * if tv2 is passed, 0 is returned.
- * Returns TIME_ETERNITY if tv2 is eternity.
- */
-#define tv_ms_remain2 _tv_ms_remain2
-REGPRM2 unsigned long _tv_ms_remain2(const struct timeval *tv1, const struct timeval *tv2);
-REGPRM2 static inline unsigned long __tv_ms_remain2(const struct timeval *tv1, const struct timeval *tv2)
-{
-	if (tv_iseternity(tv2))
-		return TIME_ETERNITY;
-
-	return tv_ms_remain(tv1, tv2);
-}
-
-/*
- * adds <inc> to <from>, set the result to <tv> and returns a pointer <tv>
- */
-#define tv_add _tv_add
-REGPRM3 struct timeval *_tv_add(struct timeval *tv, const struct timeval *from, const struct timeval *inc);
-REGPRM3 static inline struct timeval *__tv_add(struct timeval *tv, const struct timeval *from, const struct timeval *inc)
-{
-	tv->tv_usec = from->tv_usec + inc->tv_usec;
-	tv->tv_sec  = from->tv_sec  + inc->tv_sec;
-	if (tv->tv_usec >= 1000000) {
-		tv->tv_usec -= 1000000;
-		tv->tv_sec++;
-	}
-	return tv;
-}
-
-
-/*
- * If <inc> is set, then add it to <from> and set the result to <tv>, then
- * return 1, otherwise return 0. It is meant to be used in if conditions.
- */
-#define tv_add_ifset _tv_add_ifset
-REGPRM3 int _tv_add_ifset(struct timeval *tv, const struct timeval *from, const struct timeval *inc);
-REGPRM3 static inline int __tv_add_ifset(struct timeval *tv, const struct timeval *from, const struct timeval *inc)
-{
-	if (tv_iseternity(inc))
-		return 0;
-	tv->tv_usec = from->tv_usec + inc->tv_usec;
-	tv->tv_sec  = from->tv_sec  + inc->tv_sec;
-	if (tv->tv_usec >= 1000000) {
-		tv->tv_usec -= 1000000;
-		tv->tv_sec++;
-	}
-	return 1;
-}
-
-/*
- * adds <inc> to <tv> and returns a pointer <tv>
- */
-REGPRM2 static inline struct timeval *__tv_add2(struct timeval *tv, const struct timeval *inc)
-{
-	tv->tv_usec += inc->tv_usec;
-	tv->tv_sec  += inc->tv_sec;
-	if (tv->tv_usec >= 1000000) {
-		tv->tv_usec -= 1000000;
-		tv->tv_sec++;
-	}
-	return tv;
-}
-
-
-/*
- * Computes the remaining time between tv1=now and event=tv2. if tv2 is passed,
- * 0 is returned. The result is stored into tv.
- */
-#define tv_remain _tv_remain
-REGPRM3 struct timeval *_tv_remain(const struct timeval *tv1, const struct timeval *tv2, struct timeval *tv);
-REGPRM3 static inline struct timeval *__tv_remain(const struct timeval *tv1, const struct timeval *tv2, struct timeval *tv)
-{
-	tv->tv_usec = tv2->tv_usec - tv1->tv_usec;
-	tv->tv_sec  = tv2->tv_sec  - tv1->tv_sec;
-	if ((signed)tv->tv_sec > 0) {
-		if ((signed)tv->tv_usec < 0) {
-			tv->tv_usec += 1000000;
-			tv->tv_sec--;
-		}
-	} else if (tv->tv_sec == 0) {
-		if ((signed)tv->tv_usec < 0)
-			tv->tv_usec = 0;
-	} else {
-		tv->tv_sec = 0;
-		tv->tv_usec = 0;
-	}
- 	return tv;
-}
-
-
-/*
- * Computes the remaining time between tv1=now and event=tv2. if tv2 is passed,
- * 0 is returned. The result is stored into tv. Returns ETERNITY if tv2 is
- * eternity.
- */
-#define tv_remain2 _tv_remain2
-REGPRM3 struct timeval *_tv_remain2(const struct timeval *tv1, const struct timeval *tv2, struct timeval *tv);
-REGPRM3 static inline struct timeval *__tv_remain2(const struct timeval *tv1, const struct timeval *tv2, struct timeval *tv)
-{
-	if (tv_iseternity(tv2))
-		return tv_eternity(tv);
-	return __tv_remain(tv1, tv2, tv);
-}
-
-
-/*
- * adds <ms> ms to <from>, set the result to <tv> and returns a pointer <tv>
- */
-#define tv_ms_add _tv_ms_add
-REGPRM3 struct timeval *_tv_ms_add(struct timeval *tv, const struct timeval *from, int ms);
-REGPRM3 static inline struct timeval *__tv_ms_add(struct timeval *tv, const struct timeval *from, int ms)
-{
-	tv->tv_usec = from->tv_usec + (ms % 1000) * 1000;
-	tv->tv_sec  = from->tv_sec  + (ms / 1000);
-	while (tv->tv_usec >= 1000000) {
-		tv->tv_usec -= 1000000;
-		tv->tv_sec++;
-	}
-	return tv;
-}
-
-
-/*
- * compares <tv1> and <tv2> : returns 1 if <tv1> is before <tv2>, otherwise 0.
- * This should be very fast because it's used in schedulers.
- * It has been optimized to return 1  (so call it in a loop which continues
- * as long as tv1<=tv2)
- */
-
-#define tv_isbefore(tv1, tv2)                                               \
-	(unlikely((unsigned)(tv1)->tv_sec < (unsigned)(tv2)->tv_sec) ? 1 :  \
-	 (unlikely((unsigned)(tv1)->tv_sec > (unsigned)(tv2)->tv_sec) ? 0 : \
-	  unlikely((unsigned)(tv1)->tv_usec < (unsigned)(tv2)->tv_usec)))
-
-/*
- * returns the first event between <tv1> and <tv2> into <tvmin>.
- * a zero tv is ignored. <tvmin> is returned. If <tvmin> is known
- * to be the same as <tv1> or <tv2>, it is recommended to use
- * tv_bound instead.
- */
-#define tv_min(tvmin, tv1, tv2) ({      \
-        if (tv_isbefore(tv1, tv2)) {    \
-                *tvmin = *tv1;          \
-        }                               \
-        else {                          \
-                *tvmin = *tv2;          \
-        }                               \
-        tvmin;                          \
-})
-
-/*
- * returns the first event between <tv1> and <tv2> into <tvmin>.
- * a zero tv is ignored. <tvmin> is returned. This function has been
- * optimized to be called as tv_min(a,a,b) or tv_min(b,a,b).
- */
-#define tv_bound(tv1, tv2) ({      \
-        if (tv_isbefore(tv2, tv1)) \
-                  *tv1 = *tv2;     \
-        tv1;                       \
-})
-
-char *human_time(int t, short hz_div);
-
-#endif /* _COMMON_TIME_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/common/tools.h b/deps/haproxy-1.4.21/include/common/tools.h
deleted file mode 100644
index e8d02c6..0000000
--- a/deps/haproxy-1.4.21/include/common/tools.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * include/common/tools.h
- * Trivial macros needed everywhere.
- *
- * Copyright (C) 2000-2011 Willy Tarreau - w@1wt.eu
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _COMMON_TOOLS_H
-#define _COMMON_TOOLS_H
-
-#include <common/config.h>
-
-#ifndef MIN
-#define MIN(a, b) (((a) < (b)) ? (a) : (b))
-#endif
-
-#ifndef MAX
-#define MAX(a, b) (((a) > (b)) ? (a) : (b))
-#endif
-
-/* return an integer of type <ret> with only the highest bit set. <ret> may be
- * both a variable or a type.
- */
-#define MID_RANGE(ret) ((typeof(ret))1 << (8*sizeof(ret) - 1))
-
-/* return the largest possible integer of type <ret>, with all bits set */
-#define MAX_RANGE(ret) (~(typeof(ret))0)
-
-#endif /* _COMMON_TOOLS_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/common/uri_auth.h b/deps/haproxy-1.4.21/include/common/uri_auth.h
deleted file mode 100644
index 906cb2c..0000000
--- a/deps/haproxy-1.4.21/include/common/uri_auth.h
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * URI-based user authentication using the HTTP basic method.
- *
- * Copyright 2006-2007 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#ifndef _COMMON_URI_AUTH_H
-#define _COMMON_URI_AUTH_H
-
-#include <common/config.h>
-
-#include <types/auth.h>
-
-/* This is a list of proxies we are allowed to see. Later, it should go in the
- * user list, but before this we need to support de/re-authentication.
- */
-struct stat_scope {
-	struct stat_scope *next;	/* next entry, NULL if none */
-	int px_len;			/* proxy name length */
-	char *px_id;			/* proxy id */
-};
-
-#define	ST_HIDEVER	0x00000001	/* do not report the version and reldate */
-#define	ST_SHNODE	0x00000002	/* show node name */
-#define	ST_SHDESC	0x00000004	/* show description */
-#define	ST_SHLGNDS	0x00000008	/* show legends */
-#define	ST_CONVDONE	0x00000010	/* req_acl conversion done */
-
-/* later we may link them to support multiple URI matching */
-struct uri_auth {
-	int uri_len;			/* the prefix length */
-	char *uri_prefix;		/* the prefix we want to match */
-	char *auth_realm;		/* the realm reported to the client */
-	char *node, *desc;		/* node name & description reported in this stats */
-	int refresh;			/* refresh interval for the browser (in seconds) */
-	int flags;			/* some flags describing the statistics page */
-	struct stat_scope *scope;	/* linked list of authorized proxies */
-	struct userlist *userlist;	/* private userlist to emulate legacy "stats auth user:password" */
-	struct list req_acl; 		/* http stats ACL: allow/deny/auth */
-	struct list admin_rules;	/* 'stats admin' rules (chained) */
-	struct uri_auth *next;		/* Used at deinit() to build a list of unique elements */
-};
-
-/* This is the default statistics URI */
-#ifdef CONFIG_STATS_DEFAULT_URI
-#define STATS_DEFAULT_URI CONFIG_STATS_DEFAULT_URI
-#else
-#define STATS_DEFAULT_URI "/haproxy?stats"
-#endif
-
-/* This is the default statistics realm */
-#ifdef CONFIG_STATS_DEFAULT_REALM
-#define STATS_DEFAULT_REALM CONFIG_STATS_DEFAULT_REALM
-#else
-#define STATS_DEFAULT_REALM "HAProxy Statistics"
-#endif
-
-
-struct stats_admin_rule {
-	struct list list;	/* list linked to from the proxy */
-	struct acl_cond *cond;	/* acl condition to meet */
-};
-
-
-/* Various functions used to set the fields during the configuration parsing.
- * Please that all those function can initialize the root entry in order not to
- * force the user to respect a certain order in the configuration file.
- *
- * Default values are used during initialization. Check STATS_DEFAULT_* for
- * more information.
- */
-struct uri_auth *stats_check_init_uri_auth(struct uri_auth **root);
-struct uri_auth *stats_set_uri(struct uri_auth **root, char *uri);
-struct uri_auth *stats_set_realm(struct uri_auth **root, char *realm);
-struct uri_auth *stats_set_refresh(struct uri_auth **root, int interval);
-struct uri_auth *stats_set_flag(struct uri_auth **root, int flag);
-struct uri_auth *stats_add_auth(struct uri_auth **root, char *user);
-struct uri_auth *stats_add_scope(struct uri_auth **root, char *scope);
-struct uri_auth *stats_set_node(struct uri_auth **root, char *name);
-struct uri_auth *stats_set_desc(struct uri_auth **root, char *desc);
-
-#endif /* _COMMON_URI_AUTH_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/common/version.h b/deps/haproxy-1.4.21/include/common/version.h
deleted file mode 100644
index a869231..0000000
--- a/deps/haproxy-1.4.21/include/common/version.h
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
-  include/common/version.h
-  This file serves as a template for future include files.
-
-  Copyright (C) 2000-2007 Willy Tarreau - w@1wt.eu
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _COMMON_VERSION_H
-#define _COMMON_VERSION_H
-
-#include <common/config.h>
-
-#ifdef  CONFIG_PRODUCT_NAME
-#define PRODUCT_NAME    CONFIG_PRODUCT_NAME
-#else
-#define PRODUCT_NAME    "HAProxy"
-#endif
-
-#ifdef  CONFIG_PRODUCT_BRANCH
-#define PRODUCT_BRANCH    CONFIG_PRODUCT_BRANCH
-#else
-#define PRODUCT_BRANCH   "1.4"
-#endif
-
-#ifdef  CONFIG_PRODUCT_URL
-#define PRODUCT_URL    CONFIG_PRODUCT_URL
-#else
-#define PRODUCT_URL    "http://haproxy.1wt.eu/"
-#endif
-
-#ifdef  CONFIG_PRODUCT_URL_UPD
-#define PRODUCT_URL_UPD  CONFIG_PRODUCT_URL_UPD
-#else
-#define PRODUCT_URL_UPD "http://haproxy.1wt.eu/#down"
-#endif
-
-#ifdef  CONFIG_PRODUCT_URL_DOC
-#define PRODUCT_URL_DOC  CONFIG_PRODUCT_URL_DOC
-#else
-#define PRODUCT_URL_DOC "http://haproxy.1wt.eu/#docs"
-#endif
-
-#ifdef CONFIG_HAPROXY_VERSION
-#define HAPROXY_VERSION CONFIG_HAPROXY_VERSION
-#else
-#error "Must define CONFIG_HAPROXY_VERSION"
-#endif
-
-#ifdef CONFIG_HAPROXY_DATE
-#define HAPROXY_DATE    CONFIG_HAPROXY_DATE
-#else
-#error "Must define CONFIG_HAPROXY_DATE"
-#endif
-
-#endif /* _COMMON_VERSION_H */
-
diff --git a/deps/haproxy-1.4.21/include/import/ip_tproxy.h b/deps/haproxy-1.4.21/include/import/ip_tproxy.h
deleted file mode 100644
index d33f14d..0000000
--- a/deps/haproxy-1.4.21/include/import/ip_tproxy.h
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Transparent proxy support for Linux/iptables
- *
- * Copyright (c) 2002-2004 BalaBit IT Ltd.
- * Author: Balzs Scheidler
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- */
-
-#ifndef _IP_TPROXY_H
-#define _IP_TPROXY_H
-
-#ifdef __KERNEL__
-#include <linux/types.h>
-#include <linux/in.h>
-#else
-#include <netinet/in.h>
-#ifndef IP_RECVORIGADDRS
-#define IP_RECVORIGADDRS	11273
-#define IP_ORIGADDRS	IP_RECVORIGADDRS
-struct in_origaddrs {
-        struct in_addr ioa_srcaddr;
-        struct in_addr ioa_dstaddr;
-        unsigned short int ioa_srcport;
-        unsigned short int ioa_dstport;
-};
-#endif
-#endif
-
-/* 
- * used in setsockopt(SOL_IP, IP_TPROXY) should not collide 
- * with values in <linux/in.h> 
- */
-
-#define IP_TPROXY	   11274
-
-/* tproxy operations */
-enum {
-	TPROXY_VERSION = 0,
-	TPROXY_ASSIGN,
-	TPROXY_UNASSIGN,
-	TPROXY_QUERY,
-	TPROXY_FLAGS,
-	TPROXY_ALLOC,
-	TPROXY_CONNECT
-};
-
-/* bitfields in IP_TPROXY_FLAGS */
-#define ITP_CONNECT     0x00000001
-#define ITP_LISTEN      0x00000002
-#define ITP_ESTABLISHED 0x00000004
-
-#define ITP_ONCE        0x00010000
-#define ITP_MARK        0x00020000
-#define ITP_APPLIED     0x00040000
-#define ITP_UNIDIR      0x00080000
-
-struct in_tproxy_addr{
-	struct in_addr	faddr;
-	u_int16_t	fport;
-};
-
-struct in_tproxy {
-	/* fixed part, should not change between versions */
-	u_int32_t op;
-	/* extensible part */
-	union _in_args {
-		u_int32_t		version;
-		struct in_tproxy_addr	addr;
-		u_int32_t		flags;
-	} v;
-};
-
-#endif
diff --git a/deps/haproxy-1.4.21/include/proto/acl.h b/deps/haproxy-1.4.21/include/proto/acl.h
deleted file mode 100644
index 9b556ba..0000000
--- a/deps/haproxy-1.4.21/include/proto/acl.h
+++ /dev/null
@@ -1,217 +0,0 @@
-/*
- * include/proto/acl.h
- * This file provides interface definitions for ACL manipulation.
- *
- * Copyright (C) 2000-2011 Willy Tarreau - w@1wt.eu
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _PROTO_ACL_H
-#define _PROTO_ACL_H
-
-#include <common/config.h>
-#include <types/acl.h>
-
-/*
- * FIXME: we need destructor functions too !
- */
-
-/* Negate an acl result. This turns (ACL_PAT_FAIL, ACL_PAT_MISS, ACL_PAT_PASS)
- * into (ACL_PAT_PASS, ACL_PAT_MISS, ACL_PAT_FAIL).
- */
-static inline int acl_neg(int res)
-{
-	return (3 >> res);
-}
-
-/* Convert an acl result to a boolean. Only ACL_PAT_PASS returns 1. */
-static inline int acl_pass(int res)
-{
-	return (res >> 1);
-}
-
-/* Return a pointer to the ACL <name> within the list starting at <head>, or
- * NULL if not found.
- */
-struct acl *find_acl_by_name(const char *name, struct list *head);
-
-/* Return a pointer to the ACL keyword <kw> within the list starting at <head>,
- * or NULL if not found. Note that if <kw> contains an opening parenthesis,
- * only the left part of it is checked.
- */
-struct acl_keyword *find_acl_kw(const char *kw);
-
-/* Parse an ACL expression starting at <args>[0], and return it.
- * Right now, the only accepted syntax is :
- * <subject> [<value>...]
- */
-struct acl_expr *parse_acl_expr(const char **args);
-
-/* Purge everything in the acl <acl>, then return <acl>. */
-struct acl *prune_acl(struct acl *acl);
-
-/* Parse an ACL with the name starting at <args>[0], and with a list of already
- * known ACLs in <acl>. If the ACL was not in the list, it will be added.
- * A pointer to that ACL is returned.
- *
- * args syntax: <aclname> <acl_expr>
- */
-struct acl *parse_acl(const char **args, struct list *known_acl);
-
-/* Purge everything in the acl_cond <cond>, then return <cond>. */
-struct acl_cond *prune_acl_cond(struct acl_cond *cond);
-
-/* Parse an ACL condition starting at <args>[0], relying on a list of already
- * known ACLs passed in <known_acl>. The new condition is returned (or NULL in
- * case of low memory). Supports multiple conditions separated by "or".
- */
-struct acl_cond *parse_acl_cond(const char **args, struct list *known_acl, int pol);
-
-/* Builds an ACL condition starting at the if/unless keyword. The complete
- * condition is returned. NULL is returned in case of error or if the first
- * word is neither "if" nor "unless". It automatically sets the file name and
- * the line number in the condition for better error reporting, and adds the
- * ACL requirements to the proxy's acl_requires.
- */
-struct acl_cond *build_acl_cond(const char *file, int line, struct proxy *px, const char **args);
-
-/* Execute condition <cond> and return either ACL_PAT_FAIL, ACL_PAT_MISS or
- * ACL_PAT_PASS depending on the test results. This function only computes the
- * condition, it does not apply the polarity required by IF/UNLESS, it's up to
- * the caller to do this.
- */
-int acl_exec_cond(struct acl_cond *cond, struct proxy *px, struct session *l4, void *l7, int dir);
-
-/* Reports a pointer to the first ACL used in condition <cond> which requires
- * at least one of the USE_FLAGS in <require>. Returns NULL if none matches.
- */
-struct acl *cond_find_require(const struct acl_cond *cond, unsigned int require);
-
-/*
- * Find targets for userlist and groups in acl. Function returns the number
- * of errors or OK if everything is fine.
- */
-int acl_find_targets(struct proxy *p);
-
-/* Return a pointer to the ACL <name> within the list starting at <head>, or
- * NULL if not found.
- */
-struct acl *find_acl_by_name(const char *name, struct list *head);
-
-/*
- * Registers the ACL keyword list <kwl> as a list of valid keywords for next
- * parsing sessions.
- */
-void acl_register_keywords(struct acl_kw_list *kwl);
-
-/*
- * Unregisters the ACL keyword list <kwl> from the list of valid keywords.
- */
-void acl_unregister_keywords(struct acl_kw_list *kwl);
-
-
-/*
- *
- * The following functions are general purpose ACL matching functions.
- *
- */
-
-
-/* ignore the current line */
-int acl_parse_nothing(const char **text, struct acl_pattern *pattern, int *opaque);
-
-/* NB: For two strings to be identical, it is required that their lengths match */
-int acl_match_str(struct acl_test *test, struct acl_pattern *pattern);
-
-/* Checks that the length of the pattern in <test> is included between min and max */
-int acl_match_len(struct acl_test *test, struct acl_pattern *pattern);
-
-/* Checks that the integer in <test> is included between min and max */
-int acl_match_int(struct acl_test *test, struct acl_pattern *pattern);
-
-/* Parse an integer. It is put both in min and max. */
-int acl_parse_int(const char **text, struct acl_pattern *pattern, int *opaque);
-
-/* Parse an version. It is put both in min and max. */
-int acl_parse_dotted_ver(const char **text, struct acl_pattern *pattern, int *opaque);
-
-/* Parse a range of integers delimited by either ':' or '-'. If only one
- * integer is read, it is set as both min and max.
- */
-int acl_parse_range(const char **text, struct acl_pattern *pattern, int *opaque);
-
-/* Parse a string. It is allocated and duplicated. */
-int acl_parse_str(const char **text, struct acl_pattern *pattern, int *opaque);
-
-/* Parse and concatenate strings into one. It is allocated and duplicated. */
-int acl_parse_strcat(const char **text, struct acl_pattern *pattern, int *opaque);
-
-/* Parse a regex. It is allocated. */
-int acl_parse_reg(const char **text, struct acl_pattern *pattern, int *opaque);
-
-/* Parse an IP address and an optional mask in the form addr[/mask].
- * The addr may either be an IPv4 address or a hostname. The mask
- * may either be a dotted mask or a number of bits. Returns 1 if OK,
- * otherwise 0.
- */
-int acl_parse_ip(const char **text, struct acl_pattern *pattern, int *opaque);
-
-/* always fake a data retrieval */
-int acl_fetch_nothing(struct proxy *px, struct session *l4, void *l7, int dir,
-		      struct acl_expr *expr, struct acl_test *test);
-
-/* always return false */
-int acl_match_nothing(struct acl_test *test, struct acl_pattern *pattern);
-
-/* Checks that the pattern matches the end of the tested string. */
-int acl_match_end(struct acl_test *test, struct acl_pattern *pattern);
-
-/* Checks that the pattern matches the beginning of the tested string. */
-int acl_match_beg(struct acl_test *test, struct acl_pattern *pattern);
-
-/* Checks that the pattern is included inside the tested string. */
-int acl_match_sub(struct acl_test *test, struct acl_pattern *pattern);
-
-/* Checks that the pattern is included inside the tested string, but enclosed
- * between slashes or at the beginning or end of the string. Slashes at the
- * beginning or end of the pattern are ignored.
- */
-int acl_match_dir(struct acl_test *test, struct acl_pattern *pattern);
-
-/* Checks that the pattern is included inside the tested string, but enclosed
- * between dots or at the beginning or end of the string. Dots at the beginning
- * or end of the pattern are ignored.
- */
-int acl_match_dom(struct acl_test *test, struct acl_pattern *pattern);
-
-/* Check that the IPv4 address in <test> matches the IP/mask in pattern */
-int acl_match_ip(struct acl_test *test, struct acl_pattern *pattern);
-
-/* Executes a regex. It needs to change the data. If it is marked READ_ONLY
- * then it will be allocated and duplicated in place so that others may use
- * it later on. Note that this is embarrassing because we always try to avoid
- * allocating memory at run time.
- */
-int acl_match_reg(struct acl_test *test, struct acl_pattern *pattern);
-
-#endif /* _PROTO_ACL_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/proto/auth.h b/deps/haproxy-1.4.21/include/proto/auth.h
deleted file mode 100644
index 7385ab0..0000000
--- a/deps/haproxy-1.4.21/include/proto/auth.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * User authentication & authorization.
- *
- * Copyright 2010 Krzysztof Piotr Oledzki <ole@ans.pl>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#ifndef _PROTO_AUTH_H
-#define _PROTO_AUTH_H
-
-#include <common/config.h>
-#include <types/auth.h>
-
-extern struct userlist *userlist;
-
-struct userlist *auth_find_userlist(char *name);
-unsigned int auth_resolve_groups(struct userlist *l, char *groups);
-struct req_acl_rule *parse_auth_cond(const char **args, const char *file, int linenum, struct proxy *proxy);
-void userlist_free(struct userlist *ul);
-void req_acl_free(struct list *r);
-int acl_match_auth(struct acl_test *test, struct acl_pattern *pattern);
-
-#endif /* _PROTO_AUTH_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
-
diff --git a/deps/haproxy-1.4.21/include/proto/backend.h b/deps/haproxy-1.4.21/include/proto/backend.h
deleted file mode 100644
index c8322b8..0000000
--- a/deps/haproxy-1.4.21/include/proto/backend.h
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * include/proto/backend.h
- * Functions prototypes for the backend.
- *
- * Copyright (C) 2000-2012 Willy Tarreau - w@1wt.eu
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _PROTO_BACKEND_H
-#define _PROTO_BACKEND_H
-
-#include <common/config.h>
-
-#include <types/backend.h>
-#include <types/proxy.h>
-#include <types/server.h>
-#include <types/session.h>
-
-int assign_server(struct session *s);
-int assign_server_address(struct session *s);
-int assign_server_and_queue(struct session *s);
-int connect_server(struct session *s);
-int srv_redispatch_connect(struct session *t);
-const char *backend_lb_algo_str(int algo);
-int backend_parse_balance(const char **args, char *err,
-			  int errlen, struct proxy *curproxy);
-
-int be_downtime(struct proxy *px);
-void recount_servers(struct proxy *px);
-void update_backend_weight(struct proxy *px);
-struct server *get_server_sh(struct proxy *px, const char *addr, int len);
-struct server *get_server_uh(struct proxy *px, char *uri, int uri_len);
-
-/* This function returns non-zero if a server with the given weight and state
- * is usable for LB, otherwise zero.
- */
-static inline int srv_is_usable(int state, int weight)
-{
-	if (!weight)
-		return 0;
-	if (state & (SRV_GOINGDOWN | SRV_MAINTAIN))
-		return 0;
-	if (!(state & SRV_RUNNING))
-		return 0;
-	return 1;
-}
-
-#endif /* _PROTO_BACKEND_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/proto/buffers.h b/deps/haproxy-1.4.21/include/proto/buffers.h
deleted file mode 100644
index cd3685f..0000000
--- a/deps/haproxy-1.4.21/include/proto/buffers.h
+++ /dev/null
@@ -1,532 +0,0 @@
-/*
- * include/proto/buffers.h
- * Buffer management definitions, macros and inline functions.
- *
- * Copyright (C) 2000-2010 Willy Tarreau - w@1wt.eu
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _PROTO_BUFFERS_H
-#define _PROTO_BUFFERS_H
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include <common/config.h>
-#include <common/memory.h>
-#include <common/ticks.h>
-#include <common/time.h>
-
-#include <types/buffers.h>
-#include <types/global.h>
-
-extern struct pool_head *pool2_buffer;
-
-/* perform minimal intializations, report 0 in case of error, 1 if OK. */
-int init_buffer();
-
-/* Initialize all fields in the buffer. The BF_OUT_EMPTY flags is set. */
-static inline void buffer_init(struct buffer *buf)
-{
-	buf->send_max = 0;
-	buf->to_forward = 0;
-	buf->l = buf->total = 0;
-	buf->pipe = NULL;
-	buf->analysers = 0;
-	buf->cons = NULL;
-	buf->flags = BF_OUT_EMPTY;
-	buf->r = buf->lr = buf->w = buf->data;
-}
-
-/* Return the max number of bytes the buffer can contain so that once all the
- * pending bytes are forwarded, the buffer still has global.tune.maxrewrite
- * bytes free. The result sits between buf->size - maxrewrite and buf->size.
- */
-static inline int buffer_max_len(struct buffer *buf)
-{
-	if (buf->to_forward == BUF_INFINITE_FORWARD ||
-	    buf->to_forward + buf->send_max >= global.tune.maxrewrite)
-		return buf->size;
-	else
-		return buf->size - global.tune.maxrewrite + buf->to_forward + buf->send_max;
-}
-
-/* Check buffer timeouts, and set the corresponding flags. The
- * likely/unlikely have been optimized for fastest normal path.
- * The read/write timeouts are not set if there was activity on the buffer.
- * That way, we don't have to update the timeout on every I/O. Note that the
- * analyser timeout is always checked.
- */
-static inline void buffer_check_timeouts(struct buffer *b)
-{
-	if (likely(!(b->flags & (BF_SHUTR|BF_READ_TIMEOUT|BF_READ_ACTIVITY|BF_READ_NOEXP))) &&
-	    unlikely(tick_is_expired(b->rex, now_ms)))
-		b->flags |= BF_READ_TIMEOUT;
-
-	if (likely(!(b->flags & (BF_SHUTW|BF_WRITE_TIMEOUT|BF_WRITE_ACTIVITY))) &&
-	    unlikely(tick_is_expired(b->wex, now_ms)))
-		b->flags |= BF_WRITE_TIMEOUT;
-
-	if (likely(!(b->flags & BF_ANA_TIMEOUT)) &&
-	    unlikely(tick_is_expired(b->analyse_exp, now_ms)))
-		b->flags |= BF_ANA_TIMEOUT;
-}
-
-/* Schedule all remaining buffer data to be sent. send_max is not touched if it
- * already covers those data. That permits doing a flush even after a forward,
- * although not recommended.
- */
-static inline void buffer_flush(struct buffer *buf)
-{
-	if (buf->send_max < buf->l)
-		buf->send_max = buf->l;
-	if (buf->send_max)
-		buf->flags &= ~BF_OUT_EMPTY;
-}
-
-/* Erase any content from buffer <buf> and adjusts flags accordingly. Note
- * that any spliced data is not affected since we may not have any access to
- * it.
- */
-static inline void buffer_erase(struct buffer *buf)
-{
-	buf->send_max = 0;
-	buf->to_forward = 0;
-	buf->r = buf->lr = buf->w = buf->data;
-	buf->l = 0;
-	buf->flags &= ~(BF_FULL | BF_OUT_EMPTY);
-	if (!buf->pipe)
-		buf->flags |= BF_OUT_EMPTY;
-}
-
-/* Cut the "tail" of the buffer, which means strip it to the length of unsent
- * data only, and kill any remaining unsent data. Any scheduled forwarding is
- * stopped. This is mainly to be used to send error messages after existing
- * data.
- */
-static inline void buffer_cut_tail(struct buffer *buf)
-{
-	if (!buf->send_max)
-		return buffer_erase(buf);
-
-	buf->to_forward = 0;
-	if (buf->l == buf->send_max)
-		return;
-
-	buf->l = buf->send_max;
-	buf->r = buf->w + buf->l;
-	if (buf->r >= buf->data + buf->size)
-		buf->r -= buf->size;
-	buf->lr = buf->r;
-	buf->flags &= ~BF_FULL;
-	if (buf->l >= buffer_max_len(buf))
-		buf->flags |= BF_FULL;
-}
-
-/* Cut the <n> next unsent bytes of the buffer. The caller must ensure that <n>
- * is smaller than the actual buffer's length. This is mainly used to remove
- * empty lines at the beginning of a request or a response.
- */
-static inline void buffer_ignore(struct buffer *buf, int n)
-{
-	buf->l -= n;
-	buf->w += n;
-	if (buf->w >= buf->data + buf->size)
-		buf->w -= buf->size;
-	buf->flags &= ~BF_FULL;
-	if (buf->l >= buffer_max_len(buf))
-		buf->flags |= BF_FULL;
-}
-
-/* marks the buffer as "shutdown" ASAP for reads */
-static inline void buffer_shutr_now(struct buffer *buf)
-{
-	buf->flags |= BF_SHUTR_NOW;
-}
-
-/* marks the buffer as "shutdown" ASAP for writes */
-static inline void buffer_shutw_now(struct buffer *buf)
-{
-	buf->flags |= BF_SHUTW_NOW;
-}
-
-/* marks the buffer as "shutdown" ASAP in both directions */
-static inline void buffer_abort(struct buffer *buf)
-{
-	buf->flags |= BF_SHUTR_NOW | BF_SHUTW_NOW;
-	buf->flags &= ~BF_AUTO_CONNECT;
-}
-
-/* Installs <func> as a hijacker on the buffer <b> for session <s>. The hijack
- * flag is set, and the function called once. The function is responsible for
- * clearing the hijack bit. It is possible that the function clears the flag
- * during this first call.
- */
-static inline void buffer_install_hijacker(struct session *s,
-					   struct buffer *b,
-					   void (*func)(struct session *, struct buffer *))
-{
-	b->hijacker = func;
-	b->flags |= BF_HIJACK;
-	func(s, b);
-}
-
-/* Releases the buffer from hijacking mode. Often used by the hijack function */
-static inline void buffer_stop_hijack(struct buffer *buf)
-{
-	buf->flags &= ~BF_HIJACK;
-}
-
-/* allow the consumer to try to establish a new connection. */
-static inline void buffer_auto_connect(struct buffer *buf)
-{
-	buf->flags |= BF_AUTO_CONNECT;
-}
-
-/* prevent the consumer from trying to establish a new connection, and also
- * disable auto shutdown forwarding.
- */
-static inline void buffer_dont_connect(struct buffer *buf)
-{
-	buf->flags &= ~(BF_AUTO_CONNECT|BF_AUTO_CLOSE);
-}
-
-/* allow the producer to forward shutdown requests */
-static inline void buffer_auto_close(struct buffer *buf)
-{
-	buf->flags |= BF_AUTO_CLOSE;
-}
-
-/* prevent the producer from forwarding shutdown requests */
-static inline void buffer_dont_close(struct buffer *buf)
-{
-	buf->flags &= ~BF_AUTO_CLOSE;
-}
-
-/* allow the producer to read / poll the input */
-static inline void buffer_auto_read(struct buffer *buf)
-{
-	buf->flags &= ~BF_DONT_READ;
-}
-
-/* prevent the producer from read / poll the input */
-static inline void buffer_dont_read(struct buffer *buf)
-{
-	buf->flags |= BF_DONT_READ;
-}
-
-/* returns the maximum number of bytes writable at once in this buffer */
-static inline int buffer_max(const struct buffer *buf)
-{
-	if (buf->l == buf->size)
-		return 0;
-	else if (buf->r >= buf->w)
-		return buf->data + buf->size - buf->r;
-	else
-		return buf->w - buf->r;
-}
-
-/*
- * Tries to realign the given buffer, and returns how many bytes can be written
- * there at once without overwriting anything.
- */
-static inline int buffer_realign(struct buffer *buf)
-{
-	if (buf->l == 0) {
-		/* let's realign the buffer to optimize I/O */
-		buf->r = buf->w = buf->lr = buf->data;
-	}
-	return buffer_max(buf);
-}
-
-/*
- * Return the max amount of bytes that can be stuffed into the buffer at once.
- * Note that this may be lower than the actual buffer size when the free space
- * wraps after the end, so it's preferable to call this function again after
- * writing. Also note that this function respects max_len.
- */
-static inline int buffer_contig_space(struct buffer *buf)
-{
-	int ret;
-
-	if (buf->l == 0) {
-		buf->r = buf->w = buf->lr = buf->data;
-		ret = buffer_max_len(buf);
-	}
-	else if (buf->r > buf->w) {
-		ret = buf->data + buffer_max_len(buf) - buf->r;
-	}
-	else {
-		ret = buf->w - buf->r;
-		if (ret > buffer_max_len(buf))
-			ret = buffer_max_len(buf);
-	}
-	return ret;
-}
-
-/* Return 1 if the buffer has less than 1/4 of its capacity free, otherwise 0 */
-static inline int buffer_almost_full(struct buffer *buf)
-{
-	if (buffer_contig_space(buf) < buf->size / 4)
-		return 1;
-	return 0;
-}
-
-/*
- * Return the max amount of bytes that can be read from the buffer at once.
- * Note that this may be lower than the actual buffer length when the data
- * wrap after the end, so it's preferable to call this function again after
- * reading. Also note that this function respects the send_max limit.
- */
-static inline int buffer_contig_data(struct buffer *buf)
-{
-	int ret;
-
-	if (!buf->send_max || !buf->l)
-		return 0;
-
-	if (buf->r > buf->w)
-		ret = buf->r - buf->w;
-	else
-		ret = buf->data + buf->size - buf->w;
-
-	/* limit the amount of outgoing data if required */
-	if (ret > buf->send_max)
-		ret = buf->send_max;
-
-	return ret;
-}
-
-/*
- * Advance the buffer's read pointer by <len> bytes. This is useful when data
- * have been read directly from the buffer. It is illegal to call this function
- * with <len> causing a wrapping at the end of the buffer. It's the caller's
- * responsibility to ensure that <len> is never larger than buf->send_max.
- */
-static inline void buffer_skip(struct buffer *buf, int len)
-{
-	buf->w += len;
-	if (buf->w >= buf->data + buf->size)
-		buf->w -= buf->size; /* wrap around the buffer */
-
-	buf->l -= len;
-	if (!buf->l)
-		buf->r = buf->w = buf->lr = buf->data;
-
-	if (buf->l < buffer_max_len(buf))
-		buf->flags &= ~BF_FULL;
-
-	buf->send_max -= len;
-	if (!buf->send_max && !buf->pipe)
-		buf->flags |= BF_OUT_EMPTY;
-
-	/* notify that some data was written to the SI from the buffer */
-	buf->flags |= BF_WRITE_PARTIAL;
-}
-
-/*
- * Return one char from the buffer. If the buffer is empty and closed, return -1.
- * If the buffer is just empty, return -2. The buffer's pointer is not advanced,
- * it's up to the caller to call buffer_skip(buf, 1) when it has consumed the char.
- * Also note that this function respects the send_max limit.
- */
-static inline int buffer_si_peekchar(struct buffer *buf)
-{
-	if (buf->send_max)
-		return *buf->w;
-
-	if (buf->flags & (BF_SHUTW|BF_SHUTW_NOW))
-		return -1;
-	else
-		return -2;
-}
-
-/* Try to write character <c> into buffer <buf> after length controls. This
- * work like buffer_feed2(buf, &c, 1).
- * Returns non-zero in case of success, 0 if the buffer was full.
- * The send limit is automatically adjusted with the amount of data written.
- */
-static inline int buffer_si_putchar(struct buffer *buf, char c)
-{
-	if (buf->flags & BF_FULL)
-		return 0;
-
-	*buf->r = c;
-
-	buf->l++;
-	if (buf->l >= buffer_max_len(buf))
-		buf->flags |= BF_FULL;
-
-	buf->r++;
-	if (buf->r - buf->data == buf->size)
-		buf->r -= buf->size;
-
-	if (buf->to_forward >= 1) {
-		if (buf->to_forward != BUF_INFINITE_FORWARD)
-			buf->to_forward--;
-		buf->send_max++;
-		buf->flags &= ~BF_OUT_EMPTY;
-	}
-
-	buf->total++;
-	return 1;
-}
-
-int buffer_write(struct buffer *buf, const char *msg, int len);
-int buffer_feed2(struct buffer *buf, const char *str, int len);
-int buffer_si_putchar(struct buffer *buf, char c);
-int buffer_si_peekline(struct buffer *buf, char *str, int len);
-int buffer_replace(struct buffer *b, char *pos, char *end, const char *str);
-int buffer_replace2(struct buffer *b, char *pos, char *end, const char *str, int len);
-int buffer_insert_line2(struct buffer *b, char *pos, const char *str, int len);
-void buffer_dump(FILE *o, struct buffer *b, int from, int to);
-void buffer_bounce_realign(struct buffer *buf);
-unsigned long long buffer_forward(struct buffer *buf, unsigned long long bytes);
-
-
-
-/* writes the chunk <chunk> to buffer <buf>. Returns -1 in case of success,
- * -2 if it is larger than the buffer size, or the number of bytes available
- * otherwise. If the chunk has been written, its size is automatically reset
- * to zero. The send limit is automatically adjusted with the amount of data
- * written.
- */
-static inline int buffer_write_chunk(struct buffer *buf, struct chunk *chunk)
-{
-	int ret;
-
-	ret = buffer_write(buf, chunk->str, chunk->len);
-	if (ret == -1)
-		chunk->len = 0;
-	return ret;
-}
-
-/* Try to write chunk <chunk> into buffer <buf> after length controls. This is
- * the equivalent of buffer_write_chunk() except that to_forward and send_max
- * are updated and that max_len is respected. Returns -1 in case of success,
- * -2 if it is larger than the buffer size, or the number of bytes available
- * otherwise. If the chunk has been written, its size is automatically reset
- * to zero. The send limit is automatically adjusted with the amount of data
- * written.
- */
-static inline int buffer_feed_chunk(struct buffer *buf, struct chunk *chunk)
-{
-	int ret;
-
-	ret = buffer_feed2(buf, chunk->str, chunk->len);
-	if (ret == -1)
-		chunk->len = 0;
-	return ret;
-}
-
-/* Try to write string <str> into buffer <buf> after length controls. This is
- * the equivalent of buffer_feed2() except that string length is measured by
- * the function. Returns -1 in case of success, -2 if it is larger than the
- * buffer size, or the number of bytes available otherwise. The send limit is
- * automatically adjusted with the amount of data written.
- */
-static inline int buffer_feed(struct buffer *buf, const char *str)
-{
-	return buffer_feed2(buf, str, strlen(str));
-}
-
-static inline void chunk_init(struct chunk *chk, char *str, size_t size) {
-	chk->str  = str;
-	chk->len  = 0;
-	chk->size = size;
-}
-
-/* report 0 in case of error, 1 if OK. */
-static inline int chunk_initlen(struct chunk *chk, char *str, size_t size, int len) {
-
-	if (size && len > size)
-		return 0;
-
-	chk->str  = str;
-	chk->len  = len;
-	chk->size = size;
-
-	return 1;
-}
-
-static inline void chunk_initstr(struct chunk *chk, char *str) {
-	chk->str = str;
-	chk->len = strlen(str);
-	chk->size = 0;			/* mark it read-only */
-}
-
-static inline int chunk_strcpy(struct chunk *chk, const char *str) {
-	size_t len;
-
-	len = strlen(str);
-
-	if (unlikely(len > chk->size))
-		return 0;
-
-	chk->len  = len;
-	memcpy(chk->str, str, len);
-
-	return 1;
-}
-
-int chunk_printf(struct chunk *chk, const char *fmt, ...)
-	__attribute__ ((format(printf, 2, 3)));
-
-int chunk_htmlencode(struct chunk *dst, struct chunk *src);
-int chunk_asciiencode(struct chunk *dst, struct chunk *src, char qc);
-
-static inline void chunk_reset(struct chunk *chk) {
-	chk->str  = NULL;
-	chk->len  = -1;
-	chk->size = 0;
-}
-
-static inline void chunk_destroy(struct chunk *chk) {
-
-	if (!chk->size)
-		return;
-
-	if (chk->str)
-		free(chk->str);
-
-	chunk_reset(chk);
-}
-
-/*
- * frees the destination chunk if already allocated, allocates a new string,
- * and copies the source into it. The pointer to the destination string is
- * returned, or NULL if the allocation fails or if any pointer is NULL..
- */
-static inline char *chunk_dup(struct chunk *dst, const struct chunk *src) {
-	if (!dst || !src || !src->str)
-		return NULL;
-	if (dst->str)
-		free(dst->str);
-	dst->len = src->len;
-	dst->str = (char *)malloc(dst->len);
-	memcpy(dst->str, src->str, dst->len);
-	return dst->str;
-}
-
-#endif /* _PROTO_BUFFERS_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/proto/checks.h b/deps/haproxy-1.4.21/include/proto/checks.h
deleted file mode 100644
index cee6dda..0000000
--- a/deps/haproxy-1.4.21/include/proto/checks.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
-  include/proto/checks.h
-  Functions prototypes for the checks.
-
-  Copyright (C) 2000-2009 Willy Tarreau - w@1wt.eu
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _PROTO_CHECKS_H
-#define _PROTO_CHECKS_H
-
-#include <types/task.h>
-#include <common/config.h>
-
-const char *get_check_status_description(short check_status);
-const char *get_check_status_info(short check_status);
-void set_server_down(struct server *s);
-void set_server_up(struct server *s);
-struct task *process_chk(struct task *t);
-int start_checks();
-void health_adjust(struct server *s, short status);
-
-#endif /* _PROTO_CHECKS_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/proto/client.h b/deps/haproxy-1.4.21/include/proto/client.h
deleted file mode 100644
index ae11a09..0000000
--- a/deps/haproxy-1.4.21/include/proto/client.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
-  include/proto/client.h
-  This file contains client-side definitions.
-
-  Copyright (C) 2000-2008 Willy Tarreau - w@1wt.eu
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _PROTO_CLIENT_H
-#define _PROTO_CLIENT_H
-
-#include <common/config.h>
-#include <types/session.h>
-
-int frontend_decode_proxy_request(struct session *s, struct buffer *req, int an_bit);
-void get_frt_addr(struct session *s);
-int event_accept(int fd);
-
-
-#endif /* _PROTO_CLIENT_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/proto/cttproxy.h b/deps/haproxy-1.4.21/include/proto/cttproxy.h
deleted file mode 100644
index f343037..0000000
--- a/deps/haproxy-1.4.21/include/proto/cttproxy.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
-  include/proto/cttproxy.h
-  This file contains prototypes for Linux's cttproxy interface.
-  This file should be included only if CTTPROXY is enabled.
-
-  Copyright (C) 2000-2007 Willy Tarreau - w@1wt.eu
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _PROTO_CTTPROXY_H
-#define _PROTO_CTTPROXY_H
-
-#include <stdlib.h>
-#include <sys/socket.h>
-#include <sys/types.h>
-
-#include <common/config.h>
-#include <import/ip_tproxy.h>
-
-/*
- * Checks that CTTPROXY is available and in the right version.
- * Returns 0 if OK, -1 if wrong version, -2 if not available or other error.
- */
-int check_cttproxy_version();
-
-
-#endif /* _PROTO_CTTPROXY_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/proto/dumpstats.h b/deps/haproxy-1.4.21/include/proto/dumpstats.h
deleted file mode 100644
index d82883d..0000000
--- a/deps/haproxy-1.4.21/include/proto/dumpstats.h
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
-  include/proto/dumpstats.h
-  This file contains definitions of some primitives to dedicated to
-  statistics output.
-
-  Copyright (C) 2000-2009 Willy Tarreau - w@1wt.eu
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _PROTO_DUMPSTATS_H
-#define _PROTO_DUMPSTATS_H
-
-#include <common/config.h>
-#include <types/buffers.h>
-#include <types/session.h>
-
-/* Flags for session->data_ctx.stats.flags */
-#define STAT_FMT_CSV    0x00000001	/* dump the stats in CSV format instead of HTML */
-#define STAT_SHOW_STAT  0x00000002	/* dump the stats part */
-#define STAT_SHOW_INFO  0x00000004	/* dump the info part */
-#define STAT_HIDE_DOWN  0x00000008	/* hide 'down' servers in the stats page */
-#define STAT_NO_REFRESH 0x00000010	/* do not automatically refresh the stats page */
-#define STAT_ADMIN      0x00000020	/* indicate a stats admin level */
-#define STAT_BOUND      0x00800000	/* bound statistics to selected proxies/types/services */
-
-#define STATS_TYPE_FE  0
-#define STATS_TYPE_BE  1
-#define STATS_TYPE_SV  2
-#define STATS_TYPE_SO  3
-
-/* unix stats socket states */
-#define STAT_CLI_INIT   0   /* initial state */
-#define STAT_CLI_END    1   /* final state, let's close */
-#define STAT_CLI_GETREQ 2   /* wait for a request */
-#define STAT_CLI_OUTPUT 3   /* all states after this one are responses */
-#define STAT_CLI_PROMPT 3   /* display the prompt (first output, same code) */
-#define STAT_CLI_PRINT  4   /* display message in cli->msg */
-
-#define STAT_CLI_O_INFO 5   /* dump info/stats */
-#define STAT_CLI_O_SESS 6   /* dump sessions */
-#define STAT_CLI_O_ERR  7   /* dump errors */
-
-/* status codes (strictly 4 chars) used in the URL to display a message */
-#define STAT_STATUS_UNKN "UNKN"	/* an unknown error occured, shouldn't happen */
-#define STAT_STATUS_DONE "DONE"	/* the action is successful */
-#define STAT_STATUS_PART "PART"	/* the action is partially successful */
-#define STAT_STATUS_NONE "NONE"	/* nothing happened (no action chosen or servers state didn't change) */
-#define STAT_STATUS_ERRP "ERRP"	/* an error occured due to invalid values in parameters */
-#define STAT_STATUS_EXCD "EXCD"	/* an error occured because the buffer couldn't store all data */
-#define STAT_STATUS_DENY "DENY"	/* action denied */
-
-
-int stats_sock_parse_request(struct stream_interface *si, char *line);
-void stats_io_handler(struct stream_interface *si);
-int stats_dump_raw_to_buffer(struct session *s, struct buffer *rep);
-int stats_dump_http(struct session *s, struct buffer *rep, struct uri_auth *uri);
-int stats_dump_proxy(struct session *s, struct proxy *px, struct uri_auth *uri);
-int stats_dump_sess_to_buffer(struct session *s, struct buffer *rep);
-int stats_dump_errors_to_buffer(struct session *s, struct buffer *rep);
-void http_stats_io_handler(struct stream_interface *si);
-
-
-#endif /* _PROTO_DUMPSTATS_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/proto/fd.h b/deps/haproxy-1.4.21/include/proto/fd.h
deleted file mode 100644
index 1cba33b..0000000
--- a/deps/haproxy-1.4.21/include/proto/fd.h
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
-  include/proto/fd.h
-  File descriptors states.
-
-  Copyright (C) 2000-2007 Willy Tarreau - w@1wt.eu
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _PROTO_FD_H
-#define _PROTO_FD_H
-
-#include <stdio.h>
-#include <sys/time.h>
-#include <sys/types.h>
-#include <unistd.h>
-
-#include <common/config.h>
-#include <types/fd.h>
-
-/* Deletes an FD from the fdsets, and recomputes the maxfd limit.
- * The file descriptor is also closed.
- */
-void fd_delete(int fd);
-
-/* disable the specified poller */
-void disable_poller(const char *poller_name);
-
-/*
- * Initialize the pollers till the best one is found.
- * If none works, returns 0, otherwise 1.
- * The pollers register themselves just before main() is called.
- */
-int init_pollers();
-
-/*
- * Deinitialize the pollers.
- */
-void deinit_pollers();
-
-/*
- * Some pollers may lose their connection after a fork(). It may be necessary
- * to create initialize part of them again. Returns 0 in case of failure,
- * otherwise 1. The fork() function may be NULL if unused. In case of error,
- * the the current poller is destroyed and the caller is responsible for trying
- * another one by calling init_pollers() again.
- */
-int fork_poller();
-
-/*
- * Lists the known pollers on <out>.
- * Should be performed only before initialization.
- */
-int list_pollers(FILE *out);
-
-/*
- * Runs the polling loop
- */
-void run_poller();
-
-#define EV_FD_SET(fd, ev)    (cur_poller.set((fd), (ev)))
-#define EV_FD_CLR(fd, ev)    (cur_poller.clr((fd), (ev)))
-#define EV_FD_ISSET(fd, ev)  (cur_poller.is_set((fd), (ev)))
-#define EV_FD_COND_S(fd, ev) (cur_poller.cond_s((fd), (ev)))
-#define EV_FD_COND_C(fd, ev) (cur_poller.cond_c((fd), (ev)))
-#define EV_FD_REM(fd)        (cur_poller.rem(fd))
-#define EV_FD_CLO(fd)        (cur_poller.clo(fd))
-
-
-/* Prepares <fd> for being polled */
-static inline void fd_insert(int fd)
-{
-	fdtab[fd].ev = 0;
-	if (fd + 1 > maxfd)
-		maxfd = fd + 1;
-}
-
-
-#endif /* _PROTO_FD_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/proto/freq_ctr.h b/deps/haproxy-1.4.21/include/proto/freq_ctr.h
deleted file mode 100644
index 7add514..0000000
--- a/deps/haproxy-1.4.21/include/proto/freq_ctr.h
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
-  include/proto/freq_ctr.h
-  This file contains macros and inline functions for frequency counters.
-
-  Copyright (C) 2000-2009 Willy Tarreau - w@1wt.eu
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _PROTO_FREQ_CTR_H
-#define _PROTO_FREQ_CTR_H
-
-#include <common/config.h>
-#include <common/time.h>
-#include <types/freq_ctr.h>
-
-/* Rotate a frequency counter when current period is over. Must not be called
- * during a valid period. It is important that it correctly initializes a null
- * area.
- */
-static inline void rotate_freq_ctr(struct freq_ctr *ctr)
-{
-	ctr->prev_ctr = ctr->curr_ctr;
-	if (likely(now.tv_sec - ctr->curr_sec != 1)) {
-		/* we missed more than one second */
-		ctr->prev_ctr = 0;
-	}
-	ctr->curr_sec = now.tv_sec;
-	ctr->curr_ctr = 0; /* leave it at the end to help gcc optimize it away */
-}
-
-/* Update a frequency counter by <inc> incremental units. It is automatically
- * rotated if the period is over. It is important that it correctly initializes
- * a null area.
- */
-static inline void update_freq_ctr(struct freq_ctr *ctr, unsigned int inc)
-{
-	if (likely(ctr->curr_sec == now.tv_sec)) {
-		ctr->curr_ctr += inc;
-		return;
-	}
-	rotate_freq_ctr(ctr);
-	ctr->curr_ctr = inc;
-	/* Note: later we may want to propagate the update to other counters */
-}
-
-/* Read a frequency counter taking history into account for missing time in
- * current period.
- */
-unsigned int read_freq_ctr(struct freq_ctr *ctr);
-
-/* returns the number of remaining events that can occur on this freq counter
- * while respecting <freq> and taking into account that <pend> events are
- * already known to be pending. Returns 0 if limit was reached.
- */
-unsigned int freq_ctr_remain(struct freq_ctr *ctr, unsigned int freq, unsigned int pend);
-
-/* return the expected wait time in ms before the next event may occur,
- * respecting frequency <freq>, and assuming there may already be some pending
- * events. It returns zero if we can proceed immediately, otherwise the wait
- * time, which will be rounded down 1ms for better accuracy, with a minimum
- * of one ms.
- */
-unsigned int next_event_delay(struct freq_ctr *ctr, unsigned int freq, unsigned int pend);
-
-#endif /* _PROTO_FREQ_CTR_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
-  */
diff --git a/deps/haproxy-1.4.21/include/proto/hdr_idx.h b/deps/haproxy-1.4.21/include/proto/hdr_idx.h
deleted file mode 100644
index 9e67a00..0000000
--- a/deps/haproxy-1.4.21/include/proto/hdr_idx.h
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
-  include/proto/hdr_idx.h
-  This file defines function prototypes for fast header indexation.
-
-  Copyright (C) 2000-2006 Willy Tarreau - w@1wt.eu
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _PROTO_HDR_IDX_H
-#define _PROTO_HDR_IDX_H
-
-#include <common/config.h>
-#include <types/hdr_idx.h>
-
-/*
- * Initialize the list pointers.
- * list->size must already be set. If list->size is set and list->v is
- * non-null, list->v is also initialized..
- */
-static inline void hdr_idx_init(struct hdr_idx *list)
-{
-	if (list->size && list->v) {
-		register struct hdr_idx_elem e = { .len=0, .cr=0, .next=0};
-		list->v[0] = e;
-	}
-	list->tail = 0;
-	list->used = list->last = 1;
-}
-
-/*
- * Return index of the first entry in the list. Usually, it means the index of
- * the first header just after the request or response. If zero is returned, it
- * means that the list is empty.
- */
-static inline int hdr_idx_first_idx(struct hdr_idx *list)
-{
-	return list->v[0].next;
-}
-
-/*
- * Return position of the first entry in the list. Usually, it means the
- * position of the first header just after the request, but it can also be the
- * end of the headers if the request has no header. hdr_idx_start_idx() should
- * be checked before to ensure there is a valid header.
- */
-static inline int hdr_idx_first_pos(struct hdr_idx *list)
-{
-	return list->v[0].len + list->v[0].cr + 1;
-}
-
-/*
- * Sets the information about the start line. Its length and the presence of
- * the CR are registered so that hdr_idx_first_pos() knows exactly where to
- * find the first header.
- */
-static inline void hdr_idx_set_start(struct hdr_idx *list, int len, int cr)
-{
-	list->v[0].len = len;
-	list->v[0].cr = cr;
-}
-
-/*
- * Add a header entry to <list> after element <after>. <after> is ignored when
- * the list is empty or full. Common usage is to set <after> to list->tail.
- *
- * Returns the position of the new entry in the list (from 1 to size-1), or 0
- * if the array is already full. An effort is made to fill the array linearly,
- * but once the last entry has been used, we have to search for unused blocks,
- * which takes much more time. For this reason, it's important to size is
- * appropriately.
- */
-int hdr_idx_add(int len, int cr, struct hdr_idx *list, int after);
-
-#endif /* _PROTO_HDR_IDX_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/proto/httperr.h b/deps/haproxy-1.4.21/include/proto/httperr.h
deleted file mode 100644
index 438ff24..0000000
--- a/deps/haproxy-1.4.21/include/proto/httperr.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
-  include/proto/httperr.h
-  This file contains declarations for HTTP responses and errors.
-
-  Copyright (C) 2000-2006 Willy Tarreau - w@1wt.eu
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _PROTO_HTTPERR_H
-#define _PROTO_HTTPERR_H
-
-#include <types/httperr.h>
-
-extern const int http_err_codes[HTTP_ERR_SIZE];
-extern struct chunk http_err_chunks[HTTP_ERR_SIZE];
-extern const char *HTTP_302;
-extern const char *HTTP_303;
-extern const char *HTTP_401_fmt;
-
-struct chunk *error_message(struct session *s, int msgnum);
-
-#endif /* _PROTO_HTTPERR_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/proto/lb_chash.h b/deps/haproxy-1.4.21/include/proto/lb_chash.h
deleted file mode 100644
index a0ebf69..0000000
--- a/deps/haproxy-1.4.21/include/proto/lb_chash.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * include/proto/lb_chash.h
- * Function declarations for Consistent Hash LB algorithm.
- *
- * Copyright (C) 2000-2009 Willy Tarreau - w@1wt.eu
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _PROTO_LB_CHASH_H
-#define _PROTO_LB_CHASH_H
-
-#include <common/config.h>
-#include <types/proxy.h>
-#include <types/server.h>
-
-void chash_init_server_tree(struct proxy *p);
-struct server *chash_get_next_server(struct proxy *p, struct server *srvtoavoid);
-struct server *chash_get_server_hash(struct proxy *p, unsigned int hash);
-
-#endif /* _PROTO_LB_CHASH_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/proto/lb_fwlc.h b/deps/haproxy-1.4.21/include/proto/lb_fwlc.h
deleted file mode 100644
index 8c56746..0000000
--- a/deps/haproxy-1.4.21/include/proto/lb_fwlc.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * include/proto/lb_fwlc.h
- * Fast Weighted Least Connection load balancing algorithm.
- *
- * Copyright (C) 2000-2009 Willy Tarreau - w@1wt.eu
- * 
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _PROTO_LB_FWLC_H
-#define _PROTO_LB_FWLC_H
-
-#include <common/config.h>
-#include <types/proxy.h>
-#include <types/server.h>
-
-struct server *fwlc_get_next_server(struct proxy *p, struct server *srvtoavoid);
-void fwlc_init_server_tree(struct proxy *p);
-
-#endif /* _PROTO_LB_FWLC_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/proto/lb_fwrr.h b/deps/haproxy-1.4.21/include/proto/lb_fwrr.h
deleted file mode 100644
index 1189c38..0000000
--- a/deps/haproxy-1.4.21/include/proto/lb_fwrr.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * include/proto/lb_fwrr.h
- * Fast Weighted Round Robin load balancing algorithm.
- *
- * Copyright (C) 2000-2009 Willy Tarreau - w@1wt.eu
- * 
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _PROTO_LB_FWRR_H
-#define _PROTO_LB_FWRR_H
-
-#include <common/config.h>
-#include <types/proxy.h>
-#include <types/server.h>
-
-void fwrr_init_server_groups(struct proxy *p);
-struct server *fwrr_get_next_server(struct proxy *p, struct server *srvtoavoid);
-
-#endif /* _PROTO_LB_FWRR_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/proto/lb_map.h b/deps/haproxy-1.4.21/include/proto/lb_map.h
deleted file mode 100644
index 061273d..0000000
--- a/deps/haproxy-1.4.21/include/proto/lb_map.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * include/proto/lb_map.h
- * Map-based load-balancing (RR and HASH)
- *
- * Copyright (C) 2000-2009 Willy Tarreau - w@1wt.eu
- * 
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _PROTO_LB_MAP_H
-#define _PROTO_LB_MAP_H
-
-#include <common/config.h>
-#include <types/proxy.h>
-#include <types/server.h>
-
-void map_set_server_status_down(struct server *srv);
-void map_set_server_status_up(struct server *srv);
-void recalc_server_map(struct proxy *px);
-void init_server_map(struct proxy *p);
-struct server *map_get_server_rr(struct proxy *px, struct server *srvtoavoid);
-struct server *map_get_server_hash(struct proxy *px, unsigned int hash);
-
-#endif /* _PROTO_LB_MAP_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/proto/log.h b/deps/haproxy-1.4.21/include/proto/log.h
deleted file mode 100644
index f2ecf0b..0000000
--- a/deps/haproxy-1.4.21/include/proto/log.h
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
-  include/proto/log.h
-  This file contains definitions of log-related functions, structures,
-  and macros.
-
-  Copyright (C) 2000-2008 Willy Tarreau - w@1wt.eu
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _PROTO_LOG_H
-#define _PROTO_LOG_H
-
-#include <stdio.h>
-#include <syslog.h>
-
-#include <common/config.h>
-#include <common/memory.h>
-#include <types/log.h>
-#include <types/proxy.h>
-#include <types/session.h>
-
-extern struct pool_head *pool2_requri;
-
-/*
- * Displays the message on stderr with the date and pid. Overrides the quiet
- * mode during startup.
- */
-void Alert(const char *fmt, ...)
-	__attribute__ ((format(printf, 1, 2)));
-
-/*
- * Displays the message on stderr with the date and pid.
- */
-void Warning(const char *fmt, ...)
-	__attribute__ ((format(printf, 1, 2)));
-
-/*
- * Displays the message on <out> only if quiet mode is not set.
- */
-void qfprintf(FILE *out, const char *fmt, ...)
-	__attribute__ ((format(printf, 2, 3)));
-
-/*
- * This function sends a syslog message to both log servers of a proxy,
- * or to global log servers if the proxy is NULL.
- * It also tries not to waste too much time computing the message header.
- * It doesn't care about errors nor does it report them.
- */
-void send_log(struct proxy *p, int level, const char *message, ...)
-	__attribute__ ((format(printf, 3, 4)));
-
-/*
- * send a log for the session when we have enough info about it
- */
-void tcp_sess_log(struct session *s);
-
-/*
- * returns log level for <lev> or -1 if not found.
- */
-int get_log_level(const char *lev);
-
-/*
- * returns log facility for <fac> or -1 if not found.
- */
-int get_log_facility(const char *fac);
-
-#endif /* _PROTO_LOG_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/proto/pattern.h b/deps/haproxy-1.4.21/include/proto/pattern.h
deleted file mode 100644
index 41eda06..0000000
--- a/deps/haproxy-1.4.21/include/proto/pattern.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * include/proto/pattern.h
- * Functions for patterns management.
- *
- * Copyright (C) 2009-2010 EXCELIANCE, Emeric Brun <ebrun@exceliance.fr>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _PROTO_PATTERN_H
-#define _PROTO_PATTERN_H
-
-#include <types/pattern.h>
-#include <types/stick_table.h>
-
-struct pattern_expr *pattern_parse_expr(char **str, int *idx);
-struct pattern *pattern_process(struct proxy *px, struct session *l4,
-                                void *l7, int dir, struct pattern_expr *expr,
-                                struct pattern *p);
-struct stktable_key *pattern_process_key(struct proxy *px, struct session *l4,
-                                         void *l7, int dir, struct pattern_expr *expr,
-                                         unsigned long table_type);
-int pattern_notusable_key(struct pattern_expr *expr, unsigned long table_type);
-void pattern_register_fetches(struct pattern_fetch_kw_list *psl);
-void pattern_register_convs(struct pattern_conv_kw_list *psl);
-
-#endif
diff --git a/deps/haproxy-1.4.21/include/proto/pipe.h b/deps/haproxy-1.4.21/include/proto/pipe.h
deleted file mode 100644
index 0c02165..0000000
--- a/deps/haproxy-1.4.21/include/proto/pipe.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
-  include/proto/pipe.h
-  Pipe management
-
-  Copyright (C) 2000-2009 Willy Tarreau - w@1wt.eu
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _PROTO_PIPE_H
-#define _PROTO_PIPE_H
-
-#include <common/config.h>
-#include <types/pipe.h>
-
-extern int pipes_used;	/* # of pipes in use (2 fds each) */
-extern int pipes_free;	/* # of pipes unused (2 fds each) */
-
-/* return a pre-allocated empty pipe. Try to allocate one if there isn't any
- * left. NULL is returned if a pipe could not be allocated.
- */
-struct pipe *get_pipe();
-
-/* destroy a pipe, possibly because an error was encountered on it. Its FDs
- * will be closed and it will not be reinjected into the live pool.
- */
-void kill_pipe(struct pipe *p);
-
-/* put back a unused pipe into the live pool. If it still has data in it, it is
- * closed and not reinjected into the live pool. The caller is not allowed to
- * use it once released.
- */
-void put_pipe(struct pipe *p);
-
-#endif /* _PROTO_PIPE_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/proto/port_range.h b/deps/haproxy-1.4.21/include/proto/port_range.h
deleted file mode 100644
index 8c63fac..0000000
--- a/deps/haproxy-1.4.21/include/proto/port_range.h
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
-  include/proto/port_range.h
-  This file defines everything needed to manage port ranges
-
-  Copyright (C) 2000-2009 Willy Tarreau - w@1wt.eu
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _PROTO_PORT_RANGE_H
-#define _PROTO_PORT_RANGE_H
-
-#include <types/port_range.h>
-
-/* return an available port from range <range>, or zero if none is left */
-static inline int port_range_alloc_port(struct port_range *range)
-{
-	int ret;
-
-	if (!range->avail)
-		return 0;
-	ret = range->ports[range->get];
-	range->get++;
-	if (range->get >= range->size)
-		range->get = 0;
-	range->avail--;
-	return ret;
-}
-
-/* release port <port> into port range <range>. Does nothing if <port> is zero
- * nor if <range> is null. The caller is responsible for marking the port
- * unused by either setting the port to zero or the range to NULL.
- */
-static inline void port_range_release_port(struct port_range *range, int port)
-{
-	if (!port || !range)
-		return;
-
-	range->ports[range->put] = port;
-	range->avail++;
-	range->put++;
-	if (range->put >= range->size)
-		range->put = 0;
-}
-
-/* return a new initialized port range of N ports. The ports are not
- * filled in, it's up to the caller to do it.
- */
-static inline struct port_range *port_range_alloc_range(int n)
-{
-	struct port_range *ret;
-	ret = calloc(1, sizeof(struct port_range) +
-		     n * sizeof(((struct port_range *)0)->ports[0]));
-	ret->size = ret->avail = n;
-	return ret;
-}
-
-#endif /* _PROTO_PORT_RANGE_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/proto/proto_http.h b/deps/haproxy-1.4.21/include/proto/proto_http.h
deleted file mode 100644
index c099dde..0000000
--- a/deps/haproxy-1.4.21/include/proto/proto_http.h
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * include/proto/proto_http.h
- * This file contains HTTP protocol definitions.
- *
- * Copyright (C) 2000-2010 Willy Tarreau - w@1wt.eu
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _PROTO_PROTO_HTTP_H
-#define _PROTO_PROTO_HTTP_H
-
-#include <common/config.h>
-#include <types/proto_http.h>
-#include <types/session.h>
-#include <types/task.h>
-
-/*
- * some macros used for the request parsing.
- * from RFC2616:
- *   CTL                 = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
- *   SEP                 = one of the 17 defined separators or SP or HT
- *   LWS                 = CR, LF, SP or HT
- *   SPHT                = SP or HT. Use this macro and not a boolean expression for best speed.
- *   CRLF                = CR or LF. Use this macro and not a boolean expression for best speed.
- *   token               = any CHAR except CTL or SEP. Use this macro and not a boolean expression for best speed.
- *
- * added for ease of use:
- *   ver_token           = 'H', 'P', 'T', '/', '.', and digits.
- */
-
-extern const char http_is_ctl[256];
-extern const char http_is_sep[256];
-extern const char http_is_lws[256];
-extern const char http_is_spht[256];
-extern const char http_is_crlf[256];
-extern const char http_is_token[256];
-extern const char http_is_ver_token[256];
-
-#define HTTP_IS_CTL(x)   (http_is_ctl[(unsigned char)(x)])
-#define HTTP_IS_SEP(x)   (http_is_sep[(unsigned char)(x)])
-#define HTTP_IS_LWS(x)   (http_is_lws[(unsigned char)(x)])
-#define HTTP_IS_SPHT(x)  (http_is_spht[(unsigned char)(x)])
-#define HTTP_IS_CRLF(x)  (http_is_crlf[(unsigned char)(x)])
-#define HTTP_IS_TOKEN(x) (http_is_token[(unsigned char)(x)])
-#define HTTP_IS_VER_TOKEN(x) (http_is_ver_token[(unsigned char)(x)])
-
-int event_accept(int fd);
-int process_cli(struct session *t);
-int process_srv_data(struct session *t);
-int process_srv_conn(struct session *t);
-int http_wait_for_request(struct session *s, struct buffer *req, int an_bit);
-int http_process_req_common(struct session *s, struct buffer *req, int an_bit, struct proxy *px);
-int http_process_request(struct session *t, struct buffer *req, int an_bit);
-int http_process_tarpit(struct session *s, struct buffer *req, int an_bit);
-int http_process_request_body(struct session *s, struct buffer *req, int an_bit);
-int http_send_name_header(struct http_txn *txn, struct http_msg *msg, struct buffer *buf, struct proxy* be, const char* svr_name);
-int http_wait_for_response(struct session *s, struct buffer *rep, int an_bit);
-int http_process_res_common(struct session *t, struct buffer *rep, int an_bit, struct proxy *px);
-int http_request_forward_body(struct session *s, struct buffer *req, int an_bit);
-int http_response_forward_body(struct session *s, struct buffer *res, int an_bit);
-
-void debug_hdr(const char *dir, struct session *t, const char *start, const char *end);
-void get_srv_from_appsession(struct session *t, const char *begin, int len);
-int apply_filter_to_req_headers(struct session *t, struct buffer *req, struct hdr_exp *exp);
-int apply_filter_to_req_line(struct session *t, struct buffer *req, struct hdr_exp *exp);
-int apply_filters_to_request(struct session *s, struct buffer *req, struct proxy *px);
-int apply_filters_to_response(struct session *t, struct buffer *rtr, struct proxy *px);
-void manage_client_side_appsession(struct session *t, const char *buf, int len);
-void manage_client_side_cookies(struct session *t, struct buffer *req);
-void manage_server_side_cookies(struct session *t, struct buffer *rtr);
-void check_response_for_cacheability(struct session *t, struct buffer *rtr);
-int stats_check_uri(struct session *s, struct proxy *backend);
-void init_proto_http();
-int http_find_header2(const char *name, int len,
-		      char *sol, struct hdr_idx *idx,
-		      struct hdr_ctx *ctx);
-void http_sess_log(struct session *s);
-void perform_http_redirect(struct session *s, struct stream_interface *si);
-void http_return_srv_error(struct session *s, struct stream_interface *si);
-void http_capture_bad_message(struct error_snapshot *es, struct session *s,
-                              struct buffer *buf, struct http_msg *msg,
-			      int state, struct proxy *other_end);
-unsigned int get_ip_from_hdr2(struct http_msg *msg, const char *hname, int hlen,
-			      struct hdr_idx *idx, int occ);
-
-void http_init_txn(struct session *s);
-void http_end_txn(struct session *s);
-void http_reset_txn(struct session *s);
-
-/* to be used when contents change in an HTTP message */
-#define http_msg_move_end(msg, bytes) do { \
-		unsigned int _bytes = (bytes);	\
-		(msg)->sov += (_bytes);		\
-		(msg)->eoh += (_bytes);		\
-	} while (0)
-
-#endif /* _PROTO_PROTO_HTTP_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/proto/proto_tcp.h b/deps/haproxy-1.4.21/include/proto/proto_tcp.h
deleted file mode 100644
index ba48f4f..0000000
--- a/deps/haproxy-1.4.21/include/proto/proto_tcp.h
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * include/proto/proto_tcp.h
- * This file contains TCP socket protocol definitions.
- *
- * Copyright (C) 2000-2010 Willy Tarreau - w@1wt.eu
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _PROTO_PROTO_TCP_H
-#define _PROTO_PROTO_TCP_H
-
-#include <common/config.h>
-#include <types/proto_tcp.h>
-#include <types/task.h>
-
-int tcp_event_accept(int fd);
-int tcpv4_bind_socket(int fd, int flags, struct sockaddr_in *local, struct sockaddr_in *remote);
-void tcpv4_add_listener(struct listener *listener);
-void tcpv6_add_listener(struct listener *listener);
-int tcp_bind_listener(struct listener *listener, char *errmsg, int errlen);
-int tcpv4_connect_server(struct stream_interface *si,
-			 struct proxy *be, struct server *srv,
-			 struct sockaddr *srv_addr, struct sockaddr *from_addr);
-int tcp_inspect_request(struct session *s, struct buffer *req, int an_bit);
-int acl_fetch_rdp_cookie(struct proxy *px, struct session *l4, void *l7, int dir,
-                         struct acl_expr *expr, struct acl_test *test);
-int tcp_persist_rdp_cookie(struct session *s, struct buffer *req, int an_bit);
-
-#endif /* _PROTO_PROTO_TCP_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/proto/proto_uxst.h b/deps/haproxy-1.4.21/include/proto/proto_uxst.h
deleted file mode 100644
index c0163fb..0000000
--- a/deps/haproxy-1.4.21/include/proto/proto_uxst.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
-  include/proto/proto_uxst.h
-  This file contains UNIX-stream socket protocol definitions.
-
-  Copyright (C) 2000-2008 Willy Tarreau - w@1wt.eu
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _PROTO_PROTO_UXST_H
-#define _PROTO_PROTO_UXST_H
-
-#include <common/config.h>
-#include <types/session.h>
-#include <types/task.h>
-
-int uxst_event_accept(int fd);
-void uxst_add_listener(struct listener *listener);
-int uxst_req_analyser_stats(struct session *s, struct buffer *req, int an_bit);
-
-#endif /* _PROTO_PROTO_UXST_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/proto/protocols.h b/deps/haproxy-1.4.21/include/proto/protocols.h
deleted file mode 100644
index cd54ec8..0000000
--- a/deps/haproxy-1.4.21/include/proto/protocols.h
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
-  include/proto/protocols.h
-  This file declares generic protocol primitives.
-
-  Copyright (C) 2000-2007 Willy Tarreau - w@1wt.eu
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _PROTO_PROTOCOLS_H
-#define _PROTO_PROTOCOLS_H
-
-#include <types/protocols.h>
-
-/* This function adds the specified listener's file descriptor to the polling
- * lists if it is in the LI_LISTEN state. The listener enters LI_READY or
- * LI_FULL state depending on its number of connections.
- */
-void enable_listener(struct listener *listener);
-
-/* This function removes the specified listener's file descriptor from the
- * polling lists if it is in the LI_READY or in the LI_FULL state. The listener
- * enters LI_LISTEN.
- */
-void disable_listener(struct listener *listener);
-
-/* This function adds all of the protocol's listener's file descriptors to the
- * polling lists when they are in the LI_LISTEN state. It is intended to be
- * used as a protocol's generic enable_all() primitive, for use after the
- * fork(). It puts the listeners into LI_READY or LI_FULL states depending on
- * their number of connections. It always returns ERR_NONE.
- */
-int enable_all_listeners(struct protocol *proto);
-
-/* This function removes all of the protocol's listener's file descriptors from
- * the polling lists when they are in the LI_READY or LI_FULL states. It is
- * intended to be used as a protocol's generic disable_all() primitive. It puts
- * the listeners into LI_LISTEN, and always returns ERR_NONE.
- */
-int disable_all_listeners(struct protocol *proto);
-
-/* This function closes the listening socket for the specified listener,
- * provided that it's already in a listening state. The listener enters the
- * LI_ASSIGNED state. It always returns ERR_NONE. This function is intended
- * to be used as a generic function for standard protocols.
- */
-int unbind_listener(struct listener *listener);
-
-/* This function closes all listening sockets bound to the protocol <proto>,
- * and the listeners end in LI_ASSIGNED state if they were higher. It does not
- * detach them from the protocol. It always returns ERR_NONE.
- */
-int unbind_all_listeners(struct protocol *proto);
-
-/* Delete a listener from its protocol's list of listeners. The listener's
- * state is automatically updated from LI_ASSIGNED to LI_INIT. The protocol's
- * number of listeners is updated. Note that the listener must have previously
- * been unbound. This is the generic function to use to remove a listener.
- */
-void delete_listener(struct listener *listener);
-
-/* Registers the protocol <proto> */
-void protocol_register(struct protocol *proto);
-
-/* Unregisters the protocol <proto>. Note that all listeners must have
- * previously been unbound.
- */
-void protocol_unregister(struct protocol *proto);
-
-/* binds all listeneres of all registered protocols. Returns a composition
- * of ERR_NONE, ERR_RETRYABLE, ERR_FATAL.
- */
-int protocol_bind_all(void);
-
-/* unbinds all listeners of all registered protocols. They are also closed.
- * This must be performed before calling exit() in order to get a chance to
- * remove file-system based sockets and pipes.
- * Returns a composition of ERR_NONE, ERR_RETRYABLE, ERR_FATAL.
- */
-int protocol_unbind_all(void);
-
-/* enables all listeners of all registered protocols. This is intended to be
- * used after a fork() to enable reading on all file descriptors. Returns a
- * composition of ERR_NONE, ERR_RETRYABLE, ERR_FATAL.
- */
-int protocol_enable_all(void);
-
-
-#endif /* _PROTO_PROTOCOLS_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/proto/proxy.h b/deps/haproxy-1.4.21/include/proto/proxy.h
deleted file mode 100644
index 288ca22..0000000
--- a/deps/haproxy-1.4.21/include/proto/proxy.h
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * include/proto/proxy.h
- * This file defines function prototypes for proxy management.
- *
- * Copyright (C) 2000-2009 Willy Tarreau - w@1wt.eu
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _PROTO_PROXY_H
-#define _PROTO_PROXY_H
-
-#include <common/config.h>
-#include <common/ticks.h>
-#include <common/time.h>
-#include <types/proxy.h>
-#include <proto/freq_ctr.h>
-
-int start_proxies(int verbose);
-void maintain_proxies(int *next);
-void soft_stop(void);
-void pause_proxy(struct proxy *p);
-void stop_proxy(struct proxy *p);
-void pause_proxies(void);
-void listen_proxies(void);
-int  session_set_backend(struct session *s, struct proxy *be);
-
-const char *proxy_cap_str(int cap);
-const char *proxy_mode_str(int mode);
-struct proxy *findproxy_mode(const char *name, int mode, int cap);
-struct proxy *findproxy(const char *name, int cap);
-struct server *findserver(const struct proxy *px, const char *name);
-int proxy_cfg_ensure_no_http(struct proxy *curproxy);
-int get_backend_server(const char *bk_name, const char *sv_name,
-		       struct proxy **bk, struct server **sv);
-
-/*
- * This function returns a string containing the type of the proxy in a format
- * suitable for error messages, from its capabilities.
- */
-static inline const char *proxy_type_str(struct proxy *proxy)
-{
-	return proxy_cap_str(proxy->cap);
-}
-
-/* this function initializes all timeouts for proxy p */
-static inline void proxy_reset_timeouts(struct proxy *proxy)
-{
-	proxy->timeout.client = TICK_ETERNITY;
-	proxy->timeout.tarpit = TICK_ETERNITY;
-	proxy->timeout.queue = TICK_ETERNITY;
-	proxy->timeout.connect = TICK_ETERNITY;
-	proxy->timeout.server = TICK_ETERNITY;
-	proxy->timeout.appsession = TICK_ETERNITY;
-	proxy->timeout.httpreq = TICK_ETERNITY;
-	proxy->timeout.check = TICK_ETERNITY;
-}
-
-/* increase the number of cumulated connections on the designated frontend */
-static void inline proxy_inc_fe_ctr(struct listener *l, struct proxy *fe)
-{
-	fe->counters.cum_feconn++;
-	if (l->counters)
-		l->counters->cum_conn++;
-
-	update_freq_ctr(&fe->fe_sess_per_sec, 1);
-	if (fe->fe_sess_per_sec.curr_ctr > fe->counters.fe_sps_max)
-		fe->counters.fe_sps_max = fe->fe_sess_per_sec.curr_ctr;
-}
-
-/* increase the number of cumulated connections on the designated backend */
-static void inline proxy_inc_be_ctr(struct proxy *be)
-{
-	be->counters.cum_beconn++;
-	update_freq_ctr(&be->be_sess_per_sec, 1);
-	if (be->be_sess_per_sec.curr_ctr > be->counters.be_sps_max)
-		be->counters.be_sps_max = be->be_sess_per_sec.curr_ctr;
-}
-
-/* increase the number of cumulated requests on the designated frontend */
-static void inline proxy_inc_fe_req_ctr(struct proxy *fe)
-{
-	fe->counters.cum_fe_req++;
-	update_freq_ctr(&fe->fe_req_per_sec, 1);
-	if (fe->fe_req_per_sec.curr_ctr > fe->counters.fe_rps_max)
-		fe->counters.fe_rps_max = fe->fe_req_per_sec.curr_ctr;
-}
-
-#endif /* _PROTO_PROXY_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/proto/queue.h b/deps/haproxy-1.4.21/include/proto/queue.h
deleted file mode 100644
index 7bf8137..0000000
--- a/deps/haproxy-1.4.21/include/proto/queue.h
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * include/proto/queue.h
- * This file defines everything related to queues.
- *
- * Copyright (C) 2000-2012 Willy Tarreau - w@1wt.eu
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _PROTO_QUEUE_H
-#define _PROTO_QUEUE_H
-
-#include <common/config.h>
-#include <common/memory.h>
-#include <common/mini-clist.h>
-
-#include <types/proxy.h>
-#include <types/queue.h>
-#include <types/session.h>
-#include <types/server.h>
-#include <types/task.h>
-
-#include <proto/backend.h>
-
-extern struct pool_head *pool2_pendconn;
-
-int init_pendconn();
-struct session *pendconn_get_next_sess(struct server *srv, struct proxy *px);
-struct pendconn *pendconn_add(struct session *sess);
-void pendconn_free(struct pendconn *p);
-void process_srv_queue(struct server *s);
-unsigned int srv_dynamic_maxconn(const struct server *s);
-
-
-
-/* Returns the first pending connection for server <s>, which may be NULL if
- * nothing is pending.
- */
-static inline struct pendconn *pendconn_from_srv(const struct server *s) {
-	if (!s->nbpend)
-		return NULL;
-
-	return LIST_ELEM(s->pendconns.n, struct pendconn *, list);
-}
-
-/* Returns the first pending connection for proxy <px>, which may be NULL if
- * nothing is pending.
- */
-static inline struct pendconn *pendconn_from_px(const struct proxy *px) {
-	if (!px->nbpend)
-		return NULL;
-
-	return LIST_ELEM(px->pendconns.n, struct pendconn *, list);
-}
-
-/* returns 0 if nothing has to be done for server <s> regarding queued connections,
- * and non-zero otherwise. If the server is down, we only check its own queue. Suited
- * for and if/else usage.
- */
-static inline int may_dequeue_tasks(const struct server *s, const struct proxy *p) {
-	return (s && (s->nbpend || (p->nbpend && srv_is_usable(s->state, s->eweight))) &&
-		(!s->maxconn || s->cur_sess < srv_dynamic_maxconn(s)));
-}
-
-#endif /* _PROTO_QUEUE_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/proto/server.h b/deps/haproxy-1.4.21/include/proto/server.h
deleted file mode 100644
index a1fa6c2..0000000
--- a/deps/haproxy-1.4.21/include/proto/server.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * include/proto/server.h
- * This file defines everything related to servers.
- *
- * Copyright (C) 2000-2009 Willy Tarreau - w@1wt.eu
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _PROTO_SERVER_H
-#define _PROTO_SERVER_H
-
-#include <unistd.h>
-
-#include <common/config.h>
-#include <types/proxy.h>
-#include <types/queue.h>
-#include <types/server.h>
-
-#include <proto/queue.h>
-#include <proto/freq_ctr.h>
-
-int srv_downtime(struct server *s);
-int srv_getinter(struct server *s);
-
-/* increase the number of cumulated connections on the designated server */
-static void inline srv_inc_sess_ctr(struct server *s)
-{
-	s->counters.cum_sess++;
-	update_freq_ctr(&s->sess_per_sec, 1);
-	if (s->sess_per_sec.curr_ctr > s->counters.sps_max)
-		s->counters.sps_max = s->sess_per_sec.curr_ctr;
-}
-
-#endif /* _PROTO_SERVER_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/proto/session.h b/deps/haproxy-1.4.21/include/proto/session.h
deleted file mode 100644
index 737e065..0000000
--- a/deps/haproxy-1.4.21/include/proto/session.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
-  include/proto/session.h
-  This file defines everything related to sessions.
-
-  Copyright (C) 2000-2008 Willy Tarreau - w@1wt.eu
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _PROTO_SESSION_H
-#define _PROTO_SESSION_H
-
-#include <common/config.h>
-#include <common/memory.h>
-#include <types/session.h>
-
-extern struct pool_head *pool2_session;
-extern struct list sessions;
-
-void session_free(struct session *s);
-
-/* perform minimal intializations, report 0 in case of error, 1 if OK. */
-int init_session();
-
-void session_process_counters(struct session *s);
-void sess_change_server(struct session *sess, struct server *newsrv);
-struct task *process_session(struct task *t);
-void sess_set_term_flags(struct session *s);
-void default_srv_error(struct session *s, struct stream_interface *si);
-
-static void inline trace_term(struct session *s, unsigned int code)
-{
-	s->term_trace <<= TT_BIT_SHIFT;
-	s->term_trace |= code;
-}
-
-#endif /* _PROTO_SESSION_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/proto/signal.h b/deps/haproxy-1.4.21/include/proto/signal.h
deleted file mode 100644
index 2734827..0000000
--- a/deps/haproxy-1.4.21/include/proto/signal.h
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Asynchronous signal delivery functions.
- *
- * Copyright 2000-2009 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <signal.h>
-#include <common/standard.h>
-#include <types/signal.h>
-
-extern int signal_queue_len;
-extern struct signal_descriptor signal_state[];
-
-void signal_init();
-void signal_handler(int sig);
-void signal_register(int sig, void (*handler)(int));
-void __signal_process_queue();
-
-static inline void signal_process_queue()
-{
-	if (unlikely(signal_queue_len > 0))
-		__signal_process_queue();
-}
diff --git a/deps/haproxy-1.4.21/include/proto/stick_table.h b/deps/haproxy-1.4.21/include/proto/stick_table.h
deleted file mode 100644
index 1cc4624..0000000
--- a/deps/haproxy-1.4.21/include/proto/stick_table.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * include/proto/stick_table.h
- * Functions for stick tables management.
- *
- * Copyright (C) 2009-2010 EXCELIANCE, Emeric Brun <ebrun@exceliance.fr>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _PROTO_STICK_TABLE_H
-#define _PROTO_STICK_TABLE_H
-
-#include <types/stick_table.h>
-
-struct stksess *stksess_new(struct stktable *t, struct stktable_key *key);
-void stksess_key(struct stktable *t, struct stksess *ts, struct stktable_key *key);
-void stksess_free(struct stktable *t, struct stksess *ts);
-
-int stktable_init(struct stktable *t);
-int stktable_parse_type(char **args, int *idx, unsigned long *type, size_t *key_size);
-int stktable_store(struct stktable *t, struct stksess *ts, int sid);
-struct stksess *stktable_lookup(struct stktable *t, struct stktable_key *key);
-
-
-#endif /* _PROTO_STICK_TABLE_H */
diff --git a/deps/haproxy-1.4.21/include/proto/stream_interface.h b/deps/haproxy-1.4.21/include/proto/stream_interface.h
deleted file mode 100644
index 4e7f734..0000000
--- a/deps/haproxy-1.4.21/include/proto/stream_interface.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * include/proto/stream_interface.h
- * This file contains stream_interface function prototypes
- *
- * Copyright (C) 2000-2009 Willy Tarreau - w@1wt.eu
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _PROTO_STREAM_INTERFACE_H
-#define _PROTO_STREAM_INTERFACE_H
-
-#include <stdlib.h>
-
-#include <common/config.h>
-#include <types/stream_interface.h>
-
-
-/* main event functions used to move data between sockets and buffers */
-int stream_int_check_timeouts(struct stream_interface *si);
-void stream_int_report_error(struct stream_interface *si);
-void stream_int_retnclose(struct stream_interface *si, const struct chunk *msg);
-
-/* functions used when running a stream interface as a task */
-void stream_int_update(struct stream_interface *si);
-void stream_int_update_embedded(struct stream_interface *si);
-void stream_int_shutr(struct stream_interface *si);
-void stream_int_shutw(struct stream_interface *si);
-void stream_int_chk_rcv(struct stream_interface *si);
-void stream_int_chk_snd(struct stream_interface *si);
-
-struct task *stream_int_register_handler(struct stream_interface *si,
-					 void (*fct)(struct stream_interface *));
-struct task *stream_int_register_handler_task(struct stream_interface *si,
-					      struct task *(*fct)(struct task *));
-void stream_int_unregister_handler(struct stream_interface *si);
-
-#endif /* _PROTO_STREAM_INTERFACE_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/proto/stream_sock.h b/deps/haproxy-1.4.21/include/proto/stream_sock.h
deleted file mode 100644
index 929cb08..0000000
--- a/deps/haproxy-1.4.21/include/proto/stream_sock.h
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
-  include/proto/stream_sock.h
-  This file contains client-side definitions.
-
-  Copyright (C) 2000-2008 Willy Tarreau - w@1wt.eu
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _PROTO_STREAM_SOCK_H
-#define _PROTO_STREAM_SOCK_H
-
-#include <stdlib.h>
-#include <sys/socket.h>
-#include <sys/types.h>
-
-#include <common/config.h>
-#include <types/stream_interface.h>
-
-
-/* main event functions used to move data between sockets and buffers */
-int stream_sock_read(int fd);
-int stream_sock_write(int fd);
-void stream_sock_data_finish(struct stream_interface *si);
-void stream_sock_shutr(struct stream_interface *si);
-void stream_sock_shutw(struct stream_interface *si);
-void stream_sock_chk_rcv(struct stream_interface *si);
-void stream_sock_chk_snd(struct stream_interface *si);
-
-
-/* This either returns the sockname or the original destination address. Code
- * inspired from Patrick Schaaf's example of nf_getsockname() implementation.
- */
-static inline int get_original_dst(int fd, struct sockaddr_in *sa, socklen_t *salen) {
-#if defined(TPROXY) && defined(SO_ORIGINAL_DST)
-    return getsockopt(fd, SOL_IP, SO_ORIGINAL_DST, (void *)sa, salen);
-#else
-#if defined(TPROXY) && defined(USE_GETSOCKNAME)
-    return getsockname(fd, (struct sockaddr *)sa, salen);
-#else
-    return -1;
-#endif
-#endif
-}
-
-
-#endif /* _PROTO_STREAM_SOCK_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/proto/task.h b/deps/haproxy-1.4.21/include/proto/task.h
deleted file mode 100644
index cf75ac8..0000000
--- a/deps/haproxy-1.4.21/include/proto/task.h
+++ /dev/null
@@ -1,270 +0,0 @@
-/*
-  include/proto/task.h
-  Functions for task management.
-
-  Copyright (C) 2000-2009 Willy Tarreau - w@1wt.eu
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _PROTO_TASK_H
-#define _PROTO_TASK_H
-
-
-#include <sys/time.h>
-
-#include <common/config.h>
-#include <common/memory.h>
-#include <common/mini-clist.h>
-#include <common/standard.h>
-#include <common/ticks.h>
-#include <eb32tree.h>
-
-#include <types/task.h>
-
-/* Principle of the wait queue.
- *
- * We want to be able to tell whether an expiration date is before of after the
- * current time <now>. We KNOW that expiration dates are never too far apart,
- * because they are measured in ticks (milliseconds). We also know that almost
- * all dates will be in the future, and that a very small part of them will be
- * in the past, they are the ones which have expired since last time we checked
- * them. Using ticks, we know if a date is in the future or in the past, but we
- * cannot use that to store sorted information because that reference changes
- * all the time.
- *
- * We'll use the fact that the time wraps to sort timers. Timers above <now>
- * are in the future, timers below <now> are in the past. Here, "above" and
- * "below" are to be considered modulo 2^31.
- *
- * Timers are stored sorted in an ebtree. We use the new ability for ebtrees to
- * lookup values starting from X to only expire tasks between <now> - 2^31 and
- * <now>. If the end of the tree is reached while walking over it, we simply
- * loop back to the beginning. That way, we have no problem keeping sorted
- * wrapping timers in a tree, between (now - 24 days) and (now + 24 days). The
- * keys in the tree always reflect their real position, none can be infinite.
- * This reduces the number of checks to be performed.
- *
- * Another nice optimisation is to allow a timer to stay at an old place in the
- * queue as long as it's not further than the real expiration date. That way,
- * we use the tree as a place holder for a minorant of the real expiration
- * date. Since we have a very low chance of hitting a timeout anyway, we can
- * bounce the nodes to their right place when we scan the tree if we encounter
- * a misplaced node once in a while. This even allows us not to remove the
- * infinite timers from the wait queue.
- *
- * So, to summarize, we have :
- *   - node->key always defines current position in the wait queue
- *   - timer is the real expiration date (possibly infinite)
- *   - node->key is always before or equal to timer
- *
- * The run queue works similarly to the wait queue except that the current date
- * is replaced by an insertion counter which can also wrap without any problem.
- */
-
-/* The farthest we can look back in a timer tree */
-#define TIMER_LOOK_BACK       (1U << 31)
-
-/* a few exported variables */
-extern unsigned int nb_tasks;     /* total number of tasks */
-extern unsigned int run_queue;    /* run queue size */
-extern unsigned int run_queue_cur;
-extern unsigned int nb_tasks_cur;
-extern unsigned int niced_tasks;  /* number of niced tasks in the run queue */
-extern struct pool_head *pool2_task;
-extern struct eb32_node *last_timer;   /* optimization: last queued timer */
-
-/* return 0 if task is in run queue, otherwise non-zero */
-static inline int task_in_rq(struct task *t)
-{
-	return t->rq.node.leaf_p != NULL;
-}
-
-/* return 0 if task is in wait queue, otherwise non-zero */
-static inline int task_in_wq(struct task *t)
-{
-	return t->wq.node.leaf_p != NULL;
-}
-
-/* puts the task <t> in run queue with reason flags <f>, and returns <t> */
-struct task *__task_wakeup(struct task *t);
-static inline struct task *task_wakeup(struct task *t, unsigned int f)
-{
-	if (likely(!task_in_rq(t)))
-		__task_wakeup(t);
-	t->state |= f;
-	return t;
-}
-
-/*
- * Unlink the task from the wait queue, and possibly update the last_timer
- * pointer. A pointer to the task itself is returned. The task *must* already
- * be in the wait queue before calling this function. If unsure, use the safer
- * task_unlink_wq() function.
- */
-static inline struct task *__task_unlink_wq(struct task *t)
-{
-	eb32_delete(&t->wq);
-	if (last_timer == &t->wq)
-		last_timer = NULL;
-	return t;
-}
-
-static inline struct task *task_unlink_wq(struct task *t)
-{
-	if (likely(task_in_wq(t)))
-		__task_unlink_wq(t);
-	return t;
-}
-
-/*
- * Unlink the task from the run queue. The run_queue size and number of niced
- * tasks are updated too. A pointer to the task itself is returned. The task
- * *must* already be in the wait queue before calling this function. If unsure,
- * use the safer task_unlink_rq() function.
- */
-static inline struct task *__task_unlink_rq(struct task *t)
-{
-	eb32_delete(&t->rq);
-	run_queue--;
-	if (likely(t->nice))
-		niced_tasks--;
-	return t;
-}
-
-static inline struct task *task_unlink_rq(struct task *t)
-{
-	if (likely(task_in_rq(t)))
-		__task_unlink_rq(t);
-	return t;
-}
-
-/*
- * Unlinks the task and adjusts run queue stats.
- * A pointer to the task itself is returned.
- */
-static inline struct task *task_delete(struct task *t)
-{
-	task_unlink_wq(t);
-	task_unlink_rq(t);
-	return t;
-}
-
-/*
- * Initialize a new task. The bare minimum is performed (queue pointers and
- * state).  The task is returned. This function should not be used outside of
- * task_new().
- */
-static inline struct task *task_init(struct task *t)
-{
-	t->wq.node.leaf_p = NULL;
-	t->rq.node.leaf_p = NULL;
-	t->state = TASK_SLEEPING;
-	t->nice = 0;
-	t->calls = 0;
-	return t;
-}
-
-/*
- * Allocate and initialise a new task. The new task is returned, or NULL in
- * case of lack of memory. The task count is incremented. Tasks should only
- * be allocated this way, and must be freed using task_free().
- */
-static inline struct task *task_new(void)
-{
-	struct task *t = pool_alloc2(pool2_task);
-	if (t) {
-		nb_tasks++;
-		task_init(t);
-	}
-	return t;
-}
-
-/*
- * Free a task. Its context must have been freed since it will be lost.
- * The task count is decremented.
- */
-static inline void task_free(struct task *t)
-{
-	pool_free2(pool2_task, t);
-	nb_tasks--;
-}
-
-/* Place <task> into the wait queue, where it may already be. If the expiration
- * timer is infinite, do nothing and rely on wake_expired_task to clean up.
- */
-void __task_queue(struct task *task);
-static inline void task_queue(struct task *task)
-{
-	/* If we already have a place in the wait queue no later than the
-	 * timeout we're trying to set, we'll stay there, because it is very
-	 * unlikely that we will reach the timeout anyway. If the timeout
-	 * has been disabled, it's useless to leave the queue as well. We'll
-	 * rely on wake_expired_tasks() to catch the node and move it to the
-	 * proper place should it ever happen. Finally we only add the task
-	 * to the queue if it was not there or if it was further than what
-	 * we want.
-	 */
-	if (!tick_isset(task->expire))
-		return;
-
-	if (!task_in_wq(task) || tick_is_lt(task->expire, task->wq.key))
-		__task_queue(task);
-}
-
-/* Ensure <task> will be woken up at most at <when>. If the task is already in
- * the run queue (but not running), nothing is done. It may be used that way
- * with a delay :  task_schedule(task, tick_add(now_ms, delay));
- */
-static inline void task_schedule(struct task *task, int when)
-{
-	if (task_in_rq(task))
-		return;
-
-	if (task_in_wq(task))
-		when = tick_first(when, task->expire);
-
-	task->expire = when;
-	if (!task_in_wq(task) || tick_is_lt(task->expire, task->wq.key))
-		__task_queue(task);
-}
-
-/*
- * This does 4 things :
- *   - wake up all expired tasks
- *   - call all runnable tasks
- *   - call maintain_proxies() to enable/disable the listeners
- *   - return the date of next event in <next> or eternity.
- */
-
-void process_runnable_tasks(int *next);
-
-/*
- * Extract all expired timers from the timer queue, and wakes up all
- * associated tasks. Returns the date of next event (or eternity).
- */
-void wake_expired_tasks(int *next);
-
-/* Perform minimal initializations, report 0 in case of error, 1 if OK. */
-int init_task();
-
-#endif /* _PROTO_TASK_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/proto/template.h b/deps/haproxy-1.4.21/include/proto/template.h
deleted file mode 100644
index f7f9e55..0000000
--- a/deps/haproxy-1.4.21/include/proto/template.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
-  include/proto/template.h
-  This file serves as a template for future include files.
-
-  Copyright (C) 2000-2006 Willy Tarreau - w@1wt.eu
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _PROTO_TEMPLATE_H
-#define _PROTO_TEMPLATE_H
-
-#include <common/config.h>
-#include <types/template.h>
-
-
-#endif /* _PROTO_TEMPLATE_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/types/acl.h b/deps/haproxy-1.4.21/include/types/acl.h
deleted file mode 100644
index 1fda0e4..0000000
--- a/deps/haproxy-1.4.21/include/types/acl.h
+++ /dev/null
@@ -1,352 +0,0 @@
-/*
- * include/types/acl.h
- * This file provides structures and types for ACLs.
- *
- * Copyright (C) 2000-2010 Willy Tarreau - w@1wt.eu
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _TYPES_ACL_H
-#define _TYPES_ACL_H
-
-#include <common/compat.h>
-#include <common/config.h>
-#include <common/mini-clist.h>
-
-#include <types/auth.h>
-#include <types/proxy.h>
-#include <types/server.h>
-#include <types/session.h>
-
-#include <ebmbtree.h>
-
-/* Pattern matching function result.
- *
- * We're using a 3-state matching system :
- *   - PASS : at least one pattern already matches
- *   - MISS : some data is missing to decide if some rules may finally match.
- *   - FAIL : no mattern may ever match
- *
- * We assign values 0, 1 and 3 to FAIL, MISS and PASS respectively, so that we
- * can make use of standard arithmetics for the truth tables below :
- *
- *      x  | !x          x&y | F(0) | M(1) | P(3)     x|y | F(0) | M(1) | P(3)
- *   ------+-----       -----+------+------+-----    -----+------+------+-----
- *    F(0) | P(3)        F(0)| F(0) | F(0) | F(0)     F(0)| F(0) | M(1) | P(3)
- *    M(1) | M(1)        M(1)| F(0) | M(1) | M(1)     M(1)| M(1) | M(1) | P(3)
- *    P(3) | F(0)        P(3)| F(0) | M(1) | P(3)     P(3)| P(3) | P(3) | P(3)
- *
- *  neg(x) = (3 >> x)       and(x,y) = (x & y)           or(x,y) = (x | y)
- *
- */
-
-enum {
-	ACL_PAT_FAIL = 0,           /* test failed */
-	ACL_PAT_MISS = 1,           /* test may pass with more info */
-	ACL_PAT_PASS = 3,           /* test passed */
-};
-
-/* Condition polarity. It makes it easier for any option to choose between
- * IF/UNLESS if it can store that information within the condition itself.
- * Those should be interpreted as "IF/UNLESS result == PASS".
- */
-enum {
-	ACL_COND_NONE,		/* no polarity set yet */
-	ACL_COND_IF,		/* positive condition (after 'if') */
-	ACL_COND_UNLESS,	/* negative condition (after 'unless') */
-};
-
-/* possible flags for intermediate test values. The flags are maintained
- * across consecutive fetches for a same entry (eg: parse all req lines).
- */
-enum {
-	ACL_TEST_F_READ_ONLY  = 1 << 0, /* test data are read-only */
-	ACL_TEST_F_MUST_FREE  = 1 << 1, /* test data must be freed after end of evaluation */
-	ACL_TEST_F_VOL_TEST   = 1 << 2, /* result must not survive longer than the test (eg: time) */
-	ACL_TEST_F_VOL_HDR    = 1 << 3, /* result sensitive to changes in headers */
-	ACL_TEST_F_VOL_1ST    = 1 << 4, /* result sensitive to changes in first line (eg: URI) */
-	ACL_TEST_F_VOL_TXN    = 1 << 5, /* result sensitive to new transaction (eg: persist) */
-	ACL_TEST_F_VOL_SESS   = 1 << 6, /* result sensitive to new session (eg: IP) */
-	ACL_TEST_F_VOLATILE   = (1<<2)|(1<<3)|(1<<4)|(1<<5)|(1<<6),
-	ACL_TEST_F_FETCH_MORE = 1 << 7, /* if test does not match, retry with next entry (for multi-match) */
-	ACL_TEST_F_MAY_CHANGE = 1 << 8, /* if test does not match, retry later (eg: request size) */
-	ACL_TEST_F_RES_SET    = 1 << 9, /* for fetch() function to assign the result without calling match() */
-	ACL_TEST_F_RES_PASS   = 1 << 10,/* with SET_RESULT, sets result to PASS (defaults to FAIL) */
-	ACL_TEST_F_SET_RES_PASS = (ACL_TEST_F_RES_SET|ACL_TEST_F_RES_PASS),  /* sets result to PASS */
-	ACL_TEST_F_SET_RES_FAIL = (ACL_TEST_F_RES_SET),                      /* sets result to FAIL */
-	ACL_TEST_F_NULL_MATCH = 1 << 11,/* call expr->kw->match with NULL pattern if expr->patterns is empty */
-};
-
-/* ACLs can be evaluated on requests and on responses, and on partial or complete data */
-enum {
-	ACL_DIR_REQ = 0,        /* ACL evaluated on request */
-	ACL_DIR_RTR = (1 << 0), /* ACL evaluated on response */
-	ACL_DIR_MASK = (ACL_DIR_REQ | ACL_DIR_RTR),
-	ACL_PARTIAL = (1 << 1), /* partial data, return MISS if data are missing */
-};
-
-/* possible flags for expressions or patterns */
-enum {
-	ACL_PAT_F_IGNORE_CASE = 1 << 0,       /* ignore case */
-	ACL_PAT_F_FROM_FILE   = 1 << 1,       /* pattern comes from a file */
-	ACL_PAT_F_TREE_OK     = 1 << 2,       /* the pattern parser is allowed to build a tree */
-	ACL_PAT_F_TREE        = 1 << 3,       /* some patterns are arranged in a tree */
-};
-
-/* what capabilities an ACL uses. These flags are set during parsing, which
- * allows for flexible ACLs typed by their contents.
- */
-enum {
-	ACL_USE_NOTHING         = 0,            /* no need for anything beyond internal information */
-	ACL_USE_TCP4_PERMANENT  = 1 <<  0,      /* unchanged TCPv4 data (eg: source IP) */
-	ACL_USE_TCP4_CACHEABLE  = 1 <<  1,      /* cacheable TCPv4 data (eg: src conns) */
-	ACL_USE_TCP4_VOLATILE   = 1 <<  2,      /* volatile  TCPv4 data (eg: RTT) */
-	ACL_USE_TCP4_ANY        = (ACL_USE_TCP4_PERMANENT | ACL_USE_TCP4_CACHEABLE | ACL_USE_TCP4_VOLATILE),
-
-	ACL_USE_TCP6_PERMANENT  = 1 <<  3,      /* unchanged TCPv6 data (eg: source IP) */
-	ACL_USE_TCP6_CACHEABLE  = 1 <<  4,      /* cacheable TCPv6 data (eg: src conns) */
-	ACL_USE_TCP6_VOLATILE   = 1 <<  5,      /* volatile  TCPv6 data (eg: RTT) */
-	ACL_USE_TCP6_ANY        = (ACL_USE_TCP6_PERMANENT | ACL_USE_TCP6_CACHEABLE | ACL_USE_TCP6_VOLATILE),
-
-	ACL_USE_TCP_PERMANENT   = 1 <<  6,      /* unchanged TCPv4/v6 data (eg: source IP) */
-	ACL_USE_TCP_CACHEABLE   = 1 <<  7,      /* cacheable TCPv4/v6 data (eg: src conns) */
-	ACL_USE_TCP_VOLATILE    = 1 <<  8,      /* volatile  TCPv4/v6 data (eg: RTT) */
-	ACL_USE_TCP_ANY         = (ACL_USE_TCP_PERMANENT | ACL_USE_TCP_CACHEABLE | ACL_USE_TCP_VOLATILE),
-
-	ACL_USE_L4REQ_PERMANENT = 1 <<  9,      /* unchanged layer4 request data */
-	ACL_USE_L4REQ_CACHEABLE = 1 << 10,      /* cacheable layer4 request data (eg: length) */
-	ACL_USE_L4REQ_VOLATILE  = 1 << 11,      /* volatile  layer4 request data (eg: contents) */
-	ACL_USE_L4REQ_ANY       = (ACL_USE_L4REQ_PERMANENT | ACL_USE_L4REQ_CACHEABLE | ACL_USE_L4REQ_VOLATILE),
-
-	ACL_USE_L4RTR_PERMANENT = 1 << 12,      /* unchanged layer4 response data */
-	ACL_USE_L4RTR_CACHEABLE = 1 << 13,      /* cacheable layer4 response data (eg: length) */
-	ACL_USE_L4RTR_VOLATILE  = 1 << 14,      /* volatile  layer4 response data (eg: contents) */
-	ACL_USE_L4RTR_ANY       = (ACL_USE_L4RTR_PERMANENT | ACL_USE_L4RTR_CACHEABLE | ACL_USE_L4RTR_VOLATILE),
-
-	ACL_USE_L7REQ_PERMANENT = 1 << 15,      /* unchanged layer7 request data (eg: method) */
-	ACL_USE_L7REQ_CACHEABLE = 1 << 16,      /* cacheable layer7 request data (eg: content-length) */
-	ACL_USE_L7REQ_VOLATILE  = 1 << 17,      /* volatile  layer7 request data (eg: cookie) */
-	ACL_USE_L7REQ_ANY       = (ACL_USE_L7REQ_PERMANENT | ACL_USE_L7REQ_CACHEABLE | ACL_USE_L7REQ_VOLATILE),
-
-	ACL_USE_L7RTR_PERMANENT = 1 << 18,      /* unchanged layer7 response data (eg: status) */
-	ACL_USE_L7RTR_CACHEABLE = 1 << 19,      /* cacheable layer7 response data (eg: content-length) */
-	ACL_USE_L7RTR_VOLATILE  = 1 << 20,      /* volatile  layer7 response data (eg: cookie) */
-	ACL_USE_L7RTR_ANY       = (ACL_USE_L7RTR_PERMANENT | ACL_USE_L7RTR_CACHEABLE | ACL_USE_L7RTR_VOLATILE),
-
-	/* those ones are used for ambiguous "hdr_xxx" verbs */
-	ACL_USE_HDR_CACHEABLE   = 1 << 21,      /* cacheable request or response header (eg: content-length) */
-	ACL_USE_HDR_VOLATILE    = 1 << 22,      /* volatile  request or response header (eg: cookie) */
-	ACL_USE_HDR_ANY = (ACL_USE_HDR_CACHEABLE | ACL_USE_HDR_VOLATILE),
-
-	/* information which remains during response */
-	ACL_USE_REQ_PERMANENT   = (ACL_USE_TCP4_PERMANENT | ACL_USE_TCP6_PERMANENT | ACL_USE_TCP_PERMANENT |
-				   ACL_USE_L4REQ_PERMANENT | ACL_USE_L7REQ_PERMANENT),
-	ACL_USE_REQ_CACHEABLE   = (ACL_USE_TCP4_CACHEABLE | ACL_USE_TCP6_CACHEABLE | ACL_USE_TCP_CACHEABLE |
-				   ACL_USE_L4REQ_CACHEABLE | ACL_USE_L7REQ_CACHEABLE | ACL_USE_HDR_CACHEABLE),
-
-	/* information which does not remain during response */
-	ACL_USE_REQ_VOLATILE    = (ACL_USE_TCP4_VOLATILE | ACL_USE_TCP6_VOLATILE | ACL_USE_TCP_VOLATILE |
-				   ACL_USE_L4REQ_VOLATILE | ACL_USE_L7REQ_VOLATILE),
-
-	/* any type of layer 4 contents information */
-	ACL_USE_L4_ANY          = (ACL_USE_L4REQ_ANY | ACL_USE_L4RTR_ANY),
-
-	/* any type of layer 7 information */
-	ACL_USE_L7_ANY          = (ACL_USE_L7REQ_ANY | ACL_USE_L7RTR_ANY | ACL_USE_HDR_ANY),
-
-	/* any type of response information */
-	ACL_USE_RTR_ANY         = (ACL_USE_L4RTR_ANY | ACL_USE_L7RTR_ANY),
-
-	/* some flags indicating if a keyword supports exact pattern matching,
-	 * so that patterns may be arranged in lookup trees. Let's put those
-	 * flags at the end to leave some space for the other ones above.
-	 */
-	ACL_MAY_LOOKUP          =  1 << 31,  /* exact pattern lookup */
-};
-
-/* filtering hooks */
-enum {
-	/* hooks on the request path */
-	ACL_HOOK_REQ_FE_TCP = 0,
-	ACL_HOOK_REQ_FE_TCP_CONTENT,
-	ACL_HOOK_REQ_FE_HTTP_IN,
-	ACL_HOOK_REQ_FE_SWITCH,
-	ACL_HOOK_REQ_BE_TCP_CONTENT,
-	ACL_HOOK_REQ_BE_HTTP_IN,
-	ACL_HOOK_REQ_BE_SWITCH,
-	ACL_HOOK_REQ_FE_HTTP_OUT,
-	ACL_HOOK_REQ_BE_HTTP_OUT,
-	/* hooks on the response path */
-	ACL_HOOK_RTR_BE_TCP_CONTENT,
-	ACL_HOOK_RTR_BE_HTTP_IN,
-	ACL_HOOK_RTR_FE_TCP_CONTENT,
-	ACL_HOOK_RTR_FE_HTTP_IN,
-	ACL_HOOK_RTR_BE_HTTP_OUT,
-	ACL_HOOK_RTR_FE_HTTP_OUT,
-};
-
-/* How to store a time range and the valid days in 29 bits */
-struct acl_time {
-	int dow:7;              /* 1 bit per day of week: 0-6 */
-	int h1:5, m1:6;         /* 0..24:0..60. Use 0:0 for all day. */
-	int h2:5, m2:6;         /* 0..24:0..60. Use 24:0 for all day. */
-};
-
-/* The acl will be linked to from the proxy where it is declared */
-struct acl_pattern {
-	struct list list;                       /* chaining */
-	union {
-		int i;                          /* integer value */
-		struct {
-			signed long long min, max;
-			int min_set :1;
-			int max_set :1;
-		} range; /* integer range */
-		struct {
-			struct in_addr addr;
-			struct in_addr mask;
-		} ipv4;                         /* IPv4 address */
-		struct acl_time time;           /* valid hours and days */
-		unsigned int group_mask;
-		struct eb_root *tree;           /* tree storing all values if any */
-	} val;                                  /* direct value */
-	union {
-		void *ptr;              /* any data */
-		char *str;              /* any string  */
-		regex_t *reg;           /* a compiled regex */
-	} ptr;                          /* indirect values, allocated */
-	void(*freeptrbuf)(void *ptr);	/* a destructor able to free objects from the ptr */
-	int len;                        /* data length when required  */
-	int flags;                      /* expr or pattern flags. */
-};
-
-/* The structure exchanged between an acl_fetch_* function responsible for
- * retrieving a value, and an acl_match_* function responsible for testing it.
- */
-struct acl_test {
-	int i;                  /* integer value */
-	char *ptr;              /* pointer to beginning of value */
-	int len;                /* length of value at ptr, otherwise ignored */
-	int flags;              /* ACL_TEST_F_* set to 0 on first call */
-	union {                 /* fetch_* functions context for any purpose */
-		void *p;        /* any pointer */
-		int i;          /* any integer */
-		long long ll;   /* any long long or smaller */
-		double d;       /* any float or double */
-		void *a[8];     /* any array of up to 8 pointers */
-	} ctx;
-};
-
-
-/*
- * ACL keyword: Associates keywords with parsers, methods to retrieve the value and testers.
- */
-
-/* some dummy declarations to silent the compiler */
-struct proxy;
-struct session;
-
-/*
- * NOTE:
- * The 'parse' function is called to parse words in the configuration. It must
- * return the number of valid words read. 0 = error. The 'opaque' argument may
- * be used by functions which need to maintain a context between consecutive
- * values. It is initialized to zero before the first call, and passed along
- * successive calls.
- */
-
-struct acl_expr;
-struct acl_keyword {
-	const char *kw;
-	int (*parse)(const char **text, struct acl_pattern *pattern, int *opaque);
-	int (*fetch)(struct proxy *px, struct session *l4, void *l7, int dir,
-	             struct acl_expr *expr, struct acl_test *test);
-	int (*match)(struct acl_test *test, struct acl_pattern *pattern);
-	unsigned int requires;   /* bit mask of all ACL_USE_* required to evaluate this keyword */
-	int use_cnt;
-};
-
-/*
- * A keyword list. It is a NULL-terminated array of keywords. It embeds a
- * struct list in order to be linked to other lists, allowing it to easily
- * be declared where it is needed, and linked without duplicating data nor
- * allocating memory.
- */
-struct acl_kw_list {
-	struct list list;
-	struct acl_keyword kw[VAR_ARRAY];
-};
-
-/*
- * Description of an ACL expression.
- * It contains a subject and a set of patterns to test against it.
- *  - the function get() is called to retrieve the subject from the
- *    current session or transaction and build a test.
- *  - the function test() is called to evaluate the test based on the
- *    available patterns and return ACL_PAT_*
- * Both of those functions are available through the keyword.
- */
-struct acl_expr {
-	struct list list;           /* chaining */
-	struct acl_keyword *kw;     /* back-reference to the keyword */
-	union {                     /* optional argument of the subject (eg: header or cookie name) */
-		char *str;
-		struct userlist *ul;
-		struct server *srv;
-	} arg;
-	int arg_len;                /* optional argument length */
-	struct list patterns;       /* list of acl_patterns */
-	struct eb_root pattern_tree;  /* may be used for lookup in large datasets */
-};
-
-struct acl {
-	struct list list;           /* chaining */
-	char *name;		    /* acl name */
-	struct list expr;	    /* list of acl_exprs */
-	int cache_idx;              /* ACL index in cache */
-	unsigned int requires;      /* or'ed bit mask of all acl_expr's ACL_USE_* */
-};
-
-/* the condition will be linked to from an action in a proxy */
-struct acl_term {
-	struct list list;           /* chaining */
-	struct acl *acl;            /* acl pointed to by this term */
-	int neg;                    /* 1 if the ACL result must be negated */
-};
-
-struct acl_term_suite {
-	struct list list;           /* chaining of term suites */
-	struct list terms;          /* list of acl_terms */
-};
-
-struct acl_cond {
-	struct list list;           /* Some specific tests may use multiple conditions */
-	struct list suites;         /* list of acl_term_suites */
-	int pol;                    /* polarity: ACL_COND_IF / ACL_COND_UNLESS */
-	unsigned int requires;      /* or'ed bit mask of all acl's ACL_USE_* */
-	const char *file;           /* config file where the condition is declared */
-	int line;                   /* line in the config file where the condition is declared */
-};
-
-
-#endif /* _TYPES_ACL_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/types/auth.h b/deps/haproxy-1.4.21/include/types/auth.h
deleted file mode 100644
index f7e3dd6..0000000
--- a/deps/haproxy-1.4.21/include/types/auth.h
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * User authentication & authorization.
- *
- * Copyright 2010 Krzysztof Piotr Oledzki <ole@ans.pl>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#ifndef _TYPES_AUTH_H
-#define _TYPES_AUTH_H
-
-#include <common/config.h>
-#include <common/mini-clist.h>
-
-#include <types/auth.h>
-
-#define MAX_AUTH_GROUPS (unsigned int)(sizeof(int)*8)
-
-#define AU_O_INSECURE	0x00000001		/* insecure, unencrypted password */
-
-enum {
-	PR_REQ_ACL_ACT_UNKNOWN = 0,
-	PR_REQ_ACL_ACT_ALLOW,
-	PR_REQ_ACL_ACT_DENY,
-	PR_REQ_ACL_ACT_HTTP_AUTH,
-
-	PR_REQ_ACL_ACT_MAX
-};
-
-
-struct req_acl_rule {
-	struct list list;
-	struct acl_cond *cond;			/* acl condition to meet */
-	unsigned int action;
-	struct {
-		char *realm;
-	} http_auth;
-};
-
-struct auth_users {
-	struct auth_users *next;
-	unsigned int flags;
-	char *user, *pass;
-	union {
-		char *groups;
-		unsigned int group_mask;
-	} u;
-};
-
-struct userlist {
-	struct userlist *next;
-	char *name;
-	struct auth_users *users;
-	int grpcnt;
-	char *groups[MAX_AUTH_GROUPS];
-	char **groupusers;
-};
-
-#endif /* _TYPES_AUTH_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
-
diff --git a/deps/haproxy-1.4.21/include/types/backend.h b/deps/haproxy-1.4.21/include/types/backend.h
deleted file mode 100644
index dc4786e..0000000
--- a/deps/haproxy-1.4.21/include/types/backend.h
+++ /dev/null
@@ -1,139 +0,0 @@
-/*
- * include/types/backend.h
- * This file assembles definitions for backends
- *
- * Copyright (C) 2000-2009 Willy Tarreau - w@1wt.eu
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _TYPES_BACKEND_H
-#define _TYPES_BACKEND_H
-
-#include <common/config.h>
-#include <types/lb_chash.h>
-#include <types/lb_fwlc.h>
-#include <types/lb_fwrr.h>
-#include <types/lb_map.h>
-#include <types/server.h>
-
-/* Parameters for lbprm.algo */
-
-/* Lower bits define the kind of load balancing method, which means the type of
- * algorithm, and which criterion it is based on. For this reason, those bits
- * also include information about dependencies, so that the config parser can
- * detect incompatibilities.
- */
-
-/* LB parameters. Depends on the LB kind. Right now, only hashing uses this. */
-#define BE_LB_HASH_SRC  0x00000  /* hash source IP */
-#define BE_LB_HASH_URI  0x00001  /* hash HTTP URI */
-#define BE_LB_HASH_PRM  0x00002  /* hash HTTP URL parameter */
-#define BE_LB_HASH_HDR  0x00003  /* hash HTTP header value */
-#define BE_LB_HASH_RDP  0x00004  /* hash RDP cookie value */
-
-#define BE_LB_RR_DYN    0x00000  /* dynamic round robin (default) */
-#define BE_LB_RR_STATIC 0x00001  /* static round robin */
-#define BE_LB_PARM      0x000FF  /* mask to get/clear the LB param */
-
-/* Required input(s) */
-#define BE_LB_NEED_NONE	0x00000  /* no input needed            */
-#define BE_LB_NEED_ADDR	0x00100  /* only source address needed */
-#define BE_LB_NEED_DATA	0x00200  /* some payload is needed     */
-#define BE_LB_NEED_HTTP	0x00400  /* an HTTP request is needed  */
-/* not used: 0x0800 */
-#define BE_LB_NEED      0x00F00  /* mask to get/clear dependencies */
-
-/* Algorithm */
-#define BE_LB_KIND_NONE 0x00000  /* algorithm not set */
-#define BE_LB_KIND_RR   0x01000  /* round-robin */
-#define BE_LB_KIND_LC   0x02000  /* least connections */
-#define BE_LB_KIND_HI   0x03000  /* hash of input (see hash inputs above) */
-#define BE_LB_KIND      0x07000  /* mask to get/clear LB algorithm */
-
-/* All known variants of load balancing algorithms. These can be cleared using
- * the BE_LB_ALGO mask. For a check, using BE_LB_KIND is preferred.
- */
-#define BE_LB_ALGO_NONE (BE_LB_KIND_NONE | BE_LB_NEED_NONE)    /* not defined */
-#define BE_LB_ALGO_RR   (BE_LB_KIND_RR | BE_LB_NEED_NONE)      /* round robin */
-#define BE_LB_ALGO_LC   (BE_LB_KIND_LC | BE_LB_NEED_NONE)      /* least connections */
-#define BE_LB_ALGO_SRR  (BE_LB_KIND_RR | BE_LB_NEED_NONE | BE_LB_RR_STATIC) /* static round robin */
-#define BE_LB_ALGO_SH	(BE_LB_KIND_HI | BE_LB_NEED_ADDR | BE_LB_HASH_SRC) /* hash: source IP */
-#define BE_LB_ALGO_UH	(BE_LB_KIND_HI | BE_LB_NEED_HTTP | BE_LB_HASH_URI) /* hash: HTTP URI  */
-#define BE_LB_ALGO_PH	(BE_LB_KIND_HI | BE_LB_NEED_HTTP | BE_LB_HASH_PRM) /* hash: HTTP URL parameter */
-#define BE_LB_ALGO_HH	(BE_LB_KIND_HI | BE_LB_NEED_HTTP | BE_LB_HASH_HDR) /* hash: HTTP header value  */
-#define BE_LB_ALGO_RCH	(BE_LB_KIND_HI | BE_LB_NEED_DATA | BE_LB_HASH_RDP) /* hash: RDP cookie value   */
-#define BE_LB_ALGO      (BE_LB_KIND    | BE_LB_NEED      | BE_LB_PARM    ) /* mask to clear algo */
-
-/* Higher bits define how a given criterion is mapped to a server. In fact it
- * designates the LB function by itself. The dynamic algorithms will also have
- * the DYN bit set. These flags are automatically set at the end of the parsing.
- */
-#define BE_LB_LKUP_NONE   0x00000  /* not defined */
-#define BE_LB_LKUP_MAP    0x10000  /* static map based lookup */
-#define BE_LB_LKUP_RRTREE 0x20000  /* FWRR tree lookup */
-#define BE_LB_LKUP_LCTREE 0x30000  /* FWLC tree lookup */
-#define BE_LB_LKUP_CHTREE 0x40000  /* consistent hash  */
-#define BE_LB_LKUP        0x70000  /* mask to get just the LKUP value */
-
-/* additional properties */
-#define BE_LB_PROP_DYN    0x80000 /* bit to indicate a dynamic algorithm */
-
-/* hash types */
-#define BE_LB_HASH_MAP    0x000000 /* map-based hash (default) */
-#define BE_LB_HASH_CONS   0x100000 /* consistent hashbit to indicate a dynamic algorithm */
-#define BE_LB_HASH_TYPE   0x100000 /* get/clear hash types */
-
-/* various constants */
-
-/* The scale factor between user weight and effective weight allows smooth
- * weight modulation even with small weights (eg: 1). It should not be too high
- * though because it limits the number of servers in FWRR mode in order to
- * prevent any integer overflow. The max number of servers per backend is
- * limited to about 2^32/255^2/scale ~= 66051/scale. A scale of 16 looks like
- * a good value, as it allows more than 4000 servers per backend while leaving
- * modulation steps of about 6% for servers with the lowest weight (1).
- */
-#define BE_WEIGHT_SCALE 16
-
-/* LB parameters for all algorithms */
-struct lbprm {
-	int algo;			/* load balancing algorithm and variants: BE_LB_* */
-	int tot_wact, tot_wbck;		/* total effective weights of active and backup servers */
-	int tot_weight;			/* total effective weight of servers participating to LB */
-	int tot_used;			/* total number of servers used for LB */
-	int wmult;			/* ratio between user weight and effective weight */
-	int wdiv;			/* ratio between effective weight and user weight */
-	struct server *fbck;		/* first backup server when !PR_O_USE_ALL_BK, or NULL */
-	struct lb_map map;		/* LB parameters for map-based algorithms */
-	struct lb_fwrr fwrr;
-	struct lb_fwlc fwlc;
-	struct lb_chash chash;
-	/* Call backs for some actions. Any of them may be NULL (thus should be ignored). */
-	void (*update_server_eweight)(struct server *);  /* to be called after eweight change */
-	void (*set_server_status_up)(struct server *);   /* to be called after status changes to UP */
-	void (*set_server_status_down)(struct server *); /* to be called after status changes to DOWN */
-	void (*server_take_conn)(struct server *);       /* to be called when connection is assigned */
-	void (*server_drop_conn)(struct server *);       /* to be called when connection is dropped */
-};
-
-#endif /* _TYPES_BACKEND_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/types/buffers.h b/deps/haproxy-1.4.21/include/types/buffers.h
deleted file mode 100644
index 3adeaa7..0000000
--- a/deps/haproxy-1.4.21/include/types/buffers.h
+++ /dev/null
@@ -1,274 +0,0 @@
-/*
- * include/types/buffers.h
- * Buffer management definitions, macros and inline functions.
- *
- * Copyright (C) 2000-2009 Willy Tarreau - w@1wt.eu
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _TYPES_BUFFERS_H
-#define _TYPES_BUFFERS_H
-
-#include <common/config.h>
-#include <common/memory.h>
-#include <types/stream_interface.h>
-
-/* The BF_* macros designate Buffer Flags, which may be ORed in the bit field
- * member 'flags' in struct buffer. Here we have several types of flags :
- *
- *   - pure status flags, reported by the lower layer, which must be cleared
- *     before doing further I/O :
- *     BF_*_NULL, BF_*_PARTIAL
- *
- *   - pure status flags, reported by mid-layer, which must also be cleared
- *     before doing further I/O :
- *     BF_*_TIMEOUT, BF_*_ERROR
- *
- *   - read-only indicators reported by lower levels :
- *     BF_STREAMER, BF_STREAMER_FAST
- *
- *   - write-once status flags reported by the mid-level : BF_SHUTR, BF_SHUTW
- *
- *   - persistent control flags managed only by higher level :
- *     BF_SHUT*_NOW, BF_*_ENA, BF_HIJACK
- *
- * The flags have been arranged for readability, so that the read and write
- * bits have the same position in a byte (read being the lower byte and write
- * the second one). All flag names are relative to the buffer. For instance,
- * 'write' indicates the direction from the buffer to the stream interface.
- */
-
-#define BF_READ_NULL      0x000001  /* last read detected on producer side */
-#define BF_READ_PARTIAL   0x000002  /* some data were read from producer */
-#define BF_READ_TIMEOUT   0x000004  /* timeout while waiting for producer */
-#define BF_READ_ERROR     0x000008  /* unrecoverable error on producer side */
-#define BF_READ_ACTIVITY  (BF_READ_NULL|BF_READ_PARTIAL|BF_READ_ERROR)
-
-#define BF_FULL           0x000010  /* buffer cannot accept any more data (l >= max len) */
-#define BF_SHUTR          0x000020  /* producer has already shut down */
-#define BF_SHUTR_NOW      0x000040  /* the producer must shut down for reads ASAP */
-#define BF_READ_NOEXP     0x000080  /* producer should not expire */
-
-#define BF_WRITE_NULL     0x000100  /* write(0) or connect() succeeded on consumer side */
-#define BF_WRITE_PARTIAL  0x000200  /* some data were written to the consumer */
-#define BF_WRITE_TIMEOUT  0x000400  /* timeout while waiting for consumer */
-#define BF_WRITE_ERROR    0x000800  /* unrecoverable error on consumer side */
-#define BF_WRITE_ACTIVITY (BF_WRITE_NULL|BF_WRITE_PARTIAL|BF_WRITE_ERROR)
-
-#define BF_OUT_EMPTY      0x001000  /* send_max and pipe are empty. Set by last change. */
-#define BF_SHUTW          0x002000  /* consumer has already shut down */
-#define BF_SHUTW_NOW      0x004000  /* the consumer must shut down for writes ASAP */
-#define BF_AUTO_CLOSE     0x008000  /* producer can forward shutdown to other side */
-
-/* When either BF_SHUTR_NOW or BF_HIJACK is set, it is strictly forbidden for
- * the producer to alter the buffer contents. When BF_SHUTW_NOW is set, the
- * consumer is free to perform a shutw() when it has consumed the last contents,
- * otherwise the session processor will do it anyway.
- *
- * The SHUT* flags work like this :
- *
- *  SHUTR SHUTR_NOW  meaning
- *    0       0      normal case, connection still open and data is being read
- *    0       1      closing : the producer cannot feed data anymore but can close
- *    1       0      closed: the producer has closed its input channel.
- *    1       1      impossible
- *
- *  SHUTW SHUTW_NOW  meaning
- *    0       0      normal case, connection still open and data is being written
- *    0       1      closing: the consumer can send last data and may then close
- *    1       0      closed: the consumer has closed its output channel.
- *    1       1      impossible
- *
- * The SHUTW_NOW flag should be set by the session processor when SHUTR and AUTO_CLOSE
- * are both set. It may also be set by a hijacker at the end of data. And it may also
- * be set by the producer when it detects SHUTR while directly forwarding data to the
- * consumer.
- *
- * The SHUTR_NOW flag is mostly used to force the producer to abort when an error is
- * detected on the consumer side.
- */
-
-#define BF_STREAMER       0x010000  /* the producer is identified as streaming data */
-#define BF_STREAMER_FAST  0x020000  /* the consumer seems to eat the stream very fast */
-
-#define BF_HIJACK         0x040000  /* the producer is temporarily replaced by ->hijacker */
-#define BF_ANA_TIMEOUT    0x080000  /* the analyser timeout has expired */
-#define BF_READ_ATTACHED  0x100000  /* the read side is attached for the first time */
-#define BF_KERN_SPLICING  0x200000  /* kernel splicing desired for this buffer */
-#define BF_READ_DONTWAIT  0x400000  /* wake the task up after every read (eg: HTTP request) */
-#define BF_AUTO_CONNECT   0x800000  /* consumer may attempt to establish a new connection */
-
-#define BF_DONT_READ     0x1000000  /* disable reading for now */
-#define BF_EXPECT_MORE   0x2000000  /* more data expected to be sent very soon (one-shoot) */
-#define BF_SEND_DONTWAIT 0x4000000  /* don't wait for sending data (one-shoot) */
-#define BF_NEVER_WAIT    0x8000000  /* never wait for sending data (permanent) */
-
-/* Use these masks to clear the flags before going back to lower layers */
-#define BF_CLEAR_READ     (~(BF_READ_NULL|BF_READ_PARTIAL|BF_READ_ERROR|BF_READ_ATTACHED))
-#define BF_CLEAR_WRITE    (~(BF_WRITE_NULL|BF_WRITE_PARTIAL|BF_WRITE_ERROR))
-#define BF_CLEAR_TIMEOUT  (~(BF_READ_TIMEOUT|BF_WRITE_TIMEOUT|BF_ANA_TIMEOUT))
-
-/* Masks which define input events for stream analysers */
-#define BF_MASK_ANALYSER        (BF_READ_ATTACHED|BF_READ_ACTIVITY|BF_READ_TIMEOUT|BF_ANA_TIMEOUT|BF_WRITE_ACTIVITY)
-
-/* Mask for static flags which are not events, but might change during processing */
-#define BF_MASK_STATIC          (BF_OUT_EMPTY|BF_FULL|BF_HIJACK|BF_AUTO_CLOSE|BF_AUTO_CONNECT|BF_SHUTR|BF_SHUTW|BF_SHUTR_NOW|BF_SHUTW_NOW)
-
-
-/* Analysers (buffer->analysers).
- * Those bits indicate that there are some processing to do on the buffer
- * contents. It will probably evolve into a linked list later. Those
- * analysers could be compared to higher level processors.
- * The field is blanked by buffer_init() and only by analysers themselves
- * afterwards.
- */
-#define AN_REQ_DECODE_PROXY     0x00000001  /* take the proxied address from a 'PROXY' line */
-#define AN_REQ_INSPECT          0x00000002  /* inspect request contents */
-#define AN_REQ_WAIT_HTTP        0x00000004  /* wait for an HTTP request */
-#define AN_REQ_HTTP_PROCESS_FE  0x00000008  /* process the frontend's HTTP part */
-#define AN_REQ_SWITCHING_RULES  0x00000010  /* apply the switching rules */
-#define AN_REQ_HTTP_PROCESS_BE  0x00000020  /* process the backend's HTTP part */
-#define AN_REQ_HTTP_INNER       0x00000040  /* inner processing of HTTP request */
-#define AN_REQ_HTTP_TARPIT      0x00000080  /* wait for end of HTTP tarpit */
-#define AN_REQ_HTTP_BODY        0x00000100  /* inspect HTTP request body */
-#define AN_REQ_STICKING_RULES   0x00000200  /* table persistence matching */
-#define AN_REQ_PRST_RDP_COOKIE  0x00000400  /* persistence on rdp cookie */
-#define AN_REQ_HTTP_XFER_BODY   0x00000800  /* forward request body */
-
-/* response analysers */
-#define AN_RES_INSPECT          0x00010000  /* content inspection */
-#define AN_RES_WAIT_HTTP        0x00020000  /* wait for HTTP response */
-#define AN_RES_HTTP_PROCESS_BE  0x00040000  /* process backend's HTTP part */
-#define AN_RES_HTTP_PROCESS_FE  0x00040000  /* process frontend's HTTP part (same for now) */
-#define AN_RES_STORE_RULES      0x00080000  /* table persistence matching */
-#define AN_RES_HTTP_XFER_BODY   0x00100000  /* forward response body */
-
-
-/* Magic value to forward infinite size (TCP, ...), used with ->to_forward */
-#define BUF_INFINITE_FORWARD    MAX_RANGE(int)
-
-/* describes a chunk of string */
-struct chunk {
-	char *str;	/* beginning of the string itself. Might not be 0-terminated */
-	size_t size;	/* total size of the buffer, 0 if the *str is read-only */
-	int len;	/* current size of the string from first to last char. <0 = uninit. */
-};
-
-/* needed for a declaration below */
-struct session;
-
-struct buffer {
-	unsigned int flags;             /* BF_* */
-	int rex;                        /* expiration date for a read, in ticks */
-	int wex;                        /* expiration date for a write or connect, in ticks */
-	int rto;                        /* read timeout, in ticks */
-	int wto;                        /* write timeout, in ticks */
-	int cto;                        /* connect timeout, in ticks */
-	unsigned int l;                 /* data length */
-	char *r, *w, *lr;               /* read ptr, write ptr, last read */
-	unsigned int size;              /* buffer size in bytes */
-	unsigned int send_max;          /* number of bytes the sender can consume om this buffer, <= l */
-	unsigned int to_forward;        /* number of bytes to forward after send_max without a wake-up */
-	unsigned int analysers;         /* bit field indicating what to do on the buffer */
-	int analyse_exp;                /* expiration date for current analysers (if set) */
-	void (*hijacker)(struct session *, struct buffer *); /* alternative content producer */
-	unsigned char xfer_large;       /* number of consecutive large xfers */
-	unsigned char xfer_small;       /* number of consecutive small xfers */
-	unsigned long long total;       /* total data read */
-	struct stream_interface *prod;  /* producer attached to this buffer */
-	struct stream_interface *cons;  /* consumer attached to this buffer */
-	struct pipe *pipe;		/* non-NULL only when data present */
-	char data[0];                   /* <size> bytes */
-};
-
-
-/* Note about the buffer structure
-
-   The buffer contains two length indicators, one to_forward counter and one
-   send_max limit. First, it must be understood that the buffer is in fact
-   split in two parts :
-     - the visible data (->data, for ->l bytes)
-     - the invisible data, typically in kernel buffers forwarded directly from
-       the source stream sock to the destination stream sock (->pipe->data
-       bytes). Those are used only during forward.
-
-   In order not to mix data streams, the producer may only feed the invisible
-   data with data to forward, and only when the visible buffer is empty. The
-   consumer may not always be able to feed the invisible buffer due to platform
-   limitations (lack of kernel support).
-
-   Conversely, the consumer must always take data from the invisible data first
-   before ever considering visible data. There is no limit to the size of data
-   to consume from the invisible buffer, as platform-specific implementations
-   will rarely leave enough control on this. So any byte fed into the invisible
-   buffer is expected to reach the destination file descriptor, by any means.
-   However, it's the consumer's responsibility to ensure that the invisible
-   data has been entirely consumed before consuming visible data. This must be
-   reflected by ->pipe->data. This is very important as this and only this can
-   ensure strict ordering of data between buffers.
-
-   The producer is responsible for decreasing ->to_forward and increasing
-   ->send_max. The ->to_forward parameter indicates how many bytes may be fed
-   into either data buffer without waking the parent up. The special value
-   BUF_INFINITE_FORWARD is never decreased nor increased. The ->send_max
-   parameter says how many bytes may be read from the visible buffer. Thus it
-   may never exceed ->l. This parameter is updated by any buffer_write() as
-   well as any data forwarded through the visible buffer.
-
-   The consumer is responsible for decreasing ->send_max when it sends data
-   from the visible buffer, and ->pipe->data when it sends data from the
-   invisible buffer.
-
-   A real-world example consists in part in an HTTP response waiting in a
-   buffer to be forwarded. We know the header length (300) and the amount of
-   data to forward (content-length=9000). The buffer already contains 1000
-   bytes of data after the 300 bytes of headers. Thus the caller will set
-   ->send_max to 300 indicating that it explicitly wants to send those data,
-   and set ->to_forward to 9000 (content-length). This value must be normalised
-   immediately after updating ->to_forward : since there are already 1300 bytes
-   in the buffer, 300 of which are already counted in ->send_max, and that size
-   is smaller than ->to_forward, we must update ->send_max to 1300 to flush the
-   whole buffer, and reduce ->to_forward to 8000. After that, the producer may
-   try to feed the additional data through the invisible buffer using a
-   platform-specific method such as splice().
-
-   The ->to_forward entry is also used to detect whether we can fill the buffer
-   or not. The idea is that we need to save some space for data manipulation
-   (mainly header rewriting in HTTP) so we don't want to have a full buffer on
-   input before processing a request or response. Thus, we ensure that there is
-   always global.maxrewrite bytes of free space. Since we don't want to forward
-   chunks without filling the buffer, we rely on ->to_forward. When ->to_forward
-   is null, we may have some processing to do so we don't want to fill the
-   buffer. When ->to_forward is non-null, we know we don't care for at least as
-   many bytes. In the end, we know that each of the ->to_forward bytes will
-   eventually leave the buffer. So as long as ->to_forward is larger than
-   global.maxrewrite, we can fill the buffer. If ->to_forward is smaller than
-   global.maxrewrite, then we don't want to fill the buffer with more than
-   ->size - global.maxrewrite + ->to_forward.
-
-   Note that this also means that anyone touching ->to_forward must also take
-   care of updating the BF_FULL flag. For this reason, it's really advised to
-   use buffer_forward() only.
- */
-
-#endif /* _TYPES_BUFFERS_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/types/capture.h b/deps/haproxy-1.4.21/include/types/capture.h
deleted file mode 100644
index e37cc48..0000000
--- a/deps/haproxy-1.4.21/include/types/capture.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
-  include/types/capture.h
-  This file defines everything related to captures.
-
-  Copyright (C) 2000-2007 Willy Tarreau - w@1wt.eu
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _TYPES_CAPTURE_H
-#define _TYPES_CAPTURE_H
-
-#include <common/config.h>
-#include <common/memory.h>
-
-struct cap_hdr {
-    struct cap_hdr *next;
-    char *name;				/* header name, case insensitive */
-    int namelen;			/* length of the header name, to speed-up lookups */
-    int len;				/* capture length, not including terminal zero */
-    int index;				/* index in the output array */
-    struct pool_head *pool;		/* pool of pre-allocated memory area of (len+1) bytes */
-};
-
-extern struct pool_head *pool2_capture;
-
-#endif /* _TYPES_CAPTURE_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/types/checks.h b/deps/haproxy-1.4.21/include/types/checks.h
deleted file mode 100644
index 75e32b6..0000000
--- a/deps/haproxy-1.4.21/include/types/checks.h
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * Health-checks.
- *
- * Copyright 2008-2009 Krzysztof Piotr Oledzki <ole@ans.pl>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-/* check status */
-enum {
-	HCHK_STATUS_UNKNOWN	 = 0,	/* Unknown */
-	HCHK_STATUS_INI,		/* Initializing */
-	HCHK_STATUS_START,		/* Check started - SPECIAL STATUS */
-
-	/* Below we have finished checks */
-	HCHK_STATUS_CHECKED,		/* DUMMY STATUS */
-
-	HCHK_STATUS_HANA,		/* Healt analyze detected enough consecutive errors */
-
-	HCHK_STATUS_SOCKERR,		/* Socket error */
-
-	HCHK_STATUS_L4OK,		/* L4 check passed, for example tcp connect */
-	HCHK_STATUS_L4TOUT,		/* L4 timeout */
-	HCHK_STATUS_L4CON,		/* L4 connection problem, for example: */
-					/*  "Connection refused" (tcp rst) or "No route to host" (icmp) */
-
-	HCHK_STATUS_L6OK,		/* L6 check passed */
-	HCHK_STATUS_L6TOUT,		/* L6 (SSL) timeout */
-	HCHK_STATUS_L6RSP,		/* L6 invalid response - protocol error */
-
-	HCHK_STATUS_L7TOUT,		/* L7 (HTTP/SMTP) timeout */
-	HCHK_STATUS_L7RSP,		/* L7 invalid response - protocol error */
-
-	/* Below we have layer 5-7 data avaliable */
-	HCHK_STATUS_L57DATA,		/* DUMMY STATUS */
-	HCHK_STATUS_L7OKD,		/* L7 check passed */
-	HCHK_STATUS_L7OKCD,		/* L7 check conditionally passed */
-	HCHK_STATUS_L7STS,		/* L7 response error, for example HTTP 5xx */
-
-	HCHK_STATUS_SIZE
-};
-
-
-/* health status for response tracking */
-enum {
-	HANA_STATUS_UNKNOWN	= 0,
-
-	HANA_STATUS_L4_OK,		/* L4 successful connection */
-	HANA_STATUS_L4_ERR,		/* L4 unsuccessful connection */
-
-	HANA_STATUS_HTTP_OK,		/* Correct http response */
-	HANA_STATUS_HTTP_STS,		/* Wrong http response, for example HTTP 5xx */
-	HANA_STATUS_HTTP_HDRRSP,	/* Invalid http response (headers) */
-	HANA_STATUS_HTTP_RSP,		/* Invalid http response */
-
-	HANA_STATUS_HTTP_READ_ERROR,	/* Read error */
-	HANA_STATUS_HTTP_READ_TIMEOUT,	/* Read timeout */
-	HANA_STATUS_HTTP_BROKEN_PIPE,	/* Unexpected close from server */
-
-	HANA_STATUS_SIZE
-};
-
-enum {
-	HANA_ONERR_UNKNOWN	= 0,
-
-	HANA_ONERR_FASTINTER,		/* Force fastinter*/
-	HANA_ONERR_FAILCHK,		/* Simulate a failed check */
-	HANA_ONERR_SUDDTH,		/* Enters sudden death - one more failed check will mark this server down */
-	HANA_ONERR_MARKDWN,		/* Mark this server down, now! */
-};
-
-enum {
-	HANA_OBS_NONE		= 0,
-
-	HANA_OBS_LAYER4,		/* Observe L4 - for example tcp */
-	HANA_OBS_LAYER7,		/* Observe L7 - for example http */
-
-	HANA_OBS_SIZE
-};
-
-struct check_status {
-	short result;			/* one of SRV_CHK_* */
-	char *info;			/* human readable short info */
-	char *desc;			/* long description */
-};
-
-struct analyze_status {
-	char *desc;				/* description */
-	unsigned char lr[HANA_OBS_SIZE];	/* result for l4/l7: 0 = ignore, 1 - error, 2 - OK */
-};
diff --git a/deps/haproxy-1.4.21/include/types/counters.h b/deps/haproxy-1.4.21/include/types/counters.h
deleted file mode 100644
index 6e620e1..0000000
--- a/deps/haproxy-1.4.21/include/types/counters.h
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
-  include/types/counters.h
-  This file contains structure declarations for statistics counters.
-
-  Copyright 2008-2009 Krzysztof Piotr Oledzki <ole@ans.pl>
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _TYPES_COUNTERS_H
-#define _TYPES_COUNTERS_H
-
-struct pxcounters {
-	unsigned int feconn_max, beconn_max;	/* max # of active frontend and backend sessions */
-
-	long long cum_fe_req;			/* cumulated number of processed HTTP requests */
-	long long cum_feconn, cum_beconn;	/* cumulated number of processed sessions */
-	long long cum_lbconn;			/* cumulated number of sessions processed by load balancing */
-
-	unsigned int fe_rps_max;		/* maximum of new sessions per second seen on the frontend */
-	unsigned int fe_sps_max;		/* maximum of new sessions per second seen on the frontend */
-	unsigned int be_sps_max;		/* maximum of new sessions per second seen on the backend */
-	unsigned int nbpend_max;		/* max number of pending connections with no server assigned yet */
-
-	long long bytes_in;			/* number of bytes transferred from the client to the server */
-	long long bytes_out;			/* number of bytes transferred from the server to the client */
-
-	long long denied_req, denied_resp;	/* blocked requests/responses because of security concerns */
-	long long failed_req;			/* failed requests (eg: invalid or timeout) */
-
-	union {
-		struct {
-			long long rsp[6];	/* http response codes */
-		} http;
-	} fe, be;				/* FE and BE stats */
-
-	long long failed_conns, failed_resp;	/* failed connect() and responses */
-	long long cli_aborts, srv_aborts;	/* aborted responses during DATA phase due to client or server */
-	long long retries, redispatches;	/* retried and redispatched connections */
-};
-
-struct licounters {
-	unsigned int conn_max;			/* max # of active listener sessions */
-
-	long long cum_conn;			/* cumulated number of processed sessions */
-
-	long long bytes_in;			/* number of bytes transferred from the client to the server */
-	long long bytes_out;			/* number of bytes transferred from the server to the client */
-
-	long long denied_req, denied_resp;	/* blocked requests/responses because of security concerns */
-	long long failed_req;			/* failed requests (eg: invalid or timeout) */
-};
-
-struct srvcounters {
-	unsigned int cur_sess_max;		/* max number of currently active sessions */
-	unsigned int nbpend_max;		/* max number of pending connections reached */
-	unsigned int sps_max;			/* maximum of new sessions per second seen on this server */
-
-	long long cum_sess;			/* cumulated number of sessions really sent to this server */
-	long long cum_lbconn;			/* cumulated number of sessions directed by load balancing */
-
-	long long bytes_in;			/* number of bytes transferred from the client to the server */
-	long long bytes_out;			/* number of bytes transferred from the server to the client */
-
-	long long failed_conns, failed_resp;	/* failed connect() and responses */
-	long long cli_aborts, srv_aborts;	/* aborted responses during DATA phase due to client or server */
-	long long retries, redispatches;	/* retried and redispatched connections */
-	long long failed_secu;			/* blocked responses because of security concerns */
-
-	union {
-		struct {
-			long long rsp[6];	/* http response codes */
-		} http;
-	} p;
-
-	long long failed_checks, failed_hana;	/* failed health checks and health analyses */
-	long long down_trans;			/* up->down transitions */
-};
-
-#endif /* _TYPES_COUNTERS_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/types/fd.h b/deps/haproxy-1.4.21/include/types/fd.h
deleted file mode 100644
index f698863..0000000
--- a/deps/haproxy-1.4.21/include/types/fd.h
+++ /dev/null
@@ -1,146 +0,0 @@
-/*
- * include/types/fd.h
- * File descriptors states.
- *
- * Copyright (C) 2000-2009 Willy Tarreau - w@1wt.eu
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _TYPES_FD_H
-#define _TYPES_FD_H
-
-#include <sys/socket.h>
-#include <sys/time.h>
-#include <sys/types.h>
-#include <unistd.h>
-
-#include <common/config.h>
-#include <types/task.h>
-#include <types/protocols.h>
-
-/* different possible states for the fd */
-#define FD_STCLOSE	0
-#define FD_STLISTEN	1
-#define FD_STCONN	2
-#define FD_STREADY	3
-#define FD_STERROR	4
-
-enum {
-	DIR_RD=0,
-	DIR_WR=1,
-	DIR_SIZE
-};
-
-/*
- * FD_POLL_IN remains set as long as some data is pending for read.
- * FD_POLL_OUT remains set as long as the fd accepts to write data.
- * FD_POLL_ERR and FD_POLL_ERR remain set forever (until processed).
- */
-#define FD_POLL_IN	0x01
-#define FD_POLL_PRI	0x02
-#define FD_POLL_OUT	0x04
-#define FD_POLL_ERR	0x08
-#define FD_POLL_HUP	0x10
-
-#define FD_POLL_DATA    (FD_POLL_IN  | FD_POLL_OUT)
-#define FD_POLL_STICKY  (FD_POLL_ERR | FD_POLL_HUP)
-
-/* bit values for fdtab[fd]->flags. Most of them are used to hold a value
- * consecutive to a behaviour change.
- */
-#define FD_FL_TCP               0x0001       /* socket is TCP */
-#define FD_FL_TCP_NODELAY       0x0002
-#define FD_FL_TCP_NOLING        0x0004       /* lingering disabled */
-
-/* info about one given fd */
-struct fdtab {
-	struct {
-		int (*f)(int fd);            /* read/write function */
-		struct buffer *b;            /* read/write buffer */
-	} cb[DIR_SIZE];
-	void *owner;                         /* the session (or proxy) associated with this fd */
-	struct {                             /* used by pollers which support speculative polling */
-		unsigned char e;             /* read and write events status. 4 bits, may be merged into flags' lower bits */
-		unsigned int s1;             /* Position in spec list+1. 0=not in list. */
-	} spec;
-	unsigned short flags;                /* various flags precising the exact status of this fd */
-	unsigned char state;                 /* the state of this fd */
-	unsigned char ev;                    /* event seen in return of poll() : FD_POLL_* */
-};
-
-/* less often used information */
-struct fdinfo {
-	struct port_range *port_range;       /* optional port range to bind to */
-	int local_port;                      /* optional local port */
-	struct sockaddr *peeraddr;   /* pointer to peer's network address, or NULL if unset */
-	socklen_t peerlen;           /* peer's address length, or 0 if unset */
-};
-
-/*
- * Poller descriptors.
- *  - <name> is initialized by the poller's register() function, and should not
- *    be allocated, just linked to.
- *  - <pref> is initialized by the poller's register() function. It is set to 0
- *    by default, meaning the poller is disabled. init() should set it to 0 in
- *    case of failure. term() must set it to 0. A generic unoptimized select()
- *    poller should set it to 100.
- *  - <private> is initialized by the poller's init() function, and cleaned by
- *    the term() function.
- *  - cond_s() checks if fd was not set then sets it and returns 1. Otherwise
- *    it returns 0. It may be the same as set().
- *  - cond_c() checks if fd was set then clears it and returns 1. Otherwise
- *    it returns 0. It may be the same as clr().
- *  - clo() should be used to do indicate the poller that fd will be closed. It
- *    may be the same as rem() on some pollers.
- *  - poll() calls the poller, expiring at <exp>
- */
-struct poller {
-	void   *private;                                     /* any private data for the poller */
-	int  REGPRM2 (*is_set)(const int fd, int dir);       /* check if <fd> is being polled for dir <dir> */
-	int  REGPRM2    (*set)(const int fd, int dir);       /* set   polling on <fd> for <dir> */
-	int  REGPRM2    (*clr)(const int fd, int dir);       /* clear polling on <fd> for <dir> */
-	int  REGPRM2 (*cond_s)(const int fd, int dir);       /* set   polling on <fd> for <dir> if unset */
-	int  REGPRM2 (*cond_c)(const int fd, int dir);       /* clear polling on <fd> for <dir> if set */
-	void REGPRM1    (*rem)(const int fd);                /* remove any polling on <fd> */
-	void REGPRM1    (*clo)(const int fd);                /* mark <fd> as closed */
-    	void REGPRM2   (*poll)(struct poller *p, int exp);   /* the poller itself */
-	int  REGPRM1   (*init)(struct poller *p);            /* poller initialization */
-	void REGPRM1   (*term)(struct poller *p);            /* termination of this poller */
-	int  REGPRM1   (*test)(struct poller *p);            /* pre-init check of the poller */
-	int  REGPRM1   (*fork)(struct poller *p);            /* post-fork re-opening */
-	const char   *name;                                  /* poller name */
-	int    pref;                                         /* try pollers with higher preference first */
-};
-
-extern struct poller cur_poller; /* the current poller */
-extern int nbpollers;
-#define MAX_POLLERS	10
-extern struct poller pollers[MAX_POLLERS];   /* all registered pollers */
-
-extern struct fdtab *fdtab;             /* array of all the file descriptors */
-extern struct fdinfo *fdinfo;           /* less-often used infos for file descriptors */
-extern int maxfd;                       /* # of the highest fd + 1 */
-extern int totalconn;                   /* total # of terminated sessions */
-extern int actconn;                     /* # of active sessions */
-
-#endif /* _TYPES_FD_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/types/freq_ctr.h b/deps/haproxy-1.4.21/include/types/freq_ctr.h
deleted file mode 100644
index a8cfbd7..0000000
--- a/deps/haproxy-1.4.21/include/types/freq_ctr.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
-  include/types/freq_ctr.h
-  This file contains structure declarations for frequency counters.
-
-  Copyright (C) 2000-2009 Willy Tarreau - w@1wt.eu
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _TYPES_FREQ_CTR_H
-#define _TYPES_FREQ_CTR_H
-
-#include <common/config.h>
-
-struct freq_ctr {
-	unsigned int curr_sec; /* start date of current period (seconds from now.tv_sec) */
-	unsigned int curr_ctr; /* cumulated value for current period */
-	unsigned int prev_ctr; /* value for last period */
-};
-
-#endif /* _TYPES_FREQ_CTR_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/types/global.h b/deps/haproxy-1.4.21/include/types/global.h
deleted file mode 100644
index 7c5346b..0000000
--- a/deps/haproxy-1.4.21/include/types/global.h
+++ /dev/null
@@ -1,124 +0,0 @@
-/*
- * include/types/global.h
- * Global variables.
- *
- * Copyright (C) 2000-2010 Willy Tarreau - w@1wt.eu
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _TYPES_GLOBAL_H
-#define _TYPES_GLOBAL_H
-
-#include <netinet/in.h>
-
-#include <common/config.h>
-#include <types/log.h>
-#include <types/protocols.h>
-#include <types/proxy.h>
-#include <types/task.h>
-
-/* modes of operation (global.mode) */
-#define	MODE_DEBUG	0x01
-#define	MODE_DAEMON	0x02
-#define	MODE_QUIET	0x04
-#define	MODE_CHECK	0x08
-#define	MODE_VERBOSE	0x10
-#define	MODE_STARTING	0x20
-#define	MODE_FOREGROUND	0x40
-
-/* list of last checks to perform, depending on config options */
-#define LSTCHK_CAP_BIND	0x00000001	/* check that we can bind to any port */
-#define LSTCHK_CTTPROXY	0x00000002	/* check that tproxy is enabled */
-#define LSTCHK_NETADM	0x00000004	/* check that we have CAP_NET_ADMIN */
-
-/* Global tuning options */
-/* available polling mechanisms */
-#define GTUNE_USE_SELECT         (1<<0)
-#define GTUNE_USE_POLL           (1<<1)
-#define GTUNE_USE_EPOLL          (1<<2)
-#define GTUNE_USE_KQUEUE         (1<<3)
-#define GTUNE_USE_SEPOLL         (1<<4)
-/* platform-specific options */
-#define GTUNE_USE_SPLICE         (1<<5)
-
-/* Access level for a stats socket */
-#define ACCESS_LVL_NONE     0
-#define ACCESS_LVL_USER     1
-#define ACCESS_LVL_OPER     2
-#define ACCESS_LVL_ADMIN    3
-
-/* FIXME : this will have to be redefined correctly */
-struct global {
-	int uid;
-	int gid;
-	int nbproc;
-	int maxconn;
-	int maxpipes;		/* max # of pipes */
-	int maxsock;		/* max # of sockets */
-	int rlimit_nofile;	/* default ulimit-n value : 0=unset */
-	int rlimit_memmax;	/* default ulimit-d in megs value : 0=unset */
-	int mode;
-	int last_checks;
-	int spread_checks;
-	char *chroot;
-	char *pidfile;
-	char *node, *desc;		/* node name & description */
-	char *log_tag;                  /* name for syslog */
-	int logfac1, logfac2;
-	int loglev1, loglev2;
-	int minlvl1, minlvl2;
-	struct logsrv logsrv1, logsrv2;
-	char *log_send_hostname;   /* set hostname in syslog header */
-	struct {
-		int maxpollevents; /* max number of poll events at once */
-		int maxaccept;     /* max number of consecutive accept() */
-		int options;       /* various tuning options */
-		int recv_enough;   /* how many input bytes at once are "enough" */
-		int bufsize;       /* buffer size in bytes, defaults to BUFSIZE */
-		int maxrewrite;    /* buffer max rewrite size in bytes, defaults to MAXREWRITE */
-		int client_sndbuf; /* set client sndbuf to this value if not null */
-		int client_rcvbuf; /* set client rcvbuf to this value if not null */
-		int server_sndbuf; /* set server sndbuf to this value if not null */
-		int server_rcvbuf; /* set server rcvbuf to this value if not null */
-		int chksize;       /* check buffer size in bytes, defaults to BUFSIZE */
-	} tune;
-	struct listener stats_sock; /* unix socket listener for statistics */
-	struct proxy *stats_fe;     /* the frontend holding the stats settings */
-};
-
-extern struct global global;
-extern int  pid;                /* current process id */
-extern int  relative_pid;       /* process id starting at 1 */
-extern int  actconn;            /* # of active sessions */
-extern int listeners;
-extern char *trash;
-extern int  trashlen;
-extern char *swap_buffer;
-extern int nb_oldpids;          /* contains the number of old pids found */
-extern const int zero;
-extern const int one;
-extern const struct linger nolinger;
-extern int stopping;	/* non zero means stopping in progress */
-extern char hostname[MAX_HOSTNAME_LEN];
-
-#endif /* _TYPES_GLOBAL_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/types/hdr_idx.h b/deps/haproxy-1.4.21/include/types/hdr_idx.h
deleted file mode 100644
index 809ea83..0000000
--- a/deps/haproxy-1.4.21/include/types/hdr_idx.h
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
-  include/types/hdr_idx.h
-  This file defines everything related to fast header indexation.
-
-  Copyright (C) 2000-2006 Willy Tarreau - w@1wt.eu
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-
-/*
- * The type of structure described here is a finite linked list used to
- * reference small number of objects of small size. This is typically used
- * to index HTTP headers within one request or response, in order to be able
- * to add, remove, modify and check them in an efficient way. The overhead is
- * very low : 32 bits are used per list element. This is enough to reference
- * 32k headers of at most 64kB each, with one bit to indicate if the header
- * is terminated by 1 or 2 chars. It may also evolve towards something like
- * 1k headers of at most 64B for the name and 32kB of data + CR/CRLF.
- *
- * A future evolution of this concept may allow for fast header manipulation
- * without data movement through the use of vectors. This is not yet possible
- * in this version, whose goal is only to avoid parsing whole lines for each
- * consultation.
- *
- */
-
-
-#ifndef _TYPES_HDR_IDX_H
-#define _TYPES_HDR_IDX_H
-
-/*
- * This describes one element of the hdr_idx array.
- * It's a tiny linked list of at most 32k 32bit elements. The first one has a
- * special meaning, it's used as the head of the list and cannod be removed.
- * That way, we know that 'next==0' is not possible so we use it to indicate
- * an end of list. Also, [0]->next always designates the head of the list. The
- * first allocatable element is at 1. By convention, [0]->len indicates how
- * many chars should be skipped in the original buffer before finding the first
- * header.
- *
- */
-
-struct hdr_idx_elem {
-        unsigned len  :16; /* length of this header not counting CRLF. 0=unused entry. */
-        unsigned cr   : 1; /* CR present (1=CRLF, 0=LF). Total line size=len+cr+1. */
-        unsigned next :15; /* offset of next header if len>0. 0=end of list. */
-};
-
-/*
- * This structure provides necessary information to store, find, remove
- * index entries from a list. This list cannot reference more than 32k
- * elements of 64k each.
- */
-struct hdr_idx {
-	struct hdr_idx_elem *v;     /* the array itself */
-	short size;                 /* size of the array including the head */
-	short used;                 /* # of elements really used (1..size) */
-	short last;                 /* length of the allocated area (1..size) */
-	signed short tail;          /* last used element, 0..size-1 */
-};
-
-
-
-#endif /* _TYPES_HDR_IDX_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/types/httperr.h b/deps/haproxy-1.4.21/include/types/httperr.h
deleted file mode 100644
index b5cd489..0000000
--- a/deps/haproxy-1.4.21/include/types/httperr.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
-  include/types/httperr.h
-  This file defines everything related to HTTP responses and errors.
-
-  Copyright (C) 2000-2006 Willy Tarreau - w@1wt.eu
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _TYPES_HTTPERR_H
-#define _TYPES_HTTPERR_H
-
-#include <common/config.h>
-
-/*
- * All implemented return codes
- */
-enum {
-	HTTP_ERR_200 = 0,
-	HTTP_ERR_400,
-	HTTP_ERR_403,
-	HTTP_ERR_408,
-	HTTP_ERR_500,
-	HTTP_ERR_502,
-	HTTP_ERR_503,
-	HTTP_ERR_504,
-	HTTP_ERR_SIZE
-};
-
-
-#endif /* _TYPES_HTTPERR_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/types/lb_chash.h b/deps/haproxy-1.4.21/include/types/lb_chash.h
deleted file mode 100644
index 5991ce9..0000000
--- a/deps/haproxy-1.4.21/include/types/lb_chash.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * include/types/lb_chash.h
- * Types for Consistent Hash LB algorithm.
- *
- * Copyright (C) 2000-2009 Willy Tarreau - w@1wt.eu
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _TYPES_LB_CHASH_H
-#define _TYPES_LB_CHASH_H
-
-#include <common/config.h>
-#include <ebtree.h>
-#include <eb32tree.h>
-
-struct lb_chash {
-	struct eb_root act;	/* weighted chash entries of active servers */
-	struct eb_root bck;	/* weighted chash entries of backup servers */
-	struct eb32_node *last;	/* last node found in case of round robin (or NULL) */
-};
-
-#endif /* _TYPES_LB_CHASH_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/types/lb_fwlc.h b/deps/haproxy-1.4.21/include/types/lb_fwlc.h
deleted file mode 100644
index 170eb24..0000000
--- a/deps/haproxy-1.4.21/include/types/lb_fwlc.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * include/types/lb_fwlc.h
- * Types for Fast Weighted Least Connection load balancing algorithm.
- *
- * Copyright (C) 2000-2009 Willy Tarreau - w@1wt.eu
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _TYPES_LB_FWLC_H
-#define _TYPES_LB_FWLC_H
-
-#include <common/config.h>
-#include <ebtree.h>
-
-struct lb_fwlc {
-	struct eb_root act;	/* weighted least conns on the active servers */
-	struct eb_root bck;	/* weighted least conns on the backup servers */
-};
-
-#endif /* _TYPES_LB_FWLC_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/types/lb_fwrr.h b/deps/haproxy-1.4.21/include/types/lb_fwrr.h
deleted file mode 100644
index 731f055..0000000
--- a/deps/haproxy-1.4.21/include/types/lb_fwrr.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * include/types/lb_fwrr.h
- * Types for Fast Weighted Round Robin load balancing algorithm.
- *
- * Copyright (C) 2000-2009 Willy Tarreau - w@1wt.eu
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _TYPES_LB_FWRR_H
-#define _TYPES_LB_FWRR_H
-
-#include <common/config.h>
-#include <ebtree.h>
-
-/* This structure is used to apply fast weighted round robin on a server group */
-struct fwrr_group {
-	struct eb_root curr;    /* tree for servers in "current" time range */
-	struct eb_root t0, t1;  /* "init" and "next" servers */
-	struct eb_root *init;   /* servers waiting to be placed */
-	struct eb_root *next;   /* servers to be placed at next run */
-	int curr_pos;           /* current position in the tree */
-	int curr_weight;        /* total weight of the current time range */
-	int next_weight;        /* total weight of the next time range */
-};
-
-struct lb_fwrr {
-	struct fwrr_group act;	/* weighted round robin on the active servers */
-	struct fwrr_group bck;	/* weighted round robin on the backup servers */
-};
-
-#endif /* _TYPES_LB_FWRR_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/types/lb_map.h b/deps/haproxy-1.4.21/include/types/lb_map.h
deleted file mode 100644
index 4c12089..0000000
--- a/deps/haproxy-1.4.21/include/types/lb_map.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * include/types/lb_map.h
- * Types for map-based load-balancing (RR and HASH)
- *
- * Copyright (C) 2000-2009 Willy Tarreau - w@1wt.eu
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _TYPES_LB_MAP_H
-#define _TYPES_LB_MAP_H
-
-#include <common/config.h>
-#include <types/server.h>
-
-/* values for map.state */
-#define LB_MAP_RECALC  (1 << 0)
-
-struct lb_map {
-	struct server **srv;	/* the server map used to apply weights */
-	int rr_idx;		/* next server to be elected in round robin mode */
-	int state;		/* LB_MAP_RECALC */
-};
-
-#endif /* _TYPES_LB_MAP_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/types/log.h b/deps/haproxy-1.4.21/include/types/log.h
deleted file mode 100644
index 3281c3c..0000000
--- a/deps/haproxy-1.4.21/include/types/log.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
-  include/types/log.h
-  This file contains definitions of log-related structures and macros.
-
-  Copyright (C) 2000-2006 Willy Tarreau - w@1wt.eu
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _TYPES_LOG_H
-#define _TYPES_LOG_H
-
-#include <sys/socket.h>
-#include <sys/un.h>
-#include <netinet/in.h>
-#include <common/config.h>
-
-#define MAX_SYSLOG_LEN          1024
-#define NB_LOG_FACILITIES       24
-#define NB_LOG_LEVELS           8
-#define SYSLOG_PORT             514
-
-
-/* fields that need to be logged. They appear as flags in session->logs.logwait */
-#define LW_DATE		1	/* date */
-#define LW_CLIP		2	/* CLient IP */
-#define LW_SVIP		4	/* SerVer IP */
-#define LW_SVID		8	/* server ID */
-#define	LW_REQ		16	/* http REQuest */
-#define LW_RESP		32	/* http RESPonse */
-#define LW_PXIP		64	/* proxy IP */
-#define LW_PXID		128	/* proxy ID */
-#define LW_BYTES	256	/* bytes read from server */
-#define LW_COOKIE	512	/* captured cookie */
-#define LW_REQHDR	1024	/* request header(s) */
-#define LW_RSPHDR	2048	/* response header(s) */
-
-struct logsrv {
-	union {
-		struct sockaddr addr;
-		struct sockaddr_un un;	/* AF_UNIX */
-		struct sockaddr_in in;	/* AF_INET */
-	} u;
-};
-
-#endif /* _TYPES_LOG_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/types/pattern.h b/deps/haproxy-1.4.21/include/types/pattern.h
deleted file mode 100644
index 01fb69c..0000000
--- a/deps/haproxy-1.4.21/include/types/pattern.h
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * include/types/pattern.h
- * Macros, variables and structures for patterns management.
- *
- * Copyright (C) 2009-2010 EXCELIANCE, Emeric Brun <ebrun@exceliance.fr>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _TYPES_PATTERN_H
-#define _TYPES_PATTERN_H
-
-#include <types/buffers.h>
-#include <sys/socket.h>
-#include <netinet/in.h>
-
-/* pattern in and out types */
-enum {
-	PATTERN_TYPE_IP      = 0,  /* ipv4 type */
-	PATTERN_TYPE_INTEGER = 1,  /* unsigned 32bits integer type */
-	PATTERN_TYPE_STRING  = 2,  /* char string type */
-	PATTERN_TYPES
-};
-
-/* pattern fetch direction */
-#define PATTERN_FETCH_REQ	1
-#define PATTERN_FETCH_RTR	2
-
-/* pattern result data */
-union pattern_data {
-	struct in_addr ip; /* used for ipv4 type */
-	uint32_t integer;  /* used for unsigned 32bits integer type */
-	struct chunk str;  /* used for char string type */
-};
-
-/* pattern result */
-struct pattern {
-	int type;                 /* current type of data */
-	union pattern_data data;  /* data */
-};
-
-/* pattern conversion */
-struct pattern_conv {
-	const char *kw;                           /* configuration keyword  */
-	int (*process)(const void *arg_p,
-	               int arg_i,
-	               union pattern_data *data); /* process function */
-	unsigned int in_type;                     /* input needed pattern type */
-	unsigned int out_type;                    /* output pattern type */
-	int (*parse_args)(const char *arg_str,
-			  void **arg_p,
-			  int *arg_i);            /* argument parser. Can be NULL. */
-};
-
-/* pattern conversion expression */
-struct pattern_conv_expr {
-	struct list list;                         /* member of a pattern expression */
-	struct pattern_conv *conv;                /* pattern conversion */
-	void *arg_p;                              /* pointer arg, most often a string argument */
-	int arg_i;                                /* int arg, most often the argument's length */
-};
-
-/* pattern fetch */
-struct pattern_fetch {
-	const char *kw;                           /* configuration keyword */
-	int (*process)(struct proxy *px,
-	               struct session *l4,
-	               void *l7,
-	               int dir, const char *arg,
-	               int arg_len,
-	               union pattern_data *data); /* fetch processing function */
-	unsigned long out_type;                   /* output pattern type */
-	int dir;                                  /* usable directions */
-};
-
-/* pattern expression */
-struct pattern_expr {
-	struct list list;                         /* member of list of pattern, currently not used */
-	struct pattern_fetch *fetch;              /* pattern fetch */
-	char *arg;                                /* configured keyword argument */
-	int arg_len;                              /* configured keyword argument length */
-	struct list conv_exprs;                   /* list of conversion expression to apply */
-};
-
-/* pattern fetch keywords list */
-struct pattern_fetch_kw_list {
-	struct list list;                         /* head of pattern fetch keyword list */
-	struct pattern_fetch kw[VAR_ARRAY];       /* array of pattern fetches */
-};
-
-/* pattern conversion keywords list */
-struct pattern_conv_kw_list {
-	struct list list;                         /* head of pattern conversion keyword list */
-	struct pattern_conv kw[VAR_ARRAY];        /* array of pattern ions */
-};
-
-#endif /* _TYPES_PATTERN_H */
diff --git a/deps/haproxy-1.4.21/include/types/pipe.h b/deps/haproxy-1.4.21/include/types/pipe.h
deleted file mode 100644
index 12a1eee..0000000
--- a/deps/haproxy-1.4.21/include/types/pipe.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
-  include/types/pipe.h
-  Pipe management.
-
-  Copyright (C) 2000-2009 Willy Tarreau - w@1wt.eu
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _TYPES_PIPE_H
-#define _TYPES_PIPE_H
-
-#include <common/config.h>
-
-/* A pipe is described by its read and write FDs, and the data remaining in it.
- * The FDs are valid if there are data pending. The user is not allowed to
- * change the FDs.
- */
-struct pipe {
-	int data;	/* number of bytes present in the pipe  */
-	int prod;	/* FD the producer must write to ; -1 if none */
-	int cons;	/* FD the consumer must read from ; -1 if none */
-	struct pipe *next;
-};
-
-#endif /* _TYPES_PIPE_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/types/port_range.h b/deps/haproxy-1.4.21/include/types/port_range.h
deleted file mode 100644
index 1d010f7..0000000
--- a/deps/haproxy-1.4.21/include/types/port_range.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
-  include/types/port_range.h
-  This file defines everything needed to manage port ranges
-
-  Copyright (C) 2000-2009 Willy Tarreau - w@1wt.eu
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _TYPES_PORT_RANGE_H
-#define _TYPES_PORT_RANGE_H
-
-#include <netinet/in.h>
-
-struct port_range {
-	int size, get, put;		/* range size, and get/put positions */
-	int avail;			/* number of available ports left */
-	uint16_t ports[0];		/* array of <size> ports, in host byte order */
-};
-
-#endif /* _TYPES_PORT_RANGE_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/types/proto_http.h b/deps/haproxy-1.4.21/include/types/proto_http.h
deleted file mode 100644
index 7e52124..0000000
--- a/deps/haproxy-1.4.21/include/types/proto_http.h
+++ /dev/null
@@ -1,367 +0,0 @@
-/*
- * include/types/proto_http.h
- * This file contains HTTP protocol definitions.
- *
- * Copyright (C) 2000-2010 Willy Tarreau - w@1wt.eu
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _TYPES_PROTO_HTTP_H
-#define _TYPES_PROTO_HTTP_H
-
-#include <common/config.h>
-
-#include <types/buffers.h>
-#include <types/hdr_idx.h>
-
-/* These are the flags that are found in txn->flags */
-
-/* action flags */
-#define TX_CLDENY	0x00000001	/* a client header matches a deny regex */
-#define TX_CLALLOW	0x00000002	/* a client header matches an allow regex */
-#define TX_SVDENY	0x00000004	/* a server header matches a deny regex */
-#define TX_SVALLOW	0x00000008	/* a server header matches an allow regex */
-#define TX_CLTARPIT	0x00000010	/* the session is tarpitted (anti-dos) */
-
-/* transaction flags dedicated to cookies : bits values 0x20 to 0x80 (0-7 shift 5) */
-#define TX_CK_NONE	0x00000000	/* this session had no cookie */
-#define TX_CK_INVALID	0x00000020	/* this session had a cookie which matches no server */
-#define TX_CK_DOWN	0x00000040	/* this session had cookie matching a down server */
-#define TX_CK_VALID	0x00000060	/* this session had cookie matching a valid server */
-#define TX_CK_EXPIRED	0x00000080	/* this session had an expired cookie (idle for too long) */
-#define TX_CK_OLD	0x000000A0	/* this session had too old a cookie (offered too long ago) */
-#define TX_CK_MASK	0x000000E0	/* mask to get this session's cookie flags */
-#define TX_CK_SHIFT	5		/* bit shift */
-
-/* response cookie information, bits values 0x100 to 0x700 (0-7 shift 8) */
-#define TX_SCK_NONE	0x00000000	/* no cookie found in the response */
-#define TX_SCK_FOUND    0x00000100	/* a persistence cookie was found and forwarded */
-#define TX_SCK_DELETED	0x00000200	/* an existing persistence cookie was deleted */
-#define TX_SCK_INSERTED	0x00000300	/* a persistence cookie was inserted */
-#define TX_SCK_REPLACED	0x00000400	/* a persistence cookie was present and rewritten */
-#define TX_SCK_UPDATED	0x00000500	/* an expirable persistence cookie was updated */
-#define TX_SCK_MASK	0x00000700	/* mask to get the set-cookie field */
-#define TX_SCK_SHIFT	8		/* bit shift */
-
-#define TX_SCK_PRESENT  0x00000800	/* a cookie was found in the server's response */
-
-/* cacheability management, bits values 0x1000 to 0x3000 (0-3 shift 12) */
-#define TX_CACHEABLE	0x00001000	/* at least part of the response is cacheable */
-#define TX_CACHE_COOK	0x00002000	/* a cookie in the response is cacheable */
-#define TX_CACHE_SHIFT	12		/* bit shift */
-
-/* request and response HTTP version */
-#define TX_REQ_VER_11	0x00004000	/* the request is HTTP/1.1 or above */
-#define TX_RES_VER_11	0x00008000	/* the response is HTTP/1.1 or above */
-
-/* report presence of transfer-encoding:chunked and content-length headers */
-#define TX_REQ_CNT_LEN	0x00010000	/* content-length present in the request */
-#define TX_REQ_TE_CHNK	0x00020000	/* transfer-encoding: chunked present in the request */
-#define TX_RES_CNT_LEN	0x00040000	/* content-length present in the response */
-#define TX_RES_TE_CHNK	0x00080000	/* transfer-encoding: chunked present in the response */
-
-/* indicate how we *want* the connection to behave, regardless of what is in
- * the headers. We have 4 possible values right now :
- * - WANT_TUN : will be a tunnel (default when nothing configured or with CONNECT).
- * - WANT_KAL : try to maintain keep-alive
- * - WANT_SCL : enforce close on the server side
- * - WANT_CLO : enforce close on both sides
- */
-#define TX_CON_WANT_TUN 0x00000000	/* note: it's important that it is 0 (init) */
-#define TX_CON_WANT_KAL 0x00100000
-#define TX_CON_WANT_SCL 0x00200000
-#define TX_CON_WANT_CLO 0x00300000
-#define TX_CON_WANT_MSK 0x00300000	/* this is the mask to get the bits */
-
-#define TX_CON_CLO_SET  0x00400000	/* "connection: close" is now set */
-#define TX_CON_KAL_SET  0x00800000	/* "connection: keep-alive" is now set */
-
-/* if either of these flags is not set, we may be forced to complete an
- * connection as a half-way tunnel. For instance, if no content-length
- * appears in a 1.1 response, but the request is correctly sized.
- */
-#define TX_REQ_XFER_LEN	0x01000000	/* request xfer size can be determined */
-#define TX_RES_XFER_LEN	0x02000000	/* response xfer size can be determined */
-#define TX_WAIT_NEXT_RQ	0x04000000	/* waiting for the second request to start, use keep-alive timeout */
-
-#define TX_HDR_CONN_PRS	0x08000000	/* "connection" header already parsed (req or res), results below */
-#define TX_HDR_CONN_CLO	0x10000000	/* "Connection: close" was present at least once */
-#define TX_HDR_CONN_KAL	0x20000000	/* "Connection: keep-alive" was present at least once */
-#define TX_USE_PX_CONN	0x40000000	/* Use "Proxy-Connection" instead of "Connection" */
-
-/* used only for keep-alive purposes, to indicate we're on a second transaction */
-#define TX_NOT_FIRST	0x80000000	/* the transaction is not the first one */
-/* no more room for transaction flags ! */
-
-/* The HTTP parser is more complex than it looks like, because we have to
- * support multi-line headers and any number of spaces between the colon and
- * the value.
- *
- * All those examples must work :
-
- Hdr1:val1\r\n
- Hdr1: val1\r\n
- Hdr1:\t val1\r\n
- Hdr1: \r\n
-  val1\r\n
- Hdr1:\r\n
-  val1\n
- \tval2\r\n
-  val3\n
-
- *
- */
-
-/* Possible states while parsing HTTP messages (request|response) */
-#define HTTP_MSG_RQBEFORE      0 // request: leading LF, before start line
-#define HTTP_MSG_RQBEFORE_CR   1 // request: leading CRLF, before start line
-
-/* these ones define a request start line */
-#define HTTP_MSG_RQMETH        2 // parsing the Method
-#define HTTP_MSG_RQMETH_SP     3 // space(s) after the ethod
-#define HTTP_MSG_RQURI         4 // parsing the Request URI
-#define HTTP_MSG_RQURI_SP      5 // space(s) after the Request URI
-#define HTTP_MSG_RQVER         6 // parsing the Request Version
-#define HTTP_MSG_RQLINE_END    7 // end of request line (CR or LF)
-
-#define HTTP_MSG_RPBEFORE      8 // response: leading LF, before start line
-#define HTTP_MSG_RPBEFORE_CR   9 // response: leading CRLF, before start line
-
-/* these ones define a response start line */
-#define HTTP_MSG_RPVER        10 // parsing the Response Version
-#define HTTP_MSG_RPVER_SP     11 // space(s) after the Response Version
-#define HTTP_MSG_RPCODE       12 // response code
-#define HTTP_MSG_RPCODE_SP    13 // space(s) after the response code
-#define HTTP_MSG_RPREASON     14 // response reason
-#define HTTP_MSG_RPLINE_END   15 // end of response line (CR or LF)
-
-/* common header processing */
-
-#define HTTP_MSG_HDR_FIRST    16 // waiting for first header or last CRLF (no LWS possible)
-#define HTTP_MSG_HDR_NAME     17 // parsing header name
-#define HTTP_MSG_HDR_COL      18 // parsing header colon
-#define HTTP_MSG_HDR_L1_SP    19 // parsing header LWS (SP|HT) before value
-#define HTTP_MSG_HDR_L1_LF    20 // parsing header LWS (LF) before value
-#define HTTP_MSG_HDR_L1_LWS   21 // checking whether it's a new header or an LWS
-#define HTTP_MSG_HDR_VAL      22 // parsing header value
-#define HTTP_MSG_HDR_L2_LF    23 // parsing header LWS (LF) inside/after value
-#define HTTP_MSG_HDR_L2_LWS   24 // checking whether it's a new header or an LWS
-
-#define HTTP_MSG_LAST_LF      25 // parsing last LF
-
-/* error state : must be before HTTP_MSG_BODY so that (>=BODY) always indicates
- * that data are being processed.
- */
-
-#define HTTP_MSG_ERROR        26 // an error occurred
-
-/* Body processing.
- * The state HTTP_MSG_BODY is a delimiter to know if we're waiting for headers
- * or body. All the sub-states below also indicate we're processing the body,
- * with some additional information.
- */
-#define HTTP_MSG_BODY         27 // parsing body at end of headers
-#define HTTP_MSG_100_SENT     28 // parsing body after a 100-Continue was sent
-#define HTTP_MSG_CHUNK_SIZE   29 // parsing the chunk size (RFC2616 #3.6.1)
-#define HTTP_MSG_DATA         30 // skipping data chunk / content-length data
-#define HTTP_MSG_DATA_CRLF    31 // skipping CRLF after data chunk
-#define HTTP_MSG_TRAILERS     32 // trailers (post-data entity headers)
-
-/* we enter this state when we've received the end of the current message */
-#define HTTP_MSG_DONE         33 // message end received, waiting for resync or close
-#define HTTP_MSG_CLOSING      34 // shutdown_w done, not all bytes sent yet
-#define HTTP_MSG_CLOSED       35 // shutdown_w done, all bytes sent
-#define HTTP_MSG_TUNNEL       36 // tunneled data after DONE
-
-/* various data sources for the responses */
-#define DATA_SRC_NONE	0
-#define DATA_SRC_STATS	1
-
-/* data transmission states for the stats responses */
-enum {
-	DATA_ST_INIT = 0,
-	DATA_ST_HEAD,
-	DATA_ST_INFO,
-	DATA_ST_LIST,
-	DATA_ST_END,
-	DATA_ST_FIN,
-};
-
-/* data transmission states for the stats responses inside a proxy */
-enum {
-	DATA_ST_PX_INIT = 0,
-	DATA_ST_PX_TH,
-	DATA_ST_PX_FE,
-	DATA_ST_PX_LI,
-	DATA_ST_PX_SV,
-	DATA_ST_PX_BE,
-	DATA_ST_PX_END,
-	DATA_ST_PX_FIN,
-};
-
-/* Redirect flags */
-enum {
-	REDIRECT_FLAG_NONE = 0,
-	REDIRECT_FLAG_DROP_QS = 1,	/* drop query string */
-	REDIRECT_FLAG_APPEND_SLASH = 2,	/* append a slash if missing at the end */
-};
-
-/* Redirect types (location, prefix, extended ) */
-enum {
-	REDIRECT_TYPE_NONE = 0,         /* no redirection */
-	REDIRECT_TYPE_LOCATION,         /* location redirect */
-	REDIRECT_TYPE_PREFIX,           /* prefix redirect */
-};
-
-/* Perist types (force-persist, ignore-persist) */
-enum {
-	PERSIST_TYPE_NONE = 0,          /* no persistence */
-	PERSIST_TYPE_FORCE,             /* force-persist */
-	PERSIST_TYPE_IGNORE,            /* ignore-persist */
-};
-
-/* Known HTTP methods */
-typedef enum {
-	HTTP_METH_NONE = 0,
-	HTTP_METH_OPTIONS,
-	HTTP_METH_GET,
-	HTTP_METH_HEAD,
-	HTTP_METH_POST,
-	HTTP_METH_PUT,
-	HTTP_METH_DELETE,
-	HTTP_METH_TRACE,
-	HTTP_METH_CONNECT,
-	HTTP_METH_OTHER,
-} http_meth_t;
-
-enum {
-	HTTP_AUTH_WRONG		= -1,		/* missing or unknown */
-	HTTP_AUTH_UNKNOWN	= 0,
-	HTTP_AUTH_BASIC,
-	HTTP_AUTH_DIGEST,
-};
-
-/* Actions available for the stats admin forms */
-enum {
-	ST_ADM_ACTION_NONE = 0,
-	ST_ADM_ACTION_DISABLE,
-	ST_ADM_ACTION_ENABLE,
-};
-
-/* This is an HTTP message, as described in RFC2616. It can be either a request
- * message or a response message.
- *
- * The values there are a little bit obscure, because their meaning can change
- * during the parsing :
- *
- *  - som (Start of Message) : relative offset in the buffer of first byte of
- *                             the request being processed or parsed. Reset to
- *                             zero during accept(), and changes while parsing
- *                             chunks.
- *  - eoh (End of Headers)   : relative offset in the buffer of first byte that
- *                             is not part of a completely processed header.
- *                             During parsing, it points to last header seen
- *                             for states after START. When in HTTP_MSG_BODY,
- *                             eoh points to the first byte of the last CRLF
- *                             preceeding data.
- *  - col and sov            : When in HTTP_MSG_BODY, will point to the first
- *                             byte of data (relative to buffer).
- *  - sol (start of line)    : start of line, also start of message when fully parsed.
- *  - eol (End of Line)      : relative offset in the buffer of the first byte
- *                             which marks the end of the line (LF or CRLF).
- * Note that all offsets are relative to the beginning of the buffer. To get
- * them relative to the current request, subtract ->som or ->sol.
- */
-struct http_msg {
-	unsigned int msg_state;                /* where we are in the current message parsing */
-	unsigned int col, sov;                 /* current header: colon, start of value */
-	unsigned int eoh;                      /* End Of Headers, relative to buffer */
-	char *sol;                             /* start of line, also start of message when fully parsed */
-	char *eol;                             /* end of line */
-	unsigned int som;                      /* Start Of Message, relative to buffer */
-	int err_pos;                           /* err handling: -2=block, -1=pass, 0+=detected */
-	union {                                /* useful start line pointers, relative to ->sol */
-		struct {
-			int l;                 /* request line length (not including CR) */
-			int m_l;               /* METHOD length (method starts at ->som) */
-			int u, u_l;            /* URI, length */
-			int v, v_l;            /* VERSION, length */
-		} rq;                          /* request line : field, length */
-		struct {
-			int l;                 /* status line length (not including CR) */
-			int v_l;               /* VERSION length (version starts at ->som) */
-			int c, c_l;            /* CODE, length */
-			int r, r_l;            /* REASON, length */
-		} st;                          /* status line : field, length */
-	} sl;                                  /* start line */
-	unsigned long long chunk_len;          /* cache for last chunk size or content-length header value */
-	unsigned long long body_len;           /* total known length of the body, excluding encoding */
-	char **cap;                            /* array of captured headers (may be NULL) */
-};
-
-struct http_auth_data {
-	int method;			/* one of HTTP_AUTH_* */
-	struct chunk method_data;	/* points to the creditial part from 'Authorization:' header */
-	char *user, *pass;		/* extracted username & password */
-};
-
-/* This is an HTTP transaction. It contains both a request message and a
- * response message (which can be empty).
- */
-struct http_txn {
-	struct http_msg req;            /* HTTP request message */
-	struct hdr_idx hdr_idx;         /* array of header indexes (max: MAX_HTTP_HDR) */
-	unsigned int flags;             /* transaction flags */
-	http_meth_t meth;               /* HTTP method */
-
-	int status;                     /* HTTP status from the server, negative if from proxy */
-	struct http_msg rsp;            /* HTTP response message */
-
-	char *uri;                      /* first line if log needed, NULL otherwise */
-	char *cli_cookie;               /* cookie presented by the client, in capture mode */
-	char *srv_cookie;               /* cookie presented by the server, in capture mode */
-	char *sessid;                   /* the appsession id, if found in the request or in the response */
-	int cookie_first_date;          /* if non-zero, first date the expirable cookie was set/seen */
-	int cookie_last_date;           /* if non-zero, last date the expirable cookie was set/seen */
-
-	struct http_auth_data auth;	/* HTTP auth data */
-};
-
-/* This structure is used by http_find_header() to return values of headers.
- * The header starts at <line>, the value (excluding leading and trailing white
- * spaces) at <line>+<val> for <vlen> bytes, followed by optional <tws> trailing
- * white spaces, and sets <line>+<del> to point to the last delimitor (colon or
- * comma) before this value. <prev> points to the index of the header whose next
- * is this one.
- */
-struct hdr_ctx {
-	char *line;
-	int  idx;
-	int  val;  /* relative to line, may skip some leading white spaces */
-	int  vlen; /* relative to line+val, stops before trailing white spaces */
-	int  tws;  /* added to vlen if some trailing white spaces are present */
-	int  del;  /* relative to line */
-	int  prev; /* index of previous header */
-};
-
-#endif /* _TYPES_PROTO_HTTP_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/types/proto_tcp.h b/deps/haproxy-1.4.21/include/types/proto_tcp.h
deleted file mode 100644
index 54d12a7..0000000
--- a/deps/haproxy-1.4.21/include/types/proto_tcp.h
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
-  include/types/proto_tcp.h
-  This file contains TCP protocol definitions.
-
-  Copyright (C) 2000-2008 Willy Tarreau - w@1wt.eu
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _TYPES_PROTO_TCP_H
-#define _TYPES_PROTO_TCP_H
-
-#include <common/config.h>
-#include <common/mini-clist.h>
-
-#include <types/acl.h>
-
-/* Layer4 accept/reject rules */
-enum {
-	TCP_ACT_ACCEPT = 1,
-	TCP_ACT_REJECT = 2,
-};
-
-struct tcp_rule {
-	struct list list;
-	struct acl_cond *cond;
-	int action;
-};
-
-#endif /* _TYPES_PROTO_TCP_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/types/protocols.h b/deps/haproxy-1.4.21/include/types/protocols.h
deleted file mode 100644
index ed0d403..0000000
--- a/deps/haproxy-1.4.21/include/types/protocols.h
+++ /dev/null
@@ -1,151 +0,0 @@
-/*
-  include/types/protocols.h
-  This file defines the structures used by generic network protocols.
-
-  Copyright (C) 2000-2009 Willy Tarreau - w@1wt.eu
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _TYPES_PROTOCOLS_H
-#define _TYPES_PROTOCOLS_H
-
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <sys/stat.h>
-#include <sys/un.h>
-
-#include <common/config.h>
-#include <common/mini-clist.h>
-#include <eb32tree.h>
-
-#include <types/counters.h>
-#include <types/task.h>
-
-/* max length of a protcol name, including trailing zero */
-#define PROTO_NAME_LEN 16
-
-/* listener state */
-#define LI_NEW		0	/* not initialized yet */
-#define LI_INIT		1	/* all parameters filled in, but not assigned yet */
-#define LI_ASSIGNED	2	/* assigned to the protocol, but not listening yet */
-#define LI_LISTEN	3	/* started, listening but not enabled */
-#define LI_READY	4	/* started, listening and enabled */
-#define LI_FULL		5	/* reached its connection limit */
-
-/* Listener transitions
- * calloc()     set()      add_listener()       bind()
- * -------> NEW ----> INIT ----------> ASSIGNED -----> LISTEN
- * <-------     <----      <----------          <-----
- *    free()   bzero()     del_listener()       unbind()
- *
- * The file descriptor is valid only during these three states :
- *
- *             disable()
- * LISTEN <------------ READY
- *   A|   ------------>  |A
- *   ||  !max & enable() ||
- *   ||                  ||
- *   ||              max ||
- *   || max & enable()   V| !max
- *   |+---------------> FULL
- *   +-----------------
- *            disable()
- *
- */
-
-/* listener socket options */
-#define LI_O_NONE	0x0000
-#define LI_O_NOLINGER	0x0001	/* disable linger on this socket */
-#define LI_O_FOREIGN	0x0002	/* permit listening on foreing addresses */
-#define LI_O_NOQUICKACK	0x0004	/* disable quick ack of immediate data (linux) */
-#define LI_O_DEF_ACCEPT	0x0008	/* wait up to 1 second for data before accepting */
-#define LI_O_ACC_PROXY  0x0010  /* find the proxied address in the first request line */
-
-/* The listener will be directly referenced by the fdtab[] which holds its
- * socket. The listener provides the protocol-specific accept() function to
- * the fdtab.
- */
-struct listener {
-	int fd;				/* the listen socket */
-	char *name;			/* */
-	int luid;			/* listener universally unique ID, used for SNMP */
-	int state;			/* state: NEW, INIT, ASSIGNED, LISTEN, READY, FULL */
-	int options;			/* socket options : LI_O_* */
-	struct licounters *counters;	/* statistics counters */
-	struct sockaddr_storage addr;	/* the address we listen to */
-	struct protocol *proto;		/* protocol this listener belongs to */
-	int nbconn;			/* current number of connections on this listener */
-	int maxconn;			/* maximum connections allowed on this listener */
-	unsigned int backlog;		/* if set, listen backlog */
-	struct listener *next;		/* next address for the same proxy, or NULL */
-	struct list proto_list;         /* list in the protocol header */
-	int (*accept)(int fd);		/* accept() function passed to fdtab[] */
-	struct task * (*handler)(struct task *t); /* protocol handler. It is a task */
-	int  *timeout;                  /* pointer to client-side timeout */
-	void *private;			/* any private data which may be used by accept() */
-	unsigned int analysers;		/* bitmap of required protocol analysers */
-	int nice;			/* nice value to assign to the instanciated tasks */
-	union {				/* protocol-dependant access restrictions */
-		struct {		/* UNIX socket permissions */
-			uid_t uid;	/* -1 to leave unchanged */
-			gid_t gid;	/* -1 to leave unchanged */
-			mode_t mode;	/* 0 to leave unchanged */
-			int level;	/* access level (ACCESS_LVL_*) */
-		} ux;
-	} perm;
-	char *interface;		/* interface name or NULL */
-	int maxseg;			/* for TCP, advertised MSS */
-
-	struct {
-		const char *file;	/* file where the section appears */
-		int line;		/* line where the section appears */
-		struct eb32_node id;	/* place in the tree of used IDs */
-	} conf;				/* config information */
-};
-
-/* This structure contains all information needed to easily handle a protocol.
- * Its primary goal is to ease listeners maintenance. Specifically, the
- * bind_all() primitive must be used before any fork(), and the enable_all()
- * primitive must be called after the fork() to enable all fds. Last, the
- * unbind_all() primitive closes all listeners.
- */
-struct protocol {
-	char name[PROTO_NAME_LEN];			/* protocol name, zero-terminated */
-	int sock_domain;				/* socket domain, as passed to socket()   */
-	int sock_type;					/* socket type, as passed to socket()     */
-	int sock_prot;					/* socket protocol, as passed to socket() */
-	sa_family_t sock_family;			/* socket family, for sockaddr */
-	socklen_t sock_addrlen;				/* socket address length, used by bind() */
-	int l3_addrlen;					/* layer3 address length, used by hashes */
-	int (*read)(int fd);				/* generic read function */
-	int (*write)(int fd);				/* generic write function */
-	int (*bind_all)(struct protocol *proto);	/* bind all unbound listeners */
-	int (*unbind_all)(struct protocol *proto);	/* unbind all bound listeners */
-	int (*enable_all)(struct protocol *proto);	/* enable all bound listeners */
-	int (*disable_all)(struct protocol *proto);	/* disable all bound listeners */
-	struct list listeners;				/* list of listeners using this protocol */
-	int nb_listeners;				/* number of listeners */
-	struct list list;				/* list of registered protocols */
-};
-
-#endif /* _TYPES_PROTOCOLS_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/types/proxy.h b/deps/haproxy-1.4.21/include/types/proxy.h
deleted file mode 100644
index 4312e0f..0000000
--- a/deps/haproxy-1.4.21/include/types/proxy.h
+++ /dev/null
@@ -1,373 +0,0 @@
-/*
- * include/types/proxy.h
- * This file defines everything related to proxies.
- *
- * Copyright (C) 2000-2010 Willy Tarreau - w@1wt.eu
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _TYPES_PROXY_H
-#define _TYPES_PROXY_H
-
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-
-#include <common/appsession.h>
-#include <common/config.h>
-#include <common/mini-clist.h>
-#include <common/regex.h>
-#include <common/sessionhash.h>
-#include <common/tools.h>
-#include <eb32tree.h>
-
-#include <types/acl.h>
-#include <types/pattern.h>
-#include <types/backend.h>
-#include <types/buffers.h>
-#include <types/counters.h>
-#include <types/freq_ctr.h>
-#include <types/httperr.h>
-#include <types/log.h>
-#include <types/protocols.h>
-#include <types/session.h>
-#include <types/server.h>
-#include <types/stick_table.h>
-
-/* values for proxy->state */
-#define PR_STNEW        0
-#define PR_STIDLE       1
-#define PR_STRUN        2
-#define PR_STSTOPPED    3
-#define PR_STPAUSED     4
-#define PR_STERROR      5
-
-/* values for proxy->mode */
-#define PR_MODE_TCP     0
-#define PR_MODE_HTTP    1
-#define PR_MODE_HEALTH  2
-
-/* flag values for proxy->cap. This is a bitmask of capabilities supported by the proxy */
-#define PR_CAP_NONE    0x0000
-#define PR_CAP_FE      0x0001
-#define PR_CAP_BE      0x0002
-#define PR_CAP_RS      0x0004
-#define PR_CAP_LISTEN  (PR_CAP_FE|PR_CAP_BE|PR_CAP_RS)
-
-/* bits for proxy->options */
-#define PR_O_REDISP     0x00000001      /* allow reconnection to dispatch in case of errors */
-#define PR_O_TRANSP     0x00000002      /* transparent mode : use original DEST as dispatch */
-#define PR_O_COOK_RW    0x00000004      /* rewrite all direct cookies with the right serverid */
-#define PR_O_COOK_IND   0x00000008      /* keep only indirect cookies */
-#define PR_O_COOK_INS   0x00000010      /* insert cookies when not accessing a server directly */
-#define PR_O_COOK_PFX   0x00000020      /* rewrite all cookies by prefixing the right serverid */
-#define PR_O_COOK_ANY   (PR_O_COOK_RW | PR_O_COOK_IND | PR_O_COOK_INS | PR_O_COOK_PFX)
-#define PR_O_SMTP_CHK   0x00000040      /* use SMTP EHLO check for server health - pvandijk@vision6.com.au */
-#define PR_O_KEEPALIVE  0x00000080      /* follow keep-alive sessions */
-#define PR_O_FWDFOR     0x00000100      /* conditionally insert x-forwarded-for with client address */
-#define PR_O_BIND_SRC   0x00000200      /* bind to a specific source address when connect()ing */
-#define PR_O_NULLNOLOG  0x00000400      /* a connect without request will not be logged */
-#define PR_O_COOK_NOC   0x00000800      /* add a 'Cache-control' header with the cookie */
-#define PR_O_COOK_POST  0x00001000      /* don't insert cookies for requests other than a POST */
-#define PR_O_HTTP_CHK   0x00002000      /* use HTTP 'OPTIONS' method to check server health */
-#define PR_O_PERSIST    0x00004000      /* server persistence stays effective even when server is down */
-#define PR_O_LOGASAP    0x00008000      /* log as soon as possible, without waiting for the session to complete */
-#define PR_O_HTTP_CLOSE 0x00010000      /* force 'connection: close' in both directions */
-#define PR_O_CHK_CACHE  0x00020000      /* require examination of cacheability of the 'set-cookie' field */
-#define PR_O_TCP_CLI_KA 0x00040000      /* enable TCP keep-alive on client-side sessions */
-#define PR_O_TCP_SRV_KA 0x00080000      /* enable TCP keep-alive on server-side sessions */
-#define PR_O_USE_ALL_BK 0x00100000      /* load-balance between backup servers */
-#define PR_O_FORCE_CLO  0x00200000      /* enforce the connection close immediately after server response */
-#define PR_O_TCP_NOLING 0x00400000      /* disable lingering on client and server connections */
-#define PR_O_ABRT_CLOSE 0x00800000      /* immediately abort request when client closes */
-
-/* TPXY: exclusive values */
-#define PR_O_TPXY_ADDR  0x01000000	/* bind to this non-local address when connect()ing */
-#define PR_O_TPXY_CIP   0x02000000	/* bind to the client's IP address when connect()ing */
-#define PR_O_TPXY_CLI   0x03000000	/* bind to the client's IP+port when connect()ing */
-#define PR_O_TPXY_DYN   0x04000000	/* bind to a dynamically computed non-local address */
-#define PR_O_TPXY_MASK  0x07000000	/* bind to a non-local address when connect()ing */
-
-#define PR_O_SERVER_CLO 0x08000000	/* option http-server-close */
-#define PR_O_CONTSTATS	0x10000000	/* continous counters */
-#define PR_O_HTTP_PROXY 0x20000000	/* Enable session to use HTTP proxy operations */
-#define PR_O_DISABLE404 0x40000000      /* Disable a server on a 404 response to a health-check */
-#define PR_O_ORGTO      0x80000000      /* insert x-original-to with destination address */
-
-/* bits for proxy->options2 */
-#define PR_O2_SPLIC_REQ	0x00000001      /* transfer requests using linux kernel's splice() */
-#define PR_O2_SPLIC_RTR	0x00000002      /* transfer responses using linux kernel's splice() */
-#define PR_O2_SPLIC_AUT	0x00000004      /* automatically use linux kernel's splice() */
-#define PR_O2_SPLIC_ANY	(PR_O2_SPLIC_REQ|PR_O2_SPLIC_RTR|PR_O2_SPLIC_AUT)
-#define PR_O2_REQBUG_OK	0x00000008      /* let buggy requests pass through */
-#define PR_O2_RSPBUG_OK	0x00000010      /* let buggy responses pass through */
-#define PR_O2_NOLOGNORM	0x00000020      /* don't log normal traffic, only errors and retries */
-#define PR_O2_LOGERRORS	0x00000040      /* log errors and retries at level LOG_ERR */
-#define PR_O2_SMARTACC 	0x00000080      /* don't immediately ACK request after accept */
-#define PR_O2_SMARTCON 	0x00000100      /* don't immediately send empty ACK after connect */
-#define PR_O2_RDPC_PRST	0x00000200      /* Actvate rdp cookie analyser */
-#define PR_O2_CLFLOG	0x00000400      /* log into clf format */
-#define PR_O2_LOGHCHKS	0x00000800	/* log health checks */
-#define PR_O2_INDEPSTR	0x00001000	/* independant streams, don't update rex on write */
-#define PR_O2_SOCKSTAT	0x00002000	/* collect & provide separate statistics for sockets */
-
-/* appsession */
-#define PR_O2_AS_REQL	0x00004000      /* learn the session id from the request */
-#define PR_O2_AS_PFX	0x00008000      /* match on the cookie prefix */
-
-/* Encoding of appsession cookie matching modes : 2 possible values => 1 bit */
-#define PR_O2_AS_M_PP	0x00000000      /* path-parameters mode (the default mode) */
-#define PR_O2_AS_M_QS	0x00010000      /* query-string mode */
-#define PR_O2_AS_M_ANY	0x00010000      /* mask covering all PR_O2_AS_M_* values */
-
-#define PR_O2_MYSQL_CHK 0x00020000      /* use MYSQL check for server health */
-#define PR_O2_USE_PXHDR 0x00040000      /* use Proxy-Connection for proxy requests */
-#define PR_O2_CHK_SNDST 0x00080000      /* send the state of each server along with HTTP health checks */
-#define PR_O2_SSL3_CHK  0x00100000      /* use SSLv3 CLIENT_HELLO packets for server health */
-#define PR_O2_FAKE_KA   0x00200000      /* pretend we do keep-alive with server eventhough we close */
-#define PR_O2_LDAP_CHK  0x00400000      /* use LDAP check for server health */
-
-#define PR_O2_EXP_NONE  0x00000000      /* http-check : no expect rule */
-#define PR_O2_EXP_STS   0x00800000      /* http-check expect status */
-#define PR_O2_EXP_RSTS  0x01000000      /* http-check expect rstatus */
-#define PR_O2_EXP_STR   0x01800000      /* http-check expect string */
-#define PR_O2_EXP_RSTR  0x02000000      /* http-check expect rstring */
-#define PR_O2_EXP_TYPE  0x03800000      /* mask for http-check expect type */
-#define PR_O2_EXP_INV   0x04000000      /* http-check expect !<rule> */
-#define PR_O2_COOK_PSV  0x08000000      /* cookie ... preserve */
-/* unused: 0x10000000 */
-#define PR_O2_FF_ALWAYS 0x20000000      /* always set x-forwarded-for */
-#define PR_O2_NODELAY   0x40000000      /* fully interactive mode, never delay outgoing data */
-/* end of proxy->options2 */
-
-/* bits for sticking rules */
-#define STK_IS_MATCH	0x00000001	/* match on request fetch */
-#define STK_IS_STORE	0x00000002	/* store on request fetch */
-#define STK_ON_RSP	0x00000004	/* store on response fetch */
-
-struct error_snapshot {
-	struct timeval when;		/* date of this event, (tv_sec == 0) means "never" */
-	unsigned int len;		/* original length of the last invalid request/response */
-	unsigned int pos;		/* position of the first invalid character */
-	unsigned int sid;		/* ID of the faulty session */
-	unsigned int ev_id;		/* event number (counter incremented for each capture) */
-	unsigned int state;		/* message state before the error (when saved) */
-	unsigned int flags;		/* buffer flags */
-	struct server *srv;		/* server associated with the error (or NULL) */
-	struct proxy *oe;		/* other end = frontend or backend involved */
-	struct sockaddr_storage src;	/* client's address */
-	char buf[BUFSIZE];		/* copy of the beginning of the message */
-};
-
-struct proxy {
-	struct listener *listen;		/* the listen addresses and sockets */
-	struct in_addr mon_net, mon_mask;	/* don't forward connections from this net (network order) FIXME: should support IPv6 */
-	int state;				/* proxy state */
-	int options;				/* PR_O_REDISP, PR_O_TRANSP, ... */
-	int options2;				/* PR_O2_* */
-	unsigned int fe_req_ana, be_req_ana;	/* bitmap of common request protocol analysers for the frontend and backend */
-	unsigned int fe_rsp_ana, be_rsp_ana;	/* bitmap of common response protocol analysers for the frontend and backend */
-	int mode;				/* mode = PR_MODE_TCP, PR_MODE_HTTP or PR_MODE_HEALTH */
-	struct sockaddr_in dispatch_addr;	/* the default address to connect to */
-	union {
-		struct proxy *be;		/* default backend, or NULL if none set */
-		char *name;			/* default backend name during config parse */
-	} defbe;
-	struct list acl;                        /* ACL declared on this proxy */
-	struct list req_acl;			/* request ACL: allow/deny/http-auth */
-	struct list block_cond;                 /* early blocking conditions (chained) */
-	struct list redirect_rules;             /* content redirecting rules (chained) */
-	struct list switching_rules;            /* content switching rules (chained) */
-	struct list persist_rules;		/* 'force-persist' and 'ignore-persist' rules (chained) */
-	struct list sticking_rules;             /* content sticking rules (chained) */
-	struct list storersp_rules;             /* content store response rules (chained) */
-	struct {                                /* TCP request processing */
-		unsigned int inspect_delay;     /* inspection delay */
-		struct list inspect_rules;      /* inspection rules */
-	} tcp_req;
-	int acl_requires;                       /* Elements required to satisfy all ACLs (ACL_USE_*) */
-	struct server *srv, defsrv;		/* known servers; default server configuration */
-	int srv_act, srv_bck;			/* # of servers eligible for LB (UP|!checked) AND (enabled+weight!=0) */
-	struct lbprm lbprm;			/* load-balancing parameters */
-	char *cookie_domain;			/* domain used to insert the cookie */
-	char *cookie_name;			/* name of the cookie to look for */
-	int  cookie_len;			/* strlen(cookie_name), computed only once */
-	unsigned int cookie_maxidle;		/* max idle time for this cookie */
-	unsigned int cookie_maxlife;		/* max life time for this cookie */
-	char *rdp_cookie_name;			/* name of the RDP cookie to look for */
-	int  rdp_cookie_len;			/* strlen(rdp_cookie_name), computed only once */
-	char *url_param_name;			/* name of the URL parameter used for hashing */
-	int  url_param_len;			/* strlen(url_param_name), computed only once */
-	unsigned url_param_post_limit;		/* if checking POST body for URI parameter, max body to wait for */
-	int  uri_len_limit;			/* character limit for uri balancing algorithm */
-	int  uri_dirs_depth1;			/* directories+1 (slashes) limit for uri balancing algorithm */
-	char *hh_name;				/* name of the header parameter used for hashing */
-	int  hh_len;				/* strlen(hh_name), computed only once */
-	int  hh_match_domain;			/* toggle use of special match function */
-	char *appsession_name;			/* name of the cookie to look for */
-	int  appsession_name_len;		/* strlen(appsession_name), computed only once */
-	int  appsession_len;			/* length of the appsession cookie value to be used */
-	struct appsession_hash htbl_proxy;	/* Per Proxy hashtable */
-	char *capture_name;			/* beginning of the name of the cookie to capture */
-	int  capture_namelen;			/* length of the cookie name to match */
-	int  capture_len;			/* length of the string to be captured */
-	struct uri_auth *uri_auth;		/* if non-NULL, the (list of) per-URI authentications */
-	char *monitor_uri;			/* a special URI to which we respond with HTTP/200 OK */
-	int monitor_uri_len;			/* length of the string above. 0 if unused */
-	struct list mon_fail_cond;              /* list of conditions to fail monitoring requests (chained) */
-	struct {				/* WARNING! check proxy_reset_timeouts() in proxy.h !!! */
-		int client;                     /* client I/O timeout (in ticks) */
-		int tarpit;                     /* tarpit timeout, defaults to connect if unspecified */
-		int queue;                      /* queue timeout, defaults to connect if unspecified */
-		int connect;                    /* connect timeout (in ticks) */
-		int server;                     /* server I/O timeout (in ticks) */
-		int appsession;                 /* appsession cookie expiration */
-		int httpreq;                    /* maximum time for complete HTTP request */
-		int httpka;                     /* maximum time for a new HTTP request when using keep-alive */
-		int check;                      /* maximum time for complete check */
-	} timeout;
-	char *id, *desc;			/* proxy id (name) and description */
-	struct list pendconns;			/* pending connections with no server assigned yet */
-	int nbpend;				/* number of pending connections with no server assigned yet */
-	int totpend;				/* total number of pending connections on this instance (for stats) */
-	unsigned int feconn, beconn;		/* # of active frontend and backends sessions */
-	struct freq_ctr fe_req_per_sec;		/* HTTP requests per second on the frontend */
-	struct freq_ctr fe_sess_per_sec;	/* sessions per second on the frontend */
-	struct freq_ctr be_sess_per_sec;	/* sessions per second on the backend */
-	unsigned int maxconn;			/* max # of active sessions on the frontend */
-	unsigned int fe_sps_lim;		/* limit on new sessions per second on the frontend */
-	unsigned int fullconn;			/* #conns on backend above which servers are used at full load */
-	struct in_addr except_net, except_mask; /* don't x-forward-for for this address. FIXME: should support IPv6 */
-	struct in_addr except_to;		/* don't x-original-to for this address. */
-	struct in_addr except_mask_to;		/* the netmask for except_to. */
-	char *fwdfor_hdr_name;			/* header to use - default: "x-forwarded-for" */
-	int fwdfor_hdr_len;			/* length of "x-forwarded-for" header */
-	char *orgto_hdr_name;			/* header to use - default: "x-original-to" */
-	int orgto_hdr_len;			/* length of "x-original-to" header */
-	char *server_id_hdr_name;                   /* the header to use to send the server id (name) */
-	int server_id_hdr_len;                      /* the length of the id (name) header... name */
-
-	unsigned down_trans;			/* up-down transitions */
-	unsigned down_time;			/* total time the proxy was down */
-	time_t last_change;			/* last time, when the state was changed */
-
-	int conn_retries;			/* maximum number of connect retries */
-	int cap;				/* supported capabilities (PR_CAP_*) */
-	struct sockaddr_in source_addr;		/* the address to which we want to bind for connect() */
-#if defined(CONFIG_HAP_CTTPROXY) || defined(CONFIG_HAP_LINUX_TPROXY)
-	struct sockaddr_in tproxy_addr;		/* non-local address we want to bind to for connect() */
-	char *bind_hdr_name;			/* bind to this header name if defined */
-	int bind_hdr_len;			/* length of the name of the header above */
-	int bind_hdr_occ;			/* occurrence number of header above: >0 = from first, <0 = from end, 0=disabled */
-#endif
-	int iface_len;				/* bind interface name length */
-	char *iface_name;			/* bind interface name or NULL */
-	struct proxy *next;
-	struct logsrv logsrv1, logsrv2;		/* 2 syslog servers */
-	signed char logfac1, logfac2;		/* log facility for both servers. -1 = disabled */
-	int loglev1, loglev2;			/* log level for each server, 7 by default */
-	int minlvl1, minlvl2;			/* minimum log level for each server, 0 by default */
-	int to_log;				/* things to be logged (LW_*) */
-	int stop_time;                          /* date to stop listening, when stopping != 0 (int ticks) */
-	struct hdr_exp *req_exp;		/* regular expressions for request headers */
-	struct hdr_exp *rsp_exp;		/* regular expressions for response headers */
-	int nb_req_cap, nb_rsp_cap;		/* # of headers to be captured */
-	struct cap_hdr *req_cap;		/* chained list of request headers to be captured */
-	struct cap_hdr *rsp_cap;		/* chained list of response headers to be captured */
-	struct pool_head *req_cap_pool,		/* pools of pre-allocated char ** used to build the sessions */
-	                 *rsp_cap_pool;
-	struct pool_head *hdr_idx_pool;         /* pools of pre-allocated int* used for headers indexing */
-	struct list req_add, rsp_add;           /* headers to be added */
-	struct pxcounters counters;		/* statistics counters */
-
-	struct stktable table;			/* table for storing sticking sessions */
-
-	int grace;				/* grace time after stop request */
-	char *check_req;			/* HTTP or SSL request to use for PR_O_HTTP_CHK|PR_O_SSL3_CHK */
-	int check_len;				/* Length of the HTTP or SSL3 request */
-	char *expect_str;			/* http-check expected content : string or text version of the regex */
-	regex_t *expect_regex;			/* http-check expected content */
-	struct chunk errmsg[HTTP_ERR_SIZE];	/* default or customized error messages for known errors */
-	int uuid;				/* universally unique proxy ID, used for SNMP */
-	unsigned int backlog;			/* force the frontend's listen backlog */
-	unsigned int bind_proc;			/* bitmask of processes using this proxy. 0 = all. */
-	struct error_snapshot invalid_req, invalid_rep; /* captures of last errors */
-
-	/* used only during configuration parsing */
-	int no_options;				/* PR_O_REDISP, PR_O_TRANSP, ... */
-	int no_options2;			/* PR_O2_* */
-
-	struct {
-		const char *file;		/* file where the section appears */
-		int line;			/* line where the section appears */
-		struct eb32_node id;		/* place in the tree of used IDs */
-		struct eb_root used_listener_id;/* list of listener IDs in use */
-		struct eb_root used_server_id;	/* list of server IDs in use */
-	} conf;					/* config information */
-};
-
-struct switching_rule {
-	struct list list;			/* list linked to from the proxy */
-	struct acl_cond *cond;			/* acl condition to meet */
-	union {
-		struct proxy *backend;		/* target backend */
-		char *name;			/* target backend name during config parsing */
-	} be;
-};
-
-struct persist_rule {
-	struct list list;			/* list linked to from the proxy */
-	struct acl_cond *cond;			/* acl condition to meet */
-	int type;
-};
-
-struct sticking_rule {
-	struct list list;                       /* list linked to from the proxy */
-	struct acl_cond *cond;                  /* acl condition to meet */
-	struct pattern_expr *expr;              /* fetch expr to fetch key */
-	int flags;                              /* STK_* */
-	union {
-		struct stktable *t;	        /* target table */
-		char *name;                     /* target table name during config parsing */
-	} table;
-};
-
-
-struct redirect_rule {
-	struct list list;                       /* list linked to from the proxy */
-	struct acl_cond *cond;                  /* acl condition to meet */
-	int type;
-	int rdr_len;
-	char *rdr_str;
-	int code;
-	unsigned int flags;
-	int cookie_len;
-	char *cookie_str;
-};
-
-extern struct proxy *proxy;
-extern struct eb_root used_proxy_id;	/* list of proxy IDs in use */
-extern unsigned int error_snapshot_id;  /* global ID assigned to each error then incremented */
-
-#endif /* _TYPES_PROXY_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/types/queue.h b/deps/haproxy-1.4.21/include/types/queue.h
deleted file mode 100644
index 922aa92..0000000
--- a/deps/haproxy-1.4.21/include/types/queue.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
-  include/types/queue.h
-  This file defines variables and structures needed for queues.
-
-  Copyright (C) 2000-2006 Willy Tarreau - w@1wt.eu
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _TYPES_QUEUE_H
-#define _TYPES_QUEUE_H
-
-#include <common/config.h>
-#include <common/mini-clist.h>
-
-#include <types/server.h>
-#include <types/session.h>
-
-struct pendconn {
-	struct list list;		/* chaining ... */
-	struct session *sess;		/* the session waiting for a connection */
-	struct server *srv;		/* the server we are waiting for */
-};
-
-#endif /* _TYPES_QUEUE_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/types/server.h b/deps/haproxy-1.4.21/include/types/server.h
deleted file mode 100644
index 14e4d1f..0000000
--- a/deps/haproxy-1.4.21/include/types/server.h
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
-  include/types/server.h
-  This file defines everything related to servers.
-
-  Copyright (C) 2000-2009 Willy Tarreau - w@1wt.eu
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _TYPES_SERVER_H
-#define _TYPES_SERVER_H
-
-#include <netinet/in.h>
-#include <arpa/inet.h>
-
-#include <common/config.h>
-#include <common/mini-clist.h>
-#include <eb32tree.h>
-
-#include <types/buffers.h>
-#include <types/counters.h>
-#include <types/freq_ctr.h>
-#include <types/port_range.h>
-#include <types/proxy.h>
-#include <types/queue.h>
-#include <types/task.h>
-#include <types/checks.h>
-
-
-/* server flags */
-#define SRV_RUNNING	0x0001	/* the server is UP */
-#define SRV_BACKUP	0x0002	/* this server is a backup server */
-#define SRV_MAPPORTS	0x0004	/* this server uses mapped ports */
-#define SRV_BIND_SRC	0x0008	/* this server uses a specific source address */
-#define SRV_CHECKED	0x0010	/* this server needs to be checked */
-#define SRV_GOINGDOWN	0x0020	/* this server says that it's going down (404) */
-#define SRV_WARMINGUP	0x0040	/* this server is warming up after a failure */
-#define SRV_MAINTAIN	0x0080	/* this server is in maintenance mode */
-#define SRV_TPROXY_ADDR	0x0100	/* bind to this non-local address to reach this server */
-#define SRV_TPROXY_CIP	0x0200	/* bind to the client's IP address to reach this server */
-#define SRV_TPROXY_CLI	0x0300	/* bind to the client's IP+port to reach this server */
-#define SRV_TPROXY_DYN	0x0400	/* bind to a dynamically computed non-local address */
-#define SRV_TPROXY_MASK	0x0700	/* bind to a non-local address to reach this server */
-
-/* function which act on servers need to return various errors */
-#define SRV_STATUS_OK       0   /* everything is OK. */
-#define SRV_STATUS_INTERNAL 1   /* other unrecoverable errors. */
-#define SRV_STATUS_NOSRV    2   /* no server is available */
-#define SRV_STATUS_FULL     3   /* the/all server(s) are saturated */
-#define SRV_STATUS_QUEUED   4   /* the/all server(s) are saturated but the connection was queued */
-
-/* bits for s->result used for health-checks */
-#define SRV_CHK_UNKNOWN 0x0000   /* initialized to this by default */
-#define SRV_CHK_ERROR   0x0001   /* error encountered during the check; has precedence */
-#define SRV_CHK_RUNNING 0x0002   /* server seen as running */
-#define SRV_CHK_DISABLE 0x0004   /* server returned a "disable" code */
-
-/* various constants */
-#define SRV_UWGHT_RANGE 256
-#define SRV_UWGHT_MAX   (SRV_UWGHT_RANGE - 1)
-#define SRV_EWGHT_RANGE (SRV_UWGHT_RANGE * BE_WEIGHT_SCALE)
-#define SRV_EWGHT_MAX   (SRV_UWGHT_MAX   * BE_WEIGHT_SCALE)
-
-/* A tree occurrence is a descriptor of a place in a tree, with a pointer back
- * to the server itself.
- */
-struct server;
-struct tree_occ {
-	struct server *server;
-	struct eb32_node node;
-};
-
-struct server {
-	struct server *next;
-	int state;				/* server state (SRV_*) */
-	int prev_state;				/* server state before last change (SRV_*) */
-	int cklen;				/* the len of the cookie, to speed up checks */
-	int rdr_len;				/* the length of the redirection prefix */
-	char *cookie;				/* the id set in the cookie */
-	char *rdr_pfx;				/* the redirection prefix */
-
-	struct proxy *proxy;			/* the proxy this server belongs to */
-	int served;				/* # of active sessions currently being served (ie not pending) */
-	int cur_sess;				/* number of currently active sessions (including syn_sent) */
-	unsigned maxconn, minconn;		/* max # of active sessions (0 = unlimited), min# for dynamic limit. */
-	int nbpend;				/* number of pending connections */
-	int maxqueue;				/* maximum number of pending connections allowed */
-	struct srvcounters counters;		/* statistics counters */
-
-	struct list pendconns;			/* pending connections */
-	struct task *check;                     /* the task associated to the health check processing */
-	struct task *warmup;                    /* the task dedicated to the warmup when slowstart is set */
-
-	struct sockaddr_in addr;		/* the address to connect to */
-	struct sockaddr_in source_addr;		/* the address to which we want to bind for connect() */
-#if defined(CONFIG_HAP_CTTPROXY) || defined(CONFIG_HAP_LINUX_TPROXY)
-	struct sockaddr_in tproxy_addr;		/* non-local address we want to bind to for connect() */
-	char *bind_hdr_name;			/* bind to this header name if defined */
-	int bind_hdr_len;			/* length of the name of the header above */
-	int bind_hdr_occ;			/* occurrence number of header above: >0 = from first, <0 = from end, 0=disabled */
-#endif
-	int iface_len;				/* bind interface name length */
-	char *iface_name;			/* bind interface name or NULL */
-	struct port_range *sport_range;		/* optional per-server TCP source ports */
-
-	struct server *tracknext, *tracked;	/* next server in a tracking list, tracked server */
-	char *trackit;				/* temporary variable to make assignment deferrable */
-	struct sockaddr_in check_addr;		/* the address to check, if different from <addr> */
-	short check_port;			/* the port to use for the health checks */
-	int health;				/* 0->rise-1 = bad; rise->rise+fall-1 = good */
-	int consecutive_errors;			/* current number of consecutive errors */
-	int rise, fall;				/* time in iterations */
-	int consecutive_errors_limit;		/* number of consecutive errors that triggers an event */
-	short observe, onerror;			/* observing mode: one of HANA_OBS_*; what to do on error: on of ANA_ONERR_* */
-	int inter, fastinter, downinter;	/* checks: time in milliseconds */
-	int slowstart;				/* slowstart time in seconds (ms in the conf) */
-	int result;				/* health-check result : SRV_CHK_* */
-	int curfd;				/* file desc used for current test, or -1 if not in test */
-
-	char *id;				/* just for identification */
-	unsigned iweight,uweight, eweight;	/* initial weight, user-specified weight, and effective weight */
-	unsigned wscore;			/* weight score, used during srv map computation */
-	unsigned prev_eweight;			/* eweight before last change */
-	unsigned rweight;			/* remainer of weight in the current LB tree */
-	unsigned npos, lpos;			/* next and last positions in the LB tree */
-	struct eb32_node lb_node;               /* node used for tree-based load balancing */
-	struct eb_root *lb_tree;                /* we want to know in what tree the server is */
-	struct server *next_full;               /* next server in the temporary full list */
-	unsigned lb_nodes_tot;                  /* number of allocated lb_nodes (C-HASH) */
-	unsigned lb_nodes_now;                  /* number of lb_nodes placed in the tree (C-HASH) */
-	struct tree_occ *lb_nodes;              /* lb_nodes_tot * struct tree_occ */
-
-	unsigned down_time;			/* total time the server was down */
-	time_t last_change;			/* last time, when the state was changed */
-	struct timeval check_start;		/* last health check start time */
-	long check_duration;			/* time in ms took to finish last health check */
-	short check_status, check_code;		/* check result, check code */
-	char check_desc[HCHK_DESC_LEN];		/* health check descritpion */
-
-	struct freq_ctr sess_per_sec;		/* sessions per second on this server */
-	int puid;				/* proxy-unique server ID, used for SNMP */
-
-	char *check_data;			/* storage of partial check results */
-	int check_data_len;			/* length of partial check results stored in check_data */
-
-	struct {
-		const char *file;		/* file where the section appears */
-		int line;			/* line where the section appears */
-		struct eb32_node id;		/* place in the tree of used IDs */
-	} conf;					/* config information */
-};
-
-
-#endif /* _TYPES_SERVER_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/types/session.h b/deps/haproxy-1.4.21/include/types/session.h
deleted file mode 100644
index 20d2a2c..0000000
--- a/deps/haproxy-1.4.21/include/types/session.h
+++ /dev/null
@@ -1,248 +0,0 @@
-/*
- * include/types/session.h
- * This file defines everything related to sessions.
- *
- * Copyright (C) 2000-2010 Willy Tarreau - w@1wt.eu
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _TYPES_SESSION_H
-#define _TYPES_SESSION_H
-
-
-#include <sys/time.h>
-#include <unistd.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-
-#include <common/config.h>
-#include <common/mini-clist.h>
-
-#include <types/buffers.h>
-#include <types/proto_http.h>
-#include <types/proxy.h>
-#include <types/queue.h>
-#include <types/server.h>
-#include <types/stream_interface.h>
-#include <types/task.h>
-#include <types/stick_table.h>
-
-
-/* various session flags, bits values 0x01 to 0x100 (shift 0) */
-#define SN_DIRECT	0x00000001	/* connection made on the server matching the client cookie */
-#define SN_ASSIGNED	0x00000002	/* no need to assign a server to this session */
-#define SN_ADDR_SET	0x00000004	/* this session's server address has been set */
-#define SN_BE_ASSIGNED	0x00000008	/* a backend was assigned. Conns are accounted. */
-
-#define SN_FORCE_PRST	0x00000010	/* force persistence here, even if server is down */
-#define SN_MONITOR	0x00000020	/* this session comes from a monitoring system */
-#define SN_CURR_SESS	0x00000040	/* a connection is currently being counted on the server */
-#define SN_FRT_ADDR_SET	0x00000080	/* set if the frontend address has been filled */
-#define SN_REDISP	0x00000100	/* set if this session was redispatched from one server to another */
-#define SN_CONN_TAR	0x00000200	/* set if this session is turning around before reconnecting */
-#define SN_REDIRECTABLE	0x00000400	/* set if this session is redirectable (GET or HEAD) */
-#define SN_TUNNEL	0x00000800	/* tunnel-mode session, nothing to catch after data */
-
-/* session termination conditions, bits values 0x1000 to 0x7000 (0-7 shift 12) */
-#define SN_ERR_NONE     0x00000000
-#define SN_ERR_CLITO	0x00001000	/* client time-out */
-#define SN_ERR_CLICL	0x00002000	/* client closed (read/write error) */
-#define SN_ERR_SRVTO	0x00003000	/* server time-out, connect time-out */
-#define SN_ERR_SRVCL	0x00004000	/* server closed (connect/read/write error) */
-#define SN_ERR_PRXCOND	0x00005000	/* the proxy decided to close (deny...) */
-#define SN_ERR_RESOURCE	0x00006000	/* the proxy encountered a lack of a local resources (fd, mem, ...) */
-#define SN_ERR_INTERNAL	0x00007000	/* the proxy encountered an internal error */
-#define SN_ERR_MASK	0x00007000	/* mask to get only session error flags */
-#define SN_ERR_SHIFT	12		/* bit shift */
-/* unused:              0x00008000 */
-
-/* session state at termination, bits values 0x10000 to 0x70000 (0-7 shift 16) */
-#define SN_FINST_R	0x00010000	/* session ended during client request */
-#define SN_FINST_C	0x00020000	/* session ended during server connect */
-#define SN_FINST_H	0x00030000	/* session ended during server headers */
-#define SN_FINST_D	0x00040000	/* session ended during data phase */
-#define SN_FINST_L	0x00050000	/* session ended while pushing last data to client */
-#define SN_FINST_Q	0x00060000	/* session ended while waiting in queue for a server slot */
-#define SN_FINST_T	0x00070000	/* session ended tarpitted */
-#define SN_FINST_MASK	0x00070000	/* mask to get only final session state flags */
-#define	SN_FINST_SHIFT	16		/* bit shift */
-/* unused:              0x00080000 */
-
-#define SN_IGNORE_PRST	0x00100000	/* ignore persistence */
-
-/* WARNING: if new fields are added, they must be initialized in event_accept()
- * and freed in session_free() !
- */
-
-/* Termination sequence tracing.
- *
- * These values have to be set into the field term_trace of a session when
- * closing a session (half or full). They are only meant for post-mortem
- * analysis. The value must be assigned this way :
- *    trace_term(s, TT_XXX);
- *
- * One TT_XXX value is assigned to each location in the code which may be
- * involved in a connection closing. Since a full session close generally
- * involves 4 steps, we will be able to read these steps afterwards by simply
- * checking the code. Value TT_NONE is zero and must never be set, as it means
- * the connection was not closed. Value TT_ANON must be used when no value was
- * assigned to a specific code part. Never ever reuse an already assigned code
- * as it will defeat the purpose of this trace. It is wise to use a per-file
- * anonymous value though.
- */
-#define TT_BIT_SHIFT 8
-enum {
-	TT_NONE     = 0,
-	TT_ANON     = 1,
-	TT_CLIENT   = 0x10,
-	TT_CLIENT_1,
-	TT_CLIENT_2,
-	TT_HTTP_CLI = 0x20,
-	TT_HTTP_CLI_1,
-	TT_HTTP_CLI_2,
-	TT_HTTP_CLI_3,
-	TT_HTTP_CLI_4,
-	TT_HTTP_CLI_5,
-	TT_HTTP_CLI_6,
-	TT_HTTP_CLI_7,
-	TT_HTTP_CLI_8,
-	TT_HTTP_CLI_9,
-	TT_HTTP_CLI_10,
-	TT_HTTP_SRV = 0x30,
-	TT_HTTP_SRV_1,
-	TT_HTTP_SRV_2,
-	TT_HTTP_SRV_3,
-	TT_HTTP_SRV_4,
-	TT_HTTP_SRV_5,
-	TT_HTTP_SRV_6,
-	TT_HTTP_SRV_7,
-	TT_HTTP_SRV_8,
-	TT_HTTP_SRV_9,
-	TT_HTTP_SRV_10,
-	TT_HTTP_SRV_11,
-	TT_HTTP_SRV_12,
-	TT_HTTP_SRV_13,
-	TT_HTTP_SRV_14,
-	TT_HTTP_CNT = 0x40,
-	TT_HTTP_CNT_1,
-	TT_HTTP_URI = 0x50,
-	TT_HTTP_URI_1,
-};
-
-
-/*
- * Note: some session flags have dependencies :
- *  - SN_DIRECT cannot exist without SN_ASSIGNED, because a server is
- *    immediately assigned when SN_DIRECT is determined. Both must be cleared
- *    when clearing SN_DIRECT (eg: redispatch).
- *  - ->srv has no meaning without SN_ASSIGNED and must not be checked without
- *    it. ->prev_srv should be used to check previous ->srv. If SN_ASSIGNED is
- *    set and sess->srv is NULL, then it is a dispatch or proxy mode.
- *  - a session being processed has srv_conn set.
- *  - srv_conn might remain after SN_DIRECT has been reset, but the assigned
- *    server should eventually be released.
- */
-struct session {
-	struct list list;			/* position in global sessions list */
-	struct list back_refs;			/* list of users tracking this session */
-	struct task *task;			/* the task associated with this session */
-	/* application specific below */
-	struct listener *listener;		/* the listener by which the request arrived */
-	struct proxy *fe;			/* the proxy this session depends on for the client side */
-	struct proxy *be;			/* the proxy this session depends on for the server side */
-	int conn_retries;			/* number of connect retries left */
-	int flags;				/* some flags describing the session */
-	unsigned term_trace;			/* term trace: 4*8 bits indicating which part of the code closed */
-	struct buffer *req;			/* request buffer */
-	struct buffer *rep;			/* response buffer */
-	struct stream_interface si[2];          /* client and server stream interfaces */
-	struct sockaddr_storage cli_addr;	/* the client address */
-	struct sockaddr_storage frt_addr;	/* the frontend address reached by the client if SN_FRT_ADDR_SET is set */
-	struct sockaddr_in srv_addr;		/* the address to connect to */
-	struct sockaddr_in from_addr;		/* the address to spoof when connecting to the server (transparent mode) */
-	struct server *srv;			/* the server the session will be running or has been running on */
-	struct server *srv_conn;		/* session already has a slot on a server and is not in queue */
-	struct server *prev_srv;		/* the server the was running on, after a redispatch, otherwise NULL */
-	struct pendconn *pend_pos;		/* if not NULL, points to the position in the pending queue */
-	struct http_txn txn;			/* current HTTP transaction being processed. Should become a list. */
-
-	struct {
-		struct stksess *ts;
-		struct stktable *table;
-		int flags;
-	} store[8];				/* tracked stickiness values to store */
-	int store_count;
-
-	struct {
-		int logwait;			/* log fields waiting to be collected : LW_* */
-		struct timeval accept_date;	/* date of the accept() in user date */
-		struct timeval tv_accept;	/* date of the accept() in internal date (monotonic) */
-		struct timeval tv_request;	/* date the request arrives, {0,0} if never occurs */
-		long  t_queue;			/* delay before the session gets out of the connect queue, -1 if never occurs */
-		long  t_connect;		/* delay before the connect() to the server succeeds, -1 if never occurs */
-		long  t_data;			/* delay before the first data byte from the server ... */
-		unsigned long t_close;		/* total session duration */
-		unsigned long srv_queue_size;	/* number of sessions waiting for a connect slot on this server at accept() time (in direct assignment) */
-		unsigned long prx_queue_size;	/* overall number of sessions waiting for a connect slot on this instance at accept() time */
-		long long bytes_in;		/* number of bytes transferred from the client to the server */
-		long long bytes_out;		/* number of bytes transferred from the server to the client */
-	} logs;
-	void (*do_log)(struct session *s);	/* the function to call in order to log (or NULL) */
-	void (*srv_error)(struct session *s,	/* the function to call upon unrecoverable server errors (or NULL) */
-			  struct stream_interface *si);
-	short int data_source;			/* where to get the data we generate ourselves */
-	short int data_state;			/* where to get the data we generate ourselves */
-	union {
-		struct {
-			struct proxy *px;
-			struct server *sv;
-			struct listener *l;
-			short px_st, sv_st;	/* DATA_ST_INIT or DATA_ST_DATA */
-			unsigned int flags;	/* STAT_* */
-			int iid, type, sid;	/* proxy id, type and service id if bounding of stats is enabled */
-			const char *st_code;	/* pointer to the status code returned by an action */
-		} stats;
-		struct {
-			struct bref bref;	/* back-reference from the session being dumped */
-			void *target;		/* session we want to dump, or NULL for all */
-			unsigned int uid;	/* if non-null, the uniq_id of the session being dumped */
-			int section;		/* section of the session being dumped */
-			int pos;		/* last position of the current session's buffer */
-		} sess;
-		struct {
-			int iid;		/* if >= 0, ID of the proxy to filter on */
-			struct proxy *px;	/* current proxy being dumped, NULL = not started yet. */
-			unsigned int buf;	/* buffer being dumped, 0 = req, 1 = rep */
-			unsigned int sid;	/* session ID of error being dumped */
-			int ptr;		/* <0: headers, >=0 : text pointer to restart from */
-			int bol;		/* pointer to beginning of current line */
-		} errors;
-		struct {
-			const char *msg;	/* pointer to a persistent message to be returned in PRINT state */
-		} cli;
-	} data_ctx;				/* used by stats I/O handlers to dump the stats */
-	unsigned int uniq_id;			/* unique ID used for the traces */
-};
-
-
-#endif /* _TYPES_SESSION_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/types/signal.h b/deps/haproxy-1.4.21/include/types/signal.h
deleted file mode 100644
index b863d23..0000000
--- a/deps/haproxy-1.4.21/include/types/signal.h
+++ /dev/null
@@ -1,20 +0,0 @@
-/*
- * Asynchronous signal delivery functions descriptors.
- *
- * Copyright 2000-2009 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <signal.h>
-#include <common/config.h>
-#include <common/standard.h>
-
-struct signal_descriptor {
-	int count;  /* number of times raised */
-	void (*handler)(int sig);
-};
diff --git a/deps/haproxy-1.4.21/include/types/stick_table.h b/deps/haproxy-1.4.21/include/types/stick_table.h
deleted file mode 100644
index fd0c806..0000000
--- a/deps/haproxy-1.4.21/include/types/stick_table.h
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- * include/types/stick_table.h
- * Macros, variables and structures for stick tables management.
- *
- * Copyright (C) 2009-2010 EXCELIANCE, Emeric Brun <ebrun@exceliance.fr>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _TYPES_STICK_TABLE_H
-#define _TYPES_STICK_TABLE_H
-
-#include <sys/socket.h>
-#include <netinet/in.h>
-
-#include <ebtree.h>
-#include <ebmbtree.h>
-#include <eb32tree.h>
-#include <common/memory.h>
-
-/* stick table key types */
-#define STKTABLE_TYPE_IP	0 /* table key is ipv4 */
-#define STKTABLE_TYPE_INTEGER	1 /* table key is unsigned 32bit integer */
-#define STKTABLE_TYPE_STRING	2 /* table key is a null terminated string */
-
-#define STKTABLE_TYPES	3  /* Increase this value if you add a type */
-
-/* stick table type flags */
-#define STKTABLE_TYPEFLAG_CUSTOMKEYSIZE 0x00000001 /* this table type maxsize is configurable */
-
-/* stick table keyword type */
-struct stktable_type {
-	const char *kw;       /* keyword string */
-	int flags;            /* type flags */
-	size_t default_size;  /* default key size */
-};
-
-/* stuck session */
-struct stksess {
-	int sid;                  /* id of server to use for session */
-	unsigned int expire;      /* session expiration date */
-	struct eb32_node exps;    /* ebtree node used to hold the session in expiration tree */
-	struct ebmb_node keys;    /* ebtree node used to hold the session in table */
-};
-
-
-/* stick table */
-struct stktable {
-	struct eb_root keys;      /* head of stuck session tree */
-	struct eb_root exps;      /* head of stuck session expiration tree */
-	struct pool_head *pool;   /* pool used to allocate stuck sessions */
-	struct task *exp_task;    /* expiration task */
-	unsigned long type;       /* type of table (determine key format) */
-	size_t key_size;          /* size of a key, maximum size in case of string */
-	unsigned int size;        /* maximum stuck session in table */
-	unsigned int current;     /* number of stuck session in table */
-	int nopurge;              /* 1 never purge stuck sessions */
-	int exp_next;             /* next epiration date */
-	int expire;               /* duration before expiration of stuck session */
-};
-
-/* stick table key data */
-union stktable_key_data {
-	struct in_addr ip;        /* used to store an ip key */
-	uint32_t integer;         /* used to store an integer key */
-	char buf[BUFSIZE];        /* used to store a null terminated string key */
-};
-
-/* stick table key */
-struct stktable_key {
-	void *key;                      /* pointer on key buffer */
-	size_t key_len;                 /* data len to read in buff in case of null terminated string */
-	union stktable_key_data data;   /* data */
-};
-
-#endif /* _TYPES_STICK_TABLE_H */
-
diff --git a/deps/haproxy-1.4.21/include/types/stream_interface.h b/deps/haproxy-1.4.21/include/types/stream_interface.h
deleted file mode 100644
index 6ad6684..0000000
--- a/deps/haproxy-1.4.21/include/types/stream_interface.h
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * include/types/stream_interface.h
- * This file describes the stream_interface struct and associated constants.
- *
- * Copyright (C) 2000-2009 Willy Tarreau - w@1wt.eu
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _TYPES_STREAM_INTERFACE_H
-#define _TYPES_STREAM_INTERFACE_H
-
-#include <stdlib.h>
-#include <sys/socket.h>
-
-#include <types/buffers.h>
-#include <common/config.h>
-
-/* A stream interface must have its own errors independantly of the buffer's,
- * so that applications can rely on what the buffer reports while the stream
- * interface is performing some retries (eg: connection error). Some states are
- * transient and do not last beyond process_session().
- */
-enum {
-	SI_ST_INI = 0,           /* interface not sollicitated yet */
-	SI_ST_REQ,               /* [transient] connection initiation desired and not started yet */
-	SI_ST_QUE,               /* interface waiting in queue */
-	SI_ST_TAR,               /* interface in turn-around state after failed connect attempt */
-	SI_ST_ASS,               /* server just assigned to this interface */
-	SI_ST_CON,               /* initiated connection request (resource exists) */
-	SI_ST_CER,               /* [transient] previous connection attempt failed (resource released) */
-	SI_ST_EST,               /* connection established (resource exists) */
-	SI_ST_DIS,               /* [transient] disconnected from other side, but cleanup not done yet */
-	SI_ST_CLO,               /* stream intf closed, might not existing anymore. Buffers shut. */
-};
-
-/* error types reported on the streams interface for more accurate reporting */
-enum {
-	SI_ET_NONE       = 0x0000,  /* no error yet, leave it to zero */
-	SI_ET_QUEUE_TO   = 0x0001,  /* queue timeout */
-	SI_ET_QUEUE_ERR  = 0x0002,  /* queue error (eg: full) */
-	SI_ET_QUEUE_ABRT = 0x0004,  /* aborted in queue by external cause */
-	SI_ET_CONN_TO    = 0x0008,  /* connection timeout */
-	SI_ET_CONN_ERR   = 0x0010,  /* connection error (eg: no server available) */
-	SI_ET_CONN_ABRT  = 0x0020,  /* connection aborted by external cause (eg: abort) */
-	SI_ET_CONN_OTHER = 0x0040,  /* connection aborted for other reason (eg: 500) */
-	SI_ET_DATA_TO    = 0x0080,  /* timeout during data phase */
-	SI_ET_DATA_ERR   = 0x0100,  /* error during data phase */
-	SI_ET_DATA_ABRT  = 0x0200,  /* data phase aborted by external cause */
-};
-
-/* flags set after I/O */
-enum {
-	SI_FL_NONE       = 0x0000,  /* nothing */
-	SI_FL_EXP        = 0x0001,  /* timeout has expired */
-	SI_FL_ERR        = 0x0002,  /* a non-recoverable error has occurred */
-	SI_FL_WAIT_ROOM  = 0x0004,  /* waiting for space to store incoming data */
-	SI_FL_WAIT_DATA  = 0x0008,  /* waiting for more data to send */
-	SI_FL_CAP_SPLTCP = 0x0010,  /* splicing possible from/to TCP */
-	SI_FL_DONT_WAKE  = 0x0020,  /* resync in progress, don't wake up */
-	SI_FL_INDEP_STR  = 0x0040,  /* independant streams = don't update rex on write */
-	SI_FL_NOLINGER   = 0x0080,  /* may close without lingering. One-shot. */
-};
-
-#define SI_FL_CAP_SPLICE (SI_FL_CAP_SPLTCP)
-
-struct server;
-struct proxy;
-
-/* Note that if an iohandler is set, the update function will not be called by
- * the session handler, so it may be used to resync flags at the end of the I/O
- * handler. See stream_int_update_embedded() for reference.
- */
-struct stream_interface {
-	unsigned int state;     /* SI_ST* */
-	unsigned int prev_state;/* SI_ST*, copy of previous state */
-	void *owner;            /* generally a (struct task*) */
-	int fd;                 /* file descriptor for a stream driver when known */
-	unsigned int flags;
-	unsigned int exp;       /* wake up time for connect, queue, turn-around, ... */
-	void (*update)(struct stream_interface *); /* I/O update function */
-	void (*shutr)(struct stream_interface *);  /* shutr function */
-	void (*shutw)(struct stream_interface *);  /* shutw function */
-	void (*chk_rcv)(struct stream_interface *);/* chk_rcv function */
-	void (*chk_snd)(struct stream_interface *);/* chk_snd function */
-	int (*connect)(struct stream_interface *, struct proxy *, struct server *,
-		       struct sockaddr *, struct sockaddr *); /* connect function if any */
-	void (*iohandler)(struct stream_interface *);  /* internal I/O handler when embedded */
-	struct buffer *ib, *ob; /* input and output buffers */
-	unsigned int err_type;  /* first error detected, one of SI_ET_* */
-	void *err_loc;          /* commonly the server, NULL when SI_ET_NONE */
-	void *private;          /* may be used by any function above */
-	unsigned int st0, st1;  /* may be used by any function above */
-};
-
-
-#endif /* _TYPES_STREAM_INTERFACE_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/types/task.h b/deps/haproxy-1.4.21/include/types/task.h
deleted file mode 100644
index 41f889c..0000000
--- a/deps/haproxy-1.4.21/include/types/task.h
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
-  include/types/task.h
-  Macros, variables and structures for task management.
-
-  Copyright (C) 2000-2009 Willy Tarreau - w@1wt.eu
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _TYPES_TASK_H
-#define _TYPES_TASK_H
-
-#include <sys/time.h>
-
-#include <common/config.h>
-#include <common/mini-clist.h>
-#include <eb32tree.h>
-
-/* values for task->state */
-#define TASK_SLEEPING     0x00  /* task sleeping */
-#define TASK_RUNNING      0x01  /* the task is currently running */
-#define TASK_WOKEN_INIT   0x02  /* woken up for initialisation purposes */
-#define TASK_WOKEN_TIMER  0x04  /* woken up because of expired timer */
-#define TASK_WOKEN_IO     0x08  /* woken up because of completed I/O */
-#define TASK_WOKEN_SIGNAL 0x10  /* woken up by a system signal */
-#define TASK_WOKEN_MSG    0x20  /* woken up by another task's message */
-#define TASK_WOKEN_RES    0x40  /* woken up because of available resource */
-#define TASK_WOKEN_OTHER  0x80  /* woken up for an unspecified reason */
-
-/* use this to check a task state or to clean it up before queueing */
-#define TASK_WOKEN_ANY    (TASK_WOKEN_OTHER|TASK_WOKEN_INIT|TASK_WOKEN_TIMER| \
-                           TASK_WOKEN_IO|TASK_WOKEN_SIGNAL|TASK_WOKEN_MSG| \
-                           TASK_WOKEN_RES)
-
-/* The base for all tasks */
-struct task {
-	struct eb32_node wq;		/* ebtree node used to hold the task in the wait queue */
-	struct eb32_node rq;		/* ebtree node used to hold the task in the run queue */
-	int state;			/* task state : bit field of TASK_* */
-	int expire;			/* next expiration date for this task, in ticks */
-	unsigned int calls;		/* number of times ->process() was called */
-	struct task * (*process)(struct task *t);  /* the function which processes the task */
-	void *context;			/* the task's context */
-	int nice;			/* the task's current nice value from -1024 to +1024 */
-};
-
-/*
- * The task callback (->process) is responsible for updating ->expire. It must
- * return a pointer to the task itself, except if the task has been deleted, in
- * which case it returns NULL so that the scheduler knows it must not check the
- * expire timer. The scheduler will requeue the task at the proper location.
- */
-
-#endif /* _TYPES_TASK_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/include/types/template.h b/deps/haproxy-1.4.21/include/types/template.h
deleted file mode 100644
index e4292e7..0000000
--- a/deps/haproxy-1.4.21/include/types/template.h
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
-  include/types/template.h
-  This file serves as a template for future include files.
-
-  Copyright (C) 2000-2006 Willy Tarreau - w@1wt.eu
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _TYPES_TEMPLATE_H
-#define _TYPES_TEMPLATE_H
-
-#include <common/config.h>
-
-#endif /* _TYPES_TEMPLATE_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/acl.c b/deps/haproxy-1.4.21/src/acl.c
deleted file mode 100644
index 35b6eb8..0000000
--- a/deps/haproxy-1.4.21/src/acl.c
+++ /dev/null
@@ -1,1599 +0,0 @@
-/*
- * ACL management functions.
- *
- * Copyright 2000-2011 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <ctype.h>
-#include <stdio.h>
-#include <string.h>
-
-#include <common/config.h>
-#include <common/mini-clist.h>
-#include <common/standard.h>
-#include <common/uri_auth.h>
-
-#include <types/global.h>
-
-#include <proto/acl.h>
-#include <proto/auth.h>
-#include <proto/log.h>
-#include <proto/proxy.h>
-
-#include <ebsttree.h>
-
-/* The capabilities of filtering hooks describe the type of information
- * available to each of them.
- */
-const unsigned int filt_cap[] = {
-	[ACL_HOOK_REQ_FE_TCP]         = ACL_USE_TCP4_ANY|ACL_USE_TCP6_ANY|ACL_USE_TCP_ANY,
-	[ACL_HOOK_REQ_FE_TCP_CONTENT] = ACL_USE_TCP4_ANY|ACL_USE_TCP6_ANY|ACL_USE_TCP_ANY|ACL_USE_L4REQ_ANY,
-	[ACL_HOOK_REQ_FE_HTTP_IN]     = ACL_USE_TCP4_ANY|ACL_USE_TCP6_ANY|ACL_USE_TCP_ANY|ACL_USE_L4REQ_ANY|ACL_USE_L7REQ_ANY|ACL_USE_HDR_ANY,
-	[ACL_HOOK_REQ_FE_SWITCH]      = ACL_USE_TCP4_ANY|ACL_USE_TCP6_ANY|ACL_USE_TCP_ANY|ACL_USE_L4REQ_ANY|ACL_USE_L7REQ_ANY|ACL_USE_HDR_ANY,
-	[ACL_HOOK_REQ_BE_TCP_CONTENT] = ACL_USE_TCP4_ANY|ACL_USE_TCP6_ANY|ACL_USE_TCP_ANY|ACL_USE_L4REQ_ANY|ACL_USE_L7REQ_ANY|ACL_USE_HDR_ANY,
-	[ACL_HOOK_REQ_BE_HTTP_IN]     = ACL_USE_TCP4_ANY|ACL_USE_TCP6_ANY|ACL_USE_TCP_ANY|ACL_USE_L4REQ_ANY|ACL_USE_L7REQ_ANY|ACL_USE_HDR_ANY,
-	[ACL_HOOK_REQ_BE_SWITCH]      = ACL_USE_TCP4_ANY|ACL_USE_TCP6_ANY|ACL_USE_TCP_ANY|ACL_USE_L4REQ_ANY|ACL_USE_L7REQ_ANY|ACL_USE_HDR_ANY,
-	[ACL_HOOK_REQ_FE_HTTP_OUT]    = ACL_USE_TCP4_ANY|ACL_USE_TCP6_ANY|ACL_USE_TCP_ANY|ACL_USE_L4REQ_ANY|ACL_USE_L7REQ_ANY|ACL_USE_HDR_ANY,
-	[ACL_HOOK_REQ_BE_HTTP_OUT]    = ACL_USE_TCP4_ANY|ACL_USE_TCP6_ANY|ACL_USE_TCP_ANY|ACL_USE_L4REQ_ANY|ACL_USE_L7REQ_ANY|ACL_USE_HDR_ANY,
-
-	[ACL_HOOK_RTR_BE_TCP_CONTENT] = ACL_USE_REQ_PERMANENT|ACL_USE_REQ_CACHEABLE|ACL_USE_L4RTR_ANY,
-	[ACL_HOOK_RTR_BE_HTTP_IN]     = ACL_USE_REQ_PERMANENT|ACL_USE_REQ_CACHEABLE|ACL_USE_L4RTR_ANY|ACL_USE_L7RTR_ANY,
-	[ACL_HOOK_RTR_FE_TCP_CONTENT] = ACL_USE_REQ_PERMANENT|ACL_USE_REQ_CACHEABLE|ACL_USE_L4RTR_ANY|ACL_USE_L7RTR_ANY,
-	[ACL_HOOK_RTR_FE_HTTP_IN]     = ACL_USE_REQ_PERMANENT|ACL_USE_REQ_CACHEABLE|ACL_USE_L4RTR_ANY|ACL_USE_L7RTR_ANY,
-	[ACL_HOOK_RTR_BE_HTTP_OUT]    = ACL_USE_REQ_PERMANENT|ACL_USE_REQ_CACHEABLE|ACL_USE_L4RTR_ANY|ACL_USE_L7RTR_ANY,
-	[ACL_HOOK_RTR_FE_HTTP_OUT]    = ACL_USE_REQ_PERMANENT|ACL_USE_REQ_CACHEABLE|ACL_USE_L4RTR_ANY|ACL_USE_L7RTR_ANY,
-};
-
-/* List head of all known ACL keywords */
-static struct acl_kw_list acl_keywords = {
-	.list = LIST_HEAD_INIT(acl_keywords.list)
-};
-
-
-/*
- * These functions are only used for debugging complex configurations.
- */
-
-/* force TRUE to be returned at the fetch level */
-static int
-acl_fetch_true(struct proxy *px, struct session *l4, void *l7, int dir,
-	       struct acl_expr *expr, struct acl_test *test)
-{
-	test->flags |= ACL_TEST_F_SET_RES_PASS;
-	return 1;
-}
-
-/* wait for more data as long as possible, then return TRUE. This should be
- * used with content inspection.
- */
-static int
-acl_fetch_wait_end(struct proxy *px, struct session *l4, void *l7, int dir,
-		   struct acl_expr *expr, struct acl_test *test)
-{
-	if (dir & ACL_PARTIAL) {
-		test->flags |= ACL_TEST_F_MAY_CHANGE;
-		return 0;
-	}
-	test->flags |= ACL_TEST_F_SET_RES_PASS;
-	return 1;
-}
-
-/* force FALSE to be returned at the fetch level */
-static int
-acl_fetch_false(struct proxy *px, struct session *l4, void *l7, int dir,
-		struct acl_expr *expr, struct acl_test *test)
-{
-	test->flags |= ACL_TEST_F_SET_RES_FAIL;
-	return 1;
-}
-
-
-/*
- * These functions are exported and may be used by any other component.
- */
-
-/* ignore the current line */
-int acl_parse_nothing(const char **text, struct acl_pattern *pattern, int *opaque)
-{
-	return 1;
-}
-
-/* always fake a data retrieval */
-int acl_fetch_nothing(struct proxy *px, struct session *l4, void *l7, int dir,
-		      struct acl_expr *expr, struct acl_test *test)
-{
-	return 1;
-}
-
-/* always return false */
-int acl_match_nothing(struct acl_test *test, struct acl_pattern *pattern)
-{
-	return ACL_PAT_FAIL;
-}
-
-
-/* NB: For two strings to be identical, it is required that their lengths match */
-int acl_match_str(struct acl_test *test, struct acl_pattern *pattern)
-{
-	int icase;
-
-	if (pattern->len != test->len)
-		return ACL_PAT_FAIL;
-
-	icase = pattern->flags & ACL_PAT_F_IGNORE_CASE;
-	if ((icase && strncasecmp(pattern->ptr.str, test->ptr, test->len) == 0) ||
-	    (!icase && strncmp(pattern->ptr.str, test->ptr, test->len) == 0))
-		return ACL_PAT_PASS;
-	return ACL_PAT_FAIL;
-}
-
-/* Lookup a string in the expression's pattern tree. The node is returned if it
- * exists, otherwise NULL.
- */
-void *acl_lookup_str(struct acl_test *test, struct acl_expr *expr)
-{
-	/* data are stored in a tree */
-	struct ebmb_node *node;
-	char prev;
-
-	/* we may have to force a trailing zero on the test pattern */
-	prev = test->ptr[test->len];
-	if (prev)
-		test->ptr[test->len] = '\0';
-	node = ebst_lookup(&expr->pattern_tree, test->ptr);
-	if (prev)
-		test->ptr[test->len] = prev;
-	return node;
-}
-
-/* Executes a regex. It needs to change the data. If it is marked READ_ONLY
- * then it will be allocated and duplicated in place so that others may use
- * it later on. Note that this is embarrassing because we always try to avoid
- * allocating memory at run time.
- */
-int acl_match_reg(struct acl_test *test, struct acl_pattern *pattern)
-{
-	char old_char;
-	int ret;
-
-	if (unlikely(test->flags & ACL_TEST_F_READ_ONLY)) {
-		char *new_str;
-
-		new_str = calloc(1, test->len + 1);
-		if (!new_str)
-			return ACL_PAT_FAIL;
-
-		memcpy(new_str, test->ptr, test->len);
-		new_str[test->len] = 0;
-		if (test->flags & ACL_TEST_F_MUST_FREE)
-			free(test->ptr);
-		test->ptr = new_str;
-		test->flags |= ACL_TEST_F_MUST_FREE;
-		test->flags &= ~ACL_TEST_F_READ_ONLY;
-	}
-
-	old_char = test->ptr[test->len];
-	test->ptr[test->len] = 0;
-
-	if (regexec(pattern->ptr.reg, test->ptr, 0, NULL, 0) == 0)
-		ret = ACL_PAT_PASS;
-	else
-		ret = ACL_PAT_FAIL;
-
-	test->ptr[test->len] = old_char;
-	return ret;
-}
-
-/* Checks that the pattern matches the beginning of the tested string. */
-int acl_match_beg(struct acl_test *test, struct acl_pattern *pattern)
-{
-	int icase;
-
-	if (pattern->len > test->len)
-		return ACL_PAT_FAIL;
-
-	icase = pattern->flags & ACL_PAT_F_IGNORE_CASE;
-	if ((icase && strncasecmp(pattern->ptr.str, test->ptr, pattern->len) != 0) ||
-	    (!icase && strncmp(pattern->ptr.str, test->ptr, pattern->len) != 0))
-		return ACL_PAT_FAIL;
-	return ACL_PAT_PASS;
-}
-
-/* Checks that the pattern matches the end of the tested string. */
-int acl_match_end(struct acl_test *test, struct acl_pattern *pattern)
-{
-	int icase;
-
-	if (pattern->len > test->len)
-		return ACL_PAT_FAIL;
-	icase = pattern->flags & ACL_PAT_F_IGNORE_CASE;
-	if ((icase && strncasecmp(pattern->ptr.str, test->ptr + test->len - pattern->len, pattern->len) != 0) ||
-	    (!icase && strncmp(pattern->ptr.str, test->ptr + test->len - pattern->len, pattern->len) != 0))
-		return ACL_PAT_FAIL;
-	return ACL_PAT_PASS;
-}
-
-/* Checks that the pattern is included inside the tested string.
- * NB: Suboptimal, should be rewritten using a Boyer-Moore method.
- */
-int acl_match_sub(struct acl_test *test, struct acl_pattern *pattern)
-{
-	int icase;
-	char *end;
-	char *c;
-
-	if (pattern->len > test->len)
-		return ACL_PAT_FAIL;
-
-	end = test->ptr + test->len - pattern->len;
-	icase = pattern->flags & ACL_PAT_F_IGNORE_CASE;
-	if (icase) {
-		for (c = test->ptr; c <= end; c++) {
-			if (tolower(*c) != tolower(*pattern->ptr.str))
-				continue;
-			if (strncasecmp(pattern->ptr.str, c, pattern->len) == 0)
-				return ACL_PAT_PASS;
-		}
-	} else {
-		for (c = test->ptr; c <= end; c++) {
-			if (*c != *pattern->ptr.str)
-				continue;
-			if (strncmp(pattern->ptr.str, c, pattern->len) == 0)
-				return ACL_PAT_PASS;
-		}
-	}
-	return ACL_PAT_FAIL;
-}
-
-/* Background: Fast way to find a zero byte in a word
- * http://graphics.stanford.edu/~seander/bithacks.html#ZeroInWord
- * hasZeroByte = (v - 0x01010101UL) & ~v & 0x80808080UL;
- *
- * To look for 4 different byte values, xor the word with those bytes and
- * then check for zero bytes:
- *
- * v = (((unsigned char)c * 0x1010101U) ^ delimiter)
- * where <delimiter> is the 4 byte values to look for (as an uint)
- * and <c> is the character that is being tested
- */
-static inline unsigned int is_delimiter(unsigned char c, unsigned int mask)
-{
-	mask ^= (c * 0x01010101); /* propagate the char to all 4 bytes */
-	return (mask - 0x01010101) & ~mask & 0x80808080U;
-}
-
-static inline unsigned int make_4delim(unsigned char d1, unsigned char d2, unsigned char d3, unsigned char d4)
-{
-	return d1 << 24 | d2 << 16 | d3 << 8 | d4;
-}
-
-/* This one is used by other real functions. It checks that the pattern is
- * included inside the tested string, but enclosed between the specified
- * delimiters or at the beginning or end of the string. The delimiters are
- * provided as an unsigned int made by make_4delim() and match up to 4 different
- * delimiters. Delimiters are stripped at the beginning and end of the pattern.
- */
-static int match_word(struct acl_test *test, struct acl_pattern *pattern, unsigned int delimiters)
-{
-	int may_match, icase;
-	char *c, *end;
-	char *ps;
-	int pl;
-
-	pl = pattern->len;
-	ps = pattern->ptr.str;
-
-	while (pl > 0 && is_delimiter(*ps, delimiters)) {
-		pl--;
-		ps++;
-	}
-
-	while (pl > 0 && is_delimiter(ps[pl - 1], delimiters))
-		pl--;
-
-	if (pl > test->len)
-		return ACL_PAT_FAIL;
-
-	may_match = 1;
-	icase = pattern->flags & ACL_PAT_F_IGNORE_CASE;
-	end = test->ptr + test->len - pl;
-	for (c = test->ptr; c <= end; c++) {
-		if (is_delimiter(*c, delimiters)) {
-			may_match = 1;
-			continue;
-		}
-
-		if (!may_match)
-			continue;
-
-		if (icase) {
-			if ((tolower(*c) == tolower(*ps)) &&
-			    (strncasecmp(ps, c, pl) == 0) &&
-			    (c == end || is_delimiter(c[pl], delimiters)))
-				return ACL_PAT_PASS;
-		} else {
-			if ((*c == *ps) &&
-			    (strncmp(ps, c, pl) == 0) &&
-			    (c == end || is_delimiter(c[pl], delimiters)))
-				return ACL_PAT_PASS;
-		}
-		may_match = 0;
-	}
-	return ACL_PAT_FAIL;
-}
-
-/* Checks that the pattern is included inside the tested string, but enclosed
- * between the delimiters '?' or '/' or at the beginning or end of the string.
- * Delimiters at the beginning or end of the pattern are ignored.
- */
-int acl_match_dir(struct acl_test *test, struct acl_pattern *pattern)
-{
-	return match_word(test, pattern, make_4delim('/', '?', '?', '?'));
-}
-
-/* Checks that the pattern is included inside the tested string, but enclosed
- * between the delmiters '/', '?', '.' or ":" or at the beginning or end of
- * the string. Delimiters at the beginning or end of the pattern are ignored.
- */
-int acl_match_dom(struct acl_test *test, struct acl_pattern *pattern)
-{
-	return match_word(test, pattern, make_4delim('/', '?', '.', ':'));
-}
-
-/* Checks that the integer in <test> is included between min and max */
-int acl_match_int(struct acl_test *test, struct acl_pattern *pattern)
-{
-	if ((!pattern->val.range.min_set || pattern->val.range.min <= test->i) &&
-	    (!pattern->val.range.max_set || test->i <= pattern->val.range.max))
-		return ACL_PAT_PASS;
-	return ACL_PAT_FAIL;
-}
-
-/* Checks that the length of the pattern in <test> is included between min and max */
-int acl_match_len(struct acl_test *test, struct acl_pattern *pattern)
-{
-	if ((!pattern->val.range.min_set || pattern->val.range.min <= test->len) &&
-	    (!pattern->val.range.max_set || test->len <= pattern->val.range.max))
-		return ACL_PAT_PASS;
-	return ACL_PAT_FAIL;
-}
-
-int acl_match_ip(struct acl_test *test, struct acl_pattern *pattern)
-{
-	struct in_addr *s;
-
-	if (test->i != AF_INET)
-		return ACL_PAT_FAIL;
-
-	s = (void *)test->ptr;
-	if (((s->s_addr ^ pattern->val.ipv4.addr.s_addr) & pattern->val.ipv4.mask.s_addr) == 0)
-		return ACL_PAT_PASS;
-	return ACL_PAT_FAIL;
-}
-
-/* Lookup an IPv4 address in the expression's pattern tree using the longest
- * match method. The node is returned if it exists, otherwise NULL.
- */
-void *acl_lookup_ip(struct acl_test *test, struct acl_expr *expr)
-{
-	struct in_addr *s;
-
-	if (test->i != AF_INET)
-		return ACL_PAT_FAIL;
-
-	s = (void *)test->ptr;
-
-	return ebmb_lookup_longest(&expr->pattern_tree, &s->s_addr);
-}
-
-/* Parse a string. It is allocated and duplicated. */
-int acl_parse_str(const char **text, struct acl_pattern *pattern, int *opaque)
-{
-	int len;
-
-	len  = strlen(*text);
-
-	if (pattern->flags & ACL_PAT_F_TREE_OK) {
-		/* we're allowed to put the data in a tree whose root is pointed
-		 * to by val.tree.
-		 */
-		struct ebmb_node *node;
-
-		node = calloc(1, sizeof(*node) + len + 1);
-		if (!node)
-			return 0;
-		memcpy(node->key, *text, len + 1);
-		if (ebst_insert(pattern->val.tree, node) != node)
-			free(node); /* was a duplicate */
-		pattern->flags |= ACL_PAT_F_TREE; /* this pattern now contains a tree */
-		return 1;
-	}
-
-	pattern->ptr.str = strdup(*text);
-	if (!pattern->ptr.str)
-		return 0;
-	pattern->len = len;
-	return 1;
-}
-
-/* Parse and concatenate all further strings into one. */
-int
-acl_parse_strcat(const char **text, struct acl_pattern *pattern, int *opaque)
-{
-
-	int len = 0, i;
-	char *s;
-
-	for (i = 0; *text[i]; i++)
-		len += strlen(text[i])+1;
-
-	pattern->ptr.str = s = calloc(1, len);
-	if (!pattern->ptr.str)
-		return 0;
-
-	for (i = 0; *text[i]; i++)
-		s += sprintf(s, i?" %s":"%s", text[i]);
-
-	pattern->len = len;
-
-	return i;
-}
-
-/* Free data allocated by acl_parse_reg */
-static void acl_free_reg(void *ptr) {
-
-	regfree((regex_t *)ptr);
-}
-
-/* Parse a regex. It is allocated. */
-int acl_parse_reg(const char **text, struct acl_pattern *pattern, int *opaque)
-{
-	regex_t *preg;
-	int icase;
-
-	preg = calloc(1, sizeof(regex_t));
-
-	if (!preg)
-		return 0;
-
-	icase = (pattern->flags & ACL_PAT_F_IGNORE_CASE) ? REG_ICASE : 0;
-	if (regcomp(preg, *text, REG_EXTENDED | REG_NOSUB | icase) != 0) {
-		free(preg);
-		return 0;
-	}
-
-	pattern->ptr.reg = preg;
-	pattern->freeptrbuf = &acl_free_reg;
-	return 1;
-}
-
-/* Parse a range of positive integers delimited by either ':' or '-'. If only
- * one integer is read, it is set as both min and max. An operator may be
- * specified as the prefix, among this list of 5 :
- *
- *    0:eq, 1:gt, 2:ge, 3:lt, 4:le
- *
- * The default operator is "eq". It supports range matching. Ranges are
- * rejected for other operators. The operator may be changed at any time.
- * The operator is stored in the 'opaque' argument.
- *
- */
-int acl_parse_int(const char **text, struct acl_pattern *pattern, int *opaque)
-{
-	signed long long i;
-	unsigned int j, last, skip = 0;
-	const char *ptr = *text;
-
-
-	while (!isdigit((unsigned char)*ptr)) {
-		if      (strcmp(ptr, "eq") == 0) *opaque = 0;
-		else if (strcmp(ptr, "gt") == 0) *opaque = 1;
-		else if (strcmp(ptr, "ge") == 0) *opaque = 2;
-		else if (strcmp(ptr, "lt") == 0) *opaque = 3;
-		else if (strcmp(ptr, "le") == 0) *opaque = 4;
-		else
-			return 0;
-
-		skip++;
-		ptr = text[skip];
-	}
-
-	last = i = 0;
-	while (1) {
-                j = *ptr++;
-		if ((j == '-' || j == ':') && !last) {
-			last++;
-			pattern->val.range.min = i;
-			i = 0;
-			continue;
-		}
-		j -= '0';
-                if (j > 9)
-			// also catches the terminating zero
-                        break;
-                i *= 10;
-                i += j;
-        }
-
-	if (last && *opaque >= 1 && *opaque <= 4)
-		/* having a range with a min or a max is absurd */
-		return 0;
-
-	if (!last)
-		pattern->val.range.min = i;
-	pattern->val.range.max = i;
-
-	switch (*opaque) {
-	case 0: /* eq */
-		pattern->val.range.min_set = 1;
-		pattern->val.range.max_set = 1;
-		break;
-	case 1: /* gt */
-		pattern->val.range.min++; /* gt = ge + 1 */
-	case 2: /* ge */
-		pattern->val.range.min_set = 1;
-		pattern->val.range.max_set = 0;
-		break;
-	case 3: /* lt */
-		pattern->val.range.max--; /* lt = le - 1 */
-	case 4: /* le */
-		pattern->val.range.min_set = 0;
-		pattern->val.range.max_set = 1;
-		break;
-	}
-	return skip + 1;
-}
-
-/* Parse a range of positive 2-component versions delimited by either ':' or
- * '-'. The version consists in a major and a minor, both of which must be
- * smaller than 65536, because internally they will be represented as a 32-bit
- * integer.
- * If only one version is read, it is set as both min and max. Just like for
- * pure integers, an operator may be specified as the prefix, among this list
- * of 5 :
- *
- *    0:eq, 1:gt, 2:ge, 3:lt, 4:le
- *
- * The default operator is "eq". It supports range matching. Ranges are
- * rejected for other operators. The operator may be changed at any time.
- * The operator is stored in the 'opaque' argument. This allows constructs
- * such as the following one :
- *
- *    acl obsolete_ssl    ssl_req_proto lt 3
- *    acl unsupported_ssl ssl_req_proto gt 3.1
- *    acl valid_ssl       ssl_req_proto 3.0-3.1
- *
- */
-int acl_parse_dotted_ver(const char **text, struct acl_pattern *pattern, int *opaque)
-{
-	signed long long i;
-	unsigned int j, last, skip = 0;
-	const char *ptr = *text;
-
-
-	while (!isdigit((unsigned char)*ptr)) {
-		if      (strcmp(ptr, "eq") == 0) *opaque = 0;
-		else if (strcmp(ptr, "gt") == 0) *opaque = 1;
-		else if (strcmp(ptr, "ge") == 0) *opaque = 2;
-		else if (strcmp(ptr, "lt") == 0) *opaque = 3;
-		else if (strcmp(ptr, "le") == 0) *opaque = 4;
-		else
-			return 0;
-
-		skip++;
-		ptr = text[skip];
-	}
-
-	last = i = 0;
-	while (1) {
-                j = *ptr++;
-		if (j == '.') {
-			/* minor part */
-			if (i >= 65536)
-				return 0;
-			i <<= 16;
-			continue;
-		}
-		if ((j == '-' || j == ':') && !last) {
-			last++;
-			if (i < 65536)
-				i <<= 16;
-			pattern->val.range.min = i;
-			i = 0;
-			continue;
-		}
-		j -= '0';
-                if (j > 9)
-			// also catches the terminating zero
-                        break;
-                i = (i & 0xFFFF0000) + (i & 0xFFFF) * 10;
-                i += j;
-        }
-
-	/* if we only got a major version, let's shift it now */
-	if (i < 65536)
-		i <<= 16;
-
-	if (last && *opaque >= 1 && *opaque <= 4)
-		/* having a range with a min or a max is absurd */
-		return 0;
-
-	if (!last)
-		pattern->val.range.min = i;
-	pattern->val.range.max = i;
-
-	switch (*opaque) {
-	case 0: /* eq */
-		pattern->val.range.min_set = 1;
-		pattern->val.range.max_set = 1;
-		break;
-	case 1: /* gt */
-		pattern->val.range.min++; /* gt = ge + 1 */
-	case 2: /* ge */
-		pattern->val.range.min_set = 1;
-		pattern->val.range.max_set = 0;
-		break;
-	case 3: /* lt */
-		pattern->val.range.max--; /* lt = le - 1 */
-	case 4: /* le */
-		pattern->val.range.min_set = 0;
-		pattern->val.range.max_set = 1;
-		break;
-	}
-	return skip + 1;
-}
-
-/* Parse an IP address and an optional mask in the form addr[/mask].
- * The addr may either be an IPv4 address or a hostname. The mask
- * may either be a dotted mask or a number of bits. Returns 1 if OK,
- * otherwise 0.
- */
-int acl_parse_ip(const char **text, struct acl_pattern *pattern, int *opaque)
-{
-	struct eb_root *tree = NULL;
-	if (pattern->flags & ACL_PAT_F_TREE_OK)
-		tree = pattern->val.tree;
-
-	if (str2net(*text, &pattern->val.ipv4.addr, &pattern->val.ipv4.mask)) {
-		unsigned int mask = ntohl(pattern->val.ipv4.mask.s_addr);
-		struct ebmb_node *node;
-		/* check if the mask is contiguous so that we can insert the
-		 * network into the tree. A continuous mask has only ones on
-		 * the left. This means that this mask + its lower bit added
-		 * once again is null.
-		 */
-		if (mask + (mask & -mask) == 0 && tree) {
-			mask = mask ? 33 - flsnz(mask & -mask) : 0; /* equals cidr value */
-			/* FIXME: insert <addr>/<mask> into the tree here */
-			node = calloc(1, sizeof(*node) + 4); /* reserve 4 bytes for IPv4 address */
-			if (!node)
-				return 0;
-			memcpy(node->key, &pattern->val.ipv4.addr, 4); /* network byte order */
-			node->node.pfx = mask;
-			if (ebmb_insert_prefix(tree, node, 4) != node)
-				free(node); /* was a duplicate */
-			pattern->flags |= ACL_PAT_F_TREE;
-			return 1;
-		}
-		return 1;
-	}
-	else
-		return 0;
-}
-
-/*
- * Registers the ACL keyword list <kwl> as a list of valid keywords for next
- * parsing sessions.
- */
-void acl_register_keywords(struct acl_kw_list *kwl)
-{
-	LIST_ADDQ(&acl_keywords.list, &kwl->list);
-}
-
-/*
- * Unregisters the ACL keyword list <kwl> from the list of valid keywords.
- */
-void acl_unregister_keywords(struct acl_kw_list *kwl)
-{
-	LIST_DEL(&kwl->list);
-	LIST_INIT(&kwl->list);
-}
-
-/* Return a pointer to the ACL <name> within the list starting at <head>, or
- * NULL if not found.
- */
-struct acl *find_acl_by_name(const char *name, struct list *head)
-{
-	struct acl *acl;
-	list_for_each_entry(acl, head, list) {
-		if (strcmp(acl->name, name) == 0)
-			return acl;
-	}
-	return NULL;
-}
-
-/* Return a pointer to the ACL keyword <kw>, or NULL if not found. Note that if
- * <kw> contains an opening parenthesis, only the left part of it is checked.
- */
-struct acl_keyword *find_acl_kw(const char *kw)
-{
-	int index;
-	const char *kwend;
-	struct acl_kw_list *kwl;
-
-	kwend = strchr(kw, '(');
-	if (!kwend)
-		kwend = kw + strlen(kw);
-
-	list_for_each_entry(kwl, &acl_keywords.list, list) {
-		for (index = 0; kwl->kw[index].kw != NULL; index++) {
-			if ((strncmp(kwl->kw[index].kw, kw, kwend - kw) == 0) &&
-			    kwl->kw[index].kw[kwend-kw] == 0)
-				return &kwl->kw[index];
-		}
-	}
-	return NULL;
-}
-
-/* NB: does nothing if <pat> is NULL */
-static void free_pattern(struct acl_pattern *pat)
-{
-	if (!pat)
-		return;
-
-	if (pat->ptr.ptr) {
-		if (pat->freeptrbuf)
-			pat->freeptrbuf(pat->ptr.ptr);
-
-		free(pat->ptr.ptr);
-	}
-
-	free(pat);
-}
-
-static void free_pattern_list(struct list *head)
-{
-	struct acl_pattern *pat, *tmp;
-	list_for_each_entry_safe(pat, tmp, head, list)
-		free_pattern(pat);
-}
-
-static void free_pattern_tree(struct eb_root *root)
-{
-	struct eb_node *node, *next;
-	node = eb_first(root);
-	while (node) {
-		next = eb_next(node);
-		free(node);
-		node = next;
-	}
-}
-
-static struct acl_expr *prune_acl_expr(struct acl_expr *expr)
-{
-	free_pattern_list(&expr->patterns);
-	free_pattern_tree(&expr->pattern_tree);
-	LIST_INIT(&expr->patterns);
-	if (expr->arg_len && expr->arg.str)
-		free(expr->arg.str);
-	expr->kw->use_cnt--;
-	return expr;
-}
-
-static int acl_read_patterns_from_file(	struct acl_keyword *aclkw,
-					struct acl_expr *expr,
-					const char *filename, int patflags)
-{
-	FILE *file;
-	char *c;
-	const char *args[2];
-	struct acl_pattern *pattern;
-	int opaque;
-	int ret = 0;
-
-	file = fopen(filename, "r");
-	if (!file)
-		return 0;
-
-	/* now parse all patterns. The file may contain only one pattern per
-	 * line. If the line contains spaces, they will be part of the pattern.
-	 * The pattern stops at the first CR, LF or EOF encountered.
-	 */
-	opaque = 0;
-	pattern = NULL;
-	args[1] = "";
-	while (fgets(trash, trashlen, file) != NULL) {
-		c = trash;
-
-		/* ignore lines beginning with a dash */
-		if (*c == '#')
-			continue;
-
-		/* strip leading spaces and tabs */
-		while (*c == ' ' || *c == '\t')
-			c++;
-
-
-		args[0] = c;
-		while (*c && *c != '\n' && *c != '\r')
-			c++;
-		*c = 0;
-
-		/* empty lines are ignored too */
-		if (c == args[0])
-			continue;
-
-		/* we keep the previous pattern along iterations as long as it's not used */
-		if (!pattern)
-			pattern = (struct acl_pattern *)malloc(sizeof(*pattern));
-		if (!pattern)
-			goto out_close;
-
-		memset(pattern, 0, sizeof(*pattern));
-		pattern->flags = patflags;
-
-		if ((aclkw->requires & ACL_MAY_LOOKUP) && !(pattern->flags & ACL_PAT_F_IGNORE_CASE)) {
-			/* we pre-set the data pointer to the tree's head so that functions
-			 * which are able to insert in a tree know where to do that.
-			 */
-			pattern->flags |= ACL_PAT_F_TREE_OK;
-			pattern->val.tree = &expr->pattern_tree;
-		}
-
-		if (!aclkw->parse(args, pattern, &opaque))
-			goto out_free_pattern;
-
-		/* if the parser did not feed the tree, let's chain the pattern to the list */
-		if (!(pattern->flags & ACL_PAT_F_TREE)) {
-			LIST_ADDQ(&expr->patterns, &pattern->list);
-			pattern = NULL; /* get a new one */
-		}
-	}
-
-	ret = 1; /* success */
-
- out_free_pattern:
-	free_pattern(pattern);
- out_close:
-	fclose(file);
-	return ret;
-}
-
-/* Parse an ACL expression starting at <args>[0], and return it.
- * Right now, the only accepted syntax is :
- * <subject> [<value>...]
- */
-struct acl_expr *parse_acl_expr(const char **args)
-{
-	__label__ out_return, out_free_expr, out_free_pattern;
-	struct acl_expr *expr;
-	struct acl_keyword *aclkw;
-	struct acl_pattern *pattern;
-	int opaque, patflags;
-	const char *arg;
-
-	aclkw = find_acl_kw(args[0]);
-	if (!aclkw || !aclkw->parse)
-		goto out_return;
-
-	expr = (struct acl_expr *)calloc(1, sizeof(*expr));
-	if (!expr)
-		goto out_return;
-
-	expr->kw = aclkw;
-	aclkw->use_cnt++;
-	LIST_INIT(&expr->patterns);
-	expr->pattern_tree = EB_ROOT_UNIQUE;
-	expr->arg.str = NULL;
-	expr->arg_len = 0;
-
-	arg = strchr(args[0], '(');
-	if (arg != NULL) {
-		char *end, *arg2;
-		/* there is an argument in the form "subject(arg)" */
-		arg++;
-		end = strchr(arg, ')');
-		if (!end)
-			goto out_free_expr;
-		arg2 = my_strndup(arg, end - arg);
-		if (!arg2)
-			goto out_free_expr;
-		expr->arg_len = end - arg;
-		expr->arg.str = arg2;
-	}
-
-	args++;
-
-	/* check for options before patterns. Supported options are :
-	 *   -i : ignore case for all patterns by default
-	 *   -f : read patterns from those files
-	 *   -- : everything after this is not an option
-	 */
-	patflags = 0;
-	while (**args == '-') {
-		if ((*args)[1] == 'i')
-			patflags |= ACL_PAT_F_IGNORE_CASE;
-		else if ((*args)[1] == 'f') {
-			if (!acl_read_patterns_from_file(aclkw, expr, args[1], patflags | ACL_PAT_F_FROM_FILE))
-				goto out_free_expr;
-			args++;
-		}
-		else if ((*args)[1] == '-') {
-			args++;
-			break;
-		}
-		else
-			break;
-		args++;
-	}
-
-	/* now parse all patterns */
-	opaque = 0;
-	while (**args) {
-		int ret;
-		pattern = (struct acl_pattern *)calloc(1, sizeof(*pattern));
-		if (!pattern)
-			goto out_free_expr;
-		pattern->flags = patflags;
-
-		ret = aclkw->parse(args, pattern, &opaque);
-		if (!ret)
-			goto out_free_pattern;
-		LIST_ADDQ(&expr->patterns, &pattern->list);
-		args += ret;
-	}
-
-	return expr;
-
- out_free_pattern:
-	free_pattern(pattern);
- out_free_expr:
-	prune_acl_expr(expr);
-	free(expr);
- out_return:
-	return NULL;
-}
-
-/* Purge everything in the acl <acl>, then return <acl>. */
-struct acl *prune_acl(struct acl *acl) {
-
-	struct acl_expr *expr, *exprb;
-
-	free(acl->name);
-
-	list_for_each_entry_safe(expr, exprb, &acl->expr, list) {
-		LIST_DEL(&expr->list);
-		prune_acl_expr(expr);
-		free(expr);
-	}
-
-	return acl;
-}
-
-/* Parse an ACL with the name starting at <args>[0], and with a list of already
- * known ACLs in <acl>. If the ACL was not in the list, it will be added.
- * A pointer to that ACL is returned. If the ACL has an empty name, then it's
- * an anonymous one and it won't be merged with any other one.
- *
- * args syntax: <aclname> <acl_expr>
- */
-struct acl *parse_acl(const char **args, struct list *known_acl)
-{
-	__label__ out_return, out_free_acl_expr, out_free_name;
-	struct acl *cur_acl;
-	struct acl_expr *acl_expr;
-	char *name;
-
-	if (**args && invalid_char(*args))
-		goto out_return;
-
-	acl_expr = parse_acl_expr(args + 1);
-	if (!acl_expr)
-		goto out_return;
-
-	/* Check for args beginning with an opening parenthesis just after the
-	 * subject, as this is almost certainly a typo. Right now we can only
-	 * emit a warning, so let's do so.
-	 */
-	if (!strchr(args[1], '(') && *args[2] == '(')
-		Warning("parsing acl '%s' :\n"
-			"  matching '%s' for pattern '%s' is likely a mistake and probably\n"
-			"  not what you want. Maybe you need to remove the extraneous space before '('.\n"
-			"  If you are really sure this is not an error, please insert '--' between the\n"
-			"  match and the pattern to make this warning message disappear.\n",
-			args[0], args[1], args[2]);
-
-	if (*args[0])
-		cur_acl = find_acl_by_name(args[0], known_acl);
-	else
-		cur_acl = NULL;
-
-	if (!cur_acl) {
-		name = strdup(args[0]);
-		if (!name)
-			goto out_free_acl_expr;
-		cur_acl = (struct acl *)calloc(1, sizeof(*cur_acl));
-		if (cur_acl == NULL)
-			goto out_free_name;
-
-		LIST_INIT(&cur_acl->expr);
-		LIST_ADDQ(known_acl, &cur_acl->list);
-		cur_acl->name = name;
-	}
-
-	cur_acl->requires |= acl_expr->kw->requires;
-	LIST_ADDQ(&cur_acl->expr, &acl_expr->list);
-	return cur_acl;
-
- out_free_name:
-	free(name);
- out_free_acl_expr:
-	prune_acl_expr(acl_expr);
-	free(acl_expr);
- out_return:
-	return NULL;
-}
-
-/* Some useful ACLs provided by default. Only those used are allocated. */
-
-const struct {
-	const char *name;
-	const char *expr[4]; /* put enough for longest expression */
-} default_acl_list[] = {
-	{ .name = "TRUE",           .expr = {"always_true",""}},
-	{ .name = "FALSE",          .expr = {"always_false",""}},
-	{ .name = "LOCALHOST",      .expr = {"src","127.0.0.1/8",""}},
-	{ .name = "HTTP",           .expr = {"req_proto_http",""}},
-	{ .name = "HTTP_1.0",       .expr = {"req_ver","1.0",""}},
-	{ .name = "HTTP_1.1",       .expr = {"req_ver","1.1",""}},
-	{ .name = "METH_CONNECT",   .expr = {"method","CONNECT",""}},
-	{ .name = "METH_GET",       .expr = {"method","GET","HEAD",""}},
-	{ .name = "METH_HEAD",      .expr = {"method","HEAD",""}},
-	{ .name = "METH_OPTIONS",   .expr = {"method","OPTIONS",""}},
-	{ .name = "METH_POST",      .expr = {"method","POST",""}},
-	{ .name = "METH_TRACE",     .expr = {"method","TRACE",""}},
-	{ .name = "HTTP_URL_ABS",   .expr = {"url_reg","^[^/:]*://",""}},
-	{ .name = "HTTP_URL_SLASH", .expr = {"url_beg","/",""}},
-	{ .name = "HTTP_URL_STAR",  .expr = {"url","*",""}},
-	{ .name = "HTTP_CONTENT",   .expr = {"hdr_val(content-length)","gt","0",""}},
-	{ .name = "RDP_COOKIE",     .expr = {"req_rdp_cookie_cnt","gt","0",""}},
-	{ .name = "REQ_CONTENT",    .expr = {"req_len","gt","0",""}},
-	{ .name = "WAIT_END",       .expr = {"wait_end",""}},
-	{ .name = NULL, .expr = {""}}
-};
-
-/* Find a default ACL from the default_acl list, compile it and return it.
- * If the ACL is not found, NULL is returned. In theory, it cannot fail,
- * except when default ACLs are broken, in which case it will return NULL.
- * If <known_acl> is not NULL, the ACL will be queued at its tail.
- */
-struct acl *find_acl_default(const char *acl_name, struct list *known_acl)
-{
-	__label__ out_return, out_free_acl_expr, out_free_name;
-	struct acl *cur_acl;
-	struct acl_expr *acl_expr;
-	char *name;
-	int index;
-
-	for (index = 0; default_acl_list[index].name != NULL; index++) {
-		if (strcmp(acl_name, default_acl_list[index].name) == 0)
-			break;
-	}
-
-	if (default_acl_list[index].name == NULL)
-		return NULL;
-
-	acl_expr = parse_acl_expr((const char **)default_acl_list[index].expr);
-	if (!acl_expr)
-		goto out_return;
-
-	name = strdup(acl_name);
-	if (!name)
-		goto out_free_acl_expr;
-	cur_acl = (struct acl *)calloc(1, sizeof(*cur_acl));
-	if (cur_acl == NULL)
-		goto out_free_name;
-
-	cur_acl->name = name;
-	cur_acl->requires |= acl_expr->kw->requires;
-	LIST_INIT(&cur_acl->expr);
-	LIST_ADDQ(&cur_acl->expr, &acl_expr->list);
-	if (known_acl)
-		LIST_ADDQ(known_acl, &cur_acl->list);
-
-	return cur_acl;
-
- out_free_name:
-	free(name);
- out_free_acl_expr:
-	prune_acl_expr(acl_expr);
-	free(acl_expr);
- out_return:
-	return NULL;
-}
-
-/* Purge everything in the acl_cond <cond>, then return <cond>. */
-struct acl_cond *prune_acl_cond(struct acl_cond *cond)
-{
-	struct acl_term_suite *suite, *tmp_suite;
-	struct acl_term *term, *tmp_term;
-
-	/* iterate through all term suites and free all terms and all suites */
-	list_for_each_entry_safe(suite, tmp_suite, &cond->suites, list) {
-		list_for_each_entry_safe(term, tmp_term, &suite->terms, list)
-			free(term);
-		free(suite);
-	}
-	return cond;
-}
-
-/* Parse an ACL condition starting at <args>[0], relying on a list of already
- * known ACLs passed in <known_acl>. The new condition is returned (or NULL in
- * case of low memory). Supports multiple conditions separated by "or".
- */
-struct acl_cond *parse_acl_cond(const char **args, struct list *known_acl, int pol)
-{
-	__label__ out_return, out_free_suite, out_free_term;
-	int arg, neg;
-	const char *word;
-	struct acl *cur_acl;
-	struct acl_term *cur_term;
-	struct acl_term_suite *cur_suite;
-	struct acl_cond *cond;
-
-	cond = (struct acl_cond *)calloc(1, sizeof(*cond));
-	if (cond == NULL)
-		goto out_return;
-
-	LIST_INIT(&cond->list);
-	LIST_INIT(&cond->suites);
-	cond->pol = pol;
-
-	cur_suite = NULL;
-	neg = 0;
-	for (arg = 0; *args[arg]; arg++) {
-		word = args[arg];
-
-		/* remove as many exclamation marks as we can */
-		while (*word == '!') {
-			neg = !neg;
-			word++;
-		}
-
-		/* an empty word is allowed because we cannot force the user to
-		 * always think about not leaving exclamation marks alone.
-		 */
-		if (!*word)
-			continue;
-
-		if (strcasecmp(word, "or") == 0 || strcmp(word, "||") == 0) {
-			/* new term suite */
-			cur_suite = NULL;
-			neg = 0;
-			continue;
-		}
-
-		if (strcmp(word, "{") == 0) {
-			/* we may have a complete ACL expression between two braces,
-			 * find the last one.
-			 */
-			int arg_end = arg + 1;
-			const char **args_new;
-
-			while (*args[arg_end] && strcmp(args[arg_end], "}") != 0)
-				arg_end++;
-
-			if (!*args[arg_end])
-				goto out_free_suite;
-
-			args_new = calloc(1, (arg_end - arg + 1) * sizeof(*args_new));
-			if (!args_new)
-				goto out_free_suite;
-
-			args_new[0] = "";
-			memcpy(args_new + 1, args + arg + 1, (arg_end - arg) * sizeof(*args_new));
-			args_new[arg_end - arg] = "";
-			cur_acl = parse_acl(args_new, known_acl);
-			free(args_new);
-
-			if (!cur_acl)
-				goto out_free_suite;
-			arg = arg_end;
-		}
-		else {
-			/* search for <word> in the known ACL names. If we do not find
-			 * it, let's look for it in the default ACLs, and if found, add
-			 * it to the list of ACLs of this proxy. This makes it possible
-			 * to override them.
-			 */
-			cur_acl = find_acl_by_name(word, known_acl);
-			if (cur_acl == NULL) {
-				cur_acl = find_acl_default(word, known_acl);
-				if (cur_acl == NULL)
-					goto out_free_suite;
-			}
-		}
-
-		cur_term = (struct acl_term *)calloc(1, sizeof(*cur_term));
-		if (cur_term == NULL)
-			goto out_free_suite;
-
-		cur_term->acl = cur_acl;
-		cur_term->neg = neg;
-		cond->requires |= cur_acl->requires;
-
-		if (!cur_suite) {
-			cur_suite = (struct acl_term_suite *)calloc(1, sizeof(*cur_suite));
-			if (cur_term == NULL)
-				goto out_free_term;
-			LIST_INIT(&cur_suite->terms);
-			LIST_ADDQ(&cond->suites, &cur_suite->list);
-		}
-		LIST_ADDQ(&cur_suite->terms, &cur_term->list);
-		neg = 0;
-	}
-
-	return cond;
-
- out_free_term:
-	free(cur_term);
- out_free_suite:
-	prune_acl_cond(cond);
-	free(cond);
- out_return:
-	return NULL;
-}
-
-/* Builds an ACL condition starting at the if/unless keyword. The complete
- * condition is returned. NULL is returned in case of error or if the first
- * word is neither "if" nor "unless". It automatically sets the file name and
- * the line number in the condition for better error reporting, and adds the
- * ACL requirements to the proxy's acl_requires.
- */
-struct acl_cond *build_acl_cond(const char *file, int line, struct proxy *px, const char **args)
-{
-	int pol = ACL_COND_NONE;
-	struct acl_cond *cond = NULL;
-
-	if (!strcmp(*args, "if")) {
-		pol = ACL_COND_IF;
-		args++;
-	}
-	else if (!strcmp(*args, "unless")) {
-		pol = ACL_COND_UNLESS;
-		args++;
-	}
-	else
-		return NULL;
-
-	cond = parse_acl_cond(args, &px->acl, pol);
-	if (!cond)
-		return NULL;
-
-	cond->file = file;
-	cond->line = line;
-	px->acl_requires |= cond->requires;
-
-	return cond;
-}
-
-/* Execute condition <cond> and return either ACL_PAT_FAIL, ACL_PAT_MISS or
- * ACL_PAT_PASS depending on the test results. ACL_PAT_MISS may only be
- * returned if <dir> contains ACL_PARTIAL, indicating that incomplete data
- * is being examined.
- * This function only computes the condition, it does not apply the polarity
- * required by IF/UNLESS, it's up to the caller to do this using something like
- * this :
- *
- *     res = acl_pass(res);
- *     if (res == ACL_PAT_MISS)
- *         return 0;
- *     if (cond->pol == ACL_COND_UNLESS)
- *         res = !res;
- */
-int acl_exec_cond(struct acl_cond *cond, struct proxy *px, struct session *l4, void *l7, int dir)
-{
-	__label__ fetch_next;
-	struct acl_term_suite *suite;
-	struct acl_term *term;
-	struct acl_expr *expr;
-	struct acl *acl;
-	struct acl_pattern *pattern;
-	struct acl_test test;
-	int acl_res, suite_res, cond_res;
-
-	/* We're doing a logical OR between conditions so we initialize to FAIL.
-	 * The MISS status is propagated down from the suites.
-	 */
-	cond_res = ACL_PAT_FAIL;
-	list_for_each_entry(suite, &cond->suites, list) {
-		/* Evaluate condition suite <suite>. We stop at the first term
-		 * which returns ACL_PAT_FAIL. The MISS status is still propagated
-		 * in case of uncertainty in the result.
-		 */
-
-		/* we're doing a logical AND between terms, so we must set the
-		 * initial value to PASS.
-		 */
-		suite_res = ACL_PAT_PASS;
-		list_for_each_entry(term, &suite->terms, list) {
-			acl = term->acl;
-
-			/* FIXME: use cache !
-			 * check acl->cache_idx for this.
-			 */
-
-			/* ACL result not cached. Let's scan all the expressions
-			 * and use the first one to match.
-			 */
-			acl_res = ACL_PAT_FAIL;
-			list_for_each_entry(expr, &acl->expr, list) {
-				/* we need to reset context and flags */
-				memset(&test, 0, sizeof(test));
-			fetch_next:
-				if (!expr->kw->fetch(px, l4, l7, dir, expr, &test)) {
-					/* maybe we could not fetch because of missing data */
-					if (test.flags & ACL_TEST_F_MAY_CHANGE && dir & ACL_PARTIAL)
-						acl_res |= ACL_PAT_MISS;
-					continue;
-				}
-
-				if (test.flags & ACL_TEST_F_RES_SET) {
-					if (test.flags & ACL_TEST_F_RES_PASS)
-						acl_res |= ACL_PAT_PASS;
-					else
-						acl_res |= ACL_PAT_FAIL;
-				}
-				else {
-					if (!eb_is_empty(&expr->pattern_tree)) {
-						/* a tree is present, let's check what type it is */
-						if (expr->kw->match == acl_match_str)
-							acl_res |= acl_lookup_str(&test, expr) ? ACL_PAT_PASS : ACL_PAT_FAIL;
-						else if (expr->kw->match == acl_match_ip)
-							acl_res |= acl_lookup_ip(&test, expr) ? ACL_PAT_PASS : ACL_PAT_FAIL;
-					}
-
-					/* call the match() function for all tests on this value */
-					list_for_each_entry(pattern, &expr->patterns, list) {
-						if (acl_res == ACL_PAT_PASS)
-							break;
-						acl_res |= expr->kw->match(&test, pattern);
-					}
-
-					if ((test.flags & ACL_TEST_F_NULL_MATCH) &&
-					    LIST_ISEMPTY(&expr->patterns) && eb_is_empty(&expr->pattern_tree))
-						acl_res |= expr->kw->match(&test, NULL);
-				}
-				/*
-				 * OK now acl_res holds the result of this expression
-				 * as one of ACL_PAT_FAIL, ACL_PAT_MISS or ACL_PAT_PASS.
-				 *
-				 * Then if (!MISS) we can cache the result, and put
-				 * (test.flags & ACL_TEST_F_VOLATILE) in the cache flags.
-				 *
-				 * FIXME: implement cache.
-				 *
-				 */
-
-				/* now we may have some cleanup to do */
-				if (test.flags & ACL_TEST_F_MUST_FREE) {
-					free(test.ptr);
-					test.len = 0;
-				}
-
-				/* we're ORing these terms, so a single PASS is enough */
-				if (acl_res == ACL_PAT_PASS)
-					break;
-
-				if (test.flags & ACL_TEST_F_FETCH_MORE)
-					goto fetch_next;
-
-				/* sometimes we know the fetched data is subject to change
-				 * later and give another chance for a new match (eg: request
-				 * size, time, ...)
-				 */
-				if (test.flags & ACL_TEST_F_MAY_CHANGE && dir & ACL_PARTIAL)
-					acl_res |= ACL_PAT_MISS;
-			}
-			/*
-			 * Here we have the result of an ACL (cached or not).
-			 * ACLs are combined, negated or not, to form conditions.
-			 */
-
-			if (term->neg)
-				acl_res = acl_neg(acl_res);
-
-			suite_res &= acl_res;
-
-			/* we're ANDing these terms, so a single FAIL is enough */
-			if (suite_res == ACL_PAT_FAIL)
-				break;
-		}
-		cond_res |= suite_res;
-
-		/* we're ORing these terms, so a single PASS is enough */
-		if (cond_res == ACL_PAT_PASS)
-			break;
-	}
-	return cond_res;
-}
-
-
-/* Reports a pointer to the first ACL used in condition <cond> which requires
- * at least one of the USE_FLAGS in <require>. Returns NULL if none matches.
- * The construct is almost the same as for acl_exec_cond() since we're walking
- * down the ACL tree as well. It is important that the tree is really walked
- * through and never cached, because that way, this function can be used as a
- * late check.
- */
-struct acl *cond_find_require(const struct acl_cond *cond, unsigned int require)
-{
-	struct acl_term_suite *suite;
-	struct acl_term *term;
-	struct acl *acl;
-
-	list_for_each_entry(suite, &cond->suites, list) {
-		list_for_each_entry(term, &suite->terms, list) {
-			acl = term->acl;
-			if (acl->requires & require)
-				return acl;
-		}
-	}
-	return NULL;
-}
-
-/*
- * Find targets for userlist and groups in acl. Function returns the number
- * of errors or OK if everything is fine.
- */
-int
-acl_find_targets(struct proxy *p)
-{
-
-	struct acl *acl;
-	struct acl_expr *expr;
-	struct acl_pattern *pattern;
-	struct userlist *ul;
-	int cfgerr = 0;
-
-	list_for_each_entry(acl, &p->acl, list) {
-		list_for_each_entry(expr, &acl->expr, list) {
-			if (strcmp(expr->kw->kw, "srv_is_up") == 0) {
-				struct proxy *px;
-				struct server *srv;
-				char *pname, *sname;
-
-				if (!expr->arg.str || !*expr->arg.str) {
-					Alert("proxy %s: acl %s %s(): missing server name.\n",
-						p->id, acl->name, expr->kw->kw);
-					cfgerr++;
-					continue;
-				}
-
-				pname = expr->arg.str;
-				sname = strrchr(pname, '/');
-
-				if (sname)
-					*sname++ = '\0';
-				else {
-					sname = pname;
-					pname = NULL;
-				}
-
-				px = p;
-				if (pname) {
-					px = findproxy(pname, PR_CAP_BE);
-					if (!px) {
-						Alert("proxy %s: acl %s %s(): unable to find proxy '%s'.\n",
-						      p->id, acl->name, expr->kw->kw, pname);
-						cfgerr++;
-						continue;
-					}
-				}
-
-				srv = findserver(px, sname);
-				if (!srv) {
-					Alert("proxy %s: acl %s %s(): unable to find server '%s'.\n",
-					      p->id, acl->name, expr->kw->kw, sname);
-					cfgerr++;
-					continue;
-				}
-
-				free(expr->arg.str);
-				expr->arg_len = 0;
-				expr->arg.srv = srv;
-				continue;
-			}
-
-			if (strstr(expr->kw->kw, "http_auth") == expr->kw->kw) {
-
-				if (!expr->arg.str || !*expr->arg.str) {
-					Alert("proxy %s: acl %s %s(): missing userlist name.\n",
-						p->id, acl->name, expr->kw->kw);
-					cfgerr++;
-					continue;
-				}
-
-				if (p->uri_auth && p->uri_auth->userlist &&
-				    !strcmp(p->uri_auth->userlist->name, expr->arg.str))
-					ul = p->uri_auth->userlist;
-				else
-					ul = auth_find_userlist(expr->arg.str);
-
-				if (!ul) {
-					Alert("proxy %s: acl %s %s(%s): unable to find userlist.\n",
-						p->id, acl->name, expr->kw->kw, expr->arg.str);
-					cfgerr++;
-					continue;
-				}
-
-				expr->arg_len = 0;
-				expr->arg.ul  = ul;
-			}
-
-
-			if (!strcmp(expr->kw->kw, "http_auth_group")) {
-
-				if (LIST_ISEMPTY(&expr->patterns)) {
-					Alert("proxy %s: acl %s %s(): no groups specified.\n",
-						p->id, acl->name, expr->kw->kw);
-					cfgerr++;
-					continue;
-				}
-
-				list_for_each_entry(pattern, &expr->patterns, list) {
-					pattern->val.group_mask = auth_resolve_groups(expr->arg.ul, pattern->ptr.str);
-
-					free(pattern->ptr.str);
-					pattern->ptr.str = NULL;
-					pattern->len = 0;
-
-					if (!pattern->val.group_mask) {
-						Alert("proxy %s: acl %s %s(): invalid group(s).\n",
-							p->id, acl->name, expr->kw->kw);
-						cfgerr++;
-						continue;
-					}
-				}
-			}
-		}
-	}
-
-	return cfgerr;
-}
-
-/************************************************************************/
-/*             All supported keywords must be declared here.            */
-/************************************************************************/
-
-/* Note: must not be declared <const> as its list will be overwritten */
-static struct acl_kw_list acl_kws = {{ },{
-	{ "always_true", acl_parse_nothing, acl_fetch_true, acl_match_nothing,   ACL_USE_NOTHING },
-	{ "always_false", acl_parse_nothing, acl_fetch_false, acl_match_nothing, ACL_USE_NOTHING },
-	{ "wait_end", acl_parse_nothing, acl_fetch_wait_end, acl_match_nothing,  ACL_USE_NOTHING },
-#if 0
-	{ "time",       acl_parse_time,  acl_fetch_time,   acl_match_time  },
-#endif
-	{ NULL, NULL, NULL, NULL }
-}};
-
-
-__attribute__((constructor))
-static void __acl_init(void)
-{
-	acl_register_keywords(&acl_kws);
-}
-
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/appsession.c b/deps/haproxy-1.4.21/src/appsession.c
deleted file mode 100644
index 48ba698..0000000
--- a/deps/haproxy-1.4.21/src/appsession.c
+++ /dev/null
@@ -1,178 +0,0 @@
-/*
- * AppSession functions.
- *
- * Copyright 2004-2006 Alexander Lazic, Klaus Wagner
- * Copyright 2006-2009 Willy Tarreau
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <stdio.h>
-#include <string.h>
-
-#include <common/appsession.h>
-#include <common/config.h>
-#include <common/memory.h>
-#include <common/sessionhash.h>
-#include <common/ticks.h>
-#include <common/time.h>
-
-#include <types/global.h>
-
-#include <proto/proxy.h>
-#include <proto/task.h>
-
-static struct task *appsess_refresh = NULL;
-struct pool_head *pool2_appsess;
-struct app_pool apools;
-int have_appsession;
-
-int appsession_init(void)
-{
-	static int          initialized = 0;
-	int                 idlen;
-	struct server       *s;
-	struct proxy        *p = proxy;
-    
-	if (!initialized) {
-		pool2_appsess = create_pool("appsess", sizeof(appsess), MEM_F_SHARED);
-		if (pool2_appsess == NULL)
-			return -1;
-
-		if (!appsession_task_init()) {
-			int ser_msize, ses_msize;
-
-			apools.sessid = NULL;
-			apools.serverid = NULL;
-
-			ser_msize = sizeof(void *);
-			ses_msize = sizeof(void *);
-			while (p) {
-				s = p->srv;
-				if (ses_msize < p->appsession_len)
-					ses_msize = p->appsession_len;
-				while (s) {
-					idlen = strlen(s->id);
-					if (ser_msize < idlen)
-						ser_msize = idlen;
-					s = s->next;
-				}
-				p = p->next;
-			}
-			/* we use strings, so reserve space for '\0' */
-			ser_msize ++;
-			ses_msize ++;
-
-			apools.sessid = create_pool("sessid", ses_msize, MEM_F_SHARED);
-			if (!apools.sessid)
-				return -1;
-			apools.serverid = create_pool("serverid", ser_msize, MEM_F_SHARED);
-			if (!apools.serverid)
-				return -1;
-		}
-		else {
-			fprintf(stderr, "appsession_task_init failed\n");
-			return -1;
-		}
-		initialized ++;
-	}
-	return 0;
-}
-
-int appsession_task_init(void)
-{
-	static int initialized = 0;
-	if (!initialized) {
-		if ((appsess_refresh = task_new()) == NULL)
-			return -1;
-
-		appsess_refresh->context = NULL;
-		appsess_refresh->expire = tick_add(now_ms, MS_TO_TICKS(TBLCHKINT));
-		appsess_refresh->process = appsession_refresh;
-		task_queue(appsess_refresh);
-		initialized ++;
-	}
-	return 0;
-}
-
-struct task *appsession_refresh(struct task *t)
-{
-	struct proxy           *p = proxy;
-	struct appsession_hash *htbl;
-	appsess                *element, *back;
-	int                    i;
-
-	while (p) {
-		if (p->appsession_name != NULL) {
-			htbl = &p->htbl_proxy;
-			as_hash_for_each_entry_safe(i, element, back, &p->htbl_proxy, hash_list) {
-				if (tick_is_expired(element->expire, now_ms)) {
-					if ((global.mode & MODE_DEBUG) &&
-					    (!(global.mode & MODE_QUIET) || (global.mode & MODE_VERBOSE))) {
-						int len;
-						/*
-						  on Linux NULL pointers are caught by sprintf, on solaris -> segfault 
-						*/
-						len = sprintf(trash, "appsession_refresh: cleaning up expired Session '%s' on Server %s\n", 
-							      element->sessid, element->serverid?element->serverid:"(null)");
-						if (write(1, trash, len) < 0) /* shut gcc warning */;
-					}
-					/* delete the expired element from within the hash table */
-					LIST_DEL(&element->hash_list);
-					htbl->destroy(element);
-				}/* end if (tv_isle(&asession->expire, &now)) */
-			}
-		}
-		p = p->next;
-	}
-	t->expire = tick_add(now_ms, MS_TO_TICKS(TBLCHKINT)); /* check expiration every 5 seconds */
-	return t;
-} /* end appsession_refresh */
-
-int match_str(const void *key1, const void *key2)
-{
-    appsess *temp1,*temp2;
-    temp1 = (appsess *)key1;
-    temp2 = (appsess *)key2;
-
-    //fprintf(stdout,">>>>>>>>>>>>>>temp1->sessid :%s:\n",temp1->sessid);
-    //fprintf(stdout,">>>>>>>>>>>>>>temp2->sessid :%s:\n",temp2->sessid);
-  
-    return (strcmp(temp1->sessid,temp2->sessid) == 0);
-}/* end match_str */
-
-void destroy(appsess *temp1) {
-	pool_free2(apools.sessid, temp1->sessid);
-	pool_free2(apools.serverid, temp1->serverid);
-	pool_free2(pool2_appsess, temp1);
-} /* end destroy */
-
-void appsession_cleanup( void )
-{
-	struct proxy *p = proxy;
-
-	while(p) {
-		appsession_hash_destroy(&(p->htbl_proxy));
-		p = p->next;
-	}
-
-	if (appsess_refresh) {
-		task_delete(appsess_refresh);
-		task_free(appsess_refresh);
-		appsess_refresh = NULL;
-	}
-
-}/* end appsession_cleanup() */
-
-
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/auth.c b/deps/haproxy-1.4.21/src/auth.c
deleted file mode 100644
index 8ae4858..0000000
--- a/deps/haproxy-1.4.21/src/auth.c
+++ /dev/null
@@ -1,259 +0,0 @@
-/*
- * User authentication & authorization
- *
- * Copyright 2010 Krzysztof Piotr Oledzki <ole@ans.pl>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#ifdef CONFIG_HAP_CRYPT
-/* This is to have crypt() defined on Linux */
-#define _GNU_SOURCE
-
-#ifdef NEED_CRYPT_H
-/* some platforms such as Solaris need this */
-#include <crypt.h>
-#endif
-#endif /* CONFIG_HAP_CRYPT */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-
-#include <common/config.h>
-
-#include <proto/acl.h>
-#include <proto/log.h>
-
-#include <types/auth.h>
-
-struct userlist *userlist = NULL;    /* list of all existing userlists */
-
-/* find targets for selected gropus. The function returns pointer to
- * the userlist struct ot NULL if name is NULL/empty or unresolvable.
- */
-
-struct userlist *
-auth_find_userlist(char *name)
-{
-	struct userlist *l;
-
-	if (!name || !*name)
-		return NULL;
-
-	for (l = userlist; l; l = l->next)
-		if (!strcmp(l->name, name))
-			return l;
-
-	return NULL;
-}
-
-/* find group_mask for selected gropus. The function returns 1 if OK or nothing to do,
- * 0 if case of unresolved groupname.
- * WARING: the function destroys the list (strtok), so it can only be used once.
- */
-
-unsigned int
-auth_resolve_groups(struct userlist *l, char *groups)
-{
-
-	char *group = NULL;
-	unsigned int g, group_mask = 0;
-
-	if (!groups || !*groups)
-		return 0;
-
-	while ((group = strtok(group?NULL:groups," "))) {
-		for (g = 0; g < l->grpcnt; g++)
-			if (!strcmp(l->groups[g], group))
-				break;
-
-		if (g == l->grpcnt) {
-			Alert("No such group '%s' in userlist '%s'.\n",
-				group, l->name);
-			return 0;
-		}
-
-		group_mask |= (1 << g);
-	}
-
-	return group_mask;
-}
-
-struct req_acl_rule *
-parse_auth_cond(const char **args, const char *file, int linenum, struct proxy *proxy)
-{
-	struct req_acl_rule *req_acl;
-	int cur_arg;
-
-	req_acl = (struct req_acl_rule*)calloc(1, sizeof(struct req_acl_rule));
-	if (!req_acl) {
-		Alert("parsing [%s:%d]: out of memory.\n", file, linenum);
-		return NULL;
-	}
-
-	if (!*args[0]) {
-		goto req_error_parsing;
-	} else if (!strcmp(args[0], "allow")) {
-		req_acl->action = PR_REQ_ACL_ACT_ALLOW;
-		cur_arg = 1;
-	} else if (!strcmp(args[0], "deny")) {
-		req_acl->action = PR_REQ_ACL_ACT_DENY;
-		cur_arg = 1;
-	} else if (!strcmp(args[0], "auth")) {
-		req_acl->action = PR_REQ_ACL_ACT_HTTP_AUTH;
-		cur_arg = 1;
-
-		while(*args[cur_arg]) {
-			if (!strcmp(args[cur_arg], "realm")) {
-				req_acl->http_auth.realm = strdup(args[cur_arg + 1]);
-				cur_arg+=2;
-				continue;
-			} else
-				break;
-		}
-	} else {
-req_error_parsing:
-		Alert("parsing [%s:%d]: %s '%s', expects 'allow', 'deny', 'auth'.\n",
-			file, linenum, *args[1]?"unknown parameter":"missing keyword in", args[*args[1]?1:0]);
-		return NULL;
-	}
-
-	if (strcmp(args[cur_arg], "if") == 0 || strcmp(args[cur_arg], "unless") == 0) {
-		struct acl_cond *cond;
-
-		if ((cond = build_acl_cond(file, linenum, proxy, args+cur_arg)) == NULL) {
-			Alert("parsing [%s:%d] : error detected while parsing an 'http-request %s' condition.\n",
-			      file, linenum, args[0]);
-			return NULL;
-		}
-		req_acl->cond = cond;
-	}
-	else if (*args[cur_arg]) {
-		Alert("parsing [%s:%d]: 'http-request %s' expects 'realm' for 'auth' or"
-		      " either 'if' or 'unless' followed by a condition but found '%s'.\n",
-		      file, linenum, args[0], args[cur_arg]);
-		return NULL;
-	}
-
-	return req_acl;
-}
-
-void
-userlist_free(struct userlist *ul)
-{
-	struct userlist *tul;
-	struct auth_users *au, *tau;
-	int i;
-
-	while (ul) {
-		au = ul->users;
-		while (au) {
-			tau = au;
-			au = au->next;
-			free(tau->user);
-			free(tau->pass);
-			free(tau);
-		}
-
-		tul = ul;
-		ul = ul->next;
-
-		for (i = 0; i < tul->grpcnt; i++)
-			free(tul->groups[i]);
-
-		free(tul->name);
-		free(tul);
-	};
-}
-
-void
-req_acl_free(struct list *r) {
-	struct req_acl_rule *tr, *pr;
-
-	list_for_each_entry_safe(pr, tr, r, list) {
-		LIST_DEL(&pr->list);
-		if (pr->action == PR_REQ_ACL_ACT_HTTP_AUTH)
-			free(pr->http_auth.realm);
-
-		free(pr);
-	}
-}
-
-/*
- * Authenticate and authorize user; return 1 if OK, 0 if case of error.
- */
-int
-check_user(struct userlist *ul, unsigned int group_mask, const char *user, const char *pass)
-{
-
-	struct auth_users *u;
-	const char *ep;
-
-#ifdef DEBUG_AUTH
-	fprintf(stderr, "req: userlist=%s, user=%s, pass=%s, group_mask=%u\n",
-		ul->name, user, pass, group_mask);
-#endif
-
-	for (u = ul->users; u; u = u->next)
-		if (!strcmp(user, u->user))
-			break;
-
-	if (!u)
-		return 0;
-
-#ifdef DEBUG_AUTH
-	fprintf(stderr, "cfg: user=%s, pass=%s, group_mask=%u, flags=%X",
-		u->user, u->pass, u->group_mask, u->flags);
-#endif
-
-	/*
-	 * if user matches but group does not,
-	 * it makes no sens to check passwords
-	 */
-	if (group_mask && !(group_mask & u->u.group_mask))
-		return 0;
-
-	if (!(u->flags & AU_O_INSECURE)) {
-#ifdef CONFIG_HAP_CRYPT
-		ep = crypt(pass, u->pass);
-#else
-		return 0;
-#endif
-	} else
-		ep = pass;
-
-#ifdef DEBUG_AUTH
-	fprintf(stderr, ", crypt=%s\n", ep);
-#endif
-
-	if (!strcmp(ep, u->pass))
-		return 1;
-	else
-		return 0;
-}
-
-int
-acl_match_auth(struct acl_test *test, struct acl_pattern *pattern)
-{
-
-	struct userlist *ul = test->ctx.a[0];
-	char *user = test->ctx.a[1];
-	char *pass = test->ctx.a[2];
-	unsigned int group_mask;
-
-	if (pattern)
-		group_mask = pattern->val.group_mask;
-	else
-		group_mask = 0;
-
-	if (check_user(ul, group_mask, user, pass))
-		return ACL_PAT_PASS;
-	else
-		return ACL_PAT_FAIL;
-}
diff --git a/deps/haproxy-1.4.21/src/backend.c b/deps/haproxy-1.4.21/src/backend.c
deleted file mode 100644
index 2e026d8..0000000
--- a/deps/haproxy-1.4.21/src/backend.c
+++ /dev/null
@@ -1,1485 +0,0 @@
-/*
- * Backend variables and functions.
- *
- * Copyright 2000-2009 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <errno.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <syslog.h>
-#include <string.h>
-#include <ctype.h>
-#include <sys/types.h>
-
-#include <common/compat.h>
-#include <common/config.h>
-#include <common/debug.h>
-#include <common/ticks.h>
-#include <common/time.h>
-
-#include <types/global.h>
-
-#include <proto/acl.h>
-#include <proto/backend.h>
-#include <proto/client.h>
-#include <proto/lb_chash.h>
-#include <proto/lb_fwlc.h>
-#include <proto/lb_fwrr.h>
-#include <proto/lb_map.h>
-#include <proto/proto_http.h>
-#include <proto/proto_tcp.h>
-#include <proto/queue.h>
-#include <proto/server.h>
-#include <proto/session.h>
-#include <proto/task.h>
-
-/*
- * This function recounts the number of usable active and backup servers for
- * proxy <p>. These numbers are returned into the p->srv_act and p->srv_bck.
- * This function also recomputes the total active and backup weights. However,
- * it does not update tot_weight nor tot_used. Use update_backend_weight() for
- * this.
- */
-void recount_servers(struct proxy *px)
-{
-	struct server *srv;
-
-	px->srv_act = px->srv_bck = 0;
-	px->lbprm.tot_wact = px->lbprm.tot_wbck = 0;
-	px->lbprm.fbck = NULL;
-	for (srv = px->srv; srv != NULL; srv = srv->next) {
-		if (!srv_is_usable(srv->state, srv->eweight))
-			continue;
-
-		if (srv->state & SRV_BACKUP) {
-			if (!px->srv_bck &&
-			    !(px->options & PR_O_USE_ALL_BK))
-				px->lbprm.fbck = srv;
-			px->srv_bck++;
-			px->lbprm.tot_wbck += srv->eweight;
-		} else {
-			px->srv_act++;
-			px->lbprm.tot_wact += srv->eweight;
-		}
-	}
-}
-
-/* This function simply updates the backend's tot_weight and tot_used values
- * after servers weights have been updated. It is designed to be used after
- * recount_servers() or equivalent.
- */
-void update_backend_weight(struct proxy *px)
-{
-	if (px->srv_act) {
-		px->lbprm.tot_weight = px->lbprm.tot_wact;
-		px->lbprm.tot_used   = px->srv_act;
-	}
-	else if (px->lbprm.fbck) {
-		/* use only the first backup server */
-		px->lbprm.tot_weight = px->lbprm.fbck->eweight;
-		px->lbprm.tot_used = 1;
-	}
-	else {
-		px->lbprm.tot_weight = px->lbprm.tot_wbck;
-		px->lbprm.tot_used   = px->srv_bck;
-	}
-}
-
-/*
- * This function tries to find a running server for the proxy <px> following
- * the source hash method. Depending on the number of active/backup servers,
- * it will either look for active servers, or for backup servers.
- * If any server is found, it will be returned. If no valid server is found,
- * NULL is returned.
- */
-struct server *get_server_sh(struct proxy *px, const char *addr, int len)
-{
-	unsigned int h, l;
-
-	if (px->lbprm.tot_weight == 0)
-		return NULL;
-
-	l = h = 0;
-
-	/* note: we won't hash if there's only one server left */
-	if (px->lbprm.tot_used == 1)
-		goto hash_done;
-
-	while ((l + sizeof (int)) <= len) {
-		h ^= ntohl(*(unsigned int *)(&addr[l]));
-		l += sizeof (int);
-	}
- hash_done:
-	if (px->lbprm.algo & BE_LB_LKUP_CHTREE)
-		return chash_get_server_hash(px, h);
-	else
-		return map_get_server_hash(px, h);
-}
-
-/*
- * This function tries to find a running server for the proxy <px> following
- * the URI hash method. In order to optimize cache hits, the hash computation
- * ends at the question mark. Depending on the number of active/backup servers,
- * it will either look for active servers, or for backup servers.
- * If any server is found, it will be returned. If no valid server is found,
- * NULL is returned.
- *
- * This code was contributed by Guillaume Dallaire, who also selected this hash
- * algorithm out of a tens because it gave him the best results.
- *
- */
-struct server *get_server_uh(struct proxy *px, char *uri, int uri_len)
-{
-	unsigned long hash = 0;
-	int c;
-	int slashes = 0;
-
-	if (px->lbprm.tot_weight == 0)
-		return NULL;
-
-	/* note: we won't hash if there's only one server left */
-	if (px->lbprm.tot_used == 1)
-		goto hash_done;
-
-	if (px->uri_len_limit)
-		uri_len = MIN(uri_len, px->uri_len_limit);
-
-	while (uri_len--) {
-		c = *uri++;
-		if (c == '/') {
-			slashes++;
-			if (slashes == px->uri_dirs_depth1) /* depth+1 */
-				break;
-		}
-		else if (c == '?')
-			break;
-
-		hash = c + (hash << 6) + (hash << 16) - hash;
-	}
- hash_done:
-	if (px->lbprm.algo & BE_LB_LKUP_CHTREE)
-		return chash_get_server_hash(px, hash);
-	else
-		return map_get_server_hash(px, hash);
-}
-
-/* 
- * This function tries to find a running server for the proxy <px> following
- * the URL parameter hash method. It looks for a specific parameter in the
- * URL and hashes it to compute the server ID. This is useful to optimize
- * performance by avoiding bounces between servers in contexts where sessions
- * are shared but cookies are not usable. If the parameter is not found, NULL
- * is returned. If any server is found, it will be returned. If no valid server
- * is found, NULL is returned.
- */
-struct server *get_server_ph(struct proxy *px, const char *uri, int uri_len)
-{
-	unsigned long hash = 0;
-	const char *p;
-	const char *params;
-	int plen;
-
-	/* when tot_weight is 0 then so is srv_count */
-	if (px->lbprm.tot_weight == 0)
-		return NULL;
-
-	if ((p = memchr(uri, '?', uri_len)) == NULL)
-		return NULL;
-
-	p++;
-
-	uri_len -= (p - uri);
-	plen = px->url_param_len;
-	params = p;
-
-	while (uri_len > plen) {
-		/* Look for the parameter name followed by an equal symbol */
-		if (params[plen] == '=') {
-			if (memcmp(params, px->url_param_name, plen) == 0) {
-				/* OK, we have the parameter here at <params>, and
-				 * the value after the equal sign, at <p>
-				 * skip the equal symbol
-				 */
-				p += plen + 1;
-				uri_len -= plen + 1;
-
-				while (uri_len && *p != '&') {
-					hash = *p + (hash << 6) + (hash << 16) - hash;
-					uri_len--;
-					p++;
-				}
-				if (px->lbprm.algo & BE_LB_LKUP_CHTREE)
-					return chash_get_server_hash(px, hash);
-				else
-					return map_get_server_hash(px, hash);
-			}
-		}
-		/* skip to next parameter */
-		p = memchr(params, '&', uri_len);
-		if (!p)
-			return NULL;
-		p++;
-		uri_len -= (p - params);
-		params = p;
-	}
-	return NULL;
-}
-
-/*
- * this does the same as the previous server_ph, but check the body contents
- */
-struct server *get_server_ph_post(struct session *s)
-{
-	unsigned long    hash = 0;
-	struct http_txn *txn  = &s->txn;
-	struct buffer   *req  = s->req;
-	struct http_msg *msg  = &txn->req;
-	struct proxy    *px   = s->be;
-	unsigned int     plen = px->url_param_len;
-	unsigned long    len  = msg->body_len;
-	const char      *params = req->data + msg->sov;
-	const char      *p    = params;
-
-	if (len > req->l - (msg->sov - msg->som))
-		len = req->l - (msg->sov - msg->som);
-
-	if (len == 0)
-		return NULL;
-
-	if (px->lbprm.tot_weight == 0)
-		return NULL;
-
-	while (len > plen) {
-		/* Look for the parameter name followed by an equal symbol */
-		if (params[plen] == '=') {
-			if (memcmp(params, px->url_param_name, plen) == 0) {
-				/* OK, we have the parameter here at <params>, and
-				 * the value after the equal sign, at <p>
-				 * skip the equal symbol
-				 */
-				p += plen + 1;
-				len -= plen + 1;
-
-				while (len && *p != '&') {
-					if (unlikely(!HTTP_IS_TOKEN(*p))) {
-						/* if in a POST, body must be URI encoded or it's not a URI.
-						 * Do not interprete any possible binary data as a parameter.
-						 */
-						if (likely(HTTP_IS_LWS(*p))) /* eol, uncertain uri len */
-							break;
-						return NULL;                 /* oh, no; this is not uri-encoded.
-									      * This body does not contain parameters.
-									      */
-					}
-					hash = *p + (hash << 6) + (hash << 16) - hash;
-					len--;
-					p++;
-					/* should we break if vlen exceeds limit? */
-				}
-				if (px->lbprm.algo & BE_LB_LKUP_CHTREE)
-					return chash_get_server_hash(px, hash);
-				else
-					return map_get_server_hash(px, hash);
-			}
-		}
-		/* skip to next parameter */
-		p = memchr(params, '&', len);
-		if (!p)
-			return NULL;
-		p++;
-		len -= (p - params);
-		params = p;
-	}
-	return NULL;
-}
-
-
-/*
- * This function tries to find a running server for the proxy <px> following
- * the Header parameter hash method. It looks for a specific parameter in the
- * URL and hashes it to compute the server ID. This is useful to optimize
- * performance by avoiding bounces between servers in contexts where sessions
- * are shared but cookies are not usable. If the parameter is not found, NULL
- * is returned. If any server is found, it will be returned. If no valid server
- * is found, NULL is returned.
- */
-struct server *get_server_hh(struct session *s)
-{
-	unsigned long    hash = 0;
-	struct http_txn *txn  = &s->txn;
-	struct http_msg *msg  = &txn->req;
-	struct proxy    *px   = s->be;
-	unsigned int     plen = px->hh_len;
-	unsigned long    len;
-	struct hdr_ctx   ctx;
-	const char      *p;
-
-	/* tot_weight appears to mean srv_count */
-	if (px->lbprm.tot_weight == 0)
-		return NULL;
-
-	ctx.idx = 0;
-
-	/* if the message is chunked, we skip the chunk size, but use the value as len */
-	http_find_header2(px->hh_name, plen, msg->sol, &txn->hdr_idx, &ctx);
-
-	/* if the header is not found or empty, let's fallback to round robin */
-	if (!ctx.idx || !ctx.vlen)
-		return NULL;
-
-	/* note: we won't hash if there's only one server left */
-	if (px->lbprm.tot_used == 1)
-		goto hash_done;
-
-	/* Found a the hh_name in the headers.
-	 * we will compute the hash based on this value ctx.val.
-	 */
-	len = ctx.vlen;
-	p = (char *)ctx.line + ctx.val;
-	if (!px->hh_match_domain) {
-		while (len) {
-			hash = *p + (hash << 6) + (hash << 16) - hash;
-			len--;
-			p++;
-		}
-	} else {
-		int dohash = 0;
-		p += len - 1;
-		/* special computation, use only main domain name, not tld/host
-		 * going back from the end of string, start hashing at first
-		 * dot stop at next.
-		 * This is designed to work with the 'Host' header, and requires
-		 * a special option to activate this.
-		 */
-		while (len) {
-			if (*p == '.') {
-				if (!dohash)
-					dohash = 1;
-				else
-					break;
-			} else {
-				if (dohash)
-					hash = *p + (hash << 6) + (hash << 16) - hash;
-			}
-			len--;
-			p--;
-		}
-	}
- hash_done:
-	if (px->lbprm.algo & BE_LB_LKUP_CHTREE)
-		return chash_get_server_hash(px, hash);
-	else
-		return map_get_server_hash(px, hash);
-}
-
-struct server *get_server_rch(struct session *s)
-{
-	unsigned long    hash = 0;
-	struct proxy    *px   = s->be;
-	unsigned long    len;
-	const char      *p;
-	int              ret;
-	struct acl_expr  expr;
-	struct acl_test  test;
-
-	/* tot_weight appears to mean srv_count */
-	if (px->lbprm.tot_weight == 0)
-		return NULL;
-
-	memset(&expr, 0, sizeof(expr));
-	memset(&test, 0, sizeof(test));
-
-	expr.arg.str = px->hh_name;
-	expr.arg_len = px->hh_len;
-
-	ret = acl_fetch_rdp_cookie(px, s, NULL, ACL_DIR_REQ, &expr, &test);
-	if (ret == 0 || (test.flags & ACL_TEST_F_MAY_CHANGE) || test.len == 0)
-		return NULL;
-
-	/* note: we won't hash if there's only one server left */
-	if (px->lbprm.tot_used == 1)
-		goto hash_done;
-
-	/* Found a the hh_name in the headers.
-	 * we will compute the hash based on this value ctx.val.
-	 */
-	len = test.len;
-	p = (char *)test.ptr;
-	while (len) {
-		hash = *p + (hash << 6) + (hash << 16) - hash;
-		len--;
-		p++;
-	}
- hash_done:
-	if (px->lbprm.algo & BE_LB_LKUP_CHTREE)
-		return chash_get_server_hash(px, hash);
-	else
-		return map_get_server_hash(px, hash);
-}
- 
-/*
- * This function applies the load-balancing algorithm to the session, as
- * defined by the backend it is assigned to. The session is then marked as
- * 'assigned'.
- *
- * This function MAY NOT be called with SN_ASSIGNED already set. If the session
- * had a server previously assigned, it is rebalanced, trying to avoid the same
- * server.
- * The function tries to keep the original connection slot if it reconnects to
- * the same server, otherwise it releases it and tries to offer it.
- *
- * It is illegal to call this function with a session in a queue.
- *
- * It may return :
- *   SRV_STATUS_OK       if everything is OK. Session assigned to ->srv
- *   SRV_STATUS_NOSRV    if no server is available. Session is not ASSIGNED
- *   SRV_STATUS_FULL     if all servers are saturated. Session is not ASSIGNED
- *   SRV_STATUS_INTERNAL for other unrecoverable errors.
- *
- * Upon successful return, the session flag SN_ASSIGNED is set to indicate that
- * it does not need to be called anymore. This means that s->srv can be trusted
- * in balance and direct modes.
- *
- */
-
-int assign_server(struct session *s)
-{
-
-	struct server *conn_slot;
-	int err;
-
-#ifdef DEBUG_FULL
-	fprintf(stderr,"assign_server : s=%p\n",s);
-#endif
-
-	err = SRV_STATUS_INTERNAL;
-	if (unlikely(s->pend_pos || s->flags & SN_ASSIGNED))
-		goto out_err;
-
-	s->prev_srv = s->prev_srv;
-	conn_slot = s->srv_conn;
-
-	/* We have to release any connection slot before applying any LB algo,
-	 * otherwise we may erroneously end up with no available slot.
-	 */
-	if (conn_slot)
-		sess_change_server(s, NULL);
-
-	/* We will now try to find the good server and store it into <s->srv>.
-	 * Note that <s->srv> may be NULL in case of dispatch or proxy mode,
-	 * as well as if no server is available (check error code).
-	 */
-
-	s->srv = NULL;
-	if (s->be->lbprm.algo & BE_LB_KIND) {
-		/* we must check if we have at least one server available */
-		if (!s->be->lbprm.tot_weight) {
-			err = SRV_STATUS_NOSRV;
-			goto out;
-		}
-
-		/* First check whether we need to fetch some data or simply call
-		 * the LB lookup function. Only the hashing functions will need
-		 * some input data in fact, and will support multiple algorithms.
-		 */
-		switch (s->be->lbprm.algo & BE_LB_LKUP) {
-		case BE_LB_LKUP_RRTREE:
-			s->srv = fwrr_get_next_server(s->be, s->prev_srv);
-			break;
-
-		case BE_LB_LKUP_LCTREE:
-			s->srv = fwlc_get_next_server(s->be, s->prev_srv);
-			break;
-
-		case BE_LB_LKUP_CHTREE:
-		case BE_LB_LKUP_MAP:
-			if ((s->be->lbprm.algo & BE_LB_KIND) == BE_LB_KIND_RR) {
-				if (s->be->lbprm.algo & BE_LB_LKUP_CHTREE)
-					s->srv = chash_get_next_server(s->be, s->prev_srv);
-				else
-					s->srv = map_get_server_rr(s->be, s->prev_srv);
-				break;
-			}
-			else if ((s->be->lbprm.algo & BE_LB_KIND) != BE_LB_KIND_HI) {
-				/* unknown balancing algorithm */
-				err = SRV_STATUS_INTERNAL;
-				goto out;
-			}
-
-			switch (s->be->lbprm.algo & BE_LB_PARM) {
-			case BE_LB_HASH_SRC:
-				if (s->cli_addr.ss_family == AF_INET)
-					s->srv = get_server_sh(s->be,
-					                       (void *)&((struct sockaddr_in *)&s->cli_addr)->sin_addr,
-					                       4);
-				else if (s->cli_addr.ss_family == AF_INET6)
-					s->srv = get_server_sh(s->be,
-					                       (void *)&((struct sockaddr_in6 *)&s->cli_addr)->sin6_addr,
-					                       16);
-				else {
-					/* unknown IP family */
-					err = SRV_STATUS_INTERNAL;
-					goto out;
-				}
-				break;
-
-			case BE_LB_HASH_URI:
-				/* URI hashing */
-				if (s->txn.req.msg_state < HTTP_MSG_BODY)
-					break;
-				s->srv = get_server_uh(s->be,
-						       s->txn.req.sol + s->txn.req.sl.rq.u,
-						       s->txn.req.sl.rq.u_l);
-				break;
-
-			case BE_LB_HASH_PRM:
-				/* URL Parameter hashing */
-				if (s->txn.req.msg_state < HTTP_MSG_BODY)
-					break;
-
-				s->srv = get_server_ph(s->be,
-						       s->txn.req.sol + s->txn.req.sl.rq.u,
-						       s->txn.req.sl.rq.u_l);
-
-				if (!s->srv && s->txn.meth == HTTP_METH_POST)
-					s->srv = get_server_ph_post(s);
-				break;
-
-			case BE_LB_HASH_HDR:
-				/* Header Parameter hashing */
-				if (s->txn.req.msg_state < HTTP_MSG_BODY)
-					break;
-				s->srv = get_server_hh(s);
-				break;
-
-			case BE_LB_HASH_RDP:
-				/* RDP Cookie hashing */
-				s->srv = get_server_rch(s);
-				break;
-
-			default:
-				/* unknown balancing algorithm */
-				err = SRV_STATUS_INTERNAL;
-				goto out;
-			}
-
-			/* If the hashing parameter was not found, let's fall
-			 * back to round robin on the map.
-			 */
-			if (!s->srv) {
-				if (s->be->lbprm.algo & BE_LB_LKUP_CHTREE)
-					s->srv = chash_get_next_server(s->be, s->prev_srv);
-				else
-					s->srv = map_get_server_rr(s->be, s->prev_srv);
-			}
-
-			/* end of map-based LB */
-			break;
-
-		default:
-			/* unknown balancing algorithm */
-			err = SRV_STATUS_INTERNAL;
-			goto out;
-		}
-
-		if (!s->srv) {
-			err = SRV_STATUS_FULL;
-			goto out;
-		}
-		else if (s->srv != s->prev_srv) {
-			s->be->counters.cum_lbconn++;
-			s->srv->counters.cum_lbconn++;
-		}
-	}
-	else if (s->be->options & PR_O_HTTP_PROXY) {
-		if (!s->srv_addr.sin_addr.s_addr) {
-			err = SRV_STATUS_NOSRV;
-			goto out;
-		}
-	}
-	else if (!*(int *)&s->be->dispatch_addr.sin_addr &&
-		 !(s->be->options & PR_O_TRANSP)) {
-		err = SRV_STATUS_NOSRV;
-		goto out;
-	}
-
-	s->flags |= SN_ASSIGNED;
-	err = SRV_STATUS_OK;
- out:
-
-	/* Either we take back our connection slot, or we offer it to someone
-	 * else if we don't need it anymore.
-	 */
-	if (conn_slot) {
-		if (conn_slot == s->srv) {
-			sess_change_server(s, s->srv);
-		} else {
-			if (may_dequeue_tasks(conn_slot, s->be))
-				process_srv_queue(conn_slot);
-		}
-	}
-
- out_err:
-	return err;
-}
-
-
-/*
- * This function assigns a server address to a session, and sets SN_ADDR_SET.
- * The address is taken from the currently assigned server, or from the
- * dispatch or transparent address.
- *
- * It may return :
- *   SRV_STATUS_OK       if everything is OK.
- *   SRV_STATUS_INTERNAL for other unrecoverable errors.
- *
- * Upon successful return, the session flag SN_ADDR_SET is set. This flag is
- * not cleared, so it's to the caller to clear it if required.
- *
- */
-int assign_server_address(struct session *s)
-{
-#ifdef DEBUG_FULL
-	fprintf(stderr,"assign_server_address : s=%p\n",s);
-#endif
-
-	if ((s->flags & SN_DIRECT) || (s->be->lbprm.algo & BE_LB_KIND)) {
-		/* A server is necessarily known for this session */
-		if (!(s->flags & SN_ASSIGNED))
-			return SRV_STATUS_INTERNAL;
-
-		s->srv_addr = s->srv->addr;
-
-		if (!s->srv_addr.sin_addr.s_addr) {
-			/* if the server has no address, we use the same address
-			 * the client asked, which is handy for remapping ports
-			 * locally on multiple addresses at once.
-			 */
-			if (!(s->be->options & PR_O_TRANSP) && !(s->flags & SN_FRT_ADDR_SET))
-				get_frt_addr(s);
-
-			s->srv_addr.sin_addr = ((struct sockaddr_in *)&s->frt_addr)->sin_addr;
-		}
-
-		/* if this server remaps proxied ports, we'll use
-		 * the port the client connected to with an offset. */
-		if (s->srv->state & SRV_MAPPORTS) {
-			if (!(s->be->options & PR_O_TRANSP) && !(s->flags & SN_FRT_ADDR_SET))
-				get_frt_addr(s);
-			if (s->frt_addr.ss_family == AF_INET) {
-				s->srv_addr.sin_port = htons(ntohs(s->srv_addr.sin_port) +
-							     ntohs(((struct sockaddr_in *)&s->frt_addr)->sin_port));
-			} else {
-				s->srv_addr.sin_port = htons(ntohs(s->srv_addr.sin_port) +
-							     ntohs(((struct sockaddr_in6 *)&s->frt_addr)->sin6_port));
-			}
-		}
-	}
-	else if (*(int *)&s->be->dispatch_addr.sin_addr) {
-		/* connect to the defined dispatch addr */
-		s->srv_addr = s->be->dispatch_addr;
-	}
-	else if (s->be->options & PR_O_TRANSP) {
-		/* in transparent mode, use the original dest addr if no dispatch specified */
-		if (!(s->flags & SN_FRT_ADDR_SET))
-			get_frt_addr(s);
-
-		memcpy(&s->srv_addr, &s->frt_addr, MIN(sizeof(s->srv_addr), sizeof(s->frt_addr)));
-		/* when we support IPv6 on the backend, we may add other tests */
-		//qfprintf(stderr, "Cannot get original server address.\n");
-		//return SRV_STATUS_INTERNAL;
-	}
-	else if (s->be->options & PR_O_HTTP_PROXY) {
-		/* If HTTP PROXY option is set, then server is already assigned
-		 * during incoming client request parsing. */
-	}
-	else {
-		/* no server and no LB algorithm ! */
-		return SRV_STATUS_INTERNAL;
-	}
-
-	s->flags |= SN_ADDR_SET;
-	return SRV_STATUS_OK;
-}
-
-
-/* This function assigns a server to session <s> if required, and can add the
- * connection to either the assigned server's queue or to the proxy's queue.
- * If ->srv_conn is set, the session is first released from the server.
- * It may also be called with SN_DIRECT and/or SN_ASSIGNED though. It will
- * be called before any connection and after any retry or redispatch occurs.
- *
- * It is not allowed to call this function with a session in a queue.
- *
- * Returns :
- *
- *   SRV_STATUS_OK       if everything is OK.
- *   SRV_STATUS_NOSRV    if no server is available. s->srv = NULL.
- *   SRV_STATUS_QUEUED   if the connection has been queued.
- *   SRV_STATUS_FULL     if the server(s) is/are saturated and the
- *                       connection could not be queued in s->srv,
- *                       which may be NULL if we queue on the backend.
- *   SRV_STATUS_INTERNAL for other unrecoverable errors.
- *
- */
-int assign_server_and_queue(struct session *s)
-{
-	struct pendconn *p;
-	int err;
-
-	if (s->pend_pos)
-		return SRV_STATUS_INTERNAL;
-
-	err = SRV_STATUS_OK;
-	if (!(s->flags & SN_ASSIGNED)) {
-		err = assign_server(s);
-		if (s->prev_srv) {
-			/* This session was previously assigned to a server. We have to
-			 * update the session's and the server's stats :
-			 *  - if the server changed :
-			 *    - set TX_CK_DOWN if txn.flags was TX_CK_VALID
-			 *    - set SN_REDISP if it was successfully redispatched
-			 *    - increment srv->redispatches and be->redispatches
-			 *  - if the server remained the same : update retries.
-			 */
-
-			if (s->prev_srv != s->srv) {
-				if ((s->txn.flags & TX_CK_MASK) == TX_CK_VALID) {
-					s->txn.flags &= ~TX_CK_MASK;
-					s->txn.flags |= TX_CK_DOWN;
-				}
-				s->flags |= SN_REDISP;
-				s->prev_srv->counters.redispatches++;
-				s->be->counters.redispatches++;
-			} else {
-				s->prev_srv->counters.retries++;
-				s->be->counters.retries++;
-			}
-		}
-	}
-
-	switch (err) {
-	case SRV_STATUS_OK:
-		/* we have SN_ASSIGNED set */
-		if (!s->srv)
-			return SRV_STATUS_OK;   /* dispatch or proxy mode */
-
-		/* If we already have a connection slot, no need to check any queue */
-		if (s->srv_conn == s->srv)
-			return SRV_STATUS_OK;
-
-		/* OK, this session already has an assigned server, but no
-		 * connection slot yet. Either it is a redispatch, or it was
-		 * assigned from persistence information (direct mode).
-		 */
-		if ((s->flags & SN_REDIRECTABLE) && s->srv->rdr_len) {
-			/* server scheduled for redirection, and already assigned. We
-			 * don't want to go further nor check the queue.
-			 */
-			sess_change_server(s, s->srv); /* not really needed in fact */
-			return SRV_STATUS_OK;
-		}
-
-		/* We might have to queue this session if the assigned server is full.
-		 * We know we have to queue it into the server's queue, so if a maxqueue
-		 * is set on the server, we must also check that the server's queue is
-		 * not full, in which case we have to return FULL.
-		 */
-		if (s->srv->maxconn &&
-		    (s->srv->nbpend || s->srv->served >= srv_dynamic_maxconn(s->srv))) {
-
-			if (s->srv->maxqueue > 0 && s->srv->nbpend >= s->srv->maxqueue)
-				return SRV_STATUS_FULL;
-
-			p = pendconn_add(s);
-			if (p)
-				return SRV_STATUS_QUEUED;
-			else
-				return SRV_STATUS_INTERNAL;
-		}
-
-		/* OK, we can use this server. Let's reserve our place */
-		sess_change_server(s, s->srv);
-		return SRV_STATUS_OK;
-
-	case SRV_STATUS_FULL:
-		/* queue this session into the proxy's queue */
-		p = pendconn_add(s);
-		if (p)
-			return SRV_STATUS_QUEUED;
-		else
-			return SRV_STATUS_INTERNAL;
-
-	case SRV_STATUS_NOSRV:
-		return err;
-
-	case SRV_STATUS_INTERNAL:
-		return err;
-
-	default:
-		return SRV_STATUS_INTERNAL;
-	}
-}
-
-/* If an explicit source binding is specified on the server and/or backend, and
- * this source makes use of the transparent proxy, then it is extracted now and
- * assigned to the session's from_addr entry.
- */
-static void assign_tproxy_address(struct session *s)
-{
-#if defined(CONFIG_HAP_CTTPROXY) || defined(CONFIG_HAP_LINUX_TPROXY)
-	if (s->srv != NULL && s->srv->state & SRV_BIND_SRC) {
-		switch (s->srv->state & SRV_TPROXY_MASK) {
-		case SRV_TPROXY_ADDR:
-			s->from_addr = *(struct sockaddr_in *)&s->srv->tproxy_addr;
-			break;
-		case SRV_TPROXY_CLI:
-		case SRV_TPROXY_CIP:
-			/* FIXME: what can we do if the client connects in IPv6 ? */
-			s->from_addr = *(struct sockaddr_in *)&s->cli_addr;
-			break;
-		case SRV_TPROXY_DYN:
-			if (s->srv->bind_hdr_occ) {
-				/* bind to the IP in a header */
-				s->from_addr.sin_port = 0;
-				s->from_addr.sin_addr.s_addr = htonl(get_ip_from_hdr2(&s->txn.req,
-										s->srv->bind_hdr_name,
-										s->srv->bind_hdr_len,
-										&s->txn.hdr_idx,
-										s->srv->bind_hdr_occ));
-			}
-			break;
-		default:
-			memset(&s->from_addr, 0, sizeof(s->from_addr));
-		}
-	}
-	else if (s->be->options & PR_O_BIND_SRC) {
-		switch (s->be->options & PR_O_TPXY_MASK) {
-		case PR_O_TPXY_ADDR:
-			s->from_addr = *(struct sockaddr_in *)&s->be->tproxy_addr;
-			break;
-		case PR_O_TPXY_CLI:
-		case PR_O_TPXY_CIP:
-			/* FIXME: what can we do if the client connects in IPv6 ? */
-			s->from_addr = *(struct sockaddr_in *)&s->cli_addr;
-			break;
-		case PR_O_TPXY_DYN:
-			if (s->be->bind_hdr_occ) {
-				/* bind to the IP in a header */
-				s->from_addr.sin_port = 0;
-				s->from_addr.sin_addr.s_addr = htonl(get_ip_from_hdr2(&s->txn.req,
-										s->be->bind_hdr_name,
-										s->be->bind_hdr_len,
-										&s->txn.hdr_idx,
-										s->be->bind_hdr_occ));
-			}
-			break;
-		default:
-			memset(&s->from_addr, 0, sizeof(s->from_addr));
-		}
-	}
-#endif
-}
-
-
-/*
- * This function initiates a connection to the server assigned to this session
- * (s->srv, s->srv_addr). It will assign a server if none is assigned yet.
- * It can return one of :
- *  - SN_ERR_NONE if everything's OK
- *  - SN_ERR_SRVTO if there are no more servers
- *  - SN_ERR_SRVCL if the connection was refused by the server
- *  - SN_ERR_PRXCOND if the connection has been limited by the proxy (maxconn)
- *  - SN_ERR_RESOURCE if a system resource is lacking (eg: fd limits, ports, ...)
- *  - SN_ERR_INTERNAL for any other purely internal errors
- * Additionnally, in the case of SN_ERR_RESOURCE, an emergency log will be emitted.
- */
-int connect_server(struct session *s)
-{
-	int err;
-
-	if (!(s->flags & SN_ADDR_SET)) {
-		err = assign_server_address(s);
-		if (err != SRV_STATUS_OK)
-			return SN_ERR_INTERNAL;
-	}
-
-	if (!s->req->cons->connect)
-		return SN_ERR_INTERNAL;
-
-	assign_tproxy_address(s);
-
-	err = s->req->cons->connect(s->req->cons, s->be, s->srv,
-				    (struct sockaddr *)&s->srv_addr,
-				    (struct sockaddr *)&s->from_addr);
-
-	if (err != SN_ERR_NONE)
-		return err;
-
-	if (s->srv) {
-		s->flags |= SN_CURR_SESS;
-		s->srv->cur_sess++;
-		if (s->srv->cur_sess > s->srv->counters.cur_sess_max)
-			s->srv->counters.cur_sess_max = s->srv->cur_sess;
-		if (s->be->lbprm.server_take_conn)
-			s->be->lbprm.server_take_conn(s->srv);
-	}
-
-	return SN_ERR_NONE;  /* connection is OK */
-}
-
-
-/* This function performs the "redispatch" part of a connection attempt. It
- * will assign a server if required, queue the connection if required, and
- * handle errors that might arise at this level. It can change the server
- * state. It will return 1 if it encounters an error, switches the server
- * state, or has to queue a connection. Otherwise, it will return 0 indicating
- * that the connection is ready to use.
- */
-
-int srv_redispatch_connect(struct session *t)
-{
-	int conn_err;
-
-	/* We know that we don't have any connection pending, so we will
-	 * try to get a new one, and wait in this state if it's queued
-	 */
- redispatch:
-	conn_err = assign_server_and_queue(t);
-	switch (conn_err) {
-	case SRV_STATUS_OK:
-		break;
-
-	case SRV_STATUS_FULL:
-		/* The server has reached its maxqueue limit. Either PR_O_REDISP is set
-		 * and we can redispatch to another server, or it is not and we return
-		 * 503. This only makes sense in DIRECT mode however, because normal LB
-		 * algorithms would never select such a server, and hash algorithms
-		 * would bring us on the same server again. Note that t->srv is set in
-		 * this case.
-		 */
-		if (((t->flags & (SN_DIRECT|SN_FORCE_PRST)) == SN_DIRECT) &&
-		    (t->be->options & PR_O_REDISP)) {
-			t->flags &= ~(SN_DIRECT | SN_ASSIGNED | SN_ADDR_SET);
-			t->prev_srv = t->srv;
-			goto redispatch;
-		}
-
-		if (!t->req->cons->err_type) {
-			t->req->cons->err_type = SI_ET_QUEUE_ERR;
-			t->req->cons->err_loc = t->srv;
-		}
-
-		t->srv->counters.failed_conns++;
-		t->be->counters.failed_conns++;
-		return 1;
-
-	case SRV_STATUS_NOSRV:
-		/* note: it is guaranteed that t->srv == NULL here */
-		if (!t->req->cons->err_type) {
-			t->req->cons->err_type = SI_ET_CONN_ERR;
-			t->req->cons->err_loc = NULL;
-		}
-
-		t->be->counters.failed_conns++;
-		return 1;
-
-	case SRV_STATUS_QUEUED:
-		t->req->cons->exp = tick_add_ifset(now_ms, t->be->timeout.queue);
-		t->req->cons->state = SI_ST_QUE;
-		/* do nothing else and do not wake any other session up */
-		return 1;
-
-	case SRV_STATUS_INTERNAL:
-	default:
-		if (!t->req->cons->err_type) {
-			t->req->cons->err_type = SI_ET_CONN_OTHER;
-			t->req->cons->err_loc = t->srv;
-		}
-
-		if (t->srv)
-			srv_inc_sess_ctr(t->srv);
-		if (t->srv)
-			t->srv->counters.failed_conns++;
-		t->be->counters.failed_conns++;
-
-		/* release other sessions waiting for this server */
-		if (may_dequeue_tasks(t->srv, t->be))
-			process_srv_queue(t->srv);
-		return 1;
-	}
-	/* if we get here, it's because we got SRV_STATUS_OK, which also
-	 * means that the connection has not been queued.
-	 */
-	return 0;
-}
-
-int be_downtime(struct proxy *px) {
-	if (px->lbprm.tot_weight && px->last_change < now.tv_sec)  // ignore negative time
-		return px->down_time;
-
-	return now.tv_sec - px->last_change + px->down_time;
-}
-
-/*
- * This function returns a string containing the balancing
- * mode of the proxy in a format suitable for stats.
- */
-
-const char *backend_lb_algo_str(int algo) {
-
-	if (algo == BE_LB_ALGO_RR)
-		return "roundrobin";
-	else if (algo == BE_LB_ALGO_SRR)
-		return "static-rr";
-	else if (algo == BE_LB_ALGO_LC)
-		return "leastconn";
-	else if (algo == BE_LB_ALGO_SH)
-		return "source";
-	else if (algo == BE_LB_ALGO_UH)
-		return "uri";
-	else if (algo == BE_LB_ALGO_PH)
-		return "url_param";
-	else if (algo == BE_LB_ALGO_HH)
-		return "hdr";
-	else if (algo == BE_LB_ALGO_RCH)
-		return "rdp-cookie";
-	else
-		return NULL;
-}
-
-/* This function parses a "balance" statement in a backend section describing
- * <curproxy>. It returns -1 if there is any error, otherwise zero. If it
- * returns -1, it may write an error message into ther <err> buffer, for at
- * most <errlen> bytes, trailing zero included. The trailing '\n' will not be
- * written. The function must be called with <args> pointing to the first word
- * after "balance".
- */
-int backend_parse_balance(const char **args, char *err, int errlen, struct proxy *curproxy)
-{
-	if (!*(args[0])) {
-		/* if no option is set, use round-robin by default */
-		curproxy->lbprm.algo &= ~BE_LB_ALGO;
-		curproxy->lbprm.algo |= BE_LB_ALGO_RR;
-		return 0;
-	}
-
-	if (!strcmp(args[0], "roundrobin")) {
-		curproxy->lbprm.algo &= ~BE_LB_ALGO;
-		curproxy->lbprm.algo |= BE_LB_ALGO_RR;
-	}
-	else if (!strcmp(args[0], "static-rr")) {
-		curproxy->lbprm.algo &= ~BE_LB_ALGO;
-		curproxy->lbprm.algo |= BE_LB_ALGO_SRR;
-	}
-	else if (!strcmp(args[0], "leastconn")) {
-		curproxy->lbprm.algo &= ~BE_LB_ALGO;
-		curproxy->lbprm.algo |= BE_LB_ALGO_LC;
-	}
-	else if (!strcmp(args[0], "source")) {
-		curproxy->lbprm.algo &= ~BE_LB_ALGO;
-		curproxy->lbprm.algo |= BE_LB_ALGO_SH;
-	}
-	else if (!strcmp(args[0], "uri")) {
-		int arg = 1;
-
-		curproxy->lbprm.algo &= ~BE_LB_ALGO;
-		curproxy->lbprm.algo |= BE_LB_ALGO_UH;
-
-		while (*args[arg]) {
-			if (!strcmp(args[arg], "len")) {
-				if (!*args[arg+1] || (atoi(args[arg+1]) <= 0)) {
-					snprintf(err, errlen, "'balance uri len' expects a positive integer (got '%s').", args[arg+1]);
-					return -1;
-				}
-				curproxy->uri_len_limit = atoi(args[arg+1]);
-				arg += 2;
-			}
-			else if (!strcmp(args[arg], "depth")) {
-				if (!*args[arg+1] || (atoi(args[arg+1]) <= 0)) {
-					snprintf(err, errlen, "'balance uri depth' expects a positive integer (got '%s').", args[arg+1]);
-					return -1;
-				}
-				/* hint: we store the position of the ending '/' (depth+1) so
-				 * that we avoid a comparison while computing the hash.
-				 */
-				curproxy->uri_dirs_depth1 = atoi(args[arg+1]) + 1;
-				arg += 2;
-			}
-			else {
-				snprintf(err, errlen, "'balance uri' only accepts parameters 'len' and 'depth' (got '%s').", args[arg]);
-				return -1;
-			}
-		}
-	}
-	else if (!strcmp(args[0], "url_param")) {
-		if (!*args[1]) {
-			snprintf(err, errlen, "'balance url_param' requires an URL parameter name.");
-			return -1;
-		}
-		curproxy->lbprm.algo &= ~BE_LB_ALGO;
-		curproxy->lbprm.algo |= BE_LB_ALGO_PH;
-
-		free(curproxy->url_param_name);
-		curproxy->url_param_name = strdup(args[1]);
-		curproxy->url_param_len  = strlen(args[1]);
-		if (*args[2]) {
-			if (strcmp(args[2], "check_post")) {
-				snprintf(err, errlen, "'balance url_param' only accepts check_post modifier.");
-				return -1;
-			}
-			if (*args[3]) {
-				/* TODO: maybe issue a warning if there is no value, no digits or too long */
-				curproxy->url_param_post_limit = str2ui(args[3]);
-			}
-			/* if no limit, or faul value in args[3], then default to a moderate wordlen */
-			if (!curproxy->url_param_post_limit)
-				curproxy->url_param_post_limit = 48;
-			else if ( curproxy->url_param_post_limit < 3 )
-				curproxy->url_param_post_limit = 3; /* minimum example: S=3 or \r\nS=6& */
-		}
-	}
-	else if (!strncmp(args[0], "hdr(", 4)) {
-		const char *beg, *end;
-
-		beg = args[0] + 4;
-		end = strchr(beg, ')');
-
-		if (!end || end == beg) {
-			snprintf(err, errlen, "'balance hdr(name)' requires an http header field name.");
-			return -1;
-		}
-
-		curproxy->lbprm.algo &= ~BE_LB_ALGO;
-		curproxy->lbprm.algo |= BE_LB_ALGO_HH;
-
-		free(curproxy->hh_name);
-		curproxy->hh_len  = end - beg;
-		curproxy->hh_name = my_strndup(beg, end - beg);
-		curproxy->hh_match_domain = 0;
-
-		if (*args[1]) {
-			if (strcmp(args[1], "use_domain_only")) {
-				snprintf(err, errlen, "'balance hdr(name)' only accepts 'use_domain_only' modifier.");
-				return -1;
-			}
-			curproxy->hh_match_domain = 1;
-		}
-
-	}
-	else if (!strncmp(args[0], "rdp-cookie", 10)) {
-		curproxy->lbprm.algo &= ~BE_LB_ALGO;
-		curproxy->lbprm.algo |= BE_LB_ALGO_RCH;
-
-		if ( *(args[0] + 10 ) == '(' ) { /* cookie name */
-			const char *beg, *end;
-
-			beg = args[0] + 11;
-			end = strchr(beg, ')');
-
-			if (!end || end == beg) {
-				snprintf(err, errlen, "'balance rdp-cookie(name)' requires an rdp cookie name.");
-				return -1;
-			}
-
-			free(curproxy->hh_name);
-			curproxy->hh_name = my_strndup(beg, end - beg);
-			curproxy->hh_len  = end - beg;
-		}
-		else if ( *(args[0] + 10 ) == '\0' ) { /* default cookie name 'mstshash' */
-			free(curproxy->hh_name);
-			curproxy->hh_name = strdup("mstshash");
-			curproxy->hh_len  = strlen(curproxy->hh_name);
-		}
-		else { /* syntax */
-			snprintf(err, errlen, "'balance rdp-cookie(name)' requires an rdp cookie name.");
-			return -1;
-		}
-	}
-	else {
-		snprintf(err, errlen, "'balance' only supports 'roundrobin', 'static-rr', 'leastconn', 'source', 'uri', 'url_param', 'hdr(name)' and 'rdp-cookie(name)' options.");
-		return -1;
-	}
-	return 0;
-}
-
-
-/************************************************************************/
-/*             All supported keywords must be declared here.            */
-/************************************************************************/
-
-/* set test->i to the number of enabled servers on the proxy */
-static int
-acl_fetch_nbsrv(struct proxy *px, struct session *l4, void *l7, int dir,
-                struct acl_expr *expr, struct acl_test *test)
-{
-	test->flags = ACL_TEST_F_VOL_TEST;
-	if (expr->arg_len) {
-		/* another proxy was designated, we must look for it */
-		for (px = proxy; px; px = px->next)
-			if ((px->cap & PR_CAP_BE) && !strcmp(px->id, expr->arg.str))
-				break;
-	}
-	if (!px)
-		return 0;
-
-	if (px->srv_act)
-		test->i = px->srv_act;
-	else if (px->lbprm.fbck)
-		test->i = 1;
-	else
-		test->i = px->srv_bck;
-
-	return 1;
-}
-
-/* report in test->flags a success or failure depending on the designated
- * server's state. There is no match function involved since there's no pattern.
- */
-static int
-acl_fetch_srv_is_up(struct proxy *px, struct session *l4, void *l7, int dir,
-		    struct acl_expr *expr, struct acl_test *test)
-{
-	struct server *srv = expr->arg.srv;
-
-	test->flags = ACL_TEST_F_VOL_TEST;
-	if (!(srv->state & SRV_MAINTAIN) &&
-	    (!(srv->state & SRV_CHECKED) || (srv->state & SRV_RUNNING)))
-		test->flags |= ACL_TEST_F_SET_RES_PASS;
-	else
-		test->flags |= ACL_TEST_F_SET_RES_FAIL;
-	return 1;
-}
-
-/* set test->i to the number of enabled servers on the proxy */
-static int
-acl_fetch_connslots(struct proxy *px, struct session *l4, void *l7, int dir,
-		    struct acl_expr *expr, struct acl_test *test)
-{
-	struct server *iterator;
-	test->flags = ACL_TEST_F_VOL_TEST;
-	if (expr->arg_len) {
-		/* another proxy was designated, we must look for it */
-		for (px = proxy; px; px = px->next)
-			if ((px->cap & PR_CAP_BE) && !strcmp(px->id, expr->arg.str))
-				break;
-	}
-	if (!px)
-		return 0;
-
-	test->i = 0;
-	iterator = px->srv;
-	while (iterator) {
-		if ((iterator->state & SRV_RUNNING) == 0) {
-			iterator = iterator->next;
-			continue;
-		}
-		if (iterator->maxconn == 0 || iterator->maxqueue == 0) {
-			test->i = -1;
-			return 1;
-		}
-
-		test->i += (iterator->maxconn - iterator->cur_sess)
-			+  (iterator->maxqueue - iterator->nbpend);
-		iterator = iterator->next;
-	}
-
-	return 1;
-}
-
-/* set test->i to the id of the backend */
-static int
-acl_fetch_be_id(struct proxy *px, struct session *l4, void *l7, int dir,
-                struct acl_expr *expr, struct acl_test *test) {
-
-	test->flags = ACL_TEST_F_READ_ONLY;
-
-	test->i = l4->be->uuid;
-
-	return 1;
-}
-
-/* set test->i to the id of the server */
-static int
-acl_fetch_srv_id(struct proxy *px, struct session *l4, void *l7, int dir,
-                struct acl_expr *expr, struct acl_test *test) {
-
-	if (!l4->srv)
-		return 0;
-
-	test->flags = ACL_TEST_F_READ_ONLY;
-
-	test->i = l4->srv->puid;
-
-	return 1;
-}
-
-/* set test->i to the number of connections per second reaching the frontend */
-static int
-acl_fetch_fe_sess_rate(struct proxy *px, struct session *l4, void *l7, int dir,
-                       struct acl_expr *expr, struct acl_test *test)
-{
-	test->flags = ACL_TEST_F_VOL_TEST;
-	if (expr->arg_len) {
-		/* another proxy was designated, we must look for it */
-		for (px = proxy; px; px = px->next)
-			if ((px->cap & PR_CAP_FE) && !strcmp(px->id, expr->arg.str))
-				break;
-	}
-	if (!px)
-		return 0;
-
-	test->i = read_freq_ctr(&px->fe_sess_per_sec);
-	return 1;
-}
-
-/* set test->i to the number of connections per second reaching the backend */
-static int
-acl_fetch_be_sess_rate(struct proxy *px, struct session *l4, void *l7, int dir,
-                       struct acl_expr *expr, struct acl_test *test)
-{
-	test->flags = ACL_TEST_F_VOL_TEST;
-	if (expr->arg_len) {
-		/* another proxy was designated, we must look for it */
-		for (px = proxy; px; px = px->next)
-			if ((px->cap & PR_CAP_BE) && !strcmp(px->id, expr->arg.str))
-				break;
-	}
-	if (!px)
-		return 0;
-
-	test->i = read_freq_ctr(&px->be_sess_per_sec);
-	return 1;
-}
-
-/* set test->i to the number of concurrent connections on the frontend */
-static int
-acl_fetch_fe_conn(struct proxy *px, struct session *l4, void *l7, int dir,
-		  struct acl_expr *expr, struct acl_test *test)
-{
-	test->flags = ACL_TEST_F_VOL_TEST;
-	if (expr->arg_len) {
-		/* another proxy was designated, we must look for it */
-		for (px = proxy; px; px = px->next)
-			if ((px->cap & PR_CAP_FE) && !strcmp(px->id, expr->arg.str))
-				break;
-	}
-	if (!px)
-		return 0;
-
-	test->i = px->feconn;
-	return 1;
-}
-
-/* set test->i to the number of concurrent connections on the backend */
-static int
-acl_fetch_be_conn(struct proxy *px, struct session *l4, void *l7, int dir,
-		  struct acl_expr *expr, struct acl_test *test)
-{
-	test->flags = ACL_TEST_F_VOL_TEST;
-	if (expr->arg_len) {
-		/* another proxy was designated, we must look for it */
-		for (px = proxy; px; px = px->next)
-			if ((px->cap & PR_CAP_BE) && !strcmp(px->id, expr->arg.str))
-				break;
-	}
-	if (!px)
-		return 0;
-
-	test->i = px->beconn;
-	return 1;
-}
-
-/* set test->i to the total number of queued connections on the backend */
-static int
-acl_fetch_queue_size(struct proxy *px, struct session *l4, void *l7, int dir,
-		   struct acl_expr *expr, struct acl_test *test)
-{
-	test->flags = ACL_TEST_F_VOL_TEST;
-	if (expr->arg_len) {
-		/* another proxy was designated, we must look for it */
-		for (px = proxy; px; px = px->next)
-			if ((px->cap & PR_CAP_BE) && !strcmp(px->id, expr->arg.str))
-				break;
-	}
-	if (!px)
-		return 0;
-
-	test->i = px->totpend;
-	return 1;
-}
-
-/* set test->i to the total number of queued connections on the backend divided
- * by the number of running servers and rounded up. If there is no running
- * server, we return twice the total, just as if we had half a running server.
- * This is more or less correct anyway, since we expect the last server to come
- * back soon.
- */
-static int
-acl_fetch_avg_queue_size(struct proxy *px, struct session *l4, void *l7, int dir,
-		   struct acl_expr *expr, struct acl_test *test)
-{
-	int nbsrv;
-
-	test->flags = ACL_TEST_F_VOL_TEST;
-	if (expr->arg_len) {
-		/* another proxy was designated, we must look for it */
-		for (px = proxy; px; px = px->next)
-			if ((px->cap & PR_CAP_BE) && !strcmp(px->id, expr->arg.str))
-				break;
-	}
-	if (!px)
-		return 0;
-
-	if (px->srv_act)
-		nbsrv = px->srv_act;
-	else if (px->lbprm.fbck)
-		nbsrv = 1;
-	else
-		nbsrv = px->srv_bck;
-
-	if (nbsrv > 0)
-		test->i = (px->totpend + nbsrv - 1) / nbsrv;
-	else
-		test->i = px->totpend * 2;
-
-	return 1;
-}
-
-/* Note: must not be declared <const> as its list will be overwritten */
-static struct acl_kw_list acl_kws = {{ },{
-	{ "nbsrv",    acl_parse_int,   acl_fetch_nbsrv,     acl_match_int, ACL_USE_NOTHING },
-	{ "connslots", acl_parse_int,   acl_fetch_connslots, acl_match_int, ACL_USE_NOTHING },
-	{ "fe_sess_rate", acl_parse_int, acl_fetch_fe_sess_rate, acl_match_int, ACL_USE_NOTHING },
-	{ "be_sess_rate", acl_parse_int, acl_fetch_be_sess_rate, acl_match_int, ACL_USE_NOTHING },
-	{ "fe_conn", acl_parse_int, acl_fetch_fe_conn, acl_match_int, ACL_USE_NOTHING },
-	{ "be_conn", acl_parse_int, acl_fetch_be_conn, acl_match_int, ACL_USE_NOTHING },
-	{ "queue", acl_parse_int, acl_fetch_queue_size, acl_match_int, ACL_USE_NOTHING },
-	{ "avg_queue", acl_parse_int, acl_fetch_avg_queue_size, acl_match_int, ACL_USE_NOTHING },
-	{ "srv_is_up",    acl_parse_nothing,   acl_fetch_srv_is_up,  acl_match_nothing, ACL_USE_NOTHING },
-	{ "be_id",        acl_parse_int,     acl_fetch_be_id,          acl_match_int,     ACL_USE_NOTHING },
-	{ "srv_id",       acl_parse_int,     acl_fetch_srv_id,         acl_match_int,     ACL_USE_NOTHING },
-	{ NULL, NULL, NULL, NULL },
-}};
-
-
-__attribute__((constructor))
-static void __backend_init(void)
-{
-	acl_register_keywords(&acl_kws);
-}
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/base64.c b/deps/haproxy-1.4.21/src/base64.c
deleted file mode 100644
index 594ab45..0000000
--- a/deps/haproxy-1.4.21/src/base64.c
+++ /dev/null
@@ -1,184 +0,0 @@
-/*
- * ASCII <-> Base64 conversion as described in RFC1421.
- *
- * Copyright 2006-2010 Willy Tarreau <w@1wt.eu>
- * Copyright 2009-2010 Krzysztof Piotr Oledzki <ole@ans.pl>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <stdlib.h>
-#include <string.h>
-
-#include <common/base64.h>
-#include <common/config.h>
-
-#define B64BASE	'#'		/* arbitrary chosen base value */
-#define B64CMIN	'+'
-#define B64CMAX	'z'
-#define B64PADV	64		/* Base64 chosen special pad value */
-
-const char base64tab[65]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
-const char base64rev[]="b###cXYZ[\\]^_`a###d###$%&'()*+,-./0123456789:;<=######>?@ABCDEFGHIJKLMNOPQRSTUVW";
-
-/* Encodes <ilen> bytes from <in> to <out> for at most <olen> chars (including
- * the trailing zero). Returns the number of bytes written. No check is made
- * for <in> or <out> to be NULL. Returns negative value if <olen> is too short
- * to accept <ilen>. 4 output bytes are produced for 1 to 3 input bytes.
- */
-int a2base64(char *in, int ilen, char *out, int olen)
-{
-	int convlen;
-
-	convlen = ((ilen + 2) / 3) * 4;
-
-	if (convlen >= olen)
-		return -1;
-
-	/* we don't need to check olen anymore */
-	while (ilen >= 3) {
-		out[0] = base64tab[(((unsigned char)in[0]) >> 2)];
-		out[1] = base64tab[(((unsigned char)in[0] & 0x03) << 4) | (((unsigned char)in[1]) >> 4)];
-		out[2] = base64tab[(((unsigned char)in[1] & 0x0F) << 2) | (((unsigned char)in[2]) >> 6)];
-		out[3] = base64tab[(((unsigned char)in[2] & 0x3F))];
-		out += 4;
-		in += 3; ilen -= 3;
-	}
-	
-	if (!ilen) {
-		out[0] = '\0';
-	} else {
-		out[0] = base64tab[((unsigned char)in[0]) >> 2];
-		if (ilen == 1) {
-			out[1] = base64tab[((unsigned char)in[0] & 0x03) << 4];
-			out[2] = '=';
-		} else {
-			out[1] = base64tab[(((unsigned char)in[0] & 0x03) << 4) |
-					(((unsigned char)in[1]) >> 4)];
-			out[2] = base64tab[((unsigned char)in[1] & 0x0F) << 2];
-		}
-		out[3] = '=';
-		out[4] = '\0';
-	}
-
-	return convlen;
-}
-
-/* Decodes <ilen> bytes from <in> to <out> for at most <olen> chars.
- * Returns the number of bytes converted. No check is made for
- * <in> or <out> to be NULL. Returns -1 if <in> is invalid or ilen
- * has wrong size, -2 if <olen> is too short.
- * 1 to 3 output bytes are produced for 4 input bytes.
- */
-int base64dec(const char *in, size_t ilen, char *out, size_t olen) {
-
-	unsigned char t[4];
-	signed char b;
-	int convlen = 0, i = 0, pad = 0;
-
-	if (ilen % 4)
-		return -1;
-
-	if (olen < ilen / 4 * 3)
-		return -2;
-
-	while (ilen) {
-
-		/* if (*p < B64CMIN || *p > B64CMAX) */
-		b = (signed char)*in - B64CMIN;
-		if ((unsigned char)b > (B64CMAX-B64CMIN))
-			return -1;
-
-		b = base64rev[b] - B64BASE - 1;
-
-		/* b == -1: invalid character */
-		if (b < 0)
-			return -1;
-
-		/* padding has to be continous */
-		if (pad && b != B64PADV)
-			return -1;
-
-		/* valid padding: "XX==" or "XXX=", but never "X===" or "====" */
-		if (pad && i < 2)
-			return -1;
-
-		if (b == B64PADV)
-			pad++;
-
-		t[i++] = b;
-
-		if (i == 4) {
-			/*
-			 * WARNING: we allow to write little more data than we
-			 * should, but the checks from the beginning of the
-			 * functions guarantee that we can safely do that.
-			 */
-
-			/* xx000000 xx001111 xx111122 xx222222 */
-			out[convlen]   = ((t[0] << 2) + (t[1] >> 4));
-			out[convlen+1] = ((t[1] << 4) + (t[2] >> 2));
-			out[convlen+2] = ((t[2] << 6) + (t[3] >> 0));
-
-			convlen += 3-pad;
-
-			pad = i = 0;
-		}
-
-		in++;
-		ilen--;
-	}
-
-	return convlen;
-}
-
-
-/* Converts the lower 30 bits of an integer to a 5-char base64 string. The
- * caller is responsible for ensuring that the output buffer can accept 6 bytes
- * (5 + the trailing zero). The pointer to the string is returned. The
- * conversion is performed with MSB first and in a format that can be
- * decoded with b64tos30(). This format is not padded and thus is not
- * compatible with usual base64 routines.
- */
-const char *s30tob64(int in, char *out)
-{
-	int i;
-	for (i = 0; i < 5; i++) {
-		out[i] = base64tab[(in >> 24) & 0x3F];
-		in <<= 6;
-	}
-	out[5] = '\0';
-	return out;
-}
-
-/* Converts a 5-char base64 string encoded by s30tob64() into a 30-bit integer.
- * The caller is responsible for ensuring that the input contains at least 5
- * chars. If any unexpected character is encountered, a negative value is
- * returned.  Otherwise the decoded value is returned.
- */
-int b64tos30(const char *in)
-{
-	int i, out;
-	signed char b;
-
-	out = 0;
-	for (i = 0; i < 5; i++) {
-		b = (signed char)in[i] - B64CMIN;
-		if ((unsigned char)b > (B64CMAX - B64CMIN))
-			return -1;  /* input character out of range */
-
-		b = base64rev[b] - B64BASE - 1;
-		if (b < 0)          /* invalid character */
-			return -1;
-
-		if (b == B64PADV)   /* padding not allowed */
-			return -1;
-
-		out = (out << 6) + b;
-	}
-	return out;
-}
diff --git a/deps/haproxy-1.4.21/src/buffers.c b/deps/haproxy-1.4.21/src/buffers.c
deleted file mode 100644
index 25fabf7..0000000
--- a/deps/haproxy-1.4.21/src/buffers.c
+++ /dev/null
@@ -1,555 +0,0 @@
-/*
- * Buffer management functions.
- *
- * Copyright 2000-2010 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <ctype.h>
-#include <stdarg.h>
-#include <stdio.h>
-#include <string.h>
-
-#include <common/config.h>
-#include <common/memory.h>
-#include <proto/buffers.h>
-#include <types/global.h>
-
-struct pool_head *pool2_buffer;
-
-
-/* perform minimal intializations, report 0 in case of error, 1 if OK. */
-int init_buffer()
-{
-	pool2_buffer = create_pool("buffer", sizeof(struct buffer) + global.tune.bufsize, MEM_F_SHARED);
-	return pool2_buffer != NULL;
-}
-
-/* Schedule up to <bytes> more bytes to be forwarded by the buffer without notifying
- * the task. Any pending data in the buffer is scheduled to be sent as well,
- * in the limit of the number of bytes to forward. This must be the only method
- * to use to schedule bytes to be sent. If the requested number is too large, it
- * is automatically adjusted. The number of bytes taken into account is returned.
- * Directly touching ->to_forward will cause lockups when send_max goes down to
- * zero if nobody is ready to push the remaining data.
- */
-unsigned long long buffer_forward(struct buffer *buf, unsigned long long bytes)
-{
-	unsigned int data_left;
-	unsigned int new_forward;
-
-	if (!bytes)
-		return 0;
-	data_left = buf->l - buf->send_max;
-	if (bytes <= (unsigned long long)data_left) {
-		buf->send_max += bytes;
-		buf->flags &= ~BF_OUT_EMPTY;
-		return bytes;
-	}
-
-	buf->send_max += data_left;
-	if (buf->send_max)
-		buf->flags &= ~BF_OUT_EMPTY;
-
-	if (buf->l < buffer_max_len(buf))
-		buf->flags &= ~BF_FULL;
-	else
-		buf->flags |= BF_FULL;
-
-	if (likely(bytes == BUF_INFINITE_FORWARD)) {
-		buf->to_forward = bytes;
-		return bytes;
-	}
-
-	/* Note: the case below is the only case where we may return
-	 * a byte count that does not fit into a 32-bit number.
-	 */
-	if (likely(buf->to_forward == BUF_INFINITE_FORWARD))
-		return bytes;
-
-	new_forward = buf->to_forward + bytes - data_left;
-	bytes = data_left; /* at least those bytes were scheduled */
-
-	if (new_forward <= buf->to_forward) {
-		/* integer overflow detected, let's assume no more than 2G at once */
-		new_forward = MID_RANGE(new_forward);
-	}
-
-	if (new_forward > buf->to_forward) {
-		bytes += new_forward - buf->to_forward;
-		buf->to_forward = new_forward;
-	}
-	return bytes;
-}
-
-/* writes <len> bytes from message <msg> to buffer <buf>. Returns -1 in case of
- * success, -2 if the message is larger than the buffer size, or the number of
- * bytes available otherwise. The send limit is automatically adjusted with the
- * amount of data written. FIXME-20060521: handle unaligned data.
- */
-int buffer_write(struct buffer *buf, const char *msg, int len)
-{
-	int max;
-
-	if (len == 0)
-		return -1;
-
-	if (len > buf->size) {
-		/* we can't write this chunk and will never be able to, because
-		 * it is larger than the buffer. This must be reported as an
-		 * error. Then we return -2 so that writers that don't care can
-		 * ignore it and go on, and others can check for this value.
-		 */
-		return -2;
-	}
-
-	max = buffer_realign(buf);
-
-	if (len > max)
-		return max;
-
-	memcpy(buf->r, msg, len);
-	buf->l += len;
-	buf->send_max += len;
-	buf->r += len;
-	buf->total += len;
-	if (buf->r == buf->data + buf->size)
-		buf->r = buf->data;
-
-	buf->flags &= ~(BF_OUT_EMPTY|BF_FULL);
-	if (buf->l >= buffer_max_len(buf))
-		buf->flags |= BF_FULL;
-
-	return -1;
-}
-
-/* Try to write string <str> into buffer <buf> after length controls. This
- * is the equivalent of buffer_write() except that to_forward and send_max
- * are updated and that max_len is respected. Returns -1 in case of success,
- * -2 if it is larger than the buffer size, or the number of bytes available
- * otherwise. The send limit is automatically adjusted with the amount of data
- * written.
- */
-int buffer_feed2(struct buffer *buf, const char *str, int len)
-{
-	int max;
-
-	if (len == 0)
-		return -1;
-
-	if (len > buffer_max_len(buf)) {
-		/* we can't write this chunk and will never be able to, because
-		 * it is larger than the buffer's current max size.
-		 */
-		return -2;
-	}
-
-	max = buffer_contig_space(buf);
-
-	if (len > max)
-		return max;
-
-	memcpy(buf->r, str, len);
-	buf->l += len;
-	buf->r += len;
-	buf->total += len;
-	if (buf->to_forward) {
-		unsigned long fwd = len;
-		if (buf->to_forward != BUF_INFINITE_FORWARD) {
-			if (fwd > buf->to_forward)
-				fwd = buf->to_forward;
-			buf->to_forward -= fwd;
-		}
-		buf->send_max += fwd;
-		buf->flags &= ~BF_OUT_EMPTY;
-	}
-
-	if (buf->r == buf->data + buf->size)
-		buf->r = buf->data;
-
-	buf->flags &= ~BF_FULL;
-	if (buf->l >= buffer_max_len(buf))
-		buf->flags |= BF_FULL;
-
-	/* notify that some data was read from the SI into the buffer */
-	buf->flags |= BF_READ_PARTIAL;
-	return -1;
-}
-
-/* Get one text line out of a buffer from a stream interface.
- * Return values :
- *   >0 : number of bytes read. Includes the \n if present before len or end.
- *   =0 : no '\n' before end found. <buf> is undefined.
- *   <0 : no more bytes readable + shutdown set.
- * The buffer status is not changed. The caller must call buffer_skip() to
- * update it. The '\n' is waited for as long as neither the buffer nor the
- * output are full. If either of them is full, the string may be returned
- * as is, without the '\n'.
- */
-int buffer_si_peekline(struct buffer *buf, char *str, int len)
-{
-	int ret, max;
-	char *p;
-
-	ret = 0;
-	max = len;
-	if (!buf->send_max) {
-		if (buf->flags & (BF_SHUTW|BF_SHUTW_NOW))
-			ret = -1;
-		goto out;
-	}
-
-	p = buf->w;
-
-	if (max > buf->send_max) {
-		max = buf->send_max;
-		str[max-1] = 0;
-	}
-	while (max) {
-		*str++ = *p;
-		ret++;
-		max--;
-
-		if (*p == '\n')
-			break;
-		p++;
-		if (p == buf->data + buf->size)
-			p = buf->data;
-	}
-	if (ret > 0 && ret < len && ret < buf->send_max &&
-	    *(str-1) != '\n' &&
-	    !(buf->flags & (BF_SHUTW|BF_SHUTW_NOW)))
-		ret = 0;
- out:
-	if (max)
-		*str = 0;
-	return ret;
-}
-
-/*
- * this function writes the string <str> at position <pos> which must be in buffer <b>,
- * and moves <end> just after the end of <str>.
- * <b>'s parameters (l, r, lr) are recomputed to be valid after the shift.
- * the shift value (positive or negative) is returned.
- * If there's no space left, the move is not done.
- * The function does not adjust ->send_max nor BF_OUT_EMPTY because it does not
- * make sense to use it on data scheduled to be sent.
- *
- */
-int buffer_replace(struct buffer *b, char *pos, char *end, const char *str)
-{
-	int delta;
-	int len;
-
-	len = strlen(str);
-	delta = len - (end - pos);
-
-	if (delta + b->r >= b->data + b->size)
-		return 0;  /* no space left */
-
-	if (delta + b->r > b->w && b->w >= b->r && b->l)
-		return 0;  /* no space left before wrapping data */
-
-	/* first, protect the end of the buffer */
-	memmove(end + delta, end, b->r - end);
-
-	/* now, copy str over pos */
-	memcpy(pos, str,len);
-
-	/* we only move data after the displaced zone */
-	if (b->r  > pos) b->r  += delta;
-	if (b->lr > pos) b->lr += delta;
-	b->l += delta;
-
-	b->flags &= ~BF_FULL;
-	if (b->l == 0)
-		b->r = b->w = b->lr = b->data;
-	if (b->l >= buffer_max_len(b))
-		b->flags |= BF_FULL;
-
-	return delta;
-}
-
-/*
- * same except that the string length is given, which allows str to be NULL if
- * len is 0. The send limit is *not* adjusted.
- */
-int buffer_replace2(struct buffer *b, char *pos, char *end, const char *str, int len)
-{
-	int delta;
-
-	delta = len - (end - pos);
-
-	if (delta + b->r >= b->data + b->size)
-		return 0;  /* no space left */
-
-	if (delta + b->r > b->w && b->w >= b->r && b->l)
-		return 0;  /* no space left before wrapping data */
-
-	/* first, protect the end of the buffer */
-	memmove(end + delta, end, b->r - end);
-
-	/* now, copy str over pos */
-	if (len)
-		memcpy(pos, str, len);
-
-	/* we only move data after the displaced zone */
-	if (b->r  > pos) b->r  += delta;
-	if (b->lr > pos) b->lr += delta;
-	b->l += delta;
-
-	b->flags &= ~BF_FULL;
-	if (b->l == 0)
-		b->r = b->w = b->lr = b->data;
-	if (b->l >= buffer_max_len(b))
-		b->flags |= BF_FULL;
-
-	return delta;
-}
-
-
-/*
- * Inserts <str> followed by "\r\n" at position <pos> in buffer <b>. The <len>
- * argument informs about the length of string <str> so that we don't have to
- * measure it. It does not include the "\r\n". If <str> is NULL, then the buffer
- * is only opened for len+2 bytes but nothing is copied in. It may be useful in
- * some circumstances. The send limit is *not* adjusted.
- *
- * The number of bytes added is returned on success. 0 is returned on failure.
- */
-int buffer_insert_line2(struct buffer *b, char *pos, const char *str, int len)
-{
-	int delta;
-
-	delta = len + 2;
-
-	if (delta + b->r >= b->data + b->size)
-		return 0;  /* no space left */
-
-	/* first, protect the end of the buffer */
-	memmove(pos + delta, pos, b->r - pos);
-
-	/* now, copy str over pos */
-	if (len && str) {
-		memcpy(pos, str, len);
-		pos[len] = '\r';
-		pos[len + 1] = '\n';
-	}
-
-	/* we only move data after the displaced zone */
-	if (b->r  > pos) b->r  += delta;
-	if (b->lr > pos) b->lr += delta;
-	b->l += delta;
-
-	b->flags &= ~BF_FULL;
-	if (b->l >= buffer_max_len(b))
-		b->flags |= BF_FULL;
-
-	return delta;
-}
-
-
-/* Realigns a possibly non-contiguous buffer by bouncing bytes from source to
- * destination. It does not use any intermediate buffer and does the move in
- * place, though it will be slower than a simple memmove() on contiguous data,
- * so it's desirable to use it only on non-contiguous buffers. No pointers are
- * changed, the caller is responsible for that.
- */
-void buffer_bounce_realign(struct buffer *buf)
-{
-	int advance, to_move;
-	char *from, *to;
-
-	advance = buf->data + buf->size - buf->w;
-	if (!advance)
-		return;
-
-	from = buf->w;
-	to_move = buf->l;
-	while (to_move) {
-		char last, save;
-
-		last = *from;
-		to = from + advance;
-		if (to >= buf->data + buf->size)
-			to -= buf->size;
-
-		while (1) {
-			save = *to;
-			*to  = last;
-			last = save;
-			to_move--;
-			if (!to_move)
-				break;
-
-			/* check if we went back home after rotating a number of bytes */
-			if (to == from)
-				break;
-
-			/* if we ended up in the empty area, let's walk to next place. The
-			 * empty area is either between buf->r and from or before from or
-			 * after buf->r.
-			 */
-			if (from > buf->r) {
-				if (to >= buf->r && to < from)
-					break;
-			} else if (from < buf->r) {
-				if (to < from || to >= buf->r)
-					break;
-			}
-
-			/* we have overwritten a byte of the original set, let's move it */
-			to += advance;
-			if (to >= buf->data + buf->size)
-				to -= buf->size;
-		}
-
-		from++;
-		if (from >= buf->data + buf->size)
-			from -= buf->size;
-	}
-}
-
-
-/*
- * Does an snprintf() at the end of chunk <chk>, respecting the limit of
- * at most chk->size chars. If the chk->len is over, nothing is added. Returns
- * the new chunk size.
- */
-int chunk_printf(struct chunk *chk, const char *fmt, ...)
-{
-	va_list argp;
-	int ret;
-
-	if (!chk->str || !chk->size)
-		return 0;
-
-	va_start(argp, fmt);
-	ret = vsnprintf(chk->str + chk->len, chk->size - chk->len, fmt, argp);
-	if (ret >= chk->size - chk->len)
-		/* do not copy anything in case of truncation */
-		chk->str[chk->len] = 0;
-	else
-		chk->len += ret;
-	va_end(argp);
-	return chk->len;
-}
-
-/*
- * Encode chunk <src> into chunk <dst>, respecting the limit of at most
- * chk->size chars. Replace non-printable or special chracters with "&#%d;".
- * If the chk->len is over, nothing is added. Returns the new chunk size.
- */
-int chunk_htmlencode(struct chunk *dst, struct chunk *src) {
-
-	int i, l;
-	int olen, free;
-	char c;
-
-	olen = dst->len;
-
-	for (i = 0; i < src->len; i++) {
-		free = dst->size - dst->len;
-
-		if (!free) {
-			dst->len = olen;
-			return dst->len;
-		}
-
-		c = src->str[i];
-
-		if (!isascii(c) || !isprint((unsigned char)c) || c == '&' || c == '"' || c == '\'' || c == '<' || c == '>') {
-			l = snprintf(dst->str + dst->len, free, "&#%u;", (unsigned char)c);
-
-			if (free < l) {
-				dst->len = olen;
-				return dst->len;
-			}
-
-			dst->len += l;
-		} else {
-			dst->str[dst->len] = c;
-			dst->len++;
-		}
-	}
-
-	return dst->len;
-}
-
-/*
- * Encode chunk <src> into chunk <dst>, respecting the limit of at most
- * chk->size chars. Replace non-printable or char passed in qc with "<%02X>".
- * If the chk->len is over, nothing is added. Returns the new chunk size.
- */
-int chunk_asciiencode(struct chunk *dst, struct chunk *src, char qc) {
-	int i, l;
-	int olen, free;
-	char c;
-
-	olen = dst->len;
-
-	for (i = 0; i < src->len; i++) {
-		free = dst->size - dst->len;
-
-		if (!free) {
-			dst->len = olen;
-			return dst->len;
-		}
-
-		c = src->str[i];
-
-		if (!isascii(c) || !isprint((unsigned char)c) || c == '<' || c == '>' || c == qc) {
-			l = snprintf(dst->str + dst->len, free, "<%02X>", (unsigned char)c);
-
-			if (free < l) {
-				dst->len = olen;
-				return dst->len;
-			}
-
-			dst->len += l;
-		} else {
-			dst->str[dst->len] = c;
-			dst->len++;
-		}
-	}
-
-	return dst->len;
-}
-
-/*
- * Dumps part or all of a buffer.
- */
-void buffer_dump(FILE *o, struct buffer *b, int from, int to)
-{
-	fprintf(o, "Dumping buffer %p\n", b);
-	fprintf(o, "  data=%p l=%d r=%p w=%p lr=%p\n",
-		b->data, b->l, b->r, b->w, b->lr);
-
-	if (!to || to > b->l)
-		to = b->l;
-
-	fprintf(o, "Dumping contents from byte %d to byte %d\n", from, to);
-	for (; from < to; from++) {
-		if ((from & 15) == 0)
-			fprintf(o, "  %04x: ", from);
-		fprintf(o, "%02x ", b->data[from]);
-		if ((from & 15) == 7)
-			fprintf(o, "- ");
-		else if (((from & 15) == 15) && (from != to-1))
-			fprintf(o, "\n");
-	}
-	fprintf(o, "\n--\n");
-}
-
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/cfgparse.c b/deps/haproxy-1.4.21/src/cfgparse.c
deleted file mode 100644
index 11020be..0000000
--- a/deps/haproxy-1.4.21/src/cfgparse.c
+++ /dev/null
@@ -1,5916 +0,0 @@
-/*
- * Configuration parser
- *
- * Copyright 2000-2010 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <netdb.h>
-#include <ctype.h>
-#include <pwd.h>
-#include <grp.h>
-#include <errno.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <unistd.h>
-
-#include <netinet/tcp.h>
-
-#include <common/cfgparse.h>
-#include <common/config.h>
-#include <common/errors.h>
-#include <common/memory.h>
-#include <common/standard.h>
-#include <common/time.h>
-#include <common/uri_auth.h>
-
-#include <types/capture.h>
-#include <types/global.h>
-
-#include <proto/acl.h>
-#include <proto/auth.h>
-#include <proto/backend.h>
-#include <proto/buffers.h>
-#include <proto/checks.h>
-#include <proto/dumpstats.h>
-#include <proto/httperr.h>
-#include <proto/lb_chash.h>
-#include <proto/lb_fwlc.h>
-#include <proto/lb_fwrr.h>
-#include <proto/lb_map.h>
-#include <proto/log.h>
-#include <proto/pattern.h>
-#include <proto/port_range.h>
-#include <proto/protocols.h>
-#include <proto/proto_tcp.h>
-#include <proto/proto_http.h>
-#include <proto/proxy.h>
-#include <proto/server.h>
-#include <proto/session.h>
-#include <proto/task.h>
-#include <proto/stick_table.h>
-
-
-/* This is the SSLv3 CLIENT HELLO packet used in conjunction with the
- * ssl-hello-chk option to ensure that the remote server speaks SSL.
- *
- * Check RFC 2246 (TLSv1.0) sections A.3 and A.4 for details.
- */
-const char sslv3_client_hello_pkt[] = {
-	"\x16"                /* ContentType         : 0x16 = Hanshake           */
-	"\x03\x00"            /* ProtocolVersion     : 0x0300 = SSLv3            */
-	"\x00\x79"            /* ContentLength       : 0x79 bytes after this one */
-	"\x01"                /* HanshakeType        : 0x01 = CLIENT HELLO       */
-	"\x00\x00\x75"        /* HandshakeLength     : 0x75 bytes after this one */
-	"\x03\x00"            /* Hello Version       : 0x0300 = v3               */
-	"\x00\x00\x00\x00"    /* Unix GMT Time (s)   : filled with <now> (@0x0B) */
-	"HAPROXYSSLCHK\nHAPROXYSSLCHK\n" /* Random   : must be exactly 28 bytes  */
-	"\x00"                /* Session ID length   : empty (no session ID)     */
-	"\x00\x4E"            /* Cipher Suite Length : 78 bytes after this one   */
-	"\x00\x01" "\x00\x02" "\x00\x03" "\x00\x04" /* 39 most common ciphers :  */
-	"\x00\x05" "\x00\x06" "\x00\x07" "\x00\x08" /* 0x01...0x1B, 0x2F...0x3A  */
-	"\x00\x09" "\x00\x0A" "\x00\x0B" "\x00\x0C" /* This covers RSA/DH,       */
-	"\x00\x0D" "\x00\x0E" "\x00\x0F" "\x00\x10" /* various bit lengths,      */
-	"\x00\x11" "\x00\x12" "\x00\x13" "\x00\x14" /* SHA1/MD5, DES/3DES/AES... */
-	"\x00\x15" "\x00\x16" "\x00\x17" "\x00\x18"
-	"\x00\x19" "\x00\x1A" "\x00\x1B" "\x00\x2F"
-	"\x00\x30" "\x00\x31" "\x00\x32" "\x00\x33"
-	"\x00\x34" "\x00\x35" "\x00\x36" "\x00\x37"
-	"\x00\x38" "\x00\x39" "\x00\x3A"
-	"\x01"                /* Compression Length  : 0x01 = 1 byte for types   */
-	"\x00"                /* Compression Type    : 0x00 = NULL compression   */
-};
-
-/* various keyword modifiers */
-enum kw_mod {
-	KWM_STD = 0,  /* normal */
-	KWM_NO,       /* "no" prefixed before the keyword */
-	KWM_DEF,      /* "default" prefixed before the keyword */
-};
-
-/* some of the most common options which are also the easiest to handle */
-struct cfg_opt {
-	const char *name;
-	unsigned int val;
-	unsigned int cap;
-	unsigned int checks;
-	unsigned int mode;
-};
-
-/* proxy->options */
-static const struct cfg_opt cfg_opts[] =
-{
-	{ "abortonclose", PR_O_ABRT_CLOSE, PR_CAP_BE, 0, 0 },
-	{ "allbackups",   PR_O_USE_ALL_BK, PR_CAP_BE, 0, 0 },
-	{ "checkcache",   PR_O_CHK_CACHE,  PR_CAP_BE, 0, PR_MODE_HTTP },
-	{ "clitcpka",     PR_O_TCP_CLI_KA, PR_CAP_FE, 0, 0 },
-	{ "contstats",    PR_O_CONTSTATS,  PR_CAP_FE, 0, 0 },
-	{ "dontlognull",  PR_O_NULLNOLOG,  PR_CAP_FE, 0, 0 },
-	{ "forceclose",   PR_O_FORCE_CLO,  PR_CAP_FE | PR_CAP_BE, 0, PR_MODE_HTTP },
-	{ "http_proxy",	  PR_O_HTTP_PROXY, PR_CAP_FE | PR_CAP_BE, 0, PR_MODE_HTTP },
-	{ "httpclose",    PR_O_HTTP_CLOSE, PR_CAP_FE | PR_CAP_BE, 0, PR_MODE_HTTP },
-	{ "keepalive",    PR_O_KEEPALIVE,  PR_CAP_NONE, 0, PR_MODE_HTTP },
-	{ "http-server-close", PR_O_SERVER_CLO,  PR_CAP_FE | PR_CAP_BE, 0, PR_MODE_HTTP },
-	{ "logasap",      PR_O_LOGASAP,    PR_CAP_FE, 0, 0 },
-	{ "nolinger",     PR_O_TCP_NOLING, PR_CAP_FE | PR_CAP_BE, 0, 0 },
-	{ "persist",      PR_O_PERSIST,    PR_CAP_BE, 0, 0 },
-	{ "redispatch",   PR_O_REDISP,     PR_CAP_BE, 0, 0 },
-	{ "srvtcpka",     PR_O_TCP_SRV_KA, PR_CAP_BE, 0, 0 },
-#ifdef TPROXY
-	{ "transparent",  PR_O_TRANSP,     PR_CAP_BE, 0, 0 },
-#endif
-
-	{ NULL, 0, 0, 0, 0 }
-};
-
-/* proxy->options2 */
-static const struct cfg_opt cfg_opts2[] =
-{
-#ifdef CONFIG_HAP_LINUX_SPLICE
-	{ "splice-request",  PR_O2_SPLIC_REQ, PR_CAP_FE|PR_CAP_BE, 0, 0 },
-	{ "splice-response", PR_O2_SPLIC_RTR, PR_CAP_FE|PR_CAP_BE, 0, 0 },
-	{ "splice-auto",     PR_O2_SPLIC_AUT, PR_CAP_FE|PR_CAP_BE, 0, 0 },
-#endif
-	{ "accept-invalid-http-request",  PR_O2_REQBUG_OK, PR_CAP_FE, 0, PR_MODE_HTTP },
-	{ "accept-invalid-http-response", PR_O2_RSPBUG_OK, PR_CAP_BE, 0, PR_MODE_HTTP },
-	{ "dontlog-normal",               PR_O2_NOLOGNORM, PR_CAP_FE, 0, 0 },
-	{ "log-separate-errors",          PR_O2_LOGERRORS, PR_CAP_FE, 0, 0 },
-	{ "log-health-checks",            PR_O2_LOGHCHKS,  PR_CAP_BE, 0, 0 },
-	{ "socket-stats",                 PR_O2_SOCKSTAT,  PR_CAP_FE, 0, 0 },
-	{ "tcp-smart-accept",             PR_O2_SMARTACC,  PR_CAP_FE, 0, 0 },
-	{ "tcp-smart-connect",            PR_O2_SMARTCON,  PR_CAP_BE, 0, 0 },
-	{ "independant-streams",          PR_O2_INDEPSTR,  PR_CAP_FE|PR_CAP_BE, 0, 0 },
-	{ "http-use-proxy-header",        PR_O2_USE_PXHDR, PR_CAP_FE, 0, PR_MODE_HTTP },
-	{ "http-pretend-keepalive",       PR_O2_FAKE_KA,   PR_CAP_FE|PR_CAP_BE, 0, PR_MODE_HTTP },
-	{ "http-no-delay",                PR_O2_NODELAY,   PR_CAP_FE|PR_CAP_BE, 0, PR_MODE_HTTP },
-	{ NULL, 0, 0, 0 }
-};
-
-static char *cursection = NULL;
-static struct proxy defproxy;		/* fake proxy used to assign default values on all instances */
-int cfg_maxpconn = DEFAULT_MAXCONN;	/* # of simultaneous connections per proxy (-N) */
-int cfg_maxconn = 0;			/* # of simultaneous connections, (-n) */
-
-/* List head of all known configuration keywords */
-static struct cfg_kw_list cfg_keywords = {
-	.list = LIST_HEAD_INIT(cfg_keywords.list)
-};
-
-/*
- * converts <str> to a list of listeners which are dynamically allocated.
- * The format is "{addr|'*'}:port[-end][,{addr|'*'}:port[-end]]*", where :
- *  - <addr> can be empty or "*" to indicate INADDR_ANY ;
- *  - <port> is a numerical port from 1 to 65535 ;
- *  - <end> indicates to use the range from <port> to <end> instead (inclusive).
- * This can be repeated as many times as necessary, separated by a coma.
- * Function returns 1 for success or 0 if error.
- */
-static int str2listener(char *str, struct proxy *curproxy)
-{
-	struct listener *l;
-	char *c, *next, *range, *dupstr;
-	int port, end;
-
-	next = dupstr = strdup(str);
-
-	while (next && *next) {
-		struct sockaddr_storage ss;
-
-		str = next;
-		/* 1) look for the end of the first address */
-		if ((next = strchr(str, ',')) != NULL) {
-			*next++ = 0;
-		}
-
-		/* 2) look for the addr/port delimiter, it's the last colon. */
-		if ((range = strrchr(str, ':')) == NULL) {
-			Alert("Missing port number: '%s'\n", str);
-			goto fail;
-		}	    
-
-		*range++ = 0;
-
-		if (strrchr(str, ':') != NULL) {
-			/* IPv6 address contains ':' */
-			memset(&ss, 0, sizeof(ss));
-			ss.ss_family = AF_INET6;
-
-			if (!inet_pton(ss.ss_family, str, &((struct sockaddr_in6 *)&ss)->sin6_addr)) {
-				Alert("Invalid server address: '%s'\n", str);
-				goto fail;
-			}
-		}
-		else {
-			memset(&ss, 0, sizeof(ss));
-			ss.ss_family = AF_INET;
-
-			if (*str == '*' || *str == '\0') { /* INADDR_ANY */
-				((struct sockaddr_in *)&ss)->sin_addr.s_addr = INADDR_ANY;
-			}
-			else if (!inet_pton(ss.ss_family, str, &((struct sockaddr_in *)&ss)->sin_addr)) {
-				struct hostent *he;
-		
-				if ((he = gethostbyname(str)) == NULL) {
-					Alert("Invalid server name: '%s'\n", str);
-					goto fail;
-				}
-				else
-					((struct sockaddr_in *)&ss)->sin_addr =
-						*(struct in_addr *) *(he->h_addr_list);
-			}
-		}
-
-		/* 3) look for the port-end delimiter */
-		if ((c = strchr(range, '-')) != NULL) {
-			*c++ = 0;
-			end = atol(c);
-		}
-		else {
-			end = atol(range);
-		}
-
-		port = atol(range);
-
-		if (port < 1 || port > 65535) {
-			Alert("Invalid port '%d' specified for address '%s'.\n", port, str);
-			goto fail;
-		}
-
-		if (end < 1 || end > 65535) {
-			Alert("Invalid port '%d' specified for address '%s'.\n", end, str);
-			goto fail;
-		}
-
-		for (; port <= end; port++) {
-			l = (struct listener *)calloc(1, sizeof(struct listener));
-			l->next = curproxy->listen;
-			curproxy->listen = l;
-
-			l->fd = -1;
-			l->addr = ss;
-			l->state = LI_INIT;
-
-			if (ss.ss_family == AF_INET6) {
-				((struct sockaddr_in6 *)(&l->addr))->sin6_port = htons(port);
-				tcpv6_add_listener(l);
-			} else {
-				((struct sockaddr_in *)(&l->addr))->sin_port = htons(port);
-				tcpv4_add_listener(l);
-			}
-
-			listeners++;
-		} /* end for(port) */
-	} /* end while(next) */
-	free(dupstr);
-	return 1;
- fail:
-	free(dupstr);
-	return 0;
-}
-
-/*
- * Sends a warning if proxy <proxy> does not have at least one of the
- * capabilities in <cap>. An optionnal <hint> may be added at the end
- * of the warning to help the user. Returns 1 if a warning was emitted
- * or 0 if the condition is valid.
- */
-int warnifnotcap(struct proxy *proxy, int cap, const char *file, int line, const char *arg, const char *hint)
-{
-	char *msg;
-
-	switch (cap) {
-	case PR_CAP_BE: msg = "no backend"; break;
-	case PR_CAP_FE: msg = "no frontend"; break;
-	case PR_CAP_RS: msg = "no ruleset"; break;
-	case PR_CAP_BE|PR_CAP_FE: msg = "neither frontend nor backend"; break;
-	default: msg = "not enough"; break;
-	}
-
-	if (!(proxy->cap & cap)) {
-		Warning("parsing [%s:%d] : '%s' ignored because %s '%s' has %s capability.%s\n",
-			file, line, arg, proxy_type_str(proxy), proxy->id, msg, hint ? hint : "");
-		return 1;
-	}
-	return 0;
-}
-
-/* Report a warning if a rule is placed after a 'block' rule.
- * Return 1 if the warning has been emitted, otherwise 0.
- */
-int warnif_rule_after_block(struct proxy *proxy, const char *file, int line, const char *arg)
-{
-	if (!LIST_ISEMPTY(&proxy->block_cond)) {
-		Warning("parsing [%s:%d] : a '%s' rule placed after a 'block' rule will still be processed before.\n",
-			file, line, arg);
-		return 1;
-	}
-	return 0;
-}
-
-/* Report a warning if a rule is placed after a reqrewrite rule.
- * Return 1 if the warning has been emitted, otherwise 0.
- */
-int warnif_rule_after_reqxxx(struct proxy *proxy, const char *file, int line, const char *arg)
-{
-	if (proxy->req_exp) {
-		Warning("parsing [%s:%d] : a '%s' rule placed after a 'reqxxx' rule will still be processed before.\n",
-			file, line, arg);
-		return 1;
-	}
-	return 0;
-}
-
-/* Report a warning if a rule is placed after a reqadd rule.
- * Return 1 if the warning has been emitted, otherwise 0.
- */
-int warnif_rule_after_reqadd(struct proxy *proxy, const char *file, int line, const char *arg)
-{
-	if (!LIST_ISEMPTY(&proxy->req_add)) {
-		Warning("parsing [%s:%d] : a '%s' rule placed after a 'reqadd' rule will still be processed before.\n",
-			file, line, arg);
-		return 1;
-	}
-	return 0;
-}
-
-/* Report a warning if a rule is placed after a redirect rule.
- * Return 1 if the warning has been emitted, otherwise 0.
- */
-int warnif_rule_after_redirect(struct proxy *proxy, const char *file, int line, const char *arg)
-{
-	if (!LIST_ISEMPTY(&proxy->redirect_rules)) {
-		Warning("parsing [%s:%d] : a '%s' rule placed after a 'redirect' rule will still be processed before.\n",
-			file, line, arg);
-		return 1;
-	}
-	return 0;
-}
-
-/* Report a warning if a rule is placed after a 'use_backend' rule.
- * Return 1 if the warning has been emitted, otherwise 0.
- */
-int warnif_rule_after_use_backend(struct proxy *proxy, const char *file, int line, const char *arg)
-{
-	if (!LIST_ISEMPTY(&proxy->switching_rules)) {
-		Warning("parsing [%s:%d] : a '%s' rule placed after a 'use_backend' rule will still be processed before.\n",
-			file, line, arg);
-		return 1;
-	}
-	return 0;
-}
-
-/* report a warning if a block rule is dangerously placed */
-int warnif_misplaced_block(struct proxy *proxy, const char *file, int line, const char *arg)
-{
-	return	warnif_rule_after_reqxxx(proxy, file, line, arg) ||
-		warnif_rule_after_reqadd(proxy, file, line, arg) ||
-		warnif_rule_after_redirect(proxy, file, line, arg) ||
-		warnif_rule_after_use_backend(proxy, file, line, arg);
-}
-
-/* report a warning if a reqxxx rule is dangerously placed */
-int warnif_misplaced_reqxxx(struct proxy *proxy, const char *file, int line, const char *arg)
-{
-	return	warnif_rule_after_reqadd(proxy, file, line, arg) ||
-		warnif_rule_after_redirect(proxy, file, line, arg) ||
-		warnif_rule_after_use_backend(proxy, file, line, arg);
-}
-
-/* report a warning if a reqadd rule is dangerously placed */
-int warnif_misplaced_reqadd(struct proxy *proxy, const char *file, int line, const char *arg)
-{
-	return	warnif_rule_after_redirect(proxy, file, line, arg) ||
-		warnif_rule_after_use_backend(proxy, file, line, arg);
-}
-
-/* Report it if a request ACL condition uses some response-only parameters. It
- * returns either 0 or ERR_WARN so that its result can be or'ed with err_code.
- * Note that <cond> may be NULL and then will be ignored.
- */
-static int warnif_cond_requires_resp(const struct acl_cond *cond, const char *file, int line)
-{
-	struct acl *acl;
-
-	if (!cond || !(cond->requires & ACL_USE_RTR_ANY))
-		return 0;
-
-	acl = cond_find_require(cond, ACL_USE_RTR_ANY);
-	Warning("parsing [%s:%d] : acl '%s' involves some response-only criteria which will be ignored.\n",
-		file, line, acl ? acl->name : "(unknown)");
-	return ERR_WARN;
-}
-
-/* Report it if a request ACL condition uses some request-only volatile parameters.
- * It returns either 0 or ERR_WARN so that its result can be or'ed with err_code.
- * Note that <cond> may be NULL and then will be ignored.
- */
-static int warnif_cond_requires_req(const struct acl_cond *cond, const char *file, int line)
-{
-	struct acl *acl;
-
-	if (!cond || !(cond->requires & ACL_USE_REQ_VOLATILE))
-		return 0;
-
-	acl = cond_find_require(cond, ACL_USE_REQ_VOLATILE);
-	Warning("parsing [%s:%d] : acl '%s' involves some volatile request-only criteria which will be ignored.\n",
-		file, line, acl ? acl->name : "(unknown)");
-	return ERR_WARN;
-}
-
-
-/*
- * parse a line in a <global> section. Returns the error code, 0 if OK, or
- * any combination of :
- *  - ERR_ABORT: must abort ASAP
- *  - ERR_FATAL: we can continue parsing but not start the service
- *  - ERR_WARN: a warning has been emitted
- *  - ERR_ALERT: an alert has been emitted
- * Only the two first ones can stop processing, the two others are just
- * indicators.
- */
-int cfg_parse_global(const char *file, int linenum, char **args, int kwm)
-{
-	int err_code = 0;
-
-	if (!strcmp(args[0], "global")) {  /* new section */
-		/* no option, nothing special to do */
-		goto out;
-	}
-	else if (!strcmp(args[0], "daemon")) {
-		global.mode |= MODE_DAEMON;
-	}
-	else if (!strcmp(args[0], "debug")) {
-		global.mode |= MODE_DEBUG;
-	}
-	else if (!strcmp(args[0], "noepoll")) {
-		global.tune.options &= ~GTUNE_USE_EPOLL;
-	}
-	else if (!strcmp(args[0], "nosepoll")) {
-		global.tune.options &= ~GTUNE_USE_SEPOLL;
-	}
-	else if (!strcmp(args[0], "nokqueue")) {
-		global.tune.options &= ~GTUNE_USE_KQUEUE;
-	}
-	else if (!strcmp(args[0], "nopoll")) {
-		global.tune.options &= ~GTUNE_USE_POLL;
-	}
-	else if (!strcmp(args[0], "nosplice")) {
-		global.tune.options &= ~GTUNE_USE_SPLICE;
-	}
-	else if (!strcmp(args[0], "quiet")) {
-		global.mode |= MODE_QUIET;
-	}
-	else if (!strcmp(args[0], "tune.maxpollevents")) {
-		if (global.tune.maxpollevents != 0) {
-			Alert("parsing [%s:%d] : '%s' already specified. Continuing.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT;
-			goto out;
-		}
-		if (*(args[1]) == 0) {
-			Alert("parsing [%s:%d] : '%s' expects an integer argument.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		global.tune.maxpollevents = atol(args[1]);
-	}
-	else if (!strcmp(args[0], "tune.maxaccept")) {
-		if (global.tune.maxaccept != 0) {
-			Alert("parsing [%s:%d] : '%s' already specified. Continuing.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT;
-			goto out;
-		}
-		if (*(args[1]) == 0) {
-			Alert("parsing [%s:%d] : '%s' expects an integer argument.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		global.tune.maxaccept = atol(args[1]);
-	}
-	else if (!strcmp(args[0], "tune.chksize")) {
-		if (*(args[1]) == 0) {
-			Alert("parsing [%s:%d] : '%s' expects an integer argument.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		global.tune.chksize = atol(args[1]);
-	}
-	else if (!strcmp(args[0], "tune.bufsize")) {
-		if (*(args[1]) == 0) {
-			Alert("parsing [%s:%d] : '%s' expects an integer argument.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		global.tune.bufsize = atol(args[1]);
-		if (global.tune.maxrewrite >= global.tune.bufsize / 2)
-			global.tune.maxrewrite = global.tune.bufsize / 2;
-		trashlen = global.tune.bufsize;
-		trash = realloc(trash, trashlen);
-	}
-	else if (!strcmp(args[0], "tune.maxrewrite")) {
-		if (*(args[1]) == 0) {
-			Alert("parsing [%s:%d] : '%s' expects an integer argument.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		global.tune.maxrewrite = atol(args[1]);
-		if (global.tune.maxrewrite >= global.tune.bufsize / 2)
-			global.tune.maxrewrite = global.tune.bufsize / 2;
-	}
-	else if (!strcmp(args[0], "tune.rcvbuf.client")) {
-		if (global.tune.client_rcvbuf != 0) {
-			Alert("parsing [%s:%d] : '%s' already specified. Continuing.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT;
-			goto out;
-		}
-		if (*(args[1]) == 0) {
-			Alert("parsing [%s:%d] : '%s' expects an integer argument.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		global.tune.client_rcvbuf = atol(args[1]);
-	}
-	else if (!strcmp(args[0], "tune.rcvbuf.server")) {
-		if (global.tune.server_rcvbuf != 0) {
-			Alert("parsing [%s:%d] : '%s' already specified. Continuing.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT;
-			goto out;
-		}
-		if (*(args[1]) == 0) {
-			Alert("parsing [%s:%d] : '%s' expects an integer argument.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		global.tune.server_rcvbuf = atol(args[1]);
-	}
-	else if (!strcmp(args[0], "tune.sndbuf.client")) {
-		if (global.tune.client_sndbuf != 0) {
-			Alert("parsing [%s:%d] : '%s' already specified. Continuing.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT;
-			goto out;
-		}
-		if (*(args[1]) == 0) {
-			Alert("parsing [%s:%d] : '%s' expects an integer argument.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		global.tune.client_sndbuf = atol(args[1]);
-	}
-	else if (!strcmp(args[0], "tune.sndbuf.server")) {
-		if (global.tune.server_sndbuf != 0) {
-			Alert("parsing [%s:%d] : '%s' already specified. Continuing.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT;
-			goto out;
-		}
-		if (*(args[1]) == 0) {
-			Alert("parsing [%s:%d] : '%s' expects an integer argument.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		global.tune.server_sndbuf = atol(args[1]);
-	}
-	else if (!strcmp(args[0], "uid")) {
-		if (global.uid != 0) {
-			Alert("parsing [%s:%d] : user/uid already specified. Continuing.\n", file, linenum);
-			err_code |= ERR_ALERT;
-			goto out;
-		}
-		if (*(args[1]) == 0) {
-			Alert("parsing [%s:%d] : '%s' expects an integer argument.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		global.uid = atol(args[1]);
-	}
-	else if (!strcmp(args[0], "gid")) {
-		if (global.gid != 0) {
-			Alert("parsing [%s:%d] : group/gid already specified. Continuing.\n", file, linenum);
-			err_code |= ERR_ALERT;
-			goto out;
-		}
-		if (*(args[1]) == 0) {
-			Alert("parsing [%s:%d] : '%s' expects an integer argument.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		global.gid = atol(args[1]);
-	}
-	/* user/group name handling */
-	else if (!strcmp(args[0], "user")) {
-		struct passwd *ha_user;
-		if (global.uid != 0) {
-			Alert("parsing [%s:%d] : user/uid already specified. Continuing.\n", file, linenum);
-			err_code |= ERR_ALERT;
-			goto out;
-		}
-		errno = 0;
-		ha_user = getpwnam(args[1]);
-		if (ha_user != NULL) {
-			global.uid = (int)ha_user->pw_uid;
-		}
-		else {
-			Alert("parsing [%s:%d] : cannot find user id for '%s' (%d:%s)\n", file, linenum, args[1], errno, strerror(errno));
-			err_code |= ERR_ALERT | ERR_FATAL;
-		}
-	}
-	else if (!strcmp(args[0], "group")) {
-		struct group *ha_group;
-		if (global.gid != 0) {
-			Alert("parsing [%s:%d] : gid/group was already specified. Continuing.\n", file, linenum);
-			err_code |= ERR_ALERT;
-			goto out;
-		}
-		errno = 0;
-		ha_group = getgrnam(args[1]);
-		if (ha_group != NULL) {
-			global.gid = (int)ha_group->gr_gid;
-		}
-		else {
-			Alert("parsing [%s:%d] : cannot find group id for '%s' (%d:%s)\n", file, linenum, args[1], errno, strerror(errno));
-			err_code |= ERR_ALERT | ERR_FATAL;
-		}
-	}
-	/* end of user/group name handling*/
-	else if (!strcmp(args[0], "nbproc")) {
-		if (global.nbproc != 0) {
-			Alert("parsing [%s:%d] : '%s' already specified. Continuing.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT;
-			goto out;
-		}
-		if (*(args[1]) == 0) {
-			Alert("parsing [%s:%d] : '%s' expects an integer argument.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		global.nbproc = atol(args[1]);
-	}
-	else if (!strcmp(args[0], "maxconn")) {
-		if (global.maxconn != 0) {
-			Alert("parsing [%s:%d] : '%s' already specified. Continuing.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT;
-			goto out;
-		}
-		if (*(args[1]) == 0) {
-			Alert("parsing [%s:%d] : '%s' expects an integer argument.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		global.maxconn = atol(args[1]);
-#ifdef SYSTEM_MAXCONN
-		if (global.maxconn > DEFAULT_MAXCONN && cfg_maxconn <= DEFAULT_MAXCONN) {
-			Alert("parsing [%s:%d] : maxconn value %d too high for this system.\nLimiting to %d. Please use '-n' to force the value.\n", file, linenum, global.maxconn, DEFAULT_MAXCONN);
-			global.maxconn = DEFAULT_MAXCONN;
-			err_code |= ERR_ALERT;
-		}
-#endif /* SYSTEM_MAXCONN */
-	}
-	else if (!strcmp(args[0], "maxpipes")) {
-		if (global.maxpipes != 0) {
-			Alert("parsing [%s:%d] : '%s' already specified. Continuing.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT;
-			goto out;
-		}
-		if (*(args[1]) == 0) {
-			Alert("parsing [%s:%d] : '%s' expects an integer argument.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		global.maxpipes = atol(args[1]);
-	}
-	else if (!strcmp(args[0], "ulimit-n")) {
-		if (global.rlimit_nofile != 0) {
-			Alert("parsing [%s:%d] : '%s' already specified. Continuing.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT;
-			goto out;
-		}
-		if (*(args[1]) == 0) {
-			Alert("parsing [%s:%d] : '%s' expects an integer argument.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		global.rlimit_nofile = atol(args[1]);
-	}
-	else if (!strcmp(args[0], "chroot")) {
-		if (global.chroot != NULL) {
-			Alert("parsing [%s:%d] : '%s' already specified. Continuing.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT;
-			goto out;
-		}
-		if (*(args[1]) == 0) {
-			Alert("parsing [%s:%d] : '%s' expects a directory as an argument.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		global.chroot = strdup(args[1]);
-	}
-	else if (!strcmp(args[0], "description")) {
-		int i, len=0;
-		char *d;
-
-		if (!*args[1]) {
-			Alert("parsing [%s:%d]: '%s' expects a string argument.\n",
-				file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		for(i=1; *args[i]; i++)
-			len += strlen(args[i])+1;
-
-		if (global.desc)
-			free(global.desc);
-
-		global.desc = d = (char *)calloc(1, len);
-
-		d += sprintf(d, "%s", args[1]);
-		for(i=2; *args[i]; i++)
-			d += sprintf(d, " %s", args[i]);
-	}
-	else if (!strcmp(args[0], "node")) {
-		int i;
-		char c;
-
-		for (i=0; args[1][i]; i++) {
-			c = args[1][i];
-			if (!isupper((unsigned char)c) && !islower((unsigned char)c) &&
-			    !isdigit((unsigned char)c) && c != '_' && c != '-' && c != '.')
-				break;
-		}
-
-		if (!i || args[1][i]) {
-			Alert("parsing [%s:%d]: '%s' requires valid node name - non-empty string"
-				" with digits(0-9), letters(A-Z, a-z), dot(.), hyphen(-) or underscode(_).\n",
-				file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		if (global.node)
-			free(global.node);
-
-		global.node = strdup(args[1]);
-	}
-	else if (!strcmp(args[0], "pidfile")) {
-		if (global.pidfile != NULL) {
-			Alert("parsing [%s:%d] : '%s' already specified. Continuing.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT;
-			goto out;
-		}
-		if (*(args[1]) == 0) {
-			Alert("parsing [%s:%d] : '%s' expects a file name as an argument.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		global.pidfile = strdup(args[1]);
-	}
-	else if (!strcmp(args[0], "log")) {  /* syslog server address */
-		struct logsrv logsrv;
-		int facility, level, minlvl;
-	
-		if (*(args[1]) == 0 || *(args[2]) == 0) {
-			Alert("parsing [%s:%d] : '%s' expects <address> and <facility> as arguments.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-	
-		facility = get_log_facility(args[2]);
-		if (facility < 0) {
-			Alert("parsing [%s:%d] : unknown log facility '%s'\n", file, linenum, args[2]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			facility = 0;
-		}
-
-		level = 7; /* max syslog level = debug */
-		if (*(args[3])) {
-			level = get_log_level(args[3]);
-			if (level < 0) {
-				Alert("parsing [%s:%d] : unknown optional log level '%s'\n", file, linenum, args[3]);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				level = 0;
-			}
-		}
-
-		minlvl = 0; /* limit syslog level to this level (emerg) */
-		if (*(args[4])) {
-			minlvl = get_log_level(args[4]);
-			if (minlvl < 0) {
-				Alert("parsing [%s:%d] : unknown optional minimum log level '%s'\n", file, linenum, args[4]);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				minlvl = 0;
-			}
-		}
-
-		if (args[1][0] == '/') {
-			struct sockaddr_un *sk = str2sun(args[1]);
-			if (!sk) {
-				Alert("parsing [%s:%d] : Socket path '%s' too long (max %d)\n", file, linenum,
-				      args[1], (int)sizeof(sk->sun_path) - 1);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			}
-			logsrv.u.un = *sk;
-			logsrv.u.addr.sa_family = AF_UNIX;
-		} else {
-			struct sockaddr_in *sk = str2sa(args[1]);
-			if (!sk) {
-				Alert("parsing [%s:%d] : Unknown host in '%s'\n", file, linenum, args[1]);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			}
-			logsrv.u.in = *sk;
-			logsrv.u.addr.sa_family = AF_INET;
-			if (!logsrv.u.in.sin_port)
-				logsrv.u.in.sin_port = htons(SYSLOG_PORT);
-		}
-
-		if (global.logfac1 == -1) {
-			global.logsrv1 = logsrv;
-			global.logfac1 = facility;
-			global.loglev1 = level;
-			global.minlvl1 = minlvl;
-		}
-		else if (global.logfac2 == -1) {
-			global.logsrv2 = logsrv;
-			global.logfac2 = facility;
-			global.loglev2 = level;
-			global.minlvl2 = minlvl;
-		}
-		else {
-			Alert("parsing [%s:%d] : too many syslog servers\n", file, linenum);
-			err_code |= ERR_ALERT | ERR_FATAL;
-		}
-	}
-	else if (!strcmp(args[0], "log-send-hostname")) { /* set the hostname in syslog header */
-		char *name;
-		int len;
-
-		if (global.log_send_hostname != NULL) {
-			Alert("parsing [%s:%d] : '%s' already specified. Continuing.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT;
-			goto out;
-		}
-
-		if (*(args[1]))
-			name = args[1];
-		else
-			name = hostname;
-
-		len = strlen(name);
-
-		/* We'll add a space after the name to respect the log format */
-		free(global.log_send_hostname);
-		global.log_send_hostname = malloc(len + 2);
-		snprintf(global.log_send_hostname, len + 2, "%s ", name);
-	}
-	else if (!strcmp(args[0], "log-tag")) {  /* tag to report to syslog */
-		if (*(args[1]) == 0) {
-			Alert("parsing [%s:%d] : '%s' expects a tag for use in syslog.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		free(global.log_tag);
-		global.log_tag = strdup(args[1]);
-	}
-	else if (!strcmp(args[0], "spread-checks")) {  /* random time between checks (0-50) */
-		if (global.spread_checks != 0) {
-			Alert("parsing [%s:%d]: spread-checks already specified. Continuing.\n", file, linenum);
-			err_code |= ERR_ALERT;
-			goto out;
-		}
-		if (*(args[1]) == 0) {
-			Alert("parsing [%s:%d]: '%s' expects an integer argument (0..50).\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		global.spread_checks = atol(args[1]);
-		if (global.spread_checks < 0 || global.spread_checks > 50) {
-			Alert("parsing [%s:%d]: 'spread-checks' needs a positive value in range 0..50.\n", file, linenum);
-			err_code |= ERR_ALERT | ERR_FATAL;
-		}
-	}
-	else {
-		struct cfg_kw_list *kwl;
-		int index;
-		int rc;
-
-		list_for_each_entry(kwl, &cfg_keywords.list, list) {
-			for (index = 0; kwl->kw[index].kw != NULL; index++) {
-				if (kwl->kw[index].section != CFG_GLOBAL)
-					continue;
-				if (strcmp(kwl->kw[index].kw, args[0]) == 0) {
-					/* prepare error message just in case */
-					snprintf(trash, trashlen,
-						 "error near '%s' in '%s' section", args[0], "global");
-					rc = kwl->kw[index].parse(args, CFG_GLOBAL, NULL, NULL, trash, trashlen);
-					if (rc < 0) {
-						Alert("parsing [%s:%d] : %s\n", file, linenum, trash);
-						err_code |= ERR_ALERT | ERR_FATAL;
-					}
-					else if (rc > 0) {
-						Warning("parsing [%s:%d] : %s\n", file, linenum, trash);
-						err_code |= ERR_WARN;
-						goto out;
-					}
-					goto out;
-				}
-			}
-		}
-		
-		Alert("parsing [%s:%d] : unknown keyword '%s' in '%s' section\n", file, linenum, args[0], "global");
-		err_code |= ERR_ALERT | ERR_FATAL;
-	}
-
- out:
-	return err_code;
-}
-
-/* Perform the most basic initialization of a proxy :
- * memset(), list_init(*), reset_timeouts(*).
- */
-static void init_new_proxy(struct proxy *p)
-{
-	memset(p, 0, sizeof(struct proxy));
-	LIST_INIT(&p->pendconns);
-	LIST_INIT(&p->acl);
-	LIST_INIT(&p->req_acl);
-	LIST_INIT(&p->block_cond);
-	LIST_INIT(&p->redirect_rules);
-	LIST_INIT(&p->mon_fail_cond);
-	LIST_INIT(&p->switching_rules);
-	LIST_INIT(&p->persist_rules);
-	LIST_INIT(&p->sticking_rules);
-	LIST_INIT(&p->storersp_rules);
-	LIST_INIT(&p->tcp_req.inspect_rules);
-	LIST_INIT(&p->req_add);
-	LIST_INIT(&p->rsp_add);
-
-	/* Timeouts are defined as -1 */
-	proxy_reset_timeouts(p);
-}
-
-void init_default_instance()
-{
-	init_new_proxy(&defproxy);
-	defproxy.mode = PR_MODE_TCP;
-	defproxy.state = PR_STNEW;
-	defproxy.maxconn = cfg_maxpconn;
-	defproxy.conn_retries = CONN_RETRIES;
-	defproxy.logfac1 = defproxy.logfac2 = -1; /* log disabled */
-
-	defproxy.defsrv.inter = DEF_CHKINTR;
-	defproxy.defsrv.fastinter = 0;
-	defproxy.defsrv.downinter = 0;
-	defproxy.defsrv.rise = DEF_RISETIME;
-	defproxy.defsrv.fall = DEF_FALLTIME;
-	defproxy.defsrv.check_port = 0;
-	defproxy.defsrv.maxqueue = 0;
-	defproxy.defsrv.minconn = 0;
-	defproxy.defsrv.maxconn = 0;
-	defproxy.defsrv.slowstart = 0;
-	defproxy.defsrv.onerror = DEF_HANA_ONERR;
-	defproxy.defsrv.consecutive_errors_limit = DEF_HANA_ERRLIMIT;
-	defproxy.defsrv.uweight = defproxy.defsrv.iweight = 1;
-}
-
-
-static int create_cond_regex_rule(const char *file, int line,
-				  struct proxy *px, int dir, int action, int flags,
-				  const char *cmd, const char *reg, const char *repl,
-				  const char **cond_start)
-{
-	regex_t *preg = NULL;
-	const char *err;
-	int err_code = 0;
-	struct acl_cond *cond = NULL;
-
-	if (px == &defproxy) {
-		Alert("parsing [%s:%d] : '%s' not allowed in 'defaults' section.\n", file, line, cmd);
-		err_code |= ERR_ALERT | ERR_FATAL;
-		goto err;
-	}
-
-	if (*reg == 0) {
-		Alert("parsing [%s:%d] : '%s' expects <regex> as an argument.\n", file, line, cmd);
-		err_code |= ERR_ALERT | ERR_FATAL;
-		goto err;
-	}
-
-	if (warnifnotcap(px, PR_CAP_RS, file, line, cmd, NULL))
-		err_code |= ERR_WARN;
-
-	if (cond_start &&
-	    (strcmp(*cond_start, "if") == 0 || strcmp(*cond_start, "unless") == 0)) {
-		if ((cond = build_acl_cond(file, line, px, cond_start)) == NULL) {
-			Alert("parsing [%s:%d] : error detected while parsing a '%s' condition.\n",
-			      file, line, cmd);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto err;
-		}
-	}
-	else if (cond_start && **cond_start) {
-		Alert("parsing [%s:%d] : '%s' : Expecting nothing, 'if', or 'unless', got '%s'.\n",
-		      file, line, cmd, *cond_start);
-		err_code |= ERR_ALERT | ERR_FATAL;
-		goto err;
-	}
-
-	if (dir == ACL_DIR_REQ)
-		err_code |= warnif_cond_requires_resp(cond, file, line);
-	else
-		err_code |= warnif_cond_requires_req(cond, file, line);
-
-	preg = calloc(1, sizeof(regex_t));
-	if (!preg) {
-		Alert("parsing [%s:%d] : '%s' : not enough memory to build regex.\n", file, line, cmd);
-		err_code = ERR_ALERT | ERR_FATAL;
-		goto err;
-	}
-
-	if (regcomp(preg, reg, REG_EXTENDED | flags) != 0) {
-		Alert("parsing [%s:%d] : '%s' : bad regular expression '%s'.\n", file, line, cmd, reg);
-		err_code = ERR_ALERT | ERR_FATAL;
-		goto err;
-	}
-
-	err = chain_regex((dir == ACL_DIR_REQ) ? &px->req_exp : &px->rsp_exp,
-			  preg, action, repl ? strdup(repl) : NULL, cond);
-	if (repl && err) {
-		Alert("parsing [%s:%d] : '%s' : invalid character or unterminated sequence in replacement string near '%c'.\n",
-		      file, line, cmd, *err);
-		err_code |= ERR_ALERT | ERR_FATAL;
-		goto err;
-	}
-
-	if (dir == ACL_DIR_REQ && warnif_misplaced_reqxxx(px, file, line, cmd))
-		err_code |= ERR_WARN;
-
-	return err_code;
- err:
-	free(preg);
-	return err_code;
-}
-
-/*
- * Parse a line in a <listen>, <frontend>, <backend> or <ruleset> section.
- * Returns the error code, 0 if OK, or any combination of :
- *  - ERR_ABORT: must abort ASAP
- *  - ERR_FATAL: we can continue parsing but not start the service
- *  - ERR_WARN: a warning has been emitted
- *  - ERR_ALERT: an alert has been emitted
- * Only the two first ones can stop processing, the two others are just
- * indicators.
- */
-int cfg_parse_listen(const char *file, int linenum, char **args, int kwm)
-{
-	static struct proxy *curproxy = NULL;
-	struct server *newsrv = NULL;
-	const char *err;
-	int rc;
-	unsigned val;
-	int err_code = 0;
-	struct acl_cond *cond = NULL;
-
-	if (!strcmp(args[0], "listen"))
-		rc = PR_CAP_LISTEN;
- 	else if (!strcmp(args[0], "frontend"))
-		rc = PR_CAP_FE | PR_CAP_RS;
- 	else if (!strcmp(args[0], "backend"))
-		rc = PR_CAP_BE | PR_CAP_RS;
- 	else if (!strcmp(args[0], "ruleset"))
-		rc = PR_CAP_RS;
-	else
-		rc = PR_CAP_NONE;
-
-	if (rc != PR_CAP_NONE) {  /* new proxy */
-		if (!*args[1]) {
-			Alert("parsing [%s:%d] : '%s' expects an <id> argument and\n"
-			      "  optionnally supports [addr1]:port1[-end1]{,[addr]:port[-end]}...\n",
-			      file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_ABORT;
-			goto out;
-		}
-
-		err = invalid_char(args[1]);
-		if (err) {
-			Alert("parsing [%s:%d] : character '%c' is not permitted in '%s' name '%s'.\n",
-			      file, linenum, *err, args[0], args[1]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-		}
-
-		for (curproxy = proxy; curproxy != NULL; curproxy = curproxy->next) {
-			/*
-			 * If there are two proxies with the same name only following
-			 * combinations are allowed:
-			 *
-			 *			listen backend frontend ruleset
-			 *	listen             -      -       -        -
-			 *	backend            -      -       OK       -
-			 *	frontend           -      OK      -        -
-			 *	ruleset            -      -       -        -
-			 */
-
-			if (!strcmp(curproxy->id, args[1]) &&
-				(rc!=(PR_CAP_FE|PR_CAP_RS) || curproxy->cap!=(PR_CAP_BE|PR_CAP_RS)) &&
-				(rc!=(PR_CAP_BE|PR_CAP_RS) || curproxy->cap!=(PR_CAP_FE|PR_CAP_RS))) {
-				Warning("Parsing [%s:%d]: %s '%s' has same name as another %s (declared at %s:%d).\n",
-					file, linenum, proxy_cap_str(rc), args[1], proxy_type_str(curproxy),
-					curproxy->conf.file, curproxy->conf.line);
-				err_code |= ERR_WARN;
-			}
-		}
-
-		if ((curproxy = (struct proxy *)calloc(1, sizeof(struct proxy))) == NULL) {
-			Alert("parsing [%s:%d] : out of memory.\n", file, linenum);
-			err_code |= ERR_ALERT | ERR_ABORT;
-			goto out;
-		}
-
-		init_new_proxy(curproxy);
-		curproxy->next = proxy;
-		proxy = curproxy;
-		curproxy->conf.file = file;
-		curproxy->conf.line = linenum;
-		curproxy->last_change = now.tv_sec;
-		curproxy->id = strdup(args[1]);
-		curproxy->cap = rc;
-
-		/* parse the listener address if any */
-		if ((curproxy->cap & PR_CAP_FE) && *args[2]) {
-			struct listener *new, *last = curproxy->listen;
-			if (!str2listener(args[2], curproxy)) {
-				err_code |= ERR_FATAL;
-				goto out;
-			}
-			new = curproxy->listen;
-			while (new != last) {
-				new->conf.file = file;
-				new->conf.line = linenum;
-				new = new->next;
-				global.maxsock++;
-			}
-		}
-
-		/* set default values */
-		memcpy(&curproxy->defsrv, &defproxy.defsrv, sizeof(curproxy->defsrv));
-		curproxy->defsrv.id = "default-server";
-
-		curproxy->state = defproxy.state;
-		curproxy->options = defproxy.options;
-		curproxy->options2 = defproxy.options2;
-		curproxy->no_options = defproxy.no_options;
-		curproxy->no_options2 = defproxy.no_options2;
-		curproxy->bind_proc = defproxy.bind_proc;
-		curproxy->lbprm.algo = defproxy.lbprm.algo;
-		curproxy->except_net = defproxy.except_net;
-		curproxy->except_mask = defproxy.except_mask;
-		curproxy->except_to = defproxy.except_to;
-		curproxy->except_mask_to = defproxy.except_mask_to;
-
-		if (defproxy.fwdfor_hdr_len) {
-			curproxy->fwdfor_hdr_len  = defproxy.fwdfor_hdr_len;
-			curproxy->fwdfor_hdr_name = strdup(defproxy.fwdfor_hdr_name);
-		}
-
-		if (defproxy.orgto_hdr_len) {
-			curproxy->orgto_hdr_len  = defproxy.orgto_hdr_len;
-			curproxy->orgto_hdr_name = strdup(defproxy.orgto_hdr_name);
-		}
-
-		if (defproxy.server_id_hdr_len) {
-			curproxy->server_id_hdr_len  = defproxy.server_id_hdr_len;
-			curproxy->server_id_hdr_name = strdup(defproxy.server_id_hdr_name);
-		}
-
-		if (curproxy->cap & PR_CAP_FE) {
-			curproxy->maxconn = defproxy.maxconn;
-			curproxy->backlog = defproxy.backlog;
-			curproxy->fe_sps_lim = defproxy.fe_sps_lim;
-
-			/* initialize error relocations */
-			for (rc = 0; rc < HTTP_ERR_SIZE; rc++)
-				chunk_dup(&curproxy->errmsg[rc], &defproxy.errmsg[rc]);
-
-			curproxy->to_log = defproxy.to_log & ~LW_COOKIE & ~LW_REQHDR & ~ LW_RSPHDR;
-		}
-
-		if (curproxy->cap & PR_CAP_BE) {
-			curproxy->fullconn = defproxy.fullconn;
-			curproxy->conn_retries = defproxy.conn_retries;
-
-			if (defproxy.check_req) {
-				curproxy->check_req = calloc(1, defproxy.check_len);
-				memcpy(curproxy->check_req, defproxy.check_req, defproxy.check_len);
-			}
-			curproxy->check_len = defproxy.check_len;
-
-			if (defproxy.expect_str) {
-				curproxy->expect_str = strdup(defproxy.expect_str);
-				if (defproxy.expect_regex) {
-					/* note: this regex is known to be valid */
-					curproxy->expect_regex = calloc(1, sizeof(regex_t));
-					regcomp(curproxy->expect_regex, defproxy.expect_str, REG_EXTENDED);
-				}
-			}
-
-			if (defproxy.cookie_name)
-				curproxy->cookie_name = strdup(defproxy.cookie_name);
-			curproxy->cookie_len = defproxy.cookie_len;
-			if (defproxy.cookie_domain)
-				curproxy->cookie_domain = strdup(defproxy.cookie_domain);
-
-			if (defproxy.cookie_maxidle)
-				curproxy->cookie_maxidle = defproxy.cookie_maxidle;
-
-			if (defproxy.cookie_maxlife)
-				curproxy->cookie_maxlife = defproxy.cookie_maxlife;
-
-			if (defproxy.rdp_cookie_name)
-				 curproxy->rdp_cookie_name = strdup(defproxy.rdp_cookie_name);
-			curproxy->rdp_cookie_len = defproxy.rdp_cookie_len;
-
-			if (defproxy.url_param_name)
-				curproxy->url_param_name = strdup(defproxy.url_param_name);
-			curproxy->url_param_len = defproxy.url_param_len;
-
-			if (defproxy.hh_name)
-				curproxy->hh_name = strdup(defproxy.hh_name);
-			curproxy->hh_len  = defproxy.hh_len;
-			curproxy->hh_match_domain  = defproxy.hh_match_domain;
-
-			if (defproxy.iface_name)
-				curproxy->iface_name = strdup(defproxy.iface_name);
-			curproxy->iface_len  = defproxy.iface_len;
-		}
-
-		if (curproxy->cap & PR_CAP_FE) {
-			if (defproxy.capture_name)
-				curproxy->capture_name = strdup(defproxy.capture_name);
-			curproxy->capture_namelen = defproxy.capture_namelen;
-			curproxy->capture_len = defproxy.capture_len;
-		}
-
-		if (curproxy->cap & PR_CAP_FE) {
-			curproxy->timeout.client = defproxy.timeout.client;
-			curproxy->timeout.tarpit = defproxy.timeout.tarpit;
-			curproxy->timeout.httpreq = defproxy.timeout.httpreq;
-			curproxy->timeout.httpka = defproxy.timeout.httpka;
-			curproxy->uri_auth  = defproxy.uri_auth;
-			curproxy->mon_net = defproxy.mon_net;
-			curproxy->mon_mask = defproxy.mon_mask;
-			if (defproxy.monitor_uri)
-				curproxy->monitor_uri = strdup(defproxy.monitor_uri);
-			curproxy->monitor_uri_len = defproxy.monitor_uri_len;
-			if (defproxy.defbe.name)
-				curproxy->defbe.name = strdup(defproxy.defbe.name);
-		}
-
-		if (curproxy->cap & PR_CAP_BE) {
-			curproxy->timeout.connect = defproxy.timeout.connect;
-			curproxy->timeout.server = defproxy.timeout.server;
-			curproxy->timeout.check = defproxy.timeout.check;
-			curproxy->timeout.queue = defproxy.timeout.queue;
-			curproxy->timeout.tarpit = defproxy.timeout.tarpit;
-			curproxy->timeout.httpreq = defproxy.timeout.httpreq;
-			curproxy->timeout.httpka = defproxy.timeout.httpka;
-			curproxy->source_addr = defproxy.source_addr;
-		}
-
-		curproxy->mode = defproxy.mode;
-		curproxy->logfac1 = defproxy.logfac1;
-		curproxy->logsrv1 = defproxy.logsrv1;
-		curproxy->loglev1 = defproxy.loglev1;
-		curproxy->minlvl1 = defproxy.minlvl1;
-		curproxy->logfac2 = defproxy.logfac2;
-		curproxy->logsrv2 = defproxy.logsrv2;
-		curproxy->loglev2 = defproxy.loglev2;
-		curproxy->minlvl2 = defproxy.minlvl2;
-		curproxy->grace  = defproxy.grace;
-		curproxy->conf.used_listener_id = EB_ROOT;
-		curproxy->conf.used_server_id = EB_ROOT;
-
-		goto out;
-	}
-	else if (!strcmp(args[0], "defaults")) {  /* use this one to assign default values */
-		/* some variables may have already been initialized earlier */
-		/* FIXME-20070101: we should do this too at the end of the
-		 * config parsing to free all default values.
-		 */
-		free(defproxy.check_req);
-		free(defproxy.cookie_name);
-		free(defproxy.rdp_cookie_name);
-		free(defproxy.cookie_domain);
-		free(defproxy.url_param_name);
-		free(defproxy.hh_name);
-		free(defproxy.capture_name);
-		free(defproxy.monitor_uri);
-		free(defproxy.defbe.name);
-		free(defproxy.iface_name);
-		free(defproxy.fwdfor_hdr_name);
-		defproxy.fwdfor_hdr_len = 0;
-		free(defproxy.orgto_hdr_name);
-		defproxy.orgto_hdr_len = 0;
-		free(defproxy.server_id_hdr_name);
-		defproxy.server_id_hdr_len = 0;
-		free(defproxy.expect_str);
-		if (defproxy.expect_regex) regfree(defproxy.expect_regex);
-
-		for (rc = 0; rc < HTTP_ERR_SIZE; rc++)
-			chunk_destroy(&defproxy.errmsg[rc]);
-
-		/* we cannot free uri_auth because it might already be used */
-		init_default_instance();
-		curproxy = &defproxy;
-		defproxy.cap = PR_CAP_LISTEN; /* all caps for now */
-		goto out;
-	}
-	else if (curproxy == NULL) {
-		Alert("parsing [%s:%d] : 'listen' or 'defaults' expected.\n", file, linenum);
-		err_code |= ERR_ALERT | ERR_FATAL;
-		goto out;
-	}
-    
-
-	/* Now let's parse the proxy-specific keywords */
-	if (!strcmp(args[0], "bind")) {  /* new listen addresses */
-		struct listener *new_listen, *last_listen;
-		int cur_arg;
-
-		if (curproxy == &defproxy) {
-			Alert("parsing [%s:%d] : '%s' not allowed in 'defaults' section.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		if (warnifnotcap(curproxy, PR_CAP_FE, file, linenum, args[0], NULL))
-			err_code |= ERR_WARN;
-
-		if (strchr(args[1], ':') == NULL) {
-			Alert("parsing [%s:%d] : '%s' expects [addr1]:port1[-end1]{,[addr]:port[-end]}... as arguments.\n",
-			      file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		last_listen = curproxy->listen;
-		if (!str2listener(args[1], curproxy)) {
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		new_listen = curproxy->listen;
-		while (new_listen != last_listen) {
-			new_listen->conf.file = file;
-			new_listen->conf.line = linenum;
-			new_listen = new_listen->next;
-			global.maxsock++;
-		}
-
-		cur_arg = 2;
-		while (*(args[cur_arg])) {
-			if (!strcmp(args[cur_arg], "interface")) { /* specifically bind to this interface */
-#ifdef SO_BINDTODEVICE
-				struct listener *l;
-
-				if (!*args[cur_arg + 1]) {
-					Alert("parsing [%s:%d] : '%s' : missing interface name.\n",
-					      file, linenum, args[0]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-				
-				for (l = curproxy->listen; l != last_listen; l = l->next)
-					l->interface = strdup(args[cur_arg + 1]);
-
-				global.last_checks |= LSTCHK_NETADM;
-
-				cur_arg += 2;
-				continue;
-#else
-				Alert("parsing [%s:%d] : '%s' : '%s' option not implemented.\n",
-				      file, linenum, args[0], args[cur_arg]);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-#endif
-			}
-			if (!strcmp(args[cur_arg], "mss")) { /* set MSS of listening socket */
-#ifdef TCP_MAXSEG
-				struct listener *l;
-				int mss;
-
-				if (!*args[cur_arg + 1]) {
-					Alert("parsing [%s:%d] : '%s' : missing MSS value.\n",
-					      file, linenum, args[0]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-
-				mss = str2uic(args[cur_arg + 1]);
-				if (mss < 1 || mss > 65535) {
-					Alert("parsing [%s:%d]: %s expects an MSS value between 1 and 65535.\n",
-					      file, linenum, args[0]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-
-				for (l = curproxy->listen; l != last_listen; l = l->next)
-					l->maxseg = mss;
-
-				cur_arg += 2;
-				continue;
-#else
-				Alert("parsing [%s:%d] : '%s' : '%s' option not implemented.\n",
-				      file, linenum, args[0], args[cur_arg]);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-#endif
-			}
-
-			if (!strcmp(args[cur_arg], "defer-accept")) { /* wait for some data for 1 second max before doing accept */
-#ifdef TCP_DEFER_ACCEPT
-				struct listener *l;
-
-				for (l = curproxy->listen; l != last_listen; l = l->next)
-					l->options |= LI_O_DEF_ACCEPT;
-
-				cur_arg ++;
-				continue;
-#else
-				Alert("parsing [%s:%d] : '%s' : '%s' option not implemented.\n",
-				      file, linenum, args[0], args[cur_arg]);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-#endif
-			}
-
-			if (!strcmp(args[cur_arg], "transparent")) { /* transparently bind to these addresses */
-#ifdef CONFIG_HAP_LINUX_TPROXY
-				struct listener *l;
-
-				for (l = curproxy->listen; l != last_listen; l = l->next)
-					l->options |= LI_O_FOREIGN;
-
-				cur_arg ++;
-				continue;
-#else
-				Alert("parsing [%s:%d] : '%s' : '%s' option not implemented.\n",
-				      file, linenum, args[0], args[cur_arg]);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-#endif
-			}
-
-			if (!strcmp(args[cur_arg], "accept-proxy")) { /* expect a 'PROXY' line first */
-				struct listener *l;
-
-				for (l = curproxy->listen; l != last_listen; l = l->next)
-					l->options |= LI_O_ACC_PROXY;
-
-				cur_arg ++;
-				continue;
-			}
-
-			if (!strcmp(args[cur_arg], "name")) {
-				struct listener *l;
-
-				for (l = curproxy->listen; l != last_listen; l = l->next)
-					l->name = strdup(args[cur_arg + 1]);
-
-				cur_arg += 2;
-				continue;
-			}
-
-			if (!strcmp(args[cur_arg], "id")) {
-				struct eb32_node *node;
-				struct listener *l;
-
-				if (curproxy->listen->next != last_listen) {
-					Alert("parsing [%s:%d]: '%s' can be only used with a single socket.\n",
-						file, linenum, args[cur_arg]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-
-				if (!*args[cur_arg + 1]) {
-					Alert("parsing [%s:%d]: '%s' expects an integer argument.\n",
-						file, linenum, args[cur_arg]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-
-				curproxy->listen->luid = atol(args[cur_arg + 1]);
-				curproxy->listen->conf.id.key = curproxy->listen->luid;
-
-				if (curproxy->listen->luid <= 0) {
-					Alert("parsing [%s:%d]: custom id has to be > 0\n",
-						file, linenum);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-
-				node = eb32_lookup(&curproxy->conf.used_listener_id, curproxy->listen->luid);
-				if (node) {
-					l = container_of(node, struct listener, conf.id);
-					Alert("parsing [%s:%d]: custom id %d for socket '%s' already used at %s:%d.\n",
-					      file, linenum, l->luid, args[1], l->conf.file, l->conf.line);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-				eb32_insert(&curproxy->conf.used_listener_id, &curproxy->listen->conf.id);
-
-				cur_arg += 2;
-				continue;
-			}
-
-			Alert("parsing [%s:%d] : '%s' only supports the 'transparent', 'accept-proxy', 'defer-accept', 'name', 'id', 'mss' and 'interface' options.\n",
-			      file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		goto out;
-	}
-	else if (!strcmp(args[0], "monitor-net")) {  /* set the range of IPs to ignore */
-		if (!*args[1] || !str2net(args[1], &curproxy->mon_net, &curproxy->mon_mask)) {
-			Alert("parsing [%s:%d] : '%s' expects address[/mask].\n",
-			      file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		if (warnifnotcap(curproxy, PR_CAP_FE, file, linenum, args[0], NULL))
-			err_code |= ERR_WARN;
-
-		/* flush useless bits */
-		curproxy->mon_net.s_addr &= curproxy->mon_mask.s_addr;
-		goto out;
-	}
-	else if (!strcmp(args[0], "monitor-uri")) {  /* set the URI to intercept */
-		if (warnifnotcap(curproxy, PR_CAP_FE, file, linenum, args[0], NULL))
-			err_code |= ERR_WARN;
-
-		if (!*args[1]) {
-			Alert("parsing [%s:%d] : '%s' expects an URI.\n",
-			      file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		free(curproxy->monitor_uri);
-		curproxy->monitor_uri_len = strlen(args[1]);
-		curproxy->monitor_uri = (char *)calloc(1, curproxy->monitor_uri_len + 1);
-		memcpy(curproxy->monitor_uri, args[1], curproxy->monitor_uri_len);
-		curproxy->monitor_uri[curproxy->monitor_uri_len] = '\0';
-
-		goto out;
-	}
-	else if (!strcmp(args[0], "mode")) {  /* sets the proxy mode */
-		if (!strcmp(args[1], "http")) curproxy->mode = PR_MODE_HTTP;
-		else if (!strcmp(args[1], "tcp")) curproxy->mode = PR_MODE_TCP;
-		else if (!strcmp(args[1], "health")) curproxy->mode = PR_MODE_HEALTH;
-		else {
-			Alert("parsing [%s:%d] : unknown proxy mode '%s'.\n", file, linenum, args[1]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-	}
-	else if (!strcmp(args[0], "id")) {
-		struct eb32_node *node;
-
-		if (curproxy == &defproxy) {
-			Alert("parsing [%s:%d]: '%s' not allowed in 'defaults' section.\n",
-				 file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		if (!*args[1]) {
-			Alert("parsing [%s:%d]: '%s' expects an integer argument.\n",
-				file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		curproxy->uuid = atol(args[1]);
-		curproxy->conf.id.key = curproxy->uuid;
-
-		if (curproxy->uuid <= 0) {
-			Alert("parsing [%s:%d]: custom id has to be > 0.\n",
-				file, linenum);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		node = eb32_lookup(&used_proxy_id, curproxy->uuid);
-		if (node) {
-			struct proxy *target = container_of(node, struct proxy, conf.id);
-			Alert("parsing [%s:%d]: %s %s reuses same custom id as %s %s (declared at %s:%d).\n",
-			      file, linenum, proxy_type_str(curproxy), curproxy->id,
-			      proxy_type_str(target), target->id, target->conf.file, target->conf.line);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		eb32_insert(&used_proxy_id, &curproxy->conf.id);
-	}
-	else if (!strcmp(args[0], "description")) {
-		int i, len=0;
-		char *d;
-
-		if (curproxy == &defproxy) {
-			Alert("parsing [%s:%d]: '%s' not allowed in 'defaults' section.\n",
-				 file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		if (!*args[1]) {
-			Alert("parsing [%s:%d]: '%s' expects a string argument.\n",
-				file, linenum, args[0]);
-			return -1;
-		}
-
-		for(i=1; *args[i]; i++)
-			len += strlen(args[i])+1;
-
-		d = (char *)calloc(1, len);
-		curproxy->desc = d;
-
-		d += sprintf(d, "%s", args[1]);
-		for(i=2; *args[i]; i++)
-			d += sprintf(d, " %s", args[i]);
-
-	}
-	else if (!strcmp(args[0], "disabled")) {  /* disables this proxy */
-		curproxy->state = PR_STSTOPPED;
-	}
-	else if (!strcmp(args[0], "enabled")) {  /* enables this proxy (used to revert a disabled default) */
-		curproxy->state = PR_STNEW;
-	}
-	else if (!strcmp(args[0], "bind-process")) {  /* enable this proxy only on some processes */
-		int cur_arg = 1;
-		unsigned int set = 0;
-
-		while (*args[cur_arg]) {
-			int u;
-			if (strcmp(args[cur_arg], "all") == 0) {
-				set = 0;
-				break;
-			}
-			else if (strcmp(args[cur_arg], "odd") == 0) {
-				set |= 0x55555555;
-			}
-			else if (strcmp(args[cur_arg], "even") == 0) {
-				set |= 0xAAAAAAAA;
-			}
-			else {
-				u = str2uic(args[cur_arg]);
-				if (u < 1 || u > 32) {
-					Alert("parsing [%s:%d]: %s expects 'all', 'odd', 'even', or process numbers from 1 to 32.\n",
-					      file, linenum, args[0]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-				if (u > global.nbproc) {
-					Warning("parsing [%s:%d]: %s references process number higher than global.nbproc.\n",
-						file, linenum, args[0]);
-					err_code |= ERR_WARN;
-				}
-				set |= 1 << (u - 1);
-			}
-			cur_arg++;
-		}
-		curproxy->bind_proc = set;
-	}
-	else if (!strcmp(args[0], "acl")) {  /* add an ACL */
-		if (curproxy == &defproxy) {
-			Alert("parsing [%s:%d] : '%s' not allowed in 'defaults' section.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		err = invalid_char(args[1]);
-		if (err) {
-			Alert("parsing [%s:%d] : character '%c' is not permitted in acl name '%s'.\n",
-			      file, linenum, *err, args[1]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-		}
-
-		if (parse_acl((const char **)args + 1, &curproxy->acl) == NULL) {
-			Alert("parsing [%s:%d] : error detected while parsing ACL '%s'.\n",
-			      file, linenum, args[1]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-	}
-	else if (!strcmp(args[0], "cookie")) {  /* cookie name */
-		int cur_arg;
-
-		if (warnifnotcap(curproxy, PR_CAP_BE, file, linenum, args[0], NULL))
-			err_code |= ERR_WARN;
-
-		if (*(args[1]) == 0) {
-			Alert("parsing [%s:%d] : '%s' expects <cookie_name> as argument.\n",
-			      file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		curproxy->options &= ~PR_O_COOK_ANY;
-		curproxy->options2 &= ~PR_O2_COOK_PSV;
-		curproxy->cookie_maxidle = curproxy->cookie_maxlife = 0;
-		free(curproxy->cookie_domain); curproxy->cookie_domain = NULL;
-		free(curproxy->cookie_name);
-		curproxy->cookie_name = strdup(args[1]);
-		curproxy->cookie_len = strlen(curproxy->cookie_name);
-
-		cur_arg = 2;
-		while (*(args[cur_arg])) {
-			if (!strcmp(args[cur_arg], "rewrite")) {
-				curproxy->options |= PR_O_COOK_RW;
-			}
-			else if (!strcmp(args[cur_arg], "indirect")) {
-				curproxy->options |= PR_O_COOK_IND;
-			}
-			else if (!strcmp(args[cur_arg], "insert")) {
-				curproxy->options |= PR_O_COOK_INS;
-			}
-			else if (!strcmp(args[cur_arg], "nocache")) {
-				curproxy->options |= PR_O_COOK_NOC;
-			}
-			else if (!strcmp(args[cur_arg], "postonly")) {
-				curproxy->options |= PR_O_COOK_POST;
-			}
-			else if (!strcmp(args[cur_arg], "preserve")) {
-				curproxy->options2 |= PR_O2_COOK_PSV;
-			}
-			else if (!strcmp(args[cur_arg], "prefix")) {
-				curproxy->options |= PR_O_COOK_PFX;
-			}
-			else if (!strcmp(args[cur_arg], "domain")) {
-				if (!*args[cur_arg + 1]) {
-					Alert("parsing [%s:%d]: '%s' expects <domain> as argument.\n",
-						file, linenum, args[cur_arg]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-
-				if (*args[cur_arg + 1] != '.' || !strchr(args[cur_arg + 1] + 1, '.')) {
-					/* rfc2109, 4.3.2 Rejecting Cookies */
-					Warning("parsing [%s:%d]: domain '%s' contains no embedded"
-						" dots nor does not start with a dot."
-						" RFC forbids it, this configuration may not work properly.\n",
-						file, linenum, args[cur_arg + 1]);
-					err_code |= ERR_WARN;
-				}
-
-				err = invalid_domainchar(args[cur_arg + 1]);
-				if (err) {
-					Alert("parsing [%s:%d]: character '%c' is not permitted in domain name '%s'.\n",
-						file, linenum, *err, args[cur_arg + 1]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-
-				if (!curproxy->cookie_domain) {
-					curproxy->cookie_domain = strdup(args[cur_arg + 1]);
-				} else {
-					/* one domain was already specified, add another one by
-					 * building the string which will be returned along with
-					 * the cookie.
-					 */
-					char *new_ptr;
-					int new_len = strlen(curproxy->cookie_domain) +
-						strlen("; domain=") + strlen(args[cur_arg + 1]) + 1;
-					new_ptr = malloc(new_len);
-					snprintf(new_ptr, new_len, "%s; domain=%s", curproxy->cookie_domain, args[cur_arg+1]);
-					free(curproxy->cookie_domain);
-					curproxy->cookie_domain = new_ptr;
-				}
-				cur_arg++;
-			}
-			else if (!strcmp(args[cur_arg], "maxidle")) {
-				unsigned int maxidle;
-				const char *res;
-
-				if (!*args[cur_arg + 1]) {
-					Alert("parsing [%s:%d]: '%s' expects <idletime> in seconds as argument.\n",
-						file, linenum, args[cur_arg]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-
-				res = parse_time_err(args[cur_arg + 1], &maxidle, TIME_UNIT_S);
-				if (res) {
-					Alert("parsing [%s:%d]: unexpected character '%c' in argument to <%s>.\n",
-					      file, linenum, *res, args[cur_arg]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-				curproxy->cookie_maxidle = maxidle;
-				cur_arg++;
-			}
-			else if (!strcmp(args[cur_arg], "maxlife")) {
-				unsigned int maxlife;
-				const char *res;
-
-				if (!*args[cur_arg + 1]) {
-					Alert("parsing [%s:%d]: '%s' expects <lifetime> in seconds as argument.\n",
-						file, linenum, args[cur_arg]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-
-				res = parse_time_err(args[cur_arg + 1], &maxlife, TIME_UNIT_S);
-				if (res) {
-					Alert("parsing [%s:%d]: unexpected character '%c' in argument to <%s>.\n",
-					      file, linenum, *res, args[cur_arg]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-				curproxy->cookie_maxlife = maxlife;
-				cur_arg++;
-			}
-			else {
-				Alert("parsing [%s:%d] : '%s' supports 'rewrite', 'insert', 'prefix', 'indirect', 'nocache', 'postonly', 'domain', 'maxidle, and 'maxlife' options.\n",
-				      file, linenum, args[0]);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			}
-			cur_arg++;
-		}
-		if (!POWEROF2(curproxy->options & (PR_O_COOK_RW|PR_O_COOK_IND))) {
-			Alert("parsing [%s:%d] : cookie 'rewrite' and 'indirect' modes are incompatible.\n",
-			      file, linenum);
-			err_code |= ERR_ALERT | ERR_FATAL;
-		}
-
-		if (!POWEROF2(curproxy->options & (PR_O_COOK_RW|PR_O_COOK_INS|PR_O_COOK_PFX))) {
-			Alert("parsing [%s:%d] : cookie 'rewrite', 'insert' and 'prefix' modes are incompatible.\n",
-			      file, linenum);
-			err_code |= ERR_ALERT | ERR_FATAL;
-		}
-
-		if ((curproxy->options2 & PR_O2_COOK_PSV) && !(curproxy->options & (PR_O_COOK_INS|PR_O_COOK_IND))) {
-			Alert("parsing [%s:%d] : cookie 'preserve' requires at least 'insert' or 'indirect'.\n",
-			      file, linenum);
-			err_code |= ERR_ALERT | ERR_FATAL;
-		}
-	}/* end else if (!strcmp(args[0], "cookie"))  */
-	else if (!strcmp(args[0], "persist")) {  /* persist */
-		if (*(args[1]) == 0) {
-			Alert("parsing [%s:%d] : missing persist method.\n",
-				file, linenum);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-                }
-
-		if (!strncmp(args[1], "rdp-cookie", 10)) {
-			curproxy->options2 |= PR_O2_RDPC_PRST;
-
-	                if (*(args[1] + 10) == '(') { /* cookie name */
-				const char *beg, *end;
-
-				beg = args[1] + 11;
-				end = strchr(beg, ')');
-
-				if (!end || end == beg) {
-					Alert("parsing [%s:%d] : persist rdp-cookie(name)' requires an rdp cookie name.\n",
-					      file, linenum);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-
-				free(curproxy->rdp_cookie_name);
-				curproxy->rdp_cookie_name = my_strndup(beg, end - beg);
-				curproxy->rdp_cookie_len = end-beg;
-			}
-			else if (*(args[1] + 10) == '\0') { /* default cookie name 'msts' */
-				free(curproxy->rdp_cookie_name);
-				curproxy->rdp_cookie_name = strdup("msts");
-				curproxy->rdp_cookie_len = strlen(curproxy->rdp_cookie_name);
-			}
-			else { /* syntax */
-				Alert("parsing [%s:%d] : persist rdp-cookie(name)' requires an rdp cookie name.\n",
-				      file, linenum);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			}
-		}
-		else {
-			Alert("parsing [%s:%d] : unknown persist method.\n",
-			      file, linenum);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-	}
-	else if (!strcmp(args[0], "appsession")) {  /* cookie name */
-		int cur_arg;
-
-		if (curproxy == &defproxy) {
-			Alert("parsing [%s:%d] : '%s' not allowed in 'defaults' section.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		if (warnifnotcap(curproxy, PR_CAP_BE, file, linenum, args[0], NULL))
-			err_code |= ERR_WARN;
-
-		if (*(args[5]) == 0) {
-			Alert("parsing [%s:%d] : '%s' expects 'appsession' <cookie_name> 'len' <len> 'timeout' <timeout> [options*].\n",
-			      file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		have_appsession = 1;
-		free(curproxy->appsession_name);
-		curproxy->appsession_name = strdup(args[1]);
-		curproxy->appsession_name_len = strlen(curproxy->appsession_name);
-		curproxy->appsession_len = atoi(args[3]);
-		err = parse_time_err(args[5], &val, TIME_UNIT_MS);
-		if (err) {
-			Alert("parsing [%s:%d] : unexpected character '%c' in %s timeout.\n",
-			      file, linenum, *err, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		curproxy->timeout.appsession = val;
-
-		if (appsession_hash_init(&(curproxy->htbl_proxy), destroy) == 0) {
-			Alert("parsing [%s:%d] : out of memory.\n", file, linenum);
-			err_code |= ERR_ALERT | ERR_ABORT;
-			goto out;
-		}
-
-		cur_arg = 6;
-		curproxy->options2 &= ~PR_O2_AS_REQL;
-		curproxy->options2 &= ~PR_O2_AS_M_ANY;
-		curproxy->options2 |= PR_O2_AS_M_PP;
-		while (*(args[cur_arg])) {
-			if (!strcmp(args[cur_arg], "request-learn")) {
-				curproxy->options2 |= PR_O2_AS_REQL;
-			} else if (!strcmp(args[cur_arg], "prefix")) {
-				curproxy->options2 |= PR_O2_AS_PFX;
-			} else if (!strcmp(args[cur_arg], "mode")) {
-				if (!*args[cur_arg + 1]) {
-					Alert("parsing [%s:%d] : '%s': missing argument for '%s'.\n",
-					      file, linenum, args[0], args[cur_arg]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-
-				cur_arg++;
-				if (!strcmp(args[cur_arg], "query-string")) {
-					curproxy->options2 &= ~PR_O2_AS_M_ANY;
-					curproxy->options2 |= PR_O2_AS_M_QS;
-				} else if (!strcmp(args[cur_arg], "path-parameters")) {
-					curproxy->options2 &= ~PR_O2_AS_M_ANY;
-					curproxy->options2 |= PR_O2_AS_M_PP;
-				} else {
-					Alert("parsing [%s:%d] : unknown mode '%s'\n", file, linenum, args[cur_arg]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-			}
-			cur_arg++;
-		}
-	} /* Url App Session */
-	else if (!strcmp(args[0], "capture")) {
-		if (warnifnotcap(curproxy, PR_CAP_FE, file, linenum, args[0], NULL))
-			err_code |= ERR_WARN;
-
-		if (!strcmp(args[1], "cookie")) {  /* name of a cookie to capture */
-			if (curproxy == &defproxy) {
-				Alert("parsing [%s:%d] : '%s %s' not allowed in 'defaults' section.\n", file, linenum, args[0], args[1]);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			}
-
-			if (*(args[4]) == 0) {
-				Alert("parsing [%s:%d] : '%s' expects 'cookie' <cookie_name> 'len' <len>.\n",
-				      file, linenum, args[0]);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			}
-			free(curproxy->capture_name);
-			curproxy->capture_name = strdup(args[2]);
-			curproxy->capture_namelen = strlen(curproxy->capture_name);
-			curproxy->capture_len = atol(args[4]);
-			if (curproxy->capture_len >= CAPTURE_LEN) {
-				Warning("parsing [%s:%d] : truncating capture length to %d bytes.\n",
-					file, linenum, CAPTURE_LEN - 1);
-				err_code |= ERR_WARN;
-				curproxy->capture_len = CAPTURE_LEN - 1;
-			}
-			curproxy->to_log |= LW_COOKIE;
-		}
-		else if (!strcmp(args[1], "request") && !strcmp(args[2], "header")) {
-			struct cap_hdr *hdr;
-
-			if (curproxy == &defproxy) {
-				Alert("parsing [%s:%d] : '%s %s' not allowed in 'defaults' section.\n", file, linenum, args[0], args[1]);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			}
-
-			if (*(args[3]) == 0 || strcmp(args[4], "len") != 0 || *(args[5]) == 0) {
-				Alert("parsing [%s:%d] : '%s %s' expects 'header' <header_name> 'len' <len>.\n",
-				      file, linenum, args[0], args[1]);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			}
-
-			hdr = calloc(sizeof(struct cap_hdr), 1);
-			hdr->next = curproxy->req_cap;
-			hdr->name = strdup(args[3]);
-			hdr->namelen = strlen(args[3]);
-			hdr->len = atol(args[5]);
-			hdr->pool = create_pool("caphdr", hdr->len + 1, MEM_F_SHARED);
-			hdr->index = curproxy->nb_req_cap++;
-			curproxy->req_cap = hdr;
-			curproxy->to_log |= LW_REQHDR;
-		}
-		else if (!strcmp(args[1], "response") && !strcmp(args[2], "header")) {
-			struct cap_hdr *hdr;
-
-			if (curproxy == &defproxy) {
-				Alert("parsing [%s:%d] : '%s %s' not allowed in 'defaults' section.\n", file, linenum, args[0], args[1]);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			}
-
-			if (*(args[3]) == 0 || strcmp(args[4], "len") != 0 || *(args[5]) == 0) {
-				Alert("parsing [%s:%d] : '%s %s' expects 'header' <header_name> 'len' <len>.\n",
-				      file, linenum, args[0], args[1]);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			}
-			hdr = calloc(sizeof(struct cap_hdr), 1);
-			hdr->next = curproxy->rsp_cap;
-			hdr->name = strdup(args[3]);
-			hdr->namelen = strlen(args[3]);
-			hdr->len = atol(args[5]);
-			hdr->pool = create_pool("caphdr", hdr->len + 1, MEM_F_SHARED);
-			hdr->index = curproxy->nb_rsp_cap++;
-			curproxy->rsp_cap = hdr;
-			curproxy->to_log |= LW_RSPHDR;
-		}
-		else {
-			Alert("parsing [%s:%d] : '%s' expects 'cookie' or 'request header' or 'response header'.\n",
-			      file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-	}
-	else if (!strcmp(args[0], "retries")) {  /* connection retries */
-		if (warnifnotcap(curproxy, PR_CAP_BE, file, linenum, args[0], NULL))
-			err_code |= ERR_WARN;
-
-		if (*(args[1]) == 0) {
-			Alert("parsing [%s:%d] : '%s' expects an integer argument (dispatch counts for one).\n",
-			      file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		curproxy->conn_retries = atol(args[1]);
-	}
-	else if (!strcmp(args[0], "http-request")) {	/* request access control: allow/deny/auth */
-		struct req_acl_rule *req_acl;
-
-		if (curproxy == &defproxy) {
-			Alert("parsing [%s:%d]: '%s' not allowed in 'defaults' section.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-
-		if (!LIST_ISEMPTY(&curproxy->req_acl) && !LIST_PREV(&curproxy->req_acl, struct req_acl_rule *, list)->cond) {
-			Warning("parsing [%s:%d]: previous '%s' action has no condition attached, further entries are NOOP.\n",
-			        file, linenum, args[0]);
-			err_code |= ERR_WARN;
-		}
-
-		req_acl = parse_auth_cond((const char **)args + 1, file, linenum, curproxy);
-
-		if (!req_acl) {
-			err_code |= ERR_ALERT | ERR_ABORT;
-			goto out;
-		}
-
-		err_code |= warnif_cond_requires_resp(req_acl->cond, file, linenum);
-		LIST_ADDQ(&curproxy->req_acl, &req_acl->list);
-	}
-	else if (!strcmp(args[0], "http-send-name-header")) { /* send server name in request header */
-		/* set the header name and length into the proxy structure */
-		if (warnifnotcap(curproxy, PR_CAP_BE, file, linenum, args[0], NULL))
-			err_code |= ERR_WARN;
-
-		if (!*args[1]) {
-			Alert("parsing [%s:%d] : '%s' requires a header string.\n",
-			      file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		/* set the desired header name */
-		free(curproxy->server_id_hdr_name);
-		curproxy->server_id_hdr_name = strdup(args[1]);
-		curproxy->server_id_hdr_len  = strlen(curproxy->server_id_hdr_name);
-	}
-	else if (!strcmp(args[0], "block")) {  /* early blocking based on ACLs */
-		if (curproxy == &defproxy) {
-			Alert("parsing [%s:%d] : '%s' not allowed in 'defaults' section.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		if (strcmp(args[1], "if") != 0 && strcmp(args[1], "unless") != 0) {
-			Alert("parsing [%s:%d] : '%s' requires either 'if' or 'unless' followed by a condition.\n",
-			      file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		if ((cond = build_acl_cond(file, linenum, curproxy, (const char **)args + 1)) == NULL) {
-			Alert("parsing [%s:%d] : error detected while parsing blocking condition.\n",
-			      file, linenum);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		LIST_ADDQ(&curproxy->block_cond, &cond->list);
-		warnif_misplaced_block(curproxy, file, linenum, args[0]);
-	}
-	else if (!strcmp(args[0], "redirect")) {
-		struct redirect_rule *rule;
-		int cur_arg;
-		int type = REDIRECT_TYPE_NONE;
-		int code = 302;
-		char *destination = NULL;
-		char *cookie = NULL;
-		int cookie_set = 0;
-		unsigned int flags = REDIRECT_FLAG_NONE;
-
-		if (curproxy == &defproxy) {
-			Alert("parsing [%s:%d] : '%s' not allowed in 'defaults' section.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		cur_arg = 1;
-		while (*(args[cur_arg])) {
-			if (!strcmp(args[cur_arg], "location")) {
-				if (!*args[cur_arg + 1]) {
-					Alert("parsing [%s:%d] : '%s': missing argument for '%s'.\n",
-					      file, linenum, args[0], args[cur_arg]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-
-				type = REDIRECT_TYPE_LOCATION;
-				cur_arg++;
-				destination = args[cur_arg];
-			}
-			else if (!strcmp(args[cur_arg], "prefix")) {
-				if (!*args[cur_arg + 1]) {
-					Alert("parsing [%s:%d] : '%s': missing argument for '%s'.\n",
-					      file, linenum, args[0], args[cur_arg]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-
-				type = REDIRECT_TYPE_PREFIX;
-				cur_arg++;
-				destination = args[cur_arg];
-			}
-			else if (!strcmp(args[cur_arg], "set-cookie")) {
-				if (!*args[cur_arg + 1]) {
-					Alert("parsing [%s:%d] : '%s': missing argument for '%s'.\n",
-					      file, linenum, args[0], args[cur_arg]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-
-				cur_arg++;
-				cookie = args[cur_arg];
-				cookie_set = 1;
-			}
-			else if (!strcmp(args[cur_arg], "clear-cookie")) {
-				if (!*args[cur_arg + 1]) {
-					Alert("parsing [%s:%d] : '%s': missing argument for '%s'.\n",
-					      file, linenum, args[0], args[cur_arg]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-
-				cur_arg++;
-				cookie = args[cur_arg];
-				cookie_set = 0;
-			}
-			else if (!strcmp(args[cur_arg],"code")) {
-				if (!*args[cur_arg + 1]) {
-					Alert("parsing [%s:%d] : '%s': missing HTTP code.\n",
-					      file, linenum, args[0]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-				cur_arg++;
-				code = atol(args[cur_arg]);
-				if (code < 301 || code > 303) {
-					Alert("parsing [%s:%d] : '%s': unsupported HTTP code '%d'.\n",
-					      file, linenum, args[0], code);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-			}
-			else if (!strcmp(args[cur_arg],"drop-query")) {
-				flags |= REDIRECT_FLAG_DROP_QS;
-			}
-			else if (!strcmp(args[cur_arg],"append-slash")) {
-				flags |= REDIRECT_FLAG_APPEND_SLASH;
-			}
-			else if (strcmp(args[cur_arg], "if") == 0 ||
-				 strcmp(args[cur_arg], "unless") == 0) {
-				cond = build_acl_cond(file, linenum, curproxy, (const char **)args + cur_arg);
-				if (!cond) {
-					Alert("parsing [%s:%d] : '%s': error detected while parsing redirect condition.\n",
-					      file, linenum, args[0]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-				break;
-			}
-			else {
-				Alert("parsing [%s:%d] : '%s' expects 'code', 'prefix', 'location', 'set-cookie', 'clear-cookie', 'drop-query' or 'append-slash' (was '%s').\n",
-				      file, linenum, args[0], args[cur_arg]);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			}
-			cur_arg++;
-		}
-
-		if (type == REDIRECT_TYPE_NONE) {
-			Alert("parsing [%s:%d] : '%s' expects a redirection type ('prefix' or 'location').\n",
-			      file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		rule = (struct redirect_rule *)calloc(1, sizeof(*rule));
-		rule->cond = cond;
-		rule->rdr_str = strdup(destination);
-		rule->rdr_len = strlen(destination);
-		if (cookie) {
-			/* depending on cookie_set, either we want to set the cookie, or to clear it.
-			 * a clear consists in appending "; path=/; Max-Age=0;" at the end.
-			 */
-			rule->cookie_len = strlen(cookie);
-			if (cookie_set) {
-				rule->cookie_str = malloc(rule->cookie_len + 10);
-				memcpy(rule->cookie_str, cookie, rule->cookie_len);
-				memcpy(rule->cookie_str + rule->cookie_len, "; path=/;", 10);
-				rule->cookie_len += 9;
-			} else {
-				rule->cookie_str = malloc(rule->cookie_len + 21);
-				memcpy(rule->cookie_str, cookie, rule->cookie_len);
-				memcpy(rule->cookie_str + rule->cookie_len, "; path=/; Max-Age=0;", 21);
-				rule->cookie_len += 20;
-			}
-		}
-		rule->type = type;
-		rule->code = code;
-		rule->flags = flags;
-		LIST_INIT(&rule->list);
-		LIST_ADDQ(&curproxy->redirect_rules, &rule->list);
-		warnif_rule_after_use_backend(curproxy, file, linenum, args[0]);
-	}
-	else if (!strcmp(args[0], "use_backend")) {
-		struct switching_rule *rule;
-
-		if (curproxy == &defproxy) {
-			Alert("parsing [%s:%d] : '%s' not allowed in 'defaults' section.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		if (warnifnotcap(curproxy, PR_CAP_FE, file, linenum, args[0], NULL))
-			err_code |= ERR_WARN;
-
-		if (*(args[1]) == 0) {
-			Alert("parsing [%s:%d] : '%s' expects a backend name.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		if (strcmp(args[2], "if") != 0 && strcmp(args[2], "unless") != 0) {
-			Alert("parsing [%s:%d] : '%s' requires either 'if' or 'unless' followed by a condition.\n",
-			      file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		if ((cond = build_acl_cond(file, linenum, curproxy, (const char **)args + 2)) == NULL) {
-			Alert("parsing [%s:%d] : error detected while parsing switching rule.\n",
-			      file, linenum);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		err_code |= warnif_cond_requires_resp(cond, file, linenum);
-
-		rule = (struct switching_rule *)calloc(1, sizeof(*rule));
-		rule->cond = cond;
-		rule->be.name = strdup(args[1]);
-		LIST_INIT(&rule->list);
-		LIST_ADDQ(&curproxy->switching_rules, &rule->list);
-	}
-	else if ((!strcmp(args[0], "force-persist")) ||
-		 (!strcmp(args[0], "ignore-persist"))) {
-		struct persist_rule *rule;
-
-		if (curproxy == &defproxy) {
-			Alert("parsing [%s:%d] : '%s' not allowed in 'defaults' section.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		if (warnifnotcap(curproxy, PR_CAP_FE|PR_CAP_BE, file, linenum, args[0], NULL))
-			err_code |= ERR_WARN;
-
-		if (strcmp(args[1], "if") != 0 && strcmp(args[1], "unless") != 0) {
-			Alert("parsing [%s:%d] : '%s' requires either 'if' or 'unless' followed by a condition.\n",
-			      file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		if ((cond = build_acl_cond(file, linenum, curproxy, (const char **)args + 1)) == NULL) {
-			Alert("parsing [%s:%d] : error detected while parsing a '%s' rule.\n",
-			      file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		err_code |= warnif_cond_requires_resp(cond, file, linenum);
-
-		rule = (struct persist_rule *)calloc(1, sizeof(*rule));
-		rule->cond = cond;
-		if (!strcmp(args[0], "force-persist")) {
-			rule->type = PERSIST_TYPE_FORCE;
-		} else {
-			rule->type = PERSIST_TYPE_IGNORE;
-		}
-		LIST_INIT(&rule->list);
-		LIST_ADDQ(&curproxy->persist_rules, &rule->list);
-	}
-	else if (!strcmp(args[0], "stick-table")) {
-		int myidx = 1;
-
-		curproxy->table.type = (unsigned int)-1;
-		while (*args[myidx]) {
-			const char *err;
-
-			if (strcmp(args[myidx], "size") == 0) {
-				myidx++;
-				if (!*(args[myidx])) {
-					Alert("parsing [%s:%d] : stick-table: missing argument after '%s'.\n",
-					      file, linenum, args[myidx-1]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-				if ((err = parse_size_err(args[myidx], &curproxy->table.size))) {
-					Alert("parsing [%s:%d] : stick-table: unexpected character '%c' in argument of '%s'.\n",
-					      file, linenum, *err, args[myidx-1]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-				myidx++;
-			}
-			else if (strcmp(args[myidx], "expire") == 0) {
-				myidx++;
-				if (!*(args[myidx])) {
-					Alert("parsing [%s:%d] : stick-table: missing argument after '%s'.\n",
-					      file, linenum, args[myidx-1]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-				err = parse_time_err(args[myidx], &val, TIME_UNIT_MS);
-				if (err) {
-					Alert("parsing [%s:%d] : stick-table: unexpected character '%c' in argument of '%s'.\n",
-					      file, linenum, *err, args[myidx-1]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-				curproxy->table.expire = val;
-				myidx++;
-			}
-			else if (strcmp(args[myidx], "nopurge") == 0) {
-				curproxy->table.nopurge = 1;
-				myidx++;
-			}
-			else if (strcmp(args[myidx], "type") == 0) {
-				myidx++;
-				if (stktable_parse_type(args, &myidx, &curproxy->table.type, &curproxy->table.key_size) != 0) {
-					Alert("parsing [%s:%d] : stick-table: unknown type '%s'.\n",
-					      file, linenum, args[myidx]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-				/* myidx already points to next arg */
-			}
-			else {
-				Alert("parsing [%s:%d] : stick-table: unknown argument '%s'.\n",
-				      file, linenum, args[myidx]);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			}
-		}
-
-		if (!curproxy->table.size) {
-			Alert("parsing [%s:%d] : stick-table: missing size.\n",
-			       file, linenum);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		if (curproxy->table.type == (unsigned int)-1) {
-			Alert("parsing [%s:%d] : stick-table: missing type.\n",
-			       file, linenum);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-	}
-	else if (!strcmp(args[0], "stick")) {
-		struct sticking_rule *rule;
-		struct pattern_expr *expr;
-		int myidx = 0;
-		const char *name = NULL;
-		int flags;
-
-		if (curproxy == &defproxy) {
-			Alert("parsing [%s:%d] : '%s' not allowed in 'defaults' section.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		if (warnifnotcap(curproxy, PR_CAP_BE, file, linenum, args[0], NULL)) {
-			err_code |= ERR_WARN;
-			goto out;
-		}
-
-		myidx++;
-		if ((strcmp(args[myidx], "store") == 0) ||
-		    (strcmp(args[myidx], "store-request") == 0)) {
-			myidx++;
-			flags = STK_IS_STORE;
-		}
-		else if (strcmp(args[myidx], "store-response") == 0) {
-			myidx++;
-			flags = STK_IS_STORE | STK_ON_RSP;
-		}
-		else if (strcmp(args[myidx], "match") == 0) {
-			myidx++;
-			flags = STK_IS_MATCH;
-		}
-		else if (strcmp(args[myidx], "on") == 0) {
-			myidx++;
-			flags = STK_IS_MATCH | STK_IS_STORE;
-		}
-		else {
-			Alert("parsing [%s:%d] : '%s' expects 'on', 'match', or 'store'.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		if (*(args[myidx]) == 0) {
-			Alert("parsing [%s:%d] : '%s' expects a fetch method.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		expr = pattern_parse_expr(args, &myidx);
-		if (!expr) {
-			Alert("parsing [%s:%d] : '%s': unknown fetch method '%s'.\n", file, linenum, args[0], args[myidx]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		if (flags & STK_ON_RSP) {
-			if (!(expr->fetch->dir & PATTERN_FETCH_RTR)) {
-				Alert("parsing [%s:%d] : '%s': fetch method '%s' can not be used on response.\n",
-				      file, linenum, args[0], expr->fetch->kw);
-		                err_code |= ERR_ALERT | ERR_FATAL;
-			        goto out;
-			}
-		} else {
-			if (!(expr->fetch->dir & PATTERN_FETCH_REQ)) {
-				Alert("parsing [%s:%d] : '%s': fetch method '%s' can not be used on request.\n",
-				      file, linenum, args[0], expr->fetch->kw);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			}
-		}
-
-		if (strcmp(args[myidx], "table") == 0) {
-			myidx++;
-			name = args[myidx++];
-		}
-
-		if (strcmp(args[myidx], "if") == 0 || strcmp(args[myidx], "unless") == 0) {
-			if ((cond = build_acl_cond(file, linenum, curproxy, (const char **)args + myidx)) == NULL) {
-				Alert("parsing [%s:%d] : '%s': error detected while parsing sticking condition.\n",
-				      file, linenum, args[0]);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			}
-		}
-		else if (*(args[myidx])) {
-			Alert("parsing [%s:%d] : '%s': unknown keyword '%s'.\n",
-			      file, linenum, args[0], args[myidx]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		err_code |= warnif_cond_requires_resp(cond, file, linenum);
-
-		rule = (struct sticking_rule *)calloc(1, sizeof(*rule));
-		rule->cond = cond;
-		rule->expr = expr;
-		rule->flags = flags;
-		rule->table.name = name ? strdup(name) : NULL;
-		LIST_INIT(&rule->list);
-		if (flags & STK_ON_RSP)
-			LIST_ADDQ(&curproxy->storersp_rules, &rule->list);
-		else
-			LIST_ADDQ(&curproxy->sticking_rules, &rule->list);
-	}
-	else if (!strcmp(args[0], "stats")) {
-		if (warnifnotcap(curproxy, PR_CAP_BE, file, linenum, args[0], NULL))
-			err_code |= ERR_WARN;
-
-		if (curproxy != &defproxy && curproxy->uri_auth == defproxy.uri_auth)
-			curproxy->uri_auth = NULL; /* we must detach from the default config */
-
-		if (!*args[1]) {
-			goto stats_error_parsing;
-		} else if (!strcmp(args[1], "admin")) {
-			struct stats_admin_rule *rule;
-
-			if (curproxy == &defproxy) {
-				Alert("parsing [%s:%d]: '%s %s' not allowed in 'defaults' section.\n", file, linenum, args[0], args[1]);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			}
-
-			if (!stats_check_init_uri_auth(&curproxy->uri_auth)) {
-				Alert("parsing [%s:%d]: out of memory.\n", file, linenum);
-				err_code |= ERR_ALERT | ERR_ABORT;
-				goto out;
-			}
-
-			if (strcmp(args[2], "if") != 0 && strcmp(args[2], "unless") != 0) {
-				Alert("parsing [%s:%d] : '%s %s' requires either 'if' or 'unless' followed by a condition.\n",
-				file, linenum, args[0], args[1]);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			}
-			if ((cond = build_acl_cond(file, linenum, curproxy, (const char **)args + 2)) == NULL) {
-				Alert("parsing [%s:%d] : error detected while parsing a '%s %s' rule.\n",
-				file, linenum, args[0], args[1]);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			}
-
-			err_code |= warnif_cond_requires_resp(cond, file, linenum);
-
-			rule = (struct stats_admin_rule *)calloc(1, sizeof(*rule));
-			rule->cond = cond;
-			LIST_INIT(&rule->list);
-			LIST_ADDQ(&curproxy->uri_auth->admin_rules, &rule->list);
-		} else if (!strcmp(args[1], "uri")) {
-			if (*(args[2]) == 0) {
-				Alert("parsing [%s:%d] : 'uri' needs an URI prefix.\n", file, linenum);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			} else if (!stats_set_uri(&curproxy->uri_auth, args[2])) {
-				Alert("parsing [%s:%d] : out of memory.\n", file, linenum);
-				err_code |= ERR_ALERT | ERR_ABORT;
-				goto out;
-			}
-		} else if (!strcmp(args[1], "realm")) {
-			if (*(args[2]) == 0) {
-				Alert("parsing [%s:%d] : 'realm' needs an realm name.\n", file, linenum);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			} else if (!stats_set_realm(&curproxy->uri_auth, args[2])) {
-				Alert("parsing [%s:%d] : out of memory.\n", file, linenum);
-				err_code |= ERR_ALERT | ERR_ABORT;
-				goto out;
-			}
-		} else if (!strcmp(args[1], "refresh")) {
-			unsigned interval;
-
-			err = parse_time_err(args[2], &interval, TIME_UNIT_S);
-			if (err) {
-				Alert("parsing [%s:%d] : unexpected character '%c' in stats refresh interval.\n",
-				      file, linenum, *err);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			} else if (!stats_set_refresh(&curproxy->uri_auth, interval)) {
-				Alert("parsing [%s:%d] : out of memory.\n", file, linenum);
-				err_code |= ERR_ALERT | ERR_ABORT;
-				goto out;
-			}
-		} else if (!strcmp(args[1], "http-request")) {    /* request access control: allow/deny/auth */
-			struct req_acl_rule *req_acl;
-
-			if (curproxy == &defproxy) {
-				Alert("parsing [%s:%d]: '%s' not allowed in 'defaults' section.\n", file, linenum, args[0]);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			}
-
-			if (!stats_check_init_uri_auth(&curproxy->uri_auth)) {
-				Alert("parsing [%s:%d]: out of memory.\n", file, linenum);
-				err_code |= ERR_ALERT | ERR_ABORT;
-				goto out;
-			}
-
-			if (!LIST_ISEMPTY(&curproxy->uri_auth->req_acl) &&
-			    !LIST_PREV(&curproxy->uri_auth->req_acl, struct req_acl_rule *, list)->cond) {
-				Warning("parsing [%s:%d]: previous '%s' action has no condition attached, further entries are NOOP.\n",
-					file, linenum, args[0]);
-				err_code |= ERR_WARN;
-			}
-
-			req_acl = parse_auth_cond((const char **)args + 2, file, linenum, curproxy);
-
-			if (!req_acl) {
-				err_code |= ERR_ALERT | ERR_ABORT;
-				goto out;
-			}
-
-			err_code |= warnif_cond_requires_resp(req_acl->cond, file, linenum);
-			LIST_ADDQ(&curproxy->uri_auth->req_acl, &req_acl->list);
-
-		} else if (!strcmp(args[1], "auth")) {
-			if (*(args[2]) == 0) {
-				Alert("parsing [%s:%d] : 'auth' needs a user:password account.\n", file, linenum);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			} else if (!stats_add_auth(&curproxy->uri_auth, args[2])) {
-				Alert("parsing [%s:%d] : out of memory.\n", file, linenum);
-				err_code |= ERR_ALERT | ERR_ABORT;
-				goto out;
-			}
-		} else if (!strcmp(args[1], "scope")) {
-			if (*(args[2]) == 0) {
-				Alert("parsing [%s:%d] : 'scope' needs a proxy name.\n", file, linenum);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			} else if (!stats_add_scope(&curproxy->uri_auth, args[2])) {
-				Alert("parsing [%s:%d] : out of memory.\n", file, linenum);
-				err_code |= ERR_ALERT | ERR_ABORT;
-				goto out;
-			}
-		} else if (!strcmp(args[1], "enable")) {
-			if (!stats_check_init_uri_auth(&curproxy->uri_auth)) {
-				Alert("parsing [%s:%d] : out of memory.\n", file, linenum);
-				err_code |= ERR_ALERT | ERR_ABORT;
-				goto out;
-			}
-		} else if (!strcmp(args[1], "hide-version")) {
-			if (!stats_set_flag(&curproxy->uri_auth, ST_HIDEVER)) {
-				Alert("parsing [%s:%d] : out of memory.\n", file, linenum);
-				err_code |= ERR_ALERT | ERR_ABORT;
-				goto out;
-			}
-		} else if (!strcmp(args[1], "show-legends")) {
-			if (!stats_set_flag(&curproxy->uri_auth, ST_SHLGNDS)) {
-				Alert("parsing [%s:%d]: out of memory.\n", file, linenum);
-				err_code |= ERR_ALERT | ERR_ABORT;
-				goto out;
-			}
-		} else if (!strcmp(args[1], "show-node")) {
-
-			if (*args[2]) {
-				int i;
-				char c;
-
-				for (i=0; args[2][i]; i++) {
-					c = args[2][i];
-					if (!isupper((unsigned char)c) && !islower((unsigned char)c) &&
-					    !isdigit((unsigned char)c) && c != '_' && c != '-' && c != '.')
-						break;
-				}
-
-				if (!i || args[2][i]) {
-					Alert("parsing [%s:%d]: '%s %s' invalid node name - should be a string"
-						"with digits(0-9), letters(A-Z, a-z), hyphen(-) or underscode(_).\n",
-						file, linenum, args[0], args[1]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-			}
-
-			if (!stats_set_node(&curproxy->uri_auth, args[2])) {
-				Alert("parsing [%s:%d]: out of memory.\n", file, linenum);
-				err_code |= ERR_ALERT | ERR_ABORT;
-				goto out;
-			}
-		} else if (!strcmp(args[1], "show-desc")) {
-			char *desc = NULL;
-
-			if (*args[2]) {
-				int i, len=0;
-				char *d;
-
-				for(i=2; *args[i]; i++)
-					len += strlen(args[i])+1;
-
-				desc = d = (char *)calloc(1, len);
-
-				d += sprintf(d, "%s", args[2]);
-				for(i=3; *args[i]; i++)
-					d += sprintf(d, " %s", args[i]);
-			}
-
-			if (!*args[2] && !global.desc)
-				Warning("parsing [%s:%d]: '%s' requires a parameter or 'desc' to be set in the global section.\n",
-					file, linenum, args[1]);
-			else {
-				if (!stats_set_desc(&curproxy->uri_auth, desc)) {
-					free(desc);
-					Alert("parsing [%s:%d]: out of memory.\n", file, linenum);
-					err_code |= ERR_ALERT | ERR_ABORT;
-					goto out;
-				}
-				free(desc);
-			}
-		} else {
-stats_error_parsing:
-			Alert("parsing [%s:%d]: %s '%s', expects 'admin', 'uri', 'realm', 'auth', 'scope', 'enable', 'hide-version', 'show-node', 'show-desc' or 'show-legends'.\n",
-			      file, linenum, *args[1]?"unknown stats parameter":"missing keyword in", args[*args[1]?1:0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-	}
-	else if (!strcmp(args[0], "option")) {
-		int optnum;
-
-		if (*(args[1]) == '\0') {
-			Alert("parsing [%s:%d]: '%s' expects an option name.\n",
-			      file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		for (optnum = 0; cfg_opts[optnum].name; optnum++) {
-			if (!strcmp(args[1], cfg_opts[optnum].name)) {
-				if (warnifnotcap(curproxy, cfg_opts[optnum].cap, file, linenum, args[1], NULL)) {
-					err_code |= ERR_WARN;
-					goto out;
-				}
-
-				curproxy->no_options &= ~cfg_opts[optnum].val;
-				curproxy->options    &= ~cfg_opts[optnum].val;
-
-				switch (kwm) {
-				case KWM_STD:
-					curproxy->options |= cfg_opts[optnum].val;
-					break;
-				case KWM_NO:
-					curproxy->no_options |= cfg_opts[optnum].val;
-					break;
-				case KWM_DEF: /* already cleared */
-					break;
-				}
-
-				goto out;
-			}
-		}
-
-		for (optnum = 0; cfg_opts2[optnum].name; optnum++) {
-			if (!strcmp(args[1], cfg_opts2[optnum].name)) {
-				if (warnifnotcap(curproxy, cfg_opts2[optnum].cap, file, linenum, args[1], NULL)) {
-					err_code |= ERR_WARN;
-					goto out;
-				}
-
-				curproxy->no_options2 &= ~cfg_opts2[optnum].val;
-				curproxy->options2    &= ~cfg_opts2[optnum].val;
-
-				switch (kwm) {
-				case KWM_STD:
-					curproxy->options2 |= cfg_opts2[optnum].val;
-					break;
-				case KWM_NO:
-					curproxy->no_options2 |= cfg_opts2[optnum].val;
-					break;
-				case KWM_DEF: /* already cleared */
-					break;
-				}
-				goto out;
-			}
-		}
-
-		if (kwm != KWM_STD) {
-			Alert("parsing [%s:%d]: negation/default is not supported for option '%s'.\n",
-				file, linenum, args[1]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		if (!strcmp(args[1], "httplog")) {
-			/* generate a complete HTTP log */
-			curproxy->options2 &= ~PR_O2_CLFLOG;
-			curproxy->to_log |= LW_DATE | LW_CLIP | LW_SVID | LW_REQ | LW_PXID | LW_RESP | LW_BYTES;
-			if (*(args[2]) != '\0') {
-				if (!strcmp(args[2], "clf")) {
-					curproxy->options2 |= PR_O2_CLFLOG;
-				} else {
-					Alert("parsing [%s:%d] : keyword '%s' only supports option 'clf'.\n", file, linenum, args[2]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-			}
-		}
-		else if (!strcmp(args[1], "tcplog"))
-			/* generate a detailed TCP log */
-			curproxy->to_log |= LW_DATE | LW_CLIP | LW_SVID | LW_PXID | LW_BYTES;
-		else if (!strcmp(args[1], "tcpka")) {
-			/* enable TCP keep-alives on client and server sessions */
-			if (warnifnotcap(curproxy, PR_CAP_BE | PR_CAP_FE, file, linenum, args[1], NULL))
-				err_code |= ERR_WARN;
-
-			if (curproxy->cap & PR_CAP_FE)
-				curproxy->options |= PR_O_TCP_CLI_KA;
-			if (curproxy->cap & PR_CAP_BE)
-				curproxy->options |= PR_O_TCP_SRV_KA;
-		}
-		else if (!strcmp(args[1], "httpchk")) {
-			if (warnifnotcap(curproxy, PR_CAP_BE, file, linenum, args[1], NULL))
-				err_code |= ERR_WARN;
-
-			/* use HTTP request to check servers' health */
-			free(curproxy->check_req);
-			curproxy->check_req = NULL;
-			curproxy->options &= ~PR_O_SMTP_CHK;
-			curproxy->options2 &= ~PR_O2_SSL3_CHK;
-			curproxy->options2 &= ~PR_O2_MYSQL_CHK;
-			curproxy->options2 &= ~PR_O2_LDAP_CHK;
-			curproxy->options |= PR_O_HTTP_CHK;
-			if (!*args[2]) { /* no argument */
-				curproxy->check_req = strdup(DEF_CHECK_REQ); /* default request */
-				curproxy->check_len = strlen(DEF_CHECK_REQ);
-			} else if (!*args[3]) { /* one argument : URI */
-				int reqlen = strlen(args[2]) + strlen("OPTIONS  HTTP/1.0\r\n") + 1;
-				curproxy->check_req = (char *)malloc(reqlen);
-				curproxy->check_len = snprintf(curproxy->check_req, reqlen,
-							       "OPTIONS %s HTTP/1.0\r\n", args[2]); /* URI to use */
-			} else { /* more arguments : METHOD URI [HTTP_VER] */
-				int reqlen = strlen(args[2]) + strlen(args[3]) + 3 + strlen("\r\n");
-				if (*args[4])
-					reqlen += strlen(args[4]);
-				else
-					reqlen += strlen("HTTP/1.0");
-		    
-				curproxy->check_req = (char *)malloc(reqlen);
-				curproxy->check_len = snprintf(curproxy->check_req, reqlen,
-							       "%s %s %s\r\n", args[2], args[3], *args[4]?args[4]:"HTTP/1.0");
-			}
-		}
-		else if (!strcmp(args[1], "ssl-hello-chk")) {
-			/* use SSLv3 CLIENT HELLO to check servers' health */
-			if (warnifnotcap(curproxy, PR_CAP_BE, file, linenum, args[1], NULL))
-				err_code |= ERR_WARN;
-
-			free(curproxy->check_req);
-			curproxy->check_req = NULL;
-			curproxy->options &= ~PR_O_HTTP_CHK;
-			curproxy->options &= ~PR_O_SMTP_CHK;
-			curproxy->options2 &= ~PR_O2_MYSQL_CHK;
-			curproxy->options2 &= ~PR_O2_LDAP_CHK;
-			curproxy->options2 |= PR_O2_SSL3_CHK;
-		}
-		else if (!strcmp(args[1], "smtpchk")) {
-			/* use SMTP request to check servers' health */
-			free(curproxy->check_req);
-			curproxy->check_req = NULL;
-			curproxy->options &= ~PR_O_HTTP_CHK;
-			curproxy->options2 &= ~PR_O2_SSL3_CHK;
-			curproxy->options2 &= ~PR_O2_MYSQL_CHK;
-			curproxy->options2 &= ~PR_O2_LDAP_CHK;
-			curproxy->options |= PR_O_SMTP_CHK;
-
-			if (!*args[2] || !*args[3]) { /* no argument or incomplete EHLO host */
-				curproxy->check_req = strdup(DEF_SMTP_CHECK_REQ); /* default request */
-				curproxy->check_len = strlen(DEF_SMTP_CHECK_REQ);
-			} else { /* ESMTP EHLO, or SMTP HELO, and a hostname */
-				if (!strcmp(args[2], "EHLO") || !strcmp(args[2], "HELO")) {
-					int reqlen = strlen(args[2]) + strlen(args[3]) + strlen(" \r\n") + 1;
-					curproxy->check_req = (char *)malloc(reqlen);
-					curproxy->check_len = snprintf(curproxy->check_req, reqlen,
-								       "%s %s\r\n", args[2], args[3]); /* HELO hostname */
-				} else {
-					/* this just hits the default for now, but you could potentially expand it to allow for other stuff
-					   though, it's unlikely you'd want to send anything other than an EHLO or HELO */
-					curproxy->check_req = strdup(DEF_SMTP_CHECK_REQ); /* default request */
-					curproxy->check_len = strlen(DEF_SMTP_CHECK_REQ);
-				}
-			}
-		}
-		else if (!strcmp(args[1], "mysql-check")) {
-			/* use MYSQL request to check servers' health */
-			if (warnifnotcap(curproxy, PR_CAP_BE, file, linenum, args[1], NULL))
-				err_code |= ERR_WARN;
-
-			free(curproxy->check_req);
-			curproxy->check_req = NULL;
-			curproxy->options &= ~PR_O_HTTP_CHK;
-			curproxy->options &= ~PR_O_SMTP_CHK;
-			curproxy->options2 &= ~PR_O2_SSL3_CHK;
-			curproxy->options2 &= ~PR_O2_LDAP_CHK;
-			curproxy->options2 |= PR_O2_MYSQL_CHK;
-
-			/* This is an exemple of an MySQL >=4.0 client Authentication packet kindly provided by Cyril Bonte.
-			 * const char mysql40_client_auth_pkt[] = {
-			 * 	"\x0e\x00\x00"	// packet length
-			 * 	"\x01"		// packet number
-			 * 	"\x00\x00"	// client capabilities
-			 * 	"\x00\x00\x01"	// max packet
-			 * 	"haproxy\x00"	// username (null terminated string)
-			 * 	"\x00"		// filler (always 0x00)
-			 * 	"\x01\x00\x00"	// packet length
-			 * 	"\x00"		// packet number
-			 * 	"\x01"		// COM_QUIT command
-			 * };
-			 */
-
-			if (*(args[2])) {
-				int cur_arg = 2;
-
-				while (*(args[cur_arg])) {
-					if (strcmp(args[cur_arg], "user") == 0) {
-						char *mysqluser;
-						int packetlen, reqlen, userlen;
-
-						/* suboption header - needs additional argument for it */
-						if (*(args[cur_arg+1]) == 0) {
-							Alert("parsing [%s:%d] : '%s %s %s' expects <username> as argument.\n",
-							      file, linenum, args[0], args[1], args[cur_arg]);
-							err_code |= ERR_ALERT | ERR_FATAL;
-							goto out;
-						}
-						mysqluser = args[cur_arg + 1];
-						userlen   = strlen(mysqluser);
-						packetlen = userlen + 7;
-						reqlen    = packetlen + 9;
-
-						free(curproxy->check_req);
-						curproxy->check_req = (char *)calloc(1, reqlen);
-						curproxy->check_len = reqlen;
-
-						snprintf(curproxy->check_req, 4, "%c%c%c",
-							((unsigned char) packetlen & 0xff),
-							((unsigned char) (packetlen >> 8) & 0xff),
-							((unsigned char) (packetlen >> 16) & 0xff));
-
-						curproxy->check_req[3] = 1;
-						curproxy->check_req[5] = 128;
-						curproxy->check_req[8] = 1;
-						memcpy(&curproxy->check_req[9], mysqluser, userlen);
-						curproxy->check_req[9 + userlen + 1 + 1]     = 1;
-						curproxy->check_req[9 + userlen + 1 + 1 + 4] = 1;
-						cur_arg += 2;
-					} else {
-						/* unknown suboption - catchall */
-						Alert("parsing [%s:%d] : '%s %s' only supports optional values: 'user'.\n",
-						      file, linenum, args[0], args[1]);
-						err_code |= ERR_ALERT | ERR_FATAL;
-						goto out;
-					}
-				} /* end while loop */
-			}
-		}
-		else if (!strcmp(args[1], "ldap-check")) {
-			/* use LDAP request to check servers' health */
-			free(curproxy->check_req);
-			curproxy->check_req = NULL;
-			curproxy->options &= ~PR_O_HTTP_CHK;
-			curproxy->options &= ~PR_O_SMTP_CHK;
-			curproxy->options2 &= ~PR_O2_SSL3_CHK;
-			curproxy->options2 &= ~PR_O2_MYSQL_CHK;
-			curproxy->options2 |= PR_O2_LDAP_CHK;
-
-			curproxy->check_req = (char *) malloc(sizeof(DEF_LDAP_CHECK_REQ) - 1);
-			memcpy(curproxy->check_req, DEF_LDAP_CHECK_REQ, sizeof(DEF_LDAP_CHECK_REQ) - 1);
-			curproxy->check_len = sizeof(DEF_LDAP_CHECK_REQ) - 1;
-		}
-		else if (!strcmp(args[1], "forwardfor")) {
-			int cur_arg;
-
-			/* insert x-forwarded-for field, but not for the IP address listed as an except.
-			 * set default options (ie: bitfield, header name, etc) 
-			 */
-
-			curproxy->options |= PR_O_FWDFOR;
-			curproxy->options2 |= PR_O2_FF_ALWAYS;
-
-			free(curproxy->fwdfor_hdr_name);
-			curproxy->fwdfor_hdr_name = strdup(DEF_XFORWARDFOR_HDR);
-			curproxy->fwdfor_hdr_len  = strlen(DEF_XFORWARDFOR_HDR);
-
-			/* loop to go through arguments - start at 2, since 0+1 = "option" "forwardfor" */
-			cur_arg = 2;
-			while (*(args[cur_arg])) {
-				if (!strcmp(args[cur_arg], "except")) {
-					/* suboption except - needs additional argument for it */
-					if (!*(args[cur_arg+1]) || !str2net(args[cur_arg+1], &curproxy->except_net, &curproxy->except_mask)) {
-						Alert("parsing [%s:%d] : '%s %s %s' expects <address>[/mask] as argument.\n",
-						      file, linenum, args[0], args[1], args[cur_arg]);
-						err_code |= ERR_ALERT | ERR_FATAL;
-						goto out;
-					}
-					/* flush useless bits */
-					curproxy->except_net.s_addr &= curproxy->except_mask.s_addr;
-					cur_arg += 2;
-				} else if (!strcmp(args[cur_arg], "header")) {
-					/* suboption header - needs additional argument for it */
-					if (*(args[cur_arg+1]) == 0) {
-						Alert("parsing [%s:%d] : '%s %s %s' expects <header_name> as argument.\n",
-						      file, linenum, args[0], args[1], args[cur_arg]);
-						err_code |= ERR_ALERT | ERR_FATAL;
-						goto out;
-					}
-					free(curproxy->fwdfor_hdr_name);
-					curproxy->fwdfor_hdr_name = strdup(args[cur_arg+1]);
-					curproxy->fwdfor_hdr_len  = strlen(curproxy->fwdfor_hdr_name);
-					cur_arg += 2;
-				} else if (!strcmp(args[cur_arg], "if-none")) {
-					curproxy->options2 &= ~PR_O2_FF_ALWAYS;
-					cur_arg += 1;
-				} else {
-					/* unknown suboption - catchall */
-					Alert("parsing [%s:%d] : '%s %s' only supports optional values: 'except', 'header' and 'if-none'.\n",
-					      file, linenum, args[0], args[1]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-			} /* end while loop */
-		}
-		else if (!strcmp(args[1], "originalto")) {
-			int cur_arg;
-
-			/* insert x-original-to field, but not for the IP address listed as an except.
-			 * set default options (ie: bitfield, header name, etc)
-			 */
-
-			curproxy->options |= PR_O_ORGTO;
-
-			free(curproxy->orgto_hdr_name);
-			curproxy->orgto_hdr_name = strdup(DEF_XORIGINALTO_HDR);
-			curproxy->orgto_hdr_len  = strlen(DEF_XORIGINALTO_HDR);
-
-			/* loop to go through arguments - start at 2, since 0+1 = "option" "originalto" */
-			cur_arg = 2;
-			while (*(args[cur_arg])) {
-				if (!strcmp(args[cur_arg], "except")) {
-					/* suboption except - needs additional argument for it */
-					if (!*(args[cur_arg+1]) || !str2net(args[cur_arg+1], &curproxy->except_to, &curproxy->except_mask_to)) {
-						Alert("parsing [%s:%d] : '%s %s %s' expects <address>[/mask] as argument.\n",
-						      file, linenum, args[0], args[1], args[cur_arg]);
-						err_code |= ERR_ALERT | ERR_FATAL;
-						goto out;
-					}
-					/* flush useless bits */
-					curproxy->except_to.s_addr &= curproxy->except_mask_to.s_addr;
-					cur_arg += 2;
-				} else if (!strcmp(args[cur_arg], "header")) {
-					/* suboption header - needs additional argument for it */
-					if (*(args[cur_arg+1]) == 0) {
-						Alert("parsing [%s:%d] : '%s %s %s' expects <header_name> as argument.\n",
-						      file, linenum, args[0], args[1], args[cur_arg]);
-						err_code |= ERR_ALERT | ERR_FATAL;
-						goto out;
-					}
-					free(curproxy->orgto_hdr_name);
-					curproxy->orgto_hdr_name = strdup(args[cur_arg+1]);
-					curproxy->orgto_hdr_len  = strlen(curproxy->orgto_hdr_name);
-					cur_arg += 2;
-				} else {
-					/* unknown suboption - catchall */
-					Alert("parsing [%s:%d] : '%s %s' only supports optional values: 'except' and 'header'.\n",
-					      file, linenum, args[0], args[1]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-			} /* end while loop */
-		}
-		else {
-			Alert("parsing [%s:%d] : unknown option '%s'.\n", file, linenum, args[1]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		goto out;
-	}
-	else if (!strcmp(args[0], "default_backend")) {
-		if (warnifnotcap(curproxy, PR_CAP_FE, file, linenum, args[0], NULL))
-			err_code |= ERR_WARN;
-
-		if (*(args[1]) == 0) {
-			Alert("parsing [%s:%d] : '%s' expects a backend name.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		free(curproxy->defbe.name);
-		curproxy->defbe.name = strdup(args[1]);
-	}
-	else if (!strcmp(args[0], "redispatch") || !strcmp(args[0], "redisp")) {
-		if (warnifnotcap(curproxy, PR_CAP_BE, file, linenum, args[0], NULL))
-			err_code |= ERR_WARN;
-
-		Warning("parsing [%s:%d]: keyword '%s' is deprecated, please use 'option redispatch' instead.\n",
-				file, linenum, args[0]);
-		err_code |= ERR_WARN;
-		/* enable reconnections to dispatch */
-		curproxy->options |= PR_O_REDISP;
-	}
-	else if (!strcmp(args[0], "http-check")) {
-		if (warnifnotcap(curproxy, PR_CAP_BE, file, linenum, args[0], NULL))
-			err_code |= ERR_WARN;
-
-		if (strcmp(args[1], "disable-on-404") == 0) {
-			/* enable a graceful server shutdown on an HTTP 404 response */
-			curproxy->options |= PR_O_DISABLE404;
-		}
-		else if (strcmp(args[1], "send-state") == 0) {
-			/* enable emission of the apparent state of a server in HTTP checks */
-			curproxy->options2 |= PR_O2_CHK_SNDST;
-		}
-		else if (strcmp(args[1], "expect") == 0) {
-			const char *ptr_arg;
-			int cur_arg;
-
-			if (curproxy->options2 & PR_O2_EXP_TYPE) {
-				Alert("parsing [%s:%d] : '%s %s' already specified.\n", file, linenum, args[0], args[1]);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			}
-
-			cur_arg = 2;
-			/* consider exclamation marks, sole or at the beginning of a word */
-			while (*(ptr_arg = args[cur_arg])) {
-				while (*ptr_arg == '!') {
-					curproxy->options2 ^= PR_O2_EXP_INV;
-					ptr_arg++;
-				}
-				if (*ptr_arg)
-					break;
-				cur_arg++;
-			}
-			/* now ptr_arg points to the beginning of a word past any possible
-			 * exclamation mark, and cur_arg is the argument which holds this word.
-			 */
-			if (strcmp(ptr_arg, "status") == 0) {
-				if (!*(args[cur_arg + 1])) {
-					Alert("parsing [%s:%d] : '%s %s %s' expects <string> as an argument.\n",
-					      file, linenum, args[0], args[1], ptr_arg);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-				curproxy->options2 |= PR_O2_EXP_STS;
-				free(curproxy->expect_str);
-				curproxy->expect_str = strdup(args[cur_arg + 1]);
-			}
-			else if (strcmp(ptr_arg, "string") == 0) {
-				if (!*(args[cur_arg + 1])) {
-					Alert("parsing [%s:%d] : '%s %s %s' expects <string> as an argument.\n",
-					      file, linenum, args[0], args[1], ptr_arg);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-				curproxy->options2 |= PR_O2_EXP_STR;
-				free(curproxy->expect_str);
-				curproxy->expect_str = strdup(args[cur_arg + 1]);
-			}
-			else if (strcmp(ptr_arg, "rstatus") == 0) {
-				if (!*(args[cur_arg + 1])) {
-					Alert("parsing [%s:%d] : '%s %s %s' expects <regex> as an argument.\n",
-					      file, linenum, args[0], args[1], ptr_arg);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-				curproxy->options2 |= PR_O2_EXP_RSTS;
-				free(curproxy->expect_str);
-				if (curproxy->expect_regex) regfree(curproxy->expect_regex);
-				curproxy->expect_str = strdup(args[cur_arg + 1]);
-				curproxy->expect_regex = calloc(1, sizeof(regex_t));
-				if (regcomp(curproxy->expect_regex, args[cur_arg + 1], REG_EXTENDED) != 0) {
-					Alert("parsing [%s:%d] : '%s %s %s' : bad regular expression '%s'.\n",
-					      file, linenum, args[0], args[1], ptr_arg, args[cur_arg + 1]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-			}
-			else if (strcmp(ptr_arg, "rstring") == 0) {
-				if (!*(args[cur_arg + 1])) {
-					Alert("parsing [%s:%d] : '%s %s %s' expects <regex> as an argument.\n",
-					      file, linenum, args[0], args[1], ptr_arg);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-				curproxy->options2 |= PR_O2_EXP_RSTR;
-				free(curproxy->expect_str);
-				if (curproxy->expect_regex) regfree(curproxy->expect_regex);
-				curproxy->expect_str = strdup(args[cur_arg + 1]);
-				curproxy->expect_regex = calloc(1, sizeof(regex_t));
-				if (regcomp(curproxy->expect_regex, args[cur_arg + 1], REG_EXTENDED) != 0) {
-					Alert("parsing [%s:%d] : '%s %s %s' : bad regular expression '%s'.\n",
-					      file, linenum, args[0], args[1], ptr_arg, args[cur_arg + 1]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-			}
-			else {
-				Alert("parsing [%s:%d] : '%s %s' only supports [!] 'status', 'string', 'rstatus', 'rstring', found '%s'.\n",
-				      file, linenum, args[0], args[1], ptr_arg);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			}
-		}
-		else {
-			Alert("parsing [%s:%d] : '%s' only supports 'disable-on-404', 'send-state', 'expect'.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-	}
-	else if (!strcmp(args[0], "monitor")) {
-		if (curproxy == &defproxy) {
-			Alert("parsing [%s:%d] : '%s' not allowed in 'defaults' section.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		if (warnifnotcap(curproxy, PR_CAP_FE, file, linenum, args[0], NULL))
-			err_code |= ERR_WARN;
-
-		if (strcmp(args[1], "fail") == 0) {
-			/* add a condition to fail monitor requests */
-			if (strcmp(args[2], "if") != 0 && strcmp(args[2], "unless") != 0) {
-				Alert("parsing [%s:%d] : '%s %s' requires either 'if' or 'unless' followed by a condition.\n",
-				      file, linenum, args[0], args[1]);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			}
-
-			if ((cond = build_acl_cond(file, linenum, curproxy, (const char **)args + 2)) == NULL) {
-				Alert("parsing [%s:%d] : error detected while parsing a '%s %s' condition.\n",
-				      file, linenum, args[0], args[1]);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			}
-			LIST_ADDQ(&curproxy->mon_fail_cond, &cond->list);
-		}
-		else {
-			Alert("parsing [%s:%d] : '%s' only supports 'fail'.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-	}
-#ifdef TPROXY
-	else if (!strcmp(args[0], "transparent")) {
-		/* enable transparent proxy connections */
-		curproxy->options |= PR_O_TRANSP;
-	}
-#endif
-	else if (!strcmp(args[0], "maxconn")) {  /* maxconn */
-		if (warnifnotcap(curproxy, PR_CAP_FE, file, linenum, args[0], " Maybe you want 'fullconn' instead ?"))
-			err_code |= ERR_WARN;
-
-		if (*(args[1]) == 0) {
-			Alert("parsing [%s:%d] : '%s' expects an integer argument.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		curproxy->maxconn = atol(args[1]);
-	}
-	else if (!strcmp(args[0], "backlog")) {  /* backlog */
-		if (warnifnotcap(curproxy, PR_CAP_FE, file, linenum, args[0], NULL))
-			err_code |= ERR_WARN;
-
-		if (*(args[1]) == 0) {
-			Alert("parsing [%s:%d] : '%s' expects an integer argument.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		curproxy->backlog = atol(args[1]);
-	}
-	else if (!strcmp(args[0], "fullconn")) {  /* fullconn */
-		if (warnifnotcap(curproxy, PR_CAP_BE, file, linenum, args[0], " Maybe you want 'maxconn' instead ?"))
-			err_code |= ERR_WARN;
-
-		if (*(args[1]) == 0) {
-			Alert("parsing [%s:%d] : '%s' expects an integer argument.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		curproxy->fullconn = atol(args[1]);
-	}
-	else if (!strcmp(args[0], "grace")) {  /* grace time (ms) */
-		if (*(args[1]) == 0) {
-			Alert("parsing [%s:%d] : '%s' expects a time in milliseconds.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		err = parse_time_err(args[1], &val, TIME_UNIT_MS);
-		if (err) {
-			Alert("parsing [%s:%d] : unexpected character '%c' in grace time.\n",
-			      file, linenum, *err);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		curproxy->grace = val;
-	}
-	else if (!strcmp(args[0], "dispatch")) {  /* dispatch address */
-		struct sockaddr_in *sk;
-		if (curproxy == &defproxy) {
-			Alert("parsing [%s:%d] : '%s' not allowed in 'defaults' section.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		else if (warnifnotcap(curproxy, PR_CAP_BE, file, linenum, args[0], NULL))
-			err_code |= ERR_WARN;
-
-		if (strchr(args[1], ':') == NULL) {
-			Alert("parsing [%s:%d] : '%s' expects <addr:port> as argument.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		sk = str2sa(args[1]);
-		if (!sk) {
-			Alert("parsing [%s:%d] : Unknown host in '%s'\n", file, linenum, args[1]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		curproxy->dispatch_addr = *sk;
-	}
-	else if (!strcmp(args[0], "balance")) {  /* set balancing with optional algorithm */
-		if (warnifnotcap(curproxy, PR_CAP_BE, file, linenum, args[0], NULL))
-			err_code |= ERR_WARN;
-
-		memcpy(trash, "error near 'balance'", 21);
-		if (backend_parse_balance((const char **)args + 1, trash, trashlen, curproxy) < 0) {
-			Alert("parsing [%s:%d] : %s\n", file, linenum, trash);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-	}
-	else if (!strcmp(args[0], "hash-type")) { /* set hashing method */
-		if (warnifnotcap(curproxy, PR_CAP_BE, file, linenum, args[0], NULL))
-			err_code |= ERR_WARN;
-
-		if (strcmp(args[1], "consistent") == 0) {	/* use consistent hashing */
-			curproxy->lbprm.algo &= ~BE_LB_HASH_TYPE;
-			curproxy->lbprm.algo |= BE_LB_HASH_CONS;
-		}
-		else if (strcmp(args[1], "map-based") == 0) {	/* use map-based hashing */
-			curproxy->lbprm.algo &= ~BE_LB_HASH_TYPE;
-			curproxy->lbprm.algo |= BE_LB_HASH_MAP;
-		}
-		else {
-			Alert("parsing [%s:%d] : '%s' only supports 'consistent' and 'map-based'.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-	}
-	else if (!strcmp(args[0], "server") || !strcmp(args[0], "default-server")) {  /* server address */
-		int cur_arg;
-		char *rport, *raddr;
-		short realport = 0;
-		int do_check = 0, defsrv = (*args[0] == 'd');
-
-		if (!defsrv && curproxy == &defproxy) {
-			Alert("parsing [%s:%d] : '%s' not allowed in 'defaults' section.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		else if (warnifnotcap(curproxy, PR_CAP_BE, file, linenum, args[0], NULL))
-			err_code |= ERR_ALERT | ERR_FATAL;
-
-		if (!*args[2]) {
-			Alert("parsing [%s:%d] : '%s' expects <name> and <addr>[:<port>] as arguments.\n",
-			      file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		err = invalid_char(args[1]);
-		if (err) {
-			Alert("parsing [%s:%d] : character '%c' is not permitted in server name '%s'.\n",
-			      file, linenum, *err, args[1]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		if (!defsrv) {
-			struct sockaddr_in *sk;
-
-			if ((newsrv = (struct server *)calloc(1, sizeof(struct server))) == NULL) {
-				Alert("parsing [%s:%d] : out of memory.\n", file, linenum);
-				err_code |= ERR_ALERT | ERR_ABORT;
-				goto out;
-			}
-
-			/* the servers are linked backwards first */
-			newsrv->next = curproxy->srv;
-			curproxy->srv = newsrv;
-			newsrv->proxy = curproxy;
-			newsrv->conf.file = file;
-			newsrv->conf.line = linenum;
-
-			LIST_INIT(&newsrv->pendconns);
-			do_check = 0;
-			newsrv->state = SRV_RUNNING; /* early server setup */
-			newsrv->last_change = now.tv_sec;
-			newsrv->id = strdup(args[1]);
-
-			/* several ways to check the port component :
-			 *  - IP    => port=+0, relative
-			 *  - IP:   => port=+0, relative
-			 *  - IP:N  => port=N, absolute
-			 *  - IP:+N => port=+N, relative
-			 *  - IP:-N => port=-N, relative
-			 */
-			raddr = strdup(args[2]);
-			rport = strchr(raddr, ':');
-			if (rport) {
-				*rport++ = 0;
-				realport = atol(rport);
-				if (!isdigit((unsigned char)*rport))
-					newsrv->state |= SRV_MAPPORTS;
-			} else
-				newsrv->state |= SRV_MAPPORTS;
-
-			sk = str2sa(raddr);
-			free(raddr);
-			if (!sk) {
-				Alert("parsing [%s:%d] : Unknown host in '%s'\n", file, linenum, args[2]);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			}
-			newsrv->addr = *sk;
-			newsrv->addr.sin_port = htons(realport);
-
-			newsrv->check_port	= curproxy->defsrv.check_port;
-			newsrv->inter		= curproxy->defsrv.inter;
-			newsrv->fastinter	= curproxy->defsrv.fastinter;
-			newsrv->downinter	= curproxy->defsrv.downinter;
-			newsrv->rise		= curproxy->defsrv.rise;
-			newsrv->fall		= curproxy->defsrv.fall;
-			newsrv->maxqueue	= curproxy->defsrv.maxqueue;
-			newsrv->minconn		= curproxy->defsrv.minconn;
-			newsrv->maxconn		= curproxy->defsrv.maxconn;
-			newsrv->slowstart	= curproxy->defsrv.slowstart;
-			newsrv->onerror		= curproxy->defsrv.onerror;
-			newsrv->consecutive_errors_limit
-						= curproxy->defsrv.consecutive_errors_limit;
-			newsrv->uweight = newsrv->iweight
-						= curproxy->defsrv.iweight;
-
-			newsrv->curfd = -1;		/* no health-check in progress */
-			newsrv->health = newsrv->rise;	/* up, but will fall down at first failure */
-
-			cur_arg = 3;
-		} else {
-			newsrv = &curproxy->defsrv;
-			cur_arg = 1;
-		}
-
-		while (*args[cur_arg]) {
-			if (!defsrv && !strcmp(args[cur_arg], "id")) {
-				struct eb32_node *node;
-
-				if (!*args[cur_arg + 1]) {
-					Alert("parsing [%s:%d]: '%s' expects an integer argument.\n",
-						file, linenum, args[cur_arg]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-
-				newsrv->puid = atol(args[cur_arg + 1]);
-				newsrv->conf.id.key = newsrv->puid;
-
-				if (newsrv->puid <= 0) {
-					Alert("parsing [%s:%d]: custom id has to be > 0.\n",
-						file, linenum);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-
-				node = eb32_lookup(&curproxy->conf.used_server_id, newsrv->puid);
-				if (node) {
-					struct server *target = container_of(node, struct server, conf.id);
-					Alert("parsing [%s:%d]: server %s reuses same custom id as server %s (declared at %s:%d).\n",
-					      file, linenum, newsrv->id, target->id, target->conf.file, target->conf.line);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-				eb32_insert(&curproxy->conf.used_server_id, &newsrv->conf.id);
-				cur_arg += 2;
-			}
-			else if (!defsrv && !strcmp(args[cur_arg], "cookie")) {
-				newsrv->cookie = strdup(args[cur_arg + 1]);
-				newsrv->cklen = strlen(args[cur_arg + 1]);
-				cur_arg += 2;
-			}
-			else if (!defsrv && !strcmp(args[cur_arg], "redir")) {
-				newsrv->rdr_pfx = strdup(args[cur_arg + 1]);
-				newsrv->rdr_len = strlen(args[cur_arg + 1]);
-				cur_arg += 2;
-			}
-			else if (!strcmp(args[cur_arg], "rise")) {
-				if (!*args[cur_arg + 1]) {
-					Alert("parsing [%s:%d]: '%s' expects an integer argument.\n",
-						file, linenum, args[cur_arg]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-
-				newsrv->rise = atol(args[cur_arg + 1]);
-				if (newsrv->rise <= 0) {
-					Alert("parsing [%s:%d]: '%s' has to be > 0.\n",
-						file, linenum, args[cur_arg]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-
-				if (newsrv->health)
-					newsrv->health = newsrv->rise;
-				cur_arg += 2;
-			}
-			else if (!strcmp(args[cur_arg], "fall")) {
-				newsrv->fall = atol(args[cur_arg + 1]);
-
-				if (!*args[cur_arg + 1]) {
-					Alert("parsing [%s:%d]: '%s' expects an integer argument.\n",
-						file, linenum, args[cur_arg]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-
-				if (newsrv->fall <= 0) {
-					Alert("parsing [%s:%d]: '%s' has to be > 0.\n",
-						file, linenum, args[cur_arg]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-
-				cur_arg += 2;
-			}
-			else if (!strcmp(args[cur_arg], "inter")) {
-				const char *err = parse_time_err(args[cur_arg + 1], &val, TIME_UNIT_MS);
-				if (err) {
-					Alert("parsing [%s:%d] : unexpected character '%c' in 'inter' argument of server %s.\n",
-					      file, linenum, *err, newsrv->id);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-				if (val <= 0) {
-					Alert("parsing [%s:%d]: invalid value %d for argument '%s' of server %s.\n",
-					      file, linenum, val, args[cur_arg], newsrv->id);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-				newsrv->inter = val;
-				cur_arg += 2;
-			}
-			else if (!strcmp(args[cur_arg], "fastinter")) {
-				const char *err = parse_time_err(args[cur_arg + 1], &val, TIME_UNIT_MS);
-				if (err) {
-					Alert("parsing [%s:%d]: unexpected character '%c' in 'fastinter' argument of server %s.\n",
-					      file, linenum, *err, newsrv->id);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-				if (val <= 0) {
-					Alert("parsing [%s:%d]: invalid value %d for argument '%s' of server %s.\n",
-					      file, linenum, val, args[cur_arg], newsrv->id);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-				newsrv->fastinter = val;
-				cur_arg += 2;
-			}
-			else if (!strcmp(args[cur_arg], "downinter")) {
-				const char *err = parse_time_err(args[cur_arg + 1], &val, TIME_UNIT_MS);
-				if (err) {
-					Alert("parsing [%s:%d]: unexpected character '%c' in 'downinter' argument of server %s.\n",
-					      file, linenum, *err, newsrv->id);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-				if (val <= 0) {
-					Alert("parsing [%s:%d]: invalid value %d for argument '%s' of server %s.\n",
-					      file, linenum, val, args[cur_arg], newsrv->id);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-				newsrv->downinter = val;
-				cur_arg += 2;
-			}
-			else if (!defsrv && !strcmp(args[cur_arg], "addr")) {
-				struct sockaddr_in *sk = str2sa(args[cur_arg + 1]);
-				if (!sk) {
-					Alert("parsing [%s:%d] : Unknown host in '%s'\n", file, linenum, args[cur_arg + 1]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-				newsrv->check_addr = *sk;
-				cur_arg += 2;
-			}
-			else if (!strcmp(args[cur_arg], "port")) {
-				newsrv->check_port = atol(args[cur_arg + 1]);
-				cur_arg += 2;
-			}
-			else if (!defsrv && !strcmp(args[cur_arg], "backup")) {
-				newsrv->state |= SRV_BACKUP;
-				cur_arg ++;
-			}
-			else if (!strcmp(args[cur_arg], "weight")) {
-				int w;
-				w = atol(args[cur_arg + 1]);
-				if (w < 0 || w > 256) {
-					Alert("parsing [%s:%d] : weight of server %s is not within 0 and 256 (%d).\n",
-					      file, linenum, newsrv->id, w);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-				newsrv->uweight = newsrv->iweight = w;
-				cur_arg += 2;
-			}
-			else if (!strcmp(args[cur_arg], "minconn")) {
-				newsrv->minconn = atol(args[cur_arg + 1]);
-				cur_arg += 2;
-			}
-			else if (!strcmp(args[cur_arg], "maxconn")) {
-				newsrv->maxconn = atol(args[cur_arg + 1]);
-				cur_arg += 2;
-			}
-			else if (!strcmp(args[cur_arg], "maxqueue")) {
-				newsrv->maxqueue = atol(args[cur_arg + 1]);
-				cur_arg += 2;
-			}
-			else if (!strcmp(args[cur_arg], "slowstart")) {
-				/* slowstart is stored in seconds */
-				const char *err = parse_time_err(args[cur_arg + 1], &val, TIME_UNIT_MS);
-				if (err) {
-					Alert("parsing [%s:%d] : unexpected character '%c' in 'slowstart' argument of server %s.\n",
-					      file, linenum, *err, newsrv->id);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-				if (val < 0) {
-					Alert("parsing [%s:%d]: invalid value %d for argument '%s' of server %s.\n",
-					      file, linenum, val, args[cur_arg], newsrv->id);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-				newsrv->slowstart = (val + 999) / 1000;
-				cur_arg += 2;
-			}
-			else if (!defsrv && !strcmp(args[cur_arg], "track")) {
-
-				if (!*args[cur_arg + 1]) {
-					Alert("parsing [%s:%d]: 'track' expects [<proxy>/]<server> as argument.\n",
-						file, linenum);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-
-				newsrv->trackit = strdup(args[cur_arg + 1]);
-
-				cur_arg += 2;
-			}
-			else if (!defsrv && !strcmp(args[cur_arg], "check")) {
-				global.maxsock++;
-				do_check = 1;
-				cur_arg += 1;
-			}
-			else if (!defsrv && !strcmp(args[cur_arg], "disabled")) {
-				newsrv->state |= SRV_MAINTAIN;
-				newsrv->state &= ~SRV_RUNNING;
-				newsrv->health = 0;
-				cur_arg += 1;
-			}
-			else if (!defsrv && !strcmp(args[cur_arg], "observe")) {
-				if (!strcmp(args[cur_arg + 1], "none"))
-					newsrv->observe = HANA_OBS_NONE;
-				else if (!strcmp(args[cur_arg + 1], "layer4"))
-					newsrv->observe = HANA_OBS_LAYER4;
-				else if (!strcmp(args[cur_arg + 1], "layer7")) {
-					if (curproxy->mode != PR_MODE_HTTP) {
-						Alert("parsing [%s:%d]: '%s' can only be used in http proxies.\n",
-							file, linenum, args[cur_arg + 1]);
-						err_code |= ERR_ALERT;
-					}
-					newsrv->observe = HANA_OBS_LAYER7;
-				}
-				else {
-					Alert("parsing [%s:%d]: '%s' expects one of 'none', "
-						"'layer4', 'layer7' but got '%s'\n",
-						file, linenum, args[cur_arg], args[cur_arg + 1]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-
-				cur_arg += 2;
-			}
-			else if (!strcmp(args[cur_arg], "on-error")) {
-				if (!strcmp(args[cur_arg + 1], "fastinter"))
-					newsrv->onerror = HANA_ONERR_FASTINTER;
-				else if (!strcmp(args[cur_arg + 1], "fail-check"))
-					newsrv->onerror = HANA_ONERR_FAILCHK;
-				else if (!strcmp(args[cur_arg + 1], "sudden-death"))
-					newsrv->onerror = HANA_ONERR_SUDDTH;
-				else if (!strcmp(args[cur_arg + 1], "mark-down"))
-					newsrv->onerror = HANA_ONERR_MARKDWN;
-				else {
-					Alert("parsing [%s:%d]: '%s' expects one of 'fastinter', "
-						"'fail-check', 'sudden-death' or 'mark-down' but got '%s'\n",
-						file, linenum, args[cur_arg], args[cur_arg + 1]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-
-				cur_arg += 2;
-			}
-			else if (!strcmp(args[cur_arg], "error-limit")) {
-				if (!*args[cur_arg + 1]) {
-					Alert("parsing [%s:%d]: '%s' expects an integer argument.\n",
-						file, linenum, args[cur_arg]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-
-				newsrv->consecutive_errors_limit = atoi(args[cur_arg + 1]);
-
-				if (newsrv->consecutive_errors_limit <= 0) {
-					Alert("parsing [%s:%d]: %s has to be > 0.\n",
-						file, linenum, args[cur_arg]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-				cur_arg += 2;
-			}
-			else if (!defsrv && !strcmp(args[cur_arg], "source")) {  /* address to which we bind when connecting */
-				int port_low, port_high;
-				struct sockaddr_in *sk;
-
-				if (!*args[cur_arg + 1]) {
-#if defined(CONFIG_HAP_CTTPROXY) || defined(CONFIG_HAP_LINUX_TPROXY)
-					Alert("parsing [%s:%d] : '%s' expects <addr>[:<port>[-<port>]], and optional '%s' <addr> as argument.\n",
-					      file, linenum, "source", "usesrc");
-#else
-					Alert("parsing [%s:%d] : '%s' expects <addr>[:<port>[-<port>]] as argument.\n",
-					      file, linenum, "source");
-#endif
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-				newsrv->state |= SRV_BIND_SRC;
-				sk = str2sa_range(args[cur_arg + 1], &port_low, &port_high);
-				if (!sk) {
-					Alert("parsing [%s:%d] : Unknown host in '%s'\n", file, linenum, args[cur_arg + 1]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-				newsrv->source_addr = *sk;
-
-				if (port_low != port_high) {
-					int i;
-					if (port_low  <= 0 || port_low > 65535 ||
-					    port_high <= 0 || port_high > 65535 ||
-					    port_low > port_high) {
-						Alert("parsing [%s:%d] : invalid source port range %d-%d.\n",
-						      file, linenum, port_low, port_high);
-						err_code |= ERR_ALERT | ERR_FATAL;
-						goto out;
-					}
-					newsrv->sport_range = port_range_alloc_range(port_high - port_low + 1);
-					for (i = 0; i < newsrv->sport_range->size; i++)
-						newsrv->sport_range->ports[i] = port_low + i;
-				}
-
-				cur_arg += 2;
-				while (*(args[cur_arg])) {
-					if (!strcmp(args[cur_arg], "usesrc")) {  /* address to use outside */
-#if defined(CONFIG_HAP_CTTPROXY) || defined(CONFIG_HAP_LINUX_TPROXY)
-#if !defined(CONFIG_HAP_LINUX_TPROXY)
-						if (newsrv->source_addr.sin_addr.s_addr == INADDR_ANY) {
-							Alert("parsing [%s:%d] : '%s' requires an explicit '%s' address.\n",
-							      file, linenum, "usesrc", "source");
-							err_code |= ERR_ALERT | ERR_FATAL;
-							goto out;
-						}
-#endif
-						if (!*args[cur_arg + 1]) {
-							Alert("parsing [%s:%d] : '%s' expects <addr>[:<port>], 'client', 'clientip', or 'hdr_ip(name,#)' as argument.\n",
-							      file, linenum, "usesrc");
-							err_code |= ERR_ALERT | ERR_FATAL;
-							goto out;
-						}
-						if (!strcmp(args[cur_arg + 1], "client")) {
-							newsrv->state &= ~SRV_TPROXY_MASK;
-							newsrv->state |= SRV_TPROXY_CLI;
-						} else if (!strcmp(args[cur_arg + 1], "clientip")) {
-							newsrv->state &= ~SRV_TPROXY_MASK;
-							newsrv->state |= SRV_TPROXY_CIP;
-						} else if (!strncmp(args[cur_arg + 1], "hdr_ip(", 7)) {
-							char *name, *end;
-
-							name = args[cur_arg+1] + 7;
-							while (isspace(*name))
-								name++;
-
-							end = name;
-							while (*end && !isspace(*end) && *end != ',' && *end != ')')
-								end++;
-
-							newsrv->state &= ~SRV_TPROXY_MASK;
-							newsrv->state |= SRV_TPROXY_DYN;
-							newsrv->bind_hdr_name = calloc(1, end - name + 1);
-							newsrv->bind_hdr_len = end - name;
-							memcpy(newsrv->bind_hdr_name, name, end - name);
-							newsrv->bind_hdr_name[end-name] = '\0';
-							newsrv->bind_hdr_occ = -1;
-
-							/* now look for an occurrence number */
-							while (isspace(*end))
-								end++;
-							if (*end == ',') {
-								end++;
-								name = end;
-								if (*end == '-')
-									end++;
-								while (isdigit(*end))
-									end++;
-								newsrv->bind_hdr_occ = strl2ic(name, end-name);
-							}
-
-							if (newsrv->bind_hdr_occ < -MAX_HDR_HISTORY) {
-								Alert("parsing [%s:%d] : usesrc hdr_ip(name,num) does not support negative"
-								      " occurrences values smaller than %d.\n",
-								      file, linenum, MAX_HDR_HISTORY);
-								err_code |= ERR_ALERT | ERR_FATAL;
-								goto out;
-							}
-						} else {
-							struct sockaddr_in *sk = str2sa(args[cur_arg + 1]);
-							if (!sk) {
-								Alert("parsing [%s:%d] : Unknown host in '%s'\n", file, linenum, args[cur_arg + 1]);
-								err_code |= ERR_ALERT | ERR_FATAL;
-								goto out;
-							}
-							newsrv->tproxy_addr = *sk;
-							newsrv->state |= SRV_TPROXY_ADDR;
-						}
-						global.last_checks |= LSTCHK_NETADM;
-#if !defined(CONFIG_HAP_LINUX_TPROXY)
-						global.last_checks |= LSTCHK_CTTPROXY;
-#endif
-						cur_arg += 2;
-						continue;
-#else	/* no TPROXY support */
-						Alert("parsing [%s:%d] : '%s' not allowed here because support for TPROXY was not compiled in.\n",
-						      file, linenum, "usesrc");
-						err_code |= ERR_ALERT | ERR_FATAL;
-						goto out;
-#endif /* defined(CONFIG_HAP_CTTPROXY) || defined(CONFIG_HAP_LINUX_TPROXY) */
-					} /* "usesrc" */
-
-					if (!strcmp(args[cur_arg], "interface")) { /* specifically bind to this interface */
-#ifdef SO_BINDTODEVICE
-						if (!*args[cur_arg + 1]) {
-							Alert("parsing [%s:%d] : '%s' : missing interface name.\n",
-							      file, linenum, args[0]);
-							err_code |= ERR_ALERT | ERR_FATAL;
-							goto out;
-						}
-						if (newsrv->iface_name)
-							free(newsrv->iface_name);
-
-						newsrv->iface_name = strdup(args[cur_arg + 1]);
-						newsrv->iface_len  = strlen(newsrv->iface_name);
-						global.last_checks |= LSTCHK_NETADM;
-#else
-						Alert("parsing [%s:%d] : '%s' : '%s' option not implemented.\n",
-						      file, linenum, args[0], args[cur_arg]);
-						err_code |= ERR_ALERT | ERR_FATAL;
-						goto out;
-#endif
-						cur_arg += 2;
-						continue;
-					}
-					/* this keyword in not an option of "source" */
-					break;
-				} /* while */
-			}
-			else if (!defsrv && !strcmp(args[cur_arg], "usesrc")) {  /* address to use outside: needs "source" first */
-				Alert("parsing [%s:%d] : '%s' only allowed after a '%s' statement.\n",
-				      file, linenum, "usesrc", "source");
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			}
-			else {
-				if (!defsrv)
-					Alert("parsing [%s:%d] : server %s only supports options 'backup', 'cookie', 'redir', 'observer', 'on-error', 'error-limit', 'check', 'disabled', 'track', 'id', 'inter', 'fastinter', 'downinter', 'rise', 'fall', 'addr', 'port', 'source', 'minconn', 'maxconn', 'maxqueue', 'slowstart' and 'weight'.\n",
-					      file, linenum, newsrv->id);
-				else
-					Alert("parsing [%s:%d]: default-server only supports options 'on-error', 'error-limit', 'inter', 'fastinter', 'downinter', 'rise', 'fall', 'port', 'minconn', 'maxconn', 'maxqueue', 'slowstart' and 'weight'.\n",
-					      file, linenum);
-
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			}
-		}
-
-		if (do_check) {
-			if (newsrv->trackit) {
-				Alert("parsing [%s:%d]: unable to enable checks and tracking at the same time!\n",
-					file, linenum);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			}
-
-			if (!newsrv->check_port && newsrv->check_addr.sin_port)
-				newsrv->check_port = htons(newsrv->check_addr.sin_port);
-
-			if (!newsrv->check_port && !(newsrv->state & SRV_MAPPORTS))
-				newsrv->check_port = realport; /* by default */
-			if (!newsrv->check_port) {
-				/* not yet valid, because no port was set on
-				 * the server either. We'll check if we have
-				 * a known port on the first listener.
-				 */
-				struct listener *l;
-				l = curproxy->listen;
-				if (l) {
-					int port;
-					port = (l->addr.ss_family == AF_INET6)
-					        ? ntohs(((struct sockaddr_in6 *)(&l->addr))->sin6_port)
-						: ntohs(((struct sockaddr_in *)(&l->addr))->sin_port);
-					newsrv->check_port = port;
-				}
-			}
-			if (!newsrv->check_port) {
-				Alert("parsing [%s:%d] : server %s has neither service port nor check port. Check has been disabled.\n",
-				      file, linenum, newsrv->id);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			}
-
-			/* Allocate buffer for partial check results... */
-			if ((newsrv->check_data = calloc(global.tune.chksize, sizeof(char))) == NULL) {
-				Alert("parsing [%s:%d] : out of memory while allocating check buffer.\n", file, linenum);
-				err_code |= ERR_ALERT | ERR_ABORT;
-				goto out;
-			}
-
-			newsrv->check_status = HCHK_STATUS_INI;
-			newsrv->state |= SRV_CHECKED;
-		}
-
-		if (!defsrv) {
-			if (newsrv->state & SRV_BACKUP)
-				curproxy->srv_bck++;
-			else
-				curproxy->srv_act++;
-
-			newsrv->prev_state = newsrv->state;
-		}
-	}
-	else if (!strcmp(args[0], "log")) {  /* syslog server address */
-		struct logsrv logsrv;
-		int facility;
-	
-		if (*(args[1]) && *(args[2]) == 0 && !strcmp(args[1], "global")) {
-			curproxy->logfac1 = global.logfac1;
-			curproxy->logsrv1 = global.logsrv1;
-			curproxy->loglev1 = global.loglev1;
-			curproxy->minlvl1 = global.minlvl1;
-			curproxy->logfac2 = global.logfac2;
-			curproxy->logsrv2 = global.logsrv2;
-			curproxy->loglev2 = global.loglev2;
-			curproxy->minlvl2 = global.minlvl2;
-		}
-		else if (*(args[1]) && *(args[2])) {
-			int level, minlvl;
-
-			facility = get_log_facility(args[2]);
-			if (facility < 0) {
-				Alert("parsing [%s:%d] : unknown log facility '%s'\n", file, linenum, args[2]);
-				exit(1);
-			}
-	    
-			level = 7; /* max syslog level = debug */
-			if (*(args[3])) {
-				level = get_log_level(args[3]);
-				if (level < 0) {
-					Alert("parsing [%s:%d] : unknown optional log level '%s'\n", file, linenum, args[3]);
-					exit(1);
-				}
-			}
-
-			minlvl = 0; /* limit syslog level to this level (emerg) */
-			if (*(args[4])) {
-				minlvl = get_log_level(args[4]);
-				if (level < 0) {
-					Alert("parsing [%s:%d] : unknown optional minimum log level '%s'\n", file, linenum, args[4]);
-					exit(1);
-				}
-			}
-
-			if (args[1][0] == '/') {
-				struct sockaddr_un *sk = str2sun(args[1]);
-				if (!sk) {
-					Alert("parsing [%s:%d] : Socket path '%s' too long (max %d)\n", file, linenum,
-					      args[1], (int)sizeof(sk->sun_path) - 1);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-				logsrv.u.un = *sk;
-				logsrv.u.addr.sa_family = AF_UNIX;
-			} else {
-				struct sockaddr_in *sk = str2sa(args[1]);
-				if (!sk) {
-					Alert("parsing [%s:%d] : Unknown host in '%s'\n", file, linenum, args[1]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-				logsrv.u.in = *sk;
-				logsrv.u.addr.sa_family = AF_INET;
-				if (!logsrv.u.in.sin_port) {
-					logsrv.u.in.sin_port =
-						htons(SYSLOG_PORT);
-				}
-			}
-	    
-			if (curproxy->logfac1 == -1) {
-				curproxy->logsrv1 = logsrv;
-				curproxy->logfac1 = facility;
-				curproxy->loglev1 = level;
-				curproxy->minlvl1 = minlvl;
-			}
-			else if (curproxy->logfac2 == -1) {
-				curproxy->logsrv2 = logsrv;
-				curproxy->logfac2 = facility;
-				curproxy->loglev2 = level;
-				curproxy->minlvl2 = minlvl;
-			}
-			else {
-				Alert("parsing [%s:%d] : too many syslog servers\n", file, linenum);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			}
-		}
-		else {
-			Alert("parsing [%s:%d] : 'log' expects either <address[:port]> and <facility> or 'global' as arguments.\n",
-			      file, linenum);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-	}
-	else if (!strcmp(args[0], "source")) {  /* address to which we bind when connecting */
-		int cur_arg;
-		struct sockaddr_in *sk;
-
-		if (warnifnotcap(curproxy, PR_CAP_BE, file, linenum, args[0], NULL))
-			err_code |= ERR_WARN;
-
-		if (!*args[1]) {
-			Alert("parsing [%s:%d] : '%s' expects <addr>[:<port>], and optionally '%s' <addr>, and '%s' <name>.\n",
-			      file, linenum, "source", "usesrc", "interface");
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		/* we must first clear any optional default setting */	
-		curproxy->options &= ~PR_O_TPXY_MASK;
-		free(curproxy->iface_name);
-		curproxy->iface_name = NULL;
-		curproxy->iface_len = 0;
-
-		sk = str2sa(args[1]);
-		if (!sk) {
-			Alert("parsing [%s:%d] : Unknown host in '%s'\n", file, linenum, args[1]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		curproxy->source_addr = *sk;
-		curproxy->options |= PR_O_BIND_SRC;
-
-		cur_arg = 2;
-		while (*(args[cur_arg])) {
-			if (!strcmp(args[cur_arg], "usesrc")) {  /* address to use outside */
-#if defined(CONFIG_HAP_CTTPROXY) || defined(CONFIG_HAP_LINUX_TPROXY)
-#if !defined(CONFIG_HAP_LINUX_TPROXY)
-				if (curproxy->source_addr.sin_addr.s_addr == INADDR_ANY) {
-					Alert("parsing [%s:%d] : '%s' requires an explicit 'source' address.\n",
-					      file, linenum, "usesrc");
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-#endif
-				if (!*args[cur_arg + 1]) {
-					Alert("parsing [%s:%d] : '%s' expects <addr>[:<port>], 'client', or 'clientip' as argument.\n",
-					      file, linenum, "usesrc");
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-
-				if (!strcmp(args[cur_arg + 1], "client")) {
-					curproxy->options &= ~PR_O_TPXY_MASK;
-					curproxy->options |= PR_O_TPXY_CLI;
-				} else if (!strcmp(args[cur_arg + 1], "clientip")) {
-					curproxy->options &= ~PR_O_TPXY_MASK;
-					curproxy->options |= PR_O_TPXY_CIP;
-				} else if (!strncmp(args[cur_arg + 1], "hdr_ip(", 7)) {
-					char *name, *end;
-
-					name = args[cur_arg+1] + 7;
-					while (isspace(*name))
-						name++;
-
-					end = name;
-					while (*end && !isspace(*end) && *end != ',' && *end != ')')
-						end++;
-
-					curproxy->options &= ~PR_O_TPXY_MASK;
-					curproxy->options |= PR_O_TPXY_DYN;
-					curproxy->bind_hdr_name = calloc(1, end - name + 1);
-					curproxy->bind_hdr_len = end - name;
-					memcpy(curproxy->bind_hdr_name, name, end - name);
-					curproxy->bind_hdr_name[end-name] = '\0';
-					curproxy->bind_hdr_occ = -1;
-
-					/* now look for an occurrence number */
-					while (isspace(*end))
-						end++;
-					if (*end == ',') {
-						end++;
-						name = end;
-						if (*end == '-')
-							end++;
-						while (isdigit(*end))
-							end++;
-						curproxy->bind_hdr_occ = strl2ic(name, end-name);
-					}
-
-					if (curproxy->bind_hdr_occ < -MAX_HDR_HISTORY) {
-						Alert("parsing [%s:%d] : usesrc hdr_ip(name,num) does not support negative"
-						      " occurrences values smaller than %d.\n",
-						      file, linenum, MAX_HDR_HISTORY);
-						err_code |= ERR_ALERT | ERR_FATAL;
-						goto out;
-					}
-				} else {
-					struct sockaddr_in *sk = str2sa(args[cur_arg + 1]);
-					if (!sk) {
-						Alert("parsing [%s:%d] : Unknown host in '%s'\n", file, linenum, args[cur_arg + 1]);
-						err_code |= ERR_ALERT | ERR_FATAL;
-						goto out;
-					}
-					curproxy->tproxy_addr = *sk;
-					curproxy->options |= PR_O_TPXY_ADDR;
-				}
-				global.last_checks |= LSTCHK_NETADM;
-#if !defined(CONFIG_HAP_LINUX_TPROXY)
-				global.last_checks |= LSTCHK_CTTPROXY;
-#endif
-#else	/* no TPROXY support */
-				Alert("parsing [%s:%d] : '%s' not allowed here because support for TPROXY was not compiled in.\n",
-				      file, linenum, "usesrc");
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-#endif
-				cur_arg += 2;
-				continue;
-			}
-
-			if (!strcmp(args[cur_arg], "interface")) { /* specifically bind to this interface */
-#ifdef SO_BINDTODEVICE
-				if (!*args[cur_arg + 1]) {
-					Alert("parsing [%s:%d] : '%s' : missing interface name.\n",
-					      file, linenum, args[0]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-				if (curproxy->iface_name)
-					free(curproxy->iface_name);
-
-				curproxy->iface_name = strdup(args[cur_arg + 1]);
-				curproxy->iface_len  = strlen(curproxy->iface_name);
-				global.last_checks |= LSTCHK_NETADM;
-#else
-				Alert("parsing [%s:%d] : '%s' : '%s' option not implemented.\n",
-				      file, linenum, args[0], args[cur_arg]);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-#endif
-				cur_arg += 2;
-				continue;
-			}
-			Alert("parsing [%s:%d] : '%s' only supports optional keywords '%s' and '%s'.\n",
-			      file, linenum, args[0], "inteface", "usesrc");
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-	}
-	else if (!strcmp(args[0], "usesrc")) {  /* address to use outside: needs "source" first */
-		Alert("parsing [%s:%d] : '%s' only allowed after a '%s' statement.\n",
-		      file, linenum, "usesrc", "source");
-		err_code |= ERR_ALERT | ERR_FATAL;
-		goto out;
-	}
-	else if (!strcmp(args[0], "cliexp") || !strcmp(args[0], "reqrep")) {  /* replace request header from a regex */
-		if (*(args[2]) == 0) {
-			Alert("parsing [%s:%d] : '%s' expects <search> and <replace> as arguments.\n",
-			      file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		err_code |= create_cond_regex_rule(file, linenum, curproxy,
-						   ACL_DIR_REQ, ACT_REPLACE, 0,
-						   args[0], args[1], args[2], (const char **)args+3);
-		if (err_code & ERR_FATAL)
-			goto out;
-	}
-	else if (!strcmp(args[0], "reqdel")) {  /* delete request header from a regex */
-		err_code |= create_cond_regex_rule(file, linenum, curproxy,
-						   ACL_DIR_REQ, ACT_REMOVE, 0,
-						   args[0], args[1], NULL, (const char **)args+2);
-		if (err_code & ERR_FATAL)
-			goto out;
-	}
-	else if (!strcmp(args[0], "reqdeny")) {  /* deny a request if a header matches this regex */
-		err_code |= create_cond_regex_rule(file, linenum, curproxy,
-						   ACL_DIR_REQ, ACT_DENY, 0,
-						   args[0], args[1], NULL, (const char **)args+2);
-		if (err_code & ERR_FATAL)
-			goto out;
-	}
-	else if (!strcmp(args[0], "reqpass")) {  /* pass this header without allowing or denying the request */
-		err_code |= create_cond_regex_rule(file, linenum, curproxy,
-						   ACL_DIR_REQ, ACT_PASS, 0,
-						   args[0], args[1], NULL, (const char **)args+2);
-		if (err_code & ERR_FATAL)
-			goto out;
-	}
-	else if (!strcmp(args[0], "reqallow")) {  /* allow a request if a header matches this regex */
-		err_code |= create_cond_regex_rule(file, linenum, curproxy,
-						   ACL_DIR_REQ, ACT_ALLOW, 0,
-						   args[0], args[1], NULL, (const char **)args+2);
-		if (err_code & ERR_FATAL)
-			goto out;
-	}
-	else if (!strcmp(args[0], "reqtarpit")) {  /* tarpit a request if a header matches this regex */
-		err_code |= create_cond_regex_rule(file, linenum, curproxy,
-						   ACL_DIR_REQ, ACT_TARPIT, 0,
-						   args[0], args[1], NULL, (const char **)args+2);
-		if (err_code & ERR_FATAL)
-			goto out;
-	}
-	else if (!strcmp(args[0], "reqsetbe")) { /* switch the backend from a regex, respecting case */
-		err_code |= create_cond_regex_rule(file, linenum, curproxy,
-						   ACL_DIR_REQ, ACT_SETBE, 0,
-						   args[0], args[1], args[2], (const char **)args+3);
-		if (err_code & ERR_FATAL)
-			goto out;
-	}
-	else if (!strcmp(args[0], "reqisetbe")) { /* switch the backend from a regex, ignoring case */
-		err_code |= create_cond_regex_rule(file, linenum, curproxy,
-						   ACL_DIR_REQ, ACT_SETBE, REG_ICASE,
-						   args[0], args[1], args[2], (const char **)args+3);
-		if (err_code & ERR_FATAL)
-			goto out;
-	}
-	else if (!strcmp(args[0], "reqirep")) {  /* replace request header from a regex, ignoring case */
-		if (*(args[2]) == 0) {
-			Alert("parsing [%s:%d] : '%s' expects <search> and <replace> as arguments.\n",
-			      file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		err_code |= create_cond_regex_rule(file, linenum, curproxy,
-						   ACL_DIR_REQ, ACT_REPLACE, REG_ICASE,
-						   args[0], args[1], args[2], (const char **)args+3);
-		if (err_code & ERR_FATAL)
-			goto out;
-	}
-	else if (!strcmp(args[0], "reqidel")) {  /* delete request header from a regex ignoring case */
-		err_code |= create_cond_regex_rule(file, linenum, curproxy,
-						   ACL_DIR_REQ, ACT_REMOVE, REG_ICASE,
-						   args[0], args[1], NULL, (const char **)args+2);
-		if (err_code & ERR_FATAL)
-			goto out;
-	}
-	else if (!strcmp(args[0], "reqideny")) {  /* deny a request if a header matches this regex ignoring case */
-		err_code |= create_cond_regex_rule(file, linenum, curproxy,
-						   ACL_DIR_REQ, ACT_DENY, REG_ICASE,
-						   args[0], args[1], NULL, (const char **)args+2);
-		if (err_code & ERR_FATAL)
-			goto out;
-	}
-	else if (!strcmp(args[0], "reqipass")) {  /* pass this header without allowing or denying the request */
-		err_code |= create_cond_regex_rule(file, linenum, curproxy,
-						   ACL_DIR_REQ, ACT_PASS, REG_ICASE,
-						   args[0], args[1], NULL, (const char **)args+2);
-		if (err_code & ERR_FATAL)
-			goto out;
-	}
-	else if (!strcmp(args[0], "reqiallow")) {  /* allow a request if a header matches this regex ignoring case */
-		err_code |= create_cond_regex_rule(file, linenum, curproxy,
-						   ACL_DIR_REQ, ACT_ALLOW, REG_ICASE,
-						   args[0], args[1], NULL, (const char **)args+2);
-		if (err_code & ERR_FATAL)
-			goto out;
-	}
-	else if (!strcmp(args[0], "reqitarpit")) {  /* tarpit a request if a header matches this regex ignoring case */
-		err_code |= create_cond_regex_rule(file, linenum, curproxy,
-						   ACL_DIR_REQ, ACT_TARPIT, REG_ICASE,
-						   args[0], args[1], NULL, (const char **)args+2);
-		if (err_code & ERR_FATAL)
-			goto out;
-	}
-	else if (!strcmp(args[0], "reqadd")) {  /* add request header */
-		struct cond_wordlist *wl;
-
-		if (curproxy == &defproxy) {
-			Alert("parsing [%s:%d] : '%s' not allowed in 'defaults' section.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		else if (warnifnotcap(curproxy, PR_CAP_RS, file, linenum, args[0], NULL))
-			err_code |= ERR_WARN;
-
-		if (*(args[1]) == 0) {
-			Alert("parsing [%s:%d] : '%s' expects <header> as an argument.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		if ((strcmp(args[2], "if") == 0 || strcmp(args[2], "unless") == 0)) {
-			if ((cond = build_acl_cond(file, linenum, curproxy, (const char **)args+2)) == NULL) {
-				Alert("parsing [%s:%d] : error detected while parsing a '%s' condition.\n",
-				      file, linenum, args[0]);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			}
-			err_code |= warnif_cond_requires_resp(cond, file, linenum);
-		}
-		else if (*args[2]) {
-			Alert("parsing [%s:%d] : '%s' : Expecting nothing, 'if', or 'unless', got '%s'.\n",
-			      file, linenum, args[0], args[2]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		wl = calloc(1, sizeof(*wl));
-		wl->cond = cond;
-		wl->s = strdup(args[1]);
-		LIST_ADDQ(&curproxy->req_add, &wl->list);
-		warnif_misplaced_reqadd(curproxy, file, linenum, args[0]);
-	}
-	else if (!strcmp(args[0], "srvexp") || !strcmp(args[0], "rsprep")) {  /* replace response header from a regex */
-		if (*(args[2]) == 0) {
-			Alert("parsing [%s:%d] : '%s' expects <search> and <replace> as arguments.\n",
-			      file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		err_code |= create_cond_regex_rule(file, linenum, curproxy,
-						   ACL_DIR_RTR, ACT_REPLACE, 0,
-						   args[0], args[1], args[2], (const char **)args+3);
-		if (err_code & ERR_FATAL)
-			goto out;
-	}
-	else if (!strcmp(args[0], "rspdel")) {  /* delete response header from a regex */
-		err_code |= create_cond_regex_rule(file, linenum, curproxy,
-						   ACL_DIR_RTR, ACT_REMOVE, 0,
-						   args[0], args[1], NULL, (const char **)args+2);
-		if (err_code & ERR_FATAL)
-			goto out;
-	}
-	else if (!strcmp(args[0], "rspdeny")) {  /* block response header from a regex */
-		err_code |= create_cond_regex_rule(file, linenum, curproxy,
-						   ACL_DIR_RTR, ACT_DENY, 0,
-						   args[0], args[1], NULL, (const char **)args+2);
-		if (err_code & ERR_FATAL)
-			goto out;
-	}
-	else if (!strcmp(args[0], "rspirep")) {  /* replace response header from a regex ignoring case */
-		if (*(args[2]) == 0) {
-			Alert("parsing [%s:%d] : '%s' expects <search> and <replace> as arguments.\n",
-			      file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		err_code |= create_cond_regex_rule(file, linenum, curproxy,
-						   ACL_DIR_RTR, ACT_REPLACE, REG_ICASE,
-						   args[0], args[1], args[2], (const char **)args+3);
-		if (err_code & ERR_FATAL)
-			goto out;
-	}
-	else if (!strcmp(args[0], "rspidel")) {  /* delete response header from a regex ignoring case */
-		err_code |= create_cond_regex_rule(file, linenum, curproxy,
-						   ACL_DIR_RTR, ACT_REMOVE, REG_ICASE,
-						   args[0], args[1], NULL, (const char **)args+2);
-		if (err_code & ERR_FATAL)
-			goto out;
-	}
-	else if (!strcmp(args[0], "rspideny")) {  /* block response header from a regex ignoring case */
-		err_code |= create_cond_regex_rule(file, linenum, curproxy,
-						   ACL_DIR_RTR, ACT_DENY, REG_ICASE,
-						   args[0], args[1], NULL, (const char **)args+2);
-		if (err_code & ERR_FATAL)
-			goto out;
-	}
-	else if (!strcmp(args[0], "rspadd")) {  /* add response header */
-		struct cond_wordlist *wl;
-
-		if (curproxy == &defproxy) {
-			Alert("parsing [%s:%d] : '%s' not allowed in 'defaults' section.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		else if (warnifnotcap(curproxy, PR_CAP_RS, file, linenum, args[0], NULL))
-			err_code |= ERR_WARN;
-
-		if (*(args[1]) == 0) {
-			Alert("parsing [%s:%d] : '%s' expects <header> as an argument.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-	
-		if ((strcmp(args[2], "if") == 0 || strcmp(args[2], "unless") == 0)) {
-			if ((cond = build_acl_cond(file, linenum, curproxy, (const char **)args+2)) == NULL) {
-				Alert("parsing [%s:%d] : error detected while parsing a '%s' condition.\n",
-				      file, linenum, args[0]);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			}
-			err_code |= warnif_cond_requires_req(cond, file, linenum);
-		}
-		else if (*args[2]) {
-			Alert("parsing [%s:%d] : '%s' : Expecting nothing, 'if', or 'unless', got '%s'.\n",
-			      file, linenum, args[0], args[2]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		wl = calloc(1, sizeof(*wl));
-		wl->cond = cond;
-		wl->s = strdup(args[1]);
-		LIST_ADDQ(&curproxy->rsp_add, &wl->list);
-	}
-	else if (!strcmp(args[0], "errorloc") ||
-		 !strcmp(args[0], "errorloc302") ||
-		 !strcmp(args[0], "errorloc303")) { /* error location */
-		int errnum, errlen;
-		char *err;
-
-		if (warnifnotcap(curproxy, PR_CAP_FE | PR_CAP_BE, file, linenum, args[0], NULL))
-			err_code |= ERR_WARN;
-
-		if (*(args[2]) == 0) {
-			Alert("parsing [%s:%d] : <%s> expects <status_code> and <url> as arguments.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		errnum = atol(args[1]);
-		if (!strcmp(args[0], "errorloc303")) {
-			err = malloc(strlen(HTTP_303) + strlen(args[2]) + 5);
-			errlen = sprintf(err, "%s%s\r\n\r\n", HTTP_303, args[2]);
-		} else {
-			err = malloc(strlen(HTTP_302) + strlen(args[2]) + 5);
-			errlen = sprintf(err, "%s%s\r\n\r\n", HTTP_302, args[2]);
-		}
-
-		for (rc = 0; rc < HTTP_ERR_SIZE; rc++) {
-			if (http_err_codes[rc] == errnum) {
-				chunk_destroy(&curproxy->errmsg[rc]);
-				chunk_initlen(&curproxy->errmsg[rc], err, errlen, errlen);
-				break;
-			}
-		}
-
-		if (rc >= HTTP_ERR_SIZE) {
-			Warning("parsing [%s:%d] : status code %d not handled, error relocation will be ignored.\n",
-				file, linenum, errnum);
-			free(err);
-		}
-	}
-	else if (!strcmp(args[0], "errorfile")) { /* error message from a file */
-		int errnum, errlen, fd;
-		char *err;
-		struct stat stat;
-
-		if (warnifnotcap(curproxy, PR_CAP_FE | PR_CAP_BE, file, linenum, args[0], NULL))
-			err_code |= ERR_WARN;
-
-		if (*(args[2]) == 0) {
-			Alert("parsing [%s:%d] : <%s> expects <status_code> and <file> as arguments.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		fd = open(args[2], O_RDONLY);
-		if ((fd < 0) || (fstat(fd, &stat) < 0)) {
-			Alert("parsing [%s:%d] : error opening file <%s> for custom error message <%s>.\n",
-			      file, linenum, args[2], args[1]);
-			if (fd >= 0)
-				close(fd);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		if (stat.st_size <= global.tune.bufsize) {
-			errlen = stat.st_size;
-		} else {
-			Warning("parsing [%s:%d] : custom error message file <%s> larger than %d bytes. Truncating.\n",
-				file, linenum, args[2], global.tune.bufsize);
-			err_code |= ERR_WARN;
-			errlen = global.tune.bufsize;
-		}
-
-		err = malloc(errlen); /* malloc() must succeed during parsing */
-		errnum = read(fd, err, errlen);
-		if (errnum != errlen) {
-			Alert("parsing [%s:%d] : error reading file <%s> for custom error message <%s>.\n",
-			      file, linenum, args[2], args[1]);
-			close(fd);
-			free(err);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-		close(fd);
-
-		errnum = atol(args[1]);
-		for (rc = 0; rc < HTTP_ERR_SIZE; rc++) {
-			if (http_err_codes[rc] == errnum) {
-				chunk_destroy(&curproxy->errmsg[rc]);
-				chunk_initlen(&curproxy->errmsg[rc], err, errlen, errlen);
-				break;
-			}
-		}
-
-		if (rc >= HTTP_ERR_SIZE) {
-			Warning("parsing [%s:%d] : status code %d not handled, error customization will be ignored.\n",
-				file, linenum, errnum);
-			err_code |= ERR_WARN;
-			free(err);
-		}
-	}
-	else {
-		struct cfg_kw_list *kwl;
-		int index;
-
-		list_for_each_entry(kwl, &cfg_keywords.list, list) {
-			for (index = 0; kwl->kw[index].kw != NULL; index++) {
-				if (kwl->kw[index].section != CFG_LISTEN)
-					continue;
-				if (strcmp(kwl->kw[index].kw, args[0]) == 0) {
-					/* prepare error message just in case */
-					snprintf(trash, trashlen,
-						 "error near '%s' in %s section", args[0], cursection);
-					rc = kwl->kw[index].parse(args, CFG_LISTEN, curproxy, &defproxy, trash, trashlen);
-					if (rc < 0) {
-						Alert("parsing [%s:%d] : %s\n", file, linenum, trash);
-						err_code |= ERR_ALERT | ERR_FATAL;
-						goto out;
-					}
-					else if (rc > 0) {
-						Warning("parsing [%s:%d] : %s\n", file, linenum, trash);
-						err_code |= ERR_WARN;
-						goto out;
-					}
-					goto out;
-				}
-			}
-		}
-		
-		Alert("parsing [%s:%d] : unknown keyword '%s' in '%s' section\n", file, linenum, args[0], cursection);
-		err_code |= ERR_ALERT | ERR_FATAL;
-		goto out;
-	}
- out:
-	return err_code;
-}
-
-int
-cfg_parse_users(const char *file, int linenum, char **args, int kwm)
-{
-
-	int err_code = 0;
-	const char *err;
-
-	if (!strcmp(args[0], "userlist")) {		/* new userlist */
-		struct userlist *newul;
-
-		if (!*args[1]) {
-			Alert("parsing [%s:%d]: '%s' expects <name> as arguments.\n",
-			      file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		err = invalid_char(args[1]);
-		if (err) {
-			Alert("parsing [%s:%d]: character '%c' is not permitted in '%s' name '%s'.\n",
-			      file, linenum, *err, args[0], args[1]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		for (newul = userlist; newul; newul = newul->next)
-			if (!strcmp(newul->name, args[1])) {
-				Warning("parsing [%s:%d]: ignoring duplicated userlist '%s'.\n",
-					file, linenum, args[1]);
-				err_code |= ERR_WARN;
-				goto out;
-			}
-
-		newul = (struct userlist *)calloc(1, sizeof(struct userlist));
-		if (!newul) {
-			Alert("parsing [%s:%d]: out of memory.\n", file, linenum);
-			err_code |= ERR_ALERT | ERR_ABORT;
-			goto out;
-		}
-
-		newul->groupusers = calloc(MAX_AUTH_GROUPS, sizeof(char *));
-		newul->name = strdup(args[1]);
-
-		if (!newul->groupusers | !newul->name) {
-			Alert("parsing [%s:%d]: out of memory.\n", file, linenum);
-			err_code |= ERR_ALERT | ERR_ABORT;
-			goto out;
-		}
-
-		newul->next = userlist;
-		userlist = newul;
-
-	} else if (!strcmp(args[0], "group")) {  	/* new group */
-		int cur_arg, i;
-		const char *err;
-
-		if (!*args[1]) {
-			Alert("parsing [%s:%d]: '%s' expects <name> as arguments.\n",
-			      file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		err = invalid_char(args[1]);
-		if (err) {
-			Alert("parsing [%s:%d]: character '%c' is not permitted in '%s' name '%s'.\n",
-			      file, linenum, *err, args[0], args[1]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		for(i = 0; i < userlist->grpcnt; i++)
-			if (!strcmp(userlist->groups[i], args[1])) {
-				Warning("parsing [%s:%d]: ignoring duplicated group '%s' in userlist '%s'.\n",
-				      file, linenum, args[1], userlist->name);
-				err_code |= ERR_ALERT;
-				goto out;
-			}
-
-		if (userlist->grpcnt >= MAX_AUTH_GROUPS) {
-			Alert("parsing [%s:%d]: too many groups (%u) in in userlist '%s' while adding group '%s'.\n",
-			      file, linenum, MAX_AUTH_GROUPS, userlist->name, args[1]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		cur_arg = 2;
-
-		while (*args[cur_arg]) {
-			if (!strcmp(args[cur_arg], "users")) {
-				userlist->groupusers[userlist->grpcnt] = strdup(args[cur_arg + 1]);
-				cur_arg += 2;
-				continue;
-			} else {
-				Alert("parsing [%s:%d]: '%s' only supports 'users' option.\n",
-				      file, linenum, args[0]);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			}
-		}
-
-		userlist->groups[userlist->grpcnt++] = strdup(args[1]);
-	} else if (!strcmp(args[0], "user")) {		/* new user */
-		struct auth_users *newuser;
-		int cur_arg;
-
-		if (!*args[1]) {
-			Alert("parsing [%s:%d]: '%s' expects <name> as arguments.\n",
-			      file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			goto out;
-		}
-
-		for (newuser = userlist->users; newuser; newuser = newuser->next)
-			if (!strcmp(newuser->user, args[1])) {
-				Warning("parsing [%s:%d]: ignoring duplicated user '%s' in userlist '%s'.\n",
-				      file, linenum, args[1], userlist->name);
-				err_code |= ERR_ALERT;
-				goto out;
-			}
-
-		newuser = (struct auth_users *)calloc(1, sizeof(struct auth_users));
-		if (!newuser) {
-			Alert("parsing [%s:%d]: out of memory.\n", file, linenum);
-			err_code |= ERR_ALERT | ERR_ABORT;
-			goto out;
-		}
-
-		newuser->user = strdup(args[1]);
-
-		newuser->next = userlist->users;
-		userlist->users = newuser;
-
-		cur_arg = 2;
-
-		while (*args[cur_arg]) {
-			if (!strcmp(args[cur_arg], "password")) {
-#ifndef CONFIG_HAP_CRYPT
-				Warning("parsing [%s:%d]: no crypt(3) support compiled, encrypted passwords will not work.\n",
-					file, linenum);
-				err_code |= ERR_ALERT;
-#endif
-				newuser->pass = strdup(args[cur_arg + 1]);
-				cur_arg += 2;
-				continue;
-			} else if (!strcmp(args[cur_arg], "insecure-password")) {
-				newuser->pass = strdup(args[cur_arg + 1]);
-				newuser->flags |= AU_O_INSECURE;
-				cur_arg += 2;
-				continue;
-			} else if (!strcmp(args[cur_arg], "groups")) {
-				newuser->u.groups = strdup(args[cur_arg + 1]);
-				cur_arg += 2;
-				continue;
-			} else {
-				Alert("parsing [%s:%d]: '%s' only supports 'password', 'insecure-password' and 'groups' options.\n",
-				      file, linenum, args[0]);
-				err_code |= ERR_ALERT | ERR_FATAL;
-				goto out;
-			}
-		}
-	} else {
-		Alert("parsing [%s:%d]: unknown keyword '%s' in '%s' section\n", file, linenum, args[0], "users");
-		err_code |= ERR_ALERT | ERR_FATAL;
-	}
-
-out:
-	return err_code;
-}
-
-/*
- * This function reads and parses the configuration file given in the argument.
- * Returns the error code, 0 if OK, or any combination of :
- *  - ERR_ABORT: must abort ASAP
- *  - ERR_FATAL: we can continue parsing but not start the service
- *  - ERR_WARN: a warning has been emitted
- *  - ERR_ALERT: an alert has been emitted
- * Only the two first ones can stop processing, the two others are just
- * indicators.
- */
-int readcfgfile(const char *file)
-{
-	char thisline[LINESIZE];
-	FILE *f;
-	int linenum = 0;
-	int confsect = CFG_NONE;
-	int err_code = 0;
-
-	if ((f=fopen(file,"r")) == NULL)
-		return -1;
-
-	while (fgets(thisline, sizeof(thisline), f) != NULL) {
-		int arg, kwm = KWM_STD;
-		char *end;
-		char *args[MAX_LINE_ARGS + 1];
-		char *line = thisline;
-
-		linenum++;
-
-		end = line + strlen(line);
-
-		if (end-line == sizeof(thisline)-1 && *(end-1) != '\n') {
-			/* Check if we reached the limit and the last char is not \n.
-			 * Watch out for the last line without the terminating '\n'!
-			 */
-			Alert("parsing [%s:%d]: line too long, limit: %d.\n",
-			      file, linenum, (int)sizeof(thisline)-1);
-			err_code |= ERR_ALERT | ERR_FATAL;
-		}
-
-		/* skip leading spaces */
-		while (isspace((unsigned char)*line))
-			line++;
-	
-		arg = 0;
-		args[arg] = line;
-
-		while (*line && arg < MAX_LINE_ARGS) {
-			/* first, we'll replace \\, \<space>, \#, \r, \n, \t, \xXX with their
-			 * C equivalent value. Other combinations left unchanged (eg: \1).
-			 */
-			if (*line == '\\') {
-				int skip = 0;
-				if (line[1] == ' ' || line[1] == '\\' || line[1] == '#') {
-					*line = line[1];
-					skip = 1;
-				}
-				else if (line[1] == 'r') {
-					*line = '\r';
-					skip = 1;
-				} 
-				else if (line[1] == 'n') {
-					*line = '\n';
-					skip = 1;
-				}
-				else if (line[1] == 't') {
-					*line = '\t';
-					skip = 1;
-				}
-				else if (line[1] == 'x') {
-					if ((line + 3 < end) && ishex(line[2]) && ishex(line[3])) {
-						unsigned char hex1, hex2;
-						hex1 = toupper(line[2]) - '0';
-						hex2 = toupper(line[3]) - '0';
-						if (hex1 > 9) hex1 -= 'A' - '9' - 1;
-						if (hex2 > 9) hex2 -= 'A' - '9' - 1;
-						*line = (hex1<<4) + hex2;
-						skip = 3;
-					}
-					else {
-						Alert("parsing [%s:%d] : invalid or incomplete '\\x' sequence in '%s'.\n", file, linenum, args[0]);
-						err_code |= ERR_ALERT | ERR_FATAL;
-					}
-				}
-				if (skip) {
-					memmove(line + 1, line + 1 + skip, end - (line + skip));
-					end -= skip;
-				}
-				line++;
-			}
-			else if (*line == '#' || *line == '\n' || *line == '\r') {
-				/* end of string, end of loop */
-				*line = 0;
-				break;
-			}
-			else if (isspace((unsigned char)*line)) {
-				/* a non-escaped space is an argument separator */
-				*line++ = '\0';
-				while (isspace((unsigned char)*line))
-					line++;
-				args[++arg] = line;
-			}
-			else {
-				line++;
-			}
-		}
-
-		/* empty line */
-		if (!**args)
-			continue;
-
-		if (*line) {
-			/* we had to stop due to too many args.
-			 * Let's terminate the string, print the offending part then cut the
-			 * last arg.
-			 */
-			while (*line && *line != '#' && *line != '\n' && *line != '\r')
-				line++;
-			*line = '\0';
-
-			Alert("parsing [%s:%d]: line too long, truncating at word %d, position %ld: <%s>.\n",
-			      file, linenum, arg + 1, (long)(args[arg] - thisline + 1), args[arg]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-			args[arg] = line;
-		}
-
-		/* zero out remaining args and ensure that at least one entry
-		 * is zeroed out.
-		 */
-		while (++arg <= MAX_LINE_ARGS) {
-			args[arg] = line;
-		}
-
-		/* check for keyword modifiers "no" and "default" */
-		if (!strcmp(args[0], "no")) {
-			kwm = KWM_NO;
-			for (arg=0; *args[arg+1]; arg++)
-				args[arg] = args[arg+1];		// shift args after inversion
-		}
-		else if (!strcmp(args[0], "default")) {
-			kwm = KWM_DEF;
-			for (arg=0; *args[arg+1]; arg++)
-				args[arg] = args[arg+1];		// shift args after inversion
-		}
-
-		if (kwm != KWM_STD && strcmp(args[0], "option") != 0) {
-			Alert("parsing [%s:%d]: negation/default currently supported only for options.\n", file, linenum);
-			err_code |= ERR_ALERT | ERR_FATAL;
-		}
-
-		if (!strcmp(args[0], "listen") ||
-		    !strcmp(args[0], "frontend") ||
-		    !strcmp(args[0], "backend") ||
-		    !strcmp(args[0], "ruleset") ||
-		    !strcmp(args[0], "defaults")) { /* new proxy */
-			confsect = CFG_LISTEN;
-			free(cursection);
-			cursection = strdup(args[0]);
-		}
-		else if (!strcmp(args[0], "global")) { /* global config */
-			confsect = CFG_GLOBAL;
-			free(cursection);
-			cursection = strdup(args[0]);
-		} else if (!strcmp(args[0], "userlist")) {
-			confsect = CFG_USERLIST;
-			free(cursection);
-			cursection = strdup(args[0]);
-		}
-		/* else it's a section keyword */
-
-		switch (confsect) {
-		case CFG_LISTEN:
-			err_code |= cfg_parse_listen(file, linenum, args, kwm);
-			break;
-		case CFG_GLOBAL:
-			err_code |= cfg_parse_global(file, linenum, args, kwm);
-			break;
-		case CFG_USERLIST:
-			err_code |= cfg_parse_users(file, linenum, args, kwm);
-			break;
-		default:
-			Alert("parsing [%s:%d]: unknown keyword '%s' out of section.\n", file, linenum, args[0]);
-			err_code |= ERR_ALERT | ERR_FATAL;
-		}
-
-		if (err_code & ERR_ABORT)
-			break;
-	}
-	free(cursection);
-	cursection = NULL;
-	fclose(f);
-	return err_code;
-}
-
-/*
- * Returns the error code, 0 if OK, or any combination of :
- *  - ERR_ABORT: must abort ASAP
- *  - ERR_FATAL: we can continue parsing but not start the service
- *  - ERR_WARN: a warning has been emitted
- *  - ERR_ALERT: an alert has been emitted
- * Only the two first ones can stop processing, the two others are just
- * indicators.
- */
-int check_config_validity()
-{
-	int cfgerr = 0;
-	struct proxy *curproxy = NULL;
-	struct server *newsrv = NULL;
-	struct userlist *curuserlist = NULL;
-	int err_code = 0;
-	unsigned int next_pxid = 1;
-
-	/*
-	 * Now, check for the integrity of all that we have collected.
-	 */
-
-	/* will be needed further to delay some tasks */
-	tv_update_date(0,1);
-
-	/* first, we will invert the proxy list order */
-	curproxy = NULL;
-	while (proxy) {
-		struct proxy *next;
-
-		next = proxy->next;
-		proxy->next = curproxy;
-		curproxy = proxy;
-		if (!next)
-			break;
-		proxy = next;
-	}
-
-	if ((curproxy = proxy) == NULL) {
-		Alert("config : no <listen> line. Nothing to do !\n");
-		err_code |= ERR_ALERT | ERR_FATAL;
-		goto out;
-	}
-
-	while (curproxy != NULL) {
-		struct switching_rule *rule;
-		struct sticking_rule *mrule;
-		struct listener *listener;
-		unsigned int next_id;
-
-		if (!curproxy->uuid) {
-			/* proxy ID not set, use automatic numbering with first
-			 * spare entry starting with next_pxid.
-			 */
-			next_pxid = get_next_id(&used_proxy_id, next_pxid);
-			curproxy->conf.id.key = curproxy->uuid = next_pxid;
-			eb32_insert(&used_proxy_id, &curproxy->conf.id);
-		}
-		next_pxid++;
-
-
-		if (curproxy->state == PR_STSTOPPED) {
-			/* ensure we don't keep listeners uselessly bound */
-			stop_proxy(curproxy);
-			curproxy = curproxy->next;
-			continue;
-		}
-
-		switch (curproxy->mode) {
-		case PR_MODE_HEALTH:
-			cfgerr += proxy_cfg_ensure_no_http(curproxy);
-			if (!(curproxy->cap & PR_CAP_FE)) {
-				Alert("config : %s '%s' cannot be in health mode as it has no frontend capability.\n",
-				      proxy_type_str(curproxy), curproxy->id);
-				cfgerr++;
-			}
-
-			if (curproxy->srv != NULL)
-				Warning("config : servers will be ignored for %s '%s'.\n",
-					proxy_type_str(curproxy), curproxy->id);
-			break;
-
-		case PR_MODE_TCP:
-			cfgerr += proxy_cfg_ensure_no_http(curproxy);
-			break;
-
-		case PR_MODE_HTTP:
-			curproxy->acl_requires |= ACL_USE_L7_ANY;
-			if ((curproxy->cookie_name != NULL) && (curproxy->srv == NULL)) {
-				Alert("config : HTTP proxy %s has a cookie but no server list !\n",
-				      curproxy->id);
-				cfgerr++;
-			}
-			break;
-		}
-
-		if ((curproxy->cap & PR_CAP_FE) && (curproxy->listen == NULL))  {
-			Alert("config : %s '%s' has no listen address. Please either specify a valid address on the <listen> line, or use the <bind> keyword.\n",
-			      proxy_type_str(curproxy), curproxy->id);
-			cfgerr++;
-		}
-
-		if ((curproxy->cap & PR_CAP_BE) && (curproxy->mode != PR_MODE_HEALTH)) {
-			if (curproxy->lbprm.algo & BE_LB_KIND) {
-				if (curproxy->options & PR_O_TRANSP) {
-					Alert("config : %s '%s' cannot use both transparent and balance mode.\n",
-					      proxy_type_str(curproxy), curproxy->id);
-					cfgerr++;
-				}
-#ifdef WE_DONT_SUPPORT_SERVERLESS_LISTENERS
-				else if (curproxy->srv == NULL) {
-					Alert("config : %s '%s' needs at least 1 server in balance mode.\n",
-					      proxy_type_str(curproxy), curproxy->id);
-					cfgerr++;
-				}
-#endif
-				else if (*(int *)&curproxy->dispatch_addr.sin_addr != 0) {
-					Warning("config : dispatch address of %s '%s' will be ignored in balance mode.\n",
-						proxy_type_str(curproxy), curproxy->id);
-					err_code |= ERR_WARN;
-				}
-			}
-			else if (!(curproxy->options & (PR_O_TRANSP | PR_O_HTTP_PROXY)) &&
-				 (*(int *)&curproxy->dispatch_addr.sin_addr == 0)) {
-				/* If no LB algo is set in a backend, and we're not in
-				 * transparent mode, dispatch mode nor proxy mode, we
-				 * want to use balance roundrobin by default.
-				 */
-				curproxy->lbprm.algo &= ~BE_LB_ALGO;
-				curproxy->lbprm.algo |= BE_LB_ALGO_RR;
-			}
-		}
-
-		if ((curproxy->options & PR_O_DISABLE404) && !(curproxy->options & PR_O_HTTP_CHK)) {
-			curproxy->options &= ~PR_O_DISABLE404;
-			Warning("config : '%s' will be ignored for %s '%s' (requires 'option httpchk').\n",
-				"disable-on-404", proxy_type_str(curproxy), curproxy->id);
-			err_code |= ERR_WARN;
-		}
-
-		if ((curproxy->options2 & PR_O2_CHK_SNDST) && !(curproxy->options & PR_O_HTTP_CHK)) {
-			curproxy->options &= ~PR_O2_CHK_SNDST;
-			Warning("config : '%s' will be ignored for %s '%s' (requires 'option httpchk').\n",
-				"send-state", proxy_type_str(curproxy), curproxy->id);
-			err_code |= ERR_WARN;
-		}
-
-		/* if a default backend was specified, let's find it */
-		if (curproxy->defbe.name) {
-			struct proxy *target;
-
-			target = findproxy_mode(curproxy->defbe.name, curproxy->mode, PR_CAP_BE);
-			if (!target) {
-				Alert("Proxy '%s': unable to find required default_backend: '%s'.\n",
-					curproxy->id, curproxy->defbe.name);
-				cfgerr++;
-			} else if (target == curproxy) {
-				Alert("Proxy '%s': loop detected for default_backend: '%s'.\n",
-					curproxy->id, curproxy->defbe.name);
-				cfgerr++;
-			} else {
-				free(curproxy->defbe.name);
-				curproxy->defbe.be = target;
-				/* we force the backend to be present on at least all of
-				 * the frontend's processes.
-				 */
-				target->bind_proc = curproxy->bind_proc ?
-					(target->bind_proc | curproxy->bind_proc) : 0;
-			}
-		}
-
-		/* find the target proxy in setbe */
-		if (curproxy->mode == PR_MODE_HTTP && curproxy->req_exp != NULL) {
-			/* map jump target for ACT_SETBE in req_rep chain */ 
-			struct hdr_exp *exp;
-			for (exp = curproxy->req_exp; exp != NULL; exp = exp->next) {
-				struct proxy *target;
-
-				if (exp->action != ACT_SETBE)
-					continue;
-
-				target = findproxy_mode(exp->replace, PR_MODE_HTTP, PR_CAP_BE);
-				if (!target) {
-					Alert("Proxy '%s': unable to find required setbe: '%s'.\n",
-						curproxy->id, exp->replace);
-					cfgerr++;
-				} else if (target == curproxy) {
-					Alert("Proxy '%s': loop detected for setbe: '%s'.\n",
-						curproxy->id, exp->replace);
-					cfgerr++;
-				} else {
-					free((void *)exp->replace);
-					exp->replace = (const char *)target;
-					/* we force the backend to be present on at least all of
-					 * the frontend's processes.
-					 */
-					target->bind_proc = curproxy->bind_proc ?
-						(target->bind_proc | curproxy->bind_proc) : 0;
-				}
-			}
-		}
-
-		/* find the target proxy for 'use_backend' rules */
-		list_for_each_entry(rule, &curproxy->switching_rules, list) {
-			struct proxy *target;
-
-			target = findproxy_mode(rule->be.name, curproxy->mode, PR_CAP_BE);
-
-			if (!target) {
-				Alert("Proxy '%s': unable to find required use_backend: '%s'.\n",
-					curproxy->id, rule->be.name);
-				cfgerr++;
-			} else if (target == curproxy) {
-				Alert("Proxy '%s': loop detected for use_backend: '%s'.\n",
-					curproxy->id, rule->be.name);
-				cfgerr++;
-			} else {
-				free((void *)rule->be.name);
-				rule->be.backend = target;
-				/* we force the backend to be present on at least all of
-				 * the frontend's processes.
-				 */
-				target->bind_proc = curproxy->bind_proc ?
-					(target->bind_proc | curproxy->bind_proc) : 0;
-			}
-		}
-
-		/* find the target table for 'stick' rules */
-		list_for_each_entry(mrule, &curproxy->sticking_rules, list) {
-			struct proxy *target;
-
-			curproxy->be_req_ana |= AN_REQ_STICKING_RULES;
-			if (mrule->flags & STK_IS_STORE)
-				curproxy->be_rsp_ana |= AN_RES_STORE_RULES;
-
-			if (mrule->table.name)
-				target = findproxy(mrule->table.name, PR_CAP_BE);
-			else
-				target = curproxy;
-
-			if (!target) {
-				Alert("Proxy '%s': unable to find stick-table '%s'.\n",
-				      curproxy->id, mrule->table.name);
-				cfgerr++;
-			}
-			else if (target->table.size == 0) {
-				Alert("Proxy '%s': stick-table '%s' used but not configured.\n",
-				      curproxy->id, mrule->table.name ? mrule->table.name : curproxy->id);
-				cfgerr++;
-			}
-			else if (pattern_notusable_key(mrule->expr,  target->table.type)) {
-				Alert("Proxy '%s': type of pattern not usable with type of stick-table '%s'.\n",
-				      curproxy->id, mrule->table.name ? mrule->table.name : curproxy->id);
-				cfgerr++;
-			}
-			else {
-				free((void *)mrule->table.name);
-				mrule->table.t = &(target->table);
-			}
-		}
-
-		/* find the target table for 'store response' rules */
-		list_for_each_entry(mrule, &curproxy->storersp_rules, list) {
-			struct proxy *target;
-
-			curproxy->be_rsp_ana |= AN_RES_STORE_RULES;
-
-			if (mrule->table.name)
-				target = findproxy(mrule->table.name, PR_CAP_BE);
-			else
-				target = curproxy;
-
-			if (!target) {
-				Alert("Proxy '%s': unable to find store table '%s'.\n",
-				      curproxy->id, mrule->table.name);
-				cfgerr++;
-			}
-			else if (target->table.size == 0) {
-				Alert("Proxy '%s': stick-table '%s' used but not configured.\n",
-				      curproxy->id, mrule->table.name ? mrule->table.name : curproxy->id);
-				cfgerr++;
-			}
-			else if (pattern_notusable_key(mrule->expr, target->table.type)) {
-				Alert("Proxy '%s': type of pattern not usable with type of stick-table '%s'.\n",
-				      curproxy->id, mrule->table.name ? mrule->table.name : curproxy->id);
-				cfgerr++;
-			}
-			else {
-				free((void *)mrule->table.name);
-				mrule->table.t = &(target->table);
-			}
-		}
-
-		if (curproxy->uri_auth && !(curproxy->uri_auth->flags & ST_CONVDONE) &&
-		    !LIST_ISEMPTY(&curproxy->uri_auth->req_acl) &&
-		    (curproxy->uri_auth->userlist || curproxy->uri_auth->auth_realm )) {
-			Alert("%s '%s': stats 'auth'/'realm' and 'http-request' can't be used at the same time.\n",
-			      "proxy", curproxy->id);
-			cfgerr++;
-			goto out_uri_auth_compat;
-		}
-
-		if (curproxy->uri_auth && curproxy->uri_auth->userlist && !(curproxy->uri_auth->flags & ST_CONVDONE)) {
-			const char *uri_auth_compat_req[10];
-			struct req_acl_rule *req_acl;
-			int i = 0;
-
-			/* build the ACL condition from scratch. We're relying on anonymous ACLs for that */
-			uri_auth_compat_req[i++] = "auth";
-
-			if (curproxy->uri_auth->auth_realm) {
-				uri_auth_compat_req[i++] = "realm";
-				uri_auth_compat_req[i++] = curproxy->uri_auth->auth_realm;
-			}
-
-			uri_auth_compat_req[i++] = "unless";
-			uri_auth_compat_req[i++] = "{";
-			uri_auth_compat_req[i++] = "http_auth(.internal-stats-userlist)";
-			uri_auth_compat_req[i++] = "}";
-			uri_auth_compat_req[i++] = "";
-
-			req_acl = parse_auth_cond(uri_auth_compat_req, "internal-stats-auth-compat", 0, curproxy);
-			if (!req_acl) {
-				cfgerr++;
-				break;
-			}
-
-			LIST_ADDQ(&curproxy->uri_auth->req_acl, &req_acl->list);
-
-			if (curproxy->uri_auth->auth_realm) {
-				free(curproxy->uri_auth->auth_realm);
-				curproxy->uri_auth->auth_realm = NULL;
-			}
-
-			curproxy->uri_auth->flags |= ST_CONVDONE;
-		}
-out_uri_auth_compat:
-
-		cfgerr += acl_find_targets(curproxy);
-
-		if ((curproxy->mode == PR_MODE_TCP || curproxy->mode == PR_MODE_HTTP) &&
-		    (((curproxy->cap & PR_CAP_FE) && !curproxy->timeout.client) ||
-		     ((curproxy->cap & PR_CAP_BE) && (curproxy->srv) &&
-		      (!curproxy->timeout.connect || !curproxy->timeout.server)))) {
-			Warning("config : missing timeouts for %s '%s'.\n"
-				"   | While not properly invalid, you will certainly encounter various problems\n"
-				"   | with such a configuration. To fix this, please ensure that all following\n"
-				"   | timeouts are set to a non-zero value: 'client', 'connect', 'server'.\n",
-				proxy_type_str(curproxy), curproxy->id);
-			err_code |= ERR_WARN;
-		}
-
-		/* Historically, the tarpit and queue timeouts were inherited from contimeout.
-		 * We must still support older configurations, so let's find out whether those
-		 * parameters have been set or must be copied from contimeouts.
-		 */
-		if (curproxy != &defproxy) {
-			if (!curproxy->timeout.tarpit ||
-			    curproxy->timeout.tarpit == defproxy.timeout.tarpit) {
-				/* tarpit timeout not set. We search in the following order:
-				 * default.tarpit, curr.connect, default.connect.
-				 */
-				if (defproxy.timeout.tarpit)
-					curproxy->timeout.tarpit = defproxy.timeout.tarpit;
-				else if (curproxy->timeout.connect)
-					curproxy->timeout.tarpit = curproxy->timeout.connect;
-				else if (defproxy.timeout.connect)
-					curproxy->timeout.tarpit = defproxy.timeout.connect;
-			}
-			if ((curproxy->cap & PR_CAP_BE) &&
-			    (!curproxy->timeout.queue ||
-			     curproxy->timeout.queue == defproxy.timeout.queue)) {
-				/* queue timeout not set. We search in the following order:
-				 * default.queue, curr.connect, default.connect.
-				 */
-				if (defproxy.timeout.queue)
-					curproxy->timeout.queue = defproxy.timeout.queue;
-				else if (curproxy->timeout.connect)
-					curproxy->timeout.queue = curproxy->timeout.connect;
-				else if (defproxy.timeout.connect)
-					curproxy->timeout.queue = defproxy.timeout.connect;
-			}
-		}
-
-		if (curproxy->options2 & PR_O2_SSL3_CHK) {
-			curproxy->check_len = sizeof(sslv3_client_hello_pkt) - 1;
-			curproxy->check_req = (char *)malloc(curproxy->check_len);
-			memcpy(curproxy->check_req, sslv3_client_hello_pkt, curproxy->check_len);
-		}
-
-		/* The small pools required for the capture lists */
-		if (curproxy->nb_req_cap) {
-			if (curproxy->mode == PR_MODE_HTTP) {
-				curproxy->req_cap_pool = create_pool("ptrcap",
-								     curproxy->nb_req_cap * sizeof(char *),
-								     MEM_F_SHARED);
-			} else {
-				Warning("config : 'capture request header' ignored for %s '%s' as it requires HTTP mode.\n",
-					proxy_type_str(curproxy), curproxy->id);
-				err_code |= ERR_WARN;
-				curproxy->to_log &= ~LW_REQHDR;
-				curproxy->nb_req_cap = 0;
-			}
-		}
-
-		if (curproxy->nb_rsp_cap) {
-			if (curproxy->mode == PR_MODE_HTTP) {
-				curproxy->rsp_cap_pool = create_pool("ptrcap",
-								     curproxy->nb_rsp_cap * sizeof(char *),
-								     MEM_F_SHARED);
-			} else {
-				Warning("config : 'capture response header' ignored for %s '%s' as it requires HTTP mode.\n",
-					proxy_type_str(curproxy), curproxy->id);
-				err_code |= ERR_WARN;
-				curproxy->to_log &= ~LW_REQHDR;
-				curproxy->nb_rsp_cap = 0;
-			}
-		}
-
-		curproxy->hdr_idx_pool = create_pool("hdr_idx",
-						     MAX_HTTP_HDR * sizeof(struct hdr_idx_elem),
-						     MEM_F_SHARED);
-
-		/* for backwards compatibility with "listen" instances, if
-		 * fullconn is not set but maxconn is set, then maxconn
-		 * is used.
-		 */
-		if (!curproxy->fullconn)
-			curproxy->fullconn = curproxy->maxconn;
-
-		/* first, we will invert the servers list order */
-		newsrv = NULL;
-		while (curproxy->srv) {
-			struct server *next;
-
-			next = curproxy->srv->next;
-			curproxy->srv->next = newsrv;
-			newsrv = curproxy->srv;
-			if (!next)
-				break;
-			curproxy->srv = next;
-		}
-
-		/* assign automatic UIDs to servers which don't have one yet */
-		next_id = 1;
-		newsrv = curproxy->srv;
-		while (newsrv != NULL) {
-			if (!newsrv->puid) {
-				/* server ID not set, use automatic numbering with first
-				 * spare entry starting with next_svid.
-				 */
-				next_id = get_next_id(&curproxy->conf.used_server_id, next_id);
-				newsrv->conf.id.key = newsrv->puid = next_id;
-				eb32_insert(&curproxy->conf.used_server_id, &newsrv->conf.id);
-			}
-			next_id++;
-			newsrv = newsrv->next;
-		}
-
-		curproxy->lbprm.wmult = 1; /* default weight multiplier */
-		curproxy->lbprm.wdiv  = 1; /* default weight divider */
-
-		/*
-		 * If this server supports a maxconn parameter, it needs a dedicated
-		 * tasks to fill the emptied slots when a connection leaves.
-		 * Also, resolve deferred tracking dependency if needed.
-		 */
-		newsrv = curproxy->srv;
-		while (newsrv != NULL) {
-			if (newsrv->minconn > newsrv->maxconn) {
-				/* Only 'minconn' was specified, or it was higher than or equal
-				 * to 'maxconn'. Let's turn this into maxconn and clean it, as
-				 * this will avoid further useless expensive computations.
-				 */
-				newsrv->maxconn = newsrv->minconn;
-			} else if (newsrv->maxconn && !newsrv->minconn) {
-				/* minconn was not specified, so we set it to maxconn */
-				newsrv->minconn = newsrv->maxconn;
-			} else if (newsrv->minconn != newsrv->maxconn && !curproxy->fullconn) {
-				Alert("config : %s '%s' : fullconn is mandatory when minconn is set on a server.\n",
-				      proxy_type_str(curproxy), curproxy->id);
-				cfgerr++;
-			}
-
-			if (newsrv->trackit) {
-				struct proxy *px;
-				struct server *srv;
-				char *pname, *sname;
-
-				pname = newsrv->trackit;
-				sname = strrchr(pname, '/');
-
-				if (sname)
-					*sname++ = '\0';
-				else {
-					sname = pname;
-					pname = NULL;
-				}
-
-				if (pname) {
-					px = findproxy(pname, PR_CAP_BE);
-					if (!px) {
-						Alert("config : %s '%s', server '%s': unable to find required proxy '%s' for tracking.\n",
-							proxy_type_str(curproxy), curproxy->id,
-							newsrv->id, pname);
-						cfgerr++;
-						goto next_srv;
-					}
-				} else
-					px = curproxy;
-
-				srv = findserver(px, sname);
-				if (!srv) {
-					Alert("config : %s '%s', server '%s': unable to find required server '%s' for tracking.\n",
-						proxy_type_str(curproxy), curproxy->id,
-						newsrv->id, sname);
-					cfgerr++;
-					goto next_srv;
-				}
-
-				if (!(srv->state & SRV_CHECKED)) {
-					Alert("config : %s '%s', server '%s': unable to use %s/%s for "
-						"tracking as it does not have checks enabled.\n",
-						proxy_type_str(curproxy), curproxy->id,
-						newsrv->id, px->id, srv->id);
-					cfgerr++;
-					goto next_srv;
-				}
-
-				if (curproxy != px &&
-					(curproxy->options & PR_O_DISABLE404) != (px->options & PR_O_DISABLE404)) {
-					Alert("config : %s '%s', server '%s': unable to use %s/%s for"
-						"tracking: disable-on-404 option inconsistency.\n",
-						proxy_type_str(curproxy), curproxy->id,
-						newsrv->id, px->id, srv->id);
-					cfgerr++;
-					goto next_srv;
-				}
-
-				/* if the other server is forced disabled, we have to do the same here */
-				if (srv->state & SRV_MAINTAIN) {
-					newsrv->state |= SRV_MAINTAIN;
-					newsrv->state &= ~SRV_RUNNING;
-					newsrv->health = 0;
-				}
-
-				newsrv->tracked = srv;
-				newsrv->tracknext = srv->tracknext;
-				srv->tracknext = newsrv;
-
-				free(newsrv->trackit);
-				newsrv->trackit = NULL;
-			}
-		next_srv:
-			newsrv = newsrv->next;
-		}
-
-		/* We have to initialize the server lookup mechanism depending
-		 * on what LB algorithm was choosen.
-		 */
-
-		curproxy->lbprm.algo &= ~(BE_LB_LKUP | BE_LB_PROP_DYN);
-		switch (curproxy->lbprm.algo & BE_LB_KIND) {
-		case BE_LB_KIND_RR:
-			if ((curproxy->lbprm.algo & BE_LB_PARM) == BE_LB_RR_STATIC) {
-				curproxy->lbprm.algo |= BE_LB_LKUP_MAP;
-				init_server_map(curproxy);
-			} else {
-				curproxy->lbprm.algo |= BE_LB_LKUP_RRTREE | BE_LB_PROP_DYN;
-				fwrr_init_server_groups(curproxy);
-			}
-			break;
-
-		case BE_LB_KIND_LC:
-			curproxy->lbprm.algo |= BE_LB_LKUP_LCTREE | BE_LB_PROP_DYN;
-			fwlc_init_server_tree(curproxy);
-			break;
-
-		case BE_LB_KIND_HI:
-			if ((curproxy->lbprm.algo & BE_LB_HASH_TYPE) == BE_LB_HASH_CONS) {
-				curproxy->lbprm.algo |= BE_LB_LKUP_CHTREE | BE_LB_PROP_DYN;
-				chash_init_server_tree(curproxy);
-			} else {
-				curproxy->lbprm.algo |= BE_LB_LKUP_MAP;
-				init_server_map(curproxy);
-			}
-			break;
-		}
-
-		if (curproxy->options & PR_O_LOGASAP)
-			curproxy->to_log &= ~LW_BYTES;
-
-		if ((curproxy->mode == PR_MODE_TCP || curproxy->mode == PR_MODE_HTTP) &&
-		    (curproxy->cap & PR_CAP_FE) && curproxy->to_log && curproxy->logfac1 < 0) {
-			Warning("config : log format ignored for %s '%s' since it has no log address.\n",
-				proxy_type_str(curproxy), curproxy->id);
-			err_code |= ERR_WARN;
-		}
-
-		if (curproxy->mode != PR_MODE_HTTP) {
-			int optnum;
-
-			if (curproxy->options & PR_O_COOK_ANY) {
-				Warning("config : 'cookie' statement ignored for %s '%s' as it requires HTTP mode.\n",
-					proxy_type_str(curproxy), curproxy->id);
-				err_code |= ERR_WARN;
-			}
-
-			if (curproxy->uri_auth) {
-				Warning("config : 'stats' statement ignored for %s '%s' as it requires HTTP mode.\n",
-					proxy_type_str(curproxy), curproxy->id);
-				err_code |= ERR_WARN;
-				curproxy->uri_auth = NULL;
-			}
-
-			if (curproxy->options & PR_O_FWDFOR) {
-				Warning("config : 'option %s' ignored for %s '%s' as it requires HTTP mode.\n",
-					"forwardfor", proxy_type_str(curproxy), curproxy->id);
-				err_code |= ERR_WARN;
-				curproxy->options &= ~PR_O_FWDFOR;
-				curproxy->options2 &= ~PR_O2_FF_ALWAYS;
-			}
-
-			if (curproxy->options & PR_O_ORGTO) {
-				Warning("config : 'option %s' ignored for %s '%s' as it requires HTTP mode.\n",
-					"originalto", proxy_type_str(curproxy), curproxy->id);
-				err_code |= ERR_WARN;
-				curproxy->options &= ~PR_O_ORGTO;
-			}
-
-			for (optnum = 0; cfg_opts[optnum].name; optnum++) {
-				if (cfg_opts[optnum].mode == PR_MODE_HTTP &&
-				    (curproxy->cap & cfg_opts[optnum].cap) &&
-				    (curproxy->options & cfg_opts[optnum].val)) {
-					Warning("config : 'option %s' ignored for %s '%s' as it requires HTTP mode.\n",
-						cfg_opts[optnum].name, proxy_type_str(curproxy), curproxy->id);
-					err_code |= ERR_WARN;
-					curproxy->options &= ~cfg_opts[optnum].val;
-				}
-			}
-
-			for (optnum = 0; cfg_opts2[optnum].name; optnum++) {
-				if (cfg_opts2[optnum].mode == PR_MODE_HTTP &&
-				    (curproxy->cap & cfg_opts2[optnum].cap) &&
-				    (curproxy->options2 & cfg_opts2[optnum].val)) {
-					Warning("config : 'option %s' ignored for %s '%s' as it requires HTTP mode.\n",
-						cfg_opts2[optnum].name, proxy_type_str(curproxy), curproxy->id);
-					err_code |= ERR_WARN;
-					curproxy->options2 &= ~cfg_opts2[optnum].val;
-				}
-			}
-
-#if defined(CONFIG_HAP_CTTPROXY) || defined(CONFIG_HAP_LINUX_TPROXY)
-			if (curproxy->bind_hdr_occ) {
-				curproxy->bind_hdr_occ = 0;
-				Warning("config : %s '%s' : ignoring use of header %s as source IP in non-HTTP mode.\n",
-					proxy_type_str(curproxy), curproxy->id, curproxy->bind_hdr_name);
-				err_code |= ERR_WARN;
-			}
-#endif
-		}
-
-		/*
-		 * ensure that we're not cross-dressing a TCP server into HTTP.
-		 */
-		newsrv = curproxy->srv;
-		while (newsrv != NULL) {
-			if ((curproxy->mode != PR_MODE_HTTP) && (newsrv->rdr_len || newsrv->cklen)) {
-				Alert("config : %s '%s' : server cannot have cookie or redirect prefix in non-HTTP mode.\n",
-				      proxy_type_str(curproxy), curproxy->id);
-				cfgerr++;
-			}
-
-#if defined(CONFIG_HAP_CTTPROXY) || defined(CONFIG_HAP_LINUX_TPROXY)
-			if (curproxy->mode != PR_MODE_HTTP && newsrv->bind_hdr_occ) {
-				newsrv->bind_hdr_occ = 0;
-				Warning("config : %s '%s' : server %s cannot use header %s as source IP in non-HTTP mode.\n",
-					proxy_type_str(curproxy), curproxy->id, newsrv->id, newsrv->bind_hdr_name);
-				err_code |= ERR_WARN;
-			}
-#endif
-			newsrv = newsrv->next;
-		}
-
-		if (curproxy->cap & PR_CAP_FE) {
-			if (curproxy->tcp_req.inspect_delay ||
-			    !LIST_ISEMPTY(&curproxy->tcp_req.inspect_rules))
-				curproxy->fe_req_ana |= AN_REQ_INSPECT;
-
-			if (curproxy->mode == PR_MODE_HTTP) {
-				curproxy->fe_req_ana |= AN_REQ_WAIT_HTTP | AN_REQ_HTTP_PROCESS_FE;
-				curproxy->fe_rsp_ana |= AN_RES_WAIT_HTTP | AN_RES_HTTP_PROCESS_FE;
-			}
-
-			/* both TCP and HTTP must check switching rules */
-			curproxy->fe_req_ana |= AN_REQ_SWITCHING_RULES;
-		}
-
-		if (curproxy->cap & PR_CAP_BE) {
-			if (curproxy->mode == PR_MODE_HTTP) {
-				curproxy->be_req_ana |= AN_REQ_WAIT_HTTP | AN_REQ_HTTP_INNER | AN_REQ_HTTP_PROCESS_BE;
-				curproxy->be_rsp_ana |= AN_RES_WAIT_HTTP | AN_RES_HTTP_PROCESS_BE;
-			}
-
-			/* init table on backend capabilities proxy */
-			stktable_init(&curproxy->table);
-
-			/* If the backend does requires RDP cookie persistence, we have to
-			 * enable the corresponding analyser.
-			 */
-			if (curproxy->options2 & PR_O2_RDPC_PRST)
-				curproxy->be_req_ana |= AN_REQ_PRST_RDP_COOKIE;
-		}
-
-		listener = NULL;
-		while (curproxy->listen) {
-			struct listener *next;
-
-			next = curproxy->listen->next;
-			curproxy->listen->next = listener;
-			listener = curproxy->listen;
-
-			if (!next)
-				break;
-
-			curproxy->listen = next;
-		}
-
-		/* adjust this proxy's listeners */
-		next_id = 1;
-		listener = curproxy->listen;
-		while (listener) {
-			if (!listener->luid) {
-				/* listener ID not set, use automatic numbering with first
-				 * spare entry starting with next_luid.
-				 */
-				next_id = get_next_id(&curproxy->conf.used_listener_id, next_id);
-				listener->conf.id.key = listener->luid = next_id;
-				eb32_insert(&curproxy->conf.used_listener_id, &listener->conf.id);
-			}
-			next_id++;
-
-			/* enable separate counters */
-			if (curproxy->options2 & PR_O2_SOCKSTAT) {
-				listener->counters = (struct licounters *)calloc(1, sizeof(struct licounters));
-				if (!listener->name) {
-					sprintf(trash, "sock-%d", listener->luid);
-					listener->name = strdup(trash);
-				}
-			}
-
-			if (curproxy->options & PR_O_TCP_NOLING)
-				listener->options |= LI_O_NOLINGER;
-			listener->maxconn = curproxy->maxconn;
-			listener->backlog = curproxy->backlog;
-			listener->timeout = &curproxy->timeout.client;
-			listener->accept = event_accept;
-			listener->private = curproxy;
-			listener->handler = process_session;
-			listener->analysers |= curproxy->fe_req_ana;
-
-			if (listener->options & LI_O_ACC_PROXY)
-				listener->analysers |= AN_REQ_DECODE_PROXY;
-
-			/* smart accept mode is automatic in HTTP mode */
-			if ((curproxy->options2 & PR_O2_SMARTACC) ||
-			    (curproxy->mode == PR_MODE_HTTP &&
-			     !(curproxy->no_options2 & PR_O2_SMARTACC)))
-				listener->options |= LI_O_NOQUICKACK;
-
-			/* We want the use_backend and default_backend rules to apply */
-			listener = listener->next;
-		}
-
-		/* Check multi-process mode compatibility for the current proxy */
-		if (global.nbproc > 1) {
-			int nbproc = 0;
-			if (curproxy->bind_proc) {
-				int proc;
-				for (proc = 0; proc < global.nbproc; proc++) {
-					if (curproxy->bind_proc & (1 << proc)) {
-						nbproc++;
-					}
-				}
-			} else {
-				nbproc = global.nbproc;
-			}
-			if (nbproc > 1) {
-				if (curproxy->uri_auth) {
-					Warning("Proxy '%s': in multi-process mode, stats will be limited to process assigned to the current request.\n",
-						curproxy->id);
-					if (!LIST_ISEMPTY(&curproxy->uri_auth->admin_rules)) {
-						Warning("Proxy '%s': stats admin will not work correctly in multi-process mode.\n",
-							curproxy->id);
-					}
-				}
-				if (curproxy->appsession_name) {
-					Warning("Proxy '%s': appsession will not work correctly in multi-process mode.\n",
-						curproxy->id);
-				}
-				if (!LIST_ISEMPTY(&curproxy->sticking_rules)) {
-					Warning("Proxy '%s': sticking rules will not work correctly in multi-process mode.\n",
-						curproxy->id);
-				}
-			}
-		}
-		curproxy = curproxy->next;
-	}
-
-	/* Check multi-process mode compatibility */
-	if (global.nbproc > 1) {
-		if (global.stats_fe) {
-			Warning("stats socket will not work correctly in multi-process mode (nbproc > 1).\n");
-		}
-	}
-
-	for (curuserlist = userlist; curuserlist; curuserlist = curuserlist->next) {
-		struct auth_users *curuser;
-		int g;
-
-		for (curuser = curuserlist->users; curuser; curuser = curuser->next) {
-			unsigned int group_mask = 0;
-			char *group = NULL;
-
-			if (!curuser->u.groups)
-				continue;
-
-			while ((group = strtok(group?NULL:curuser->u.groups, ","))) {
-
-				for (g = 0; g < curuserlist->grpcnt; g++)
-					if (!strcmp(curuserlist->groups[g], group))
-						break;
-
-				if (g == curuserlist->grpcnt) {
-					Alert("userlist '%s': no such group '%s' specified in user '%s'\n",
-					      curuserlist->name, group, curuser->user);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-
-				group_mask |= (1 << g);
-			}
-
-			free(curuser->u.groups);
-			curuser->u.group_mask = group_mask;
-		}
-
-		for (g = 0; g < curuserlist->grpcnt; g++) {
-			char *user = NULL;
-
-			if (!curuserlist->groupusers[g])
-				continue;
-
-			while ((user = strtok(user?NULL:curuserlist->groupusers[g], ","))) {
-				for (curuser = curuserlist->users; curuser; curuser = curuser->next)
-					if (!strcmp(curuser->user, user))
-						break;
-
-				if (!curuser) {
-					Alert("userlist '%s': no such user '%s' specified in group '%s'\n",
-					      curuserlist->name, user, curuserlist->groups[g]);
-					err_code |= ERR_ALERT | ERR_FATAL;
-					goto out;
-				}
-
-				curuser->u.group_mask |= (1 << g);
-			}
-
-			free(curuserlist->groupusers[g]);
-		}
-
-		free(curuserlist->groupusers);
-
-#ifdef DEBUG_AUTH
-		for (g = 0; g < curuserlist->grpcnt; g++) {
-			fprintf(stderr, "group %s, id %d, mask %08X, users:", curuserlist->groups[g], g , 1 << g);
-
-			for (curuser = curuserlist->users; curuser; curuser = curuser->next) {
-				if (curuser->group_mask & (1 << g))
-					fprintf(stderr, " %s", curuser->user);
-			}
-
-			fprintf(stderr, "\n");
-		}
-#endif
-
-	}
-
-	/*
-	 * Recount currently required checks.
-	 */
-
-	for (curproxy=proxy; curproxy; curproxy=curproxy->next) {
-		int optnum;
-
-		for (optnum = 0; cfg_opts[optnum].name; optnum++)
-			if (curproxy->options & cfg_opts[optnum].val)
-				global.last_checks |= cfg_opts[optnum].checks;
-
-		for (optnum = 0; cfg_opts2[optnum].name; optnum++)
-			if (curproxy->options2 & cfg_opts2[optnum].val)
-				global.last_checks |= cfg_opts2[optnum].checks;
-	}
-
-	if (cfgerr > 0)
-		err_code |= ERR_ALERT | ERR_FATAL;
- out:
-	return err_code;
-}
-
-/*
- * Registers the CFG keyword list <kwl> as a list of valid keywords for next
- * parsing sessions.
- */
-void cfg_register_keywords(struct cfg_kw_list *kwl)
-{
-	LIST_ADDQ(&cfg_keywords.list, &kwl->list);
-}
-
-/*
- * Unregisters the CFG keyword list <kwl> from the list of valid keywords.
- */
-void cfg_unregister_keywords(struct cfg_kw_list *kwl)
-{
-	LIST_DEL(&kwl->list);
-	LIST_INIT(&kwl->list);
-}
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/checks.c b/deps/haproxy-1.4.21/src/checks.c
deleted file mode 100644
index 7255817..0000000
--- a/deps/haproxy-1.4.21/src/checks.c
+++ /dev/null
@@ -1,1724 +0,0 @@
-/*
- * Health-checks functions.
- *
- * Copyright 2000-2009 Willy Tarreau <w@1wt.eu>
- * Copyright 2007-2009 Krzysztof Piotr Oledzki <ole@ans.pl>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <assert.h>
-#include <ctype.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <time.h>
-#include <unistd.h>
-#include <sys/socket.h>
-#include <sys/types.h>
-#include <netinet/in.h>
-#include <netinet/tcp.h>
-#include <arpa/inet.h>
-
-#include <common/compat.h>
-#include <common/config.h>
-#include <common/mini-clist.h>
-#include <common/standard.h>
-#include <common/time.h>
-
-#include <types/global.h>
-
-#include <proto/backend.h>
-#include <proto/checks.h>
-#include <proto/buffers.h>
-#include <proto/fd.h>
-#include <proto/log.h>
-#include <proto/queue.h>
-#include <proto/port_range.h>
-#include <proto/proto_http.h>
-#include <proto/proto_tcp.h>
-#include <proto/proxy.h>
-#include <proto/server.h>
-#include <proto/task.h>
-
-static int httpchk_expect(struct server *s, int done);
-
-const struct check_status check_statuses[HCHK_STATUS_SIZE] = {
-	[HCHK_STATUS_UNKNOWN]	= { SRV_CHK_UNKNOWN,                   "UNK",     "Unknown" },
-	[HCHK_STATUS_INI]	= { SRV_CHK_UNKNOWN,                   "INI",     "Initializing" },
-	[HCHK_STATUS_START]	= { /* SPECIAL STATUS*/ },
-
-	[HCHK_STATUS_HANA]	= { SRV_CHK_ERROR,                     "HANA",    "Health analyze" },
-
-	[HCHK_STATUS_SOCKERR]	= { SRV_CHK_ERROR,                     "SOCKERR", "Socket error" },
-
-	[HCHK_STATUS_L4OK]	= { SRV_CHK_RUNNING,                   "L4OK",    "Layer4 check passed" },
-	[HCHK_STATUS_L4TOUT]	= { SRV_CHK_ERROR,                     "L4TOUT",  "Layer4 timeout" },
-	[HCHK_STATUS_L4CON]	= { SRV_CHK_ERROR,                     "L4CON",   "Layer4 connection problem" },
-
-	[HCHK_STATUS_L6OK]	= { SRV_CHK_RUNNING,                   "L6OK",    "Layer6 check passed" },
-	[HCHK_STATUS_L6TOUT]	= { SRV_CHK_ERROR,                     "L6TOUT",  "Layer6 timeout" },
-	[HCHK_STATUS_L6RSP]	= { SRV_CHK_ERROR,                     "L6RSP",   "Layer6 invalid response" },
-
-	[HCHK_STATUS_L7TOUT]	= { SRV_CHK_ERROR,                     "L7TOUT",  "Layer7 timeout" },
-	[HCHK_STATUS_L7RSP]	= { SRV_CHK_ERROR,                     "L7RSP",   "Layer7 invalid response" },
-
-	[HCHK_STATUS_L57DATA]	= { /* DUMMY STATUS */ },
-
-	[HCHK_STATUS_L7OKD]	= { SRV_CHK_RUNNING,                   "L7OK",    "Layer7 check passed" },
-	[HCHK_STATUS_L7OKCD]	= { SRV_CHK_RUNNING | SRV_CHK_DISABLE, "L7OKC",   "Layer7 check conditionally passed" },
-	[HCHK_STATUS_L7STS]	= { SRV_CHK_ERROR,                     "L7STS",   "Layer7 wrong status" },
-};
-
-const struct analyze_status analyze_statuses[HANA_STATUS_SIZE] = {		/* 0: ignore, 1: error, 2: OK */
-	[HANA_STATUS_UNKNOWN]		= { "Unknown",                         { 0, 0 }},
-
-	[HANA_STATUS_L4_OK]		= { "L4 successful connection",        { 2, 0 }},
-	[HANA_STATUS_L4_ERR]		= { "L4 unsuccessful connection",      { 1, 1 }},
-
-	[HANA_STATUS_HTTP_OK]		= { "Correct http response",           { 0, 2 }},
-	[HANA_STATUS_HTTP_STS]		= { "Wrong http response",             { 0, 1 }},
-	[HANA_STATUS_HTTP_HDRRSP]	= { "Invalid http response (headers)", { 0, 1 }},
-	[HANA_STATUS_HTTP_RSP]		= { "Invalid http response",           { 0, 1 }},
-
-	[HANA_STATUS_HTTP_READ_ERROR]	= { "Read error (http)",               { 0, 1 }},
-	[HANA_STATUS_HTTP_READ_TIMEOUT]	= { "Read timeout (http)",             { 0, 1 }},
-	[HANA_STATUS_HTTP_BROKEN_PIPE]	= { "Close from server (http)",        { 0, 1 }},
-};
-
-/*
- * Convert check_status code to description
- */
-const char *get_check_status_description(short check_status) {
-
-	const char *desc;
-
-	if (check_status < HCHK_STATUS_SIZE)
-		desc = check_statuses[check_status].desc;
-	else
-		desc = NULL;
-
-	if (desc && *desc)
-		return desc;
-	else
-		return check_statuses[HCHK_STATUS_UNKNOWN].desc;
-}
-
-/*
- * Convert check_status code to short info
- */
-const char *get_check_status_info(short check_status) {
-
-	const char *info;
-
-	if (check_status < HCHK_STATUS_SIZE)
-		info = check_statuses[check_status].info;
-	else
-		info = NULL;
-
-	if (info && *info)
-		return info;
-	else
-		return check_statuses[HCHK_STATUS_UNKNOWN].info;
-}
-
-const char *get_analyze_status(short analyze_status) {
-
-	const char *desc;
-
-	if (analyze_status < HANA_STATUS_SIZE)
-		desc = analyze_statuses[analyze_status].desc;
-	else
-		desc = NULL;
-
-	if (desc && *desc)
-		return desc;
-	else
-		return analyze_statuses[HANA_STATUS_UNKNOWN].desc;
-}
-
-#define SSP_O_HCHK	0x0002
-
-static void server_status_printf(struct chunk *msg, struct server *s, unsigned options, int xferred) {
-
-	if (s->tracked)
-		chunk_printf(msg, " via %s/%s",
-			s->tracked->proxy->id, s->tracked->id);
-
-	if (options & SSP_O_HCHK) {
-		chunk_printf(msg, ", reason: %s", get_check_status_description(s->check_status));
-
-		if (s->check_status >= HCHK_STATUS_L57DATA)
-			chunk_printf(msg, ", code: %d", s->check_code);
-
-		if (*s->check_desc) {
-			struct chunk src;
-
-			chunk_printf(msg, ", info: \"");
-
-			chunk_initlen(&src, s->check_desc, 0, strlen(s->check_desc));
-			chunk_asciiencode(msg, &src, '"');
-
-			chunk_printf(msg, "\"");
-		}
-
-		if (s->check_duration >= 0)
-			chunk_printf(msg, ", check duration: %ldms", s->check_duration);
-	}
-
-	if (xferred >= 0) {
-		if (!(s->state & SRV_RUNNING))
-        	        chunk_printf(msg, ". %d active and %d backup servers left.%s"
-				" %d sessions active, %d requeued, %d remaining in queue",
-				s->proxy->srv_act, s->proxy->srv_bck,
-				(s->proxy->srv_bck && !s->proxy->srv_act) ? " Running on backup." : "",
-				s->cur_sess, xferred, s->nbpend);
-		else 
-			chunk_printf(msg, ". %d active and %d backup servers online.%s"
-				" %d sessions requeued, %d total in queue",
-				s->proxy->srv_act, s->proxy->srv_bck,
-				(s->proxy->srv_bck && !s->proxy->srv_act) ? " Running on backup." : "",
-				xferred, s->nbpend);
-	}
-}
-
-/*
- * Set s->check_status, update s->check_duration and fill s->result with
- * an adequate SRV_CHK_* value.
- *
- * Show information in logs about failed health check if server is UP
- * or succeeded health checks if server is DOWN.
- */
-static void set_server_check_status(struct server *s, short status, char *desc) {
-
-	struct chunk msg;
-
-	if (status == HCHK_STATUS_START) {
-		s->result = SRV_CHK_UNKNOWN;	/* no result yet */
-		s->check_desc[0] = '\0';
-		s->check_start = now;
-		return;
-	}
-
-	if (!s->check_status)
-		return;
-
-	if (desc && *desc) {
-		strncpy(s->check_desc, desc, HCHK_DESC_LEN-1);
-		s->check_desc[HCHK_DESC_LEN-1] = '\0';
-	} else
-		s->check_desc[0] = '\0';
-
-	s->check_status = status;
-	if (check_statuses[status].result)
-		s->result = check_statuses[status].result;
-
-	if (status == HCHK_STATUS_HANA)
-		s->check_duration = -1;
-	else if (!tv_iszero(&s->check_start)) {
-		/* set_server_check_status() may be called more than once */
-		s->check_duration = tv_ms_elapsed(&s->check_start, &now);
-		tv_zero(&s->check_start);
-	}
-
-	if (s->proxy->options2 & PR_O2_LOGHCHKS &&
-	(((s->health != 0) && (s->result & SRV_CHK_ERROR)) ||
-	    ((s->health != s->rise + s->fall - 1) && (s->result & SRV_CHK_RUNNING)) ||
-	    ((s->state & SRV_GOINGDOWN) && !(s->result & SRV_CHK_DISABLE)) ||
-	    (!(s->state & SRV_GOINGDOWN) && (s->result & SRV_CHK_DISABLE)))) {
-
-		int health, rise, fall, state;
-
-		chunk_init(&msg, trash, trashlen);
-
-		/* FIXME begin: calculate local version of the health/rise/fall/state */
-		health = s->health;
-		rise   = s->rise;
-		fall   = s->fall;
-		state  = s->state;
-
-		if (s->result & SRV_CHK_ERROR) {
-			if (health > rise) {
-				health--; /* still good */
-			} else {
-				if (health == rise)
-					state &= ~(SRV_RUNNING | SRV_GOINGDOWN);
-
-				health = 0;
-			}
-		}
-
-		if (s->result & SRV_CHK_RUNNING) {
-			if (health < rise + fall - 1) {
-				health++; /* was bad, stays for a while */
-
-				if (health == rise)
-					state |= SRV_RUNNING;
-
-				if (health >= rise)
-					health = rise + fall - 1; /* OK now */
-			}
-
-			/* clear consecutive_errors if observing is enabled */
-			if (s->onerror)
-				s->consecutive_errors = 0;
-		}
-		/* FIXME end: calculate local version of the health/rise/fall/state */
-
-		chunk_printf(&msg,
-			"Health check for %sserver %s/%s %s%s",
-			s->state & SRV_BACKUP ? "backup " : "",
-			s->proxy->id, s->id,
-			(s->result & SRV_CHK_DISABLE)?"conditionally ":"",
-			(s->result & SRV_CHK_RUNNING)?"succeeded":"failed");
-
-		server_status_printf(&msg, s, SSP_O_HCHK, -1);
-
-		chunk_printf(&msg, ", status: %d/%d %s",
-			(state & SRV_RUNNING) ? (health - rise + 1) : (health),
-			(state & SRV_RUNNING) ? (fall) : (rise),
-			(state & SRV_RUNNING)?"UP":"DOWN");
-
-		Warning("%s.\n", trash);
-		send_log(s->proxy, LOG_NOTICE, "%s.\n", trash);
-	}
-}
-
-/* sends a log message when a backend goes down, and also sets last
- * change date.
- */
-static void set_backend_down(struct proxy *be)
-{
-	be->last_change = now.tv_sec;
-	be->down_trans++;
-
-	Alert("%s '%s' has no server available!\n", proxy_type_str(be), be->id);
-	send_log(be, LOG_EMERG, "%s %s has no server available!\n", proxy_type_str(be), be->id);
-}
-
-/* Redistribute pending connections when a server goes down. The number of
- * connections redistributed is returned.
- */
-static int redistribute_pending(struct server *s)
-{
-	struct pendconn *pc, *pc_bck, *pc_end;
-	int xferred = 0;
-
-	FOREACH_ITEM_SAFE(pc, pc_bck, &s->pendconns, pc_end, struct pendconn *, list) {
-		struct session *sess = pc->sess;
-		if ((sess->be->options & (PR_O_REDISP|PR_O_PERSIST)) == PR_O_REDISP &&
-		    !(sess->flags & SN_FORCE_PRST)) {
-			/* The REDISP option was specified. We will ignore
-			 * cookie and force to balance or use the dispatcher.
-			 */
-
-			/* it's left to the dispatcher to choose a server */
-			sess->flags &= ~(SN_DIRECT | SN_ASSIGNED | SN_ADDR_SET);
-
-			pendconn_free(pc);
-			task_wakeup(sess->task, TASK_WOKEN_RES);
-			xferred++;
-		}
-	}
-	return xferred;
-}
-
-/* Check for pending connections at the backend, and assign some of them to
- * the server coming up. The server's weight is checked before being assigned
- * connections it may not be able to handle. The total number of transferred
- * connections is returned.
- */
-static int check_for_pending(struct server *s)
-{
-	int xferred;
-
-	if (!s->eweight)
-		return 0;
-
-	for (xferred = 0; !s->maxconn || xferred < srv_dynamic_maxconn(s); xferred++) {
-		struct session *sess;
-		struct pendconn *p;
-
-		p = pendconn_from_px(s->proxy);
-		if (!p)
-			break;
-		p->sess->srv = s;
-		sess = p->sess;
-		pendconn_free(p);
-		task_wakeup(sess->task, TASK_WOKEN_RES);
-	}
-	return xferred;
-}
-
-/* Sets server <s> down, notifies by all available means, recounts the
- * remaining servers on the proxy and transfers queued sessions whenever
- * possible to other servers. It automatically recomputes the number of
- * servers, but not the map.
- */
-void set_server_down(struct server *s)
-{
-	struct server *srv;
-	struct chunk msg;
-	int xferred;
-
-	if (s->state & SRV_MAINTAIN) {
-		s->health = s->rise;
-	}
-
-	if (s->health == s->rise || s->tracked) {
-		int srv_was_paused = s->state & SRV_GOINGDOWN;
-		int prev_srv_count = s->proxy->srv_bck + s->proxy->srv_act;
-
-		s->last_change = now.tv_sec;
-		s->state &= ~(SRV_RUNNING | SRV_GOINGDOWN);
-		if (s->proxy->lbprm.set_server_status_down)
-			s->proxy->lbprm.set_server_status_down(s);
-
-		/* we might have sessions queued on this server and waiting for
-		 * a connection. Those which are redispatchable will be queued
-		 * to another server or to the proxy itself.
-		 */
-		xferred = redistribute_pending(s);
-
-		chunk_init(&msg, trash, trashlen);
-
-		if (s->state & SRV_MAINTAIN) {
-			chunk_printf(&msg,
-				"%sServer %s/%s is DOWN for maintenance", s->state & SRV_BACKUP ? "Backup " : "",
-				s->proxy->id, s->id);
-		} else {
-			chunk_printf(&msg,
-				"%sServer %s/%s is DOWN", s->state & SRV_BACKUP ? "Backup " : "",
-				s->proxy->id, s->id);
-
-			server_status_printf(&msg, s,
-						((!s->tracked && !(s->proxy->options2 & PR_O2_LOGHCHKS))?SSP_O_HCHK:0),
-						xferred);
-		}
-		Warning("%s.\n", trash);
-
-		/* we don't send an alert if the server was previously paused */
-		if (srv_was_paused)
-			send_log(s->proxy, LOG_NOTICE, "%s.\n", trash);
-		else
-			send_log(s->proxy, LOG_ALERT, "%s.\n", trash);
-
-		if (prev_srv_count && s->proxy->srv_bck == 0 && s->proxy->srv_act == 0)
-			set_backend_down(s->proxy);
-
-		s->counters.down_trans++;
-
-		if (s->state & SRV_CHECKED)
-			for(srv = s->tracknext; srv; srv = srv->tracknext)
-				if (! (srv->state & SRV_MAINTAIN))
-					/* Only notify tracking servers that are not already in maintenance. */
-					set_server_down(srv);
-	}
-
-	s->health = 0; /* failure */
-}
-
-void set_server_up(struct server *s) {
-
-	struct server *srv;
-	struct chunk msg;
-	int xferred;
-	unsigned int old_state = s->state;
-
-	if (s->state & SRV_MAINTAIN) {
-		s->health = s->rise;
-	}
-
-	if (s->health == s->rise || s->tracked) {
-		if (s->proxy->srv_bck == 0 && s->proxy->srv_act == 0) {
-			if (s->proxy->last_change < now.tv_sec)		// ignore negative times
-				s->proxy->down_time += now.tv_sec - s->proxy->last_change;
-			s->proxy->last_change = now.tv_sec;
-		}
-
-		if (s->last_change < now.tv_sec)			// ignore negative times
-			s->down_time += now.tv_sec - s->last_change;
-
-		s->last_change = now.tv_sec;
-		s->state |= SRV_RUNNING;
-		s->state &= ~SRV_MAINTAIN;
-
-		if (s->slowstart > 0) {
-			s->state |= SRV_WARMINGUP;
-			if (s->proxy->lbprm.algo & BE_LB_PROP_DYN) {
-				/* For dynamic algorithms, start at the first step of the weight,
-				 * without multiplying by BE_WEIGHT_SCALE.
-				 */
-				s->eweight = s->uweight;
-				if (s->proxy->lbprm.update_server_eweight)
-					s->proxy->lbprm.update_server_eweight(s);
-			}
-			task_schedule(s->warmup, tick_add(now_ms, MS_TO_TICKS(MAX(1000, s->slowstart / 20))));
-		}
-		if (s->proxy->lbprm.set_server_status_up)
-			s->proxy->lbprm.set_server_status_up(s);
-
-		/* check if we can handle some connections queued at the proxy. We
-		 * will take as many as we can handle.
-		 */
-		xferred = check_for_pending(s);
-
-		chunk_init(&msg, trash, trashlen);
-
-		if (old_state & SRV_MAINTAIN) {
-			chunk_printf(&msg,
-				"%sServer %s/%s is UP (leaving maintenance)", s->state & SRV_BACKUP ? "Backup " : "",
-				s->proxy->id, s->id);
-		} else {
-			chunk_printf(&msg,
-				"%sServer %s/%s is UP", s->state & SRV_BACKUP ? "Backup " : "",
-				s->proxy->id, s->id);
-
-			server_status_printf(&msg, s,
-						((!s->tracked && !(s->proxy->options2 & PR_O2_LOGHCHKS))?SSP_O_HCHK:0),
-						xferred);
-		}
-
-		Warning("%s.\n", trash);
-		send_log(s->proxy, LOG_NOTICE, "%s.\n", trash);
-
-		if (s->state & SRV_CHECKED)
-			for(srv = s->tracknext; srv; srv = srv->tracknext)
-				if (! (srv->state & SRV_MAINTAIN))
-					/* Only notify tracking servers if they're not in maintenance. */
-					set_server_up(srv);
-	}
-
-	if (s->health >= s->rise)
-		s->health = s->rise + s->fall - 1; /* OK now */
-
-}
-
-static void set_server_disabled(struct server *s) {
-
-	struct server *srv;
-	struct chunk msg;
-	int xferred;
-
-	s->state |= SRV_GOINGDOWN;
-	if (s->proxy->lbprm.set_server_status_down)
-		s->proxy->lbprm.set_server_status_down(s);
-
-	/* we might have sessions queued on this server and waiting for
-	 * a connection. Those which are redispatchable will be queued
-	 * to another server or to the proxy itself.
-	 */
-	xferred = redistribute_pending(s);
-
-	chunk_init(&msg, trash, trashlen);
-
-	chunk_printf(&msg,
-		"Load-balancing on %sServer %s/%s is disabled",
-		s->state & SRV_BACKUP ? "Backup " : "",
-		s->proxy->id, s->id);
-
-	server_status_printf(&msg, s,
-				((!s->tracked && !(s->proxy->options2 & PR_O2_LOGHCHKS))?SSP_O_HCHK:0),
-				xferred);
-
-	Warning("%s.\n", trash);
-	send_log(s->proxy, LOG_NOTICE, "%s.\n", trash);
-
-	if (!s->proxy->srv_bck && !s->proxy->srv_act)
-		set_backend_down(s->proxy);
-
-	if (s->state & SRV_CHECKED)
-		for(srv = s->tracknext; srv; srv = srv->tracknext)
-			set_server_disabled(srv);
-}
-
-static void set_server_enabled(struct server *s) {
-
-	struct server *srv;
-	struct chunk msg;
-	int xferred;
-
-	s->state &= ~SRV_GOINGDOWN;
-	if (s->proxy->lbprm.set_server_status_up)
-		s->proxy->lbprm.set_server_status_up(s);
-
-	/* check if we can handle some connections queued at the proxy. We
-	 * will take as many as we can handle.
-	 */
-	xferred = check_for_pending(s);
-
-	chunk_init(&msg, trash, trashlen);
-
-	chunk_printf(&msg,
-		"Load-balancing on %sServer %s/%s is enabled again",
-		s->state & SRV_BACKUP ? "Backup " : "",
-		s->proxy->id, s->id);
-
-	server_status_printf(&msg, s,
-				((!s->tracked && !(s->proxy->options2 & PR_O2_LOGHCHKS))?SSP_O_HCHK:0),
-				xferred);
-
-	Warning("%s.\n", trash);
-	send_log(s->proxy, LOG_NOTICE, "%s.\n", trash);
-
-	if (s->state & SRV_CHECKED)
-		for(srv = s->tracknext; srv; srv = srv->tracknext)
-			set_server_enabled(srv);
-}
-
-void health_adjust(struct server *s, short status) {
-
-	int failed;
-	int expire;
-
-	/* return now if observing nor health check is not enabled */
-	if (!s->observe || !s->check)
-		return;
-
-	if (s->observe >= HANA_OBS_SIZE)
-		return;
-
-	if (status >= HCHK_STATUS_SIZE || !analyze_statuses[status].desc)
-		return;
-
-	switch (analyze_statuses[status].lr[s->observe - 1]) {
-		case 1:
-			failed = 1;
-			break;
-
-		case 2:
-			failed = 0;
-			break;
-
-		default:
-			return;
-	}
-
-	if (!failed) {
-		/* good: clear consecutive_errors */
-		s->consecutive_errors = 0;
-		return;
-	}
-
-	s->consecutive_errors++;
-
-	if (s->consecutive_errors < s->consecutive_errors_limit)
-		return;
-
-	sprintf(trash, "Detected %d consecutive errors, last one was: %s",
-		s->consecutive_errors, get_analyze_status(status));
-
-	switch (s->onerror) {
-		case HANA_ONERR_FASTINTER:
-		/* force fastinter - nothing to do here as all modes force it */
-			break;
-
-		case HANA_ONERR_SUDDTH:
-		/* simulate a pre-fatal failed health check */
-			if (s->health > s->rise)
-				s->health = s->rise + 1;
-
-			/* no break - fall through */
-
-		case HANA_ONERR_FAILCHK:
-		/* simulate a failed health check */
-			set_server_check_status(s, HCHK_STATUS_HANA, trash);
-
-			if (s->health > s->rise) {
-				s->health--; /* still good */
-				s->counters.failed_checks++;
-			}
-			else
-				set_server_down(s);
-
-			break;
-
-		case HANA_ONERR_MARKDWN:
-		/* mark server down */
-			s->health = s->rise;
-			set_server_check_status(s, HCHK_STATUS_HANA, trash);
-			set_server_down(s);
-
-			break;
-
-		default:
-			/* write a warning? */
-			break;
-	}
-
-	s->consecutive_errors = 0;
-	s->counters.failed_hana++;
-
-	if (s->fastinter) {
-		expire = tick_add(now_ms, MS_TO_TICKS(s->fastinter));
-		if (s->check->expire > expire)
-			s->check->expire = expire;
-	}
-}
-
-static int httpchk_build_status_header(struct server *s, char *buffer)
-{
-	int sv_state;
-	int ratio;
-	int hlen = 0;
-	const char *srv_hlt_st[7] = { "DOWN", "DOWN %d/%d",
-				      "UP %d/%d", "UP",
-				      "NOLB %d/%d", "NOLB",
-				      "no check" };
-
-	memcpy(buffer + hlen, "X-Haproxy-Server-State: ", 24);
-	hlen += 24;
-
-	if (!(s->state & SRV_CHECKED))
-		sv_state = 6; /* should obviously never happen */
-	else if (s->state & SRV_RUNNING) {
-		if (s->health == s->rise + s->fall - 1)
-			sv_state = 3; /* UP */
-		else
-			sv_state = 2; /* going down */
-
-		if (s->state & SRV_GOINGDOWN)
-			sv_state += 2;
-	} else {
-		if (s->health)
-			sv_state = 1; /* going up */
-		else
-			sv_state = 0; /* DOWN */
-	}
-
-	hlen += sprintf(buffer + hlen,
-			     srv_hlt_st[sv_state],
-			     (s->state & SRV_RUNNING) ? (s->health - s->rise + 1) : (s->health),
-			     (s->state & SRV_RUNNING) ? (s->fall) : (s->rise));
-
-	hlen += sprintf(buffer + hlen, "; name=%s/%s; node=%s; weight=%d/%d; scur=%d/%d; qcur=%d",
-			     s->proxy->id, s->id,
-			     global.node,
-			     (s->eweight * s->proxy->lbprm.wmult + s->proxy->lbprm.wdiv - 1) / s->proxy->lbprm.wdiv,
-			     (s->proxy->lbprm.tot_weight * s->proxy->lbprm.wmult + s->proxy->lbprm.wdiv - 1) / s->proxy->lbprm.wdiv,
-			     s->cur_sess, s->proxy->beconn - s->proxy->nbpend,
-			     s->nbpend);
-
-	if ((s->state & SRV_WARMINGUP) &&
-	    now.tv_sec < s->last_change + s->slowstart &&
-	    now.tv_sec >= s->last_change) {
-		ratio = MAX(1, 100 * (now.tv_sec - s->last_change) / s->slowstart);
-		hlen += sprintf(buffer + hlen, "; throttle=%d%%", ratio);
-	}
-
-	buffer[hlen++] = '\r';
-	buffer[hlen++] = '\n';
-
-	return hlen;
-}
-
-/*
- * This function is used only for server health-checks. It handles
- * the connection acknowledgement. If the proxy requires L7 health-checks,
- * it sends the request. In other cases, it calls set_server_check_status()
- * to set s->check_status, s->check_duration and s->result.
- * The function itself returns 0 if it needs some polling before being called
- * again, otherwise 1.
- */
-static int event_srv_chk_w(int fd)
-{
-	__label__ out_wakeup, out_nowake, out_poll, out_error;
-	struct task *t = fdtab[fd].owner;
-	struct server *s = t->context;
-
-	//fprintf(stderr, "event_srv_chk_w, state=%ld\n", unlikely(fdtab[fd].state));
-	if (unlikely(fdtab[fd].state == FD_STERROR || (fdtab[fd].ev & FD_POLL_ERR))) {
-		int skerr, err = errno;
-		socklen_t lskerr = sizeof(skerr);
-
-		if (!getsockopt(fd, SOL_SOCKET, SO_ERROR, &skerr, &lskerr) && skerr)
-			err = skerr;
-
-		set_server_check_status(s, HCHK_STATUS_L4CON, strerror(err));
-		goto out_error;
-	}
-
-	/* here, we know that the connection is established */
-
-	if (!(s->result & SRV_CHK_ERROR)) {
-		/* we don't want to mark 'UP' a server on which we detected an error earlier */
-		if ((s->proxy->options & PR_O_HTTP_CHK) ||
-		    (s->proxy->options & PR_O_SMTP_CHK) ||
-		    (s->proxy->options2 & PR_O2_SSL3_CHK) ||
-		    (s->proxy->options2 & PR_O2_MYSQL_CHK) ||
-		    (s->proxy->options2 & PR_O2_LDAP_CHK)) {
-			int ret;
-			const char *check_req = s->proxy->check_req;
-			int check_len = s->proxy->check_len;
-
-			/* we want to check if this host replies to HTTP or SSLv3 requests
-			 * so we'll send the request, and won't wake the checker up now.
-			 */
-
-			if (s->proxy->options2 & PR_O2_SSL3_CHK) {
-				/* SSL requires that we put Unix time in the request */
-				int gmt_time = htonl(date.tv_sec);
-				memcpy(s->proxy->check_req + 11, &gmt_time, 4);
-			}
-			else if (s->proxy->options & PR_O_HTTP_CHK) {
-				memcpy(trash, check_req, check_len);
-
-				if (s->proxy->options2 & PR_O2_CHK_SNDST)
-					check_len += httpchk_build_status_header(s, trash + check_len);
-
-				trash[check_len++] = '\r';
-				trash[check_len++] = '\n';
-				trash[check_len] = '\0';
-				check_req = trash;
-			}
-
-			ret = send(fd, check_req, check_len, MSG_DONTWAIT | MSG_NOSIGNAL);
-			if (ret == check_len) {
-				/* we allow up to <timeout.check> if nonzero for a responce */
-				if (s->proxy->timeout.check)
-					t->expire = tick_add_ifset(now_ms, s->proxy->timeout.check);
-				EV_FD_SET(fd, DIR_RD);   /* prepare for reading reply */
-				goto out_nowake;
-			}
-			else if (ret == 0 || errno == EAGAIN)
-				goto out_poll;
-			else {
-				switch (errno) {
-					case ECONNREFUSED:
-					case ENETUNREACH:
-						set_server_check_status(s, HCHK_STATUS_L4CON, strerror(errno));
-						break;
-
-					default:
-						set_server_check_status(s, HCHK_STATUS_SOCKERR, strerror(errno));
-				}
-
-				goto out_error;
-			}
-		}
-		else {
-			/* We have no data to send to check the connection, and
-			 * getsockopt() will not inform us whether the connection
-			 * is still pending. So we'll reuse connect() to check the
-			 * state of the socket. This has the advantage of givig us
-			 * the following info :
-			 *  - error
-			 *  - connecting (EALREADY, EINPROGRESS)
-			 *  - connected (EISCONN, 0)
-			 */
-
-			struct sockaddr_in sa;
-
-			sa = (s->check_addr.sin_addr.s_addr) ? s->check_addr : s->addr;
-			sa.sin_port = htons(s->check_port);
-
-			if (connect(fd, (struct sockaddr *)&sa, sizeof(sa)) == 0)
-				errno = 0;
-
-			if (errno == EALREADY || errno == EINPROGRESS)
-				goto out_poll;
-
-			if (errno && errno != EISCONN) {
-				set_server_check_status(s, HCHK_STATUS_L4CON, strerror(errno));
-				goto out_error;
-			}
-
-			/* good TCP connection is enough */
-			set_server_check_status(s, HCHK_STATUS_L4OK, NULL);
-			goto out_wakeup;
-		}
-	}
- out_wakeup:
-	task_wakeup(t, TASK_WOKEN_IO);
- out_nowake:
-	EV_FD_CLR(fd, DIR_WR);   /* nothing more to write */
-	fdtab[fd].ev &= ~FD_POLL_OUT;
-	return 1;
- out_poll:
-	/* The connection is still pending. We'll have to poll it
-	 * before attempting to go further. */
-	fdtab[fd].ev &= ~FD_POLL_OUT;
-	return 0;
- out_error:
-	fdtab[fd].state = FD_STERROR;
-	goto out_wakeup;
-}
-
-
-/*
- * This function is used only for server health-checks. It handles the server's
- * reply to an HTTP request, SSL HELLO or MySQL client Auth. It calls
- * set_server_check_status() to update s->check_status, s->check_duration
- * and s->result.
-
- * The set_server_check_status function is called with HCHK_STATUS_L7OKD if
- * an HTTP server replies HTTP 2xx or 3xx (valid responses), if an SMTP server
- * returns 2xx, HCHK_STATUS_L6OK if an SSL server returns at least 5 bytes in
- * response to an SSL HELLO (the principle is that this is enough to
- * distinguish between an SSL server and a pure TCP relay). All other cases will
- * call it with a proper error status like HCHK_STATUS_L7STS, HCHK_STATUS_L6RSP,
- * etc.
- *
- * The function returns 0 if it needs to be called again after some polling,
- * otherwise non-zero..
- */
-static int event_srv_chk_r(int fd)
-{
-	__label__ out_wakeup;
-	int len;
-	struct task *t = fdtab[fd].owner;
-	struct server *s = t->context;
-	char *desc;
-	int done;
-	unsigned short msglen;
-
-	if (unlikely((s->result & SRV_CHK_ERROR) || (fdtab[fd].state == FD_STERROR))) {
-		/* in case of TCP only, this tells us if the connection failed */
-		if (!(s->result & SRV_CHK_ERROR))
-			set_server_check_status(s, HCHK_STATUS_SOCKERR, NULL);
-
-		goto out_wakeup;
-	}
-
-	/* Warning! Linux returns EAGAIN on SO_ERROR if data are still available
-	 * but the connection was closed on the remote end. Fortunately, recv still
-	 * works correctly and we don't need to do the getsockopt() on linux.
-	 */
-
-	/* Set buffer to point to the end of the data already read, and check
-	 * that there is free space remaining. If the buffer is full, proceed
-	 * with running the checks without attempting another socket read.
-	 */
-
-	done = 0;
-	for (len = 0; s->check_data_len < global.tune.chksize; s->check_data_len += len) {
-		len = recv(fd, s->check_data + s->check_data_len, global.tune.chksize - s->check_data_len, 0);
-		if (len <= 0)
-			break;
-	}
-
-	if (len == 0)
-		done = 1; /* connection hangup received */
-	else if (len < 0 && errno != EAGAIN) {
-		/* Report network errors only if we got no other data. Otherwise
-		 * we'll let the upper layers decide whether the response is OK
-		 * or not. It is very common that an RST sent by the server is
-		 * reported as an error just after the last data chunk.
-		 */
-		done = 1;
-		if (!s->check_data_len) {
-			if (!(s->result & SRV_CHK_ERROR))
-				set_server_check_status(s, HCHK_STATUS_SOCKERR, NULL);
-			goto out_wakeup;
-		}
-	}
-
-	/* Intermediate or complete response received.
-	 * Terminate string in check_data buffer.
-	 */
-	if (s->check_data_len < global.tune.chksize)
-		s->check_data[s->check_data_len] = '\0';
-	else {
-		s->check_data[s->check_data_len - 1] = '\0';
-		done = 1; /* buffer full, don't wait for more data */
-	}
-
-	/* Run the checks... */
-	if (s->proxy->options & PR_O_HTTP_CHK) {
-		if (!done && s->check_data_len < strlen("HTTP/1.0 000\r"))
-			goto wait_more_data;
-
-		/* Check if the server speaks HTTP 1.X */
-		if ((s->check_data_len < strlen("HTTP/1.0 000\r")) ||
-		    (memcmp(s->check_data, "HTTP/1.", 7) != 0 ||
-		    (*(s->check_data + 12) != ' ' && *(s->check_data + 12) != '\r')) ||
-		    !isdigit((unsigned char) *(s->check_data + 9)) || !isdigit((unsigned char) *(s->check_data + 10)) ||
-		    !isdigit((unsigned char) *(s->check_data + 11))) {
-			cut_crlf(s->check_data);
-			set_server_check_status(s, HCHK_STATUS_L7RSP, s->check_data);
-
-			goto out_wakeup;
-		}
-
-		s->check_code = str2uic(s->check_data + 9);
-		desc = ltrim(s->check_data + 12, ' ');
-		
-		if ((s->proxy->options & PR_O_DISABLE404) &&
-			 (s->state & SRV_RUNNING) && (s->check_code == 404)) {
-			/* 404 may be accepted as "stopping" only if the server was up */
-			cut_crlf(desc);
-			set_server_check_status(s, HCHK_STATUS_L7OKCD, desc);
-		}
-		else if (s->proxy->options2 & PR_O2_EXP_TYPE) {
-			/* Run content verification check... We know we have at least 13 chars */
-			if (!httpchk_expect(s, done))
-				goto wait_more_data;
-		}
-		/* check the reply : HTTP/1.X 2xx and 3xx are OK */
-		else if (*(s->check_data + 9) == '2' || *(s->check_data + 9) == '3') {
-			cut_crlf(desc);
-			set_server_check_status(s, HCHK_STATUS_L7OKD, desc);
-		}
-		else {
-			cut_crlf(desc);
-			set_server_check_status(s, HCHK_STATUS_L7STS, desc);
-		}
-	}
-	else if (s->proxy->options2 & PR_O2_SSL3_CHK) {
-		if (!done && s->check_data_len < 5)
-			goto wait_more_data;
-
-		/* Check for SSLv3 alert or handshake */
-		if ((s->check_data_len >= 5) && (*s->check_data == 0x15 || *s->check_data == 0x16))
-			set_server_check_status(s, HCHK_STATUS_L6OK, NULL);
-		else
-			set_server_check_status(s, HCHK_STATUS_L6RSP, NULL);
-	}
-	else if (s->proxy->options & PR_O_SMTP_CHK) {
-		if (!done && s->check_data_len < strlen("000\r"))
-			goto wait_more_data;
-
-		/* Check if the server speaks SMTP */
-		if ((s->check_data_len < strlen("000\r")) ||
-		    (*(s->check_data + 3) != ' ' && *(s->check_data + 3) != '\r') ||
-		    !isdigit((unsigned char) *s->check_data) || !isdigit((unsigned char) *(s->check_data + 1)) ||
-		    !isdigit((unsigned char) *(s->check_data + 2))) {
-			cut_crlf(s->check_data);
-			set_server_check_status(s, HCHK_STATUS_L7RSP, s->check_data);
-
-			goto out_wakeup;
-		}
-
-		s->check_code = str2uic(s->check_data);
-
-		desc = ltrim(s->check_data + 3, ' ');
-		cut_crlf(desc);
-
-		/* Check for SMTP code 2xx (should be 250) */
-		if (*s->check_data == '2')
-			set_server_check_status(s, HCHK_STATUS_L7OKD, desc);
-		else
-			set_server_check_status(s, HCHK_STATUS_L7STS, desc);
-	}
-	else if (s->proxy->options2 & PR_O2_MYSQL_CHK) {
-		if (!done && s->check_data_len < 5)
-			goto wait_more_data;
-
-		if (s->proxy->check_len == 0) { // old mode
-			if (*(s->check_data + 4) != '\xff') {
-				/* We set the MySQL Version in description for information purpose
-				 * FIXME : it can be cool to use MySQL Version for other purpose,
-				 * like mark as down old MySQL server.
-				 */
-				if (s->check_data_len > 51) {
-					desc = ltrim(s->check_data + 5, ' ');
-					set_server_check_status(s, HCHK_STATUS_L7OKD, desc);
-				}
-				else {
-					if (!done)
-						goto wait_more_data;
-					/* it seems we have a OK packet but without a valid length,
-					 * it must be a protocol error
-					 */
-					set_server_check_status(s, HCHK_STATUS_L7RSP, s->check_data);
-				}
-			}
-			else {
-				/* An error message is attached in the Error packet */
-				desc = ltrim(s->check_data + 7, ' ');
-				set_server_check_status(s, HCHK_STATUS_L7STS, desc);
-			}
-		} else {
-			unsigned int first_packet_len = ((unsigned int) *s->check_data) +
-			                                (((unsigned int) *(s->check_data + 1)) << 8) +
-			                                (((unsigned int) *(s->check_data + 2)) << 16);
-
-			if (s->check_data_len == first_packet_len + 4) {
-				/* MySQL Error packet always begin with field_count = 0xff */
-				if (*(s->check_data + 4) != '\xff') {
-					/* We have only one MySQL packet and it is a Handshake Initialization packet
-					* but we need to have a second packet to know if it is alright
-					*/
-					if (!done && s->check_data_len < first_packet_len + 5)
-						goto wait_more_data;
-				}
-				else {
-					/* We have only one packet and it is an Error packet,
-					* an error message is attached, so we can display it
-					*/
-					desc = &s->check_data[7];
-					//Warning("onlyoneERR: %s\n", desc);
-					set_server_check_status(s, HCHK_STATUS_L7STS, desc);
-				}
-			} else if (s->check_data_len > first_packet_len + 4) {
-				unsigned int second_packet_len = ((unsigned int) *(s->check_data + first_packet_len + 4)) +
-				                                 (((unsigned int) *(s->check_data + first_packet_len + 5)) << 8) +
-				                                 (((unsigned int) *(s->check_data + first_packet_len + 6)) << 16);
-
-				if (s->check_data_len == first_packet_len + 4 + second_packet_len + 4 ) {
-					/* We have 2 packets and that's good */
-					/* Check if the second packet is a MySQL Error packet or not */
-					if (*(s->check_data + first_packet_len + 8) != '\xff') {
-						/* No error packet */
-						/* We set the MySQL Version in description for information purpose */
-						desc = &s->check_data[5];
-						//Warning("2packetOK: %s\n", desc);
-						set_server_check_status(s, HCHK_STATUS_L7OKD, desc);
-					}
-					else {
-						/* An error message is attached in the Error packet
-						* so we can display it ! :)
-						*/
-						desc = &s->check_data[first_packet_len+11];
-						//Warning("2packetERR: %s\n", desc);
-						set_server_check_status(s, HCHK_STATUS_L7STS, desc);
-					}
-				}
-			}
-			else {
-				if (!done)
-					goto wait_more_data;
-				/* it seems we have a Handshake Initialization packet but without a valid length,
-				 * it must be a protocol error
-				 */
-				desc = &s->check_data[5];
-				//Warning("protoerr: %s\n", desc);
-				set_server_check_status(s, HCHK_STATUS_L7RSP, desc);
-			}
-		}
-	}
-	else if (s->proxy->options2 & PR_O2_LDAP_CHK) {
-		if (!done && s->check_data_len < 14)
-			goto wait_more_data;
-
-		/* Check if the server speaks LDAP (ASN.1/BER)
-		 * http://en.wikipedia.org/wiki/Basic_Encoding_Rules
-		 * http://tools.ietf.org/html/rfc4511
-		 */
-
-		/* http://tools.ietf.org/html/rfc4511#section-4.1.1
-		 *   LDAPMessage: 0x30: SEQUENCE
-		 */
-		if ((s->check_data_len < 14) || (*(s->check_data) != '\x30')) {
-			set_server_check_status(s, HCHK_STATUS_L7RSP, "Not LDAPv3 protocol");
-		}
-		else {
-			 /* size of LDAPMessage */
-			msglen = (*(s->check_data + 1) & 0x80) ? (*(s->check_data + 1) & 0x7f) : 0;
-
-			/* http://tools.ietf.org/html/rfc4511#section-4.2.2
-			 *   messageID: 0x02 0x01 0x01: INTEGER 1
-			 *   protocolOp: 0x61: bindResponse
-			 */
-			if ((msglen > 2) ||
-			    (memcmp(s->check_data + 2 + msglen, "\x02\x01\x01\x61", 4) != 0)) {
-				set_server_check_status(s, HCHK_STATUS_L7RSP, "Not LDAPv3 protocol");
-
-				goto out_wakeup;
-			}
-
-			/* size of bindResponse */
-			msglen += (*(s->check_data + msglen + 6) & 0x80) ? (*(s->check_data + msglen + 6) & 0x7f) : 0;
-
-			/* http://tools.ietf.org/html/rfc4511#section-4.1.9
-			 *   ldapResult: 0x0a 0x01: ENUMERATION
-			 */
-			if ((msglen > 4) ||
-			    (memcmp(s->check_data + 7 + msglen, "\x0a\x01", 2) != 0)) {
-				set_server_check_status(s, HCHK_STATUS_L7RSP, "Not LDAPv3 protocol");
-
-				goto out_wakeup;
-			}
-
-			/* http://tools.ietf.org/html/rfc4511#section-4.1.9
-			 *   resultCode
-			 */
-			s->check_code = *(s->check_data + msglen + 9);
-			if (s->check_code) {
-				set_server_check_status(s, HCHK_STATUS_L7STS, "See RFC: http://tools.ietf.org/html/rfc4511#section-4.1.9");
-			} else {
-				set_server_check_status(s, HCHK_STATUS_L7OKD, "Success");
-			}
-		}
-	}
-	else {
-		/* other checks are valid if the connection succeeded anyway */
-		set_server_check_status(s, HCHK_STATUS_L4OK, NULL);
-	}
-
- out_wakeup:
-	if (s->result & SRV_CHK_ERROR)
-		fdtab[fd].state = FD_STERROR;
-
-	/* Reset the check buffer... */
-	*s->check_data = '\0';
-	s->check_data_len = 0;
-
-	/* Close the connection... */
-	shutdown(fd, SHUT_RDWR);
-	EV_FD_CLR(fd, DIR_RD);
-	task_wakeup(t, TASK_WOKEN_IO);
-	fdtab[fd].ev &= ~FD_POLL_IN;
-	return 1;
-
- wait_more_data:
-	fdtab[fd].ev &= ~FD_POLL_IN;
-	return 0;
-}
-
-/*
- * updates the server's weight during a warmup stage. Once the final weight is
- * reached, the task automatically stops. Note that any server status change
- * must have updated s->last_change accordingly.
- */
-static struct task *server_warmup(struct task *t)
-{
-	struct server *s = t->context;
-
-	/* by default, plan on stopping the task */
-	t->expire = TICK_ETERNITY;
-	if ((s->state & (SRV_RUNNING|SRV_WARMINGUP|SRV_MAINTAIN)) != (SRV_RUNNING|SRV_WARMINGUP))
-		return t;
-
-	if (now.tv_sec < s->last_change || now.tv_sec >= s->last_change + s->slowstart) {
-		/* go to full throttle if the slowstart interval is reached */
-		s->state &= ~SRV_WARMINGUP;
-		if (s->proxy->lbprm.algo & BE_LB_PROP_DYN)
-			s->eweight = s->uweight * BE_WEIGHT_SCALE;
-		if (s->proxy->lbprm.update_server_eweight)
-			s->proxy->lbprm.update_server_eweight(s);
-	}
-	else if (s->proxy->lbprm.algo & BE_LB_PROP_DYN) {
-		/* for dynamic algorithms, let's slowly update the weight */
-		s->eweight = (BE_WEIGHT_SCALE * (now.tv_sec - s->last_change) +
-			      s->slowstart - 1) / s->slowstart;
-		s->eweight *= s->uweight;
-		if (s->proxy->lbprm.update_server_eweight)
-			s->proxy->lbprm.update_server_eweight(s);
-	}
-	/* Note that static algorithms are already running at full throttle */
-
-	/* probably that we can refill this server with a bit more connections */
-	check_for_pending(s);
-
-	/* get back there in 1 second or 1/20th of the slowstart interval,
-	 * whichever is greater, resulting in small 5% steps.
-	 */
-	if (s->state & SRV_WARMINGUP)
-		t->expire = tick_add(now_ms, MS_TO_TICKS(MAX(1000, s->slowstart / 20)));
-	return t;
-}
-
-/*
- * manages a server health-check. Returns
- * the time the task accepts to wait, or TIME_ETERNITY for infinity.
- */
-struct task *process_chk(struct task *t)
-{
-	int attempts = 0;
-	struct server *s = t->context;
-	struct sockaddr_in sa;
-	int fd;
-	int rv;
-
- new_chk:
-	if (attempts++ > 0) {
-		/* we always fail to create a server, let's stop insisting... */
-		while (tick_is_expired(t->expire, now_ms))
-			t->expire = tick_add(t->expire, MS_TO_TICKS(s->inter));
-		return t;
-	}
-	fd = s->curfd;
-	if (fd < 0) {   /* no check currently running */
-		if (!tick_is_expired(t->expire, now_ms)) /* woke up too early */
-			return t;
-
-		/* we don't send any health-checks when the proxy is stopped or when
-		 * the server should not be checked.
-		 */
-		if (!(s->state & SRV_CHECKED) || s->proxy->state == PR_STSTOPPED || (s->state & SRV_MAINTAIN)) {
-			while (tick_is_expired(t->expire, now_ms))
-				t->expire = tick_add(t->expire, MS_TO_TICKS(s->inter));
-			return t;
-		}
-
-		/* we'll initiate a new check */
-		set_server_check_status(s, HCHK_STATUS_START, NULL);
-		if ((fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) != -1) {
-			if ((fd < global.maxsock) &&
-			    (fcntl(fd, F_SETFL, O_NONBLOCK) != -1) &&
-			    (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (char *) &one, sizeof(one)) != -1)) {
-				//fprintf(stderr, "process_chk: 3\n");
-
-				if (s->proxy->options & PR_O_TCP_NOLING) {
-					/* We don't want to useless data */
-					setsockopt(fd, SOL_SOCKET, SO_LINGER, (struct linger *) &nolinger, sizeof(struct linger));
-				}
-				
-				if (s->check_addr.sin_addr.s_addr)
-					/* we'll connect to the check addr specified on the server */
-					sa = s->check_addr;
-				else
-					/* we'll connect to the addr on the server */
-					sa = s->addr;
-
-				/* we'll connect to the check port on the server */
-				sa.sin_port = htons(s->check_port);
-
-				/* allow specific binding :
-				 * - server-specific at first
-				 * - proxy-specific next
-				 */
-				if (s->state & SRV_BIND_SRC) {
-					struct sockaddr_in *remote = NULL;
-					int ret, flags = 0;
-
-#if defined(CONFIG_HAP_CTTPROXY) || defined(CONFIG_HAP_LINUX_TPROXY)
-					if ((s->state & SRV_TPROXY_MASK) == SRV_TPROXY_ADDR) {
-						remote = (struct sockaddr_in *)&s->tproxy_addr;
-						flags  = 3;
-					}
-#endif
-#ifdef SO_BINDTODEVICE
-					/* Note: this might fail if not CAP_NET_RAW */
-					if (s->iface_name)
-						setsockopt(fd, SOL_SOCKET, SO_BINDTODEVICE,
-							   s->iface_name, s->iface_len + 1);
-#endif
-					if (s->sport_range) {
-						int bind_attempts = 10; /* should be more than enough to find a spare port */
-						struct sockaddr_in src;
-
-						ret = 1;
-						src = s->source_addr;
-
-						do {
-							/* note: in case of retry, we may have to release a previously
-							 * allocated port, hence this loop's construct.
-							 */
-							port_range_release_port(fdinfo[fd].port_range, fdinfo[fd].local_port);
-							fdinfo[fd].port_range = NULL;
-
-							if (!bind_attempts)
-								break;
-							bind_attempts--;
-
-							fdinfo[fd].local_port = port_range_alloc_port(s->sport_range);
-							if (!fdinfo[fd].local_port)
-								break;
-
-							fdinfo[fd].port_range = s->sport_range;
-							src.sin_port = htons(fdinfo[fd].local_port);
-
-							ret = tcpv4_bind_socket(fd, flags, &src, remote);
-						} while (ret != 0); /* binding NOK */
-					}
-					else {
-						ret = tcpv4_bind_socket(fd, flags, &s->source_addr, remote);
-					}
-
-					if (ret) {
-						set_server_check_status(s, HCHK_STATUS_SOCKERR, NULL);
-						switch (ret) {
-						case 1:
-							Alert("Cannot bind to source address before connect() for server %s/%s. Aborting.\n",
-							      s->proxy->id, s->id);
-							break;
-						case 2:
-							Alert("Cannot bind to tproxy source address before connect() for server %s/%s. Aborting.\n",
-							      s->proxy->id, s->id);
-							break;
-						}
-					}
-				}
-				else if (s->proxy->options & PR_O_BIND_SRC) {
-					struct sockaddr_in *remote = NULL;
-					int ret, flags = 0;
-
-#if defined(CONFIG_HAP_CTTPROXY) || defined(CONFIG_HAP_LINUX_TPROXY)
-					if ((s->proxy->options & PR_O_TPXY_MASK) == PR_O_TPXY_ADDR) {
-						remote = (struct sockaddr_in *)&s->proxy->tproxy_addr;
-						flags  = 3;
-					}
-#endif
-#ifdef SO_BINDTODEVICE
-					/* Note: this might fail if not CAP_NET_RAW */
-					if (s->proxy->iface_name)
-						setsockopt(fd, SOL_SOCKET, SO_BINDTODEVICE,
-							   s->proxy->iface_name, s->proxy->iface_len + 1);
-#endif
-					ret = tcpv4_bind_socket(fd, flags, &s->proxy->source_addr, remote);
-					if (ret) {
-						set_server_check_status(s, HCHK_STATUS_SOCKERR, NULL);
-						switch (ret) {
-						case 1:
-							Alert("Cannot bind to source address before connect() for %s '%s'. Aborting.\n",
-							      proxy_type_str(s->proxy), s->proxy->id);
-							break;
-						case 2:
-							Alert("Cannot bind to tproxy source address before connect() for %s '%s'. Aborting.\n",
-							      proxy_type_str(s->proxy), s->proxy->id);
-							break;
-						}
-					}
-				}
-
-				if (s->result == SRV_CHK_UNKNOWN) {
-#if defined(TCP_QUICKACK)
-					/* disabling tcp quick ack now allows
-					 * the request to leave the machine with
-					 * the first ACK.
-					 */
-					if (s->proxy->options2 & PR_O2_SMARTCON)
-						setsockopt(fd, IPPROTO_TCP, TCP_QUICKACK, (char *) &zero, sizeof(zero));
-#endif
-					if ((connect(fd, (struct sockaddr *)&sa, sizeof(sa)) != -1) || (errno == EINPROGRESS)) {
-						/* OK, connection in progress or established */
-			
-						//fprintf(stderr, "process_chk: 4\n");
-			
-						s->curfd = fd; /* that's how we know a test is in progress ;-) */
-						fd_insert(fd);
-						fdtab[fd].owner = t;
-						fdtab[fd].cb[DIR_RD].f = &event_srv_chk_r;
-						fdtab[fd].cb[DIR_RD].b = NULL;
-						fdtab[fd].cb[DIR_WR].f = &event_srv_chk_w;
-						fdtab[fd].cb[DIR_WR].b = NULL;
-						fdinfo[fd].peeraddr = (struct sockaddr *)&sa;
-						fdinfo[fd].peerlen = sizeof(sa);
-						fdtab[fd].state = FD_STCONN; /* connection in progress */
-						fdtab[fd].flags = FD_FL_TCP | FD_FL_TCP_NODELAY;
-						EV_FD_SET(fd, DIR_WR);  /* for connect status */
-#ifdef DEBUG_FULL
-						assert (!EV_FD_ISSET(fd, DIR_RD));
-#endif
-						//fprintf(stderr, "process_chk: 4+, %lu\n", __tv_to_ms(&s->proxy->timeout.connect));
-						/* we allow up to min(inter, timeout.connect) for a connection
-						 * to establish but only when timeout.check is set
-						 * as it may be to short for a full check otherwise
-						 */
-						t->expire = tick_add(now_ms, MS_TO_TICKS(s->inter));
-
-						if (s->proxy->timeout.check && s->proxy->timeout.connect) {
-							int t_con = tick_add(now_ms, s->proxy->timeout.connect);
-							t->expire = tick_first(t->expire, t_con);
-						}
-						return t;
-					}
-					else if (errno != EALREADY && errno != EISCONN && errno != EAGAIN) {
-						/* a real error */
-
-						switch (errno) {
-							/* FIXME: is it possible to get ECONNREFUSED/ENETUNREACH with O_NONBLOCK? */
-							case ECONNREFUSED:
-							case ENETUNREACH:
-								set_server_check_status(s, HCHK_STATUS_L4CON, strerror(errno));
-								break;
-
-							default:
-								set_server_check_status(s, HCHK_STATUS_SOCKERR, strerror(errno));
-						}
-					}
-				}
-			}
-			port_range_release_port(fdinfo[fd].port_range, fdinfo[fd].local_port);
-			fdinfo[fd].port_range = NULL;
-			close(fd); /* socket creation error */
-		}
-
-		if (s->result == SRV_CHK_UNKNOWN) { /* nothing done */
-			//fprintf(stderr, "process_chk: 6\n");
-			while (tick_is_expired(t->expire, now_ms))
-				t->expire = tick_add(t->expire, MS_TO_TICKS(s->inter));
-			goto new_chk; /* may be we should initialize a new check */
-		}
-
-		/* here, we have seen a failure */
-		if (s->health > s->rise) {
-			s->health--; /* still good */
-			s->counters.failed_checks++;
-		}
-		else
-			set_server_down(s);
-
-		//fprintf(stderr, "process_chk: 7, %lu\n", __tv_to_ms(&s->proxy->timeout.connect));
-		/* we allow up to min(inter, timeout.connect) for a connection
-		 * to establish but only when timeout.check is set
-		 * as it may be to short for a full check otherwise
-		 */
-		while (tick_is_expired(t->expire, now_ms)) {
-			int t_con;
-
-			t_con = tick_add(t->expire, s->proxy->timeout.connect);
-			t->expire = tick_add(t->expire, MS_TO_TICKS(s->inter));
-
-			if (s->proxy->timeout.check)
-				t->expire = tick_first(t->expire, t_con);
-		}
-		goto new_chk;
-	}
-	else {
-		/* there was a test running */
-		if ((s->result & (SRV_CHK_ERROR|SRV_CHK_RUNNING)) == SRV_CHK_RUNNING) { /* good server detected */
-			/* we may have to add/remove this server from the LB group */
-			if ((s->state & SRV_RUNNING) && (s->proxy->options & PR_O_DISABLE404)) {
-				if ((s->state & SRV_GOINGDOWN) &&
-				    ((s->result & (SRV_CHK_RUNNING|SRV_CHK_DISABLE)) == SRV_CHK_RUNNING))
-					set_server_enabled(s);
-				else if (!(s->state & SRV_GOINGDOWN) &&
-					 ((s->result & (SRV_CHK_RUNNING | SRV_CHK_DISABLE)) ==
-					  (SRV_CHK_RUNNING | SRV_CHK_DISABLE)))
-					set_server_disabled(s);
-			}
-
-			if (s->health < s->rise + s->fall - 1) {
-				s->health++; /* was bad, stays for a while */
-
-				set_server_up(s);
-			}
-			s->curfd = -1; /* no check running anymore */
-			fd_delete(fd);
-
-			rv = 0;
-			if (global.spread_checks > 0) {
-				rv = srv_getinter(s) * global.spread_checks / 100;
-				rv -= (int) (2 * rv * (rand() / (RAND_MAX + 1.0)));
-			}
-			t->expire = tick_add(now_ms, MS_TO_TICKS(srv_getinter(s) + rv));
-			goto new_chk;
-		}
-		else if ((s->result & SRV_CHK_ERROR) || tick_is_expired(t->expire, now_ms)) {
-			if (!(s->result & SRV_CHK_ERROR)) {
-				if (!EV_FD_ISSET(fd, DIR_RD)) {
-					set_server_check_status(s, HCHK_STATUS_L4TOUT, NULL);
-				} else {
-					if (s->proxy->options2 & PR_O2_SSL3_CHK)
-						set_server_check_status(s, HCHK_STATUS_L6TOUT, NULL);
-					else	/* HTTP, SMTP */
-						set_server_check_status(s, HCHK_STATUS_L7TOUT, NULL);
-				}
-			}
-
-			/* failure or timeout detected */
-			if (s->health > s->rise) {
-				s->health--; /* still good */
-				s->counters.failed_checks++;
-			}
-			else
-				set_server_down(s);
-			s->curfd = -1;
-			fd_delete(fd);
-
-			rv = 0;
-			if (global.spread_checks > 0) {
-				rv = srv_getinter(s) * global.spread_checks / 100;
-				rv -= (int) (2 * rv * (rand() / (RAND_MAX + 1.0)));
-			}
-			t->expire = tick_add(now_ms, MS_TO_TICKS(srv_getinter(s) + rv));
-			goto new_chk;
-		}
-		/* if result is unknown and there's no timeout, we have to wait again */
-	}
-	s->result = SRV_CHK_UNKNOWN;
-	return t;
-}
-
-/*
- * Start health-check.
- * Returns 0 if OK, -1 if error, and prints the error in this case.
- */
-int start_checks() {
-
-	struct proxy *px;
-	struct server *s;
-	struct task *t;
-	int nbchk=0, mininter=0, srvpos=0;
-
-	/* 1- count the checkers to run simultaneously.
-	 * We also determine the minimum interval among all of those which
-	 * have an interval larger than SRV_CHK_INTER_THRES. This interval
-	 * will be used to spread their start-up date. Those which have
-	 * a shorter interval will start independantly and will not dictate
-	 * too short an interval for all others.
-	 */
-	for (px = proxy; px; px = px->next) {
-		for (s = px->srv; s; s = s->next) {
-			if (!(s->state & SRV_CHECKED))
-				continue;
-
-			if ((srv_getinter(s) >= SRV_CHK_INTER_THRES) &&
-			    (!mininter || mininter > srv_getinter(s)))
-				mininter = srv_getinter(s);
-
-			nbchk++;
-		}
-	}
-
-	if (!nbchk)
-		return 0;
-
-	srand((unsigned)time(NULL));
-
-	/*
-	 * 2- start them as far as possible from each others. For this, we will
-	 * start them after their interval set to the min interval divided by
-	 * the number of servers, weighted by the server's position in the list.
-	 */
-	for (px = proxy; px; px = px->next) {
-		for (s = px->srv; s; s = s->next) {
-			if (s->slowstart) {
-				if ((t = task_new()) == NULL) {
-					Alert("Starting [%s:%s] check: out of memory.\n", px->id, s->id);
-					return -1;
-				}
-				/* We need a warmup task that will be called when the server
-				 * state switches from down to up.
-				 */
-				s->warmup = t;
-				t->process = server_warmup;
-				t->context = s;
-				t->expire = TICK_ETERNITY;
-			}
-
-			if (!(s->state & SRV_CHECKED))
-				continue;
-
-			/* one task for the checks */
-			if ((t = task_new()) == NULL) {
-				Alert("Starting [%s:%s] check: out of memory.\n", px->id, s->id);
-				return -1;
-			}
-
-			s->check = t;
-			t->process = process_chk;
-			t->context = s;
-
-			/* check this every ms */
-			t->expire = tick_add(now_ms,
-					     MS_TO_TICKS(((mininter && mininter >= srv_getinter(s)) ?
-							  mininter : srv_getinter(s)) * srvpos / nbchk));
-			s->check_start = now;
-			task_queue(t);
-
-			srvpos++;
-		}
-	}
-	return 0;
-}
-
-/*
- * Perform content verification check on data in s->check_data buffer.
- * The buffer MUST be terminated by a null byte before calling this function.
- * Sets server status appropriately. The caller is responsible for ensuring
- * that the buffer contains at least 13 characters. If <done> is zero, we may
- * return 0 to indicate that data is required to decide of a match.
- */
-static int httpchk_expect(struct server *s, int done)
-{
-	static char status_msg[] = "HTTP status check returned code <000>";
-	char status_code[] = "000";
-	char *contentptr;
-	int crlf;
-	int ret;
-
-	switch (s->proxy->options2 & PR_O2_EXP_TYPE) {
-	case PR_O2_EXP_STS:
-	case PR_O2_EXP_RSTS:
-		memcpy(status_code, s->check_data + 9, 3);
-		memcpy(status_msg + strlen(status_msg) - 4, s->check_data + 9, 3);
-
-		if ((s->proxy->options2 & PR_O2_EXP_TYPE) == PR_O2_EXP_STS)
-			ret = strncmp(s->proxy->expect_str, status_code, 3) == 0;
-		else
-			ret = regexec(s->proxy->expect_regex, status_code, MAX_MATCH, pmatch, 0) == 0;
-
-		/* we necessarily have the response, so there are no partial failures */
-		if (s->proxy->options2 & PR_O2_EXP_INV)
-			ret = !ret;
-
-		set_server_check_status(s, ret ? HCHK_STATUS_L7OKD : HCHK_STATUS_L7STS, status_msg);
-		break;
-
-	case PR_O2_EXP_STR:
-	case PR_O2_EXP_RSTR:
-		/* very simple response parser: ignore CR and only count consecutive LFs,
-		 * stop with contentptr pointing to first char after the double CRLF or
-		 * to '\0' if crlf < 2.
-		 */
-		crlf = 0;
-		for (contentptr = s->check_data; *contentptr; contentptr++) {
-			if (crlf >= 2)
-				break;
-			if (*contentptr == '\r')
-				continue;
-			else if (*contentptr == '\n')
-				crlf++;
-			else
-				crlf = 0;
-		}
-
-		/* Check that response contains a body... */
-		if (crlf < 2) {
-			if (!done)
-				return 0;
-
-			set_server_check_status(s, HCHK_STATUS_L7RSP,
-						"HTTP content check could not find a response body");
-			return 1;
-		}
-
-		/* Check that response body is not empty... */
-		if (*contentptr == '\0') {
-			if (!done)
-				return 0;
-
-			set_server_check_status(s, HCHK_STATUS_L7RSP,
-						"HTTP content check found empty response body");
-			return 1;
-		}
-
-		/* Check the response content against the supplied string
-		 * or regex... */
-		if ((s->proxy->options2 & PR_O2_EXP_TYPE) == PR_O2_EXP_STR)
-			ret = strstr(contentptr, s->proxy->expect_str) != NULL;
-		else
-			ret = regexec(s->proxy->expect_regex, contentptr, MAX_MATCH, pmatch, 0) == 0;
-
-		/* if we don't match, we may need to wait more */
-		if (!ret && !done)
-			return 0;
-
-		if (ret) {
-			/* content matched */
-			if (s->proxy->options2 & PR_O2_EXP_INV)
-				set_server_check_status(s, HCHK_STATUS_L7RSP,
-							"HTTP check matched unwanted content");
-			else
-				set_server_check_status(s, HCHK_STATUS_L7OKD,
-							"HTTP content check matched");
-		}
-		else {
-			if (s->proxy->options2 & PR_O2_EXP_INV)
-				set_server_check_status(s, HCHK_STATUS_L7OKD,
-							"HTTP check did not match unwanted content");
-			else
-				set_server_check_status(s, HCHK_STATUS_L7RSP,
-							"HTTP content check did not match");
-		}
-		break;
-	}
-	return 1;
-}
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/client.c b/deps/haproxy-1.4.21/src/client.c
deleted file mode 100644
index 6c7ed13..0000000
--- a/deps/haproxy-1.4.21/src/client.c
+++ /dev/null
@@ -1,882 +0,0 @@
-/*
- * Client-side variables and functions.
- *
- * Copyright 2000-2010 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <errno.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include <sys/socket.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-
-#include <common/compat.h>
-#include <common/config.h>
-#include <common/debug.h>
-#include <common/time.h>
-
-#include <types/global.h>
-
-#include <proto/acl.h>
-#include <proto/buffers.h>
-#include <proto/client.h>
-#include <proto/fd.h>
-#include <proto/log.h>
-#include <proto/hdr_idx.h>
-#include <proto/pattern.h>
-#include <proto/protocols.h>
-#include <proto/proto_tcp.h>
-#include <proto/proto_http.h>
-#include <proto/proxy.h>
-#include <proto/session.h>
-#include <proto/stream_interface.h>
-#include <proto/stream_sock.h>
-#include <proto/task.h>
-
-
-/* This analyser tries to fetch a line from the request buffer which looks like :
- *
- *   "PROXY" <SP> PROTO <SP> SRC3 <SP> DST3 <SP> SRC4 <SP> <DST4> "\r\n"
- *
- * There must be exactly one space between each field. Fields are :
- *  - PROTO : layer 4 protocol, which must be "TCP4" or "TCP6".
- *  - SRC3  : layer 3 (eg: IP) source address in standard text form
- *  - DST3  : layer 3 (eg: IP) destination address in standard text form
- *  - SRC4  : layer 4 (eg: TCP port) source address in standard text form
- *  - DST4  : layer 4 (eg: TCP port) destination address in standard text form
- *
- * This line MUST be at the beginning of the buffer and MUST NOT wrap.
- *
- * Once the data is fetched, the values are set in the session's field and data
- * are removed from the buffer. The function returns zero if it needs to wait
- * for more data (max: timeout_client), or 1 if it has finished and removed itself.
- */
-int frontend_decode_proxy_request(struct session *s, struct buffer *req, int an_bit)
-{
-	char *line = req->data;
-	char *end = req->data + req->l;
-	int len;
-
-	DPRINTF(stderr,"[%u] %s: session=%p b=%p, exp(r,w)=%u,%u bf=%08x bl=%d analysers=%02x\n",
-		now_ms, __FUNCTION__,
-		s,
-		req,
-		req->rex, req->wex,
-		req->flags,
-		req->l,
-		req->analysers);
-
-	if (req->flags & (BF_READ_ERROR|BF_READ_TIMEOUT))
-		goto fail;
-
-	len = MIN(req->l, 6);
-	if (!len)
-		goto missing;
-
-	/* Decode a possible proxy request, fail early if it does not match */
-	if (strncmp(line, "PROXY ", len) != 0)
-		goto fail;
-
-	line += 6;
-	if (req->l < 18) /* shortest possible line */
-		goto missing;
-
-	if (!memcmp(line, "TCP4 ", 5) != 0) {
-		u32 src3, dst3, sport, dport;
-
-		line += 5;
-
-		src3 = inetaddr_host_lim_ret(line, end, &line);
-		if (line == end)
-			goto missing;
-		if (*line++ != ' ')
-			goto fail;
-
-		dst3 = inetaddr_host_lim_ret(line, end, &line);
-		if (line == end)
-			goto missing;
-		if (*line++ != ' ')
-			goto fail;
-
-		sport = read_uint((const char **)&line, end);
-		if (line == end)
-			goto missing;
-		if (*line++ != ' ')
-			goto fail;
-
-		dport = read_uint((const char **)&line, end);
-		if (line > end - 2)
-			goto missing;
-		if (*line++ != '\r')
-			goto fail;
-		if (*line++ != '\n')
-			goto fail;
-
-		/* update the session's addresses and mark them set */
-		((struct sockaddr_in *)&s->cli_addr)->sin_family      = AF_INET;
-		((struct sockaddr_in *)&s->cli_addr)->sin_addr.s_addr = htonl(src3);
-		((struct sockaddr_in *)&s->cli_addr)->sin_port        = htons(sport);
-
-		((struct sockaddr_in *)&s->frt_addr)->sin_family      = AF_INET;
-		((struct sockaddr_in *)&s->frt_addr)->sin_addr.s_addr = htonl(dst3);
-		((struct sockaddr_in *)&s->frt_addr)->sin_port        = htons(dport);
-		s->flags |= SN_FRT_ADDR_SET;
-
-	}
-	else if (!memcmp(line, "TCP6 ", 5) != 0) {
-		u32 sport, dport;
-		char *src_s;
-		char *dst_s, *sport_s, *dport_s;
-		struct in6_addr src3, dst3;
-
-		line+=5;
-
-		src_s = line;
-		dst_s = sport_s = dport_s = NULL;
-		while (1) {
-			if (line > end - 2) {
-				goto missing;
-			}
-			else if (*line == '\r') {
-				*line = 0;
-				line++;
-				if (*line++ != '\n')
-					goto fail;
-				break;
-			}
-
-			if (*line == ' ') {
-				*line = 0;
-				if (!dst_s)
-					dst_s = line+1;
-				else if (!sport_s)
-					sport_s = line+1;
-				else if (!dport_s)
-					dport_s = line+1;
-			}
-			line++;
-		}
-
-		if (!dst_s || !sport_s || !dport_s)
-			goto fail;
-
-		sport = read_uint((const char **)&sport_s,dport_s-1);
-		if ( *sport_s != 0 )
-			goto fail;
-
-		dport = read_uint((const char **)&dport_s,line-2);
-		if ( *dport_s != 0 )
-			goto fail;
-
-		if (inet_pton(AF_INET6, src_s, (void *)&src3) != 1)
-			goto fail;
-
-		if (inet_pton(AF_INET6, dst_s, (void *)&dst3) != 1)
-			goto fail;
-
-		/* update the session's addresses and mark them set */
-		((struct sockaddr_in6 *)&s->cli_addr)->sin6_family      = AF_INET6;
-		memcpy(&((struct sockaddr_in6 *)&s->cli_addr)->sin6_addr, &src3, sizeof(struct in6_addr));
-		((struct sockaddr_in6 *)&s->cli_addr)->sin6_port        = htons(sport);
-
-		((struct sockaddr_in6 *)&s->frt_addr)->sin6_family      = AF_INET6;
-		memcpy(&((struct sockaddr_in6 *)&s->frt_addr)->sin6_addr, &dst3, sizeof(struct in6_addr));
-		((struct sockaddr_in6 *)&s->frt_addr)->sin6_port        = htons(dport);
-		s->flags |= SN_FRT_ADDR_SET;
-	}
-	else {
-		goto fail;
-	}
-
-	/* remove the PROXY line from the request */
-	len = line - req->data;
-	buffer_replace2(req, req->data, line, NULL, 0);
-	req->total -= len; /* don't count the header line */
-
-	req->analysers &= ~an_bit;
-	return 1;
-
- missing:
-	if (!(req->flags & (BF_SHUTR|BF_FULL))) {
-		buffer_dont_connect(s->req);
-		return 0;
-	}
-	/* missing data and buffer is either full or shutdown => fail */
-
- fail:
-	buffer_abort(req);
-	buffer_abort(s->rep);
-	req->analysers = 0;
-
-	s->fe->counters.failed_req++;
-	if (s->listener->counters)
-		s->listener->counters->failed_req++;
-
-	if (!(s->flags & SN_ERR_MASK))
-		s->flags |= SN_ERR_PRXCOND;
-	if (!(s->flags & SN_FINST_MASK))
-		s->flags |= SN_FINST_R;
-	return 0;
-}
-
-/* Retrieves the original destination address used by the client, and sets the
- * SN_FRT_ADDR_SET flag.
- */
-void get_frt_addr(struct session *s)
-{
-	socklen_t namelen = sizeof(s->frt_addr);
-
-	if (get_original_dst(s->si[0].fd, (struct sockaddr_in *)&s->frt_addr, &namelen) == -1)
-		getsockname(s->si[0].fd, (struct sockaddr *)&s->frt_addr, &namelen);
-	s->flags |= SN_FRT_ADDR_SET;
-}
-
-/*
- * FIXME: This should move to the STREAM_SOCK code then split into TCP and HTTP.
- */
-
-/*
- * this function is called on a read event from a listen socket, corresponding
- * to an accept. It tries to accept as many connections as possible.
- * It returns 0.
- */
-int event_accept(int fd) {
-	struct listener *l = fdtab[fd].owner;
-	struct proxy *p = (struct proxy *)l->private; /* attached frontend */
-	struct session *s;
-	struct http_txn *txn;
-	struct task *t;
-	int cfd;
-	int max_accept = global.tune.maxaccept;
-
-	if (p->fe_sps_lim) {
-		int max = freq_ctr_remain(&p->fe_sess_per_sec, p->fe_sps_lim, 0);
-		if (max_accept > max)
-			max_accept = max;
-	}
-
-	while (p->feconn < p->maxconn && actconn < global.maxconn && max_accept--) {
-		struct sockaddr_storage addr;
-		socklen_t laddr = sizeof(addr);
-
-		if ((cfd = accept(fd, (struct sockaddr *)&addr, &laddr)) == -1) {
-			switch (errno) {
-			case EAGAIN:
-			case EINTR:
-			case ECONNABORTED:
-				return 0;	    /* nothing more to accept */
-			case ENFILE:
-				send_log(p, LOG_EMERG,
-					 "Proxy %s reached system FD limit at %d. Please check system tunables.\n",
-					 p->id, maxfd);
-				return 0;
-			case EMFILE:
-				send_log(p, LOG_EMERG,
-					 "Proxy %s reached process FD limit at %d. Please check 'ulimit-n' and restart.\n",
-					 p->id, maxfd);
-				return 0;
-			case ENOBUFS:
-			case ENOMEM:
-				send_log(p, LOG_EMERG,
-					 "Proxy %s reached system memory limit at %d sockets. Please check system tunables.\n",
-					 p->id, maxfd);
-				return 0;
-			default:
-				return 0;
-			}
-		}
-
-		if (l->nbconn >= l->maxconn) {
-			/* too many connections, we shoot this one and return.
-			 * FIXME: it would be better to simply switch the listener's
-			 * state to LI_FULL and disable the FD. We could re-enable
-			 * it upon fd_delete(), but this requires all protocols to
-			 * be switched.
-			 */
-			goto out_close;
-		}
-
-		if ((s = pool_alloc2(pool2_session)) == NULL) { /* disable this proxy for a while */
-			Alert("out of memory in event_accept().\n");
-			disable_listener(l);
-			p->state = PR_STIDLE;
-			goto out_close;
-		}
-
-		LIST_INIT(&s->back_refs);
-
-		s->flags = 0;
-		s->term_trace = 0;
-
-		/* if this session comes from a known monitoring system, we want to ignore
-		 * it as soon as possible, which means closing it immediately for TCP.
-		 */
-		if (addr.ss_family == AF_INET &&
-		    p->mon_mask.s_addr &&
-		    (((struct sockaddr_in *)&addr)->sin_addr.s_addr & p->mon_mask.s_addr) == p->mon_net.s_addr) {
-			if (p->mode == PR_MODE_TCP) {
-				close(cfd);
-				pool_free2(pool2_session, s);
-				continue;
-			}
-			s->flags |= SN_MONITOR;
-		}
-
-		LIST_ADDQ(&sessions, &s->list);
-
-		if ((t = task_new()) == NULL) { /* disable this proxy for a while */
-			Alert("out of memory in event_accept().\n");
-			disable_listener(l);
-			p->state = PR_STIDLE;
-			goto out_free_session;
-		}
-
-		s->cli_addr = addr;
-		if (cfd >= global.maxsock) {
-			Alert("accept(): not enough free sockets. Raise -n argument. Giving up.\n");
-			goto out_free_task;
-		}
-
-		if ((fcntl(cfd, F_SETFL, O_NONBLOCK) == -1) ||
-		    (setsockopt(cfd, IPPROTO_TCP, TCP_NODELAY,
-				(char *) &one, sizeof(one)) == -1)) {
-			Alert("accept(): cannot set the socket in non blocking mode. Giving up\n");
-			goto out_free_task;
-		}
-
-		if (p->options & PR_O_TCP_CLI_KA)
-			setsockopt(cfd, SOL_SOCKET, SO_KEEPALIVE, (char *) &one, sizeof(one));
-
-		if (p->options & PR_O_TCP_NOLING)
-			setsockopt(cfd, SOL_SOCKET, SO_LINGER, (struct linger *) &nolinger, sizeof(struct linger));
-
-		if (global.tune.client_sndbuf)
-			setsockopt(cfd, SOL_SOCKET, SO_SNDBUF, &global.tune.client_sndbuf, sizeof(global.tune.client_sndbuf));
-
-		if (global.tune.client_rcvbuf)
-			setsockopt(cfd, SOL_SOCKET, SO_RCVBUF, &global.tune.client_rcvbuf, sizeof(global.tune.client_rcvbuf));
-
-		t->process = l->handler;
-		t->context = s;
-		t->nice = l->nice;
-
-		s->task = t;
-		s->listener = l;
-
-		/* Note: initially, the session's backend points to the frontend.
-		 * This changes later when switching rules are executed or
-		 * when the default backend is assigned.
-		 */
-		s->be = s->fe = p;
-
-		s->req = s->rep = NULL; /* will be allocated later */
-
-		s->si[0].state = s->si[0].prev_state = SI_ST_EST;
-		s->si[0].err_type = SI_ET_NONE;
-		s->si[0].err_loc = NULL;
-		s->si[0].owner = t;
-		s->si[0].update = stream_sock_data_finish;
-		s->si[0].shutr = stream_sock_shutr;
-		s->si[0].shutw = stream_sock_shutw;
-		s->si[0].chk_rcv = stream_sock_chk_rcv;
-		s->si[0].chk_snd = stream_sock_chk_snd;
-		s->si[0].connect = NULL;
-		s->si[0].iohandler = NULL;
-		s->si[0].fd = cfd;
-		s->si[0].flags = SI_FL_NONE | SI_FL_CAP_SPLTCP; /* TCP splicing capable */
-		if (s->fe->options2 & PR_O2_INDEPSTR)
-			s->si[0].flags |= SI_FL_INDEP_STR;
-		s->si[0].exp = TICK_ETERNITY;
-
-		s->si[1].state = s->si[1].prev_state = SI_ST_INI;
-		s->si[1].err_type = SI_ET_NONE;
-		s->si[1].err_loc = NULL;
-		s->si[1].owner = t;
-		s->si[1].update = stream_sock_data_finish;
-		s->si[1].shutr = stream_sock_shutr;
-		s->si[1].shutw = stream_sock_shutw;
-		s->si[1].chk_rcv = stream_sock_chk_rcv;
-		s->si[1].chk_snd = stream_sock_chk_snd;
-		s->si[1].connect = tcpv4_connect_server;
-		s->si[1].iohandler = NULL;
-		s->si[1].exp = TICK_ETERNITY;
-		s->si[1].fd = -1; /* just to help with debugging */
-		s->si[1].flags = SI_FL_NONE;
-		if (s->be->options2 & PR_O2_INDEPSTR)
-			s->si[1].flags |= SI_FL_INDEP_STR;
-
-		s->srv = s->prev_srv = s->srv_conn = NULL;
-		s->pend_pos = NULL;
-		s->conn_retries = s->be->conn_retries;
-
-		/* init store persistence */
-		s->store_count = 0;
-
-		/* FIXME: the logs are horribly complicated now, because they are
-		 * defined in <p>, <p>, and later <be> and <be>.
-		 */
-
-		if (s->flags & SN_MONITOR)
-			s->logs.logwait = 0;
-		else
-			s->logs.logwait = p->to_log;
-
-		if (s->logs.logwait & LW_REQ)
-			s->do_log = http_sess_log;
-		else
-			s->do_log = tcp_sess_log;
-
-		/* default error reporting function, may be changed by analysers */
-		s->srv_error = default_srv_error;
-
-		s->logs.accept_date = date; /* user-visible date for logging */
-		s->logs.tv_accept = now;  /* corrected date for internal use */
-		tv_zero(&s->logs.tv_request);
-		s->logs.t_queue = -1;
-		s->logs.t_connect = -1;
-		s->logs.t_data = -1;
-		s->logs.t_close = 0;
-		s->logs.bytes_in = s->logs.bytes_out = 0;
-		s->logs.prx_queue_size = 0;  /* we get the number of pending conns before us */
-		s->logs.srv_queue_size = 0; /* we will get this number soon */
-
-		s->data_source = DATA_SRC_NONE;
-
-		s->uniq_id = totalconn;
-		proxy_inc_fe_ctr(l, p);	/* note: cum_beconn will be increased once assigned */
-
-		txn = &s->txn;
-		/* Those variables will be checked and freed if non-NULL in
-		 * session.c:session_free(). It is important that they are
-		 * properly initialized.
-		 */
-		txn->sessid = NULL;
-		txn->srv_cookie = NULL;
-		txn->cli_cookie = NULL;
-		txn->uri = NULL;
-		txn->req.cap = NULL;
-		txn->rsp.cap = NULL;
-		txn->hdr_idx.v = NULL;
-		txn->hdr_idx.size = txn->hdr_idx.used = 0;
-
-		if (p->mode == PR_MODE_HTTP) {
-			/* the captures are only used in HTTP frontends */
-			if (p->nb_req_cap > 0 &&
-			    (txn->req.cap = pool_alloc2(p->req_cap_pool)) == NULL)
-					goto out_fail_reqcap;	/* no memory */
-
-			if (p->nb_rsp_cap > 0 &&
-			    (txn->rsp.cap = pool_alloc2(p->rsp_cap_pool)) == NULL)
-					goto out_fail_rspcap;	/* no memory */
-		}
-
-		if (p->acl_requires & ACL_USE_L7_ANY) {
-			/* we have to allocate header indexes only if we know
-			 * that we may make use of them. This of course includes
-			 * (mode == PR_MODE_HTTP).
-			 */
-			txn->hdr_idx.size = MAX_HTTP_HDR;
-
-			if ((txn->hdr_idx.v = pool_alloc2(p->hdr_idx_pool)) == NULL)
-				goto out_fail_idx; /* no memory */
-
-			/* and now initialize the HTTP transaction state */
-			http_init_txn(s);
-		}
-
-		if ((p->mode == PR_MODE_TCP || p->mode == PR_MODE_HTTP)
-		    && (p->logfac1 >= 0 || p->logfac2 >= 0)) {
-			if (p->to_log) {
-				/* we have the client ip */
-				if (s->logs.logwait & LW_CLIP)
-					if (!(s->logs.logwait &= ~LW_CLIP))
-						s->do_log(s);
-			}
-			else if (s->cli_addr.ss_family == AF_INET) {
-				char pn[INET_ADDRSTRLEN], sn[INET_ADDRSTRLEN];
-
-				if (!(s->flags & SN_FRT_ADDR_SET))
-					get_frt_addr(s);
-
-				if (inet_ntop(AF_INET, (const void *)&((struct sockaddr_in *)&s->frt_addr)->sin_addr,
-					      sn, sizeof(sn)) &&
-				    inet_ntop(AF_INET, (const void *)&((struct sockaddr_in *)&s->cli_addr)->sin_addr,
-					      pn, sizeof(pn))) {
-					send_log(p, LOG_INFO, "Connect from %s:%d to %s:%d (%s/%s)\n",
-						 pn, ntohs(((struct sockaddr_in *)&s->cli_addr)->sin_port),
-						 sn, ntohs(((struct sockaddr_in *)&s->frt_addr)->sin_port),
-						 p->id, (p->mode == PR_MODE_HTTP) ? "HTTP" : "TCP");
-				}
-			}
-			else {
-				char pn[INET6_ADDRSTRLEN], sn[INET6_ADDRSTRLEN];
-
-				if (!(s->flags & SN_FRT_ADDR_SET))
-					get_frt_addr(s);
-
-				if (inet_ntop(AF_INET6, (const void *)&((struct sockaddr_in6 *)&s->frt_addr)->sin6_addr,
-					      sn, sizeof(sn)) &&
-				    inet_ntop(AF_INET6, (const void *)&((struct sockaddr_in6 *)&s->cli_addr)->sin6_addr,
-					      pn, sizeof(pn))) {
-					send_log(p, LOG_INFO, "Connect from %s:%d to %s:%d (%s/%s)\n",
-						 pn, ntohs(((struct sockaddr_in6 *)&s->cli_addr)->sin6_port),
-						 sn, ntohs(((struct sockaddr_in6 *)&s->frt_addr)->sin6_port),
-						 p->id, (p->mode == PR_MODE_HTTP) ? "HTTP" : "TCP");
-				}
-			}
-		}
-
-		if ((global.mode & MODE_DEBUG) && (!(global.mode & MODE_QUIET) || (global.mode & MODE_VERBOSE))) {
-			int len;
-
-			if (!(s->flags & SN_FRT_ADDR_SET))
-				get_frt_addr(s);
-
-			if (s->cli_addr.ss_family == AF_INET) {
-				char pn[INET_ADDRSTRLEN];
-				inet_ntop(AF_INET,
-					  (const void *)&((struct sockaddr_in *)&s->cli_addr)->sin_addr,
-					  pn, sizeof(pn));
-
-				len = sprintf(trash, "%08x:%s.accept(%04x)=%04x from [%s:%d]\n",
-					      s->uniq_id, p->id, (unsigned short)fd, (unsigned short)cfd,
-					      pn, ntohs(((struct sockaddr_in *)&s->cli_addr)->sin_port));
-			}
-			else {
-				char pn[INET6_ADDRSTRLEN];
-				inet_ntop(AF_INET6,
-					  (const void *)&((struct sockaddr_in6 *)(&s->cli_addr))->sin6_addr,
-					  pn, sizeof(pn));
-
-				len = sprintf(trash, "%08x:%s.accept(%04x)=%04x from [%s:%d]\n",
-					      s->uniq_id, p->id, (unsigned short)fd, (unsigned short)cfd,
-					      pn, ntohs(((struct sockaddr_in6 *)(&s->cli_addr))->sin6_port));
-			}
-
-			if (write(1, trash, len) < 0) /* shut gcc warning */;
-		}
-
-		if ((s->req = pool_alloc2(pool2_buffer)) == NULL)
-			goto out_fail_req; /* no memory */
-
-		s->req->size = global.tune.bufsize;
-		buffer_init(s->req);
-		s->req->prod = &s->si[0];
-		s->req->cons = &s->si[1];
-		s->si[0].ib = s->si[1].ob = s->req;
-
-		s->req->flags |= BF_READ_ATTACHED; /* the producer is already connected */
-
-		if (p->mode == PR_MODE_HTTP)
-			s->req->flags |= BF_READ_DONTWAIT; /* one read is usually enough */
-
-		/* activate default analysers enabled for this listener */
-		s->req->analysers = l->analysers;
-
-		/* note: this should not happen anymore since there's always at least the switching rules */
-		if (!s->req->analysers) {
-			buffer_auto_connect(s->req);  /* don't wait to establish connection */
-			buffer_auto_close(s->req);    /* let the producer forward close requests */
-		}
-
-		s->req->rto = s->fe->timeout.client;
-		s->req->wto = s->be->timeout.server;
-		s->req->cto = s->be->timeout.connect;
-
-		if ((s->rep = pool_alloc2(pool2_buffer)) == NULL)
-			goto out_fail_rep; /* no memory */
-
-		s->rep->size = global.tune.bufsize;
-		buffer_init(s->rep);
-		s->rep->prod = &s->si[1];
-		s->rep->cons = &s->si[0];
-		s->si[0].ob = s->si[1].ib = s->rep;
-		s->rep->analysers = 0;
-
-		if (s->fe->options2 & PR_O2_NODELAY) {
-			s->req->flags |= BF_NEVER_WAIT;
-			s->rep->flags |= BF_NEVER_WAIT;
-		}
-
-		s->rep->rto = s->be->timeout.server;
-		s->rep->wto = s->fe->timeout.client;
-		s->rep->cto = TICK_ETERNITY;
-
-		s->req->rex = TICK_ETERNITY;
-		s->req->wex = TICK_ETERNITY;
-		s->req->analyse_exp = TICK_ETERNITY;
-		s->rep->rex = TICK_ETERNITY;
-		s->rep->wex = TICK_ETERNITY;
-		s->rep->analyse_exp = TICK_ETERNITY;
-		t->expire = TICK_ETERNITY;
-
-		fd_insert(cfd);
-		fdtab[cfd].owner = &s->si[0];
-		fdtab[cfd].state = FD_STREADY;
-		fdtab[cfd].flags = FD_FL_TCP | FD_FL_TCP_NODELAY;
-		if (p->options & PR_O_TCP_NOLING)
-			fdtab[cfd].flags |= FD_FL_TCP_NOLING;
-
-		fdtab[cfd].cb[DIR_RD].f = l->proto->read;
-		fdtab[cfd].cb[DIR_RD].b = s->req;
-		fdtab[cfd].cb[DIR_WR].f = l->proto->write;
-		fdtab[cfd].cb[DIR_WR].b = s->rep;
-		fdinfo[cfd].peeraddr = (struct sockaddr *)&s->cli_addr;
-		fdinfo[cfd].peerlen = sizeof(s->cli_addr);
-
-		if ((p->mode == PR_MODE_HTTP && (s->flags & SN_MONITOR)) ||
-		    (p->mode == PR_MODE_HEALTH && (p->options & PR_O_HTTP_CHK))) {
-			/* Either we got a request from a monitoring system on an HTTP instance,
-			 * or we're in health check mode with the 'httpchk' option enabled. In
-			 * both cases, we return a fake "HTTP/1.0 200 OK" response and we exit.
-			 */
-			struct chunk msg;
-			chunk_initstr(&msg, "HTTP/1.0 200 OK\r\n\r\n");
-			stream_int_retnclose(&s->si[0], &msg); /* forge a 200 response */
-			s->req->analysers = 0;
-			t->expire = s->rep->wex;
-		}
-		else if (p->mode == PR_MODE_HEALTH) {  /* health check mode, no client reading */
-			struct chunk msg;
-			chunk_initstr(&msg, "OK\n");
-			stream_int_retnclose(&s->si[0], &msg); /* forge an "OK" response */
-			s->req->analysers = 0;
-			t->expire = s->rep->wex;
-		}
-		else {
-			EV_FD_SET(cfd, DIR_RD);
-		}
-
-		/* it is important not to call the wakeup function directly but to
-		 * pass through task_wakeup(), because this one knows how to apply
-		 * priorities to tasks.
-		 */
-		task_wakeup(t, TASK_WOKEN_INIT);
-
-		l->nbconn++; /* warning! right now, it's up to the handler to decrease this */
-		if (l->nbconn >= l->maxconn) {
-			EV_FD_CLR(l->fd, DIR_RD);
-			l->state = LI_FULL;
-		}
-
-		p->feconn++;  /* beconn will be increased later */
-		if (p->feconn > p->counters.feconn_max)
-			p->counters.feconn_max = p->feconn;
-
-		if (l->counters) {
-			if (l->nbconn > l->counters->conn_max)
-				l->counters->conn_max = l->nbconn;
-		}
-
-		actconn++;
-		totalconn++;
-
-		// fprintf(stderr, "accepting from %p => %d conn, %d total, task=%p\n", p, actconn, totalconn, t);
-	} /* end of while (p->feconn < p->maxconn) */
-	return 0;
-
-	/* Error unrolling */
- out_fail_rep:
-	pool_free2(pool2_buffer, s->req);
- out_fail_req:
-	pool_free2(p->hdr_idx_pool, txn->hdr_idx.v);
- out_fail_idx:
-	pool_free2(p->rsp_cap_pool, txn->rsp.cap);
- out_fail_rspcap:
-	pool_free2(p->req_cap_pool, txn->req.cap);
- out_fail_reqcap:
- out_free_task:
-	task_free(t);
- out_free_session:
-	LIST_DEL(&s->list);
-	pool_free2(pool2_session, s);
- out_close:
-	close(cfd);
-	return 0;
-}
-
-
-
-/************************************************************************/
-/*             All supported keywords must be declared here.            */
-/************************************************************************/
-
-/* set test->ptr to point to the source IPv4/IPv6 address and test->i to the family */
-static int
-acl_fetch_src(struct proxy *px, struct session *l4, void *l7, int dir,
-              struct acl_expr *expr, struct acl_test *test)
-{
-	test->i = l4->cli_addr.ss_family;
-	if (test->i == AF_INET)
-		test->ptr = (void *)&((struct sockaddr_in *)&l4->cli_addr)->sin_addr;
-	else
-		test->ptr = (void *)&((struct sockaddr_in6 *)(&l4->cli_addr))->sin6_addr;
-	test->flags = ACL_TEST_F_READ_ONLY;
-	return 1;
-}
-
-/* extract the connection's source address */
-static int
-pattern_fetch_src(struct proxy *px, struct session *l4, void *l7, int dir,
-                  const char *arg, int arg_len, union pattern_data *data)
-{
-	data->ip.s_addr = ((struct sockaddr_in *)&l4->cli_addr)->sin_addr.s_addr;
-	return 1;
-}
-
-
-/* set test->i to the connection's source port */
-static int
-acl_fetch_sport(struct proxy *px, struct session *l4, void *l7, int dir,
-                struct acl_expr *expr, struct acl_test *test)
-{
-	if (l4->cli_addr.ss_family == AF_INET)
-		test->i = ntohs(((struct sockaddr_in *)&l4->cli_addr)->sin_port);
-	else
-		test->i = ntohs(((struct sockaddr_in6 *)(&l4->cli_addr))->sin6_port);
-	test->flags = 0;
-	return 1;
-}
-
-
-/* set test->ptr to point to the frontend's IPv4/IPv6 address and test->i to the family */
-static int
-acl_fetch_dst(struct proxy *px, struct session *l4, void *l7, int dir,
-              struct acl_expr *expr, struct acl_test *test)
-{
-	if (!(l4->flags & SN_FRT_ADDR_SET))
-		get_frt_addr(l4);
-
-	test->i = l4->frt_addr.ss_family;
-	if (test->i == AF_INET)
-		test->ptr = (void *)&((struct sockaddr_in *)&l4->frt_addr)->sin_addr;
-	else
-		test->ptr = (void *)&((struct sockaddr_in6 *)(&l4->frt_addr))->sin6_addr;
-	test->flags = ACL_TEST_F_READ_ONLY;
-	return 1;
-}
-
-
-/* extract the connection's destination address */
-static int
-pattern_fetch_dst(struct proxy *px, struct session *l4, void *l7, int dir,
-                  const char *arg, int arg_len, union pattern_data *data)
-{
-	if (!(l4->flags & SN_FRT_ADDR_SET))
-		get_frt_addr(l4);
-
-	data->ip.s_addr = ((struct sockaddr_in *)&l4->frt_addr)->sin_addr.s_addr;
-	return 1;
-}
-
-/* set test->i to the frontend connexion's destination port */
-static int
-acl_fetch_dport(struct proxy *px, struct session *l4, void *l7, int dir,
-                struct acl_expr *expr, struct acl_test *test)
-{
-	if (!(l4->flags & SN_FRT_ADDR_SET))
-		get_frt_addr(l4);
-
-	if (l4->frt_addr.ss_family == AF_INET)
-		test->i = ntohs(((struct sockaddr_in *)&l4->frt_addr)->sin_port);
-	else
-		test->i = ntohs(((struct sockaddr_in6 *)(&l4->frt_addr))->sin6_port);
-	test->flags = 0;
-	return 1;
-}
-
-static int
-pattern_fetch_dport(struct proxy *px, struct session *l4, void *l7, int dir,
-                    const char *arg, int arg_len, union pattern_data *data)
-
-{
-	if (!(l4->flags & SN_FRT_ADDR_SET))
-		get_frt_addr(l4);
-
-	data->integer = ntohs(((struct sockaddr_in *)&l4->frt_addr)->sin_port);
-	return 1;
-}
-
-/* set test->i to the number of connexions to the same listening socket */
-static int
-acl_fetch_dconn(struct proxy *px, struct session *l4, void *l7, int dir,
-                struct acl_expr *expr, struct acl_test *test)
-{
-	test->i = l4->listener->nbconn;
-	return 1;
-}
-
-/* set test->i to the id of the frontend */
-static int
-acl_fetch_fe_id(struct proxy *px, struct session *l4, void *l7, int dir,
-                struct acl_expr *expr, struct acl_test *test) {
-
-	test->flags = ACL_TEST_F_READ_ONLY;
-
-	test->i = l4->fe->uuid;
-
-	return 1;
-}
-
-/* set test->i to the id of the socket (listener) */
-static int
-acl_fetch_so_id(struct proxy *px, struct session *l4, void *l7, int dir,
-                struct acl_expr *expr, struct acl_test *test) {
-
-	test->flags = ACL_TEST_F_READ_ONLY;
-
-	test->i = l4->listener->luid;
-
-	return 1;
-}
-
-
-/* Note: must not be declared <const> as its list will be overwritten */
-static struct acl_kw_list acl_kws = {{ },{
-	{ "src_port",   acl_parse_int,   acl_fetch_sport,    acl_match_int, ACL_USE_TCP_PERMANENT  },
-	{ "src",        acl_parse_ip,    acl_fetch_src,      acl_match_ip,  ACL_USE_TCP4_PERMANENT|ACL_MAY_LOOKUP },
-	{ "dst",        acl_parse_ip,    acl_fetch_dst,      acl_match_ip,  ACL_USE_TCP4_PERMANENT|ACL_MAY_LOOKUP },
-	{ "dst_port",   acl_parse_int,   acl_fetch_dport,    acl_match_int, ACL_USE_TCP_PERMANENT  },
-#if 0
-	{ "src_limit",  acl_parse_int,   acl_fetch_sconn,    acl_match_int },
-#endif
-	{ "dst_conn",   acl_parse_int,   acl_fetch_dconn,    acl_match_int, ACL_USE_NOTHING },
-	{ "fe_id",      acl_parse_int,   acl_fetch_fe_id,    acl_match_int, ACL_USE_NOTHING },
-	{ "so_id",      acl_parse_int,   acl_fetch_so_id,    acl_match_int, ACL_USE_NOTHING },
-	{ NULL, NULL, NULL, NULL },
-}};
-
-
-/* Note: must not be declared <const> as its list will be overwritten */
-static struct pattern_fetch_kw_list pattern_fetch_keywords = {{ },{
-	{ "src",       pattern_fetch_src,   PATTERN_TYPE_IP,      PATTERN_FETCH_REQ },
-	{ "dst",       pattern_fetch_dst,   PATTERN_TYPE_IP,      PATTERN_FETCH_REQ },
-	{ "dst_port",  pattern_fetch_dport, PATTERN_TYPE_INTEGER, PATTERN_FETCH_REQ },
-	{ NULL, NULL, 0, 0 },
-}};
-
-
-__attribute__((constructor))
-static void __client_init(void)
-{
-	acl_register_keywords(&acl_kws);
-	pattern_register_fetches(&pattern_fetch_keywords);
-}
-
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/cttproxy.c b/deps/haproxy-1.4.21/src/cttproxy.c
deleted file mode 100644
index 0cfd834..0000000
--- a/deps/haproxy-1.4.21/src/cttproxy.c
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Functions for managing transparent proxying with CTTPROXY.
- * This file should be compiled only if CTTPROXY is enabled.
- *
- * Copyright 2000-2008 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <errno.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include <sys/socket.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-
-#include <common/compat.h>
-#include <common/config.h>
-#include <common/time.h>
-
-#include <import/ip_tproxy.h>
-
-/*
- * Checks that CTTPROXY is available and in the right version.
- * Returns 0 if OK, -1 if wrong version, -2 if not available or other error.
- */
-int check_cttproxy_version() {
-	struct in_tproxy itp1;
-	int fd, ret;
-
-	memset(&itp1, 0, sizeof(itp1));
-		
-	fd = socket(AF_INET, SOCK_STREAM, 0);
-	if (fd == -1)
-		return -2;
-
-	itp1.op = TPROXY_VERSION;
-	itp1.v.version = 0x02000000; /* CTTPROXY version 2.0 expected */
-
-	ret = 0;
-	if (setsockopt(fd, SOL_IP, IP_TPROXY, &itp1, sizeof(itp1)) == -1) {
-		if (errno == -EINVAL)
-			ret = -1; /* wrong version */
-		else
-			ret = -2; /* not supported or other error */
-	}
-	close(fd);
-	return ret;
-}
-
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/dumpstats.c b/deps/haproxy-1.4.21/src/dumpstats.c
deleted file mode 100644
index 0514c76..0000000
--- a/deps/haproxy-1.4.21/src/dumpstats.c
+++ /dev/null
@@ -1,3174 +0,0 @@
-/*
- * Functions dedicated to statistics output
- *
- * Copyright 2000-2009 Willy Tarreau <w@1wt.eu>
- * Copyright 2007-2009 Krzysztof Piotr Oledzki <ole@ans.pl>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <ctype.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <pwd.h>
-#include <grp.h>
-
-#include <sys/socket.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-
-#include <common/cfgparse.h>
-#include <common/compat.h>
-#include <common/config.h>
-#include <common/debug.h>
-#include <common/memory.h>
-#include <common/mini-clist.h>
-#include <common/standard.h>
-#include <common/ticks.h>
-#include <common/time.h>
-#include <common/uri_auth.h>
-#include <common/version.h>
-
-#include <types/global.h>
-
-#include <proto/backend.h>
-#include <proto/buffers.h>
-#include <proto/checks.h>
-#include <proto/dumpstats.h>
-#include <proto/fd.h>
-#include <proto/freq_ctr.h>
-#include <proto/pipe.h>
-#include <proto/proto_uxst.h>
-#include <proto/proxy.h>
-#include <proto/session.h>
-#include <proto/server.h>
-#include <proto/stream_interface.h>
-#include <proto/task.h>
-
-const char stats_sock_usage_msg[] =
-	"Unknown command. Please enter one of the following commands only :\n"
-	"  clear counters : clear max statistics counters (add 'all' for all counters)\n"
-	"  help           : this message\n"
-	"  prompt         : toggle interactive mode with prompt\n"
-	"  quit           : disconnect\n"
-	"  show info      : report information about the running process\n"
-	"  show stat      : report counters for each proxy and server\n"
-	"  show errors    : report last request and response errors for each proxy\n"
-	"  show sess [id] : report the list of current sessions or dump this session\n"
-	"  get weight     : report a server's current weight\n"
-	"  set weight     : change a server's weight\n"
-	"  set timeout    : change a timeout setting\n"
-	"  disable server : set a server in maintenance mode\n"
-	"  enable server  : re-enable a server that was previously in maintenance mode\n"
-	"";
-
-const char stats_permission_denied_msg[] =
-	"Permission denied\n"
-	"";
-
-/* allocate a new stats frontend named <name>, and return it
- * (or NULL in case of lack of memory).
- */
-static struct proxy *alloc_stats_fe(const char *name)
-{
-	struct proxy *fe;
-
-	fe = (struct proxy *)calloc(1, sizeof(struct proxy));
-	if (!fe)
-		return NULL;
-
-	LIST_INIT(&fe->pendconns);
-	LIST_INIT(&fe->acl);
-	LIST_INIT(&fe->block_cond);
-	LIST_INIT(&fe->redirect_rules);
-	LIST_INIT(&fe->mon_fail_cond);
-	LIST_INIT(&fe->switching_rules);
-	LIST_INIT(&fe->tcp_req.inspect_rules);
-
-	/* Timeouts are defined as -1, so we cannot use the zeroed area
-	 * as a default value.
-	 */
-	proxy_reset_timeouts(fe);
-
-	fe->last_change = now.tv_sec;
-	fe->id = strdup("GLOBAL");
-	fe->cap = PR_CAP_FE;
-	return fe;
-}
-
-/* This function parses a "stats" statement in the "global" section. It returns
- * -1 if there is any error, otherwise zero. If it returns -1, it may write an
- * error message into ther <err> buffer, for at most <errlen> bytes, trailing
- * zero included. The trailing '\n' must not be written. The function must be
- * called with <args> pointing to the first word after "stats".
- */
-static int stats_parse_global(char **args, int section_type, struct proxy *curpx,
-			      struct proxy *defpx, char *err, int errlen)
-{
-	args++;
-	if (!strcmp(args[0], "socket")) {
-		struct sockaddr_un *su;
-		int cur_arg;
-
-		if (*args[1] == 0) {
-			snprintf(err, errlen, "'stats socket' in global section expects a path to a UNIX socket");
-			return -1;
-		}
-
-		if (global.stats_sock.state != LI_NEW) {
-			snprintf(err, errlen, "'stats socket' already specified in global section");
-			return -1;
-		}
-
-		su = str2sun(args[1]);
-		if (!su) {
-			snprintf(err, errlen, "'stats socket' path would require truncation");
-			return -1;
-		}
-		memcpy(&global.stats_sock.addr, su, sizeof(struct sockaddr_un)); // guaranteed to fit
-
-		if (!global.stats_fe) {
-			if ((global.stats_fe = alloc_stats_fe("GLOBAL")) == NULL) {
-				snprintf(err, errlen, "out of memory");
-				return -1;
-			}
-			global.stats_fe->timeout.client = MS_TO_TICKS(10000); /* default timeout of 10 seconds */
-		}
-
-		global.stats_sock.state = LI_INIT;
-		global.stats_sock.options = LI_O_NONE;
-		global.stats_sock.accept = uxst_event_accept;
-		global.stats_sock.handler = process_session;
-		global.stats_sock.analysers = 0;
-		global.stats_sock.nice = -64;  /* we want to boost priority for local stats */
-		global.stats_sock.private = global.stats_fe; /* must point to the frontend */
-		global.stats_sock.perm.ux.level = ACCESS_LVL_OPER; /* default access level */
-		global.stats_sock.timeout = &global.stats_fe->timeout.client;
-
-		global.stats_sock.next  = global.stats_fe->listen;
-		global.stats_fe->listen = &global.stats_sock;
-
-		cur_arg = 2;
-		while (*args[cur_arg]) {
-			if (!strcmp(args[cur_arg], "uid")) {
-				global.stats_sock.perm.ux.uid = atol(args[cur_arg + 1]);
-				cur_arg += 2;
-			}
-			else if (!strcmp(args[cur_arg], "gid")) {
-				global.stats_sock.perm.ux.gid = atol(args[cur_arg + 1]);
-				cur_arg += 2;
-			}
-			else if (!strcmp(args[cur_arg], "mode")) {
-				global.stats_sock.perm.ux.mode = strtol(args[cur_arg + 1], NULL, 8);
-				cur_arg += 2;
-			}
-			else if (!strcmp(args[cur_arg], "user")) {
-				struct passwd *user;
-				user = getpwnam(args[cur_arg + 1]);
-				if (!user) {
-					snprintf(err, errlen, "unknown user '%s' in 'global' section ('stats user')",
-						 args[cur_arg + 1]);
-					return -1;
-				}
-				global.stats_sock.perm.ux.uid = user->pw_uid;
-				cur_arg += 2;
-			}
-			else if (!strcmp(args[cur_arg], "group")) {
-				struct group *group;
-				group = getgrnam(args[cur_arg + 1]);
-				if (!group) {
-					snprintf(err, errlen, "unknown group '%s' in 'global' section ('stats group')",
-						 args[cur_arg + 1]);
-					return -1;
-				}
-				global.stats_sock.perm.ux.gid = group->gr_gid;
-				cur_arg += 2;
-			}
-			else if (!strcmp(args[cur_arg], "level")) {
-				if (!strcmp(args[cur_arg+1], "user"))
-					global.stats_sock.perm.ux.level = ACCESS_LVL_USER;
-				else if (!strcmp(args[cur_arg+1], "operator"))
-					global.stats_sock.perm.ux.level = ACCESS_LVL_OPER;
-				else if (!strcmp(args[cur_arg+1], "admin"))
-					global.stats_sock.perm.ux.level = ACCESS_LVL_ADMIN;
-				else {
-					snprintf(err, errlen, "'stats socket level' only supports 'user', 'operator', and 'admin'");
-					return -1;
-				}
-				cur_arg += 2;
-			}
-			else {
-				snprintf(err, errlen, "'stats socket' only supports 'user', 'uid', 'group', 'gid', 'level', and 'mode'");
-				return -1;
-			}
-		}
-
-		uxst_add_listener(&global.stats_sock);
-		global.maxsock++;
-	}
-	else if (!strcmp(args[0], "timeout")) {
-		unsigned timeout;
-		const char *res = parse_time_err(args[1], &timeout, TIME_UNIT_MS);
-
-		if (res) {
-			snprintf(err, errlen, "unexpected character '%c' in 'stats timeout' in 'global' section", *res);
-			return -1;
-		}
-
-		if (!timeout) {
-			snprintf(err, errlen, "a positive value is expected for 'stats timeout' in 'global section'");
-			return -1;
-		}
-		if (!global.stats_fe) {
-			if ((global.stats_fe = alloc_stats_fe("GLOBAL")) == NULL) {
-				snprintf(err, errlen, "out of memory");
-				return -1;
-			}
-		}
-		global.stats_fe->timeout.client = MS_TO_TICKS(timeout);
-	}
-	else if (!strcmp(args[0], "maxconn")) {
-		int maxconn = atol(args[1]);
-
-		if (maxconn <= 0) {
-			snprintf(err, errlen, "a positive value is expected for 'stats maxconn' in 'global section'");
-			return -1;
-		}
-		global.maxsock -= global.stats_sock.maxconn;
-		global.stats_sock.maxconn = maxconn;
-		global.maxsock += global.stats_sock.maxconn;
-	}
-	else {
-		snprintf(err, errlen, "'stats' only supports 'socket', 'maxconn' and 'timeout' in 'global' section");
-		return -1;
-	}
-	return 0;
-}
-
-int print_csv_header(struct chunk *msg)
-{
-	return chunk_printf(msg,
-			    "# pxname,svname,"
-			    "qcur,qmax,"
-			    "scur,smax,slim,stot,"
-			    "bin,bout,"
-			    "dreq,dresp,"
-			    "ereq,econ,eresp,"
-			    "wretr,wredis,"
-			    "status,weight,act,bck,"
-			    "chkfail,chkdown,lastchg,downtime,qlimit,"
-			    "pid,iid,sid,throttle,lbtot,tracked,type,"
-			    "rate,rate_lim,rate_max,"
-			    "check_status,check_code,check_duration,"
-			    "hrsp_1xx,hrsp_2xx,hrsp_3xx,hrsp_4xx,hrsp_5xx,hrsp_other,hanafail,"
-			    "req_rate,req_rate_max,req_tot,"
-			    "cli_abrt,srv_abrt,"
-			    "\n");
-}
-
-/* Processes the stats interpreter on the statistics socket. This function is
- * called from an applet running in a stream interface. The function returns 1
- * if the request was understood, otherwise zero. It sets si->st0 to a value
- * designating the function which will have to process the request, which can
- * also be the print function to display the return message set into cli.msg.
- */
-int stats_sock_parse_request(struct stream_interface *si, char *line)
-{
-	struct session *s = si->private;
-	char *args[MAX_STATS_ARGS + 1];
-	int arg;
-
-	while (isspace((unsigned char)*line))
-		line++;
-
-	arg = 0;
-	args[arg] = line;
-
-	while (*line && arg < MAX_STATS_ARGS) {
-		if (isspace((unsigned char)*line)) {
-			*line++ = '\0';
-
-			while (isspace((unsigned char)*line))
-				line++;
-
-			args[++arg] = line;
-			continue;
-		}
-
-		line++;
-	}
-
-	while (++arg <= MAX_STATS_ARGS)
-		args[arg] = line;
-
-	s->data_ctx.stats.flags = 0;
-	if (strcmp(args[0], "show") == 0) {
-		if (strcmp(args[1], "stat") == 0) {
-			if (*args[2] && *args[3] && *args[4]) {
-				s->data_ctx.stats.flags |= STAT_BOUND;
-				s->data_ctx.stats.iid	= atoi(args[2]);
-				s->data_ctx.stats.type	= atoi(args[3]);
-				s->data_ctx.stats.sid	= atoi(args[4]);
-			}
-
-			s->data_ctx.stats.flags |= STAT_SHOW_STAT;
-			s->data_ctx.stats.flags |= STAT_FMT_CSV;
-			s->data_state = DATA_ST_INIT;
-			si->st0 = STAT_CLI_O_INFO; // stats_dump_raw_to_buffer
-		}
-		else if (strcmp(args[1], "info") == 0) {
-			s->data_ctx.stats.flags |= STAT_SHOW_INFO;
-			s->data_ctx.stats.flags |= STAT_FMT_CSV;
-			s->data_state = DATA_ST_INIT;
-			si->st0 = STAT_CLI_O_INFO; // stats_dump_raw_to_buffer
-		}
-		else if (strcmp(args[1], "sess") == 0) {
-			s->data_state = DATA_ST_INIT;
-			if (s->listener->perm.ux.level < ACCESS_LVL_OPER) {
-				s->data_ctx.cli.msg = stats_permission_denied_msg;
-				si->st0 = STAT_CLI_PRINT;
-				return 1;
-			}
-			if (*args[2])
-				s->data_ctx.sess.target = (void *)strtoul(args[2], NULL, 0);
-			else
-				s->data_ctx.sess.target = NULL;
-			s->data_ctx.sess.section = 0; /* start with session status */
-			s->data_ctx.sess.pos = 0;
-			si->st0 = STAT_CLI_O_SESS; // stats_dump_sess_to_buffer
-		}
-		else if (strcmp(args[1], "errors") == 0) {
-			if (s->listener->perm.ux.level < ACCESS_LVL_OPER) {
-				s->data_ctx.cli.msg = stats_permission_denied_msg;
-				si->st0 = STAT_CLI_PRINT;
-				return 1;
-			}
-			if (*args[2])
-				s->data_ctx.errors.iid	= atoi(args[2]);
-			else
-				s->data_ctx.errors.iid	= -1;
-			s->data_ctx.errors.px = NULL;
-			s->data_state = DATA_ST_INIT;
-			si->st0 = STAT_CLI_O_ERR; // stats_dump_errors_to_buffer
-		}
-		else { /* neither "stat" nor "info" nor "sess" nor "errors"*/
-			return 0;
-		}
-	}
-	else if (strcmp(args[0], "clear") == 0) {
-		if (strcmp(args[1], "counters") == 0) {
-			struct proxy *px;
-			struct server *sv;
-			struct listener *li;
-			int clrall = 0;
-
-			if (strcmp(args[2], "all") == 0)
-				clrall = 1;
-
-			/* check permissions */
-			if (s->listener->perm.ux.level < ACCESS_LVL_OPER ||
-			    (clrall && s->listener->perm.ux.level < ACCESS_LVL_ADMIN)) {
-				s->data_ctx.cli.msg = stats_permission_denied_msg;
-				si->st0 = STAT_CLI_PRINT;
-				return 1;
-			}
-
-			for (px = proxy; px; px = px->next) {
-				if (clrall)
-					memset(&px->counters, 0, sizeof(px->counters));
-				else {
-					px->counters.feconn_max = 0;
-					px->counters.beconn_max = 0;
-					px->counters.fe_rps_max = 0;
-					px->counters.fe_sps_max = 0;
-					px->counters.be_sps_max = 0;
-					px->counters.nbpend_max = 0;
-				}
-
-				for (sv = px->srv; sv; sv = sv->next)
-					if (clrall)
-						memset(&sv->counters, 0, sizeof(sv->counters));
-					else {
-						sv->counters.cur_sess_max = 0;
-						sv->counters.nbpend_max = 0;
-						sv->counters.sps_max = 0;
-					}
-
-				for (li = px->listen; li; li = li->next)
-					if (li->counters) {
-						if (clrall)
-							memset(li->counters, 0, sizeof(*li->counters));
-						else
-							li->counters->conn_max = 0;
-					}
-			}
-
-			return 1;
-		}
-		else {
-			return 0;
-		}
-	}
-	else if (strcmp(args[0], "get") == 0) {
-		if (strcmp(args[1], "weight") == 0) {
-			struct proxy *px;
-			struct server *sv;
-
-			/* split "backend/server" and make <line> point to server */
-			for (line = args[2]; *line; line++)
-				if (*line == '/') {
-					*line++ = '\0';
-					break;
-				}
-
-			if (!*line) {
-				s->data_ctx.cli.msg = "Require 'backend/server'.\n";
-				si->st0 = STAT_CLI_PRINT;
-				return 1;
-			}
-
-			if (!get_backend_server(args[2], line, &px, &sv)) {
-				s->data_ctx.cli.msg = px ? "No such server.\n" : "No such backend.\n";
-				si->st0 = STAT_CLI_PRINT;
-				return 1;
-			}
-
-			/* return server's effective weight at the moment */
-			snprintf(trash, trashlen, "%d (initial %d)\n", sv->uweight, sv->iweight);
-			buffer_feed(si->ib, trash);
-			return 1;
-		}
-		else { /* not "get weight" */
-			return 0;
-		}
-	}
-	else if (strcmp(args[0], "set") == 0) {
-		if (strcmp(args[1], "weight") == 0) {
-			struct proxy *px;
-			struct server *sv;
-			int w;
-
-			if (s->listener->perm.ux.level < ACCESS_LVL_ADMIN) {
-				s->data_ctx.cli.msg = stats_permission_denied_msg;
-				si->st0 = STAT_CLI_PRINT;
-				return 1;
-			}
-
-			/* split "backend/server" and make <line> point to server */
-			for (line = args[2]; *line; line++)
-				if (*line == '/') {
-					*line++ = '\0';
-					break;
-				}
-
-			if (!*line || !*args[3]) {
-				s->data_ctx.cli.msg = "Require 'backend/server' and 'weight' or 'weight%'.\n";
-				si->st0 = STAT_CLI_PRINT;
-				return 1;
-			}
-
-			if (!get_backend_server(args[2], line, &px, &sv)) {
-				s->data_ctx.cli.msg = px ? "No such server.\n" : "No such backend.\n";
-				si->st0 = STAT_CLI_PRINT;
-				return 1;
-			}
-
-			if (px->state == PR_STSTOPPED) {
-				s->data_ctx.cli.msg = "Proxy is disabled.\n";
-				si->st0 = STAT_CLI_PRINT;
-				return 1;
-			}
-
-			/* if the weight is terminated with '%', it is set relative to
-			 * the initial weight, otherwise it is absolute.
-			 */
-			w = atoi(args[3]);
-			if (strchr(args[3], '%') != NULL) {
-				if (w < 0 || w > 100) {
-					s->data_ctx.cli.msg = "Relative weight can only be set between 0 and 100% inclusive.\n";
-					si->st0 = STAT_CLI_PRINT;
-					return 1;
-				}
-				w = sv->iweight * w / 100;
-			}
-			else {
-				if (w < 0 || w > 256) {
-					s->data_ctx.cli.msg = "Absolute weight can only be between 0 and 256 inclusive.\n";
-					si->st0 = STAT_CLI_PRINT;
-					return 1;
-				}
-			}
-
-			if (w && w != sv->iweight && !(px->lbprm.algo & BE_LB_PROP_DYN)) {
-				s->data_ctx.cli.msg = "Backend is using a static LB algorithm and only accepts weights '0%' and '100%'.\n";
-				si->st0 = STAT_CLI_PRINT;
-				return 1;
-			}
-
-			sv->uweight = w;
-
-			if (px->lbprm.algo & BE_LB_PROP_DYN) {
-			/* we must take care of not pushing the server to full throttle during slow starts */
-				if ((sv->state & SRV_WARMINGUP) && (px->lbprm.algo & BE_LB_PROP_DYN))
-					sv->eweight = (BE_WEIGHT_SCALE * (now.tv_sec - sv->last_change) + sv->slowstart - 1) / sv->slowstart;
-				else
-					sv->eweight = BE_WEIGHT_SCALE;
-				sv->eweight *= sv->uweight;
-			} else {
-				sv->eweight = sv->uweight;
-			}
-
-			/* static LB algorithms are a bit harder to update */
-			if (px->lbprm.update_server_eweight)
-				px->lbprm.update_server_eweight(sv);
-			else if (sv->eweight) {
-				if (px->lbprm.set_server_status_up)
-					px->lbprm.set_server_status_up(sv);
-			}
-			else {
-				if (px->lbprm.set_server_status_down)
-					px->lbprm.set_server_status_down(sv);
-			}
-
-			return 1;
-		}
-		else if (strcmp(args[1], "timeout") == 0) {
-			if (strcmp(args[2], "cli") == 0) {
-				unsigned timeout;
-				const char *res;
-
-				if (!*args[3]) {
-					s->data_ctx.cli.msg = "Expects an integer value.\n";
-					si->st0 = STAT_CLI_PRINT;
-					return 1;
-				}
-
-				res = parse_time_err(args[3], &timeout, TIME_UNIT_S);
-				if (res || timeout < 1) {
-					s->data_ctx.cli.msg = "Invalid timeout value.\n";
-					si->st0 = STAT_CLI_PRINT;
-					return 1;
-				}
-
-				s->req->rto = s->rep->wto = 1 + MS_TO_TICKS(timeout*1000);
-				return 1;
-			}
-			else {
-				s->data_ctx.cli.msg = "'set timeout' only supports 'cli'.\n";
-				si->st0 = STAT_CLI_PRINT;
-				return 1;
-			}
-		}
-		else { /* unknown "set" parameter */
-			return 0;
-		}
-	}
-	else if (strcmp(args[0], "enable") == 0) {
-		if (strcmp(args[1], "server") == 0) {
-			struct proxy *px;
-			struct server *sv;
-
-			if (s->listener->perm.ux.level < ACCESS_LVL_ADMIN) {
-				s->data_ctx.cli.msg = stats_permission_denied_msg;
-				si->st0 = STAT_CLI_PRINT;
-				return 1;
-			}
-
-			/* split "backend/server" and make <line> point to server */
-			for (line = args[2]; *line; line++)
-				if (*line == '/') {
-					*line++ = '\0';
-					break;
-				}
-
-			if (!*line || !*args[2]) {
-				s->data_ctx.cli.msg = "Require 'backend/server'.\n";
-				si->st0 = STAT_CLI_PRINT;
-				return 1;
-			}
-
-			if (!get_backend_server(args[2], line, &px, &sv)) {
-				s->data_ctx.cli.msg = px ? "No such server.\n" : "No such backend.\n";
-				si->st0 = STAT_CLI_PRINT;
-				return 1;
-			}
-
-			if (px->state == PR_STSTOPPED) {
-				s->data_ctx.cli.msg = "Proxy is disabled.\n";
-				si->st0 = STAT_CLI_PRINT;
-				return 1;
-			}
-
-			if (sv->state & SRV_MAINTAIN) {
-				/* The server is really in maintenance, we can change the server state */
-				if (sv->tracked) {
-					/* If this server tracks the status of another one,
-					* we must restore the good status.
-					*/
-					if (sv->tracked->state & SRV_RUNNING) {
-						set_server_up(sv);
-						sv->health = sv->rise;	/* up, but will fall down at first failure */
-					} else {
-						sv->state &= ~SRV_MAINTAIN;
-						set_server_down(sv);
-					}
-				} else {
-					set_server_up(sv);
-					sv->health = sv->rise;	/* up, but will fall down at first failure */
-				}
-			}
-
-			return 1;
-		}
-		else { /* unknown "enable" parameter */
-			return 0;
-		}
-	}
-	else if (strcmp(args[0], "disable") == 0) {
-		if (strcmp(args[1], "server") == 0) {
-			struct proxy *px;
-			struct server *sv;
-
-			if (s->listener->perm.ux.level < ACCESS_LVL_ADMIN) {
-				s->data_ctx.cli.msg = stats_permission_denied_msg;
-				si->st0 = STAT_CLI_PRINT;
-				return 1;
-			}
-
-			/* split "backend/server" and make <line> point to server */
-			for (line = args[2]; *line; line++)
-				if (*line == '/') {
-					*line++ = '\0';
-					break;
-				}
-
-			if (!*line || !*args[2]) {
-				s->data_ctx.cli.msg = "Require 'backend/server'.\n";
-				si->st0 = STAT_CLI_PRINT;
-				return 1;
-			}
-
-			if (!get_backend_server(args[2], line, &px, &sv)) {
-				s->data_ctx.cli.msg = px ? "No such server.\n" : "No such backend.\n";
-				si->st0 = STAT_CLI_PRINT;
-				return 1;
-			}
-
-			if (px->state == PR_STSTOPPED) {
-				s->data_ctx.cli.msg = "Proxy is disabled.\n";
-				si->st0 = STAT_CLI_PRINT;
-				return 1;
-			}
-
-			if (! (sv->state & SRV_MAINTAIN)) {
-				/* Not already in maintenance, we can change the server state */
-				sv->state |= SRV_MAINTAIN;
-				set_server_down(sv);
-			}
-
-			return 1;
-		}
-		else { /* unknown "disable" parameter */
-			return 0;
-		}
-	}
-	else { /* not "show" nor "clear" nor "get" nor "set" nor "enable" nor "disable" */
-		return 0;
-	}
-	return 1;
-}
-
-/* This I/O handler runs as an applet embedded in a stream interface. It is
- * used to processes I/O from/to the stats unix socket. The system relies on a
- * state machine handling requests and various responses. We read a request,
- * then we process it and send the response, and we possibly display a prompt.
- * Then we can read again. The state is stored in si->st0 and is one of the
- * STAT_CLI_* constants. si->st1 is used to indicate whether prompt is enabled
- * or not.
- */
-void stats_io_handler(struct stream_interface *si)
-{
-	struct session *s = si->private;
-	struct buffer *req = si->ob;
-	struct buffer *res = si->ib;
-	int reql;
-	int len;
-
-	if (unlikely(si->state == SI_ST_DIS || si->state == SI_ST_CLO))
-		goto out;
-
-	while (1) {
-		if (si->st0 == STAT_CLI_INIT) {
-			/* Stats output not initialized yet */
-			memset(&s->data_ctx.stats, 0, sizeof(s->data_ctx.stats));
-			s->data_source = DATA_SRC_STATS;
-			si->st0 = STAT_CLI_GETREQ;
-		}
-		else if (si->st0 == STAT_CLI_END) {
-			/* Let's close for real now. We just close the request
-			 * side, the conditions below will complete if needed.
-			 */
-			si->shutw(si);
-			break;
-		}
-		else if (si->st0 == STAT_CLI_GETREQ) {
-			/* ensure we have some output room left in the event we
-			 * would want to return some info right after parsing.
-			 */
-			if (buffer_almost_full(si->ib))
-				break;
-
-			reql = buffer_si_peekline(si->ob, trash, trashlen);
-			if (reql <= 0) { /* closed or EOL not found */
-				if (reql == 0)
-					break;
-				si->st0 = STAT_CLI_END;
-				continue;
-			}
-
-			/* seek for a possible semi-colon. If we find one, we
-			 * replace it with an LF and skip only this part.
-			 */
-			for (len = 0; len < reql; len++)
-				if (trash[len] == ';') {
-					trash[len] = '\n';
-					reql = len + 1;
-					break;
-				}
-
-			/* now it is time to check that we have a full line,
-			 * remove the trailing \n and possibly \r, then cut the
-			 * line.
-			 */
-			len = reql - 1;
-			if (trash[len] != '\n') {
-				si->st0 = STAT_CLI_END;
-				continue;
-			}
-
-			if (len && trash[len-1] == '\r')
-				len--;
-
-			trash[len] = '\0';
-
-			si->st0 = STAT_CLI_PROMPT;
-			if (len) {
-				if (strcmp(trash, "quit") == 0) {
-					si->st0 = STAT_CLI_END;
-					continue;
-				}
-				else if (strcmp(trash, "prompt") == 0)
-					si->st1 = !si->st1;
-				else if (strcmp(trash, "help") == 0 ||
-					 !stats_sock_parse_request(si, trash)) {
-					s->data_ctx.cli.msg = stats_sock_usage_msg;
-					si->st0 = STAT_CLI_PRINT;
-				}
-				/* NB: stats_sock_parse_request() may have put
-				 * another STAT_CLI_O_* into si->st0.
-				 */
-			}
-			else if (!si->st1) {
-				/* if prompt is disabled, print help on empty lines,
-				 * so that the user at least knows how to enable
-				 * prompt and find help.
-				 */
-				s->data_ctx.cli.msg = stats_sock_usage_msg;
-				si->st0 = STAT_CLI_PRINT;
-			}
-
-			/* re-adjust req buffer */
-			buffer_skip(si->ob, reql);
-			req->flags |= BF_READ_DONTWAIT; /* we plan to read small requests */
-		}
-		else {	/* output functions: first check if the output buffer is closed then abort */
-			if (res->flags & (BF_SHUTR_NOW|BF_SHUTR)) {
-				si->st0 = STAT_CLI_END;
-				continue;
-			}
-
-			switch (si->st0) {
-			case STAT_CLI_PRINT:
-				if (buffer_feed(si->ib, s->data_ctx.cli.msg) < 0)
-					si->st0 = STAT_CLI_PROMPT;
-				break;
-			case STAT_CLI_O_INFO:
-				if (stats_dump_raw_to_buffer(s, res))
-					si->st0 = STAT_CLI_PROMPT;
-				break;
-			case STAT_CLI_O_SESS:
-				if (stats_dump_sess_to_buffer(s, res))
-					si->st0 = STAT_CLI_PROMPT;
-				break;
-			case STAT_CLI_O_ERR:	/* errors dump */
-				if (stats_dump_errors_to_buffer(s, res))
-					si->st0 = STAT_CLI_PROMPT;
-				break;
-			default: /* abnormal state */
-				si->st0 = STAT_CLI_PROMPT;
-				break;
-			}
-
-			/* The post-command prompt is either LF alone or LF + '> ' in interactive mode */
-			if (si->st0 == STAT_CLI_PROMPT) {
-				if (buffer_feed(si->ib, si->st1 ? "\n> " : "\n") < 0)
-					si->st0 = STAT_CLI_GETREQ;
-			}
-
-			/* If the output functions are still there, it means they require more room. */
-			if (si->st0 >= STAT_CLI_OUTPUT)
-				break;
-
-			/* Now we close the output if one of the writers did so,
-			 * or if we're not in interactive mode and the request
-			 * buffer is empty. This still allows pipelined requests
-			 * to be sent in non-interactive mode.
-			 */
-			if ((res->flags & (BF_SHUTW|BF_SHUTW_NOW)) || (!si->st1 && !req->send_max)) {
-				si->st0 = STAT_CLI_END;
-				continue;
-			}
-
-			/* switch state back to GETREQ to read next requests */
-			si->st0 = STAT_CLI_GETREQ;
-		}
-	}
-
-	if ((res->flags & BF_SHUTR) && (si->state == SI_ST_EST) && (si->st0 != STAT_CLI_GETREQ)) {
-		DPRINTF(stderr, "%s@%d: si to buf closed. req=%08x, res=%08x, st=%d\n",
-			__FUNCTION__, __LINE__, req->flags, res->flags, si->state);
-		/* Other size has closed, let's abort if we have no more processing to do
-		 * and nothing more to consume. This is comparable to a broken pipe, so
-		 * we forward the close to the request side so that it flows upstream to
-		 * the client.
-		 */
-		si->shutw(si);
-	}
-
-	if ((req->flags & BF_SHUTW) && (si->state == SI_ST_EST) && (si->st0 < STAT_CLI_OUTPUT)) {
-		DPRINTF(stderr, "%s@%d: buf to si closed. req=%08x, res=%08x, st=%d\n",
-			__FUNCTION__, __LINE__, req->flags, res->flags, si->state);
-		/* We have no more processing to do, and nothing more to send, and
-		 * the client side has closed. So we'll forward this state downstream
-		 * on the response buffer.
-		 */
-		si->shutr(si);
-		res->flags |= BF_READ_NULL;
-	}
-
-	/* update all other flags and resync with the other side */
-	si->update(si);
-
-	/* we don't want to expire timeouts while we're processing requests */
-	si->ib->rex = TICK_ETERNITY;
-	si->ob->wex = TICK_ETERNITY;
-
- out:
-	DPRINTF(stderr, "%s@%d: st=%d, rqf=%x, rpf=%x, rql=%d, rqs=%d, rl=%d, rs=%d\n",
-		__FUNCTION__, __LINE__,
-		si->state, req->flags, res->flags, req->l, req->send_max, res->l, res->send_max);
-
-	if (unlikely(si->state == SI_ST_DIS || si->state == SI_ST_CLO)) {
-		/* check that we have released everything then unregister */
-		stream_int_unregister_handler(si);
-	}
-}
-
-/* This function is called to send output to the response buffer.
- * It dumps statistics onto the output buffer <rep> owned by session <s>.
- * s->data_ctx must have been zeroed first, and the flags properly set.
- * It returns 0 as long as it does not complete, non-zero upon completion.
- * Some states are not used but it makes the code more similar to other
- * functions which handle stats too.
- */
-int stats_dump_raw_to_buffer(struct session *s, struct buffer *rep)
-{
-	struct proxy *px;
-	struct chunk msg;
-	unsigned int up;
-
-	chunk_init(&msg, trash, trashlen);
-
-	switch (s->data_state) {
-	case DATA_ST_INIT:
-		/* the function had not been called yet */
-		s->data_state = DATA_ST_HEAD;
-		/* fall through */
-
-	case DATA_ST_HEAD:
-		if (s->data_ctx.stats.flags & STAT_SHOW_STAT) {
-			print_csv_header(&msg);
-			if (buffer_feed_chunk(rep, &msg) >= 0)
-				return 0;
-		}
-
-		s->data_state = DATA_ST_INFO;
-		/* fall through */
-
-	case DATA_ST_INFO:
-		up = (now.tv_sec - start_date.tv_sec);
-		if (s->data_ctx.stats.flags & STAT_SHOW_INFO) {
-			chunk_printf(&msg,
-				     "Name: " PRODUCT_NAME "\n"
-				     "Version: " HAPROXY_VERSION "\n"
-				     "Release_date: " HAPROXY_DATE "\n"
-				     "Nbproc: %d\n"
-				     "Process_num: %d\n"
-				     "Pid: %d\n"
-				     "Uptime: %dd %dh%02dm%02ds\n"
-				     "Uptime_sec: %d\n"
-				     "Memmax_MB: %d\n"
-				     "Ulimit-n: %d\n"
-				     "Maxsock: %d\n"
-				     "Maxconn: %d\n"
-				     "Maxpipes: %d\n"
-				     "CurrConns: %d\n"
-				     "PipesUsed: %d\n"
-				     "PipesFree: %d\n"
-				     "Tasks: %d\n"
-				     "Run_queue: %d\n"
-				     "node: %s\n"
-				     "description: %s\n"
-				     "",
-				     global.nbproc,
-				     relative_pid,
-				     pid,
-				     up / 86400, (up % 86400) / 3600, (up % 3600) / 60, (up % 60),
-				     up,
-				     global.rlimit_memmax,
-				     global.rlimit_nofile,
-				     global.maxsock, global.maxconn, global.maxpipes,
-				     actconn, pipes_used, pipes_free,
-				     nb_tasks_cur, run_queue_cur,
-				     global.node, global.desc?global.desc:""
-				     );
-			if (buffer_feed_chunk(rep, &msg) >= 0)
-				return 0;
-		}
-
-		s->data_ctx.stats.px = proxy;
-		s->data_ctx.stats.px_st = DATA_ST_PX_INIT;
-
-		s->data_ctx.stats.sv = NULL;
-		s->data_ctx.stats.sv_st = 0;
-
-		s->data_state = DATA_ST_LIST;
-		/* fall through */
-
-	case DATA_ST_LIST:
-		/* dump proxies */
-		if (s->data_ctx.stats.flags & STAT_SHOW_STAT) {
-			while (s->data_ctx.stats.px) {
-				px = s->data_ctx.stats.px;
-				/* skip the disabled proxies and non-networked ones */
-				if (px->state != PR_STSTOPPED &&
-				    (px->cap & (PR_CAP_FE | PR_CAP_BE))) {
-					if (stats_dump_proxy(s, px, NULL) == 0)
-						return 0;
-				}
-
-				s->data_ctx.stats.px = px->next;
-				s->data_ctx.stats.px_st = DATA_ST_PX_INIT;
-			}
-			/* here, we just have reached the last proxy */
-		}
-
-		s->data_state = DATA_ST_END;
-		/* fall through */
-
-	case DATA_ST_END:
-		s->data_state = DATA_ST_FIN;
-		/* fall through */
-
-	case DATA_ST_FIN:
-		return 1;
-
-	default:
-		/* unknown state ! */
-		s->data_state = DATA_ST_FIN;
-		return 1;
-	}
-}
-
-
-/* We don't want to land on the posted stats page because a refresh will
- * repost the data.  We don't want this to happen on accident so we redirect
- * the browse to the stats page with a GET.
- */
-int stats_http_redir(struct session *s, struct buffer *rep, struct uri_auth *uri)
-{
-	struct chunk msg;
-
-	chunk_init(&msg, trash, trashlen);
-
-	switch (s->data_state) {
-	case DATA_ST_INIT:
-		chunk_printf(&msg,
-			"HTTP/1.0 303 See Other\r\n"
-			"Cache-Control: no-cache\r\n"
-			"Content-Type: text/plain\r\n"
-			"Connection: close\r\n"
-			"Location: %s;st=%s",
-			uri->uri_prefix, s->data_ctx.stats.st_code);
-		chunk_printf(&msg, "\r\n\r\n");
-
-		if (buffer_feed_chunk(rep, &msg) >= 0)
-			return 0;
-
-		s->txn.status = 303;
-
-		if (!(s->flags & SN_ERR_MASK))  // this is not really an error but it is
-			s->flags |= SN_ERR_PRXCOND; // to mark that it comes from the proxy
-		if (!(s->flags & SN_FINST_MASK))
-			s->flags |= SN_FINST_R;
-
-		s->data_state = DATA_ST_FIN;
-		return 1;
-	}
-	return 1;
-}
-
-
-/* This I/O handler runs as an applet embedded in a stream interface. It is
- * used to send HTTP stats over a TCP socket. The mechanism is very simple.
- * si->st0 becomes non-zero once the transfer is finished. The handler
- * automatically unregisters itself once transfer is complete.
- */
-void http_stats_io_handler(struct stream_interface *si)
-{
-	struct session *s = si->private;
-	struct buffer *req = si->ob;
-	struct buffer *res = si->ib;
-
-	if (unlikely(si->state == SI_ST_DIS || si->state == SI_ST_CLO))
-		goto out;
-
-	/* check that the output is not closed */
-	if (res->flags & (BF_SHUTW|BF_SHUTW_NOW))
-		si->st0 = 1;
-
-	if (!si->st0) {
-		if (s->txn.meth == HTTP_METH_POST) {
-			if (stats_http_redir(s, res, s->be->uri_auth)) {
-				si->st0 = 1;
-				si->shutw(si);
-			}
-		} else {
-			if (stats_dump_http(s, res, s->be->uri_auth)) {
-				si->st0 = 1;
-				si->shutw(si);
-			}
-		}
-	}
-
-	if ((res->flags & BF_SHUTR) && (si->state == SI_ST_EST))
-		si->shutw(si);
-
-	if ((req->flags & BF_SHUTW) && (si->state == SI_ST_EST) && si->st0) {
-		si->shutr(si);
-		res->flags |= BF_READ_NULL;
-	}
-
-	/* update all other flags and resync with the other side */
-	si->update(si);
-
-	/* we don't want to expire timeouts while we're processing requests */
-	si->ib->rex = TICK_ETERNITY;
-	si->ob->wex = TICK_ETERNITY;
-
- out:
-	if (unlikely(si->state == SI_ST_DIS || si->state == SI_ST_CLO)) {
-		/* check that we have released everything then unregister */
-		stream_int_unregister_handler(si);
-	}
-}
-
-
-/*
- * Produces statistics data for the session <s>. Expects to be called with
- * client socket shut down on input. It stops by itself by unsetting the
- * BF_HIJACK flag from the buffer, which it uses to keep on being called
- * when there is free space in the buffer, of simply by letting an empty buffer
- * upon return.s->data_ctx must have been zeroed before the first call, and the
- * flags set. It returns 0 if it had to stop writing data and an I/O is needed,
- * 1 if the dump is finished and the session must be closed, or -1 in case of
- * any error.
- */
-int stats_dump_http(struct session *s, struct buffer *rep, struct uri_auth *uri)
-{
-	struct proxy *px;
-	struct chunk msg;
-	unsigned int up;
-
-	chunk_init(&msg, trash, trashlen);
-
-	switch (s->data_state) {
-	case DATA_ST_INIT:
-		chunk_printf(&msg,
-			     "HTTP/1.0 200 OK\r\n"
-			     "Cache-Control: no-cache\r\n"
-			     "Connection: close\r\n"
-			     "Content-Type: %s\r\n",
-			     (s->data_ctx.stats.flags & STAT_FMT_CSV) ? "text/plain" : "text/html");
-
-		if (uri->refresh > 0 && !(s->data_ctx.stats.flags & STAT_NO_REFRESH))
-			chunk_printf(&msg, "Refresh: %d\r\n",
-				     uri->refresh);
-
-		chunk_printf(&msg, "\r\n");
-
-		s->txn.status = 200;
-		if (buffer_feed_chunk(rep, &msg) >= 0)
-			return 0;
-
-		if (!(s->flags & SN_ERR_MASK))  // this is not really an error but it is
-			s->flags |= SN_ERR_PRXCOND; // to mark that it comes from the proxy
-		if (!(s->flags & SN_FINST_MASK))
-			s->flags |= SN_FINST_R;
-
-		if (s->txn.meth == HTTP_METH_HEAD) {
-			/* that's all we return in case of HEAD request */
-			s->data_state = DATA_ST_FIN;
-			return 1;
-		}
-
-		s->data_state = DATA_ST_HEAD; /* let's start producing data */
-		/* fall through */
-
-	case DATA_ST_HEAD:
-		if (!(s->data_ctx.stats.flags & STAT_FMT_CSV)) {
-			/* WARNING! This must fit in the first buffer !!! */
-			chunk_printf(&msg,
-			     "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\n"
-			     "\"http://www.w3.org/TR/html4/loose.dtd\">\n"
-			     "<html><head><title>Statistics Report for " PRODUCT_NAME "%s%s</title>\n"
-			     "<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\">\n"
-			     "<style type=\"text/css\"><!--\n"
-			     "body {"
-			     " font-family: arial, helvetica, sans-serif;"
-			     " font-size: 12px;"
-			     " font-weight: normal;"
-			     " color: black;"
-			     " background: white;"
-			     "}\n"
-			     "th,td {"
-			     " font-size: 10px;"
-			     "}\n"
-			     "h1 {"
-			     " font-size: x-large;"
-			     " margin-bottom: 0.5em;"
-			     "}\n"
-			     "h2 {"
-			     " font-family: helvetica, arial;"
-			     " font-size: x-large;"
-			     " font-weight: bold;"
-			     " font-style: italic;"
-			     " color: #6020a0;"
-			     " margin-top: 0em;"
-			     " margin-bottom: 0em;"
-			     "}\n"
-			     "h3 {"
-			     " font-family: helvetica, arial;"
-			     " font-size: 16px;"
-			     " font-weight: bold;"
-			     " color: #b00040;"
-			     " background: #e8e8d0;"
-			     " margin-top: 0em;"
-			     " margin-bottom: 0em;"
-			     "}\n"
-			     "li {"
-			     " margin-top: 0.25em;"
-			     " margin-right: 2em;"
-			     "}\n"
-			     ".hr {margin-top: 0.25em;"
-			     " border-color: black;"
-			     " border-bottom-style: solid;"
-			     "}\n"
-			     ".titre	{background: #20D0D0;color: #000000; font-weight: bold; text-align: center;}\n"
-			     ".total	{background: #20D0D0;color: #ffff80;}\n"
-			     ".frontend	{background: #e8e8d0;}\n"
-			     ".socket	{background: #d0d0d0;}\n"
-			     ".backend	{background: #e8e8d0;}\n"
-			     ".active0	{background: #ff9090;}\n"
-			     ".active1	{background: #ffd020;}\n"
-			     ".active2	{background: #ffffa0;}\n"
-			     ".active3	{background: #c0ffc0;}\n"
-			     ".active4	{background: #ffffa0;}\n"  /* NOLB state shows same as going down */
-			     ".active5	{background: #a0e0a0;}\n"  /* NOLB state shows darker than up */
-			     ".active6	{background: #e0e0e0;}\n"
-			     ".backup0	{background: #ff9090;}\n"
-			     ".backup1	{background: #ff80ff;}\n"
-			     ".backup2	{background: #c060ff;}\n"
-			     ".backup3	{background: #b0d0ff;}\n"
-			     ".backup4	{background: #c060ff;}\n"  /* NOLB state shows same as going down */
-			     ".backup5	{background: #90b0e0;}\n"  /* NOLB state shows same as going down */
-			     ".backup6	{background: #e0e0e0;}\n"
-			     ".maintain	{background: #c07820;}\n"
-			     ".rls      {letter-spacing: 0.2em; margin-right: 1px;}\n" /* right letter spacing (used for grouping digits) */
-			     "\n"
-			     "a.px:link {color: #ffff40; text-decoration: none;}"
-			     "a.px:visited {color: #ffff40; text-decoration: none;}"
-			     "a.px:hover {color: #ffffff; text-decoration: none;}"
-			     "a.lfsb:link {color: #000000; text-decoration: none;}"
-			     "a.lfsb:visited {color: #000000; text-decoration: none;}"
-			     "a.lfsb:hover {color: #505050; text-decoration: none;}"
-			     "\n"
-			     "table.tbl { border-collapse: collapse; border-style: none;}\n"
-			     "table.tbl td { text-align: right; border-width: 1px 1px 1px 1px; border-style: solid solid solid solid; padding: 2px 3px; border-color: gray; white-space: nowrap;}\n"
-			     "table.tbl td.ac { text-align: center;}\n"
-			     "table.tbl th { border-width: 1px; border-style: solid solid solid solid; border-color: gray;}\n"
-			     "table.tbl th.pxname { background: #b00040; color: #ffff40; font-weight: bold; border-style: solid solid none solid; padding: 2px 3px; white-space: nowrap;}\n"
-			     "table.tbl th.empty { border-style: none; empty-cells: hide; background: white;}\n"
-			     "table.tbl th.desc { background: white; border-style: solid solid none solid; text-align: left; padding: 2px 3px;}\n"
-			     "\n"
-			     "table.lgd { border-collapse: collapse; border-width: 1px; border-style: none none none solid; border-color: black;}\n"
-			     "table.lgd td { border-width: 1px; border-style: solid solid solid solid; border-color: gray; padding: 2px;}\n"
-			     "table.lgd td.noborder { border-style: none; padding: 2px; white-space: nowrap;}\n"
-			     "u {text-decoration:none; border-bottom: 1px dotted black;}\n"
-			     "-->\n"
-			     "</style></head>\n",
-			     (uri->flags&ST_SHNODE) ? " on " : "",
-			     (uri->flags&ST_SHNODE) ? (uri->node ? uri->node : global.node) : ""
-			     );
-		} else {
-			print_csv_header(&msg);
-		}
-		if (buffer_feed_chunk(rep, &msg) >= 0)
-			return 0;
-
-		s->data_state = DATA_ST_INFO;
-		/* fall through */
-
-	case DATA_ST_INFO:
-		up = (now.tv_sec - start_date.tv_sec);
-
-		/* WARNING! this has to fit the first packet too.
-			 * We are around 3.5 kB, add adding entries will
-			 * become tricky if we want to support 4kB buffers !
-			 */
-		if (!(s->data_ctx.stats.flags & STAT_FMT_CSV)) {
-			chunk_printf(&msg,
-			     "<body><h1><a href=\"" PRODUCT_URL "\" style=\"text-decoration: none;\">"
-			     PRODUCT_NAME "%s</a></h1>\n"
-			     "<h2>Statistics Report for pid %d%s%s%s%s</h2>\n"
-			     "<hr width=\"100%%\" class=\"hr\">\n"
-			     "<h3>&gt; General process information</h3>\n"
-			     "<table border=0><tr><td align=\"left\" nowrap width=\"1%%\">\n"
-			     "<p><b>pid = </b> %d (process #%d, nbproc = %d)<br>\n"
-			     "<b>uptime = </b> %dd %dh%02dm%02ds<br>\n"
-			     "<b>system limits:</b> memmax = %s%s; ulimit-n = %d<br>\n"
-			     "<b>maxsock = </b> %d; <b>maxconn = </b> %d; <b>maxpipes = </b> %d<br>\n"
-			     "current conns = %d; current pipes = %d/%d<br>\n"
-			     "Running tasks: %d/%d<br>\n"
-			     "</td><td align=\"center\" nowrap>\n"
-			     "<table class=\"lgd\"><tr>\n"
-			     "<td class=\"active3\">&nbsp;</td><td class=\"noborder\">active UP </td>"
-			     "<td class=\"backup3\">&nbsp;</td><td class=\"noborder\">backup UP </td>"
-			     "</tr><tr>\n"
-			     "<td class=\"active2\"></td><td class=\"noborder\">active UP, going down </td>"
-			     "<td class=\"backup2\"></td><td class=\"noborder\">backup UP, going down </td>"
-			     "</tr><tr>\n"
-			     "<td class=\"active1\"></td><td class=\"noborder\">active DOWN, going up </td>"
-			     "<td class=\"backup1\"></td><td class=\"noborder\">backup DOWN, going up </td>"
-			     "</tr><tr>\n"
-			     "<td class=\"active0\"></td><td class=\"noborder\">active or backup DOWN &nbsp;</td>"
-			     "<td class=\"active6\"></td><td class=\"noborder\">not checked </td>"
-			     "</tr><tr>\n"
-			     "<td class=\"maintain\"></td><td class=\"noborder\" colspan=\"3\">active or backup DOWN for maintenance (MAINT) &nbsp;</td>"
-			     "</tr></table>\n"
-			     "Note: UP with load-balancing disabled is reported as \"NOLB\"."
-			     "</td>"
-			     "<td align=\"left\" valign=\"top\" nowrap width=\"1%%\">"
-			     "<b>Display option:</b><ul style=\"margin-top: 0.25em;\">"
-			     "",
-			     (uri->flags&ST_HIDEVER)?"":(STATS_VERSION_STRING),
-			     pid, (uri->flags&ST_SHNODE) ? " on " : "", (uri->flags&ST_SHNODE) ? (uri->node ? uri->node : global.node) : "",
-			     (uri->flags&ST_SHDESC)? ": " : "", (uri->flags&ST_SHDESC) ? (uri->desc ? uri->desc : global.desc) : "",
-			     pid, relative_pid, global.nbproc,
-			     up / 86400, (up % 86400) / 3600,
-			     (up % 3600) / 60, (up % 60),
-			     global.rlimit_memmax ? ultoa(global.rlimit_memmax) : "unlimited",
-			     global.rlimit_memmax ? " MB" : "",
-			     global.rlimit_nofile,
-			     global.maxsock, global.maxconn, global.maxpipes,
-			     actconn, pipes_used, pipes_used+pipes_free,
-			     run_queue_cur, nb_tasks_cur
-			     );
-
-			if (s->data_ctx.stats.flags & STAT_HIDE_DOWN)
-				chunk_printf(&msg,
-				     "<li><a href=\"%s%s%s\">Show all servers</a><br>\n",
-				     uri->uri_prefix,
-				     "",
-				     (s->data_ctx.stats.flags & STAT_NO_REFRESH) ? ";norefresh" : "");
-			else
-				chunk_printf(&msg,
-				     "<li><a href=\"%s%s%s\">Hide 'DOWN' servers</a><br>\n",
-				     uri->uri_prefix,
-				     ";up",
-				     (s->data_ctx.stats.flags & STAT_NO_REFRESH) ? ";norefresh" : "");
-
-			if (uri->refresh > 0) {
-				if (s->data_ctx.stats.flags & STAT_NO_REFRESH)
-					chunk_printf(&msg,
-					     "<li><a href=\"%s%s%s\">Enable refresh</a><br>\n",
-					     uri->uri_prefix,
-					     (s->data_ctx.stats.flags & STAT_HIDE_DOWN) ? ";up" : "",
-					     "");
-				else
-					chunk_printf(&msg,
-					     "<li><a href=\"%s%s%s\">Disable refresh</a><br>\n",
-					     uri->uri_prefix,
-					     (s->data_ctx.stats.flags & STAT_HIDE_DOWN) ? ";up" : "",
-					     ";norefresh");
-			}
-
-			chunk_printf(&msg,
-			     "<li><a href=\"%s%s%s\">Refresh now</a><br>\n",
-			     uri->uri_prefix,
-			     (s->data_ctx.stats.flags & STAT_HIDE_DOWN) ? ";up" : "",
-			     (s->data_ctx.stats.flags & STAT_NO_REFRESH) ? ";norefresh" : "");
-
-			chunk_printf(&msg,
-			     "<li><a href=\"%s;csv%s\">CSV export</a><br>\n",
-			     uri->uri_prefix,
-			     (uri->refresh > 0) ? ";norefresh" : "");
-
-			chunk_printf(&msg,
-			     "</ul></td>"
-			     "<td align=\"left\" valign=\"top\" nowrap width=\"1%%\">"
-			     "<b>External resources:</b><ul style=\"margin-top: 0.25em;\">\n"
-			     "<li><a href=\"" PRODUCT_URL "\">Primary site</a><br>\n"
-			     "<li><a href=\"" PRODUCT_URL_UPD "\">Updates (v" PRODUCT_BRANCH ")</a><br>\n"
-			     "<li><a href=\"" PRODUCT_URL_DOC "\">Online manual</a><br>\n"
-			     "</ul>"
-			     "</td>"
-			     "</tr></table>\n"
-			     ""
-			     );
-
-			if (s->data_ctx.stats.st_code) {
-				if (strcmp(s->data_ctx.stats.st_code, STAT_STATUS_DONE) == 0) {
-					chunk_printf(&msg,
-						     "<p><div class=active3>"
-						     "<a class=lfsb href=\"%s\" title=\"Remove this message\">[X]</a> "
-						     "Action processed successfully."
-						     "</div>\n", uri->uri_prefix);
-				}
-				else if (strcmp(s->data_ctx.stats.st_code, STAT_STATUS_NONE) == 0) {
-					chunk_printf(&msg,
-						     "<p><div class=active2>"
-						     "<a class=lfsb href=\"%s\" title=\"Remove this message\">[X]</a> "
-						     "Nothing has changed."
-						     "</div>\n", uri->uri_prefix);
-				}
-				else if (strcmp(s->data_ctx.stats.st_code, STAT_STATUS_PART) == 0) {
-					chunk_printf(&msg,
-						     "<p><div class=active2>"
-						     "<a class=lfsb href=\"%s\" title=\"Remove this message\">[X]</a> "
-						     "Action partially processed.<br>"
-						     "Some server names are probably unknown or ambiguous (duplicated names in the backend)."
-						     "</div>\n", uri->uri_prefix);
-				}
-				else if (strcmp(s->data_ctx.stats.st_code, STAT_STATUS_ERRP) == 0) {
-					chunk_printf(&msg,
-						     "<p><div class=active0>"
-						     "<a class=lfsb href=\"%s\" title=\"Remove this message\">[X]</a> "
-						     "Action not processed because of invalid parameters."
-						     "<ul>"
-						     "<li>The action is maybe unknown.</li>"
-						     "<li>The backend name is probably unknown or ambiguous (duplicated names).</li>"
-						     "<li>Some server names are probably unknown or ambiguous (duplicated names in the backend).</li>"
-						     "</ul>"
-						     "</div>\n", uri->uri_prefix);
-				}
-				else if (strcmp(s->data_ctx.stats.st_code, STAT_STATUS_EXCD) == 0) {
-					chunk_printf(&msg,
-						     "<p><div class=active0>"
-						     "<a class=lfsb href=\"%s\" title=\"Remove this message\">[X]</a> "
-						     "<b>Action not processed : the buffer couldn't store all the data.<br>"
-						     "You should retry with less servers at a time.</b>"
-						     "</div>\n", uri->uri_prefix);
-				}
-				else if (strcmp(s->data_ctx.stats.st_code, STAT_STATUS_DENY) == 0) {
-					chunk_printf(&msg,
-						     "<p><div class=active0>"
-						     "<a class=lfsb href=\"%s\" title=\"Remove this message\">[X]</a> "
-						     "<b>Action denied.</b>"
-						     "</div>\n", uri->uri_prefix);
-				}
-				else {
-					chunk_printf(&msg,
-						     "<p><div class=active6>"
-						     "<a class=lfsb href=\"%s\" title=\"Remove this message\">[X]</a> "
-						     "Unexpected result."
-						     "</div>\n", uri->uri_prefix);
-				}
-				chunk_printf(&msg,"<p>\n");
-			}
-
-			if (buffer_feed_chunk(rep, &msg) >= 0)
-				return 0;
-		}
-
-		s->data_ctx.stats.px = proxy;
-		s->data_ctx.stats.px_st = DATA_ST_PX_INIT;
-		s->data_state = DATA_ST_LIST;
-		/* fall through */
-
-	case DATA_ST_LIST:
-		/* dump proxies */
-		while (s->data_ctx.stats.px) {
-			if (buffer_almost_full(rep))
-				return 0;
-			px = s->data_ctx.stats.px;
-			/* skip the disabled proxies and non-networked ones */
-			if (px->state != PR_STSTOPPED && (px->cap & (PR_CAP_FE | PR_CAP_BE)))
-				if (stats_dump_proxy(s, px, uri) == 0)
-					return 0;
-
-			s->data_ctx.stats.px = px->next;
-			s->data_ctx.stats.px_st = DATA_ST_PX_INIT;
-		}
-		/* here, we just have reached the last proxy */
-
-		s->data_state = DATA_ST_END;
-		/* fall through */
-
-	case DATA_ST_END:
-		if (!(s->data_ctx.stats.flags & STAT_FMT_CSV)) {
-			chunk_printf(&msg, "</body></html>\n");
-			if (buffer_feed_chunk(rep, &msg) >= 0)
-				return 0;
-		}
-
-		s->data_state = DATA_ST_FIN;
-		/* fall through */
-
-	case DATA_ST_FIN:
-		return 1;
-
-	default:
-		/* unknown state ! */
-		s->data_state = DATA_ST_FIN;
-		return -1;
-	}
-}
-
-
-/*
- * Dumps statistics for a proxy.
- * Returns 0 if it had to stop dumping data because of lack of buffer space,
- * ot non-zero if everything completed.
- */
-int stats_dump_proxy(struct session *s, struct proxy *px, struct uri_auth *uri)
-{
-	struct buffer *rep = s->rep;
-	struct server *sv, *svs;	/* server and server-state, server-state=server or server->tracked */
-	struct listener *l;
-	struct chunk msg;
-
-	chunk_init(&msg, trash, trashlen);
-
-	switch (s->data_ctx.stats.px_st) {
-	case DATA_ST_PX_INIT:
-		/* we are on a new proxy */
-
-		if (uri && uri->scope) {
-			/* we have a limited scope, we have to check the proxy name */
-			struct stat_scope *scope;
-			int len;
-
-			len = strlen(px->id);
-			scope = uri->scope;
-
-			while (scope) {
-				/* match exact proxy name */
-				if (scope->px_len == len && !memcmp(px->id, scope->px_id, len))
-					break;
-
-				/* match '.' which means 'self' proxy */
-				if (!strcmp(scope->px_id, ".") && px == s->be)
-					break;
-				scope = scope->next;
-			}
-
-			/* proxy name not found : don't dump anything */
-			if (scope == NULL)
-				return 1;
-		}
-
-		if ((s->data_ctx.stats.flags & STAT_BOUND) && (s->data_ctx.stats.iid != -1) &&
-			(px->uuid != s->data_ctx.stats.iid))
-			return 1;
-
-		s->data_ctx.stats.px_st = DATA_ST_PX_TH;
-		/* fall through */
-
-	case DATA_ST_PX_TH:
-		if (!(s->data_ctx.stats.flags & STAT_FMT_CSV)) {
-			if (px->cap & PR_CAP_BE && px->srv && (s->data_ctx.stats.flags & STAT_ADMIN)) {
-				/* A form to enable/disable this proxy servers */
-				chunk_printf(&msg,
-					"<form action=\"%s\" method=\"post\">",
-					uri->uri_prefix);
-			}
-
-			/* print a new table */
-			chunk_printf(&msg,
-				     "<table class=\"tbl\" width=\"100%%\">\n"
-				     "<tr class=\"titre\">"
-				     "<th class=\"pxname\" width=\"10%%\"");
-
-			if (uri->flags&ST_SHLGNDS) {
-				/* cap, mode, id */
-				chunk_printf(&msg, " title=\"cap: %s, mode: %s, id: %d",
-					proxy_cap_str(px->cap), proxy_mode_str(px->mode),
-					px->uuid);
-
-				chunk_printf(&msg, "\"");
-			}
-
-			chunk_printf(&msg,
-				     ">%s<a name=\"%s\"></a>"
-				     "<a class=px href=\"#%s\">%s</a>%s</th>"
-				     "<th class=\"%s\" width=\"90%%\">%s</th>"
-				     "</tr>\n"
-				     "</table>\n"
-				     "<table class=\"tbl\" width=\"100%%\">\n"
-				     "<tr class=\"titre\">",
-				     (uri->flags & ST_SHLGNDS)?"<u>":"",
-				     px->id, px->id, px->id,
-				     (uri->flags & ST_SHLGNDS)?"</u>":"",
-				     px->desc ? "desc" : "empty", px->desc ? px->desc : "");
-
-			if (px->cap & PR_CAP_BE && px->srv && (s->data_ctx.stats.flags & STAT_ADMIN)) {
-				 /* Column heading for Enable or Disable server */
-				chunk_printf(&msg, "<th rowspan=2 width=1></th>");
-			}
-
-			chunk_printf(&msg,
-				     "<th rowspan=2></th>"
-				     "<th colspan=3>Queue</th>"
-				     "<th colspan=3>Session rate</th><th colspan=5>Sessions</th>"
-				     "<th colspan=2>Bytes</th><th colspan=2>Denied</th>"
-				     "<th colspan=3>Errors</th><th colspan=2>Warnings</th>"
-				     "<th colspan=9>Server</th>"
-				     "</tr>\n"
-				     "<tr class=\"titre\">"
-				     "<th>Cur</th><th>Max</th><th>Limit</th>"
-				     "<th>Cur</th><th>Max</th><th>Limit</th><th>Cur</th><th>Max</th>"
-				     "<th>Limit</th><th>Total</th><th>LbTot</th><th>In</th><th>Out</th>"
-				     "<th>Req</th><th>Resp</th><th>Req</th><th>Conn</th>"
-				     "<th>Resp</th><th>Retr</th><th>Redis</th>"
-				     "<th>Status</th><th>LastChk</th><th>Wght</th><th>Act</th>"
-				     "<th>Bck</th><th>Chk</th><th>Dwn</th><th>Dwntme</th>"
-				     "<th>Thrtle</th>\n"
-				     "</tr>");
-
-			if (buffer_feed_chunk(rep, &msg) >= 0)
-				return 0;
-		}
-
-		s->data_ctx.stats.px_st = DATA_ST_PX_FE;
-		/* fall through */
-
-	case DATA_ST_PX_FE:
-		/* print the frontend */
-		if ((px->cap & PR_CAP_FE) &&
-		    (!(s->data_ctx.stats.flags & STAT_BOUND) || (s->data_ctx.stats.type & (1 << STATS_TYPE_FE)))) {
-			if (!(s->data_ctx.stats.flags & STAT_FMT_CSV)) {
-				chunk_printf(&msg,
-				     /* name, queue */
-				     "<tr class=\"frontend\">");
-
-				if (px->cap & PR_CAP_BE && px->srv && (s->data_ctx.stats.flags & STAT_ADMIN)) {
-					/* Column sub-heading for Enable or Disable server */
-					chunk_printf(&msg, "<td></td>");
-				}
-
-				chunk_printf(&msg,
-				     "<td class=ac>"
-				     "<a name=\"%s/Frontend\"></a>"
-				     "<a class=lfsb href=\"#%s/Frontend\">Frontend</a></td>"
-				     "<td colspan=3></td>"
-				     "",
-				     px->id, px->id);
-
-				if (px->mode == PR_MODE_HTTP) {
-					chunk_printf(&msg,
-						     /* sessions rate : current, max, limit */
-						     "<td title=\"Cur: %u req/s\"><u>%s</u></td><td title=\"Max: %u req/s\"><u>%s</u></td><td>%s</td>"
-						     "",
-						     read_freq_ctr(&px->fe_req_per_sec),
-						     U2H0(read_freq_ctr(&px->fe_sess_per_sec)),
-						     px->counters.fe_rps_max,
-						     U2H1(px->counters.fe_sps_max),
-						     LIM2A2(px->fe_sps_lim, "-"));
-				} else {
-					chunk_printf(&msg,
-						     /* sessions rate : current, max, limit */
-						     "<td>%s</td><td>%s</td><td>%s</td>"
-						     "",
-						     U2H0(read_freq_ctr(&px->fe_sess_per_sec)),
-						     U2H1(px->counters.fe_sps_max), LIM2A2(px->fe_sps_lim, "-"));
-				}
-
-				chunk_printf(&msg,
-				     /* sessions: current, max, limit */
-				     "<td>%s</td><td>%s</td><td>%s</td>"
-				     "<td"
-				     "",
-				     U2H3(px->feconn), U2H4(px->counters.feconn_max), U2H5(px->maxconn));
-
-				/* http response (via td title): 1xx, 2xx, 3xx, 4xx, 5xx, other */
-				if (px->mode == PR_MODE_HTTP) {
-					int i;
-
-					chunk_printf(&msg, " title=\"%lld requests:", px->counters.cum_fe_req);
-
-					for (i = 1; i < 6; i++)
-						chunk_printf(&msg, " %dxx=%lld,", i, px->counters.fe.http.rsp[i]);
-
-					chunk_printf(&msg, " other=%lld\"", px->counters.fe.http.rsp[0]);
-				}
-
-				chunk_printf(&msg,
-				     /* sessions: total, lbtot */
-				     ">%s%s%s</td><td></td>"
-				     /* bytes : in, out */
-				     "<td>%s</td><td>%s</td>"
-				     "",
-				     (px->mode == PR_MODE_HTTP)?"<u>":"",
-				     U2H6(px->counters.cum_feconn),
-				     (px->mode == PR_MODE_HTTP)?"</u>":"",
-				     U2H7(px->counters.bytes_in), U2H8(px->counters.bytes_out));
-
-				chunk_printf(&msg,
-				     /* denied: req, resp */
-				     "<td>%s</td><td>%s</td>"
-				     /* errors : request, connect, response */
-				     "<td>%s</td><td></td><td></td>"
-				     /* warnings: retries, redispatches */
-				     "<td></td><td></td>"
-				     /* server status : reflect frontend status */
-				     "<td class=ac>%s</td>"
-				     /* rest of server: nothing */
-				     "<td class=ac colspan=8></td></tr>"
-				     "",
-				     U2H0(px->counters.denied_req), U2H1(px->counters.denied_resp),
-				     U2H2(px->counters.failed_req),
-				     px->state == PR_STRUN ? "OPEN" :
-				     px->state == PR_STIDLE ? "FULL" : "STOP");
-			} else {
-				chunk_printf(&msg,
-				     /* pxid, name, queue cur, queue max, */
-				     "%s,FRONTEND,,,"
-				     /* sessions : current, max, limit, total */
-				     "%d,%d,%d,%lld,"
-				     /* bytes : in, out */
-				     "%lld,%lld,"
-				     /* denied: req, resp */
-				     "%lld,%lld,"
-				     /* errors : request, connect, response */
-				     "%lld,,,"
-				     /* warnings: retries, redispatches */
-				     ",,"
-				     /* server status : reflect frontend status */
-				     "%s,"
-				     /* rest of server: nothing */
-				     ",,,,,,,,"
-				     /* pid, iid, sid, throttle, lbtot, tracked, type */
-				     "%d,%d,0,,,,%d,"
-				     /* rate, rate_lim, rate_max */
-				     "%u,%u,%u,"
-				     /* check_status, check_code, check_duration */
-				     ",,,",
-				     px->id,
-				     px->feconn, px->counters.feconn_max, px->maxconn, px->counters.cum_feconn,
-				     px->counters.bytes_in, px->counters.bytes_out,
-				     px->counters.denied_req, px->counters.denied_resp,
-				     px->counters.failed_req,
-				     px->state == PR_STRUN ? "OPEN" :
-				     px->state == PR_STIDLE ? "FULL" : "STOP",
-				     relative_pid, px->uuid, STATS_TYPE_FE,
-				     read_freq_ctr(&px->fe_sess_per_sec),
-				     px->fe_sps_lim, px->counters.fe_sps_max);
-
-				/* http response: 1xx, 2xx, 3xx, 4xx, 5xx, other */
-				if (px->mode == PR_MODE_HTTP) {
-					int i;
-
-					for (i=1; i<6; i++)
-						chunk_printf(&msg, "%lld,", px->counters.fe.http.rsp[i]);
-
-					chunk_printf(&msg, "%lld,", px->counters.fe.http.rsp[0]);
-				} else {
-					chunk_printf(&msg, ",,,,,,");
-				}
-
-				/* failed health analyses */
-				chunk_printf(&msg, ",");
-
-				/* requests : req_rate, req_rate_max, req_tot, */
-				chunk_printf(&msg, "%u,%u,%lld,",
-					     read_freq_ctr(&px->fe_req_per_sec),
-					     px->counters.fe_rps_max, px->counters.cum_fe_req);
-
-				/* errors: cli_aborts, srv_aborts */
-				chunk_printf(&msg, ",,");
-
-				/* finish with EOL */
-				chunk_printf(&msg, "\n");
-			}
-
-			if (buffer_feed_chunk(rep, &msg) >= 0)
-				return 0;
-		}
-
-		s->data_ctx.stats.l = px->listen; /* may be NULL */
-		s->data_ctx.stats.px_st = DATA_ST_PX_LI;
-		/* fall through */
-
-	case DATA_ST_PX_LI:
-		/* stats.l has been initialized above */
-		for (; s->data_ctx.stats.l != NULL; s->data_ctx.stats.l = l->next) {
-			if (buffer_almost_full(rep))
-				return 0;
-
-			l = s->data_ctx.stats.l;
-			if (!l->counters)
-				continue;
-
-			if (s->data_ctx.stats.flags & STAT_BOUND) {
-				if (!(s->data_ctx.stats.type & (1 << STATS_TYPE_SO)))
-					break;
-
-				if (s->data_ctx.stats.sid != -1 && l->luid != s->data_ctx.stats.sid)
-					continue;
-			}
-
-			if (!(s->data_ctx.stats.flags & STAT_FMT_CSV)) {
-				chunk_printf(&msg, "<tr class=socket>");
-				if (px->cap & PR_CAP_BE && px->srv && (s->data_ctx.stats.flags & STAT_ADMIN)) {
-					 /* Column sub-heading for Enable or Disable server */
-					chunk_printf(&msg, "<td></td>");
-				}
-				chunk_printf(&msg, "<td class=ac");
-
-					if (uri->flags&ST_SHLGNDS) {
-						char str[INET6_ADDRSTRLEN], *fmt = NULL;
-						int port;
-
-						chunk_printf(&msg, " title=\"IP: ");
-
-						port = (l->addr.ss_family == AF_INET6)
-							? ntohs(((struct sockaddr_in6 *)(&l->addr))->sin6_port)
-							: ntohs(((struct sockaddr_in *)(&l->addr))->sin_port);
-
-						if (l->addr.ss_family == AF_INET) {
-							if (inet_ntop(AF_INET,
-							    (const void *)&((struct sockaddr_in *)&l->addr)->sin_addr,
-							    str, sizeof(str)))
-								fmt = "%s:%d";
-						} else {
-							if (inet_ntop(AF_INET6,
-							    (const void *)&((struct sockaddr_in6 *)(&l->addr))->sin6_addr,
-							    str, sizeof(str)))
-								fmt = "[%s]:%d";
-						}
-
-						if (fmt)
-							chunk_printf(&msg, fmt, str, port);
-						else
-							chunk_printf(&msg, "(%s)", strerror(errno));
-
-						/* id */
-						chunk_printf(&msg, ", id: %d", l->luid);
-
-						chunk_printf(&msg, "\"");
-					}
-
-				chunk_printf(&msg,
-				     /* name, queue */
-				     ">%s<a name=\"%s/+%s\"></a>"
-				     "<a class=lfsb href=\"#%s/+%s\">%s</a></td><td colspan=3>%s</td>"
-				     /* sessions rate: current, max, limit */
-				     "<td colspan=3>&nbsp;</td>"
-				     /* sessions: current, max, limit, total, lbtot */
-				     "<td>%s</td><td>%s</td><td>%s</td>"
-				     "<td>%s</td><td>&nbsp;</td>"
-				     /* bytes: in, out */
-				     "<td>%s</td><td>%s</td>"
-				     "",
-				     (uri->flags & ST_SHLGNDS)?"<u>":"",
-				     px->id, l->name, px->id, l->name, l->name,
-				     (uri->flags & ST_SHLGNDS)?"</u>":"",
-				     U2H3(l->nbconn), U2H4(l->counters->conn_max), U2H5(l->maxconn),
-				     U2H6(l->counters->cum_conn), U2H7(l->counters->bytes_in), U2H8(l->counters->bytes_out));
-
-				chunk_printf(&msg,
-				     /* denied: req, resp */
-				     "<td>%s</td><td>%s</td>"
-				     /* errors: request, connect, response */
-				     "<td>%s</td><td></td><td></td>"
-				     /* warnings: retries, redispatches */
-				     "<td></td><td></td>"
-				     /* server status: reflect listener status */
-				     "<td class=ac>%s</td>"
-				     /* rest of server: nothing */
-				     "<td class=ac colspan=8></td></tr>"
-				     "",
-				     U2H0(l->counters->denied_req), U2H1(l->counters->denied_resp),
-				     U2H2(l->counters->failed_req),
-				     (l->nbconn < l->maxconn) ? "OPEN" : "FULL");
-			} else {
-				chunk_printf(&msg,
-				     /* pxid, name, queue cur, queue max, */
-				     "%s,%s,,,"
-				     /* sessions: current, max, limit, total */
-				     "%d,%d,%d,%lld,"
-				     /* bytes: in, out */
-				     "%lld,%lld,"
-				     /* denied: req, resp */
-				     "%lld,%lld,"
-				     /* errors: request, connect, response */
-				     "%lld,,,"
-				     /* warnings: retries, redispatches */
-				     ",,"
-				     /* server status: reflect listener status */
-				     "%s,"
-				     /* rest of server: nothing */
-				     ",,,,,,,,"
-				     /* pid, iid, sid, throttle, lbtot, tracked, type */
-				     "%d,%d,%d,,,,%d,"
-				     /* rate, rate_lim, rate_max */
-				     ",,,"
-				     /* check_status, check_code, check_duration */
-				     ",,,"
-				     /* http response: 1xx, 2xx, 3xx, 4xx, 5xx, other */
-				     ",,,,,,"
-				     /* failed health analyses */
-				     ","
-				     /* requests : req_rate, req_rate_max, req_tot, */
-				     ",,,"
-				     /* errors: cli_aborts, srv_aborts */
-				     ",,"
-				     "\n",
-				     px->id, l->name,
-				     l->nbconn, l->counters->conn_max,
-				     l->maxconn, l->counters->cum_conn,
-				     l->counters->bytes_in, l->counters->bytes_out,
-				     l->counters->denied_req, l->counters->denied_resp,
-				     l->counters->failed_req,
-				     (l->nbconn < l->maxconn) ? "OPEN" : "FULL",
-				     relative_pid, px->uuid, l->luid, STATS_TYPE_SO);
-			}
-
-			if (buffer_feed_chunk(rep, &msg) >= 0)
-				return 0;
-		}
-
-		s->data_ctx.stats.sv = px->srv; /* may be NULL */
-		s->data_ctx.stats.px_st = DATA_ST_PX_SV;
-		/* fall through */
-
-	case DATA_ST_PX_SV:
-		/* stats.sv has been initialized above */
-		for (; s->data_ctx.stats.sv != NULL; s->data_ctx.stats.sv = sv->next) {
-			int sv_state; /* 0=DOWN, 1=going up, 2=going down, 3=UP, 4,5=NOLB, 6=unchecked */
-
-			if (buffer_almost_full(rep))
-				return 0;
-
-			sv = s->data_ctx.stats.sv;
-
-			if (s->data_ctx.stats.flags & STAT_BOUND) {
-				if (!(s->data_ctx.stats.type & (1 << STATS_TYPE_SV)))
-					break;
-
-				if (s->data_ctx.stats.sid != -1 && sv->puid != s->data_ctx.stats.sid)
-					continue;
-			}
-
-			if (sv->tracked)
-				svs = sv->tracked;
-			else
-				svs = sv;
-
-			/* FIXME: produce some small strings for "UP/DOWN x/y &#xxxx;" */
-			if (!(svs->state & SRV_CHECKED))
-				sv_state = 6;
-			else if (svs->state & SRV_RUNNING) {
-				if (svs->health == svs->rise + svs->fall - 1)
-					sv_state = 3; /* UP */
-				else
-					sv_state = 2; /* going down */
-
-				if (svs->state & SRV_GOINGDOWN)
-					sv_state += 2;
-			}
-			else
-				if (svs->health)
-					sv_state = 1; /* going up */
-				else
-					sv_state = 0; /* DOWN */
-
-			if (((sv_state == 0) || (sv->state & SRV_MAINTAIN)) && (s->data_ctx.stats.flags & STAT_HIDE_DOWN)) {
-				/* do not report servers which are DOWN */
-				s->data_ctx.stats.sv = sv->next;
-				continue;
-			}
-
-			if (!(s->data_ctx.stats.flags & STAT_FMT_CSV)) {
-				static char *srv_hlt_st[7] = { "DOWN", "DN %d/%d &uarr;",
-							       "UP %d/%d &darr;", "UP",
-							       "NOLB %d/%d &darr;", "NOLB",
-							       "<i>no check</i>" };
-				if ((sv->state & SRV_MAINTAIN) || (svs->state & SRV_MAINTAIN)) {
-					chunk_printf(&msg,
-					    /* name */
-					    "<tr class=\"maintain\">"
-					);
-				}
-				else {
-					chunk_printf(&msg,
-					    /* name */
-					    "<tr class=\"%s%d\">",
-					    (sv->state & SRV_BACKUP) ? "backup" : "active", sv_state);
-				}
-
-				if (px->cap & PR_CAP_BE && px->srv && (s->data_ctx.stats.flags & STAT_ADMIN)) {
-					chunk_printf(&msg,
-						"<td><input type=\"checkbox\" name=\"s\" value=\"%s\"></td>",
-						sv->id);
-				}
-
-				chunk_printf(&msg, "<td class=ac");
-
-				if (uri->flags&ST_SHLGNDS) {
-					char str[INET6_ADDRSTRLEN];
-
-					chunk_printf(&msg, " title=\"IP: ");
-
-					/* IP */
-					if (inet_ntop(sv->addr.sin_family, &sv->addr.sin_addr, str, sizeof(str)))
-						chunk_printf(&msg, "%s:%d", str, htons(sv->addr.sin_port));
-					else
-						chunk_printf(&msg, "(%s)", strerror(errno));
-
-					/* id */
-					chunk_printf(&msg, ", id: %d", sv->puid);
-
-					/* cookie */
-					if (sv->cookie) {
-						struct chunk src;
-
-						chunk_printf(&msg, ", cookie: '");
-
-						chunk_initlen(&src, sv->cookie, 0, strlen(sv->cookie));
-						chunk_htmlencode(&msg, &src);
-
-						chunk_printf(&msg, "'");
-					}
-
-					chunk_printf(&msg, "\"");
-				}
-
-				chunk_printf(&msg,
-				     ">%s<a name=\"%s/%s\"></a>"
-				     "<a class=lfsb href=\"#%s/%s\">%s</a>%s</td>"
-				     /* queue : current, max, limit */
-				     "<td>%s</td><td>%s</td><td>%s</td>"
-				     /* sessions rate : current, max, limit */
-				     "<td>%s</td><td>%s</td><td></td>"
-				     /* sessions: current, max, limit */
-				     "<td>%s</td><td>%s</td><td>%s</td>"
-				     "<td"
-				     "",
-				     (uri->flags & ST_SHLGNDS)?"<u>":"",
-				     px->id, sv->id, px->id, sv->id, sv->id,
-				     (uri->flags & ST_SHLGNDS)?"</u>":"",
-				     U2H0(sv->nbpend), U2H1(sv->counters.nbpend_max), LIM2A2(sv->maxqueue, "-"),
-				     U2H3(read_freq_ctr(&sv->sess_per_sec)), U2H4(sv->counters.sps_max),
-				     U2H5(sv->cur_sess), U2H6(sv->counters.cur_sess_max), LIM2A7(sv->maxconn, "-"));
-
-				/* http response (via td title): 1xx, 2xx, 3xx, 4xx, 5xx, other */
-				if (px->mode == PR_MODE_HTTP) {
-					int i;
-
-					chunk_printf(&msg, " title=\"rsp codes:");
-
-					for (i = 1; i < 6; i++)
-						chunk_printf(&msg, " %dxx=%lld,", i, sv->counters.p.http.rsp[i]);
-
-					chunk_printf(&msg, " other=%lld\"", sv->counters.p.http.rsp[0]);
-				}
-
-				chunk_printf(&msg,
-				     /* sessions: total, lbtot */
-				     ">%s%s%s</td><td>%s</td>",
-				     (px->mode == PR_MODE_HTTP)?"<u>":"",
-				     U2H0(sv->counters.cum_sess),
-				     (px->mode == PR_MODE_HTTP)?"</u>":"",
-				     U2H1(sv->counters.cum_lbconn));
-
-				chunk_printf(&msg,
-				     /* bytes : in, out */
-				     "<td>%s</td><td>%s</td>"
-				     /* denied: req, resp */
-				     "<td></td><td>%s</td>"
-				     /* errors : request, connect */
-				     "<td></td><td>%s</td>"
-				     /* errors : response */
-				     "<td title=\"Connection resets during transfers: %lld client, %lld server\"><u>%s</u></td>"
-				     /* warnings: retries, redispatches */
-				     "<td>%lld</td><td>%lld</td>"
-				     "",
-				     U2H0(sv->counters.bytes_in), U2H1(sv->counters.bytes_out),
-				     U2H2(sv->counters.failed_secu),
-				     U2H3(sv->counters.failed_conns),
-				     sv->counters.cli_aborts,
-				     sv->counters.srv_aborts,
-				     U2H6(sv->counters.failed_resp),
-				     sv->counters.retries, sv->counters.redispatches);
-
-				/* status, lest check */
-				chunk_printf(&msg, "<td class=ac>");
-
-				if (sv->state & SRV_MAINTAIN) {
-					chunk_printf(&msg, "%s ",
-						human_time(now.tv_sec - sv->last_change, 1));
-					chunk_printf(&msg, "MAINT");
-				}
-				else if (svs != sv && svs->state & SRV_MAINTAIN) {
-					chunk_printf(&msg, "%s ",
-						human_time(now.tv_sec - svs->last_change, 1));
-					chunk_printf(&msg, "MAINT(via)");
-				}
-				else if (svs->state & SRV_CHECKED) {
-					chunk_printf(&msg, "%s ",
-						human_time(now.tv_sec - svs->last_change, 1));
-
-					chunk_printf(&msg,
-					     srv_hlt_st[sv_state],
-					     (svs->state & SRV_RUNNING) ? (svs->health - svs->rise + 1) : (svs->health),
-					     (svs->state & SRV_RUNNING) ? (svs->fall) : (svs->rise));
-				}
-
-				if (sv->state & SRV_CHECKED) {
-					chunk_printf(&msg, "</td><td class=ac title=\"%s",
-						get_check_status_description(sv->check_status));
-
-					if (*sv->check_desc) {
-						struct chunk src;
-
-						chunk_printf(&msg, ": ");
-
-						chunk_initlen(&src, sv->check_desc, 0, strlen(sv->check_desc));
-						chunk_htmlencode(&msg, &src);
-					}
-
-					chunk_printf(&msg, "\"><u> %s%s",
-						tv_iszero(&sv->check_start)?"":"* ",
-						get_check_status_info(sv->check_status));
-
-					if (sv->check_status >= HCHK_STATUS_L57DATA)
-						chunk_printf(&msg, "/%d", sv->check_code);
-
-					if (sv->check_status >= HCHK_STATUS_CHECKED && sv->check_duration >= 0)
-					chunk_printf(&msg, " in %lums</u>", sv->check_duration);
-				} else
-					chunk_printf(&msg, "</td><td>");
-
-				chunk_printf(&msg,
-				     /* weight */
-				     "</td><td class=ac>%d</td>"
-				     /* act, bck */
-				     "<td class=ac>%s</td><td class=ac>%s</td>"
-				     "",
-				     (sv->eweight * px->lbprm.wmult + px->lbprm.wdiv - 1) / px->lbprm.wdiv,
-				     (sv->state & SRV_BACKUP) ? "-" : "Y",
-				     (sv->state & SRV_BACKUP) ? "Y" : "-");
-
-				/* check failures: unique, fatal, down time */
-				if (sv->state & SRV_CHECKED) {
-					chunk_printf(&msg, "<td title=\"Failed Health Checks%s\"><u>%lld",
-					     svs->observe?"/Health Analyses":"", svs->counters.failed_checks);
-
-					if (svs->observe)
-						chunk_printf(&msg, "/%lld", svs->counters.failed_hana);
-
-					chunk_printf(&msg,
-					     "</u></td>"
-					     "<td>%lld</td><td>%s</td>"
-					     "",
-					     svs->counters.down_trans, human_time(srv_downtime(sv), 1));
-				} else if (sv != svs)
-					chunk_printf(&msg,
-					     "<td class=ac colspan=3><a class=lfsb href=\"#%s/%s\">via %s/%s<a></td>",
-							svs->proxy->id, svs->id, svs->proxy->id, svs->id);
-				else
-					chunk_printf(&msg,
-					     "<td colspan=3></td>");
-
-				/* throttle */
-				if ((sv->state & SRV_WARMINGUP) &&
-				    now.tv_sec < sv->last_change + sv->slowstart &&
-				    now.tv_sec >= sv->last_change) {
-					unsigned int ratio;
-					ratio = MAX(1, 100 * (now.tv_sec - sv->last_change) / sv->slowstart);
-					chunk_printf(&msg,
-						     "<td class=ac>%d %%</td></tr>\n", ratio);
-				} else {
-					chunk_printf(&msg,
-						     "<td class=ac>-</td></tr>\n");
-				}
-			} else {
-				static char *srv_hlt_st[7] = { "DOWN,", "DOWN %d/%d,",
-							       "UP %d/%d,", "UP,",
-							       "NOLB %d/%d,", "NOLB,",
-							       "no check," };
-				chunk_printf(&msg,
-				     /* pxid, name */
-				     "%s,%s,"
-				     /* queue : current, max */
-				     "%d,%d,"
-				     /* sessions : current, max, limit, total */
-				     "%d,%d,%s,%lld,"
-				     /* bytes : in, out */
-				     "%lld,%lld,"
-				     /* denied: req, resp */
-				     ",%lld,"
-				     /* errors : request, connect, response */
-				     ",%lld,%lld,"
-				     /* warnings: retries, redispatches */
-				     "%lld,%lld,"
-				     "",
-				     px->id, sv->id,
-				     sv->nbpend, sv->counters.nbpend_max,
-				     sv->cur_sess, sv->counters.cur_sess_max, LIM2A0(sv->maxconn, ""), sv->counters.cum_sess,
-				     sv->counters.bytes_in, sv->counters.bytes_out,
-				     sv->counters.failed_secu,
-				     sv->counters.failed_conns, sv->counters.failed_resp,
-				     sv->counters.retries, sv->counters.redispatches);
-
-				/* status */
-				if (sv->state & SRV_MAINTAIN) {
-					chunk_printf(&msg, "MAINT,");
-				}
-				else if (svs != sv && svs->state & SRV_MAINTAIN) {
-					chunk_printf(&msg, "MAINT(via),");
-				}
-				else {
-					chunk_printf(&msg,
-					    srv_hlt_st[sv_state],
-					    (svs->state & SRV_RUNNING) ? (svs->health - svs->rise + 1) : (svs->health),
-					    (svs->state & SRV_RUNNING) ? (svs->fall) : (svs->rise));
-				}
-
-				chunk_printf(&msg,
-				     /* weight, active, backup */
-				     "%d,%d,%d,"
-				     "",
-				     (sv->eweight * px->lbprm.wmult + px->lbprm.wdiv - 1) / px->lbprm.wdiv,
-				     (sv->state & SRV_BACKUP) ? 0 : 1,
-				     (sv->state & SRV_BACKUP) ? 1 : 0);
-
-				/* check failures: unique, fatal; last change, total downtime */
-				if (sv->state & SRV_CHECKED)
-					chunk_printf(&msg,
-					     "%lld,%lld,%d,%d,",
-					     sv->counters.failed_checks, sv->counters.down_trans,
-					     (int)(now.tv_sec - sv->last_change), srv_downtime(sv));
-				else
-					chunk_printf(&msg,
-					     ",,,,");
-
-				/* queue limit, pid, iid, sid, */
-				chunk_printf(&msg,
-				     "%s,"
-				     "%d,%d,%d,",
-				     LIM2A0(sv->maxqueue, ""),
-				     relative_pid, px->uuid, sv->puid);
-
-				/* throttle */
-				if ((sv->state & SRV_WARMINGUP) &&
-				    now.tv_sec < sv->last_change + sv->slowstart &&
-				    now.tv_sec >= sv->last_change) {
-					unsigned int ratio;
-					ratio = MAX(1, 100 * (now.tv_sec - sv->last_change) / sv->slowstart);
-					chunk_printf(&msg, "%d", ratio);
-				}
-
-				/* sessions: lbtot */
-				chunk_printf(&msg, ",%lld,", sv->counters.cum_lbconn);
-
-				/* tracked */
-				if (sv->tracked)
-					chunk_printf(&msg, "%s/%s,",
-						sv->tracked->proxy->id, sv->tracked->id);
-				else
-					chunk_printf(&msg, ",");
-
-				/* type */
-				chunk_printf(&msg, "%d,", STATS_TYPE_SV);
-
-				/* rate */
-				chunk_printf(&msg, "%u,,%u,",
-					     read_freq_ctr(&sv->sess_per_sec),
-					     sv->counters.sps_max);
-
-				if (sv->state & SRV_CHECKED) {
-					/* check_status */
-					chunk_printf(&msg, "%s,", get_check_status_info(sv->check_status));
-
-					/* check_code */
-					if (sv->check_status >= HCHK_STATUS_L57DATA)
-						chunk_printf(&msg, "%u,", sv->check_code);
-					else
-						chunk_printf(&msg, ",");
-
-					/* check_duration */
-					if (sv->check_status >= HCHK_STATUS_CHECKED)
-						chunk_printf(&msg, "%lu,", sv->check_duration);
-					else
-						chunk_printf(&msg, ",");
-
-				} else {
-					chunk_printf(&msg, ",,,");
-				}
-
-				/* http response: 1xx, 2xx, 3xx, 4xx, 5xx, other */
-				if (px->mode == PR_MODE_HTTP) {
-					int i;
-
-					for (i=1; i<6; i++)
-						chunk_printf(&msg, "%lld,", sv->counters.p.http.rsp[i]);
-
-					chunk_printf(&msg, "%lld,", sv->counters.p.http.rsp[0]);
-				} else {
-					chunk_printf(&msg, ",,,,,,");
-				}
-
-				/* failed health analyses */
-				chunk_printf(&msg, "%lld,",  sv->counters.failed_hana);
-
-				/* requests : req_rate, req_rate_max, req_tot, */
-				chunk_printf(&msg, ",,,");
-
-				/* errors: cli_aborts, srv_aborts */
-				chunk_printf(&msg, "%lld,%lld,",
-					     sv->counters.cli_aborts, sv->counters.srv_aborts);
-
-				/* finish with EOL */
-				chunk_printf(&msg, "\n");
-			}
-			if (buffer_feed_chunk(rep, &msg) >= 0)
-				return 0;
-		} /* for sv */
-
-		s->data_ctx.stats.px_st = DATA_ST_PX_BE;
-		/* fall through */
-
-	case DATA_ST_PX_BE:
-		/* print the backend */
-		if ((px->cap & PR_CAP_BE) &&
-		    (!(s->data_ctx.stats.flags & STAT_BOUND) || (s->data_ctx.stats.type & (1 << STATS_TYPE_BE)))) {
-			if (!(s->data_ctx.stats.flags & STAT_FMT_CSV)) {
-				chunk_printf(&msg, "<tr class=\"backend\">");
-				if (px->cap & PR_CAP_BE && px->srv && (s->data_ctx.stats.flags & STAT_ADMIN)) {
-					/* Column sub-heading for Enable or Disable server */
-					chunk_printf(&msg, "<td></td>");
-				}
-				chunk_printf(&msg, "<td class=ac");
-
-				if (uri->flags&ST_SHLGNDS) {
-					/* balancing */
-					 chunk_printf(&msg, " title=\"balancing: %s",
-						 backend_lb_algo_str(px->lbprm.algo & BE_LB_ALGO));
-
-					/* cookie */
-					if (px->cookie_name) {
-						struct chunk src;
-
-						chunk_printf(&msg, ", cookie: '");
-
-						chunk_initlen(&src, px->cookie_name, 0, strlen(px->cookie_name));
-						chunk_htmlencode(&msg, &src);
-
-						chunk_printf(&msg, "'");
-					}
-
-					chunk_printf(&msg, "\"");
-
-				}
-
-				chunk_printf(&msg,
-				     /* name */
-				     ">%s<a name=\"%s/Backend\"></a>"
-				     "<a class=lfsb href=\"#%s/Backend\">Backend</a>%s</td>"
-				     /* queue : current, max */
-				     "<td>%s</td><td>%s</td><td></td>"
-				     /* sessions rate : current, max, limit */
-				     "<td>%s</td><td>%s</td><td></td>"
-				     "",
-				     (uri->flags & ST_SHLGNDS)?"<u>":"",
-				     px->id, px->id,
-				     (uri->flags & ST_SHLGNDS)?"</u>":"",
-				     U2H0(px->nbpend) /* or px->totpend ? */, U2H1(px->counters.nbpend_max),
-				     U2H2(read_freq_ctr(&px->be_sess_per_sec)), U2H3(px->counters.be_sps_max));
-
-				chunk_printf(&msg,
-				     /* sessions: current, max, limit */
-				     "<td>%s</td><td>%s</td><td>%s</td>"
-				     "<td"
-				     "",
-				     U2H2(px->beconn), U2H3(px->counters.beconn_max), U2H4(px->fullconn));
-
-				/* http response (via td title): 1xx, 2xx, 3xx, 4xx, 5xx, other */
-				if (px->mode == PR_MODE_HTTP) {
-					int i;
-
-					chunk_printf(&msg, " title=\"rsp codes:");
-
-					for (i = 1; i < 6; i++)
-						chunk_printf(&msg, " %dxx=%lld", i, px->counters.be.http.rsp[i]);
-
-					chunk_printf(&msg, " other=%lld\"", px->counters.be.http.rsp[0]);
-				}
-
-				chunk_printf(&msg,
-				     /* sessions: total, lbtot */
-				     ">%s%s%s</td><td>%s</td>"
-				     /* bytes: in, out */
-				     "<td>%s</td><td>%s</td>"
-				     "",
-				     (px->mode == PR_MODE_HTTP)?"<u>":"",
-				     U2H6(px->counters.cum_beconn),
-				     (px->mode == PR_MODE_HTTP)?"</u>":"",
-				     U2H7(px->counters.cum_lbconn),
-				     U2H8(px->counters.bytes_in), U2H9(px->counters.bytes_out));
-
-				chunk_printf(&msg,
-				     /* denied: req, resp */
-				     "<td>%s</td><td>%s</td>"
-				     /* errors : request, connect */
-				     "<td></td><td>%s</td>"
-				     /* errors : response */
-				     "<td title=\"Connection resets during transfers: %lld client, %lld server\"><u>%s</u></td>"
-				     /* warnings: retries, redispatches */
-				     "<td>%lld</td><td>%lld</td>"
-				     /* backend status: reflect backend status (up/down): we display UP
-				      * if the backend has known working servers or if it has no server at
-				      * all (eg: for stats). Then we display the total weight, number of
-				      * active and backups. */
-				     "<td class=ac>%s %s</td><td class=ac>&nbsp;</td><td class=ac>%d</td>"
-				     "<td class=ac>%d</td><td class=ac>%d</td>"
-				     "",
-				     U2H0(px->counters.denied_req), U2H1(px->counters.denied_resp),
-				     U2H2(px->counters.failed_conns),
-				     px->counters.cli_aborts,
-				     px->counters.srv_aborts,
-				     U2H5(px->counters.failed_resp),
-				     px->counters.retries, px->counters.redispatches,
-				     human_time(now.tv_sec - px->last_change, 1),
-				     (px->lbprm.tot_weight > 0 || !px->srv) ? "UP" :
-					     "<font color=\"red\"><b>DOWN</b></font>",
-				     (px->lbprm.tot_weight * px->lbprm.wmult + px->lbprm.wdiv - 1) / px->lbprm.wdiv,
-				     px->srv_act, px->srv_bck);
-
-				chunk_printf(&msg,
-				     /* rest of backend: nothing, down transitions, total downtime, throttle */
-				     "<td class=ac>&nbsp;</td><td>%d</td>"
-				     "<td>%s</td>"
-				     "<td></td>"
-				     "</tr>",
-				     px->down_trans,
-				     px->srv?human_time(be_downtime(px), 1):"&nbsp;");
-			} else {
-				chunk_printf(&msg,
-				     /* pxid, name */
-				     "%s,BACKEND,"
-				     /* queue : current, max */
-				     "%d,%d,"
-				     /* sessions : current, max, limit, total */
-				     "%d,%d,%d,%lld,"
-				     /* bytes : in, out */
-				     "%lld,%lld,"
-				     /* denied: req, resp */
-				     "%lld,%lld,"
-				     /* errors : request, connect, response */
-				     ",%lld,%lld,"
-				     /* warnings: retries, redispatches */
-				     "%lld,%lld,"
-				     /* backend status: reflect backend status (up/down): we display UP
-				      * if the backend has known working servers or if it has no server at
-				      * all (eg: for stats). Then we display the total weight, number of
-				      * active and backups. */
-				     "%s,"
-				     "%d,%d,%d,"
-				     /* rest of backend: nothing, down transitions, last change, total downtime */
-				     ",%d,%d,%d,,"
-				     /* pid, iid, sid, throttle, lbtot, tracked, type */
-				     "%d,%d,0,,%lld,,%d,"
-				     /* rate, rate_lim, rate_max, */
-				     "%u,,%u,"
-				     /* check_status, check_code, check_duration */
-				     ",,,",
-				     px->id,
-				     px->nbpend /* or px->totpend ? */, px->counters.nbpend_max,
-				     px->beconn, px->counters.beconn_max, px->fullconn, px->counters.cum_beconn,
-				     px->counters.bytes_in, px->counters.bytes_out,
-				     px->counters.denied_req, px->counters.denied_resp,
-				     px->counters.failed_conns, px->counters.failed_resp,
-				     px->counters.retries, px->counters.redispatches,
-				     (px->lbprm.tot_weight > 0 || !px->srv) ? "UP" : "DOWN",
-				     (px->lbprm.tot_weight * px->lbprm.wmult + px->lbprm.wdiv - 1) / px->lbprm.wdiv,
-				     px->srv_act, px->srv_bck,
-				     px->down_trans, (int)(now.tv_sec - px->last_change),
-				     px->srv?be_downtime(px):0,
-				     relative_pid, px->uuid,
-				     px->counters.cum_lbconn, STATS_TYPE_BE,
-				     read_freq_ctr(&px->be_sess_per_sec),
-				     px->counters.be_sps_max);
-
-				/* http response: 1xx, 2xx, 3xx, 4xx, 5xx, other */
-				if (px->mode == PR_MODE_HTTP) {
-					int i;
-
-					for (i=1; i<6; i++)
-						chunk_printf(&msg, "%lld,", px->counters.be.http.rsp[i]);
-
-					chunk_printf(&msg, "%lld,", px->counters.be.http.rsp[0]);
-				} else {
-					chunk_printf(&msg, ",,,,,,");
-				}
-
-				/* failed health analyses */
-				chunk_printf(&msg, ",");
-
-				/* requests : req_rate, req_rate_max, req_tot, */
-				chunk_printf(&msg, ",,,");
-
-				/* errors: cli_aborts, srv_aborts */
-				chunk_printf(&msg, "%lld,%lld,",
-					     px->counters.cli_aborts, px->counters.srv_aborts);
-
-				/* finish with EOL */
-				chunk_printf(&msg, "\n");
-
-			}
-			if (buffer_feed_chunk(rep, &msg) >= 0)
-				return 0;
-		}
-
-		s->data_ctx.stats.px_st = DATA_ST_PX_END;
-		/* fall through */
-
-	case DATA_ST_PX_END:
-		if (!(s->data_ctx.stats.flags & STAT_FMT_CSV)) {
-			chunk_printf(&msg, "</table>");
-
-			if (px->cap & PR_CAP_BE && px->srv && (s->data_ctx.stats.flags & STAT_ADMIN)) {
-				/* close the form used to enable/disable this proxy servers */
-				chunk_printf(&msg,
-					"Choose the action to perform on the checked servers : "
-					"<select name=action>"
-					"<option value=\"\"></option>"
-					"<option value=\"disable\">Disable</option>"
-					"<option value=\"enable\">Enable</option>"
-					"</select>"
-					"<input type=\"hidden\" name=\"b\" value=\"#%d\">"
-					"&nbsp;<input type=\"submit\" value=\"Apply\">"
-					"</form>",
-					px->uuid);
-			}
-
-			chunk_printf(&msg, "<p>\n");
-
-			if (buffer_feed_chunk(rep, &msg) >= 0)
-				return 0;
-		}
-
-		s->data_ctx.stats.px_st = DATA_ST_PX_FIN;
-		/* fall through */
-
-	case DATA_ST_PX_FIN:
-		return 1;
-
-	default:
-		/* unknown state, we should put an abort() here ! */
-		return 1;
-	}
-}
-
-/* This function is called to send output to the response buffer. It dumps a
- * complete session state onto the output buffer <rep>. The session has to be
- * set in data_ctx.sess.target. It returns 0 if the output buffer is full and
- * it needs to be called again, otherwise non-zero. It is designed to be called
- * from stats_dump_sess_to_buffer() below.
- */
-
-/* returns 1 if dump is not complete */
-int stats_dump_full_sess_to_buffer(struct session *s, struct buffer *rep)
-{
-	struct tm tm;
-	struct chunk msg;
-	struct session *sess;
-	extern const char *monthname[12];
-	char pn[INET6_ADDRSTRLEN];
-
-	chunk_init(&msg, trash, trashlen);
-	sess = s->data_ctx.sess.target;
-
-	if (s->data_ctx.sess.section > 0 && s->data_ctx.sess.uid != sess->uniq_id) {
-		/* session changed, no need to go any further */
-		chunk_printf(&msg, "  *** session terminated while we were watching it ***\n");
-		if (buffer_feed_chunk(rep, &msg) >= 0)
-			return 0;
-		s->data_ctx.sess.target = NULL;
-		s->data_ctx.sess.uid = 0;
-		return 1;
-	}
-
-	switch (s->data_ctx.sess.section) {
-	case 0: /* main status of the session */
-		s->data_ctx.sess.uid = sess->uniq_id;
-		s->data_ctx.sess.section = 1;
-		/* fall through */
-
-	case 1:
-		chunk_printf(&msg,
-			     "%p: id=%u, proto=%s",
-			     sess,
-			     sess->uniq_id,
-			     sess->listener->proto->name);
-
-		switch (sess->listener->proto->sock_family) {
-		case AF_INET:
-			inet_ntop(AF_INET,
-				  (const void *)&((struct sockaddr_in *)&sess->cli_addr)->sin_addr,
-				  pn, sizeof(pn));
-
-			chunk_printf(&msg,
-				     " source=%s:%d\n",
-				     pn,
-				     ntohs(((struct sockaddr_in *)&sess->cli_addr)->sin_port));
-			break;
-		case AF_INET6:
-			inet_ntop(AF_INET6,
-				  (const void *)&((struct sockaddr_in6 *)(&sess->cli_addr))->sin6_addr,
-				  pn, sizeof(pn));
-
-			chunk_printf(&msg,
-				     " source=%s:%d\n",
-				     pn,
-				     ntohs(((struct sockaddr_in6 *)&sess->cli_addr)->sin6_port));
-			break;
-		case AF_UNIX:
-		default:
-			/* no more information to print right now */
-			chunk_printf(&msg, "\n");
-			break;
-		}
-
-		chunk_printf(&msg,
-			     "  flags=0x%x, conn_retries=%d, srv_conn=%p, pend_pos=%p\n",
-			     sess->flags, sess->conn_retries, sess->srv_conn, sess->pend_pos);
-
-		chunk_printf(&msg,
-			     "  frontend=%s (id=%u mode=%s), listener=%s (id=%u)\n",
-			     sess->fe->id, sess->fe->uuid, sess->fe->mode ? "http" : "tcp",
-			     sess->listener ? sess->listener->name ? sess->listener->name : "?" : "?",
-			     sess->listener ? sess->listener->luid : 0);
-
-		if (sess->be->cap & PR_CAP_BE)
-			chunk_printf(&msg,
-				     "  backend=%s (id=%u mode=%s) server=%s (id=%u)\n",
-				     sess->be->id,
-				     sess->be->uuid, sess->be->mode ? "http" : "tcp",
-				     sess->srv ? sess->srv->id : "<none>",
-				     sess->srv ? sess->srv->puid : 0);
-		else
-			chunk_printf(&msg, "  backend=<NONE> (id=-1 mode=-) server=<NONE> (id=-1)\n");
-
-		chunk_printf(&msg,
-			     "  task=%p (state=0x%02x nice=%d calls=%d exp=%s%s)\n",
-			     sess->task,
-			     sess->task->state,
-			     sess->task->nice, sess->task->calls,
-			     sess->task->expire ?
-			             tick_is_expired(sess->task->expire, now_ms) ? "<PAST>" :
-			                     human_time(TICKS_TO_MS(sess->task->expire - now_ms),
-			                     TICKS_TO_MS(1000)) : "<NEVER>",
-			     task_in_rq(sess->task) ? ", running" : "");
-
-		get_localtime(sess->logs.accept_date.tv_sec, &tm);
-		chunk_printf(&msg,
-			     "  task created [%02d/%s/%04d:%02d:%02d:%02d.%06d] (age=%s)\n",
-			     tm.tm_mday, monthname[tm.tm_mon], tm.tm_year+1900,
-			     tm.tm_hour, tm.tm_min, tm.tm_sec, (int)(sess->logs.accept_date.tv_usec),
-			     human_time(now.tv_sec - sess->logs.accept_date.tv_sec, 1));
-
-		chunk_printf(&msg,
-			     "  si[0]=%p (state=%d flags=0x%02x fd=%d exp=%s, et=0x%03x)\n",
-			     &sess->si[0],
-			     sess->si[0].state,
-			     sess->si[0].flags,
-			     sess->si[0].fd,
-			     sess->si[0].exp ?
-			             tick_is_expired(sess->si[0].exp, now_ms) ? "<PAST>" :
-			                     human_time(TICKS_TO_MS(sess->si[0].exp - now_ms),
-			                     TICKS_TO_MS(1000)) : "<NEVER>",
-			     sess->si[0].err_type);
-
-		chunk_printf(&msg,
-			     "  si[1]=%p (state=%d flags=0x%02x fd=%d exp=%s, et=0x%03x)\n",
-			     &sess->si[1],
-			     sess->si[1].state,
-			     sess->si[1].flags,
-			     sess->si[1].fd,
-			     sess->si[1].exp ?
-			             tick_is_expired(sess->si[1].exp, now_ms) ? "<PAST>" :
-			                     human_time(TICKS_TO_MS(sess->si[1].exp - now_ms),
-			                     TICKS_TO_MS(1000)) : "<NEVER>",
-			     sess->si[1].err_type);
-
-		chunk_printf(&msg,
-			     "  txn=%p (flags=0x%x meth=%d status=%d req.st=%d rsp.st=%d)\n",
-			     &sess->txn, sess->txn.flags, sess->txn.meth, sess->txn.status,
-			     sess->txn.req.msg_state, sess->txn.rsp.msg_state);
-
-
-		chunk_printf(&msg,
-			     "  req=%p (f=0x%06x an=0x%x l=%d sndmx=%d pipe=%d fwd=%d)\n"
-			     "      an_exp=%s",
-			     sess->req,
-			     sess->req->flags, sess->req->analysers,
-			     sess->req->l, sess->req->send_max,
-			     sess->req->pipe ? sess->req->pipe->data : 0,
-			     sess->req->to_forward,
-			     sess->req->analyse_exp ?
-			     human_time(TICKS_TO_MS(sess->req->analyse_exp - now_ms),
-					TICKS_TO_MS(1000)) : "<NEVER>");
-
-		chunk_printf(&msg,
-			     " rex=%s",
-			     sess->req->rex ?
-			     human_time(TICKS_TO_MS(sess->req->rex - now_ms),
-					TICKS_TO_MS(1000)) : "<NEVER>");
-
-		chunk_printf(&msg,
-			     " wex=%s\n"
-			     "      data=%p r=%d w=%d lr=%d total=%lld\n",
-			     sess->req->wex ?
-			     human_time(TICKS_TO_MS(sess->req->wex - now_ms),
-					TICKS_TO_MS(1000)) : "<NEVER>",
-			     sess->req->data,
-			     (int)(sess->req->r - sess->req->data),
-			     (int)(sess->req->w - sess->req->data),
-			     (int)(sess->req->lr - sess->req->data),
-			     sess->req->total);
-
-		chunk_printf(&msg,
-			     "  res=%p (f=0x%06x an=0x%x l=%d sndmx=%d pipe=%d fwd=%d)\n"
-			     "      an_exp=%s",
-			     sess->rep,
-			     sess->rep->flags, sess->rep->analysers,
-			     sess->rep->l, sess->rep->send_max,
-			     sess->rep->pipe ? sess->rep->pipe->data : 0,
-			     sess->rep->to_forward,
-			     sess->rep->analyse_exp ?
-			     human_time(TICKS_TO_MS(sess->rep->analyse_exp - now_ms),
-					TICKS_TO_MS(1000)) : "<NEVER>");
-
-		chunk_printf(&msg,
-			     " rex=%s",
-			     sess->rep->rex ?
-			     human_time(TICKS_TO_MS(sess->rep->rex - now_ms),
-					TICKS_TO_MS(1000)) : "<NEVER>");
-
-		chunk_printf(&msg,
-			     " wex=%s\n"
-			     "      data=%p r=%d w=%d lr=%d total=%lld\n",
-			     sess->rep->wex ?
-			     human_time(TICKS_TO_MS(sess->rep->wex - now_ms),
-					TICKS_TO_MS(1000)) : "<NEVER>",
-			     sess->rep->data,
-			     (int)(sess->rep->r - sess->rep->data),
-			     (int)(sess->rep->w - sess->rep->data),
-			     (int)(sess->rep->lr - sess->rep->data),
-			     sess->rep->total);
-
-		if (buffer_feed_chunk(rep, &msg) >= 0)
-			return 0;
-
-		/* use other states to dump the contents */
-	}
-	/* end of dump */
-	s->data_ctx.sess.uid = 0;
-	return 1;
-}
-
-/* This function is called to send output to the response buffer.
- * It dumps the sessions states onto the output buffer <rep>.
- * Expects to be called with client socket shut down on input.
- * s->data_ctx must have been zeroed first, and the flags properly set.
- * It returns 0 as long as it does not complete, non-zero upon completion.
- */
-int stats_dump_sess_to_buffer(struct session *s, struct buffer *rep)
-{
-	struct chunk msg;
-
-	if (unlikely(rep->flags & (BF_WRITE_ERROR|BF_SHUTW))) {
-		/* If we're forced to shut down, we might have to remove our
-		 * reference to the last session being dumped.
-		 */
-		if (s->data_state == DATA_ST_LIST) {
-			if (!LIST_ISEMPTY(&s->data_ctx.sess.bref.users)) {
-				LIST_DEL(&s->data_ctx.sess.bref.users);
-				LIST_INIT(&s->data_ctx.sess.bref.users);
-			}
-		}
-		return 1;
-	}
-
-	chunk_init(&msg, trash, trashlen);
-
-	switch (s->data_state) {
-	case DATA_ST_INIT:
-		/* the function had not been called yet, let's prepare the
-		 * buffer for a response. We initialize the current session
-		 * pointer to the first in the global list. When a target
-		 * session is being destroyed, it is responsible for updating
-		 * this pointer. We know we have reached the end when this
-		 * pointer points back to the head of the sessions list.
-		 */
-		LIST_INIT(&s->data_ctx.sess.bref.users);
-		s->data_ctx.sess.bref.ref = sessions.n;
-		s->data_state = DATA_ST_LIST;
-		/* fall through */
-
-	case DATA_ST_LIST:
-		/* first, let's detach the back-ref from a possible previous session */
-		if (!LIST_ISEMPTY(&s->data_ctx.sess.bref.users)) {
-			LIST_DEL(&s->data_ctx.sess.bref.users);
-			LIST_INIT(&s->data_ctx.sess.bref.users);
-		}
-
-		/* and start from where we stopped */
-		while (s->data_ctx.sess.bref.ref != &sessions) {
-			char pn[INET6_ADDRSTRLEN + strlen(":65535")];
-			struct session *curr_sess;
-
-			curr_sess = LIST_ELEM(s->data_ctx.sess.bref.ref, struct session *, list);
-
-			if (s->data_ctx.sess.target) {
-				if (s->data_ctx.sess.target != curr_sess)
-					goto next_sess;
-
-				LIST_ADDQ(&curr_sess->back_refs, &s->data_ctx.sess.bref.users);
-				/* call the proper dump() function and return if we're missing space */
-				if (!stats_dump_full_sess_to_buffer(s, rep))
-					return 0;
-
-				/* session dump complete */
-				LIST_DEL(&s->data_ctx.sess.bref.users);
-				LIST_INIT(&s->data_ctx.sess.bref.users);
-				s->data_ctx.sess.target = NULL;
-				break;
-			}
-
-			chunk_printf(&msg,
-				     "%p: proto=%s",
-				     curr_sess,
-				     curr_sess->listener->proto->name);
-
-			switch (curr_sess->listener->proto->sock_family) {
-			case AF_INET:
-				inet_ntop(AF_INET,
-					  (const void *)&((struct sockaddr_in *)&curr_sess->cli_addr)->sin_addr,
-					  pn, sizeof(pn));
-
-				chunk_printf(&msg,
-					     " src=%s:%d fe=%s be=%s srv=%s",
-					     pn,
-					     ntohs(((struct sockaddr_in *)&curr_sess->cli_addr)->sin_port),
-					     curr_sess->fe->id,
-					     (curr_sess->be->cap & PR_CAP_BE) ? curr_sess->be->id : "<NONE>",
-					     curr_sess->srv ? curr_sess->srv->id : "<none>"
-					     );
-				break;
-			case AF_INET6:
-				inet_ntop(AF_INET6,
-					  (const void *)&((struct sockaddr_in6 *)(&curr_sess->cli_addr))->sin6_addr,
-					  pn, sizeof(pn));
-
-				chunk_printf(&msg,
-					     " src=%s:%d fe=%s be=%s srv=%s",
-					     pn,
-					     ntohs(((struct sockaddr_in6 *)&curr_sess->cli_addr)->sin6_port),
-					     curr_sess->fe->id,
-					     (curr_sess->be->cap & PR_CAP_BE) ? curr_sess->be->id : "<NONE>",
-					     curr_sess->srv ? curr_sess->srv->id : "<none>"
-					     );
-
-				break;
-			case AF_UNIX:
-				/* no more information to print right now */
-				break;
-			}
-
-			chunk_printf(&msg,
-				     " ts=%02x age=%s calls=%d",
-				     curr_sess->task->state,
-				     human_time(now.tv_sec - curr_sess->logs.tv_accept.tv_sec, 1),
-				     curr_sess->task->calls);
-
-			chunk_printf(&msg,
-				     " rq[f=%06xh,l=%d,an=%02xh,rx=%s",
-				     curr_sess->req->flags,
-				     curr_sess->req->l,
-				     curr_sess->req->analysers,
-				     curr_sess->req->rex ?
-				     human_time(TICKS_TO_MS(curr_sess->req->rex - now_ms),
-						TICKS_TO_MS(1000)) : "");
-
-			chunk_printf(&msg,
-				     ",wx=%s",
-				     curr_sess->req->wex ?
-				     human_time(TICKS_TO_MS(curr_sess->req->wex - now_ms),
-						TICKS_TO_MS(1000)) : "");
-
-			chunk_printf(&msg,
-				     ",ax=%s]",
-				     curr_sess->req->analyse_exp ?
-				     human_time(TICKS_TO_MS(curr_sess->req->analyse_exp - now_ms),
-						TICKS_TO_MS(1000)) : "");
-
-			chunk_printf(&msg,
-				     " rp[f=%06xh,l=%d,an=%02xh,rx=%s",
-				     curr_sess->rep->flags,
-				     curr_sess->rep->l,
-				     curr_sess->rep->analysers,
-				     curr_sess->rep->rex ?
-				     human_time(TICKS_TO_MS(curr_sess->rep->rex - now_ms),
-						TICKS_TO_MS(1000)) : "");
-
-			chunk_printf(&msg,
-				     ",wx=%s",
-				     curr_sess->rep->wex ?
-				     human_time(TICKS_TO_MS(curr_sess->rep->wex - now_ms),
-						TICKS_TO_MS(1000)) : "");
-
-			chunk_printf(&msg,
-				     ",ax=%s]",
-				     curr_sess->rep->analyse_exp ?
-				     human_time(TICKS_TO_MS(curr_sess->rep->analyse_exp - now_ms),
-						TICKS_TO_MS(1000)) : "");
-
-			chunk_printf(&msg,
-				     " s0=[%d,%1xh,fd=%d,ex=%s]",
-				     curr_sess->si[0].state,
-				     curr_sess->si[0].flags,
-				     curr_sess->si[0].fd,
-				     curr_sess->si[0].exp ?
-				     human_time(TICKS_TO_MS(curr_sess->si[0].exp - now_ms),
-						TICKS_TO_MS(1000)) : "");
-
-			chunk_printf(&msg,
-				     " s1=[%d,%1xh,fd=%d,ex=%s]",
-				     curr_sess->si[1].state,
-				     curr_sess->si[1].flags,
-				     curr_sess->si[1].fd,
-				     curr_sess->si[1].exp ?
-				     human_time(TICKS_TO_MS(curr_sess->si[1].exp - now_ms),
-						TICKS_TO_MS(1000)) : "");
-
-			chunk_printf(&msg,
-				     " exp=%s",
-				     curr_sess->task->expire ?
-				     human_time(TICKS_TO_MS(curr_sess->task->expire - now_ms),
-						TICKS_TO_MS(1000)) : "");
-			if (task_in_rq(curr_sess->task))
-				chunk_printf(&msg, " run(nice=%d)", curr_sess->task->nice);
-
-			chunk_printf(&msg, "\n");
-
-			if (buffer_feed_chunk(rep, &msg) >= 0) {
-				/* let's try again later from this session. We add ourselves into
-				 * this session's users so that it can remove us upon termination.
-				 */
-				LIST_ADDQ(&curr_sess->back_refs, &s->data_ctx.sess.bref.users);
-				return 0;
-			}
-
-		next_sess:
-			s->data_ctx.sess.bref.ref = curr_sess->list.n;
-		}
-
-		if (s->data_ctx.sess.target) {
-			/* specified session not found */
-			if (s->data_ctx.sess.section > 0)
-				chunk_printf(&msg, "  *** session terminated while we were watching it ***\n");
-			else
-				chunk_printf(&msg, "Session not found.\n");
-
-			if (buffer_feed_chunk(rep, &msg) >= 0)
-				return 0;
-
-			s->data_ctx.sess.target = NULL;
-			s->data_ctx.sess.uid = 0;
-			return 1;
-		}
-
-		s->data_state = DATA_ST_FIN;
-		/* fall through */
-
-	default:
-		s->data_state = DATA_ST_FIN;
-		return 1;
-	}
-}
-
-/* print a line of text buffer (limited to 70 bytes) to <out>. The format is :
- * <2 spaces> <offset=5 digits> <space or plus> <space> <70 chars max> <\n>
- * which is 60 chars per line. Non-printable chars \t, \n, \r and \e are
- * encoded in C format. Other non-printable chars are encoded "\xHH". Original
- * lines are respected within the limit of 70 output chars. Lines that are
- * continuation of a previous truncated line begin with "+" instead of " "
- * after the offset. The new pointer is returned.
- */
-static int dump_text_line(struct chunk *out, const char *buf, int bsize, int len,
-			  int *line, int ptr)
-{
-	int end;
-	unsigned char c;
-
-	end = out->len + 80;
-	if (end > out->size)
-		return ptr;
-
-	chunk_printf(out, "  %05d%c ", ptr, (ptr == *line) ? ' ' : '+');
-
-	while (ptr < len && ptr < bsize) {
-		c = buf[ptr];
-		if (isprint(c) && isascii(c) && c != '\\') {
-			if (out->len > end - 2)
-				break;
-			out->str[out->len++] = c;
-		} else if (c == '\t' || c == '\n' || c == '\r' || c == '\e' || c == '\\') {
-			if (out->len > end - 3)
-				break;
-			out->str[out->len++] = '\\';
-			switch (c) {
-			case '\t': c = 't'; break;
-			case '\n': c = 'n'; break;
-			case '\r': c = 'r'; break;
-			case '\e': c = 'e'; break;
-			case '\\': c = '\\'; break;
-			}
-			out->str[out->len++] = c;
-		} else {
-			if (out->len > end - 5)
-				break;
-			out->str[out->len++] = '\\';
-			out->str[out->len++] = 'x';
-			out->str[out->len++] = hextab[(c >> 4) & 0xF];
-			out->str[out->len++] = hextab[c & 0xF];
-		}
-		if (buf[ptr++] == '\n') {
-			/* we had a line break, let's return now */
-			out->str[out->len++] = '\n';
-			*line = ptr;
-			return ptr;
-		}
-	}
-	/* we have an incomplete line, we return it as-is */
-	out->str[out->len++] = '\n';
-	return ptr;
-}
-
-/* This function is called to send output to the response buffer.
- * It dumps the errors logged in proxies onto the output buffer <rep>.
- * Expects to be called with client socket shut down on input.
- * s->data_ctx must have been zeroed first, and the flags properly set.
- * It returns 0 as long as it does not complete, non-zero upon completion.
- */
-int stats_dump_errors_to_buffer(struct session *s, struct buffer *rep)
-{
-	extern const char *monthname[12];
-	struct chunk msg;
-
-	if (unlikely(rep->flags & (BF_WRITE_ERROR|BF_SHUTW)))
-		return 1;
-
-	chunk_init(&msg, trash, trashlen);
-
-	if (!s->data_ctx.errors.px) {
-		/* the function had not been called yet, let's prepare the
-		 * buffer for a response.
-		 */
-		struct tm tm;
-
-		get_localtime(date.tv_sec, &tm);
-		chunk_printf(&msg, "Total events captured on [%02d/%s/%04d:%02d:%02d:%02d.%03d] : %u\n",
-			     tm.tm_mday, monthname[tm.tm_mon], tm.tm_year+1900,
-			     tm.tm_hour, tm.tm_min, tm.tm_sec, (int)(date.tv_usec/1000),
-			     error_snapshot_id);
-
-		if (buffer_feed_chunk(rep, &msg) >= 0) {
-			/* Socket buffer full. Let's try again later from the same point */
-			return 0;
-		}
-
-		s->data_ctx.errors.px = proxy;
-		s->data_ctx.errors.buf = 0;
-		s->data_ctx.errors.bol = 0;
-		s->data_ctx.errors.ptr = -1;
-	}
-
-	/* we have two inner loops here, one for the proxy, the other one for
-	 * the buffer.
-	 */
-	while (s->data_ctx.errors.px) {
-		struct error_snapshot *es;
-
-		if (s->data_ctx.errors.buf == 0)
-			es = &s->data_ctx.errors.px->invalid_req;
-		else
-			es = &s->data_ctx.errors.px->invalid_rep;
-
-		if (!es->when.tv_sec)
-			goto next;
-
-		if (s->data_ctx.errors.iid >= 0 &&
-		    s->data_ctx.errors.px->uuid != s->data_ctx.errors.iid &&
-		    es->oe->uuid != s->data_ctx.errors.iid)
-			goto next;
-
-		if (s->data_ctx.errors.ptr < 0) {
-			/* just print headers now */
-
-			char pn[INET6_ADDRSTRLEN];
-			struct tm tm;
-
-			get_localtime(es->when.tv_sec, &tm);
-			chunk_printf(&msg, " \n[%02d/%s/%04d:%02d:%02d:%02d.%03d]",
-				     tm.tm_mday, monthname[tm.tm_mon], tm.tm_year+1900,
-				     tm.tm_hour, tm.tm_min, tm.tm_sec, (int)(es->when.tv_usec/1000));
-
-
-			if (es->src.ss_family == AF_INET)
-				inet_ntop(AF_INET,
-					  (const void *)&((struct sockaddr_in *)&es->src)->sin_addr,
-					  pn, sizeof(pn));
-			else
-				inet_ntop(AF_INET6,
-					  (const void *)&((struct sockaddr_in6 *)(&es->src))->sin6_addr,
-					  pn, sizeof(pn));
-
-			switch (s->data_ctx.errors.buf) {
-			case 0:
-				chunk_printf(&msg,
-					     " frontend %s (#%d): invalid request\n"
-					     "  src %s, session #%d, backend %s (#%d), server %s (#%d)\n"
-					     "  HTTP internal state %d, buffer flags 0x%08x, event #%u\n"
-					     "  request length %d bytes, error at position %d:\n \n",
-					     s->data_ctx.errors.px->id, s->data_ctx.errors.px->uuid,
-					     pn, es->sid, (es->oe->cap & PR_CAP_BE) ? es->oe->id : "<NONE>",
-					     (es->oe->cap & PR_CAP_BE) ? es->oe->uuid : -1,
-					     es->srv ? es->srv->id : "<NONE>",
-					     es->srv ? es->srv->puid : -1,
-					     es->state, es->flags, es->ev_id,
-					     es->len, es->pos);
-				break;
-			case 1:
-				chunk_printf(&msg,
-					     " backend %s (#%d) : invalid response\n"
-					     "  src %s, session #%d, frontend %s (#%d), server %s (#%d)\n"
-					     "  HTTP internal state %d, buffer flags 0x%08x, event #%u\n"
-					     "  response length %d bytes, error at position %d:\n \n",
-					     s->data_ctx.errors.px->id, s->data_ctx.errors.px->uuid,
-					     pn, es->sid, es->oe->id, es->oe->uuid,
-					     es->srv ? es->srv->id : "<NONE>",
-					     es->srv ? es->srv->puid : -1,
-					     es->state, es->flags, es->ev_id,
-					     es->len, es->pos);
-				break;
-			}
-
-			if (buffer_feed_chunk(rep, &msg) >= 0) {
-				/* Socket buffer full. Let's try again later from the same point */
-				return 0;
-			}
-			s->data_ctx.errors.ptr = 0;
-			s->data_ctx.errors.sid = es->sid;
-		}
-
-		if (s->data_ctx.errors.sid != es->sid) {
-			/* the snapshot changed while we were dumping it */
-			chunk_printf(&msg,
-				     "  WARNING! update detected on this snapshot, dump interrupted. Please re-check!\n");
-			if (buffer_feed_chunk(rep, &msg) >= 0)
-				return 0;
-			goto next;
-		}
-
-		/* OK, ptr >= 0, so we have to dump the current line */
-		while (s->data_ctx.errors.ptr < es->len && s->data_ctx.errors.ptr < sizeof(es->buf)) {
-			int newptr;
-			int newline;
-
-			newline = s->data_ctx.errors.bol;
-			newptr = dump_text_line(&msg, es->buf, sizeof(es->buf), es->len, &newline, s->data_ctx.errors.ptr);
-			if (newptr == s->data_ctx.errors.ptr)
-				return 0;
-
-			if (buffer_feed_chunk(rep, &msg) >= 0) {
-				/* Socket buffer full. Let's try again later from the same point */
-				return 0;
-			}
-			s->data_ctx.errors.ptr = newptr;
-			s->data_ctx.errors.bol = newline;
-		};
-	next:
-		s->data_ctx.errors.bol = 0;
-		s->data_ctx.errors.ptr = -1;
-		s->data_ctx.errors.buf++;
-		if (s->data_ctx.errors.buf > 1) {
-			s->data_ctx.errors.buf = 0;
-			s->data_ctx.errors.px = s->data_ctx.errors.px->next;
-		}
-	}
-
-	/* dump complete */
-	return 1;
-}
-
-
-static struct cfg_kw_list cfg_kws = {{ },{
-	{ CFG_GLOBAL, "stats", stats_parse_global },
-	{ 0, NULL, NULL },
-}};
-
-__attribute__((constructor))
-static void __dumpstats_module_init(void)
-{
-	cfg_register_keywords(&cfg_kws);
-}
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/ev_epoll.c b/deps/haproxy-1.4.21/src/ev_epoll.c
deleted file mode 100644
index b976868..0000000
--- a/deps/haproxy-1.4.21/src/ev_epoll.c
+++ /dev/null
@@ -1,418 +0,0 @@
-/*
- * FD polling functions for linux epoll()
- *
- * Copyright 2000-2008 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <unistd.h>
-#include <sys/time.h>
-#include <sys/types.h>
-
-#include <common/compat.h>
-#include <common/config.h>
-#include <common/standard.h>
-#include <common/ticks.h>
-#include <common/time.h>
-#include <common/tools.h>
-
-#include <types/fd.h>
-#include <types/global.h>
-
-#include <proto/signal.h>
-#include <proto/task.h>
-
-#if defined(USE_MY_EPOLL)
-#include <common/epoll.h>
-#include <errno.h>
-#include <sys/syscall.h>
-static _syscall1 (int, epoll_create, int, size);
-static _syscall4 (int, epoll_ctl, int, epfd, int, op, int, fd, struct epoll_event *, event);
-static _syscall4 (int, epoll_wait, int, epfd, struct epoll_event *, events, int, maxevents, int, timeout);
-#else
-#include <sys/epoll.h>
-#endif
-
-/* This is what we store in a list. It consists in old values and fds to detect changes. */
-struct fd_chg {
-	unsigned int prev:2;	// previous state mask. New one is in fd_evts.
-	unsigned int fd:30;	// file descriptor
-};
-
-static int nbchanges = 0;		// number of changes pending
-static struct fd_chg *chg_list = NULL;	// list of changes
-static struct fd_chg **chg_ptr = NULL;	// per-fd changes
-
-/* Each 32-bit word contains 2-bit descriptors of the latest state for 16 FDs :
- *   desc = (u32 >> (2*fd)) & 3
- *   desc = 0 : FD not set
- *          1 : WRITE not set, READ set
- *          2 : WRITE set, READ not set
- *          3 : WRITE set, READ set
- */
-
-static uint32_t *fd_evts;
-
-/* private data */
-static struct epoll_event *epoll_events;
-static int epoll_fd;
-
-/* This structure may be used for any purpose. Warning! do not use it in
- * recursive functions !
- */
-static struct epoll_event ev;
-
-/* converts a direction to a single bitmask.
- *  0 => 1
- *  1 => 2
- */
-#define DIR2MSK(dir) ((dir) + 1)
-
-/* converts an FD to an fd_evts offset and to a bit shift */
-#define FD2OFS(fd)   ((uint32_t)(fd) >> 4)
-#define FD2BIT(fd)   (((uint32_t)(fd) & 0xF) << 1)
-#define FD2MSK(fd)   (3 << FD2BIT(fd))
-
-/*
- * Returns non-zero if direction <dir> is already set for <fd>.
- */
-REGPRM2 static int __fd_is_set(const int fd, int dir)
-{
-	return (fd_evts[FD2OFS(fd)] >> FD2BIT(fd)) & DIR2MSK(dir);
-}
-
-/*
- * Adds, mods or deletes <fd> according to current status and to new desired
- * mask <dmask> :
- *
- *    0 = nothing
- *    1 = EPOLLIN
- *    2 = EPOLLOUT
- *    3 = EPOLLIN | EPOLLOUT
- *
- */
-static int dmsk2event[4] = { 0, EPOLLIN, EPOLLOUT, EPOLLIN | EPOLLOUT };
-
-
-REGPRM2 static void fd_flush_changes()
-{
-	uint32_t ofs;
-	int opcode;
-	int prev, next;
-	int chg, fd;
-
-	for (chg = 0; chg < nbchanges; chg++) {
-		prev = chg_list[chg].prev;
-		fd = chg_list[chg].fd;
-		chg_ptr[fd] = NULL;
-
-		ofs = FD2OFS(fd);
-		next = (fd_evts[ofs] >> FD2BIT(fd)) & 3;
-
-		if (prev == next)
-			/* if the value was unchanged, do nothing */
-			continue;
-
-		ev.events = dmsk2event[next];
-		ev.data.fd = fd;
-
-		if (prev) {
-			if (!next) {
-				/* we want to delete it now */
-				opcode = EPOLL_CTL_DEL;
-			} else {
-				/* we want to switch it */
-				opcode = EPOLL_CTL_MOD;
-			}
-		} else {
-			/* the FD did not exist, let's add it */
-			opcode = EPOLL_CTL_ADD;
-		}
-
-		epoll_ctl(epoll_fd, opcode, fd, &ev);
-	}
-	nbchanges = 0;
-}
-
-REGPRM2 static void alloc_chg_list(const int fd, int old_evt)
-{
-	struct fd_chg *ptr;
-
-	if (unlikely(chg_ptr[fd] != NULL))
-		return;
-
-#if LIMIT_NUMBER_OF_CHANGES
-	if (nbchanges > 2)
-		fd_flush_changes();
-#endif
-
-	ptr = &chg_list[nbchanges++];
-	chg_ptr[fd] = ptr;
-	ptr->fd = fd;
-	ptr->prev = old_evt;
-}
-
-REGPRM2 static int __fd_set(const int fd, int dir)
-{
-	uint32_t ofs = FD2OFS(fd);
-	uint32_t dmsk = DIR2MSK(dir);
-	uint32_t old_evt;
-
-	old_evt = fd_evts[ofs] >> FD2BIT(fd);
-	old_evt &= 3;
-	if (unlikely(old_evt & dmsk))
-		return 0;
-
-	alloc_chg_list(fd, old_evt);
-	dmsk <<= FD2BIT(fd);
-	fd_evts[ofs] |= dmsk;
-	return 1;
-}
-
-REGPRM2 static int __fd_clr(const int fd, int dir)
-{
-	uint32_t ofs = FD2OFS(fd);
-	uint32_t dmsk = DIR2MSK(dir);
-	uint32_t old_evt;
-
-	old_evt = fd_evts[ofs] >> FD2BIT(fd);
-	old_evt &= 3;
-	if (unlikely(!(old_evt & dmsk)))
-		return 0;
-
-	alloc_chg_list(fd, old_evt);
-	dmsk <<= FD2BIT(fd);
-	fd_evts[ofs] &= ~dmsk;
-	return 1;
-}
-
-REGPRM1 static void __fd_rem(int fd)
-{
-	uint32_t ofs = FD2OFS(fd);
-
-	if (unlikely(!((fd_evts[ofs] >> FD2BIT(fd)) & 3)))
-		return;
-
-	alloc_chg_list(fd, 0);
-	fd_evts[ofs] &= ~FD2MSK(fd);
-	return;
-}
-
-/*
- * On valid epoll() implementations, a call to close() automatically removes
- * the fds. This means that the FD will appear as previously unset.
- */
-REGPRM1 static void __fd_clo(int fd)
-{
-	struct fd_chg *ptr;
-	fd_evts[FD2OFS(fd)] &= ~FD2MSK(fd);
-	ptr = chg_ptr[fd];
-	if (ptr) {
-		ptr->prev = 0;
-		chg_ptr[fd] = NULL;
-	}
-	return;
-}
-
-/*
- * epoll() poller
- */
-REGPRM2 static void _do_poll(struct poller *p, int exp)
-{
-	int status;
-	int fd;
-	int count;
-	int wait_time;
-
-	if (likely(nbchanges))
-		fd_flush_changes();
-
-	/* now let's wait for events */
-	if (run_queue || signal_queue_len)
-		wait_time = 0;
-	else if (!exp)
-		wait_time = MAX_DELAY_MS;
-	else if (tick_is_expired(exp, now_ms))
-		wait_time = 0;
-	else {
-		wait_time = TICKS_TO_MS(tick_remain(now_ms, exp)) + 1;
-		if (wait_time > MAX_DELAY_MS)
-			wait_time = MAX_DELAY_MS;
-	}
-
-	fd = MIN(maxfd, global.tune.maxpollevents);
-	status = epoll_wait(epoll_fd, epoll_events, fd, wait_time);
-	tv_update_date(wait_time, status);
-
-	for (count = 0; count < status; count++) {
-		fd = epoll_events[count].data.fd;
-
-		if ((fd_evts[FD2OFS(fd)] >> FD2BIT(fd)) & DIR2MSK(DIR_RD)) {
-			if (fdtab[fd].state == FD_STCLOSE)
-				continue;
-			if (epoll_events[count].events & ( EPOLLIN | EPOLLERR | EPOLLHUP ))
-				fdtab[fd].cb[DIR_RD].f(fd);
-		}
-
-		if ((fd_evts[FD2OFS(fd)] >> FD2BIT(fd)) & DIR2MSK(DIR_WR)) {
-			if (fdtab[fd].state == FD_STCLOSE)
-				continue;
-			if (epoll_events[count].events & ( EPOLLOUT | EPOLLERR | EPOLLHUP ))
-				fdtab[fd].cb[DIR_WR].f(fd);
-		}
-	}
-}
-
-/*
- * Initialization of the epoll() poller.
- * Returns 0 in case of failure, non-zero in case of success. If it fails, it
- * disables the poller by setting its pref to 0.
- */
-REGPRM1 static int _do_init(struct poller *p)
-{
-	__label__ fail_chg_ptr, fail_chg_list, fail_fdevt, fail_ee, fail_fd;
-	int fd_set_bytes;
-
-	p->private = NULL;
-	fd_set_bytes = 4 * (global.maxsock + 15) / 16;
-
-	epoll_fd = epoll_create(global.maxsock + 1);
-	if (epoll_fd < 0)
-		goto fail_fd;
-
-	epoll_events = (struct epoll_event*)
-		calloc(1, sizeof(struct epoll_event) * global.tune.maxpollevents);
-
-	if (epoll_events == NULL)
-		goto fail_ee;
-
-	if ((fd_evts = (uint32_t *)calloc(1, fd_set_bytes)) == NULL)
-		goto fail_fdevt;
-
-	chg_list = (struct fd_chg *)calloc(1, sizeof(struct fd_chg) * global.maxsock);
-	if (chg_list == NULL)
-		goto fail_chg_list;
-
-	chg_ptr = (struct fd_chg **)calloc(1, sizeof(struct fd_chg*) * global.maxsock);
-	if (chg_ptr == NULL)
-		goto fail_chg_ptr;
-
-	return 1;
-
- fail_chg_ptr:
-	free(chg_list);
- fail_chg_list:
-	free(fd_evts);
- fail_fdevt:
-	free(epoll_events);
- fail_ee:
-	close(epoll_fd);
-	epoll_fd = -1;
- fail_fd:
-	p->pref = 0;
-	return 0;
-}
-
-/*
- * Termination of the epoll() poller.
- * Memory is released and the poller is marked as unselectable.
- */
-REGPRM1 static void _do_term(struct poller *p)
-{
-	fd_flush_changes();
-
-	free(chg_ptr);
-	free(chg_list);
-	free(fd_evts);
-	free(epoll_events);
-
-	if (epoll_fd >= 0) {
-		close(epoll_fd);
-		epoll_fd = -1;
-	}
-
-	chg_ptr = NULL;
-	chg_list = NULL;
-	fd_evts = NULL;
-	epoll_events = NULL;
-
-	p->private = NULL;
-	p->pref = 0;
-}
-
-/*
- * Check that the poller works.
- * Returns 1 if OK, otherwise 0.
- */
-REGPRM1 static int _do_test(struct poller *p)
-{
-	int fd;
-
-	fd = epoll_create(global.maxsock + 1);
-	if (fd < 0)
-		return 0;
-	close(fd);
-	return 1;
-}
-
-/*
- * Recreate the epoll file descriptor after a fork(). Returns 1 if OK,
- * otherwise 0. It will ensure that all processes will not share their
- * epoll_fd. Some side effects were encountered because of this, such
- * as epoll_wait() returning an FD which was previously deleted.
- */
-REGPRM1 static int _do_fork(struct poller *p)
-{
-	if (epoll_fd >= 0)
-		close(epoll_fd);
-	epoll_fd = epoll_create(global.maxsock + 1);
-	if (epoll_fd < 0)
-		return 0;
-	return 1;
-}
-
-/*
- * It is a constructor, which means that it will automatically be called before
- * main(). This is GCC-specific but it works at least since 2.95.
- * Special care must be taken so that it does not need any uninitialized data.
- */
-__attribute__((constructor))
-static void _do_register(void)
-{
-	struct poller *p;
-
-	if (nbpollers >= MAX_POLLERS)
-		return;
-
-	epoll_fd = -1;
-	p = &pollers[nbpollers++];
-
-	p->name = "epoll";
-	p->pref = 300;
-	p->private = NULL;
-
-	p->test = _do_test;
-	p->init = _do_init;
-	p->term = _do_term;
-	p->poll = _do_poll;
-	p->fork = _do_fork;
-
-	p->is_set  = __fd_is_set;
-	p->cond_s = p->set = __fd_set;
-	p->cond_c = p->clr = __fd_clr;
-	p->rem = __fd_rem;
-	p->clo = __fd_clo;
-}
-
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/ev_kqueue.c b/deps/haproxy-1.4.21/src/ev_kqueue.c
deleted file mode 100644
index e167984..0000000
--- a/deps/haproxy-1.4.21/src/ev_kqueue.c
+++ /dev/null
@@ -1,285 +0,0 @@
-/*
- * FD polling functions for FreeBSD kqueue()
- *
- * Copyright 2000-2008 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- * Note: not knowing much about kqueue, I had to rely on OpenBSD's detailed man
- * page and to check how it was implemented in lighttpd to understand it better.
- * But it is possible that I got things wrong.
- *
- */
-
-#include <unistd.h>
-#include <sys/time.h>
-#include <sys/types.h>
-
-#include <sys/event.h>
-#include <sys/time.h>
-
-#include <common/compat.h>
-#include <common/config.h>
-#include <common/ticks.h>
-#include <common/time.h>
-#include <common/tools.h>
-
-#include <types/global.h>
-
-#include <proto/fd.h>
-#include <proto/signal.h>
-#include <proto/task.h>
-
-/* private data */
-static fd_set *fd_evts[2];
-static int kqueue_fd;
-static struct kevent *kev = NULL;
-
-/* speeds up conversion of DIR_RD/DIR_WR to EVFILT* */
-static const int dir2filt[2] = { EVFILT_READ, EVFILT_WRITE };
-
-/* completes a change list for deletion */
-REGPRM3 static int kqev_del(struct kevent *kev, const int fd, const int dir)
-{
-	if (FD_ISSET(fd, fd_evts[dir])) {
-		FD_CLR(fd, fd_evts[dir]);
-		EV_SET(kev, fd, dir2filt[dir], EV_DELETE, 0, 0, NULL);
-		return 1;
-	}
-	return 0;
-}
-
-/*
- * Returns non-zero if direction <dir> is already set for <fd>.
- */
-REGPRM2 static int __fd_is_set(const int fd, int dir)
-{
-	return FD_ISSET(fd, fd_evts[dir]);
-}
-
-REGPRM2 static int __fd_set(const int fd, int dir)
-{
-	/* if the value was set, do nothing */
-	if (FD_ISSET(fd, fd_evts[dir]))
-		return 0;
-
-	FD_SET(fd, fd_evts[dir]);
-	EV_SET(kev, fd, dir2filt[dir], EV_ADD, 0, 0, NULL);
-	kevent(kqueue_fd, kev, 1, NULL, 0, NULL);
-	return 1;
-}
-
-REGPRM2 static int __fd_clr(const int fd, int dir)
-{
-	if (!kqev_del(kev, fd, dir))
-		return 0;
-	kevent(kqueue_fd, kev, 1, NULL, 0, NULL);
-	return 1;
-}
-
-REGPRM1 static void __fd_rem(int fd)
-{
-	int changes = 0;
-
-	changes += kqev_del(&kev[changes], fd, DIR_RD);
-	changes += kqev_del(&kev[changes], fd, DIR_WR);
-
-	if (changes)
-		kevent(kqueue_fd, kev, changes, NULL, 0, NULL);
-}
-
-REGPRM1 static void __fd_clo(int fd)
-{
-	FD_CLR(fd, fd_evts[DIR_RD]);
-	FD_CLR(fd, fd_evts[DIR_WR]);
-}
-
-/*
- * kqueue() poller
- */
-REGPRM2 static void _do_poll(struct poller *p, int exp)
-{
-	int status;
-	int count, fd, delta_ms;
-	struct timespec timeout;
-
-	delta_ms        = 0;
-	timeout.tv_sec  = 0;
-	timeout.tv_nsec = 0;
-
-	if (!run_queue && !signal_queue_len) {
-		if (!exp) {
-			delta_ms        = MAX_DELAY_MS;
-			timeout.tv_sec  = (MAX_DELAY_MS / 1000);
-			timeout.tv_nsec = (MAX_DELAY_MS % 1000) * 1000000;
-		}
-		else if (!tick_is_expired(exp, now_ms)) {
-			delta_ms = TICKS_TO_MS(tick_remain(now_ms, exp)) + 1;
-			if (delta_ms > MAX_DELAY_MS)
-				delta_ms = MAX_DELAY_MS;
-			timeout.tv_sec  = (delta_ms / 1000);
-			timeout.tv_nsec = (delta_ms % 1000) * 1000000;
-		}
-	}
-
-	fd = MIN(maxfd, global.tune.maxpollevents);
-	status = kevent(kqueue_fd, // int kq
-			NULL,      // const struct kevent *changelist
-			0,         // int nchanges
-			kev,       // struct kevent *eventlist
-			fd,        // int nevents
-			&timeout); // const struct timespec *timeout
-	tv_update_date(delta_ms, status);
-
-	for (count = 0; count < status; count++) {
-		fd = kev[count].ident;
-		if (kev[count].filter ==  EVFILT_READ) {
-			if (FD_ISSET(fd, fd_evts[DIR_RD])) {
-				if (fdtab[fd].state == FD_STCLOSE)
-					continue;
-				fdtab[fd].cb[DIR_RD].f(fd);
-			}
-		} else if (kev[count].filter ==  EVFILT_WRITE) {
-			if (FD_ISSET(fd, fd_evts[DIR_WR])) {
-				if (fdtab[fd].state == FD_STCLOSE)
-					continue;
-				fdtab[fd].cb[DIR_WR].f(fd);
-			}
-		}
-	}
-}
-
-/*
- * Initialization of the kqueue() poller.
- * Returns 0 in case of failure, non-zero in case of success. If it fails, it
- * disables the poller by setting its pref to 0.
- */
-REGPRM1 static int _do_init(struct poller *p)
-{
-	__label__ fail_wevt, fail_revt, fail_fd;
-	int fd_set_bytes;
-
-	p->private = NULL;
-	fd_set_bytes = sizeof(fd_set) * (global.maxsock + FD_SETSIZE - 1) / FD_SETSIZE;
-
-	kqueue_fd = kqueue();
-	if (kqueue_fd < 0)
-		goto fail_fd;
-
-	kev = (struct kevent*)calloc(1, sizeof(struct kevent) * global.tune.maxpollevents);
-
-	if (kev == NULL)
-		goto fail_kev;
-		
-	if ((fd_evts[DIR_RD] = (fd_set *)calloc(1, fd_set_bytes)) == NULL)
-		goto fail_revt;
-
-	if ((fd_evts[DIR_WR] = (fd_set *)calloc(1, fd_set_bytes)) == NULL)
-		goto fail_wevt;
-
-	return 1;
-
- fail_wevt:
-	free(fd_evts[DIR_RD]);
- fail_revt:
-	free(kev);
- fail_kev:
-	close(kqueue_fd);
-	kqueue_fd = -1;
- fail_fd:
-	p->pref = 0;
-	return 0;
-}
-
-/*
- * Termination of the kqueue() poller.
- * Memory is released and the poller is marked as unselectable.
- */
-REGPRM1 static void _do_term(struct poller *p)
-{
-	free(fd_evts[DIR_WR]);
-	free(fd_evts[DIR_RD]);
-	free(kev);
-
-	if (kqueue_fd >= 0) {
-		close(kqueue_fd);
-		kqueue_fd = -1;
-	}
-
-	p->private = NULL;
-	p->pref = 0;
-}
-
-/*
- * Check that the poller works.
- * Returns 1 if OK, otherwise 0.
- */
-REGPRM1 static int _do_test(struct poller *p)
-{
-	int fd;
-
-	fd = kqueue();
-	if (fd < 0)
-		return 0;
-	close(fd);
-	return 1;
-}
-
-/*
- * Recreate the kqueue file descriptor after a fork(). Returns 1 if OK,
- * otherwise 0. Note that some pollers need to be reopened after a fork()
- * (such as kqueue), and some others may fail to do so in a chroot.
- */
-REGPRM1 static int _do_fork(struct poller *p)
-{
-	if (kqueue_fd >= 0)
-		close(kqueue_fd);
-	kqueue_fd = kqueue();
-	if (kqueue_fd < 0)
-		return 0;
-	return 1;
-}
-
-/*
- * It is a constructor, which means that it will automatically be called before
- * main(). This is GCC-specific but it works at least since 2.95.
- * Special care must be taken so that it does not need any uninitialized data.
- */
-__attribute__((constructor))
-static void _do_register(void)
-{
-	struct poller *p;
-
-	if (nbpollers >= MAX_POLLERS)
-		return;
-
-	kqueue_fd = -1;
-	p = &pollers[nbpollers++];
-
-	p->name = "kqueue";
-	p->pref = 300;
-	p->private = NULL;
-
-	p->test = _do_test;
-	p->init = _do_init;
-	p->term = _do_term;
-	p->poll = _do_poll;
-	p->fork = _do_fork;
-
-	p->is_set  = __fd_is_set;
-	p->cond_s = p->set = __fd_set;
-	p->cond_c = p->clr = __fd_clr;
-	p->rem = __fd_rem;
-	p->clo = __fd_clo;
-}
-
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/ev_poll.c b/deps/haproxy-1.4.21/src/ev_poll.c
deleted file mode 100644
index f5d011e..0000000
--- a/deps/haproxy-1.4.21/src/ev_poll.c
+++ /dev/null
@@ -1,263 +0,0 @@
-/*
- * FD polling functions for generic poll()
- *
- * Copyright 2000-2008 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <unistd.h>
-#include <sys/poll.h>
-#include <sys/time.h>
-#include <sys/types.h>
-
-#include <common/compat.h>
-#include <common/config.h>
-#include <common/ticks.h>
-#include <common/time.h>
-
-#include <types/global.h>
-
-#include <proto/fd.h>
-#include <proto/signal.h>
-#include <proto/task.h>
-
-
-static fd_set *fd_evts[2];
-
-/* private data */
-static struct pollfd *poll_events = NULL;
-
-
-/*
- * Benchmarks performed on a Pentium-M notebook show that using functions
- * instead of the usual macros improve the FD_* performance by about 80%,
- * and that marking them regparm(2) adds another 20%.
- */
-REGPRM2 static int __fd_is_set(const int fd, int dir)
-{
-	return FD_ISSET(fd, fd_evts[dir]);
-}
-
-REGPRM2 static int __fd_set(const int fd, int dir)
-{
-	FD_SET(fd, fd_evts[dir]);
-	return 0;
-}
-
-REGPRM2 static int __fd_clr(const int fd, int dir)
-{
-	FD_CLR(fd, fd_evts[dir]);
-	return 0;
-}
-
-REGPRM2 static int __fd_cond_s(const int fd, int dir)
-{
-	int ret;
-	ret = !FD_ISSET(fd, fd_evts[dir]);
-	if (ret)
-		FD_SET(fd, fd_evts[dir]);
-	return ret;
-}
-
-REGPRM2 static int __fd_cond_c(const int fd, int dir)
-{
-	int ret;
-	ret = FD_ISSET(fd, fd_evts[dir]);
-	if (ret)
-		FD_CLR(fd, fd_evts[dir]);
-	return ret;
-}
-
-REGPRM1 static void __fd_rem(const int fd)
-{
-	FD_CLR(fd, fd_evts[DIR_RD]);
-	FD_CLR(fd, fd_evts[DIR_WR]);
-}
-
-/*
- * Poll() poller
- */
-REGPRM2 static void _do_poll(struct poller *p, int exp)
-{
-	int status;
-	int fd, nbfd;
-	int wait_time;
-
-	int fds, count;
-	int sr, sw;
-	unsigned rn, wn; /* read new, write new */
-
-	nbfd = 0;
-	for (fds = 0; (fds * BITS_PER_INT) < maxfd; fds++) {
-
-		rn = ((int*)fd_evts[DIR_RD])[fds];
-		wn = ((int*)fd_evts[DIR_WR])[fds];
-	  
-		if ((rn|wn)) {
-			for (count = 0, fd = fds * BITS_PER_INT; count < BITS_PER_INT && fd < maxfd; count++, fd++) {
-#define FDSETS_ARE_INT_ALIGNED
-#ifdef FDSETS_ARE_INT_ALIGNED
-
-#define WE_REALLY_KNOW_THAT_FDSETS_ARE_INTS
-#ifdef WE_REALLY_KNOW_THAT_FDSETS_ARE_INTS
-				sr = (rn >> count) & 1;
-				sw = (wn >> count) & 1;
-#else
-				sr = FD_ISSET(fd&(BITS_PER_INT-1), (typeof(fd_set*))&rn);
-				sw = FD_ISSET(fd&(BITS_PER_INT-1), (typeof(fd_set*))&wn);
-#endif
-#else
-				sr = FD_ISSET(fd, fd_evts[DIR_RD]);
-				sw = FD_ISSET(fd, fd_evts[DIR_WR]);
-#endif
-				if ((sr|sw)) {
-					poll_events[nbfd].fd = fd;
-					poll_events[nbfd].events = (sr ? POLLIN : 0) | (sw ? POLLOUT : 0);
-					nbfd++;
-				}
-			}
-		}		  
-	}
-      
-	/* now let's wait for events */
-	if (run_queue || signal_queue_len)
-		wait_time = 0;
-	else if (!exp)
-		wait_time = MAX_DELAY_MS;
-	else if (tick_is_expired(exp, now_ms))
-		wait_time = 0;
-	else {
-		wait_time = TICKS_TO_MS(tick_remain(now_ms, exp)) + 1;
-		if (wait_time > MAX_DELAY_MS)
-			wait_time = MAX_DELAY_MS;
-	}
-
-	status = poll(poll_events, nbfd, wait_time);
-	tv_update_date(wait_time, status);
-
-	for (count = 0; status > 0 && count < nbfd; count++) {
-		fd = poll_events[count].fd;
-	  
-		if (!(poll_events[count].revents & ( POLLOUT | POLLIN | POLLERR | POLLHUP )))
-			continue;
-
-		/* ok, we found one active fd */
-		status--;
-
-		if (FD_ISSET(fd, fd_evts[DIR_RD])) {
-			if (fdtab[fd].state == FD_STCLOSE)
-				continue;
-			if (poll_events[count].revents & ( POLLIN | POLLERR | POLLHUP ))
-				fdtab[fd].cb[DIR_RD].f(fd);
-		}
-	  
-		if (FD_ISSET(fd, fd_evts[DIR_WR])) {
-			if (fdtab[fd].state == FD_STCLOSE)
-				continue;
-			if (poll_events[count].revents & ( POLLOUT | POLLERR | POLLHUP ))
-				fdtab[fd].cb[DIR_WR].f(fd);
-		}
-	}
-
-}
-
-/*
- * Initialization of the poll() poller.
- * Returns 0 in case of failure, non-zero in case of success. If it fails, it
- * disables the poller by setting its pref to 0.
- */
-REGPRM1 static int _do_init(struct poller *p)
-{
-	__label__ fail_swevt, fail_srevt, fail_pe;
-	int fd_set_bytes;
-
-	p->private = NULL;
-	fd_set_bytes = sizeof(fd_set) * (global.maxsock + FD_SETSIZE - 1) / FD_SETSIZE;
-
-	poll_events = (struct pollfd*)
-		calloc(1, sizeof(struct pollfd) * global.maxsock);
-
-	if (poll_events == NULL)
-		goto fail_pe;
-		
-	if ((fd_evts[DIR_RD] = (fd_set *)calloc(1, fd_set_bytes)) == NULL)
-		goto fail_srevt;
-
-	if ((fd_evts[DIR_WR] = (fd_set *)calloc(1, fd_set_bytes)) == NULL)
-		goto fail_swevt;
-
-	return 1;
-
- fail_swevt:
-	free(fd_evts[DIR_RD]);
- fail_srevt:
-	free(poll_events);
- fail_pe:
-	p->pref = 0;
-	return 0;
-}
-
-/*
- * Termination of the poll() poller.
- * Memory is released and the poller is marked as unselectable.
- */
-REGPRM1 static void _do_term(struct poller *p)
-{
-	free(fd_evts[DIR_WR]);
-	free(fd_evts[DIR_RD]);
-	free(poll_events);
-	p->private = NULL;
-	p->pref = 0;
-}
-
-/*
- * Check that the poller works.
- * Returns 1 if OK, otherwise 0.
- */
-REGPRM1 static int _do_test(struct poller *p)
-{
-	return 1;
-}
-
-/*
- * It is a constructor, which means that it will automatically be called before
- * main(). This is GCC-specific but it works at least since 2.95.
- * Special care must be taken so that it does not need any uninitialized data.
- */
-__attribute__((constructor))
-static void _do_register(void)
-{
-	struct poller *p;
-
-	if (nbpollers >= MAX_POLLERS)
-		return;
-	p = &pollers[nbpollers++];
-
-	p->name = "poll";
-	p->pref = 200;
-	p->private = NULL;
-
-	p->test = _do_test;
-	p->init = _do_init;
-	p->term = _do_term;
-	p->poll = _do_poll;
-	p->is_set = __fd_is_set;
-	p->set = __fd_set;
-	p->clr = __fd_clr;
-	p->clo = p->rem = __fd_rem;
-	p->cond_s = __fd_cond_s;
-	p->cond_c = __fd_cond_c;
-}
-
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/ev_select.c b/deps/haproxy-1.4.21/src/ev_select.c
deleted file mode 100644
index 5a87282..0000000
--- a/deps/haproxy-1.4.21/src/ev_select.c
+++ /dev/null
@@ -1,259 +0,0 @@
-/*
- * FD polling functions for generic select()
- *
- * Copyright 2000-2008 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <unistd.h>
-#include <sys/time.h>
-#include <sys/types.h>
-
-#include <common/compat.h>
-#include <common/config.h>
-#include <common/ticks.h>
-#include <common/time.h>
-
-#include <types/global.h>
-
-#include <proto/fd.h>
-#include <proto/signal.h>
-#include <proto/task.h>
-
-
-static fd_set *fd_evts[2];
-static fd_set *tmp_evts[2];
-
-
-/*
- * Benchmarks performed on a Pentium-M notebook show that using functions
- * instead of the usual macros improve the FD_* performance by about 80%,
- * and that marking them regparm(2) adds another 20%.
- */
-REGPRM2 static int __fd_is_set(const int fd, int dir)
-{
-	return FD_ISSET(fd, fd_evts[dir]);
-}
-
-REGPRM2 static int __fd_set(const int fd, int dir)
-{
-	FD_SET(fd, fd_evts[dir]);
-	return 0;
-}
-
-REGPRM2 static int __fd_clr(const int fd, int dir)
-{
-	FD_CLR(fd, fd_evts[dir]);
-	return 0;
-}
-
-REGPRM2 static int __fd_cond_s(const int fd, int dir)
-{
-	int ret;
-	ret = !FD_ISSET(fd, fd_evts[dir]);
-	if (ret)
-		FD_SET(fd, fd_evts[dir]);
-	return ret;
-}
-
-REGPRM2 static int __fd_cond_c(const int fd, int dir)
-{
-	int ret;
-	ret = FD_ISSET(fd, fd_evts[dir]);
-	if (ret)
-		FD_CLR(fd, fd_evts[dir]);
-	return ret;
-}
-
-REGPRM1 static void __fd_rem(int fd)
-{
-	FD_CLR(fd, fd_evts[DIR_RD]);
-	FD_CLR(fd, fd_evts[DIR_WR]);
-}
-
-/*
- * Select() poller
- */
-REGPRM2 static void _do_poll(struct poller *p, int exp)
-{
-	int status;
-	int fd, i;
-	struct timeval delta;
-	int delta_ms;
-	int readnotnull, writenotnull;
-	int fds;
-	char count;
-		
-	delta_ms      = 0;
-	delta.tv_sec  = 0;
-	delta.tv_usec = 0;
-
-	if (!run_queue && !signal_queue_len) {
-		if (!exp) {
-			delta_ms      = MAX_DELAY_MS;
-			delta.tv_sec  = (MAX_DELAY_MS / 1000);
-			delta.tv_usec = (MAX_DELAY_MS % 1000) * 1000;
-		}
-		else if (!tick_is_expired(exp, now_ms)) {
-			delta_ms = TICKS_TO_MS(tick_remain(now_ms, exp)) + SCHEDULER_RESOLUTION;
-			if (delta_ms > MAX_DELAY_MS)
-				delta_ms = MAX_DELAY_MS;
-			delta.tv_sec  = (delta_ms / 1000);
-			delta.tv_usec = (delta_ms % 1000) * 1000;
-		}
-	}
-
-	/* let's restore fdset state */
-
-	readnotnull = 0; writenotnull = 0;
-	for (i = 0; i < (maxfd + FD_SETSIZE - 1)/(8*sizeof(int)); i++) {
-		readnotnull |= (*(((int*)tmp_evts[DIR_RD])+i) = *(((int*)fd_evts[DIR_RD])+i)) != 0;
-		writenotnull |= (*(((int*)tmp_evts[DIR_WR])+i) = *(((int*)fd_evts[DIR_WR])+i)) != 0;
-	}
-
-	//	/* just a verification code, needs to be removed for performance */
-	//	for (i=0; i<maxfd; i++) {
-	//	    if (FD_ISSET(i, tmp_evts[DIR_RD]) != FD_ISSET(i, fd_evts[DIR_RD]))
-	//		abort();
-	//	    if (FD_ISSET(i, tmp_evts[DIR_WR]) != FD_ISSET(i, fd_evts[DIR_WR]))
-	//		abort();
-	//	    
-	//	}
-
-	status = select(maxfd,
-			readnotnull ? tmp_evts[DIR_RD] : NULL,
-			writenotnull ? tmp_evts[DIR_WR] : NULL,
-			NULL,
-			&delta);
-      
-	tv_update_date(delta_ms, status);
-
-	if (status <= 0)
-		return;
-
-	for (fds = 0; (fds * BITS_PER_INT) < maxfd; fds++) {
-		if ((((int *)(tmp_evts[DIR_RD]))[fds] | ((int *)(tmp_evts[DIR_WR]))[fds]) == 0)
-			continue;
-
-		for (count = BITS_PER_INT, fd = fds * BITS_PER_INT; count && fd < maxfd; count--, fd++) {
-			/* if we specify read first, the accepts and zero reads will be
-			 * seen first. Moreover, system buffers will be flushed faster.
-			 */
-			if (FD_ISSET(fd, tmp_evts[DIR_RD])) {
-				if (fdtab[fd].state == FD_STCLOSE)
-					continue;
-				fdtab[fd].cb[DIR_RD].f(fd);
-			}
-
-			if (FD_ISSET(fd, tmp_evts[DIR_WR])) {
-				if (fdtab[fd].state == FD_STCLOSE)
-					continue;
-				fdtab[fd].cb[DIR_WR].f(fd);
-			}
-		}
-	}
-}
-
-/*
- * Initialization of the select() poller.
- * Returns 0 in case of failure, non-zero in case of success. If it fails, it
- * disables the poller by setting its pref to 0.
- */
-REGPRM1 static int _do_init(struct poller *p)
-{
-	__label__ fail_swevt, fail_srevt, fail_wevt, fail_revt;
-	int fd_set_bytes;
-
-	p->private = NULL;
-	fd_set_bytes = sizeof(fd_set) * (global.maxsock + FD_SETSIZE - 1) / FD_SETSIZE;
-
-	if ((tmp_evts[DIR_RD] = (fd_set *)calloc(1, fd_set_bytes)) == NULL)
-		goto fail_revt;
-		
-	if ((tmp_evts[DIR_WR] = (fd_set *)calloc(1, fd_set_bytes)) == NULL)
-		goto fail_wevt;
-
-	if ((fd_evts[DIR_RD] = (fd_set *)calloc(1, fd_set_bytes)) == NULL)
-		goto fail_srevt;
-
-	if ((fd_evts[DIR_WR] = (fd_set *)calloc(1, fd_set_bytes)) == NULL)
-		goto fail_swevt;
-
-	return 1;
-
- fail_swevt:
-	free(fd_evts[DIR_RD]);
- fail_srevt:
-	free(tmp_evts[DIR_WR]);
- fail_wevt:
-	free(tmp_evts[DIR_RD]);
- fail_revt:
-	p->pref = 0;
-	return 0;
-}
-
-/*
- * Termination of the select() poller.
- * Memory is released and the poller is marked as unselectable.
- */
-REGPRM1 static void _do_term(struct poller *p)
-{
-	free(fd_evts[DIR_WR]);
-	free(fd_evts[DIR_RD]);
-	free(tmp_evts[DIR_WR]);
-	free(tmp_evts[DIR_RD]);
-	p->private = NULL;
-	p->pref = 0;
-}
-
-/*
- * Check that the poller works.
- * Returns 1 if OK, otherwise 0.
- */
-REGPRM1 static int _do_test(struct poller *p)
-{
-	return 1;
-}
-
-/*
- * It is a constructor, which means that it will automatically be called before
- * main(). This is GCC-specific but it works at least since 2.95.
- * Special care must be taken so that it does not need any uninitialized data.
- */
-__attribute__((constructor))
-static void _do_register(void)
-{
-	struct poller *p;
-
-	if (nbpollers >= MAX_POLLERS)
-		return;
-	p = &pollers[nbpollers++];
-
-	p->name = "select";
-	p->pref = 150;
-	p->private = NULL;
-
-	p->test = _do_test;
-	p->init = _do_init;
-	p->term = _do_term;
-	p->poll = _do_poll;
-	p->is_set = __fd_is_set;
-	p->set = __fd_set;
-	p->clr = __fd_clr;
-	p->clo = p->rem = __fd_rem;
-	p->cond_s = __fd_cond_s;
-	p->cond_c = __fd_cond_c;
-}
-
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/ev_sepoll.c b/deps/haproxy-1.4.21/src/ev_sepoll.c
deleted file mode 100644
index 248f1f4..0000000
--- a/deps/haproxy-1.4.21/src/ev_sepoll.c
+++ /dev/null
@@ -1,667 +0,0 @@
-/*
- * FD polling functions for Speculative I/O combined with Linux epoll()
- *
- * Copyright 2000-2009 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- *
- * This code implements "speculative I/O" under Linux. The principle is to
- * try to perform expected I/O before registering the events in the poller.
- * Each time this succeeds, it saves an expensive epoll_ctl(). It generally
- * succeeds for all reads after an accept(), and for writes after a connect().
- * It also improves performance for streaming connections because even if only
- * one side is polled, the other one may react accordingly depending on the
- * level of the buffer.
- *
- * It has a presents drawbacks though. If too many events are set for spec I/O,
- * those ones can starve the polled events. Experiments show that when polled
- * events starve, they quickly turn into spec I/O, making the situation even
- * worse. While we can reduce the number of polled events processed at once,
- * we cannot do this on speculative events because most of them are new ones
- * (avg 2/3 new - 1/3 old from experiments).
- *
- * The solution against this problem relies on those two factors :
- *   1) one FD registered as a spec event cannot be polled at the same time
- *   2) even during very high loads, we will almost never be interested in
- *      simultaneous read and write streaming on the same FD.
- *
- * The first point implies that during starvation, we will not have more than
- * half of our FDs in the poll list, otherwise it means there is less than that
- * in the spec list, implying there is no starvation.
- *
- * The second point implies that we're statically only interested in half of
- * the maximum number of file descriptors at once, because we will unlikely
- * have simultaneous read and writes for a same buffer during long periods.
- *
- * So, if we make it possible to drain maxsock/2/2 during peak loads, then we
- * can ensure that there will be no starvation effect. This means that we must
- * always allocate maxsock/4 events for the poller.
- *
- *
- */
-
-#include <unistd.h>
-#include <sys/time.h>
-#include <sys/types.h>
-
-#include <common/compat.h>
-#include <common/config.h>
-#include <common/debug.h>
-#include <common/standard.h>
-#include <common/ticks.h>
-#include <common/time.h>
-#include <common/tools.h>
-
-#include <types/global.h>
-
-#include <proto/fd.h>
-#include <proto/signal.h>
-#include <proto/task.h>
-
-#if defined(USE_MY_EPOLL)
-#include <common/epoll.h>
-#include <errno.h>
-#include <sys/syscall.h>
-static _syscall1 (int, epoll_create, int, size);
-static _syscall4 (int, epoll_ctl, int, epfd, int, op, int, fd, struct epoll_event *, event);
-static _syscall4 (int, epoll_wait, int, epfd, struct epoll_event *, events, int, maxevents, int, timeout);
-#else
-#include <sys/epoll.h>
-#endif
-
-/*
- * We define 4 states for each direction of a file descriptor, which we store
- * as 2 bits :
- *
- *  00 = IDLE : we're not interested in this event
- *  01 = SPEC : perform speculative I/O on this FD
- *  10 = WAIT : really wait for an availability event on this FD (poll)
- *  11 = STOP : was marked WAIT, but disabled. It can switch back to WAIT if
- *              the application changes its mind, otherwise disable FD polling
- *              and switch back to IDLE.
- *
- * Since we do not want to scan all the FD list to find speculative I/O events,
- * we store them in a list consisting in a linear array holding only the FD
- * indexes right now. Note that a closed FD cannot exist in the spec list,
- * because it is closed by fd_delete() which in turn calls __fd_clo() which
- * always removes it from the list.
- *
- * The STOP state requires the event to be present in the spec list so that
- * it can be detected and flushed upon next scan without having to scan the
- * whole FD list.
- *
- * This translates like this :
- *
- *   EVENT_IN_SPEC_LIST = 01
- *   EVENT_IN_POLL_LIST = 10
- *
- *   IDLE = 0
- *   SPEC = (EVENT_IN_SPEC_LIST)
- *   WAIT = (EVENT_IN_POLL_LIST)
- *   STOP = (EVENT_IN_SPEC_LIST|EVENT_IN_POLL_LIST)
- *
- * fd_is_set() just consists in checking that the status is 01 or 10.
- *
- * For efficiency reasons, we will store the Read and Write bits interlaced to
- * form a 4-bit field, so that we can simply shift the value right by 0/1 and
- * get what we want :
- *    3  2  1  0
- *   Wp Rp Ws Rs
- *
- * The FD array has to hold a back reference to the speculative list. This
- * reference is only valid if at least one of the directions is marked SPEC.
- *
- */
-
-#define FD_EV_IN_SL	1
-#define FD_EV_IN_PL	4
-
-#define FD_EV_IDLE	0
-#define FD_EV_SPEC	(FD_EV_IN_SL)
-#define FD_EV_WAIT	(FD_EV_IN_PL)
-#define FD_EV_STOP	(FD_EV_IN_SL|FD_EV_IN_PL)
-
-/* Those match any of R or W for Spec list or Poll list */
-#define FD_EV_RW_SL	(FD_EV_IN_SL | (FD_EV_IN_SL << 1))
-#define FD_EV_RW_PL	(FD_EV_IN_PL | (FD_EV_IN_PL << 1))
-#define FD_EV_MASK_DIR	(FD_EV_IN_SL|FD_EV_IN_PL)
-
-#define FD_EV_IDLE_R	0
-#define FD_EV_SPEC_R	(FD_EV_IN_SL)
-#define FD_EV_WAIT_R	(FD_EV_IN_PL)
-#define FD_EV_STOP_R	(FD_EV_IN_SL|FD_EV_IN_PL)
-#define FD_EV_MASK_R	(FD_EV_IN_SL|FD_EV_IN_PL)
-
-#define FD_EV_IDLE_W	(FD_EV_IDLE_R << 1)
-#define FD_EV_SPEC_W	(FD_EV_SPEC_R << 1)
-#define FD_EV_WAIT_W	(FD_EV_WAIT_R << 1)
-#define FD_EV_STOP_W	(FD_EV_STOP_R << 1)
-#define FD_EV_MASK_W	(FD_EV_MASK_R << 1)
-
-#define FD_EV_MASK	(FD_EV_MASK_W | FD_EV_MASK_R)
-
-/* This is the minimum number of events successfully processed in speculative
- * mode above which we agree to return without checking epoll() (1/2 times).
- */
-#define MIN_RETURN_EVENTS	25
-
-static int nbspec = 0;          // current size of the spec list
-static int absmaxevents = 0;    // absolute maximum amounts of polled events
-static int fd_created = 0;      // fd creation detector, reset upon poll() entry.
-
-static unsigned int *spec_list = NULL;	// speculative I/O list
-
-/* private data */
-static struct epoll_event *epoll_events;
-static int epoll_fd;
-
-/* This structure may be used for any purpose. Warning! do not use it in
- * recursive functions !
- */
-static struct epoll_event ev;
-
-
-REGPRM1 static inline void alloc_spec_entry(const int fd)
-{
-	if (fdtab[fd].spec.s1)
-		/* sometimes the entry already exists for the other direction */
-		return;
-	fdtab[fd].spec.s1 = nbspec + 1;
-	spec_list[nbspec] = fd;
-	nbspec++;
-}
-
-/* Removes entry used by fd <fd> from the spec list and replaces it with the
- * last one. The fdtab.spec is adjusted to match the back reference if needed.
- * If the fd has no entry assigned, return immediately.
- */
-REGPRM1 static void release_spec_entry(int fd)
-{
-	unsigned int pos;
-
-	pos = fdtab[fd].spec.s1;
-	if (!pos)
-		return;
-
-	fdtab[fd].spec.s1 = 0;
-	pos--;
-	/* we have spec_list[pos]==fd */
-
-	nbspec--;
-	if (pos == nbspec)
-		return;
-
-	/* we replace current FD by the highest one, which may sometimes be the same */
-	fd = spec_list[nbspec];
-	spec_list[pos] = fd;
-	fdtab[fd].spec.s1 = pos + 1;
-}
-
-/*
- * Returns non-zero if <fd> is already monitored for events in direction <dir>.
- */
-REGPRM2 static int __fd_is_set(const int fd, int dir)
-{
-	int ret;
-
-#if DEBUG_DEV
-	if (fdtab[fd].state == FD_STCLOSE) {
-		fprintf(stderr, "sepoll.fd_isset called on closed fd #%d.\n", fd);
-		ABORT_NOW();
-	}
-#endif
-	ret = ((unsigned)fdtab[fd].spec.e >> dir) & FD_EV_MASK_DIR;
-	return (ret == FD_EV_SPEC || ret == FD_EV_WAIT);
-}
-
-/*
- * Don't worry about the strange constructs in __fd_set/__fd_clr, they are
- * designed like this in order to reduce the number of jumps (verified).
- */
-REGPRM2 static int __fd_set(const int fd, int dir)
-{
-	unsigned int i;
-
-#if DEBUG_DEV
-	if (fdtab[fd].state == FD_STCLOSE) {
-		fprintf(stderr, "sepoll.fd_set called on closed fd #%d.\n", fd);
-		ABORT_NOW();
-	}
-#endif
-	i = ((unsigned)fdtab[fd].spec.e >> dir) & FD_EV_MASK_DIR;
-
-	if (i != FD_EV_STOP) {
-		if (unlikely(i != FD_EV_IDLE))
-			return 0;
-		// switch to SPEC state and allocate a SPEC entry.
-		fd_created++;
-		alloc_spec_entry(fd);
-	}
-	fdtab[fd].spec.e ^= (unsigned int)(FD_EV_IN_SL << dir);
-	return 1;
-}
-
-REGPRM2 static int __fd_clr(const int fd, int dir)
-{
-	unsigned int i;
-
-#if DEBUG_DEV
-	if (fdtab[fd].state == FD_STCLOSE) {
-		fprintf(stderr, "sepoll.fd_clr called on closed fd #%d.\n", fd);
-		ABORT_NOW();
-	}
-#endif
-	i = ((unsigned)fdtab[fd].spec.e >> dir) & FD_EV_MASK_DIR;
-
-	if (i != FD_EV_SPEC) {
-		if (unlikely(i != FD_EV_WAIT))
-			return 0;
-		// switch to STOP state
-		/* We will create a queue entry for this one because we want to
-		 * process it later in order to merge it with other events on
-		 * the same FD.
-		 */
-		alloc_spec_entry(fd);
-	}
-	fdtab[fd].spec.e ^= (unsigned int)(FD_EV_IN_SL << dir);
-	return 1;
-}
-
-/* normally unused */
-REGPRM1 static void __fd_rem(int fd)
-{
-	__fd_clr(fd, DIR_RD);
-	__fd_clr(fd, DIR_WR);
-}
-
-/*
- * On valid epoll() implementations, a call to close() automatically removes
- * the fds. This means that the FD will appear as previously unset.
- */
-REGPRM1 static void __fd_clo(int fd)
-{
-	release_spec_entry(fd);
-	fdtab[fd].spec.e &= ~(FD_EV_MASK);
-}
-
-/*
- * speculative epoll() poller
- */
-REGPRM2 static void _do_poll(struct poller *p, int exp)
-{
-	static unsigned int last_skipped;
-	static unsigned int spec_processed;
-	int status, eo;
-	int fd, opcode;
-	int count;
-	int spec_idx;
-	int wait_time;
-	int looping = 0;
-
-
- re_poll_once:
-	/* Here we have two options :
-	 * - either walk the list forwards and hope to match more events
-	 * - or walk it backwards to minimize the number of changes and
-	 *   to make better use of the cache.
-	 * Tests have shown that walking backwards improves perf by 0.2%.
-	 */
-
-	status = 0;
-	spec_idx = nbspec;
-	while (likely(spec_idx > 0)) {
-		int done;
-
-		spec_idx--;
-		fd = spec_list[spec_idx];
-		eo = fdtab[fd].spec.e;  /* save old events */
-
-		if (looping && --fd_created < 0) {
-			/* we were just checking the newly created FDs */
-			break;
-		}
-		/*
-		 * Process the speculative events.
-		 *
-		 * Principle: events which are marked FD_EV_SPEC are processed
-		 * with their assigned function. If the function returns 0, it
-		 * means there is nothing doable without polling first. We will
-		 * then convert the event to a pollable one by assigning them
-		 * the WAIT status.
-		 */
-
-#ifdef DEBUG_DEV
-		if (fdtab[fd].state == FD_STCLOSE) {
-			fprintf(stderr,"fd=%d, fdtab[].ev=%x, fdtab[].spec.e=%x, .s=%d, idx=%d\n",
-				fd, fdtab[fd].ev, fdtab[fd].spec.e, fdtab[fd].spec.s1, spec_idx);
-		}
-#endif
-		done = 0;
-		fdtab[fd].ev &= FD_POLL_STICKY;
-		if ((eo & FD_EV_MASK_R) == FD_EV_SPEC_R) {
-			/* The owner is interested in reading from this FD */
-			if (fdtab[fd].state != FD_STERROR) {
-				/* Pretend there is something to read */
-				fdtab[fd].ev |= FD_POLL_IN;
-				if (!fdtab[fd].cb[DIR_RD].f(fd))
-					fdtab[fd].spec.e ^= (FD_EV_WAIT_R ^ FD_EV_SPEC_R);
-				else
-					done = 1;
-			}
-		}
-		else if ((eo & FD_EV_MASK_R) == FD_EV_STOP_R) {
-			/* This FD was being polled and is now being removed. */
-			fdtab[fd].spec.e &= ~FD_EV_MASK_R;
-		}
-		
-		if ((eo & FD_EV_MASK_W) == FD_EV_SPEC_W) {
-			/* The owner is interested in writing to this FD */
-			if (fdtab[fd].state != FD_STERROR) {
-				/* Pretend there is something to write */
-				fdtab[fd].ev |= FD_POLL_OUT;
-				if (!fdtab[fd].cb[DIR_WR].f(fd))
-					fdtab[fd].spec.e ^= (FD_EV_WAIT_W ^ FD_EV_SPEC_W);
-				else
-					done = 1;
-			}
-		}
-		else if ((eo & FD_EV_MASK_W) == FD_EV_STOP_W) {
-			/* This FD was being polled and is now being removed. */
-			fdtab[fd].spec.e &= ~FD_EV_MASK_W;
-		}
-
-		status += done;
-		/* one callback might already have closed the fd by itself */
-		if (fdtab[fd].state == FD_STCLOSE)
-			continue;
-
-		/* Now, we will adjust the event in the poll list. Indeed, it
-		 * is possible that an event which was previously in the poll
-		 * list now goes out, and the opposite is possible too. We can
-		 * have opposite changes for READ and WRITE too.
-		 */
-
-		if ((eo ^ fdtab[fd].spec.e) & FD_EV_RW_PL) {
-			/* poll status changed*/
-			if ((fdtab[fd].spec.e & FD_EV_RW_PL) == 0) {
-				/* fd removed from poll list */
-				opcode = EPOLL_CTL_DEL;
-			}
-			else if ((eo & FD_EV_RW_PL) == 0) {
-				/* new fd in the poll list */
-				opcode = EPOLL_CTL_ADD;
-			}
-			else {
-				/* fd status changed */
-				opcode = EPOLL_CTL_MOD;
-			}
-
-			/* construct the epoll events based on new state */
-			ev.events = 0;
-			if (fdtab[fd].spec.e & FD_EV_WAIT_R)
-				ev.events |= EPOLLIN;
-
-			if (fdtab[fd].spec.e & FD_EV_WAIT_W)
-				ev.events |= EPOLLOUT;
-
-			ev.data.fd = fd;
-			epoll_ctl(epoll_fd, opcode, fd, &ev);
-		}
-
-
-		if (!(fdtab[fd].spec.e & FD_EV_RW_SL)) {
-			/* This fd switched to combinations of either WAIT or
-			 * IDLE. It must be removed from the spec list.
-			 */
-			release_spec_entry(fd);
-			continue;
-		}
-	}
-
-	/* It may make sense to immediately return here if there are enough
-	 * processed events, without passing through epoll_wait() because we
-	 * have exactly done a poll.
-	 * Measures have shown a great performance increase if we call the
-	 * epoll_wait() only the second time after speculative accesses have
-	 * succeeded. This reduces the number of unsucessful calls to
-	 * epoll_wait() by a factor of about 3, and the total number of calls
-	 * by about 2.
-	 * However, when we do that after having processed too many events,
-	 * events waiting in epoll() starve for too long a time and tend to
-	 * become themselves eligible for speculative polling. So we try to
-	 * limit this practise to reasonable situations.
-	 */
-
-	spec_processed += status;
-
-	if (looping) {
-		last_skipped++;
-		return;
-	}
-
-	if (status >= MIN_RETURN_EVENTS && spec_processed < absmaxevents) {
-		/* We have processed at least MIN_RETURN_EVENTS, it's worth
-		 * returning now without checking epoll_wait().
-		 */
-		if (++last_skipped <= 1) {
-			tv_update_date(0, 1);
-			return;
-		}
-	}
-	last_skipped = 0;
-
-	if (nbspec || status || run_queue || signal_queue_len) {
-		/* Maybe we have processed some events that we must report, or
-		 * maybe we still have events in the spec list, or there are
-		 * some tasks left pending in the run_queue, so we must not
-		 * wait in epoll() otherwise we will delay their delivery by
-		 * the next timeout.
-		 */
-		wait_time = 0;
-	}
-	else {
-		if (!exp)
-			wait_time = MAX_DELAY_MS;
-		else if (tick_is_expired(exp, now_ms))
-			wait_time = 0;
-		else {
-			wait_time = TICKS_TO_MS(tick_remain(now_ms, exp)) + 1;
-			if (wait_time > MAX_DELAY_MS)
-				wait_time = MAX_DELAY_MS;
-		}
-	}
-
-	/* now let's wait for real events. We normally use maxpollevents as a
-	 * high limit, unless <nbspec> is already big, in which case we need
-	 * to compensate for the high number of events processed there.
-	 */
-	fd = MIN(absmaxevents, spec_processed);
-	fd = MAX(global.tune.maxpollevents, fd);
-	fd = MIN(maxfd, fd);
-	/* we want to detect if an accept() will create new speculative FDs here */
-	fd_created = 0;
-	spec_processed = 0;
-	status = epoll_wait(epoll_fd, epoll_events, fd, wait_time);
-	tv_update_date(wait_time, status);
-
-	for (count = 0; count < status; count++) {
-		int e = epoll_events[count].events;
-		fd = epoll_events[count].data.fd;
-
-		/* it looks complicated but gcc can optimize it away when constants
-		 * have same values.
-		 */
-		DPRINTF(stderr, "%s:%d: fd=%d, ev=0x%08x, e=0x%08x\n",
-			__FUNCTION__, __LINE__,
-			fd, fdtab[fd].ev, e);
-
-		fdtab[fd].ev &= FD_POLL_STICKY;
-		fdtab[fd].ev |= 
-			((e & EPOLLIN ) ? FD_POLL_IN  : 0) |
-			((e & EPOLLPRI) ? FD_POLL_PRI : 0) |
-			((e & EPOLLOUT) ? FD_POLL_OUT : 0) |
-			((e & EPOLLERR) ? FD_POLL_ERR : 0) |
-			((e & EPOLLHUP) ? FD_POLL_HUP : 0);
-		
-		if ((fdtab[fd].spec.e & FD_EV_MASK_R) == FD_EV_WAIT_R) {
-			if (fdtab[fd].state == FD_STCLOSE || fdtab[fd].state == FD_STERROR)
-				continue;
-			if (fdtab[fd].ev & (FD_POLL_IN|FD_POLL_HUP|FD_POLL_ERR))
-				fdtab[fd].cb[DIR_RD].f(fd);
-		}
-
-		if ((fdtab[fd].spec.e & FD_EV_MASK_W) == FD_EV_WAIT_W) {
-			if (fdtab[fd].state == FD_STCLOSE || fdtab[fd].state == FD_STERROR)
-				continue;
-			if (fdtab[fd].ev & (FD_POLL_OUT|FD_POLL_ERR))
-				fdtab[fd].cb[DIR_WR].f(fd);
-		}
-	}
-
-	if (fd_created) {
-		/* we have created some fds, certainly in return of an accept(),
-		 * and they're marked as speculative. If we can manage to perform
-		 * a read(), we're almost sure to collect all the request at once
-		 * and avoid several expensive wakeups. So let's try now. Anyway,
-		 * if we fail, the tasks are still woken up, and the FD gets marked
-		 * for poll mode.
-		 */
-		looping = 1;
-		goto re_poll_once;
-	}
-}
-
-/*
- * Initialization of the speculative epoll() poller.
- * Returns 0 in case of failure, non-zero in case of success. If it fails, it
- * disables the poller by setting its pref to 0.
- */
-REGPRM1 static int _do_init(struct poller *p)
-{
-	__label__ fail_spec, fail_ee, fail_fd;
-
-	p->private = NULL;
-
-	epoll_fd = epoll_create(global.maxsock + 1);
-	if (epoll_fd < 0)
-		goto fail_fd;
-
-	/* See comments at the top of the file about this formula. */
-	absmaxevents = MAX(global.tune.maxpollevents, global.maxsock/4);
-	epoll_events = (struct epoll_event*)
-		calloc(1, sizeof(struct epoll_event) * absmaxevents);
-
-	if (epoll_events == NULL)
-		goto fail_ee;
-
-	if ((spec_list = (uint32_t *)calloc(1, sizeof(uint32_t) * global.maxsock)) == NULL)
-		goto fail_spec;
-
-	return 1;
-
- fail_spec:
-	free(epoll_events);
- fail_ee:
-	close(epoll_fd);
-	epoll_fd = -1;
- fail_fd:
-	p->pref = 0;
-	return 0;
-}
-
-/*
- * Termination of the speculative epoll() poller.
- * Memory is released and the poller is marked as unselectable.
- */
-REGPRM1 static void _do_term(struct poller *p)
-{
-	free(spec_list);
-	free(epoll_events);
-
-	if (epoll_fd >= 0) {
-		close(epoll_fd);
-		epoll_fd = -1;
-	}
-
-	spec_list = NULL;
-	epoll_events = NULL;
-
-	p->private = NULL;
-	p->pref = 0;
-}
-
-/*
- * Check that the poller works.
- * Returns 1 if OK, otherwise 0.
- */
-REGPRM1 static int _do_test(struct poller *p)
-{
-	int fd;
-
-	fd = epoll_create(global.maxsock + 1);
-	if (fd < 0)
-		return 0;
-	close(fd);
-	return 1;
-}
-
-/*
- * Recreate the epoll file descriptor after a fork(). Returns 1 if OK,
- * otherwise 0. It will ensure that all processes will not share their
- * epoll_fd. Some side effects were encountered because of this, such
- * as epoll_wait() returning an FD which was previously deleted.
- */
-REGPRM1 static int _do_fork(struct poller *p)
-{
-	if (epoll_fd >= 0)
-		close(epoll_fd);
-	epoll_fd = epoll_create(global.maxsock + 1);
-	if (epoll_fd < 0)
-		return 0;
-	return 1;
-}
-
-/*
- * It is a constructor, which means that it will automatically be called before
- * main(). This is GCC-specific but it works at least since 2.95.
- * Special care must be taken so that it does not need any uninitialized data.
- */
-__attribute__((constructor))
-static void _do_register(void)
-{
-	struct poller *p;
-
-	if (nbpollers >= MAX_POLLERS)
-		return;
-
-	epoll_fd = -1;
-	p = &pollers[nbpollers++];
-
-	p->name = "sepoll";
-	p->pref = 400;
-	p->private = NULL;
-
-	p->test = _do_test;
-	p->init = _do_init;
-	p->term = _do_term;
-	p->poll = _do_poll;
-	p->fork = _do_fork;
-
-	p->is_set  = __fd_is_set;
-	p->cond_s = p->set = __fd_set;
-	p->cond_c = p->clr = __fd_clr;
-	p->rem = __fd_rem;
-	p->clo = __fd_clo;
-}
-
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/fd.c b/deps/haproxy-1.4.21/src/fd.c
deleted file mode 100644
index 80bddd6..0000000
--- a/deps/haproxy-1.4.21/src/fd.c
+++ /dev/null
@@ -1,182 +0,0 @@
-/*
- * File descriptors management functions.
- *
- * Copyright 2000-2008 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <stdio.h>
-#include <string.h>
-#include <unistd.h>
-#include <sys/types.h>
-
-#include <common/compat.h>
-#include <common/config.h>
-
-#include <proto/fd.h>
-#include <proto/port_range.h>
-
-struct fdtab *fdtab = NULL;     /* array of all the file descriptors */
-struct fdinfo *fdinfo = NULL;   /* less-often used infos for file descriptors */
-int maxfd;                      /* # of the highest fd + 1 */
-int totalconn;                  /* total # of terminated sessions */
-int actconn;                    /* # of active sessions */
-
-struct poller pollers[MAX_POLLERS];
-struct poller cur_poller;
-int nbpollers = 0;
-
-
-/* Deletes an FD from the fdsets, and recomputes the maxfd limit.
- * The file descriptor is also closed.
- */
-void fd_delete(int fd)
-{
-	EV_FD_CLO(fd);
-	port_range_release_port(fdinfo[fd].port_range, fdinfo[fd].local_port);
-	fdinfo[fd].port_range = NULL;
-	close(fd);
-	fdtab[fd].state = FD_STCLOSE;
-
-	while ((maxfd-1 >= 0) && (fdtab[maxfd-1].state == FD_STCLOSE))
-		maxfd--;
-}
-
-
-/* disable the specified poller */
-void disable_poller(const char *poller_name)
-{
-	int p;
-
-	for (p = 0; p < nbpollers; p++)
-		if (strcmp(pollers[p].name, poller_name) == 0)
-			pollers[p].pref = 0;
-}
-
-/*
- * Initialize the pollers till the best one is found.
- * If none works, returns 0, otherwise 1.
- */
-int init_pollers()
-{
-	int p;
-	struct poller *bp;
-
-
-	do {
-		bp = NULL;
-		for (p = 0; p < nbpollers; p++)
-			if (!bp || (pollers[p].pref > bp->pref))
-				bp = &pollers[p];
-
-		if (!bp || bp->pref == 0)
-			break;
-
-		if (bp->init(bp)) {
-			memcpy(&cur_poller, bp, sizeof(*bp));
-			return 1;
-		}
-	} while (!bp || bp->pref == 0);
-	return 0;
-}
-
-/*
- * Deinitialize the pollers.
- */
-void deinit_pollers() {
-
-	struct poller *bp;
-	int p;
-
-	for (p = 0; p < nbpollers; p++) {
-		bp = &pollers[p];
-
-		if (bp && bp->pref)
-			bp->term(bp);
-	}
-}
-
-/*
- * Lists the known pollers on <out>.
- * Should be performed only before initialization.
- */
-int list_pollers(FILE *out)
-{
-	int p;
-	int last, next;
-	int usable;
-	struct poller *bp;
-
-	fprintf(out, "Available polling systems :\n");
-
-	usable = 0;
-	bp = NULL;
-	last = next = -1;
-	while (1) {
-		for (p = 0; p < nbpollers; p++) {
-			if ((next < 0 || pollers[p].pref > next)
-			    && (last < 0 || pollers[p].pref < last)) {
-				next = pollers[p].pref;
-				if (!bp || (pollers[p].pref > bp->pref))
-					bp = &pollers[p];
-			}
-		}
-
-		if (next == -1)
-			break;
-
-		for (p = 0; p < nbpollers; p++) {
-			if (pollers[p].pref == next) {
-				fprintf(out, " %10s : ", pollers[p].name);
-				if (pollers[p].pref == 0)
-					fprintf(out, "disabled, ");
-				else
-					fprintf(out, "pref=%3d, ", pollers[p].pref);
-				if (pollers[p].test(&pollers[p])) {
-					fprintf(out, " test result OK");
-					if (next > 0)
-						usable++;
-				} else {
-					fprintf(out, " test result FAILED");
-					if (bp == &pollers[p])
-						bp = NULL;
-				}
-				fprintf(out, "\n");
-			}
-		}
-		last = next;
-		next = -1;
-	};
-	fprintf(out, "Total: %d (%d usable), will use %s.\n", nbpollers, usable, bp ? bp->name : "none");
-	return 0;
-}
-
-/*
- * Some pollers may lose their connection after a fork(). It may be necessary
- * to create initialize part of them again. Returns 0 in case of failure,
- * otherwise 1. The fork() function may be NULL if unused. In case of error,
- * the the current poller is destroyed and the caller is responsible for trying
- * another one by calling init_pollers() again.
- */
-int fork_poller()
-{
-	if (cur_poller.fork) {
-		if (cur_poller.fork(&cur_poller))
-			return 1;
-		cur_poller.term(&cur_poller);
-		return 0;
-	}
-	return 1;
-}
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/freq_ctr.c b/deps/haproxy-1.4.21/src/freq_ctr.c
deleted file mode 100644
index 3df930f..0000000
--- a/deps/haproxy-1.4.21/src/freq_ctr.c
+++ /dev/null
@@ -1,119 +0,0 @@
-/*
- * Event rate calculation functions.
- *
- * Copyright 2000-2009 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <common/config.h>
-#include <common/standard.h>
-#include <common/time.h>
-#include <common/tools.h>
-#include <proto/freq_ctr.h>
-
-/* Read a frequency counter taking history into account for missing time in
- * current period. Current second is sub-divided in 1000 chunks of one ms,
- * and the missing ones are read proportionally from previous value. The
- * return value has the same precision as one input data sample, so low rates
- * will be inaccurate still appropriate for max checking. One trick we use for
- * low values is to specially handle the case where the rate is between 0 and 1
- * in order to avoid flapping while waiting for the next event.
- *
- * For immediate limit checking, it's recommended to use freq_ctr_remain() and
- * next_event_delay() instead which do not have the flapping correction, so
- * that even frequencies as low as one event/period are properly handled.
- */
-unsigned int read_freq_ctr(struct freq_ctr *ctr)
-{
-	unsigned int curr, past;
-	unsigned int age;
-
-	age = now.tv_sec - ctr->curr_sec;
-	if (unlikely(age > 1))
-		return 0;
-
-	curr = 0;		
-	past = ctr->curr_ctr;
-	if (likely(!age)) {
-		curr = past;
-		past = ctr->prev_ctr;
-	}
-
-	if (past <= 1 && !curr)
-		return past; /* very low rate, avoid flapping */
-
-	return curr + mul32hi(past, ~curr_sec_ms_scaled);
-}
-
-/* returns the number of remaining events that can occur on this freq counter
- * while respecting <freq> and taking into account that <pend> events are
- * already known to be pending. Returns 0 if limit was reached.
- */
-unsigned int freq_ctr_remain(struct freq_ctr *ctr, unsigned int freq, unsigned int pend)
-{
-	unsigned int curr, past;
-	unsigned int age;
-
-	past = 0;
-	curr = 0;		
-	age = now.tv_sec - ctr->curr_sec;
-
-	if (likely(age <= 1)) {
-		past = ctr->curr_ctr;
-		if (likely(!age)) {
-			curr = past;
-			past = ctr->prev_ctr;
-		}
-		curr += mul32hi(past, ~curr_sec_ms_scaled);
-	}
-	curr += pend;
-
-	if (curr >= freq)
-		return 0;
-	return freq - curr;
-}
-
-/* return the expected wait time in ms before the next event may occur,
- * respecting frequency <freq>, and assuming there may already be some pending
- * events. It returns zero if we can proceed immediately, otherwise the wait
- * time, which will be rounded down 1ms for better accuracy, with a minimum
- * of one ms.
- */
-unsigned int next_event_delay(struct freq_ctr *ctr, unsigned int freq, unsigned int pend)
-{
-	unsigned int curr, past;
-	unsigned int wait, age;
-
-	past = 0;
-	curr = 0;		
-	age = now.tv_sec - ctr->curr_sec;
-
-	if (likely(age <= 1)) {
-		past = ctr->curr_ctr;
-		if (likely(!age)) {
-			curr = past;
-			past = ctr->prev_ctr;
-		}
-		curr += mul32hi(past, ~curr_sec_ms_scaled);
-	}
-	curr += pend;
-
-	if (curr < freq)
-		return 0;
-
-	wait = 999 / curr;
-	return MAX(wait, 1);
-}
-
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/haproxy.c b/deps/haproxy-1.4.21/src/haproxy.c
deleted file mode 100644
index 6141a5b..0000000
--- a/deps/haproxy-1.4.21/src/haproxy.c
+++ /dev/null
@@ -1,1280 +0,0 @@
-/*
- * HA-Proxy : High Availability-enabled HTTP/TCP proxy
- * Copyright 2000-2012  Willy Tarreau <w@1wt.eu>.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- * Please refer to RFC2068 or RFC2616 for informations about HTTP protocol, and
- * RFC2965 for informations about cookies usage. More generally, the IETF HTTP
- * Working Group's web site should be consulted for protocol related changes :
- *
- *     http://ftp.ics.uci.edu/pub/ietf/http/
- *
- * Pending bugs (may be not fixed because never reproduced) :
- *   - solaris only : sometimes, an HTTP proxy with only a dispatch address causes
- *     the proxy to terminate (no core) if the client breaks the connection during
- *     the response. Seen on 1.1.8pre4, but never reproduced. May not be related to
- *     the snprintf() bug since requests were simple (GET / HTTP/1.0), but may be
- *     related to missing setsid() (fixed in 1.1.15)
- *   - a proxy with an invalid config will prevent the startup even if disabled.
- *
- * ChangeLog has moved to the CHANGELOG file.
- *
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <string.h>
-#include <ctype.h>
-#include <sys/time.h>
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <netinet/tcp.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include <netdb.h>
-#include <fcntl.h>
-#include <errno.h>
-#include <signal.h>
-#include <stdarg.h>
-#include <sys/resource.h>
-#include <time.h>
-#include <syslog.h>
-
-#ifdef DEBUG_FULL
-#include <assert.h>
-#endif
-
-#include <common/appsession.h>
-#include <common/base64.h>
-#include <common/cfgparse.h>
-#include <common/compat.h>
-#include <common/config.h>
-#include <common/defaults.h>
-#include <common/errors.h>
-#include <common/memory.h>
-#include <common/mini-clist.h>
-#include <common/regex.h>
-#include <common/standard.h>
-#include <common/time.h>
-#include <common/uri_auth.h>
-#include <common/version.h>
-
-#include <types/capture.h>
-#include <types/global.h>
-
-#include <proto/auth.h>
-#include <proto/acl.h>
-#include <proto/backend.h>
-#include <proto/buffers.h>
-#include <proto/checks.h>
-#include <proto/client.h>
-#include <proto/fd.h>
-#include <proto/log.h>
-#include <proto/protocols.h>
-#include <proto/proto_http.h>
-#include <proto/proxy.h>
-#include <proto/queue.h>
-#include <proto/server.h>
-#include <proto/session.h>
-#include <proto/signal.h>
-#include <proto/stream_sock.h>
-#include <proto/task.h>
-
-#ifdef CONFIG_HAP_CTTPROXY
-#include <proto/cttproxy.h>
-#endif
-
-/*********************************************************************/
-
-/*********************************************************************/
-
-/* list of config files */
-static struct list cfg_cfgfiles = LIST_HEAD_INIT(cfg_cfgfiles);
-int  pid;			/* current process id */
-int  relative_pid = 1;		/* process id starting at 1 */
-
-/* global options */
-struct global global = {
-	logfac1 : -1,
-	logfac2 : -1,
-	loglev1 : 7, /* max syslog level : debug */
-	loglev2 : 7,
-	.stats_sock = {
-		.maxconn = 10, /* 10 concurrent stats connections */
-		.perm = {
-			 .ux = {
-				 .uid = -1,
-				 .gid = -1,
-				 .mode = 0,
-			 }
-		 }
-	},
-	.tune = {
-		.bufsize = BUFSIZE,
-		.maxrewrite = MAXREWRITE,
-		.chksize = BUFSIZE,
-	},
-	/* others NULL OK */
-};
-
-/*********************************************************************/
-
-int stopping;	/* non zero means stopping in progress */
-
-/* Here we store informations about the pids of the processes we may pause
- * or kill. We will send them a signal every 10 ms until we can bind to all
- * our ports. With 200 retries, that's about 2 seconds.
- */
-#define MAX_START_RETRIES	200
-static int *oldpids = NULL;
-static int oldpids_sig; /* use USR1 or TERM */
-
-/* this is used to drain data, and as a temporary buffer for sprintf()... */
-char *trash = NULL;
-int trashlen = BUFSIZE;
-
-/* this buffer is always the same size as standard buffers and is used for
- * swapping data inside a buffer.
- */
-char *swap_buffer = NULL;
-
-int nb_oldpids = 0;
-const int zero = 0;
-const int one = 1;
-const struct linger nolinger = { .l_onoff = 1, .l_linger = 0 };
-
-char hostname[MAX_HOSTNAME_LEN];
-
-
-/*********************************************************************/
-/*  general purpose functions  ***************************************/
-/*********************************************************************/
-
-void display_version()
-{
-	printf("HA-Proxy version " HAPROXY_VERSION " " HAPROXY_DATE"\n");
-	printf("Copyright 2000-2012 Willy Tarreau <w@1wt.eu>\n\n");
-}
-
-void display_build_opts()
-{
-	printf("Build options :"
-#ifdef BUILD_TARGET
-	       "\n  TARGET  = " BUILD_TARGET
-#endif
-#ifdef BUILD_CPU
-	       "\n  CPU     = " BUILD_CPU
-#endif
-#ifdef BUILD_CC
-	       "\n  CC      = " BUILD_CC
-#endif
-#ifdef BUILD_CFLAGS
-	       "\n  CFLAGS  = " BUILD_CFLAGS
-#endif
-#ifdef BUILD_OPTIONS
-	       "\n  OPTIONS = " BUILD_OPTIONS
-#endif
-	       "\n\nDefault settings :"
-	       "\n  maxconn = %d, bufsize = %d, maxrewrite = %d, maxpollevents = %d"
-	       "\n\n",
-	       DEFAULT_MAXCONN, BUFSIZE, MAXREWRITE, MAX_POLL_EVENTS);
-
-	printf("Encrypted password support via crypt(3): "
-#ifdef CONFIG_HAP_CRYPT
-		"yes"
-#else
-		"no"
-#endif
-		"\n");
-
-	putchar('\n');
-
-	list_pollers(stdout);
-	putchar('\n');
-}
-
-/*
- * This function prints the command line usage and exits
- */
-void usage(char *name)
-{
-	display_version();
-	fprintf(stderr,
-		"Usage : %s [-f <cfgfile>]* [ -vdV"
-		"D ] [ -n <maxconn> ] [ -N <maxpconn> ]\n"
-		"        [ -p <pidfile> ] [ -m <max megs> ]\n"
-		"        -v displays version ; -vv shows known build options.\n"
-		"        -d enters debug mode ; -db only disables background mode.\n"
-		"        -V enters verbose mode (disables quiet mode)\n"
-		"        -D goes daemon\n"
-		"        -q quiet mode : don't display messages\n"
-		"        -c check mode : only check config files and exit\n"
-		"        -n sets the maximum total # of connections (%d)\n"
-		"        -m limits the usable amount of memory (in MB)\n"
-		"        -N sets the default, per-proxy maximum # of connections (%d)\n"
-		"        -p writes pids of all children to this file\n"
-#if defined(ENABLE_EPOLL)
-		"        -de disables epoll() usage even when available\n"
-#endif
-#if defined(ENABLE_SEPOLL)
-		"        -ds disables speculative epoll() usage even when available\n"
-#endif
-#if defined(ENABLE_KQUEUE)
-		"        -dk disables kqueue() usage even when available\n"
-#endif
-#if defined(ENABLE_POLL)
-		"        -dp disables poll() usage even when available\n"
-#endif
-#if defined(CONFIG_HAP_LINUX_SPLICE)
-		"        -dS disables splice usage (broken on old kernels)\n"
-#endif
-		"        -sf/-st [pid ]* finishes/terminates old pids. Must be last arguments.\n"
-		"\n",
-		name, DEFAULT_MAXCONN, cfg_maxpconn);
-	exit(1);
-}
-
-
-
-/*********************************************************************/
-/*   more specific functions   ***************************************/
-/*********************************************************************/
-
-/*
- * upon SIGUSR1, let's have a soft stop.
- */
-void sig_soft_stop(int sig)
-{
-	soft_stop();
-	pool_gc2();
-	signal_register(sig, SIG_IGN);
-}
-
-/*
- * upon SIGTTOU, we pause everything
- */
-void sig_pause(int sig)
-{
-	pause_proxies();
-	pool_gc2();
-}
-
-/*
- * upon SIGTTIN, let's have a soft stop.
- */
-void sig_listen(int sig)
-{
-	listen_proxies();
-}
-
-/*
- * this function dumps every server's state when the process receives SIGHUP.
- */
-void sig_dump_state(int sig)
-{
-	struct proxy *p = proxy;
-
-	Warning("SIGHUP received, dumping servers states.\n");
-	while (p) {
-		struct server *s = p->srv;
-
-		send_log(p, LOG_NOTICE, "SIGHUP received, dumping servers states for proxy %s.\n", p->id);
-		while (s) {
-			snprintf(trash, trashlen,
-				 "SIGHUP: Server %s/%s is %s. Conn: %d act, %d pend, %lld tot.",
-				 p->id, s->id,
-				 (s->state & SRV_RUNNING) ? "UP" : "DOWN",
-				 s->cur_sess, s->nbpend, s->counters.cum_sess);
-			Warning("%s\n", trash);
-			send_log(p, LOG_NOTICE, "%s\n", trash);
-			s = s->next;
-		}
-
-		/* FIXME: those info are a bit outdated. We should be able to distinguish between FE and BE. */
-		if (!p->srv) {
-			snprintf(trash, trashlen,
-				 "SIGHUP: Proxy %s has no servers. Conn: act(FE+BE): %d+%d, %d pend (%d unass), tot(FE+BE): %lld+%lld.",
-				 p->id,
-				 p->feconn, p->beconn, p->totpend, p->nbpend, p->counters.cum_feconn, p->counters.cum_beconn);
-		} else if (p->srv_act == 0) {
-			snprintf(trash, trashlen,
-				 "SIGHUP: Proxy %s %s ! Conn: act(FE+BE): %d+%d, %d pend (%d unass), tot(FE+BE): %lld+%lld.",
-				 p->id,
-				 (p->srv_bck) ? "is running on backup servers" : "has no server available",
-				 p->feconn, p->beconn, p->totpend, p->nbpend, p->counters.cum_feconn, p->counters.cum_beconn);
-		} else {
-			snprintf(trash, trashlen,
-				 "SIGHUP: Proxy %s has %d active servers and %d backup servers available."
-				 " Conn: act(FE+BE): %d+%d, %d pend (%d unass), tot(FE+BE): %lld+%lld.",
-				 p->id, p->srv_act, p->srv_bck,
-				 p->feconn, p->beconn, p->totpend, p->nbpend, p->counters.cum_feconn, p->counters.cum_beconn);
-		}
-		Warning("%s\n", trash);
-		send_log(p, LOG_NOTICE, "%s\n", trash);
-
-		p = p->next;
-	}
-}
-
-void dump(int sig)
-{
-#if 0
-	struct task *t;
-	struct session *s;
-	struct rb_node *node;
-
-	for(node = rb_first(&wait_queue[0]);
-		node != NULL; node = rb_next(node)) {
-		t = rb_entry(node, struct task, rb_node);
-		s = t->context;
-		qfprintf(stderr,"[dump] wq: task %p, still %ld ms, "
-			 "cli=%d, srv=%d, req=%d, rep=%d\n",
-			 s, tv_ms_remain(&now, &t->expire),
-			 s->si[0].state,
-			 s->si[1].state,
-			 s->req->l, s->rep?s->rep->l:0);
-	}
-#endif
-	/* dump memory usage then free everything possible */
-	dump_pools();
-	pool_gc2();
-}
-
-#ifdef DEBUG_MEMORY
-static void fast_stop(void)
-{
-	struct proxy *p;
-	p = proxy;
-	while (p) {
-		p->grace = 0;
-		p = p->next;
-	}
-	soft_stop();
-}
-
-void sig_int(int sig)
-{
-	/* This would normally be a hard stop,
-	   but we want to be sure about deallocation,
-	   and so on, so we do a soft stop with
-	   0 GRACE time
-	*/
-	fast_stop();
-	pool_gc2();
-	/* If we are killed twice, we decide to die */
-	signal_register(sig, SIG_DFL);
-}
-
-void sig_term(int sig)
-{
-	/* This would normally be a hard stop,
-	   but we want to be sure about deallocation,
-	   and so on, so we do a soft stop with
-	   0 GRACE time
-	*/
-	fast_stop();
-	pool_gc2();
-	/* If we are killed twice, we decide to die */
-	signal_register(sig, SIG_DFL);
-}
-#endif
-
-
-/*
- * This function initializes all the necessary variables. It only returns
- * if everything is OK. If something fails, it exits.
- */
-void init(int argc, char **argv)
-{
-	int i;
-	int arg_mode = 0;	/* MODE_DEBUG, ... */
-	char *tmp;
-	char *cfg_pidfile = NULL;
-	int err_code = 0;
-	struct wordlist *wl;
-	char *progname;
-
-	/*
-	 * Initialize the previously static variables.
-	 */
-    
-	totalconn = actconn = maxfd = listeners = stopping = 0;
-	trash = malloc(trashlen);
-
-#ifdef HAPROXY_MEMMAX
-	global.rlimit_memmax = HAPROXY_MEMMAX;
-#endif
-
-	tv_update_date(-1,-1);
-	start_date = now;
-
-	signal_init();
-	init_task();
-	init_session();
-	/* warning, we init buffers later */
-	init_pendconn();
-	init_proto_http();
-
-	global.tune.options |= GTUNE_USE_SELECT;  /* select() is always available */
-#if defined(ENABLE_POLL)
-	global.tune.options |= GTUNE_USE_POLL;
-#endif
-#if defined(ENABLE_EPOLL)
-	global.tune.options |= GTUNE_USE_EPOLL;
-#endif
-#if defined(ENABLE_SEPOLL)
-	global.tune.options |= GTUNE_USE_SEPOLL;
-#endif
-#if defined(ENABLE_KQUEUE)
-	global.tune.options |= GTUNE_USE_KQUEUE;
-#endif
-#if defined(CONFIG_HAP_LINUX_SPLICE)
-	global.tune.options |= GTUNE_USE_SPLICE;
-#endif
-
-	pid = getpid();
-	progname = *argv;
-	while ((tmp = strchr(progname, '/')) != NULL)
-		progname = tmp + 1;
-
-	/* the process name is used for the logs only */
-	global.log_tag = strdup(progname);
-
-	argc--; argv++;
-	while (argc > 0) {
-		char *flag;
-
-		if (**argv == '-') {
-			flag = *argv+1;
-
-			/* 1 arg */
-			if (*flag == 'v') {
-				display_version();
-				if (flag[1] == 'v')  /* -vv */
-					display_build_opts();
-				exit(0);
-			}
-#if defined(ENABLE_EPOLL)
-			else if (*flag == 'd' && flag[1] == 'e')
-				global.tune.options &= ~GTUNE_USE_EPOLL;
-#endif
-#if defined(ENABLE_SEPOLL)
-			else if (*flag == 'd' && flag[1] == 's')
-				global.tune.options &= ~GTUNE_USE_SEPOLL;
-#endif
-#if defined(ENABLE_POLL)
-			else if (*flag == 'd' && flag[1] == 'p')
-				global.tune.options &= ~GTUNE_USE_POLL;
-#endif
-#if defined(ENABLE_KQUEUE)
-			else if (*flag == 'd' && flag[1] == 'k')
-				global.tune.options &= ~GTUNE_USE_KQUEUE;
-#endif
-#if defined(CONFIG_HAP_LINUX_SPLICE)
-			else if (*flag == 'd' && flag[1] == 'S')
-				global.tune.options &= ~GTUNE_USE_SPLICE;
-#endif
-			else if (*flag == 'V')
-				arg_mode |= MODE_VERBOSE;
-			else if (*flag == 'd' && flag[1] == 'b')
-				arg_mode |= MODE_FOREGROUND;
-			else if (*flag == 'd')
-				arg_mode |= MODE_DEBUG;
-			else if (*flag == 'c')
-				arg_mode |= MODE_CHECK;
-			else if (*flag == 'D')
-				arg_mode |= MODE_DAEMON;
-			else if (*flag == 'q')
-				arg_mode |= MODE_QUIET;
-			else if (*flag == 's' && (flag[1] == 'f' || flag[1] == 't')) {
-				/* list of pids to finish ('f') or terminate ('t') */
-
-				if (flag[1] == 'f')
-					oldpids_sig = SIGUSR1; /* finish then exit */
-				else
-					oldpids_sig = SIGTERM; /* terminate immediately */
-				argv++; argc--;
-
-				if (argc > 0) {
-					oldpids = calloc(argc, sizeof(int));
-					while (argc > 0) {
-						oldpids[nb_oldpids] = atol(*argv);
-						if (oldpids[nb_oldpids] <= 0)
-							usage(progname);
-						argc--; argv++;
-						nb_oldpids++;
-					}
-				}
-			}
-			else { /* >=2 args */
-				argv++; argc--;
-				if (argc == 0)
-					usage(progname);
-
-				switch (*flag) {
-				case 'n' : cfg_maxconn = atol(*argv); break;
-				case 'm' : global.rlimit_memmax = atol(*argv); break;
-				case 'N' : cfg_maxpconn = atol(*argv); break;
-				case 'f' :
-					wl = (struct wordlist *)calloc(1, sizeof(*wl));
-					if (!wl) {
-						Alert("Cannot load configuration file %s : out of memory.\n", *argv);
-						exit(1);
-					}
-					wl->s = *argv;
-					LIST_ADDQ(&cfg_cfgfiles, &wl->list);
-					break;
-				case 'p' : cfg_pidfile = *argv; break;
-				default: usage(progname);
-				}
-			}
-		}
-		else
-			usage(progname);
-		argv++; argc--;
-	}
-
-	global.mode = MODE_STARTING | /* during startup, we want most of the alerts */
-		(arg_mode & (MODE_DAEMON | MODE_FOREGROUND | MODE_VERBOSE
-			     | MODE_QUIET | MODE_CHECK | MODE_DEBUG));
-
-	if (LIST_ISEMPTY(&cfg_cfgfiles))
-		usage(progname);
-
-	/* NB: POSIX does not make it mandatory for gethostname() to NULL-terminate
-	 * the string in case of truncation, and at least FreeBSD appears not to do
-	 * it.
-	 */
-	memset(hostname, 0, sizeof(hostname));
-	gethostname(hostname, sizeof(hostname) - 1);
-
-	have_appsession = 0;
-	global.maxsock = 10; /* reserve 10 fds ; will be incremented by socket eaters */
-
-	init_default_instance();
-
-	list_for_each_entry(wl, &cfg_cfgfiles, list) {
-		int ret;
-
-		ret = readcfgfile(wl->s);
-		if (ret == -1) {
-			Alert("Could not open configuration file %s : %s\n",
-			      wl->s, strerror(errno));
-			exit(1);
-		}
-		if (ret & (ERR_ABORT|ERR_FATAL))
-			Alert("Error(s) found in configuration file : %s\n", wl->s);
-		err_code |= ret;
-		if (err_code & ERR_ABORT)
-			exit(1);
-	}
-
-	err_code |= check_config_validity();
-	if (err_code & (ERR_ABORT|ERR_FATAL)) {
-		Alert("Fatal errors found in configuration.\n");
-		exit(1);
-	}
-
-	if (global.mode & MODE_CHECK) {
-		qfprintf(stdout, "Configuration file is valid\n");
-		exit(0);
-	}
-
-	/* now we know the buffer size, we can initialize the buffers */
-	init_buffer();
-
-	if (have_appsession)
-		appsession_init();
-
-	if (start_checks() < 0)
-		exit(1);
-
-	if (cfg_maxconn > 0)
-		global.maxconn = cfg_maxconn;
-
-	if (cfg_pidfile) {
-		free(global.pidfile);
-		global.pidfile = strdup(cfg_pidfile);
-	}
-
-	if (global.maxconn == 0)
-		global.maxconn = DEFAULT_MAXCONN;
-
-	if (!global.maxpipes) {
-		/* maxpipes not specified. Count how many frontends and backends
-		 * may be using splicing, and bound that to maxconn.
-		 */
-		struct proxy *cur;
-		int nbfe = 0, nbbe = 0;
-
-		for (cur = proxy; cur; cur = cur->next) {
-			if (cur->options2 & (PR_O2_SPLIC_ANY)) {
-				if (cur->cap & PR_CAP_FE)
-					nbfe += cur->maxconn;
-				if (cur->cap & PR_CAP_BE)
-					nbbe += cur->fullconn ? cur->fullconn : global.maxconn;
-			}
-		}
-		global.maxpipes = MAX(nbfe, nbbe);
-		if (global.maxpipes > global.maxconn)
-			global.maxpipes = global.maxconn;
-		global.maxpipes /= 4;
-	}
-
-
-	global.maxsock += global.maxconn * 2; /* each connection needs two sockets */
-	global.maxsock += global.maxpipes * 2; /* each pipe needs two FDs */
-
-	if (global.tune.maxpollevents <= 0)
-		global.tune.maxpollevents = MAX_POLL_EVENTS;
-
-	if (global.tune.maxaccept == 0) {
-		if (global.nbproc > 1)
-			global.tune.maxaccept = 8;  /* leave some conns to other processes */
-		else
-			global.tune.maxaccept = 100; /* accept many incoming conns at once */
-	}
-
-	if (global.tune.recv_enough == 0)
-		global.tune.recv_enough = MIN_RECV_AT_ONCE_ENOUGH;
-
-	if (global.tune.maxrewrite >= global.tune.bufsize / 2)
-		global.tune.maxrewrite = global.tune.bufsize / 2;
-
-	if (arg_mode & (MODE_DEBUG | MODE_FOREGROUND)) {
-		/* command line debug mode inhibits configuration mode */
-		global.mode &= ~(MODE_DAEMON | MODE_QUIET);
-	}
-	global.mode |= (arg_mode & (MODE_DAEMON | MODE_FOREGROUND | MODE_QUIET |
-				    MODE_VERBOSE | MODE_DEBUG ));
-
-	if ((global.mode & MODE_DEBUG) && (global.mode & (MODE_DAEMON | MODE_QUIET))) {
-		Warning("<debug> mode incompatible with <quiet> and <daemon>. Keeping <debug> only.\n");
-		global.mode &= ~(MODE_DAEMON | MODE_QUIET);
-	}
-
-	if ((global.nbproc > 1) && !(global.mode & MODE_DAEMON)) {
-		if (!(global.mode & (MODE_FOREGROUND | MODE_DEBUG)))
-			Warning("<nbproc> is only meaningful in daemon mode. Setting limit to 1 process.\n");
-		global.nbproc = 1;
-	}
-
-	if (global.nbproc < 1)
-		global.nbproc = 1;
-
-	swap_buffer = (char *)calloc(1, global.tune.bufsize);
-
-	fdinfo = (struct fdinfo *)calloc(1,
-				       sizeof(struct fdinfo) * (global.maxsock));
-	fdtab = (struct fdtab *)calloc(1,
-				       sizeof(struct fdtab) * (global.maxsock));
-	for (i = 0; i < global.maxsock; i++) {
-		fdtab[i].state = FD_STCLOSE;
-	}
-
-	/*
-	 * Note: we could register external pollers here.
-	 * Built-in pollers have been registered before main().
-	 */
-
-	if (!(global.tune.options & GTUNE_USE_KQUEUE))
-		disable_poller("kqueue");
-
-	if (!(global.tune.options & GTUNE_USE_EPOLL))
-		disable_poller("epoll");
-
-	if (!(global.tune.options & GTUNE_USE_SEPOLL))
-		disable_poller("sepoll");
-
-	if (!(global.tune.options & GTUNE_USE_POLL))
-		disable_poller("poll");
-
-	if (!(global.tune.options & GTUNE_USE_SELECT))
-		disable_poller("select");
-
-	/* Note: we could disable any poller by name here */
-
-	if (global.mode & (MODE_VERBOSE|MODE_DEBUG))
-		list_pollers(stderr);
-
-	if (!init_pollers()) {
-		Alert("No polling mechanism available.\n");
-		exit(1);
-	}
-	if (global.mode & (MODE_VERBOSE|MODE_DEBUG)) {
-		printf("Using %s() as the polling mechanism.\n", cur_poller.name);
-	}
-
-	if (!global.node)
-		global.node = strdup(hostname);
-
-}
-
-void deinit(void)
-{
-	struct proxy *p = proxy, *p0;
-	struct cap_hdr *h,*h_next;
-	struct server *s,*s_next;
-	struct listener *l,*l_next;
-	struct acl_cond *cond, *condb;
-	struct hdr_exp *exp, *expb;
-	struct acl *acl, *aclb;
-	struct switching_rule *rule, *ruleb;
-	struct redirect_rule *rdr, *rdrb;
-	struct wordlist *wl, *wlb;
-	struct cond_wordlist *cwl, *cwlb;
-	struct uri_auth *uap, *ua = NULL;
-	int i;
-
-	while (p) {
-		free(p->id);
-		free(p->check_req);
-		free(p->cookie_name);
-		free(p->cookie_domain);
-		free(p->url_param_name);
-		free(p->capture_name);
-		free(p->monitor_uri);
-
-		for (i = 0; i < HTTP_ERR_SIZE; i++)
-			chunk_destroy(&p->errmsg[i]);
-
-		list_for_each_entry_safe(cwl, cwlb, &p->req_add, list) {
-			LIST_DEL(&cwl->list);
-			free(cwl->s);
-			free(cwl);
-		}
-
-		list_for_each_entry_safe(cwl, cwlb, &p->rsp_add, list) {
-			LIST_DEL(&cwl->list);
-			free(cwl->s);
-			free(cwl);
-		}
-
-		list_for_each_entry_safe(cond, condb, &p->block_cond, list) {
-			LIST_DEL(&cond->list);
-			prune_acl_cond(cond);
-			free(cond);
-		}
-
-		list_for_each_entry_safe(cond, condb, &p->mon_fail_cond, list) {
-			LIST_DEL(&cond->list);
-			prune_acl_cond(cond);
-			free(cond);
-		}
-
-		for (exp = p->req_exp; exp != NULL; ) {
-			if (exp->preg) {
-				regfree((regex_t *)exp->preg);
-				free((regex_t *)exp->preg);
-			}
-
-			if (exp->replace && exp->action != ACT_SETBE)
-				free((char *)exp->replace);
-			expb = exp;
-			exp = exp->next;
-			free(expb);
-		}
-
-		for (exp = p->rsp_exp; exp != NULL; ) {
-			if (exp->preg) {
-				regfree((regex_t *)exp->preg);
-				free((regex_t *)exp->preg);
-			}
-
-			if (exp->replace && exp->action != ACT_SETBE)
-				free((char *)exp->replace);
-			expb = exp;
-			exp = exp->next;
-			free(expb);
-		}
-
-		/* build a list of unique uri_auths */
-		if (!ua)
-			ua = p->uri_auth;
-		else {
-			/* check if p->uri_auth is unique */
-			for (uap = ua; uap; uap=uap->next)
-				if (uap == p->uri_auth)
-					break;
-
-			if (!uap && p->uri_auth) {
-				/* add it, if it is */
-				p->uri_auth->next = ua;
-				ua = p->uri_auth;
-			}
-		}
-
-		list_for_each_entry_safe(acl, aclb, &p->acl, list) {
-			LIST_DEL(&acl->list);
-			prune_acl(acl);
-			free(acl);
-		}
-
-		list_for_each_entry_safe(rule, ruleb, &p->switching_rules, list) {
-			LIST_DEL(&rule->list);
-			prune_acl_cond(rule->cond);
-			free(rule->cond);
-			free(rule);
-		}
-
-		list_for_each_entry_safe(rdr, rdrb, &p->redirect_rules, list) {
-			LIST_DEL(&rdr->list);
-			if (rdr->cond) {
-				prune_acl_cond(rdr->cond);
-				free(rdr->cond);
-			}
-			free(rdr->rdr_str);
-			free(rdr);
-		}
-
-		free(p->appsession_name);
-
-		h = p->req_cap;
-		while (h) {
-			h_next = h->next;
-			free(h->name);
-			pool_destroy2(h->pool);
-			free(h);
-			h = h_next;
-		}/* end while(h) */
-
-		h = p->rsp_cap;
-		while (h) {
-			h_next = h->next;
-			free(h->name);
-			pool_destroy2(h->pool);
-			free(h);
-			h = h_next;
-		}/* end while(h) */
-
-		s = p->srv;
-		while (s) {
-			s_next = s->next;
-
-			if (s->check) {
-				task_delete(s->check);
-				task_free(s->check);
-			}
-
-			if (s->warmup) {
-				task_delete(s->warmup);
-				task_free(s->warmup);
-			}
-
-			free(s->id);
-			free(s->cookie);
-			free(s->check_data);
-			free(s);
-			s = s_next;
-		}/* end while(s) */
-
-		l = p->listen;
-		while (l) {
-			l_next = l->next;
-			unbind_listener(l);
-			delete_listener(l);
-			free(l->name);
-			free(l->counters);
-			free(l);
-			l = l_next;
-		}/* end while(l) */
-
-		free(p->desc);
-		free(p->fwdfor_hdr_name);
-
-		req_acl_free(&p->req_acl);
-
-		pool_destroy2(p->req_cap_pool);
-		pool_destroy2(p->rsp_cap_pool);
-		pool_destroy2(p->hdr_idx_pool);
-
-		p0 = p;
-		p = p->next;
-		free(p0);
-	}/* end while(p) */
-
-	while (ua) {
-		uap = ua;
-		ua = ua->next;
-
-		free(uap->uri_prefix);
-		free(uap->auth_realm);
-		free(uap->node);
-		free(uap->desc);
-
-		userlist_free(uap->userlist);
-		req_acl_free(&uap->req_acl);
-
-		free(uap);
-	}
-
-	userlist_free(userlist);
-
-	protocol_unbind_all();
-
-	free(global.log_send_hostname); global.log_send_hostname = NULL;
-	free(global.log_tag); global.log_tag = NULL;
-	free(global.chroot);  global.chroot = NULL;
-	free(global.pidfile); global.pidfile = NULL;
-	free(global.node);    global.node = NULL;
-	free(global.desc);    global.desc = NULL;
-	free(fdtab);          fdtab   = NULL;
-	free(oldpids);        oldpids = NULL;
-
-	list_for_each_entry_safe(wl, wlb, &cfg_cfgfiles, list) {
-		LIST_DEL(&wl->list);
-		free(wl);
-	}
-
-	pool_destroy2(pool2_session);
-	pool_destroy2(pool2_buffer);
-	pool_destroy2(pool2_requri);
-	pool_destroy2(pool2_task);
-	pool_destroy2(pool2_capture);
-	pool_destroy2(pool2_appsess);
-	pool_destroy2(pool2_pendconn);
-    
-	if (have_appsession) {
-		pool_destroy2(apools.serverid);
-		pool_destroy2(apools.sessid);
-	}
-
-	deinit_pollers();
-
-} /* end deinit() */
-
-/* sends the signal <sig> to all pids found in <oldpids>. Returns the number of
- * pids the signal was correctly delivered to.
- */
-static int tell_old_pids(int sig)
-{
-	int p;
-	int ret = 0;
-	for (p = 0; p < nb_oldpids; p++)
-		if (kill(oldpids[p], sig) == 0)
-			ret++;
-	return ret;
-}
-
-/*
- * Runs the polling loop
- *
- * FIXME:
- * - we still use 'listeners' to check whether we want to stop or not.
- *
- */
-void run_poll_loop()
-{
-	int next;
-
-	tv_update_date(0,1);
-	while (1) {
-		/* check if we caught some signals and process them */
-		signal_process_queue();
-
-		/* Check if we can expire some tasks */
-		wake_expired_tasks(&next);
-
-		/* Process a few tasks */
-		process_runnable_tasks(&next);
-
-		/* maintain all proxies in a consistent state. This should quickly
-		 * become a task because it becomes expensive when there are huge
-		 * numbers of proxies. */
-		maintain_proxies(&next);
-
-		/* stop when there's no connection left and we don't allow them anymore */
-		if (!actconn && listeners == 0)
-			break;
-
-		/* The poller will ensure it returns around <next> */
-		cur_poller.poll(&cur_poller, next);
-	}
-}
-
-
-int main(int argc, char **argv)
-{
-	int err, retry;
-	struct rlimit limit;
-	FILE *pidfile = NULL;
-	init(argc, argv);
-
-	signal_register(SIGQUIT, dump);
-	signal_register(SIGUSR1, sig_soft_stop);
-	signal_register(SIGHUP, sig_dump_state);
-#ifdef DEBUG_MEMORY
-	signal_register(SIGINT, sig_int);
-	signal_register(SIGTERM, sig_term);
-#endif
-
-	/* Always catch SIGPIPE even on platforms which define MSG_NOSIGNAL.
-	 * Some recent FreeBSD setups report broken pipes, and MSG_NOSIGNAL
-	 * was defined there, so let's stay on the safe side.
-	 */
-	signal(SIGPIPE, SIG_IGN);
-
-	/* ulimits */
-	if (!global.rlimit_nofile)
-		global.rlimit_nofile = global.maxsock;
-
-	if (global.rlimit_nofile) {
-		limit.rlim_cur = limit.rlim_max = global.rlimit_nofile;
-		if (setrlimit(RLIMIT_NOFILE, &limit) == -1) {
-			Warning("[%s.main()] Cannot raise FD limit to %d.\n", argv[0], global.rlimit_nofile);
-		}
-	}
-
-	if (global.rlimit_memmax) {
-		limit.rlim_cur = limit.rlim_max =
-			global.rlimit_memmax * 1048576 / global.nbproc;
-#ifdef RLIMIT_AS
-		if (setrlimit(RLIMIT_AS, &limit) == -1) {
-			Warning("[%s.main()] Cannot fix MEM limit to %d megs.\n",
-				argv[0], global.rlimit_memmax);
-		}
-#else
-		if (setrlimit(RLIMIT_DATA, &limit) == -1) {
-			Warning("[%s.main()] Cannot fix MEM limit to %d megs.\n",
-				argv[0], global.rlimit_memmax);
-		}
-#endif
-	}
-
-	/* We will loop at most 100 times with 10 ms delay each time.
-	 * That's at most 1 second. We only send a signal to old pids
-	 * if we cannot grab at least one port.
-	 */
-	retry = MAX_START_RETRIES;
-	err = ERR_NONE;
-	while (retry >= 0) {
-		struct timeval w;
-		err = start_proxies(retry == 0 || nb_oldpids == 0);
-		/* exit the loop on no error or fatal error */
-		if ((err & (ERR_RETRYABLE|ERR_FATAL)) != ERR_RETRYABLE)
-			break;
-		if (nb_oldpids == 0 || retry == 0)
-			break;
-
-		/* FIXME-20060514: Solaris and OpenBSD do not support shutdown() on
-		 * listening sockets. So on those platforms, it would be wiser to
-		 * simply send SIGUSR1, which will not be undoable.
-		 */
-		if (tell_old_pids(SIGTTOU) == 0) {
-			/* no need to wait if we can't contact old pids */
-			retry = 0;
-			continue;
-		}
-		/* give some time to old processes to stop listening */
-		w.tv_sec = 0;
-		w.tv_usec = 10*1000;
-		select(0, NULL, NULL, NULL, &w);
-		retry--;
-	}
-
-	/* Note: start_proxies() sends an alert when it fails. */
-	if ((err & ~ERR_WARN) != ERR_NONE) {
-		if (retry != MAX_START_RETRIES && nb_oldpids) {
-			protocol_unbind_all(); /* cleanup everything we can */
-			tell_old_pids(SIGTTIN);
-		}
-		exit(1);
-	}
-
-	if (listeners == 0) {
-		Alert("[%s.main()] No enabled listener found (check the <listen> keywords) ! Exiting.\n", argv[0]);
-		/* Note: we don't have to send anything to the old pids because we
-		 * never stopped them. */
-		exit(1);
-	}
-
-	if ((protocol_bind_all() & ~ERR_WARN) != ERR_NONE) {
-		Alert("[%s.main()] Some protocols failed to start their listeners! Exiting.\n", argv[0]);
-		protocol_unbind_all(); /* cleanup everything we can */
-		if (nb_oldpids)
-			tell_old_pids(SIGTTIN);
-		exit(1);
-	}
-
-	/* prepare pause/play signals */
-	signal_register(SIGTTOU, sig_pause);
-	signal_register(SIGTTIN, sig_listen);
-
-	/* MODE_QUIET can inhibit alerts and warnings below this line */
-
-	global.mode &= ~MODE_STARTING;
-	if ((global.mode & MODE_QUIET) && !(global.mode & MODE_VERBOSE)) {
-		/* detach from the tty */
-		fclose(stdin); fclose(stdout); fclose(stderr);
-	}
-
-	/* open log & pid files before the chroot */
-	if (global.mode & MODE_DAEMON && global.pidfile != NULL) {
-		int pidfd;
-		unlink(global.pidfile);
-		pidfd = open(global.pidfile, O_CREAT | O_WRONLY | O_TRUNC, 0644);
-		if (pidfd < 0) {
-			Alert("[%s.main()] Cannot create pidfile %s\n", argv[0], global.pidfile);
-			if (nb_oldpids)
-				tell_old_pids(SIGTTIN);
-			protocol_unbind_all();
-			exit(1);
-		}
-		pidfile = fdopen(pidfd, "w");
-	}
-
-#ifdef CONFIG_HAP_CTTPROXY
-	if (global.last_checks & LSTCHK_CTTPROXY) {
-		int ret;
-
-		ret = check_cttproxy_version();
-		if (ret < 0) {
-			Alert("[%s.main()] Cannot enable cttproxy.\n%s",
-			      argv[0],
-			      (ret == -1) ? "  Incorrect module version.\n"
-			      : "  Make sure you have enough permissions and that the module is loaded.\n");
-			protocol_unbind_all();
-			exit(1);
-		}
-	}
-#endif
-
-	if ((global.last_checks & LSTCHK_NETADM) && global.uid) {
-		Alert("[%s.main()] Some configuration options require full privileges, so global.uid cannot be changed.\n"
-		      "", argv[0]);
-		protocol_unbind_all();
-		exit(1);
-	}
-
-	/* If the user is not root, we'll still let him try the configuration
-	 * but we inform him that unexpected behaviour may occur.
-	 */
-	if ((global.last_checks & LSTCHK_NETADM) && getuid())
-		Warning("[%s.main()] Some options which require full privileges"
-			" might not work well.\n"
-			"", argv[0]);
-
-	/* chroot if needed */
-	if (global.chroot != NULL) {
-		if (chroot(global.chroot) == -1 || chdir("/") == -1) {
-			Alert("[%s.main()] Cannot chroot(%s).\n", argv[0], global.chroot);
-			if (nb_oldpids)
-				tell_old_pids(SIGTTIN);
-			protocol_unbind_all();
-			exit(1);
-		}
-	}
-
-	if (nb_oldpids)
-		nb_oldpids = tell_old_pids(oldpids_sig);
-
-	/* Note that any error at this stage will be fatal because we will not
-	 * be able to restart the old pids.
-	 */
-
-	/* setgid / setuid */
-	if (global.gid && setgid(global.gid) == -1) {
-		Alert("[%s.main()] Cannot set gid %d.\n", argv[0], global.gid);
-		protocol_unbind_all();
-		exit(1);
-	}
-
-	if (global.uid && setuid(global.uid) == -1) {
-		Alert("[%s.main()] Cannot set uid %d.\n", argv[0], global.uid);
-		protocol_unbind_all();
-		exit(1);
-	}
-
-	/* check ulimits */
-	limit.rlim_cur = limit.rlim_max = 0;
-	getrlimit(RLIMIT_NOFILE, &limit);
-	if (limit.rlim_cur < global.maxsock) {
-		Warning("[%s.main()] FD limit (%d) too low for maxconn=%d/maxsock=%d. Please raise 'ulimit-n' to %d or more to avoid any trouble.\n",
-			argv[0], (int)limit.rlim_cur, global.maxconn, global.maxsock, global.maxsock);
-	}
-
-	if (global.mode & MODE_DAEMON) {
-		struct proxy *px;
-		int ret = 0;
-		int proc;
-
-		/* the father launches the required number of processes */
-		for (proc = 0; proc < global.nbproc; proc++) {
-			ret = fork();
-			if (ret < 0) {
-				Alert("[%s.main()] Cannot fork.\n", argv[0]);
-				protocol_unbind_all();
-				exit(1); /* there has been an error */
-			}
-			else if (ret == 0) /* child breaks here */
-				break;
-			if (pidfile != NULL) {
-				fprintf(pidfile, "%d\n", ret);
-				fflush(pidfile);
-			}
-			relative_pid++; /* each child will get a different one */
-		}
-		/* close the pidfile both in children and father */
-		if (pidfile != NULL)
-			fclose(pidfile);
-
-		/* We won't ever use this anymore */
-		free(oldpids);        oldpids = NULL;
-		free(global.chroot);  global.chroot = NULL;
-		free(global.pidfile); global.pidfile = NULL;
-
-		/* we might have to unbind some proxies from some processes */
-		px = proxy;
-		while (px != NULL) {
-			if (px->bind_proc && px->state != PR_STSTOPPED) {
-				if (!(px->bind_proc & (1 << proc)))
-					stop_proxy(px);
-			}
-			px = px->next;
-		}
-
-		if (proc == global.nbproc)
-			exit(0); /* parent must leave */
-
-		/* if we're NOT in QUIET mode, we should now close the 3 first FDs to ensure
-		 * that we can detach from the TTY. We MUST NOT do it in other cases since
-		 * it would have already be done, and 0-2 would have been affected to listening
-		 * sockets
-		 */
-		if (!(global.mode & MODE_QUIET) || (global.mode & MODE_VERBOSE)) {
-			/* detach from the tty */
-			fclose(stdin); fclose(stdout); fclose(stderr);
-			global.mode &= ~MODE_VERBOSE;
-			global.mode |= MODE_QUIET; /* ensure that we won't say anything from now */
-		}
-		pid = getpid(); /* update child's pid */
-		setsid();
-		fork_poller();
-	}
-
-	protocol_enable_all();
-	/*
-	 * That's it : the central polling loop. Run until we stop.
-	 */
-	run_poll_loop();
-
-	/* Free all Hash Keys and all Hash elements */
-	appsession_cleanup();
-	/* Do some cleanup */ 
-	deinit();
-    
-	exit(0);
-}
-
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/hdr_idx.c b/deps/haproxy-1.4.21/src/hdr_idx.c
deleted file mode 100644
index a8c595d..0000000
--- a/deps/haproxy-1.4.21/src/hdr_idx.c
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Header indexation functions.
- *
- * Copyright 2000-2008 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <common/config.h>
-#include <proto/hdr_idx.h>
-
-
-/*
- * Add a header entry to <list> after element <after>. <after> is ignored when
- * the list is empty or full. Common usage is to set <after> to list->tail.
- *
- * Returns the position of the new entry in the list (from 1 to size-1), or 0
- * if the array is already full. An effort is made to fill the array linearly,
- * but once the last entry has been used, we have to search for unused blocks,
- * which takes much more time. For this reason, it's important to size is
- * appropriately.
- */
-int hdr_idx_add(int len, int cr, struct hdr_idx *list, int after)
-{
-	register struct hdr_idx_elem e = { .len=0, .cr=0, .next=0};
-	int new;
-
-	e.len = len;
-	e.cr = cr;
-
-	if (list->used == list->size) {
-		/* list is full */
-		return -1;
-	}
-
-
-	if (list->last < list->size) {
-		/* list is not completely used, we can fill linearly */
-		new = list->last++;
-	} else {
-		/* That's the worst situation :
-		 * we have to scan the list for holes. We know that we
-		 * will find a place because the list is not full.
-		 */
-		new = 1;
-		while (list->v[new].len)
-			new++;
-	}
-	
-	/* insert the new element between <after> and the next one (or end) */
-	e.next = list->v[after].next;
-	list->v[after].next = new;
-
-	list->used++;
-	list->v[new] = e;
-	list->tail = new;
-	return new;
-}
-
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/lb_chash.c b/deps/haproxy-1.4.21/src/lb_chash.c
deleted file mode 100644
index 58c029a..0000000
--- a/deps/haproxy-1.4.21/src/lb_chash.c
+++ /dev/null
@@ -1,427 +0,0 @@
-/*
- * Consistent Hash implementation
- * Please consult this very well detailed article for more information :
- * http://www.spiteful.com/2008/03/17/programmers-toolbox-part-3-consistent-hashing/
- *
- * Our implementation has to support both weighted hashing and weighted round
- * robin because we'll use it to replace the previous map-based implementation
- * which offered both algorithms.
- *
- * Copyright 2000-2009 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <common/compat.h>
-#include <common/config.h>
-#include <common/debug.h>
-#include <eb32tree.h>
-
-#include <types/global.h>
-#include <types/server.h>
-
-#include <proto/backend.h>
-#include <proto/queue.h>
-
-static inline unsigned int chash_hash(unsigned int a)
-{
-	/* This function is one of Bob Jenkins' full avalanche hashing
-	 * functions, which when provides quite a good distribution for little
-	 * input variations. The result is quite suited to fit over a 32-bit
-	 * space with enough variations so that a randomly picked number falls
-	 * equally before any server position.
-	 * Check http://burtleburtle.net/bob/hash/integer.html for more info.
-	 */
-	a = (a+0x7ed55d16) + (a<<12);
-	a = (a^0xc761c23c) ^ (a>>19);
-	a = (a+0x165667b1) + (a<<5);
-	a = (a+0xd3a2646c) ^ (a<<9);
-	a = (a+0xfd7046c5) + (a<<3);
-	a = (a^0xb55a4f09) ^ (a>>16);
-
-	/* ensure values are better spread all around the tree by multiplying
-	 * by a large prime close to 3/4 of the tree.
-	 */
-	return a * 3221225473U;
-}
-
-/* Return next tree node after <node> which must still be in the tree, or be
- * NULL. Lookup wraps around the end to the beginning. If the next node is the
- * same node, return NULL. This is designed to find a valid next node before
- * deleting one from the tree.
- */
-static inline struct eb32_node *chash_skip_node(struct eb_root *root, struct eb32_node *node)
-{
-	struct eb32_node *stop = node;
-
-	if (!node)
-		return NULL;
-	node = eb32_next(node);
-	if (!node)
-		node = eb32_first(root);
-	if (node == stop)
-		return NULL;
-	return node;
-}
-
-/* Remove all of a server's entries from its tree. This may be used when
- * setting a server down.
- */
-static inline void chash_dequeue_srv(struct server *s)
-{
-	while (s->lb_nodes_now > 0) {
-		if (s->lb_nodes_now >= s->lb_nodes_tot) // should always be false anyway
-			s->lb_nodes_now = s->lb_nodes_tot;
-		s->lb_nodes_now--;
-		if (s->proxy->lbprm.chash.last == &s->lb_nodes[s->lb_nodes_now].node)
-			s->proxy->lbprm.chash.last = chash_skip_node(s->lb_tree, s->proxy->lbprm.chash.last);
-		eb32_delete(&s->lb_nodes[s->lb_nodes_now].node);
-	}
-}
-
-/* Adjust the number of entries of a server in its tree. The server must appear
- * as many times as its weight indicates it. If it's there too often, we remove
- * the last occurrences. If it's not there enough, we add more occurrences. To
- * remove a server from the tree, normally call this with eweight=0.
- */
-static inline void chash_queue_dequeue_srv(struct server *s)
-{
-	while (s->lb_nodes_now > s->eweight) {
-		if (s->lb_nodes_now >= s->lb_nodes_tot) // should always be false anyway
-			s->lb_nodes_now = s->lb_nodes_tot;
-		s->lb_nodes_now--;
-		if (s->proxy->lbprm.chash.last == &s->lb_nodes[s->lb_nodes_now].node)
-			s->proxy->lbprm.chash.last = chash_skip_node(s->lb_tree, s->proxy->lbprm.chash.last);
-		eb32_delete(&s->lb_nodes[s->lb_nodes_now].node);
-	}
-
-	while (s->lb_nodes_now < s->eweight) {
-		if (s->lb_nodes_now >= s->lb_nodes_tot) // should always be false anyway
-			break;
-		if (s->proxy->lbprm.chash.last == &s->lb_nodes[s->lb_nodes_now].node)
-			s->proxy->lbprm.chash.last = chash_skip_node(s->lb_tree, s->proxy->lbprm.chash.last);
-		eb32_insert(s->lb_tree, &s->lb_nodes[s->lb_nodes_now].node);
-		s->lb_nodes_now++;
-	}
-}
-
-/* This function updates the server trees according to server <srv>'s new
- * state. It should be called when server <srv>'s status changes to down.
- * It is not important whether the server was already down or not. It is not
- * important either that the new state is completely down (the caller may not
- * know all the variables of a server's state).
- */
-static void chash_set_server_status_down(struct server *srv)
-{
-	struct proxy *p = srv->proxy;
-
-	if (srv->state == srv->prev_state &&
-	    srv->eweight == srv->prev_eweight)
-		return;
-
-	if (srv_is_usable(srv->state, srv->eweight))
-		goto out_update_state;
-
-	if (!srv_is_usable(srv->prev_state, srv->prev_eweight))
-		/* server was already down */
-		goto out_update_backend;
-
-	if (srv->state & SRV_BACKUP) {
-		p->lbprm.tot_wbck -= srv->prev_eweight;
-		p->srv_bck--;
-
-		if (srv == p->lbprm.fbck) {
-			/* we lost the first backup server in a single-backup
-			 * configuration, we must search another one.
-			 */
-			struct server *srv2 = p->lbprm.fbck;
-			do {
-				srv2 = srv2->next;
-			} while (srv2 &&
-				 !((srv2->state & SRV_BACKUP) &&
-				   srv_is_usable(srv2->state, srv2->eweight)));
-			p->lbprm.fbck = srv2;
-		}
-	} else {
-		p->lbprm.tot_wact -= srv->prev_eweight;
-		p->srv_act--;
-	}
-
-	chash_dequeue_srv(srv);
-
-out_update_backend:
-	/* check/update tot_used, tot_weight */
-	update_backend_weight(p);
- out_update_state:
-	srv->prev_state = srv->state;
-	srv->prev_eweight = srv->eweight;
-}
-
-/* This function updates the server trees according to server <srv>'s new
- * state. It should be called when server <srv>'s status changes to up.
- * It is not important whether the server was already down or not. It is not
- * important either that the new state is completely UP (the caller may not
- * know all the variables of a server's state). This function will not change
- * the weight of a server which was already up.
- */
-static void chash_set_server_status_up(struct server *srv)
-{
-	struct proxy *p = srv->proxy;
-
-	if (srv->state == srv->prev_state &&
-	    srv->eweight == srv->prev_eweight)
-		return;
-
-	if (!srv_is_usable(srv->state, srv->eweight))
-		goto out_update_state;
-
-	if (srv_is_usable(srv->prev_state, srv->prev_eweight))
-		/* server was already up */
-		goto out_update_backend;
-
-	if (srv->state & SRV_BACKUP) {
-		p->lbprm.tot_wbck += srv->eweight;
-		p->srv_bck++;
-
-		if (!(p->options & PR_O_USE_ALL_BK)) {
-			if (!p->lbprm.fbck) {
-				/* there was no backup server anymore */
-				p->lbprm.fbck = srv;
-			} else {
-				/* we may have restored a backup server prior to fbck,
-				 * in which case it should replace it.
-				 */
-				struct server *srv2 = srv;
-				do {
-					srv2 = srv2->next;
-				} while (srv2 && (srv2 != p->lbprm.fbck));
-				if (srv2)
-					p->lbprm.fbck = srv;
-			}
-		}
-	} else {
-		p->lbprm.tot_wact += srv->eweight;
-		p->srv_act++;
-	}
-
-	/* note that eweight cannot be 0 here */
-	chash_queue_dequeue_srv(srv);
-
- out_update_backend:
-	/* check/update tot_used, tot_weight */
-	update_backend_weight(p);
- out_update_state:
-	srv->prev_state = srv->state;
-	srv->prev_eweight = srv->eweight;
-}
-
-/* This function must be called after an update to server <srv>'s effective
- * weight. It may be called after a state change too.
- */
-static void chash_update_server_weight(struct server *srv)
-{
-	int old_state, new_state;
-	struct proxy *p = srv->proxy;
-
-	if (srv->state == srv->prev_state &&
-	    srv->eweight == srv->prev_eweight)
-		return;
-
-	/* If changing the server's weight changes its state, we simply apply
-	 * the procedures we already have for status change. If the state
-	 * remains down, the server is not in any tree, so it's as easy as
-	 * updating its values. If the state remains up with different weights,
-	 * there are some computations to perform to find a new place and
-	 * possibly a new tree for this server.
-	 */
-
-	old_state = srv_is_usable(srv->prev_state, srv->prev_eweight);
-	new_state = srv_is_usable(srv->state, srv->eweight);
-
-	if (!old_state && !new_state) {
-		srv->prev_state = srv->state;
-		srv->prev_eweight = srv->eweight;
-		return;
-	}
-	else if (!old_state && new_state) {
-		chash_set_server_status_up(srv);
-		return;
-	}
-	else if (old_state && !new_state) {
-		chash_set_server_status_down(srv);
-		return;
-	}
-
-	/* only adjust the server's presence in the tree */
-	chash_queue_dequeue_srv(srv);
-
-	if (srv->state & SRV_BACKUP)
-		p->lbprm.tot_wbck += srv->eweight - srv->prev_eweight;
-	else
-		p->lbprm.tot_wact += srv->eweight - srv->prev_eweight;
-
-	update_backend_weight(p);
-	srv->prev_state = srv->state;
-	srv->prev_eweight = srv->eweight;
-}
-
-/*
- * This function returns the running server from the CHASH tree, which is at
- * the closest distance from the value of <hash>. Doing so ensures that even
- * with a well imbalanced hash, if some servers are close to each other, they
- * will still both receive traffic. If any server is found, it will be returned.
- * If no valid server is found, NULL is returned.
- */
-struct server *chash_get_server_hash(struct proxy *p, unsigned int hash)
-{
-	struct eb32_node *next, *prev;
-	struct server *nsrv, *psrv;
-	struct eb_root *root;
-	unsigned int dn, dp;
-
-	if (p->srv_act)
-		root = &p->lbprm.chash.act;
-	else if (p->lbprm.fbck)
-		return p->lbprm.fbck;
-	else if (p->srv_bck)
-		root = &p->lbprm.chash.bck;
-	else
-		return NULL;
-
-	hash = chash_hash(hash);
-
-	/* find the node after and the node before */
-	next = eb32_lookup_ge(root, hash);
-	if (!next)
-		next = eb32_first(root);
-	if (!next)
-		return NULL; /* tree is empty */
-
-	prev = eb32_prev(next);
-	if (!prev)
-		prev = eb32_last(root);
-
-	nsrv = eb32_entry(next, struct tree_occ, node)->server;
-	psrv = eb32_entry(prev, struct tree_occ, node)->server;
-	if (nsrv == psrv)
-		return nsrv;
-
-	/* OK we're located between two distinct servers, let's
-	 * compare distances between hash and the two servers
-	 * and select the closest server.
-	 */
-	dp = hash - prev->key;
-	dn = next->key - hash;
-
-	return (dp <= dn) ? psrv : nsrv;
-}
-
-/* Return next server from the CHASH tree in backend <p>. If the tree is empty,
- * return NULL. Saturated servers are skipped.
- */
-struct server *chash_get_next_server(struct proxy *p, struct server *srvtoavoid)
-{
-	struct server *srv, *avoided;
-	struct eb32_node *node, *stop, *avoided_node;
-	struct eb_root *root;
-
-	srv = avoided = NULL;
-	avoided_node = NULL;
-
-	if (p->srv_act)
-		root = &p->lbprm.chash.act;
-	else if (p->lbprm.fbck)
-		return p->lbprm.fbck;
-	else if (p->srv_bck)
-		root = &p->lbprm.chash.bck;
-	else
-		return NULL;
-
-	stop = node = p->lbprm.chash.last;
-	do {
-		struct server *s;
-
-		if (node)
-			node = eb32_next(node);
-		if (!node)
-			node = eb32_first(root);
-
-		p->lbprm.chash.last = node;
-		if (!node)
-			/* no node is available */
-			return NULL;
-
-		/* OK, we have a server. However, it may be saturated, in which
-		 * case we don't want to reconsider it for now, so we'll simply
-		 * skip it. Same if it's the server we try to avoid, in which
-		 * case we simply remember it for later use if needed.
-		 */
-		s = eb32_entry(node, struct tree_occ, node)->server;
-		if (!s->maxconn || (!s->nbpend && s->served < srv_dynamic_maxconn(s))) {
-			if (s != srvtoavoid) {
-				srv = s;
-				break;
-			}
-			avoided = s;
-			avoided_node = node;
-		}
-	} while (node != stop);
-
-	if (!srv) {
-		srv = avoided;
-		p->lbprm.chash.last = avoided_node;
-	}
-
-	return srv;
-}
-
-/* This function is responsible for building the active and backup trees for
- * constistent hashing. The servers receive an array of initialized nodes
- * with their assigned keys. It also sets p->lbprm.wdiv to the eweight to
- * uweight ratio.
- */
-void chash_init_server_tree(struct proxy *p)
-{
-	struct server *srv;
-	struct eb_root init_head = EB_ROOT;
-	int node;
-
-	p->lbprm.set_server_status_up   = chash_set_server_status_up;
-	p->lbprm.set_server_status_down = chash_set_server_status_down;
-	p->lbprm.update_server_eweight  = chash_update_server_weight;
-	p->lbprm.server_take_conn = NULL;
-	p->lbprm.server_drop_conn = NULL;
-
-	p->lbprm.wdiv = BE_WEIGHT_SCALE;
-	for (srv = p->srv; srv; srv = srv->next) {
-		srv->prev_eweight = srv->eweight = srv->uweight * BE_WEIGHT_SCALE;
-		srv->prev_state = srv->state;
-	}
-
-	recount_servers(p);
-	update_backend_weight(p);
-
-	p->lbprm.chash.act = init_head;
-	p->lbprm.chash.bck = init_head;
-	p->lbprm.chash.last = NULL;
-
-	/* queue active and backup servers in two distinct groups */
-	for (srv = p->srv; srv; srv = srv->next) {
-		srv->lb_tree = (srv->state & SRV_BACKUP) ? &p->lbprm.chash.bck : &p->lbprm.chash.act;
-		srv->lb_nodes_tot = srv->uweight * BE_WEIGHT_SCALE;
-		srv->lb_nodes_now = 0;
-		srv->lb_nodes = (struct tree_occ *)calloc(srv->lb_nodes_tot, sizeof(struct tree_occ));
-
-		for (node = 0; node < srv->lb_nodes_tot; node++) {
-			srv->lb_nodes[node].server = srv;
-			srv->lb_nodes[node].node.key = chash_hash(srv->puid * SRV_EWGHT_RANGE + node);
-		}
-
-		if (srv_is_usable(srv->state, srv->eweight))
-			chash_queue_dequeue_srv(srv);
-	}
-}
diff --git a/deps/haproxy-1.4.21/src/lb_fwlc.c b/deps/haproxy-1.4.21/src/lb_fwlc.c
deleted file mode 100644
index c2fcb4e..0000000
--- a/deps/haproxy-1.4.21/src/lb_fwlc.c
+++ /dev/null
@@ -1,316 +0,0 @@
-/*
- * Fast Weighted Least Connection load balancing algorithm.
- *
- * Copyright 2000-2009 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <common/compat.h>
-#include <common/config.h>
-#include <common/debug.h>
-#include <eb32tree.h>
-
-#include <types/global.h>
-#include <types/server.h>
-
-#include <proto/backend.h>
-#include <proto/queue.h>
-
-
-/* Remove a server from a tree. It must have previously been dequeued. This
- * function is meant to be called when a server is going down or has its
- * weight disabled.
- */
-static inline void fwlc_remove_from_tree(struct server *s)
-{
-	s->lb_tree = NULL;
-}
-
-/* simply removes a server from a tree */
-static inline void fwlc_dequeue_srv(struct server *s)
-{
-	eb32_delete(&s->lb_node);
-}
-
-/* Queue a server in its associated tree, assuming the weight is >0.
- * Servers are sorted by #conns/weight. To ensure maximum accuracy,
- * we use #conns*SRV_EWGHT_MAX/eweight as the sorting key.
- */
-static inline void fwlc_queue_srv(struct server *s)
-{
-	s->lb_node.key = s->served * SRV_EWGHT_MAX / s->eweight;
-	eb32_insert(s->lb_tree, &s->lb_node);
-}
-
-/* Re-position the server in the FWLC tree after it has been assigned one
- * connection or after it has released one. Note that it is possible that
- * the server has been moved out of the tree due to failed health-checks.
- */
-static void fwlc_srv_reposition(struct server *s)
-{
-	if (!s->lb_tree)
-		return;
-	fwlc_dequeue_srv(s);
-	fwlc_queue_srv(s);
-}
-
-/* This function updates the server trees according to server <srv>'s new
- * state. It should be called when server <srv>'s status changes to down.
- * It is not important whether the server was already down or not. It is not
- * important either that the new state is completely down (the caller may not
- * know all the variables of a server's state).
- */
-static void fwlc_set_server_status_down(struct server *srv)
-{
-	struct proxy *p = srv->proxy;
-
-	if (srv->state == srv->prev_state &&
-	    srv->eweight == srv->prev_eweight)
-		return;
-
-	if (srv_is_usable(srv->state, srv->eweight))
-		goto out_update_state;
-
-	if (!srv_is_usable(srv->prev_state, srv->prev_eweight))
-		/* server was already down */
-		goto out_update_backend;
-
-	if (srv->state & SRV_BACKUP) {
-		p->lbprm.tot_wbck -= srv->prev_eweight;
-		p->srv_bck--;
-
-		if (srv == p->lbprm.fbck) {
-			/* we lost the first backup server in a single-backup
-			 * configuration, we must search another one.
-			 */
-			struct server *srv2 = p->lbprm.fbck;
-			do {
-				srv2 = srv2->next;
-			} while (srv2 &&
-				 !((srv2->state & SRV_BACKUP) &&
-				   srv_is_usable(srv2->state, srv2->eweight)));
-			p->lbprm.fbck = srv2;
-		}
-	} else {
-		p->lbprm.tot_wact -= srv->prev_eweight;
-		p->srv_act--;
-	}
-
-	fwlc_dequeue_srv(srv);
-	fwlc_remove_from_tree(srv);
-
-out_update_backend:
-	/* check/update tot_used, tot_weight */
-	update_backend_weight(p);
- out_update_state:
-	srv->prev_state = srv->state;
-	srv->prev_eweight = srv->eweight;
-}
-
-/* This function updates the server trees according to server <srv>'s new
- * state. It should be called when server <srv>'s status changes to up.
- * It is not important whether the server was already down or not. It is not
- * important either that the new state is completely UP (the caller may not
- * know all the variables of a server's state). This function will not change
- * the weight of a server which was already up.
- */
-static void fwlc_set_server_status_up(struct server *srv)
-{
-	struct proxy *p = srv->proxy;
-
-	if (srv->state == srv->prev_state &&
-	    srv->eweight == srv->prev_eweight)
-		return;
-
-	if (!srv_is_usable(srv->state, srv->eweight))
-		goto out_update_state;
-
-	if (srv_is_usable(srv->prev_state, srv->prev_eweight))
-		/* server was already up */
-		goto out_update_backend;
-
-	if (srv->state & SRV_BACKUP) {
-		srv->lb_tree = &p->lbprm.fwlc.bck;
-		p->lbprm.tot_wbck += srv->eweight;
-		p->srv_bck++;
-
-		if (!(p->options & PR_O_USE_ALL_BK)) {
-			if (!p->lbprm.fbck) {
-				/* there was no backup server anymore */
-				p->lbprm.fbck = srv;
-			} else {
-				/* we may have restored a backup server prior to fbck,
-				 * in which case it should replace it.
-				 */
-				struct server *srv2 = srv;
-				do {
-					srv2 = srv2->next;
-				} while (srv2 && (srv2 != p->lbprm.fbck));
-				if (srv2)
-					p->lbprm.fbck = srv;
-			}
-		}
-	} else {
-		srv->lb_tree = &p->lbprm.fwlc.act;
-		p->lbprm.tot_wact += srv->eweight;
-		p->srv_act++;
-	}
-
-	/* note that eweight cannot be 0 here */
-	fwlc_queue_srv(srv);
-
- out_update_backend:
-	/* check/update tot_used, tot_weight */
-	update_backend_weight(p);
- out_update_state:
-	srv->prev_state = srv->state;
-	srv->prev_eweight = srv->eweight;
-}
-
-/* This function must be called after an update to server <srv>'s effective
- * weight. It may be called after a state change too.
- */
-static void fwlc_update_server_weight(struct server *srv)
-{
-	int old_state, new_state;
-	struct proxy *p = srv->proxy;
-
-	if (srv->state == srv->prev_state &&
-	    srv->eweight == srv->prev_eweight)
-		return;
-
-	/* If changing the server's weight changes its state, we simply apply
-	 * the procedures we already have for status change. If the state
-	 * remains down, the server is not in any tree, so it's as easy as
-	 * updating its values. If the state remains up with different weights,
-	 * there are some computations to perform to find a new place and
-	 * possibly a new tree for this server.
-	 */
-	 
-	old_state = srv_is_usable(srv->prev_state, srv->prev_eweight);
-	new_state = srv_is_usable(srv->state, srv->eweight);
-
-	if (!old_state && !new_state) {
-		srv->prev_state = srv->state;
-		srv->prev_eweight = srv->eweight;
-		return;
-	}
-	else if (!old_state && new_state) {
-		fwlc_set_server_status_up(srv);
-		return;
-	}
-	else if (old_state && !new_state) {
-		fwlc_set_server_status_down(srv);
-		return;
-	}
-
-	if (srv->lb_tree)
-		fwlc_dequeue_srv(srv);
-
-	if (srv->state & SRV_BACKUP) {
-		p->lbprm.tot_wbck += srv->eweight - srv->prev_eweight;
-		srv->lb_tree = &p->lbprm.fwlc.bck;
-	} else {
-		p->lbprm.tot_wact += srv->eweight - srv->prev_eweight;
-		srv->lb_tree = &p->lbprm.fwlc.act;
-	}
-
-	fwlc_queue_srv(srv);
-
-	update_backend_weight(p);
-	srv->prev_state = srv->state;
-	srv->prev_eweight = srv->eweight;
-}
-
-/* This function is responsible for building the trees in case of fast
- * weighted least-conns. It also sets p->lbprm.wdiv to the eweight to
- * uweight ratio. Both active and backup groups are initialized.
- */
-void fwlc_init_server_tree(struct proxy *p)
-{
-	struct server *srv;
-	struct eb_root init_head = EB_ROOT;
-
-	p->lbprm.set_server_status_up   = fwlc_set_server_status_up;
-	p->lbprm.set_server_status_down = fwlc_set_server_status_down;
-	p->lbprm.update_server_eweight  = fwlc_update_server_weight;
-	p->lbprm.server_take_conn = fwlc_srv_reposition;
-	p->lbprm.server_drop_conn = fwlc_srv_reposition;
-
-	p->lbprm.wdiv = BE_WEIGHT_SCALE;
-	for (srv = p->srv; srv; srv = srv->next) {
-		srv->prev_eweight = srv->eweight = srv->uweight * BE_WEIGHT_SCALE;
-		srv->prev_state = srv->state;
-	}
-
-	recount_servers(p);
-	update_backend_weight(p);
-
-	p->lbprm.fwlc.act = init_head;
-	p->lbprm.fwlc.bck = init_head;
-
-	/* queue active and backup servers in two distinct groups */
-	for (srv = p->srv; srv; srv = srv->next) {
-		if (!srv_is_usable(srv->state, srv->eweight))
-			continue;
-		srv->lb_tree = (srv->state & SRV_BACKUP) ? &p->lbprm.fwlc.bck : &p->lbprm.fwlc.act;
-		fwlc_queue_srv(srv);
-	}
-}
-
-/* Return next server from the FWLC tree in backend <p>. If the tree is empty,
- * return NULL. Saturated servers are skipped.
- */
-struct server *fwlc_get_next_server(struct proxy *p, struct server *srvtoavoid)
-{
-	struct server *srv, *avoided;
-	struct eb32_node *node;
-
-	srv = avoided = NULL;
-
-	if (p->srv_act)
-		node = eb32_first(&p->lbprm.fwlc.act);
-	else if (p->lbprm.fbck)
-		return p->lbprm.fbck;
-	else if (p->srv_bck)
-		node = eb32_first(&p->lbprm.fwlc.bck);
-	else
-		return NULL;
-
-	while (node) {
-		/* OK, we have a server. However, it may be saturated, in which
-		 * case we don't want to reconsider it for now, so we'll simply
-		 * skip it. Same if it's the server we try to avoid, in which
-		 * case we simply remember it for later use if needed.
-		 */
-		struct server *s;
-
-		s = eb32_entry(node, struct server, lb_node);
-		if (!s->maxconn || (!s->nbpend && s->served < srv_dynamic_maxconn(s))) {
-			if (s != srvtoavoid) {
-				srv = s;
-				break;
-			}
-			avoided = s;
-		}
-		node = eb32_next(node);
-	}
-
-	if (!srv)
-		srv = avoided;
-
-	return srv;
-}
-
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/lb_fwrr.c b/deps/haproxy-1.4.21/src/lb_fwrr.c
deleted file mode 100644
index d92b6eb..0000000
--- a/deps/haproxy-1.4.21/src/lb_fwrr.c
+++ /dev/null
@@ -1,576 +0,0 @@
-/*
- * Fast Weighted Round Robin load balancing algorithm.
- *
- * Copyright 2000-2009 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <common/compat.h>
-#include <common/config.h>
-#include <common/debug.h>
-#include <eb32tree.h>
-
-#include <types/global.h>
-#include <types/server.h>
-
-#include <proto/backend.h>
-#include <proto/queue.h>
-
-static inline void fwrr_remove_from_tree(struct server *s);
-static inline void fwrr_queue_by_weight(struct eb_root *root, struct server *s);
-static inline void fwrr_dequeue_srv(struct server *s);
-static void fwrr_get_srv(struct server *s);
-static void fwrr_queue_srv(struct server *s);
-
-
-/* This function updates the server trees according to server <srv>'s new
- * state. It should be called when server <srv>'s status changes to down.
- * It is not important whether the server was already down or not. It is not
- * important either that the new state is completely down (the caller may not
- * know all the variables of a server's state).
- */
-static void fwrr_set_server_status_down(struct server *srv)
-{
-	struct proxy *p = srv->proxy;
-	struct fwrr_group *grp;
-
-	if (srv->state == srv->prev_state &&
-	    srv->eweight == srv->prev_eweight)
-		return;
-
-	if (srv_is_usable(srv->state, srv->eweight))
-		goto out_update_state;
-
-	if (!srv_is_usable(srv->prev_state, srv->prev_eweight))
-		/* server was already down */
-		goto out_update_backend;
-
-	grp = (srv->state & SRV_BACKUP) ? &p->lbprm.fwrr.bck : &p->lbprm.fwrr.act;
-	grp->next_weight -= srv->prev_eweight;
-
-	if (srv->state & SRV_BACKUP) {
-		p->lbprm.tot_wbck = p->lbprm.fwrr.bck.next_weight;
-		p->srv_bck--;
-
-		if (srv == p->lbprm.fbck) {
-			/* we lost the first backup server in a single-backup
-			 * configuration, we must search another one.
-			 */
-			struct server *srv2 = p->lbprm.fbck;
-			do {
-				srv2 = srv2->next;
-			} while (srv2 &&
-				 !((srv2->state & SRV_BACKUP) &&
-				   srv_is_usable(srv2->state, srv2->eweight)));
-			p->lbprm.fbck = srv2;
-		}
-	} else {
-		p->lbprm.tot_wact = p->lbprm.fwrr.act.next_weight;
-		p->srv_act--;
-	}
-
-	fwrr_dequeue_srv(srv);
-	fwrr_remove_from_tree(srv);
-
-out_update_backend:
-	/* check/update tot_used, tot_weight */
-	update_backend_weight(p);
- out_update_state:
-	srv->prev_state = srv->state;
-	srv->prev_eweight = srv->eweight;
-}
-
-/* This function updates the server trees according to server <srv>'s new
- * state. It should be called when server <srv>'s status changes to up.
- * It is not important whether the server was already down or not. It is not
- * important either that the new state is completely UP (the caller may not
- * know all the variables of a server's state). This function will not change
- * the weight of a server which was already up.
- */
-static void fwrr_set_server_status_up(struct server *srv)
-{
-	struct proxy *p = srv->proxy;
-	struct fwrr_group *grp;
-
-	if (srv->state == srv->prev_state &&
-	    srv->eweight == srv->prev_eweight)
-		return;
-
-	if (!srv_is_usable(srv->state, srv->eweight))
-		goto out_update_state;
-
-	if (srv_is_usable(srv->prev_state, srv->prev_eweight))
-		/* server was already up */
-		goto out_update_backend;
-
-	grp = (srv->state & SRV_BACKUP) ? &p->lbprm.fwrr.bck : &p->lbprm.fwrr.act;
-	grp->next_weight += srv->eweight;
-
-	if (srv->state & SRV_BACKUP) {
-		p->lbprm.tot_wbck = p->lbprm.fwrr.bck.next_weight;
-		p->srv_bck++;
-
-		if (!(p->options & PR_O_USE_ALL_BK)) {
-			if (!p->lbprm.fbck) {
-				/* there was no backup server anymore */
-				p->lbprm.fbck = srv;
-			} else {
-				/* we may have restored a backup server prior to fbck,
-				 * in which case it should replace it.
-				 */
-				struct server *srv2 = srv;
-				do {
-					srv2 = srv2->next;
-				} while (srv2 && (srv2 != p->lbprm.fbck));
-				if (srv2)
-					p->lbprm.fbck = srv;
-			}
-		}
-	} else {
-		p->lbprm.tot_wact = p->lbprm.fwrr.act.next_weight;
-		p->srv_act++;
-	}
-
-	/* note that eweight cannot be 0 here */
-	fwrr_get_srv(srv);
-	srv->npos = grp->curr_pos + (grp->next_weight + grp->curr_weight - grp->curr_pos) / srv->eweight;
-	fwrr_queue_srv(srv);
-
-out_update_backend:
-	/* check/update tot_used, tot_weight */
-	update_backend_weight(p);
- out_update_state:
-	srv->prev_state = srv->state;
-	srv->prev_eweight = srv->eweight;
-}
-
-/* This function must be called after an update to server <srv>'s effective
- * weight. It may be called after a state change too.
- */
-static void fwrr_update_server_weight(struct server *srv)
-{
-	int old_state, new_state;
-	struct proxy *p = srv->proxy;
-	struct fwrr_group *grp;
-
-	if (srv->state == srv->prev_state &&
-	    srv->eweight == srv->prev_eweight)
-		return;
-
-	/* If changing the server's weight changes its state, we simply apply
-	 * the procedures we already have for status change. If the state
-	 * remains down, the server is not in any tree, so it's as easy as
-	 * updating its values. If the state remains up with different weights,
-	 * there are some computations to perform to find a new place and
-	 * possibly a new tree for this server.
-	 */
-	 
-	old_state = srv_is_usable(srv->prev_state, srv->prev_eweight);
-	new_state = srv_is_usable(srv->state, srv->eweight);
-
-	if (!old_state && !new_state) {
-		srv->prev_state = srv->state;
-		srv->prev_eweight = srv->eweight;
-		return;
-	}
-	else if (!old_state && new_state) {
-		fwrr_set_server_status_up(srv);
-		return;
-	}
-	else if (old_state && !new_state) {
-		fwrr_set_server_status_down(srv);
-		return;
-	}
-
-	grp = (srv->state & SRV_BACKUP) ? &p->lbprm.fwrr.bck : &p->lbprm.fwrr.act;
-	grp->next_weight = grp->next_weight - srv->prev_eweight + srv->eweight;
-
-	p->lbprm.tot_wact = p->lbprm.fwrr.act.next_weight;
-	p->lbprm.tot_wbck = p->lbprm.fwrr.bck.next_weight;
-
-	if (srv->lb_tree == grp->init) {
-		fwrr_dequeue_srv(srv);
-		fwrr_queue_by_weight(grp->init, srv);
-	}
-	else if (!srv->lb_tree) {
-		/* FIXME: server was down. This is not possible right now but
-		 * may be needed soon for slowstart or graceful shutdown.
-		 */
-		fwrr_dequeue_srv(srv);
-		fwrr_get_srv(srv);
-		srv->npos = grp->curr_pos + (grp->next_weight + grp->curr_weight - grp->curr_pos) / srv->eweight;
-		fwrr_queue_srv(srv);
-	} else {
-		/* The server is either active or in the next queue. If it's
-		 * still in the active queue and it has not consumed all of its
-		 * places, let's adjust its next position.
-		 */
-		fwrr_get_srv(srv);
-
-		if (srv->eweight > 0) {
-			int prev_next = srv->npos;
-			int step = grp->next_weight / srv->eweight;
-
-			srv->npos = srv->lpos + step;
-			srv->rweight = 0;
-
-			if (srv->npos > prev_next)
-				srv->npos = prev_next;
-			if (srv->npos < grp->curr_pos + 2)
-				srv->npos = grp->curr_pos + step;
-		} else {
-			/* push it into the next tree */
-			srv->npos = grp->curr_pos + grp->curr_weight;
-		}
-
-		fwrr_dequeue_srv(srv);
-		fwrr_queue_srv(srv);
-	}
-
-	update_backend_weight(p);
-	srv->prev_state = srv->state;
-	srv->prev_eweight = srv->eweight;
-}
-
-/* Remove a server from a tree. It must have previously been dequeued. This
- * function is meant to be called when a server is going down or has its
- * weight disabled.
- */
-static inline void fwrr_remove_from_tree(struct server *s)
-{
-	s->lb_tree = NULL;
-}
-
-/* Queue a server in the weight tree <root>, assuming the weight is >0.
- * We want to sort them by inverted weights, because we need to place
- * heavy servers first in order to get a smooth distribution.
- */
-static inline void fwrr_queue_by_weight(struct eb_root *root, struct server *s)
-{
-	s->lb_node.key = SRV_EWGHT_MAX - s->eweight;
-	eb32_insert(root, &s->lb_node);
-	s->lb_tree = root;
-}
-
-/* This function is responsible for building the weight trees in case of fast
- * weighted round-robin. It also sets p->lbprm.wdiv to the eweight to uweight
- * ratio. Both active and backup groups are initialized.
- */
-void fwrr_init_server_groups(struct proxy *p)
-{
-	struct server *srv;
-	struct eb_root init_head = EB_ROOT;
-
-	p->lbprm.set_server_status_up   = fwrr_set_server_status_up;
-	p->lbprm.set_server_status_down = fwrr_set_server_status_down;
-	p->lbprm.update_server_eweight  = fwrr_update_server_weight;
-
-	p->lbprm.wdiv = BE_WEIGHT_SCALE;
-	for (srv = p->srv; srv; srv = srv->next) {
-		srv->prev_eweight = srv->eweight = srv->uweight * BE_WEIGHT_SCALE;
-		srv->prev_state = srv->state;
-	}
-
-	recount_servers(p);
-	update_backend_weight(p);
-
-	/* prepare the active servers group */
-	p->lbprm.fwrr.act.curr_pos = p->lbprm.fwrr.act.curr_weight =
-		p->lbprm.fwrr.act.next_weight = p->lbprm.tot_wact;
-	p->lbprm.fwrr.act.curr = p->lbprm.fwrr.act.t0 =
-		p->lbprm.fwrr.act.t1 = init_head;
-	p->lbprm.fwrr.act.init = &p->lbprm.fwrr.act.t0;
-	p->lbprm.fwrr.act.next = &p->lbprm.fwrr.act.t1;
-
-	/* prepare the backup servers group */
-	p->lbprm.fwrr.bck.curr_pos = p->lbprm.fwrr.bck.curr_weight =
-		p->lbprm.fwrr.bck.next_weight = p->lbprm.tot_wbck;
-	p->lbprm.fwrr.bck.curr = p->lbprm.fwrr.bck.t0 =
-		p->lbprm.fwrr.bck.t1 = init_head;
-	p->lbprm.fwrr.bck.init = &p->lbprm.fwrr.bck.t0;
-	p->lbprm.fwrr.bck.next = &p->lbprm.fwrr.bck.t1;
-
-	/* queue active and backup servers in two distinct groups */
-	for (srv = p->srv; srv; srv = srv->next) {
-		if (!srv_is_usable(srv->state, srv->eweight))
-			continue;
-		fwrr_queue_by_weight((srv->state & SRV_BACKUP) ?
-				p->lbprm.fwrr.bck.init :
-				p->lbprm.fwrr.act.init,
-				srv);
-	}
-}
-
-/* simply removes a server from a weight tree */
-static inline void fwrr_dequeue_srv(struct server *s)
-{
-	eb32_delete(&s->lb_node);
-}
-
-/* queues a server into the appropriate group and tree depending on its
- * backup status, and ->npos. If the server is disabled, simply assign
- * it to the NULL tree.
- */
-static void fwrr_queue_srv(struct server *s)
-{
-	struct proxy *p = s->proxy;
-	struct fwrr_group *grp;
-
-	grp = (s->state & SRV_BACKUP) ? &p->lbprm.fwrr.bck : &p->lbprm.fwrr.act;
-	
-	/* Delay everything which does not fit into the window and everything
-	 * which does not fit into the theorical new window.
-	 */
-	if (!srv_is_usable(s->state, s->eweight)) {
-		fwrr_remove_from_tree(s);
-	}
-	else if (s->eweight <= 0 ||
-		 s->npos >= 2 * grp->curr_weight ||
-		 s->npos >= grp->curr_weight + grp->next_weight) {
-		/* put into next tree, and readjust npos in case we could
-		 * finally take this back to current. */
-		s->npos -= grp->curr_weight;
-		fwrr_queue_by_weight(grp->next, s);
-	}
-	else {
-		/* The sorting key is stored in units of s->npos * user_weight
-		 * in order to avoid overflows. As stated in backend.h, the
-		 * lower the scale, the rougher the weights modulation, and the
-		 * higher the scale, the lower the number of servers without
-		 * overflow. With this formula, the result is always positive,
-		 * so we can use eb3_insert().
-		 */
-		s->lb_node.key = SRV_UWGHT_RANGE * s->npos +
-			(unsigned)(SRV_EWGHT_MAX + s->rweight - s->eweight) / BE_WEIGHT_SCALE;
-
-		eb32_insert(&grp->curr, &s->lb_node);
-		s->lb_tree = &grp->curr;
-	}
-}
-
-/* prepares a server when extracting it from the "init" tree */
-static inline void fwrr_get_srv_init(struct server *s)
-{
-	s->npos = s->rweight = 0;
-}
-
-/* prepares a server when extracting it from the "next" tree */
-static inline void fwrr_get_srv_next(struct server *s)
-{
-	struct fwrr_group *grp = (s->state & SRV_BACKUP) ?
-		&s->proxy->lbprm.fwrr.bck :
-		&s->proxy->lbprm.fwrr.act;
-
-	s->npos += grp->curr_weight;
-}
-
-/* prepares a server when it was marked down */
-static inline void fwrr_get_srv_down(struct server *s)
-{
-	struct fwrr_group *grp = (s->state & SRV_BACKUP) ?
-		&s->proxy->lbprm.fwrr.bck :
-		&s->proxy->lbprm.fwrr.act;
-
-	s->npos = grp->curr_pos;
-}
-
-/* prepares a server when extracting it from its tree */
-static void fwrr_get_srv(struct server *s)
-{
-	struct proxy *p = s->proxy;
-	struct fwrr_group *grp = (s->state & SRV_BACKUP) ?
-		&p->lbprm.fwrr.bck :
-		&p->lbprm.fwrr.act;
-
-	if (s->lb_tree == grp->init) {
-		fwrr_get_srv_init(s);
-	}
-	else if (s->lb_tree == grp->next) {
-		fwrr_get_srv_next(s);
-	}
-	else if (s->lb_tree == NULL) {
-		fwrr_get_srv_down(s);
-	}
-}
-
-/* switches trees "init" and "next" for FWRR group <grp>. "init" should be empty
- * when this happens, and "next" filled with servers sorted by weights.
- */
-static inline void fwrr_switch_trees(struct fwrr_group *grp)
-{
-	struct eb_root *swap;
-	swap = grp->init;
-	grp->init = grp->next;
-	grp->next = swap;
-	grp->curr_weight = grp->next_weight;
-	grp->curr_pos = grp->curr_weight;
-}
-
-/* return next server from the current tree in FWRR group <grp>, or a server
- * from the "init" tree if appropriate. If both trees are empty, return NULL.
- */
-static struct server *fwrr_get_server_from_group(struct fwrr_group *grp)
-{
-	struct eb32_node *node;
-	struct server *s;
-
-	node = eb32_first(&grp->curr);
-	s = eb32_entry(node, struct server, lb_node);
-	
-	if (!node || s->npos > grp->curr_pos) {
-		/* either we have no server left, or we have a hole */
-		struct eb32_node *node2;
-		node2 = eb32_first(grp->init);
-		if (node2) {
-			node = node2;
-			s = eb32_entry(node, struct server, lb_node);
-			fwrr_get_srv_init(s);
-			if (s->eweight == 0) /* FIXME: is it possible at all ? */
-				node = NULL;
-		}
-	}
-	if (node)
-		return s;
-	else
-		return NULL;
-}
-
-/* Computes next position of server <s> in the group. It is mandatory for <s>
- * to have a non-zero, positive eweight.
-*/
-static inline void fwrr_update_position(struct fwrr_group *grp, struct server *s)
-{
-	if (!s->npos) {
-		/* first time ever for this server */
-		s->lpos = grp->curr_pos;
-		s->npos = grp->curr_pos + grp->next_weight / s->eweight;
-		s->rweight += grp->next_weight % s->eweight;
-
-		if (s->rweight >= s->eweight) {
-			s->rweight -= s->eweight;
-			s->npos++;
-		}
-	} else {
-		s->lpos = s->npos;
-		s->npos += grp->next_weight / s->eweight;
-		s->rweight += grp->next_weight % s->eweight;
-
-		if (s->rweight >= s->eweight) {
-			s->rweight -= s->eweight;
-			s->npos++;
-		}
-	}
-}
-
-/* Return next server from the current tree in backend <p>, or a server from
- * the init tree if appropriate. If both trees are empty, return NULL.
- * Saturated servers are skipped and requeued.
- */
-struct server *fwrr_get_next_server(struct proxy *p, struct server *srvtoavoid)
-{
-	struct server *srv, *full, *avoided;
-	struct fwrr_group *grp;
-	int switched;
-
-	if (p->srv_act)
-		grp = &p->lbprm.fwrr.act;
-	else if (p->lbprm.fbck)
-		return p->lbprm.fbck;
-	else if (p->srv_bck)
-		grp = &p->lbprm.fwrr.bck;
-	else
-		return NULL;
-
-	switched = 0;
-	avoided = NULL;
-	full = NULL; /* NULL-terminated list of saturated servers */
-	while (1) {
-		/* if we see an empty group, let's first try to collect weights
-		 * which might have recently changed.
-		 */
-		if (!grp->curr_weight)
-			grp->curr_pos = grp->curr_weight = grp->next_weight;
-
-		/* get first server from the "current" tree. When the end of
-		 * the tree is reached, we may have to switch, but only once.
-		 */
-		while (1) {
-			srv = fwrr_get_server_from_group(grp);
-			if (srv)
-				break;
-			if (switched) {
-				if (avoided) {
-					srv = avoided;
-					break;
-				}
-				goto requeue_servers;
-			}
-			switched = 1;
-			fwrr_switch_trees(grp);
-
-		}
-
-		/* OK, we have a server. However, it may be saturated, in which
-		 * case we don't want to reconsider it for now. We'll update
-		 * its position and dequeue it anyway, so that we can move it
-		 * to a better place afterwards.
-		 */
-		fwrr_update_position(grp, srv);
-		fwrr_dequeue_srv(srv);
-		grp->curr_pos++;
-		if (!srv->maxconn || (!srv->nbpend && srv->served < srv_dynamic_maxconn(srv))) {
-			/* make sure it is not the server we are trying to exclude... */
-			if (srv != srvtoavoid || avoided)
-				break;
-
-			avoided = srv; /* ...but remember that is was selected yet avoided */
-		}
-
-		/* the server is saturated or avoided, let's chain it for later reinsertion */
-		srv->next_full = full;
-		full = srv;
-	}
-
-	/* OK, we got the best server, let's update it */
-	fwrr_queue_srv(srv);
-
- requeue_servers:
-	/* Requeue all extracted servers. If full==srv then it was
-	 * avoided (unsucessfully) and chained, omit it now.
-	 */
-	if (unlikely(full != NULL)) {
-		if (switched) {
-			/* the tree has switched, requeue all extracted servers
-			 * into "init", because their place was lost, and only
-			 * their weight matters.
-			 */
-			do {
-				if (likely(full != srv))
-					fwrr_queue_by_weight(grp->init, full);
-				full = full->next_full;
-			} while (full);
-		} else {
-			/* requeue all extracted servers just as if they were consumed
-			 * so that they regain their expected place.
-			 */
-			do {
-				if (likely(full != srv))
-					fwrr_queue_srv(full);
-				full = full->next_full;
-			} while (full);
-		}
-	}
-	return srv;
-}
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/lb_map.c b/deps/haproxy-1.4.21/src/lb_map.c
deleted file mode 100644
index 49805ad..0000000
--- a/deps/haproxy-1.4.21/src/lb_map.c
+++ /dev/null
@@ -1,276 +0,0 @@
-/*
- * Map-based load-balancing (RR and HASH)
- *
- * Copyright 2000-2009 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <common/compat.h>
-#include <common/config.h>
-#include <common/debug.h>
-#include <eb32tree.h>
-
-#include <types/global.h>
-#include <types/server.h>
-
-#include <proto/backend.h>
-#include <proto/proto_http.h>
-#include <proto/proto_tcp.h>
-#include <proto/queue.h>
-
-/* this function updates the map according to server <srv>'s new state */
-static void map_set_server_status_down(struct server *srv)
-{
-	struct proxy *p = srv->proxy;
-
-	if (srv->state == srv->prev_state &&
-	    srv->eweight == srv->prev_eweight)
-		return;
-
-	if (srv_is_usable(srv->state, srv->eweight))
-		goto out_update_state;
-
-	/* FIXME: could be optimized since we know what changed */
-	recount_servers(p);
-	update_backend_weight(p);
-	p->lbprm.map.state |= LB_MAP_RECALC;
- out_update_state:
-	srv->prev_state = srv->state;
-	srv->prev_eweight = srv->eweight;
-}
-
-/* This function updates the map according to server <srv>'s new state */
-static void map_set_server_status_up(struct server *srv)
-{
-	struct proxy *p = srv->proxy;
-
-	if (srv->state == srv->prev_state &&
-	    srv->eweight == srv->prev_eweight)
-		return;
-
-	if (!srv_is_usable(srv->state, srv->eweight))
-		goto out_update_state;
-
-	/* FIXME: could be optimized since we know what changed */
-	recount_servers(p);
-	update_backend_weight(p);
-	p->lbprm.map.state |= LB_MAP_RECALC;
- out_update_state:
-	srv->prev_state = srv->state;
-	srv->prev_eweight = srv->eweight;
-}
-
-/* This function recomputes the server map for proxy px. It relies on
- * px->lbprm.tot_wact, tot_wbck, tot_used, tot_weight, so it must be
- * called after recount_servers(). It also expects px->lbprm.map.srv
- * to be allocated with the largest size needed. It updates tot_weight.
- */
-void recalc_server_map(struct proxy *px)
-{
-	int o, tot, flag;
-	struct server *cur, *best;
-
-	switch (px->lbprm.tot_used) {
-	case 0:	/* no server */
-		px->lbprm.map.state &= ~LB_MAP_RECALC;
-		return;
-	default:
-		tot = px->lbprm.tot_weight;
-		break;
-	}
-
-	/* here we *know* that we have some servers */
-	if (px->srv_act)
-		flag = SRV_RUNNING;
-	else
-		flag = SRV_RUNNING | SRV_BACKUP;
-
-	/* this algorithm gives priority to the first server, which means that
-	 * it will respect the declaration order for equivalent weights, and
-	 * that whatever the weights, the first server called will always be
-	 * the first declared. This is an important asumption for the backup
-	 * case, where we want the first server only.
-	 */
-	for (cur = px->srv; cur; cur = cur->next)
-		cur->wscore = 0;
-
-	for (o = 0; o < tot; o++) {
-		int max = 0;
-		best = NULL;
-		for (cur = px->srv; cur; cur = cur->next) {
-			if (cur->eweight &&
-			    flag == (cur->state &
-				     (SRV_RUNNING | SRV_GOINGDOWN | SRV_BACKUP))) {
-				int v;
-
-				/* If we are forced to return only one server, we don't want to
-				 * go further, because we would return the wrong one due to
-				 * divide overflow.
-				 */
-				if (tot == 1) {
-					best = cur;
-					/* note that best->wscore will be wrong but we don't care */
-					break;
-				}
-
-				cur->wscore += cur->eweight;
-				v = (cur->wscore + tot) / tot; /* result between 0 and 3 */
-				if (best == NULL || v > max) {
-					max = v;
-					best = cur;
-				}
-			}
-		}
-		px->lbprm.map.srv[o] = best;
-		best->wscore -= tot;
-	}
-	px->lbprm.map.state &= ~LB_MAP_RECALC;
-}
-
-/* This function is responsible of building the server MAP for map-based LB
- * algorithms, allocating the map, and setting p->lbprm.wmult to the GCD of the
- * weights if applicable. It should be called only once per proxy, at config
- * time.
- */
-void init_server_map(struct proxy *p)
-{
-	struct server *srv;
-	int pgcd;
-	int act, bck;
-
-	p->lbprm.set_server_status_up   = map_set_server_status_up;
-	p->lbprm.set_server_status_down = map_set_server_status_down;
-	p->lbprm.update_server_eweight = NULL;
- 
-	if (!p->srv)
-		return;
-
-	/* We will factor the weights to reduce the table,
-	 * using Euclide's largest common divisor algorithm.
-	 * Since we may have zero weights, we have to first
-	 * find a non-zero weight server.
-	 */
-	pgcd = 1;
-	srv = p->srv;
-	while (srv && !srv->uweight)
-		srv = srv->next;
-
-	if (srv) {
-		pgcd = srv->uweight; /* note: cannot be zero */
-		while (pgcd > 1 && (srv = srv->next)) {
-			int w = srv->uweight;
-			while (w) {
-				int t = pgcd % w;
-				pgcd = w;
-				w = t;
-			}
-		}
-	}
-
-	/* It is sometimes useful to know what factor to apply
-	 * to the backend's effective weight to know its real
-	 * weight.
-	 */
-	p->lbprm.wmult = pgcd;
-
-	act = bck = 0;
-	for (srv = p->srv; srv; srv = srv->next) {
-		srv->eweight = srv->uweight / pgcd;
-		srv->prev_eweight = srv->eweight;
-		srv->prev_state = srv->state;
-		if (srv->state & SRV_BACKUP)
-			bck += srv->eweight;
-		else
-			act += srv->eweight;
-	}
-
-	/* this is the largest map we will ever need for this servers list */
-	if (act < bck)
-		act = bck;
-
-	if (!act)
-		act = 1;
-
-	p->lbprm.map.srv = (struct server **)calloc(act, sizeof(struct server *));
-	/* recounts servers and their weights */
-	p->lbprm.map.state = LB_MAP_RECALC;
-	recount_servers(p);
-	update_backend_weight(p);
-	recalc_server_map(p);
-}
-
-/*
- * This function tries to find a running server with free connection slots for
- * the proxy <px> following the round-robin method.
- * If any server is found, it will be returned and px->lbprm.map.rr_idx will be updated
- * to point to the next server. If no valid server is found, NULL is returned.
- */
-struct server *map_get_server_rr(struct proxy *px, struct server *srvtoavoid)
-{
-	int newidx, avoididx;
-	struct server *srv, *avoided;
-
-	if (px->lbprm.tot_weight == 0)
-		return NULL;
-
-	if (px->lbprm.map.state & LB_MAP_RECALC)
-		recalc_server_map(px);
-
-	if (px->lbprm.map.rr_idx < 0 || px->lbprm.map.rr_idx >= px->lbprm.tot_weight)
-		px->lbprm.map.rr_idx = 0;
-	newidx = px->lbprm.map.rr_idx;
-
-	avoided = NULL;
-	avoididx = 0; /* shut a gcc warning */
-	do {
-		srv = px->lbprm.map.srv[newidx++];
-		if (!srv->maxconn || srv->cur_sess < srv_dynamic_maxconn(srv)) {
-			/* make sure it is not the server we are try to exclude... */
-			if (srv != srvtoavoid) {
-				px->lbprm.map.rr_idx = newidx;
-				return srv;
-			}
-
-			avoided = srv;	/* ...but remember that is was selected yet avoided */
-			avoididx = newidx;
-		}
-		if (newidx == px->lbprm.tot_weight)
-			newidx = 0;
-	} while (newidx != px->lbprm.map.rr_idx);
-
-	if (avoided)
-		px->lbprm.map.rr_idx = avoididx;
-
-	/* return NULL or srvtoavoid if found */
-	return avoided;
-}
-
-/*
- * This function returns the running server from the map at the location
- * pointed to by the result of a modulo operation on <hash>. The server map may
- * be recomputed if required before being looked up. If any server is found, it
- * will be returned.  If no valid server is found, NULL is returned.
- */
-struct server *map_get_server_hash(struct proxy *px, unsigned int hash)
-{
-	if (px->lbprm.tot_weight == 0)
-		return NULL;
-
-	if (px->lbprm.map.state & LB_MAP_RECALC)
-		recalc_server_map(px);
-
-	return px->lbprm.map.srv[hash % px->lbprm.tot_weight];
-}
-
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/log.c b/deps/haproxy-1.4.21/src/log.c
deleted file mode 100644
index 3354eae..0000000
--- a/deps/haproxy-1.4.21/src/log.c
+++ /dev/null
@@ -1,387 +0,0 @@
-/*
- * General logging functions.
- *
- * Copyright 2000-2008 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <fcntl.h>
-#include <stdarg.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <syslog.h>
-#include <time.h>
-#include <unistd.h>
-#include <errno.h>
-
-#include <sys/time.h>
-
-#include <common/config.h>
-#include <common/compat.h>
-#include <common/standard.h>
-#include <common/time.h>
-
-#include <types/global.h>
-
-#include <proto/log.h>
-
-const char *log_facilities[NB_LOG_FACILITIES] = {
-	"kern", "user", "mail", "daemon",
-	"auth", "syslog", "lpr", "news",
-	"uucp", "cron", "auth2", "ftp",
-	"ntp", "audit", "alert", "cron2",
-	"local0", "local1", "local2", "local3",
-	"local4", "local5", "local6", "local7"
-};
-
-
-const char *log_levels[NB_LOG_LEVELS] = {
-	"emerg", "alert", "crit", "err",
-	"warning", "notice", "info", "debug"
-};
-
-const char *monthname[12] = {
-	"Jan", "Feb", "Mar", "Apr", "May", "Jun",
-	"Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
-};
-
-const char sess_term_cond[8]  = "-cCsSPRI";	/* normal, CliTo, CliErr, SrvTo, SrvErr, PxErr, Resource, Internal */
-const char sess_fin_state[8]  = "-RCHDLQT";	/* cliRequest, srvConnect, srvHeader, Data, Last, Queue, Tarpit */
-
-/*
- * Displays the message on stderr with the date and pid. Overrides the quiet
- * mode during startup.
- */
-void Alert(const char *fmt, ...)
-{
-	va_list argp;
-	struct tm tm;
-
-	if (!(global.mode & MODE_QUIET) || (global.mode & (MODE_VERBOSE | MODE_STARTING))) {
-		va_start(argp, fmt);
-
-		get_localtime(date.tv_sec, &tm);
-		fprintf(stderr, "[ALERT] %03d/%02d%02d%02d (%d) : ",
-			tm.tm_yday, tm.tm_hour, tm.tm_min, tm.tm_sec, (int)getpid());
-		vfprintf(stderr, fmt, argp);
-		fflush(stderr);
-		va_end(argp);
-	}
-}
-
-
-/*
- * Displays the message on stderr with the date and pid.
- */
-void Warning(const char *fmt, ...)
-{
-	va_list argp;
-	struct tm tm;
-
-	if (!(global.mode & MODE_QUIET) || (global.mode & MODE_VERBOSE)) {
-		va_start(argp, fmt);
-
-		get_localtime(date.tv_sec, &tm);
-		fprintf(stderr, "[WARNING] %03d/%02d%02d%02d (%d) : ",
-			tm.tm_yday, tm.tm_hour, tm.tm_min, tm.tm_sec, (int)getpid());
-		vfprintf(stderr, fmt, argp);
-		fflush(stderr);
-		va_end(argp);
-	}
-}
-
-/*
- * Displays the message on <out> only if quiet mode is not set.
- */
-void qfprintf(FILE *out, const char *fmt, ...)
-{
-	va_list argp;
-
-	if (!(global.mode & MODE_QUIET) || (global.mode & MODE_VERBOSE)) {
-		va_start(argp, fmt);
-		vfprintf(out, fmt, argp);
-		fflush(out);
-		va_end(argp);
-	}
-}
-
-/*
- * returns log level for <lev> or -1 if not found.
- */
-int get_log_level(const char *lev)
-{
-	int level;
-
-	level = NB_LOG_LEVELS - 1;
-	while (level >= 0 && strcmp(log_levels[level], lev))
-		level--;
-
-	return level;
-}
-
-
-/*
- * returns log facility for <fac> or -1 if not found.
- */
-int get_log_facility(const char *fac)
-{
-	int facility;
-
-	facility = NB_LOG_FACILITIES - 1;
-	while (facility >= 0 && strcmp(log_facilities[facility], fac))
-		facility--;
-	
-	return facility;
-}
-
-/*
- * Return the length of the address endpoint, suitable for use with sendto().
- */
-static inline int logsrv_addrlen(const struct logsrv *logsrv)
-{
-	switch (logsrv->u.addr.sa_family) {
-	case AF_UNIX:
-		return sizeof(logsrv->u.un);
-	case AF_INET:
-		return sizeof(logsrv->u.in);
-	default:
-		break;
-	}
-	return -1;
-}
-
-/*
- * This function sends a syslog message to both log servers of a proxy,
- * or to global log servers if the proxy is NULL.
- * It also tries not to waste too much time computing the message header.
- * It doesn't care about errors nor does it report them.
- */
-void send_log(struct proxy *p, int level, const char *message, ...)
-{
-	static int logfdunix = -1;	/* syslog to AF_UNIX socket */
-	static int logfdinet = -1;	/* syslog to AF_INET socket */
-	static long tvsec = -1;	/* to force the string to be initialized */
-	va_list argp;
-	static char logmsg[MAX_SYSLOG_LEN];
-	static char *dataptr = NULL;
-	int fac_level;
-	int hdr_len, data_len;
-	struct logsrv *logsrvs[2];
-	int facilities[2], loglevel[2], minlvl[2];
-	int nblogger;
-	int nbloggers = 0;
-	char *log_ptr;
-
-	if (level < 0 || message == NULL)
-		return;
-
-	if (unlikely(date.tv_sec != tvsec || dataptr == NULL)) {
-		/* this string is rebuild only once a second */
-		struct tm tm;
-
-		tvsec = date.tv_sec;
-		get_localtime(tvsec, &tm);
-
-		hdr_len = snprintf(logmsg, sizeof(logmsg),
-				   "<<<<>%s %2d %02d:%02d:%02d %s%s[%d]: ",
-				   monthname[tm.tm_mon],
-				   tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec,
-				   global.log_send_hostname ? global.log_send_hostname : "",
-				   global.log_tag, pid);
-		/* WARNING: depending upon implementations, snprintf may return
-		 * either -1 or the number of bytes that would be needed to store
-		 * the total message. In both cases, we must adjust it.
-		 */
-		if (hdr_len < 0 || hdr_len > sizeof(logmsg))
-			hdr_len = sizeof(logmsg);
-
-		dataptr = logmsg + hdr_len;
-	}
-
-	va_start(argp, message);
-	/*
-	 * FIXME: we take a huge performance hit here. We might have to replace
-	 * vsnprintf() for a hard-coded log writer.
-	 */
-	data_len = vsnprintf(dataptr, logmsg + sizeof(logmsg) - dataptr, message, argp);
-	if (data_len < 0 || data_len > (logmsg + sizeof(logmsg) - dataptr))
-		data_len = logmsg + sizeof(logmsg) - dataptr;
-	va_end(argp);
-	dataptr[data_len - 1] = '\n'; /* force a break on ultra-long lines */
-
-	if (p == NULL) {
-		if (global.logfac1 >= 0) {
-			logsrvs[nbloggers] = &global.logsrv1;
-			facilities[nbloggers] = global.logfac1;
-			loglevel[nbloggers] = global.loglev1;
-			minlvl[nbloggers] = global.minlvl1;
-			nbloggers++;
-		}
-		if (global.logfac2 >= 0) {
-			logsrvs[nbloggers] = &global.logsrv2;
-			facilities[nbloggers] = global.logfac2;
-			loglevel[nbloggers] = global.loglev2;
-			minlvl[nbloggers] = global.minlvl2;
-			nbloggers++;
-		}
-	} else {
-		if (p->logfac1 >= 0) {
-			logsrvs[nbloggers] = &p->logsrv1;
-			facilities[nbloggers] = p->logfac1;
-			loglevel[nbloggers] = p->loglev1;
-			minlvl[nbloggers] = p->minlvl1;
-			nbloggers++;
-		}
-		if (p->logfac2 >= 0) {
-			logsrvs[nbloggers] = &p->logsrv2;
-			facilities[nbloggers] = p->logfac2;
-			loglevel[nbloggers] = p->loglev2;
-			minlvl[nbloggers] = p->minlvl2;
-			nbloggers++;
-		}
-	}
-
-	/* Lazily set up syslog sockets for protocol families of configured
-	 * syslog servers. */
-	for (nblogger = 0; nblogger < nbloggers; nblogger++) {
-		const struct logsrv *logsrv = logsrvs[nblogger];
-		int proto, *plogfd;
-		if (logsrv->u.addr.sa_family == AF_UNIX) {
-			proto = 0;
-			plogfd = &logfdunix;
-		} else {
-			/* sa_family == AF_INET */
-			proto = IPPROTO_UDP;
-			plogfd = &logfdinet;
-		}
-		if (*plogfd >= 0) {
-			/* socket already created. */
-			continue;
-		}
-		if ((*plogfd = socket(logsrv->u.addr.sa_family, SOCK_DGRAM,
-				proto)) < 0) {
-			Alert("socket for logger #%d failed: %s (errno=%d)\n",
-				nblogger + 1, strerror(errno), errno);
-			return;
-		}
-		/* we don't want to receive anything on this socket */
-		setsockopt(*plogfd, SOL_SOCKET, SO_RCVBUF, &zero, sizeof(zero));
-		/* does nothing under Linux, maybe needed for others */
-		shutdown(*plogfd, SHUT_RD);
-	}
-
-	/* Send log messages to syslog server. */
-	for (nblogger = 0; nblogger < nbloggers; nblogger++) {
-		const struct logsrv *logsrv = logsrvs[nblogger];
-		int *plogfd = logsrv->u.addr.sa_family == AF_UNIX ?
-			&logfdunix : &logfdinet;
-		int sent;
-
-		/* we can filter the level of the messages that are sent to each logger */
-		if (level > loglevel[nblogger])
-			continue;
-	
-		/* For each target, we may have a different facility.
-		 * We can also have a different log level for each message.
-		 * This induces variations in the message header length.
-		 * Since we don't want to recompute it each time, nor copy it every
-		 * time, we only change the facility in the pre-computed header,
-		 * and we change the pointer to the header accordingly.
-		 */
-		fac_level = (facilities[nblogger] << 3) + MAX(level, minlvl[nblogger]);
-		log_ptr = logmsg + 3; /* last digit of the log level */
-		do {
-			*log_ptr = '0' + fac_level % 10;
-			fac_level /= 10;
-			log_ptr--;
-		} while (fac_level && log_ptr > logmsg);
-		*log_ptr = '<';
-	
-		/* the total syslog message now starts at logptr, for dataptr+data_len-logptr */
-		sent = sendto(*plogfd, log_ptr, dataptr + data_len - log_ptr,
-			MSG_DONTWAIT | MSG_NOSIGNAL, &logsrv->u.addr, logsrv_addrlen(logsrv));
-		if (sent < 0) {
-			Alert("sendto logger #%d failed: %s (errno=%d)\n",
-				nblogger, strerror(errno), errno);
-		}
-	}
-}
-
-
-/*
- * send a log for the session when we have enough info about it
- */
-void tcp_sess_log(struct session *s)
-{
-	char pn[INET6_ADDRSTRLEN + strlen(":65535")];
-	struct proxy *fe = s->fe;
-	struct proxy *be = s->be;
-	struct proxy *prx_log;
-	int tolog, level, err;
-	char *svid;
-	struct tm tm;
-
-	/* if we don't want to log normal traffic, return now */
-	err = (s->flags & (SN_ERR_MASK | SN_REDISP)) || (s->conn_retries != be->conn_retries);
-	if (!err && (fe->options2 & PR_O2_NOLOGNORM))
-		return;
-
-	if (s->cli_addr.ss_family == AF_INET)
-		inet_ntop(AF_INET,
-			  (const void *)&((struct sockaddr_in *)&s->cli_addr)->sin_addr,
-			  pn, sizeof(pn));
-	else
-		inet_ntop(AF_INET6,
-			  (const void *)&((struct sockaddr_in6 *)(&s->cli_addr))->sin6_addr,
-			  pn, sizeof(pn));
-
-	get_localtime(s->logs.tv_accept.tv_sec, &tm);
-
-	if (fe->logfac1 < 0 && fe->logfac2 < 0)
-		return;
-
-	prx_log = fe;
-	tolog = fe->to_log;
-	svid = (tolog & LW_SVID) ? (s->srv != NULL) ? s->srv->id : "<NOSRV>" : "-";
-
-	level = LOG_INFO;
-	if (err && (fe->options2 & PR_O2_LOGERRORS))
-		level = LOG_ERR;
-
-	send_log(prx_log, level, "%s:%d [%02d/%s/%04d:%02d:%02d:%02d.%03d]"
-		 " %s %s/%s %ld/%ld/%s%ld %s%lld"
-		 " %c%c %d/%d/%d/%d/%s%u %ld/%ld\n",
-		 pn,
-		 (s->cli_addr.ss_family == AF_INET) ?
-		 ntohs(((struct sockaddr_in *)&s->cli_addr)->sin_port) :
-		 ntohs(((struct sockaddr_in6 *)&s->cli_addr)->sin6_port),
-		 tm.tm_mday, monthname[tm.tm_mon], tm.tm_year+1900,
-		 tm.tm_hour, tm.tm_min, tm.tm_sec, (int)s->logs.tv_accept.tv_usec/1000,
-		 fe->id, be->id, svid,
-		 (s->logs.t_queue >= 0) ? s->logs.t_queue : -1,
-		 (s->logs.t_connect >= 0) ? s->logs.t_connect - s->logs.t_queue : -1,
-		 (tolog & LW_BYTES) ? "" : "+", s->logs.t_close,
-		 (tolog & LW_BYTES) ? "" : "+", s->logs.bytes_out,
-		 sess_term_cond[(s->flags & SN_ERR_MASK) >> SN_ERR_SHIFT],
-		 sess_fin_state[(s->flags & SN_FINST_MASK) >> SN_FINST_SHIFT],
-		 actconn, fe->feconn, be->beconn, s->srv ? s->srv->cur_sess : 0,
-		 (s->flags & SN_REDISP)?"+":"",
-		 (s->conn_retries>0)?(be->conn_retries - s->conn_retries):be->conn_retries,
-		 s->logs.srv_queue_size, s->logs.prx_queue_size);
-
-	s->logs.logwait = 0;
-}
-
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/memory.c b/deps/haproxy-1.4.21/src/memory.c
deleted file mode 100644
index 36db92e..0000000
--- a/deps/haproxy-1.4.21/src/memory.c
+++ /dev/null
@@ -1,205 +0,0 @@
-/*
- * Memory management functions.
- *
- * Copyright 2000-2007 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <common/config.h>
-#include <common/debug.h>
-#include <common/memory.h>
-#include <common/mini-clist.h>
-#include <common/standard.h>
-
-#include <proto/log.h>
-
-static struct list pools = LIST_HEAD_INIT(pools);
-
-/* Try to find an existing shared pool with the same characteristics and
- * returns it, otherwise creates this one. NULL is returned if no memory
- * is available for a new creation.
- */
-struct pool_head *create_pool(char *name, unsigned int size, unsigned int flags)
-{
-	struct pool_head *pool;
-	struct pool_head *entry;
-	struct list *start;
-	unsigned int align;
-
-	/* We need to store at least a (void *) in the chunks. Since we know
-	 * that the malloc() function will never return such a small size,
-	 * let's round the size up to something slightly bigger, in order to
-	 * ease merging of entries. Note that the rounding is a power of two.
-	 */
-
-	align = 16;
-	size  = (size + align - 1) & -align;
-
-	start = &pools;
-	pool = NULL;
-
-	list_for_each_entry(entry, &pools, list) {
-		if (entry->size == size) {
-			/* either we can share this place and we take it, or
-			 * we look for a sharable one or for the next position
-			 * before which we will insert a new one.
-			 */
-			if (flags & entry->flags & MEM_F_SHARED) {
-				/* we can share this one */
-				pool = entry;
-				DPRINTF(stderr, "Sharing %s with %s\n", name, pool->name);
-				break;
-			}
-		}
-		else if (entry->size > size) {
-			/* insert before this one */
-			start = &entry->list;
-			break;
-		}
-	}
-
-	if (!pool) {
-		pool = CALLOC(1, sizeof(*pool));
-		if (!pool)
-			return NULL;
-		if (name)
-			strlcpy2(pool->name, name, sizeof(pool->name));
-		pool->size = size;
-		pool->flags = flags;
-		LIST_ADDQ(start, &pool->list);
-	}
-	pool->users++;
-	return pool;
-}
-
-/* Allocate a new entry for pool <pool>, and return it for immediate use.
- * NULL is returned if no memory is available for a new creation. A call
- * to the garbage collector is performed before returning NULL.
- */
-void *pool_refill_alloc(struct pool_head *pool)
-{
-	void *ret;
-
-	if (pool->limit && (pool->allocated >= pool->limit))
-		return NULL;
-	ret = MALLOC(pool->size);
-	if (!ret) {
-		pool_gc2();
-		ret = MALLOC(pool->size);
-		if (!ret)
-			return NULL;
-	}
-	pool->allocated++;
-	pool->used++;
-	return ret;
-}
-
-/*
- * This function frees whatever can be freed in pool <pool>.
- */
-void pool_flush2(struct pool_head *pool)
-{
-	void *temp, *next;
-	if (!pool)
-		return;
-
-	next = pool->free_list;
-	while (next) {
-		temp = next;
-		next = *(void **)temp;
-		pool->allocated--;
-		FREE(temp);
-	}
-	pool->free_list = next;
-
-	/* here, we should have pool->allocate == pool->used */
-}
-
-/*
- * This function frees whatever can be freed in all pools, but respecting
- * the minimum thresholds imposed by owners. It takes care of avoiding
- * recursion because it may be called from a signal handler.
- */
-void pool_gc2()
-{
-	static int recurse;
-	struct pool_head *entry;
-
-	if (recurse++)
-		goto out;
-
-	list_for_each_entry(entry, &pools, list) {
-		void *temp, *next;
-		//qfprintf(stderr, "Flushing pool %s\n", entry->name);
-		next = entry->free_list;
-		while (next &&
-		       entry->allocated > entry->minavail &&
-		       entry->allocated > entry->used) {
-			temp = next;
-			next = *(void **)temp;
-			entry->allocated--;
-			FREE(temp);
-		}
-		entry->free_list = next;
-	}
- out:
-	recurse--;
-}
-
-/*
- * This function destroys a pool by freeing it completely, unless it's still
- * in use. This should be called only under extreme circumstances. It always
- * returns NULL if the resulting pool is empty, easing the clearing of the old
- * pointer, otherwise it returns the pool.
- * .
- */
-void *pool_destroy2(struct pool_head *pool)
-{
-	if (pool) {
-		pool_flush2(pool);
-		if (pool->used)
-			return pool;
-		pool->users--;
-		if (!pool->users) {
-			LIST_DEL(&pool->list);
-			FREE(pool);
-		}
-	}
-	return NULL;
-}
-
-/* Dump statistics on pools usage.
- */
-void dump_pools(void)
-{
-	struct pool_head *entry;
-	unsigned long allocated, used;
-	int nbpools;
-
-	allocated = used = nbpools = 0;
-	qfprintf(stderr, "Dumping pools usage.\n");
-	list_for_each_entry(entry, &pools, list) {
-		qfprintf(stderr, "  - Pool %s (%d bytes) : %d allocated (%u bytes), %d used, %d users%s\n",
-			 entry->name, entry->size, entry->allocated,
-			 entry->size * entry->allocated, entry->used,
-			 entry->users, (entry->flags & MEM_F_SHARED) ? " [SHARED]" : "");
-
-		allocated += entry->allocated * entry->size;
-		used += entry->used * entry->size;
-		nbpools++;
-	}
-	qfprintf(stderr, "Total: %d pools, %lu bytes allocated, %lu used.\n",
-		 nbpools, allocated, used);
-}
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/pattern.c b/deps/haproxy-1.4.21/src/pattern.c
deleted file mode 100644
index 63bae2b..0000000
--- a/deps/haproxy-1.4.21/src/pattern.c
+++ /dev/null
@@ -1,597 +0,0 @@
-/*
- * Patterns management functions.
- *
- * Copyright 2009-2010 EXCELIANCE, Emeric Brun <ebrun@exceliance.fr>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <string.h>
-#include <arpa/inet.h>
-#include <types/stick_table.h>
-
-#include <proto/pattern.h>
-#include <common/standard.h>
-
-/* static structure used on pattern_process if <p> is NULL*/
-static struct pattern spattern;
-
-/* trash chunk used for pattern conversions */
-static struct chunk trash_chunk;
-
-/* trash buffers used or pattern conversions */
-static char pattern_trash_buf1[BUFSIZE];
-static char pattern_trash_buf2[BUFSIZE];
-
-/* pattern_trash_buf point on used buffer*/
-static char *pattern_trash_buf = pattern_trash_buf1;
-
-/* static structure used to returns builded table key from a pattern*/
-static struct stktable_key stable_key;
-
-/* list head of all known pattern fetch keywords */
-static struct pattern_fetch_kw_list pattern_fetches = {
-	.list = LIST_HEAD_INIT(pattern_fetches.list)
-};
-
-/* list head of all known pattern format conversion keywords */
-static struct pattern_conv_kw_list pattern_convs = {
-	.list = LIST_HEAD_INIT(pattern_convs.list)
-};
-
-/*
- * Registers the pattern fetch keyword list <kwl> as a list of valid keywords for next
- * parsing sessions.
- */
-void pattern_register_fetches(struct pattern_fetch_kw_list *pfkl)
-{
-	LIST_ADDQ(&pattern_fetches.list, &pfkl->list);
-}
-
-/*
- * Registers the pattern format coverstion keyword list <pckl> as a list of valid keywords for next
- * parsing sessions.
- */
-void pattern_register_convs(struct pattern_conv_kw_list *pckl)
-{
-	LIST_ADDQ(&pattern_convs.list, &pckl->list);
-}
-
-/*
- * Returns the pointer on pattern fetch keyword structure identified by
- * string of <len> in buffer <kw>.
- *
- */
-struct pattern_fetch *find_pattern_fetch(const char *kw, int len)
-{
-	int index;
-	struct pattern_fetch_kw_list *kwl;
-
-	list_for_each_entry(kwl, &pattern_fetches.list, list) {
-		for (index = 0; kwl->kw[index].kw != NULL; index++) {
-			if (strncmp(kwl->kw[index].kw, kw, len) == 0 &&
-			    kwl->kw[index].kw[len] == '\0')
-				return &kwl->kw[index];
-		}
-	}
-	return NULL;
-}
-
-/*
- * Returns the pointer on pattern format conversion keyword structure identified by
- * string of <len> in buffer <kw>.
- *
- */
-struct pattern_conv *find_pattern_conv(const char *kw, int len)
-{
-	int index;
-	struct pattern_conv_kw_list *kwl;
-
-	list_for_each_entry(kwl, &pattern_convs.list, list) {
-		for (index = 0; kwl->kw[index].kw != NULL; index++) {
-			if (strncmp(kwl->kw[index].kw, kw, len) == 0 &&
-			    kwl->kw[index].kw[len] == '\0')
-				return &kwl->kw[index];
-		}
-	}
-	return NULL;
-}
-
-
-/*
-* Returns a static trash struct chunk to use in pattern casts or format conversions
-* Swiths the 2 available trash buffers to protect data during convert
-*/
-static struct chunk *get_trash_chunk(void)
-{
-	if (pattern_trash_buf == pattern_trash_buf1)
-		pattern_trash_buf = pattern_trash_buf2;
-	else
-		pattern_trash_buf = pattern_trash_buf1;
-
-	trash_chunk.str = pattern_trash_buf;
-	trash_chunk.len = 0;
-	trash_chunk.size = BUFSIZE;
-
-	return &trash_chunk;
-}
-
-/*
-* Used to set pattern data from a struct chunk, could be the trash struct chunk
-*/
-static void pattern_data_setstring(union pattern_data *data, struct chunk *c)
-{
-	data->str.str = c->str;
-	data->str.len = c->len;
-	data->str.size = c->size;
-}
-
-/******************************************************************/
-/*          Pattern casts functions                               */
-/******************************************************************/
-
-static int c_ip2int(union pattern_data *data)
-{
-	data->integer = ntohl(data->ip.s_addr);
-	return 1;
-}
-
-static int c_ip2str(union pattern_data *data)
-{
-	struct chunk *trash = get_trash_chunk();
-
-	if (!inet_ntop(AF_INET, (void *)&data->ip, trash->str, trash->size))
-		return 0;
-
-	trash->len = strlen(trash->str);
-	pattern_data_setstring(data, trash);
-
-	return 1;
-}
-
-static int c_int2ip(union pattern_data *data)
-{
-	data->ip.s_addr = htonl(data->integer);
-	return 1;
-}
-
-/* Convert a fixed-length string to an IP address. Returns 0 in case of error,
- * or the number of chars read in case of success.
- */
-static int buf2ip(const char *buf, size_t len, struct in_addr *dst)
-{
-	const char *addr;
-	int saw_digit, octets, ch;
-	u_char tmp[4], *tp;
-	const char *cp = buf;
-
-	saw_digit = 0;
-	octets = 0;
-	*(tp = tmp) = 0;
-
-	for (addr = buf; addr - buf < len; addr++) {
-		unsigned char digit = (ch = *addr) - '0';
-
-		if (digit > 9 && ch != '.')
-			break;
-
-		if (digit <= 9) {
-			u_int new = *tp * 10 + digit;
-
-			if (new > 255)
-				return 0;
-
-			*tp = new;
-
-			if (!saw_digit) {
-				if (++octets > 4)
-					return 0;
-				saw_digit = 1;
-			}
-		} else if (ch == '.' && saw_digit) {
-			if (octets == 4)
-				return 0;
-
-			*++tp = 0;
-			saw_digit = 0;
-		} else
-			return 0;
-	}
-
-	if (octets < 4)
-		return 0;
-
-	memcpy(&dst->s_addr, tmp, 4);
-	return addr - cp;
-}
-
-static int c_str2ip(union pattern_data *data)
-{
-	if (!buf2ip(data->str.str, data->str.len, &data->ip))
-		return 0;
-	return 1;
-}
-
-static int c_int2str(union pattern_data *data)
-{
-	struct chunk *trash = get_trash_chunk();
-	char *pos;
-
-	pos = ultoa_r(data->integer, trash->str, trash->size);
-
-	if (!pos)
-		return 0;
-
-	trash->str = pos;
-	trash->len = strlen(pos);
-
-	pattern_data_setstring(data, trash);
-
-	return 1;
-}
-
-static int c_donothing(union pattern_data *data)
-{
-	return 1;
-}
-
-static int c_str2int(union pattern_data *data)
-{
-	int i;
-	uint32_t ret = 0;
-
-	for (i = 0; i < data->str.len; i++) {
-		uint32_t val = data->str.str[i] - '0';
-
-		if (val > 9)
-			break;
-
-		ret = ret * 10 + val;
-	}
-
-	data->integer = ret;
-	return 1;
-}
-
-/*****************************************************************/
-/*      Pattern casts matrix:                                    */
-/*           pattern_casts[from type][to type]                   */
-/*           NULL pointer used for impossible pattern casts      */
-/*****************************************************************/
-
-typedef int (*pattern_cast)(union pattern_data *data);
-static pattern_cast pattern_casts[PATTERN_TYPES][PATTERN_TYPES] = { { c_donothing, c_ip2int, c_ip2str  },
-								    { c_int2ip, c_donothing, c_int2str },
-								    { c_str2ip, c_str2int, c_donothing } };
-
-
-/*****************************************************************/
-/*    typed pattern to typed table key functions                 */
-/*****************************************************************/
-
-static void *k_int2int(union pattern_data *pdata, union stktable_key_data *kdata, size_t *len)
-{
-	return (void *)&pdata->integer;
-}
-
-static void *k_ip2ip(union pattern_data *pdata, union stktable_key_data *kdata, size_t *len)
-{
-	return (void *)&pdata->ip.s_addr;
-}
-
-static void *k_ip2int(union pattern_data *pdata, union stktable_key_data *kdata, size_t *len)
-{
-	kdata->integer = ntohl(pdata->ip.s_addr);
-	return (void *)&kdata->integer;
-}
-
-static void *k_int2ip(union pattern_data *pdata, union stktable_key_data *kdata, size_t *len)
-{
-	kdata->ip.s_addr = htonl(pdata->integer);
-	return (void *)&kdata->ip.s_addr;
-}
-
-static void *k_str2str(union pattern_data *pdata, union stktable_key_data *kdata, size_t *len)
-{
-	*len = pdata->str.len;
-	return (void *)pdata->str.str;
-}
-
-static void *k_ip2str(union pattern_data *pdata, union stktable_key_data *kdata, size_t *len)
-{
-	if (!inet_ntop(AF_INET, &pdata->ip, kdata->buf, sizeof(kdata->buf)))
-		return NULL;
-
-	*len = strlen((const char *)kdata->buf);
-	return (void *)kdata->buf;
-}
-
-static void *k_int2str(union pattern_data *pdata, union stktable_key_data *kdata, size_t *len)
-{
-	void *key;
-
-	key = (void *)ultoa_r(pdata->integer,  kdata->buf,  sizeof(kdata->buf));
-	if (!key)
-		return NULL;
-
-	*len = strlen((const char *)key);
-	return key;
-}
-
-static void *k_str2ip(union pattern_data *pdata, union stktable_key_data *kdata, size_t *len)
-{
-	if (!buf2ip(pdata->str.str, pdata->str.len, &kdata->ip))
-		return NULL;
-
-	return (void *)&kdata->ip.s_addr;
-}
-
-
-static void *k_str2int(union pattern_data *pdata, union stktable_key_data *kdata, size_t *len)
-{
-	int i;
-
-	kdata->integer = 0;
-	for (i = 0; i < pdata->str.len; i++) {
-		uint32_t val = pdata->str.str[i] - '0';
-
-		if (val > 9)
-			break;
-
-		kdata->integer = kdata->integer * 10 + val;
-	}
-	return (void *)&kdata->integer;
-}
-
-/*****************************************************************/
-/*      typed pattern to typed table key matrix:                 */
-/*           pattern_keys[from pattern type][to table key type]  */
-/*           NULL pointer used for impossible pattern casts      */
-/*****************************************************************/
-
-typedef void *(*pattern_key)(union pattern_data *pdata, union stktable_key_data *kdata, size_t *len);
-static pattern_key pattern_keys[PATTERN_TYPES][STKTABLE_TYPES] = { { k_ip2ip,  k_ip2int,  k_ip2str  },
-                                                                   { k_int2ip, k_int2int, k_int2str },
-                                                                   { k_str2ip, k_str2int, k_str2str } };
-/*
- * Parse a pattern expression configuration:
- *        fetch keyword followed by format conversion keywords.
- * Returns a pointer on allocated pattern expression structure.
- */
-struct pattern_expr *pattern_parse_expr(char **str, int *idx)
-{
-	const char *endw;
-	const char *end;
-	struct pattern_expr *expr;
-	struct pattern_fetch *fetch;
-	struct pattern_conv *conv;
-	unsigned long prev_type;
-
-	if (!str[*idx])
-		goto out_error;
-
-	end = str[*idx] + strlen(str[*idx]);
-	endw = strchr(str[*idx], '(');
-
-	if (!endw)
-		endw = end;
-	else if ((end-1)[0] != ')')
-		goto out_error;
-
-	fetch = find_pattern_fetch(str[*idx], endw - str[*idx]);
-	if (!fetch)
-		goto out_error;
-
-	if (fetch->out_type >= PATTERN_TYPES)
-		goto out_error;
-
-	prev_type = fetch->out_type;
-	expr = calloc(1, sizeof(struct pattern_expr));
-
-	LIST_INIT(&(expr->conv_exprs));
-	expr->fetch = fetch;
-
-	if (end != endw) {
-		expr->arg_len = end - endw - 2;
-		expr->arg = my_strndup(endw + 1, expr->arg_len);
-	}
-
-	for (*idx += 1; *(str[*idx]); (*idx)++) {
-		struct pattern_conv_expr *conv_expr;
-
-		end = str[*idx] + strlen(str[*idx]);
-		endw = strchr(str[*idx], '(');
-
-		if (!endw)
-			endw = end;
-		else if ((end-1)[0] != ')')
-			goto out_error;
-
-		conv = find_pattern_conv(str[*idx], endw - str[*idx]);
-		if (!conv)
-			break;
-
-		if (conv->in_type >= PATTERN_TYPES ||
-		    conv->out_type >= PATTERN_TYPES)
-			goto out_error;
-
-		/* If impossible type conversion */
-		if (!pattern_casts[prev_type][conv->in_type])
-			goto out_error;
-
-		prev_type = conv->out_type;
-		conv_expr = calloc(1, sizeof(struct pattern_conv_expr));
-
-		LIST_ADDQ(&(expr->conv_exprs), &(conv_expr->list));
-		conv_expr->conv = conv;
-
-		if (end != endw) {
-			int i = end - endw - 2;
-			char *p = my_strndup(endw + 1, i);
-
-			if (conv->parse_args) {
-				i = conv->parse_args(p, &conv_expr->arg_p, &conv_expr->arg_i);
-				free(p);
-				if (!i)
-					goto out_error;
-			} else {
-				conv_expr->arg_i = i;
-				conv_expr->arg_p = p;
-			}
-		}
-	}
-	return expr;
-
-out_error:
-	/* TODO: prune_pattern_expr(expr); */
-	return NULL;
-}
-
-/*
- * Process a fetch + format conversion of defined by the pattern expression <expr>
- * on request or response considering the <dir> parameter.
- * Returns a pointer on a typed pattern structure containing the result or NULL if
- * pattern is not found or when format conversion failed.
- *  If <p> is not null, function returns results in structure pointed by <p>.
- *  If <p> is null, functions returns a pointer on a static pattern structure.
- */
-struct pattern *pattern_process(struct proxy *px, struct session *l4, void *l7, int dir,
-                                struct pattern_expr *expr, struct pattern *p)
-{
-	struct pattern_conv_expr *conv_expr;
-
-	if (p == NULL)
-		p = &spattern;
-
-	if (!expr->fetch->process(px, l4, l7, dir, expr->arg, expr->arg_len, &p->data))
-		return NULL;
-
-	p->type = expr->fetch->out_type;
-
-	list_for_each_entry(conv_expr, &expr->conv_exprs, list) {
-		if (!pattern_casts[p->type][conv_expr->conv->in_type](&p->data))
-			return NULL;
-
-		p->type = conv_expr->conv->in_type;
-		if (!conv_expr->conv->process(conv_expr->arg_p, conv_expr->arg_i, &p->data))
-			return NULL;
-
-		p->type = conv_expr->conv->out_type;
-	}
-	return p;
-}
-
-/*
- *  Process a fetch + format conversion of defined by the pattern expression <expr>
- *  on request or response considering the <dir> parameter.
- *  Returns a pointer on a static tablekey  structure of type <table_type> of
- *  the converted result.
- */
-struct stktable_key *pattern_process_key(struct proxy *px, struct session *l4, void *l7, int dir,
-                                         struct pattern_expr *expr, unsigned long table_type)
-{
-	struct pattern *ptrn;
-
-	ptrn = pattern_process(px, l4, l7, dir, expr, NULL);
-	if (!ptrn)
-		return NULL;
-
-	stable_key.key_len = (size_t)-1;
-	stable_key.key = pattern_keys[ptrn->type][table_type](&ptrn->data, &stable_key.data, &stable_key.key_len);
-
-	if (!stable_key.key)
-		return NULL;
-
-	return &stable_key;
-}
-
-/*
- * Returns 1 if pattern expression <expr> result cannot be converted to table key of
- * type <table_type> .
- *
- * Used in configuration check
- */
-int pattern_notusable_key(struct pattern_expr *expr, unsigned long table_type)
-{
-
-	if (table_type >= STKTABLE_TYPES)
-		return 1;
-
-	if (LIST_ISEMPTY(&expr->conv_exprs)) {
-		if (!pattern_keys[expr->fetch->out_type][table_type])
-			return 1;
-	} else {
-		struct pattern_conv_expr *conv_expr;
-		conv_expr = LIST_PREV(&expr->conv_exprs, typeof(conv_expr), list);
-
-		if (!pattern_keys[conv_expr->conv->out_type][table_type])
-			return 1;
-	}
-	return 0;
-}
-
-/* Converts an argument string to an IPv4 mask stored in network byte order in
- * arg_i. Returns non-zero in case of success, 0 on error.
- */
-static int pattern_conv_arg_to_ipmask(const char *arg_str, void **arg_p, int *arg_i)
-{
-	struct in_addr mask;
-
-	if (!str2mask(arg_str, &mask))
-		return 0;
-
-	*arg_i = mask.s_addr;
-	return 1;
-}
-
-/*****************************************************************/
-/*    Pattern format convert functions                           */
-/*****************************************************************/
-
-static int pattern_conv_str2lower(const void *arg_p, int arg_i, union pattern_data *data)
-{
-	int i;
-
-	for (i = 0; i < data->str.len; i++) {
-		if ((data->str.str[i] >= 'A') && (data->str.str[i] <= 'Z'))
-			data->str.str[i] += 'a' - 'A';
-	}
-	return 1;
-}
-
-static int pattern_conv_str2upper(const void *arg_p, int arg_i, union pattern_data *data)
-{
-	int i;
-
-	for (i = 0; i < data->str.len; i++) {
-		if ((data->str.str[i] >= 'a') && (data->str.str[i] <= 'z'))
-			data->str.str[i] += 'A' - 'a';
-	}
-	return 1;
-}
-
-/* takes the netmask in arg_i */
-static int pattern_conv_ipmask(const void *arg_p, int arg_i, union pattern_data *data)
-{
-	data->ip.s_addr &= arg_i;
-	return 1;
-}
-
-/* Note: must not be declared <const> as its list will be overwritten */
-static struct pattern_conv_kw_list pattern_conv_kws = {{ },{
-	{ "upper",       pattern_conv_str2upper, PATTERN_TYPE_STRING, PATTERN_TYPE_STRING },
-	{ "lower",       pattern_conv_str2lower, PATTERN_TYPE_STRING, PATTERN_TYPE_STRING },
-	{ "ipmask",      pattern_conv_ipmask, PATTERN_TYPE_IP, PATTERN_TYPE_IP, pattern_conv_arg_to_ipmask },
-	{ NULL, NULL, 0, 0 },
-}};
-
-__attribute__((constructor))
-static void __pattern_init(void)
-{
-	/* register pattern format convert keywords */
-	pattern_register_convs(&pattern_conv_kws);
-}
diff --git a/deps/haproxy-1.4.21/src/pipe.c b/deps/haproxy-1.4.21/src/pipe.c
deleted file mode 100644
index ee6c92c..0000000
--- a/deps/haproxy-1.4.21/src/pipe.c
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Pipe management
- *
- * Copyright 2000-2009 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <unistd.h>
-
-#include <common/config.h>
-#include <common/memory.h>
-
-#include <types/global.h>
-#include <types/pipe.h>
-
-struct pool_head *pool2_pipe = NULL;
-struct pipe *pipes_live = NULL; /* pipes which are still ready to use */
-int pipes_used = 0;             /* # of pipes in use (2 fds each) */
-int pipes_free = 0;             /* # of pipes unused */
-
-/* allocate memory for the pipes */
-static void init_pipe()
-{
-	pool2_pipe = create_pool("pipe", sizeof(struct pipe), MEM_F_SHARED);
-	pipes_used = 0;
-	pipes_free = 0;
-}
-
-/* return a pre-allocated empty pipe. Try to allocate one if there isn't any
- * left. NULL is returned if a pipe could not be allocated.
- */
-struct pipe *get_pipe()
-{
-	struct pipe *ret;
-	int pipefd[2];
-
-	if (likely(pipes_live)) {
-		ret = pipes_live;
-		pipes_live = pipes_live->next;
-		pipes_free--;
-		pipes_used++;
-		return ret;
-	}
-
-	if (pipes_used >= global.maxpipes)
-		return NULL;
-
-	ret = pool_alloc2(pool2_pipe);
-	if (!ret)
-		return NULL;
-
-	if (pipe(pipefd) < 0) {
-		pool_free2(pool2_pipe, ret);
-		return NULL;
-	}
-	ret->data = 0;
-	ret->prod = pipefd[1];
-	ret->cons = pipefd[0];
-	ret->next = NULL;
-	pipes_used++;
-	return ret;
-}
-
-/* destroy a pipe, possibly because an error was encountered on it. Its FDs
- * will be closed and it will not be reinjected into the live pool.
- */
-void kill_pipe(struct pipe *p)
-{
-	close(p->prod);
-	close(p->cons);
-	pool_free2(pool2_pipe, p);
-	pipes_used--;
-	return;
-}
-
-/* put back a unused pipe into the live pool. If it still has data in it, it is
- * closed and not reinjected into the live pool. The caller is not allowed to
- * use it once released.
- */
-void put_pipe(struct pipe *p)
-{
-	if (p->data) {
-		kill_pipe(p);
-		return;
-	}
-	p->next = pipes_live;
-	pipes_live = p;
-	pipes_free++;
-	pipes_used--;
-}
-
-
-__attribute__((constructor))
-static void __pipe_module_init(void)
-{
-	init_pipe();
-}
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/proto_http.c b/deps/haproxy-1.4.21/src/proto_http.c
deleted file mode 100644
index e22cb03..0000000
--- a/deps/haproxy-1.4.21/src/proto_http.c
+++ /dev/null
@@ -1,8426 +0,0 @@
-/*
- * HTTP protocol analyzer
- *
- * Copyright 2000-2010 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <ctype.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <syslog.h>
-#include <time.h>
-
-#include <sys/socket.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-
-#include <netinet/tcp.h>
-
-#include <common/appsession.h>
-#include <common/base64.h>
-#include <common/compat.h>
-#include <common/config.h>
-#include <common/debug.h>
-#include <common/memory.h>
-#include <common/mini-clist.h>
-#include <common/standard.h>
-#include <common/ticks.h>
-#include <common/time.h>
-#include <common/uri_auth.h>
-#include <common/version.h>
-
-#include <types/capture.h>
-#include <types/global.h>
-
-#include <proto/acl.h>
-#include <proto/auth.h>
-#include <proto/backend.h>
-#include <proto/buffers.h>
-#include <proto/checks.h>
-#include <proto/client.h>
-#include <proto/dumpstats.h>
-#include <proto/fd.h>
-#include <proto/log.h>
-#include <proto/hdr_idx.h>
-#include <proto/pattern.h>
-#include <proto/proto_tcp.h>
-#include <proto/proto_http.h>
-#include <proto/proxy.h>
-#include <proto/queue.h>
-#include <proto/server.h>
-#include <proto/session.h>
-#include <proto/stream_interface.h>
-#include <proto/stream_sock.h>
-#include <proto/task.h>
-
-const char HTTP_100[] =
-	"HTTP/1.1 100 Continue\r\n\r\n";
-
-const struct chunk http_100_chunk = {
-	.str = (char *)&HTTP_100,
-	.len = sizeof(HTTP_100)-1
-};
-
-/* Warning: no "connection" header is provided with the 3xx messages below */
-const char *HTTP_301 =
-	"HTTP/1.1 301 Moved Permanently\r\n"
-	"Cache-Control: no-cache\r\n"
-	"Content-length: 0\r\n"
-	"Location: "; /* not terminated since it will be concatenated with the URL */
-
-const char *HTTP_302 =
-	"HTTP/1.1 302 Found\r\n"
-	"Cache-Control: no-cache\r\n"
-	"Content-length: 0\r\n"
-	"Location: "; /* not terminated since it will be concatenated with the URL */
-
-/* same as 302 except that the browser MUST retry with the GET method */
-const char *HTTP_303 =
-	"HTTP/1.1 303 See Other\r\n"
-	"Cache-Control: no-cache\r\n"
-	"Content-length: 0\r\n"
-	"Location: "; /* not terminated since it will be concatenated with the URL */
-
-/* Warning: this one is an sprintf() fmt string, with <realm> as its only argument */
-const char *HTTP_401_fmt =
-	"HTTP/1.0 401 Unauthorized\r\n"
-	"Cache-Control: no-cache\r\n"
-	"Connection: close\r\n"
-	"Content-Type: text/html\r\n"
-	"WWW-Authenticate: Basic realm=\"%s\"\r\n"
-	"\r\n"
-	"<html><body><h1>401 Unauthorized</h1>\nYou need a valid user and password to access this content.\n</body></html>\n";
-
-const char *HTTP_407_fmt =
-	"HTTP/1.0 407 Unauthorized\r\n"
-	"Cache-Control: no-cache\r\n"
-	"Connection: close\r\n"
-	"Content-Type: text/html\r\n"
-	"Proxy-Authenticate: Basic realm=\"%s\"\r\n"
-	"\r\n"
-	"<html><body><h1>401 Unauthorized</h1>\nYou need a valid user and password to access this content.\n</body></html>\n";
-
-
-const int http_err_codes[HTTP_ERR_SIZE] = {
-	[HTTP_ERR_200] = 200,  /* used by "monitor-uri" */
-	[HTTP_ERR_400] = 400,
-	[HTTP_ERR_403] = 403,
-	[HTTP_ERR_408] = 408,
-	[HTTP_ERR_500] = 500,
-	[HTTP_ERR_502] = 502,
-	[HTTP_ERR_503] = 503,
-	[HTTP_ERR_504] = 504,
-};
-
-static const char *http_err_msgs[HTTP_ERR_SIZE] = {
-	[HTTP_ERR_200] =
-	"HTTP/1.0 200 OK\r\n"
-	"Cache-Control: no-cache\r\n"
-	"Connection: close\r\n"
-	"Content-Type: text/html\r\n"
-	"\r\n"
-	"<html><body><h1>200 OK</h1>\nHAProxy: service ready.\n</body></html>\n",
-
-	[HTTP_ERR_400] =
-	"HTTP/1.0 400 Bad request\r\n"
-	"Cache-Control: no-cache\r\n"
-	"Connection: close\r\n"
-	"Content-Type: text/html\r\n"
-	"\r\n"
-	"<html><body><h1>400 Bad request</h1>\nYour browser sent an invalid request.\n</body></html>\n",
-
-	[HTTP_ERR_403] =
-	"HTTP/1.0 403 Forbidden\r\n"
-	"Cache-Control: no-cache\r\n"
-	"Connection: close\r\n"
-	"Content-Type: text/html\r\n"
-	"\r\n"
-	"<html><body><h1>403 Forbidden</h1>\nRequest forbidden by administrative rules.\n</body></html>\n",
-
-	[HTTP_ERR_408] =
-	"HTTP/1.0 408 Request Time-out\r\n"
-	"Cache-Control: no-cache\r\n"
-	"Connection: close\r\n"
-	"Content-Type: text/html\r\n"
-	"\r\n"
-	"<html><body><h1>408 Request Time-out</h1>\nYour browser didn't send a complete request in time.\n</body></html>\n",
-
-	[HTTP_ERR_500] =
-	"HTTP/1.0 500 Server Error\r\n"
-	"Cache-Control: no-cache\r\n"
-	"Connection: close\r\n"
-	"Content-Type: text/html\r\n"
-	"\r\n"
-	"<html><body><h1>500 Server Error</h1>\nAn internal server error occured.\n</body></html>\n",
-
-	[HTTP_ERR_502] =
-	"HTTP/1.0 502 Bad Gateway\r\n"
-	"Cache-Control: no-cache\r\n"
-	"Connection: close\r\n"
-	"Content-Type: text/html\r\n"
-	"\r\n"
-	"<html><body><h1>502 Bad Gateway</h1>\nThe server returned an invalid or incomplete response.\n</body></html>\n",
-
-	[HTTP_ERR_503] =
-	"HTTP/1.0 503 Service Unavailable\r\n"
-	"Cache-Control: no-cache\r\n"
-	"Connection: close\r\n"
-	"Content-Type: text/html\r\n"
-	"\r\n"
-	"<html><body><h1>503 Service Unavailable</h1>\nNo server is available to handle this request.\n</body></html>\n",
-
-	[HTTP_ERR_504] =
-	"HTTP/1.0 504 Gateway Time-out\r\n"
-	"Cache-Control: no-cache\r\n"
-	"Connection: close\r\n"
-	"Content-Type: text/html\r\n"
-	"\r\n"
-	"<html><body><h1>504 Gateway Time-out</h1>\nThe server didn't respond in time.\n</body></html>\n",
-
-};
-
-/* We must put the messages here since GCC cannot initialize consts depending
- * on strlen().
- */
-struct chunk http_err_chunks[HTTP_ERR_SIZE];
-
-#define FD_SETS_ARE_BITFIELDS
-#ifdef FD_SETS_ARE_BITFIELDS
-/*
- * This map is used with all the FD_* macros to check whether a particular bit
- * is set or not. Each bit represents an ACSII code. FD_SET() sets those bytes
- * which should be encoded. When FD_ISSET() returns non-zero, it means that the
- * byte should be encoded. Be careful to always pass bytes from 0 to 255
- * exclusively to the macros.
- */
-fd_set hdr_encode_map[(sizeof(fd_set) > (256/8)) ? 1 : ((256/8) / sizeof(fd_set))];
-fd_set url_encode_map[(sizeof(fd_set) > (256/8)) ? 1 : ((256/8) / sizeof(fd_set))];
-
-#else
-#error "Check if your OS uses bitfields for fd_sets"
-#endif
-
-void init_proto_http()
-{
-	int i;
-	char *tmp;
-	int msg;
-
-	for (msg = 0; msg < HTTP_ERR_SIZE; msg++) {
-		if (!http_err_msgs[msg]) {
-			Alert("Internal error: no message defined for HTTP return code %d. Aborting.\n", msg);
-			abort();
-		}
-
-		http_err_chunks[msg].str = (char *)http_err_msgs[msg];
-		http_err_chunks[msg].len = strlen(http_err_msgs[msg]);
-	}
-
-	/* initialize the log header encoding map : '{|}"#' should be encoded with
-	 * '#' as prefix, as well as non-printable characters ( <32 or >= 127 ).
-	 * URL encoding only requires '"', '#' to be encoded as well as non-
-	 * printable characters above.
-	 */
-	memset(hdr_encode_map, 0, sizeof(hdr_encode_map));
-	memset(url_encode_map, 0, sizeof(url_encode_map));
-	for (i = 0; i < 32; i++) {
-		FD_SET(i, hdr_encode_map);
-		FD_SET(i, url_encode_map);
-	}
-	for (i = 127; i < 256; i++) {
-		FD_SET(i, hdr_encode_map);
-		FD_SET(i, url_encode_map);
-	}
-
-	tmp = "\"#{|}";
-	while (*tmp) {
-		FD_SET(*tmp, hdr_encode_map);
-		tmp++;
-	}
-
-	tmp = "\"#";
-	while (*tmp) {
-		FD_SET(*tmp, url_encode_map);
-		tmp++;
-	}
-
-	/* memory allocations */
-	pool2_requri = create_pool("requri", REQURI_LEN, MEM_F_SHARED);
-	pool2_capture = create_pool("capture", CAPTURE_LEN, MEM_F_SHARED);
-}
-
-/*
- * We have 26 list of methods (1 per first letter), each of which can have
- * up to 3 entries (2 valid, 1 null).
- */
-struct http_method_desc {
-	http_meth_t meth;
-	int len;
-	const char text[8];
-};
-
-const struct http_method_desc http_methods[26][3] = {
-	['C' - 'A'] = {
-		[0] = {	.meth = HTTP_METH_CONNECT , .len=7, .text="CONNECT" },
-	},
-	['D' - 'A'] = {
-		[0] = {	.meth = HTTP_METH_DELETE  , .len=6, .text="DELETE"  },
-	},
-	['G' - 'A'] = {
-		[0] = {	.meth = HTTP_METH_GET     , .len=3, .text="GET"     },
-	},
-	['H' - 'A'] = {
-		[0] = {	.meth = HTTP_METH_HEAD    , .len=4, .text="HEAD"    },
-	},
-	['P' - 'A'] = {
-		[0] = {	.meth = HTTP_METH_POST    , .len=4, .text="POST"    },
-		[1] = {	.meth = HTTP_METH_PUT     , .len=3, .text="PUT"     },
-	},
-	['T' - 'A'] = {
-		[0] = {	.meth = HTTP_METH_TRACE   , .len=5, .text="TRACE"   },
-	},
-	/* rest is empty like this :
-	 *      [1] = {	.meth = HTTP_METH_NONE    , .len=0, .text=""        },
-	 */
-};
-
-/* It is about twice as fast on recent architectures to lookup a byte in a
- * table than to perform a boolean AND or OR between two tests. Refer to
- * RFC2616 for those chars.
- */
-
-const char http_is_spht[256] = {
-	[' '] = 1, ['\t'] = 1,
-};
-
-const char http_is_crlf[256] = {
-	['\r'] = 1, ['\n'] = 1,
-};
-
-const char http_is_lws[256] = {
-	[' '] = 1, ['\t'] = 1,
-	['\r'] = 1, ['\n'] = 1,
-};
-
-const char http_is_sep[256] = {
-	['('] = 1, [')']  = 1, ['<']  = 1, ['>'] = 1,
-	['@'] = 1, [',']  = 1, [';']  = 1, [':'] = 1,
-	['"'] = 1, ['/']  = 1, ['[']  = 1, [']'] = 1,
-	['{'] = 1, ['}']  = 1, ['?']  = 1, ['='] = 1,
-	[' '] = 1, ['\t'] = 1, ['\\'] = 1,
-};
-
-const char http_is_ctl[256] = {
-	[0 ... 31] = 1,
-	[127] = 1,
-};
-
-/*
- * A token is any ASCII char that is neither a separator nor a CTL char.
- * Do not overwrite values in assignment since gcc-2.95 will not handle
- * them correctly. Instead, define every non-CTL char's status.
- */
-const char http_is_token[256] = {
-	[' '] = 0, ['!'] = 1, ['"'] = 0, ['#'] = 1,
-	['$'] = 1, ['%'] = 1, ['&'] = 1, ['\''] = 1,
-	['('] = 0, [')'] = 0, ['*'] = 1, ['+'] = 1,
-	[','] = 0, ['-'] = 1, ['.'] = 1, ['/'] = 0,
-	['0'] = 1, ['1'] = 1, ['2'] = 1, ['3'] = 1,
-	['4'] = 1, ['5'] = 1, ['6'] = 1, ['7'] = 1,
-	['8'] = 1, ['9'] = 1, [':'] = 0, [';'] = 0,
-	['<'] = 0, ['='] = 0, ['>'] = 0, ['?'] = 0,
-	['@'] = 0, ['A'] = 1, ['B'] = 1, ['C'] = 1,
-	['D'] = 1, ['E'] = 1, ['F'] = 1, ['G'] = 1,
-	['H'] = 1, ['I'] = 1, ['J'] = 1, ['K'] = 1,
-	['L'] = 1, ['M'] = 1, ['N'] = 1, ['O'] = 1,
-	['P'] = 1, ['Q'] = 1, ['R'] = 1, ['S'] = 1,
-	['T'] = 1, ['U'] = 1, ['V'] = 1, ['W'] = 1,
-	['X'] = 1, ['Y'] = 1, ['Z'] = 1, ['['] = 0,
-	['\\'] = 0, [']'] = 0, ['^'] = 1, ['_'] = 1,
-	['`'] = 1, ['a'] = 1, ['b'] = 1, ['c'] = 1,
-	['d'] = 1, ['e'] = 1, ['f'] = 1, ['g'] = 1,
-	['h'] = 1, ['i'] = 1, ['j'] = 1, ['k'] = 1,
-	['l'] = 1, ['m'] = 1, ['n'] = 1, ['o'] = 1,
-	['p'] = 1, ['q'] = 1, ['r'] = 1, ['s'] = 1,
-	['t'] = 1, ['u'] = 1, ['v'] = 1, ['w'] = 1,
-	['x'] = 1, ['y'] = 1, ['z'] = 1, ['{'] = 0,
-	['|'] = 1, ['}'] = 0, ['~'] = 1, 
-};
-
-
-/*
- * An http ver_token is any ASCII which can be found in an HTTP version,
- * which includes 'H', 'T', 'P', '/', '.' and any digit.
- */
-const char http_is_ver_token[256] = {
-	['.'] = 1, ['/'] = 1,
-	['0'] = 1, ['1'] = 1, ['2'] = 1, ['3'] = 1, ['4'] = 1,
-	['5'] = 1, ['6'] = 1, ['7'] = 1, ['8'] = 1, ['9'] = 1,
-	['H'] = 1, ['P'] = 1, ['T'] = 1,
-};
-
-
-/*
- * Silent debug that outputs only in strace, using fd #-1. Trash is modified.
- */
-#if defined(DEBUG_FSM)
-static void http_silent_debug(int line, struct session *s)
-{
-	int size = 0;
-	size += snprintf(trash + size, trashlen - size,
-			 "[%04d] req: p=%d(%d) s=%d bf=%08x an=%08x data=%p size=%d l=%d w=%p r=%p lr=%p sm=%d fw=%ld tf=%08x\n",
-			 line,
-			 s->si[0].state, s->si[0].fd, s->txn.req.msg_state, s->req->flags, s->req->analysers,
-			 s->req->data, s->req->size, s->req->l, s->req->w, s->req->r, s->req->lr, s->req->send_max, s->req->to_forward, s->txn.flags);
-	write(-1, trash, size);
-	size = 0;
-	size += snprintf(trash + size, trashlen - size,
-			 " %04d  rep: p=%d(%d) s=%d bf=%08x an=%08x data=%p size=%d l=%d w=%p r=%p lr=%p sm=%d fw=%ld\n",
-			 line,
-			 s->si[1].state, s->si[1].fd, s->txn.rsp.msg_state, s->rep->flags, s->rep->analysers,
-			 s->rep->data, s->rep->size, s->rep->l, s->rep->w, s->rep->r, s->rep->lr, s->rep->send_max, s->rep->to_forward);
-
-	write(-1, trash, size);
-}
-#else
-#define http_silent_debug(l,s)  do { } while (0)
-#endif
-
-/*
- * Adds a header and its CRLF at the tail of buffer <b>, just before the last
- * CRLF. Text length is measured first, so it cannot be NULL.
- * The header is also automatically added to the index <hdr_idx>, and the end
- * of headers is automatically adjusted. The number of bytes added is returned
- * on success, otherwise <0 is returned indicating an error.
- */
-int http_header_add_tail(struct buffer *b, struct http_msg *msg,
-			 struct hdr_idx *hdr_idx, const char *text)
-{
-	int bytes, len;
-
-	len = strlen(text);
-	bytes = buffer_insert_line2(b, b->data + msg->eoh, text, len);
-	if (!bytes)
-		return -1;
-	http_msg_move_end(msg, bytes);
-	return hdr_idx_add(len, 1, hdr_idx, hdr_idx->tail);
-}
-
-/*
- * Adds a header and its CRLF at the tail of buffer <b>, just before the last
- * CRLF. <len> bytes are copied, not counting the CRLF. If <text> is NULL, then
- * the buffer is only opened and the space reserved, but nothing is copied.
- * The header is also automatically added to the index <hdr_idx>, and the end
- * of headers is automatically adjusted. The number of bytes added is returned
- * on success, otherwise <0 is returned indicating an error.
- */
-int http_header_add_tail2(struct buffer *b, struct http_msg *msg,
-			 struct hdr_idx *hdr_idx, const char *text, int len)
-{
-	int bytes;
-
-	bytes = buffer_insert_line2(b, b->data + msg->eoh, text, len);
-	if (!bytes)
-		return -1;
-	http_msg_move_end(msg, bytes);
-	return hdr_idx_add(len, 1, hdr_idx, hdr_idx->tail);
-}
-
-/*
- * Checks if <hdr> is exactly <name> for <len> chars, and ends with a colon.
- * If so, returns the position of the first non-space character relative to
- * <hdr>, or <end>-<hdr> if not found before. If no value is found, it tries
- * to return a pointer to the place after the first space. Returns 0 if the
- * header name does not match. Checks are case-insensitive.
- */
-int http_header_match2(const char *hdr, const char *end,
-		       const char *name, int len)
-{
-	const char *val;
-
-	if (hdr + len >= end)
-		return 0;
-	if (hdr[len] != ':')
-		return 0;
-	if (strncasecmp(hdr, name, len) != 0)
-		return 0;
-	val = hdr + len + 1;
-	while (val < end && HTTP_IS_SPHT(*val))
-		val++;
-	if ((val >= end) && (len + 2 <= end - hdr))
-		return len + 2; /* we may replace starting from second space */
-	return val - hdr;
-}
-
-/* Find the end of the header value contained between <s> and <e>. See RFC2616,
- * par 2.2 for more information. Note that it requires a valid header to return
- * a valid result. This works for headers defined as comma-separated lists.
- */
-char *find_hdr_value_end(char *s, const char *e)
-{
-	int quoted, qdpair;
-
-	quoted = qdpair = 0;
-	for (; s < e; s++) {
-		if (qdpair)                    qdpair = 0;
-		else if (quoted) {
-			if (*s == '\\')        qdpair = 1;
-			else if (*s == '"')    quoted = 0;
-		}
-		else if (*s == '"')            quoted = 1;
-		else if (*s == ',')            return s;
-	}
-	return s;
-}
-
-/* Find the first or next occurrence of header <name> in message buffer <sol>
- * using headers index <idx>, and return it in the <ctx> structure. This
- * structure holds everything necessary to use the header and find next
- * occurrence. If its <idx> member is 0, the header is searched from the
- * beginning. Otherwise, the next occurrence is returned. The function returns
- * 1 when it finds a value, and 0 when there is no more. It is designed to work
- * with headers defined as comma-separated lists. As a special case, if ctx->val
- * is NULL when searching for a new values of a header, the current header is
- * rescanned. This allows rescanning after a header deletion.
- */
-int http_find_header2(const char *name, int len,
-		      char *sol, struct hdr_idx *idx,
-		      struct hdr_ctx *ctx)
-{
-	char *eol, *sov;
-	int cur_idx, old_idx;
-
-	cur_idx = ctx->idx;
-	if (cur_idx) {
-		/* We have previously returned a value, let's search
-		 * another one on the same line.
-		 */
-		sol = ctx->line;
-		ctx->del = ctx->val + ctx->vlen + ctx->tws;
-		sov = sol + ctx->del;
-		eol = sol + idx->v[cur_idx].len;
-
-		if (sov >= eol)
-			/* no more values in this header */
-			goto next_hdr;
-
-		/* values remaining for this header, skip the comma but save it
-		 * for later use (eg: for header deletion).
-		 */
-		sov++;
-		while (sov < eol && http_is_lws[(unsigned char)*sov])
-			sov++;
-
-		goto return_hdr;
-	}
-
-	/* first request for this header */
-	sol += hdr_idx_first_pos(idx);
-	old_idx = 0;
-	cur_idx = hdr_idx_first_idx(idx);
-	while (cur_idx) {
-		eol = sol + idx->v[cur_idx].len;
-
-		if (len == 0) {
-			/* No argument was passed, we want any header.
-			 * To achieve this, we simply build a fake request. */
-			while (sol + len < eol && sol[len] != ':')
-				len++;
-			name = sol;
-		}
-
-		if ((len < eol - sol) &&
-		    (sol[len] == ':') &&
-		    (strncasecmp(sol, name, len) == 0)) {
-			ctx->del = len;
-			sov = sol + len + 1;
-			while (sov < eol && http_is_lws[(unsigned char)*sov])
-				sov++;
-
-			ctx->line = sol;
-			ctx->prev = old_idx;
-		return_hdr:
-			ctx->idx  = cur_idx;
-			ctx->val  = sov - sol;
-
-			eol = find_hdr_value_end(sov, eol);
-			ctx->tws = 0;
-			while (eol > sov && http_is_lws[(unsigned char)*(eol - 1)]) {
-				eol--;
-				ctx->tws++;
-			}
-			ctx->vlen = eol - sov;
-			return 1;
-		}
-	next_hdr:
-		sol = eol + idx->v[cur_idx].cr + 1;
-		old_idx = cur_idx;
-		cur_idx = idx->v[cur_idx].next;
-	}
-	return 0;
-}
-
-int http_find_header(const char *name,
-		     char *sol, struct hdr_idx *idx,
-		     struct hdr_ctx *ctx)
-{
-	return http_find_header2(name, strlen(name), sol, idx, ctx);
-}
-
-/* Remove one value of a header. This only works on a <ctx> returned by one of
- * the http_find_header functions. The value is removed, as well as surrounding
- * commas if any. If the removed value was alone, the whole header is removed.
- * The ctx is always updated accordingly, as well as buffer <buf> and HTTP
- * message <msg>. The new index is returned. If it is zero, it means there is
- * no more header, so any processing may stop. The ctx is always left in a form
- * that can be handled by http_find_header2() to find next occurrence.
- */
-int http_remove_header2(struct http_msg *msg, struct buffer *buf,
-			struct hdr_idx *idx, struct hdr_ctx *ctx)
-{
-	int cur_idx = ctx->idx;
-	char *sol = ctx->line;
-	struct hdr_idx_elem *hdr;
-	int delta, skip_comma;
-
-	if (!cur_idx)
-		return 0;
-
-	hdr = &idx->v[cur_idx];
-	if (sol[ctx->del] == ':' && ctx->val + ctx->vlen + ctx->tws == hdr->len) {
-		/* This was the only value of the header, we must now remove it entirely. */
-		delta = buffer_replace2(buf, sol, sol + hdr->len + hdr->cr + 1, NULL, 0);
-		http_msg_move_end(msg, delta);
-		idx->used--;
-		hdr->len = 0;   /* unused entry */
-		idx->v[ctx->prev].next = idx->v[ctx->idx].next;
-		if (idx->tail == ctx->idx)
-			idx->tail = ctx->prev;
-		ctx->idx = ctx->prev;    /* walk back to the end of previous header */
-		ctx->line -= idx->v[ctx->idx].len + idx->v[cur_idx].cr + 1;
-		ctx->val = idx->v[ctx->idx].len; /* point to end of previous header */
-		ctx->tws = ctx->vlen = 0;
-		return ctx->idx;
-	}
-
-	/* This was not the only value of this header. We have to remove between
-	 * ctx->del+1 and ctx->val+ctx->vlen+ctx->tws+1 included. If it is the
-	 * last entry of the list, we remove the last separator.
-	 */
-
-	skip_comma = (ctx->val + ctx->vlen + ctx->tws == hdr->len) ? 0 : 1;
-	delta = buffer_replace2(buf, sol + ctx->del + skip_comma,
-				sol + ctx->val + ctx->vlen + ctx->tws + skip_comma,
-				NULL, 0);
-	hdr->len += delta;
-	http_msg_move_end(msg, delta);
-	ctx->val = ctx->del;
-	ctx->tws = ctx->vlen = 0;
-	return ctx->idx;
-}
-
-/* This function handles a server error at the stream interface level. The
- * stream interface is assumed to be already in a closed state. An optional
- * message is copied into the input buffer, and an HTTP status code stored.
- * The error flags are set to the values in arguments. Any pending request
- * in this buffer will be lost.
- */
-static void http_server_error(struct session *t, struct stream_interface *si,
-			      int err, int finst, int status, const struct chunk *msg)
-{
-	buffer_auto_read(si->ob);
-	buffer_abort(si->ob);
-	buffer_auto_close(si->ob);
-	buffer_erase(si->ob);
-	buffer_auto_close(si->ib);
-	buffer_auto_read(si->ib);
-	if (status > 0 && msg) {
-		t->txn.status = status;
-		buffer_write(si->ib, msg->str, msg->len);
-	}
-	if (!(t->flags & SN_ERR_MASK))
-		t->flags |= err;
-	if (!(t->flags & SN_FINST_MASK))
-		t->flags |= finst;
-}
-
-/* This function returns the appropriate error location for the given session
- * and message.
- */
-
-struct chunk *error_message(struct session *s, int msgnum)
-{
-	if (s->be->errmsg[msgnum].str)
-		return &s->be->errmsg[msgnum];
-	else if (s->fe->errmsg[msgnum].str)
-		return &s->fe->errmsg[msgnum];
-	else
-		return &http_err_chunks[msgnum];
-}
-
-/*
- * returns HTTP_METH_NONE if there is nothing valid to read (empty or non-text
- * string), HTTP_METH_OTHER for unknown methods, or the identified method.
- */
-static http_meth_t find_http_meth(const char *str, const int len)
-{
-	unsigned char m;
-	const struct http_method_desc *h;
-
-	m = ((unsigned)*str - 'A');
-
-	if (m < 26) {
-		for (h = http_methods[m]; h->len > 0; h++) {
-			if (unlikely(h->len != len))
-				continue;
-			if (likely(memcmp(str, h->text, h->len) == 0))
-				return h->meth;
-		};
-		return HTTP_METH_OTHER;
-	}
-	return HTTP_METH_NONE;
-
-}
-
-/* Parse the URI from the given transaction (which is assumed to be in request
- * phase) and look for the "/" beginning the PATH. If not found, return NULL.
- * It is returned otherwise.
- */
-static char *
-http_get_path(struct http_txn *txn)
-{
-	char *ptr, *end;
-
-	ptr = txn->req.sol + txn->req.sl.rq.u;
-	end = ptr + txn->req.sl.rq.u_l;
-
-	if (ptr >= end)
-		return NULL;
-
-	/* RFC2616, par. 5.1.2 :
-	 * Request-URI = "*" | absuri | abspath | authority
-	 */
-
-	if (*ptr == '*')
-		return NULL;
-
-	if (isalpha((unsigned char)*ptr)) {
-		/* this is a scheme as described by RFC3986, par. 3.1 */
-		ptr++;
-		while (ptr < end &&
-		       (isalnum((unsigned char)*ptr) || *ptr == '+' || *ptr == '-' || *ptr == '.'))
-			ptr++;
-		/* skip '://' */
-		if (ptr == end || *ptr++ != ':')
-			return NULL;
-		if (ptr == end || *ptr++ != '/')
-			return NULL;
-		if (ptr == end || *ptr++ != '/')
-			return NULL;
-	}
-	/* skip [user[:passwd]@]host[:[port]] */
-
-	while (ptr < end && *ptr != '/')
-		ptr++;
-
-	if (ptr == end)
-		return NULL;
-
-	/* OK, we got the '/' ! */
-	return ptr;
-}
-
-/* Returns a 302 for a redirectable request. This may only be called just after
- * the stream interface has moved to SI_ST_ASS. Unprocessable requests are
- * left unchanged and will follow normal proxy processing.
- */
-void perform_http_redirect(struct session *s, struct stream_interface *si)
-{
-	struct http_txn *txn;
-	struct chunk rdr;
-	char *path;
-	int len;
-
-	/* 1: create the response header */
-	rdr.len = strlen(HTTP_302);
-	rdr.str = trash;
-	rdr.size = trashlen;
-	memcpy(rdr.str, HTTP_302, rdr.len);
-
-	/* 2: add the server's prefix */
-	if (rdr.len + s->srv->rdr_len > rdr.size)
-		return;
-
-	/* special prefix "/" means don't change URL */
-	if (s->srv->rdr_len != 1 || *s->srv->rdr_pfx != '/') {
-		memcpy(rdr.str + rdr.len, s->srv->rdr_pfx, s->srv->rdr_len);
-		rdr.len += s->srv->rdr_len;
-	}
-
-	/* 3: add the request URI */
-	txn = &s->txn;
-	path = http_get_path(txn);
-	if (!path)
-		return;
-
-	len = txn->req.sl.rq.u_l + (txn->req.sol + txn->req.sl.rq.u) - path;
-	if (rdr.len + len > rdr.size - 4) /* 4 for CRLF-CRLF */
-		return;
-
-	memcpy(rdr.str + rdr.len, path, len);
-	rdr.len += len;
-
-	if (unlikely(txn->flags & TX_USE_PX_CONN)) {
-		memcpy(rdr.str + rdr.len, "\r\nProxy-Connection: close\r\n\r\n", 29);
-		rdr.len += 29;
-	} else {
-		memcpy(rdr.str + rdr.len, "\r\nConnection: close\r\n\r\n", 23);
-		rdr.len += 23;
-	}
-
-	/* prepare to return without error. */
-	si->shutr(si);
-	si->shutw(si);
-	si->err_type = SI_ET_NONE;
-	si->err_loc  = NULL;
-	si->state    = SI_ST_CLO;
-
-	/* send the message */
-	http_server_error(s, si, SN_ERR_PRXCOND, SN_FINST_C, 302, &rdr);
-
-	/* FIXME: we should increase a counter of redirects per server and per backend. */
-	if (s->srv)
-		srv_inc_sess_ctr(s->srv);
-}
-
-/* Return the error message corresponding to si->err_type. It is assumed
- * that the server side is closed. Note that err_type is actually a
- * bitmask, where almost only aborts may be cumulated with other
- * values. We consider that aborted operations are more important
- * than timeouts or errors due to the fact that nobody else in the
- * logs might explain incomplete retries. All others should avoid
- * being cumulated. It should normally not be possible to have multiple
- * aborts at once, but just in case, the first one in sequence is reported.
- */
-void http_return_srv_error(struct session *s, struct stream_interface *si)
-{
-	int err_type = si->err_type;
-
-	if (err_type & SI_ET_QUEUE_ABRT)
-		http_server_error(s, si, SN_ERR_CLICL, SN_FINST_Q,
-				  503, error_message(s, HTTP_ERR_503));
-	else if (err_type & SI_ET_CONN_ABRT)
-		http_server_error(s, si, SN_ERR_CLICL, SN_FINST_C,
-				  503, error_message(s, HTTP_ERR_503));
-	else if (err_type & SI_ET_QUEUE_TO)
-		http_server_error(s, si, SN_ERR_SRVTO, SN_FINST_Q,
-				  503, error_message(s, HTTP_ERR_503));
-	else if (err_type & SI_ET_QUEUE_ERR)
-		http_server_error(s, si, SN_ERR_SRVCL, SN_FINST_Q,
-				  503, error_message(s, HTTP_ERR_503));
-	else if (err_type & SI_ET_CONN_TO)
-		http_server_error(s, si, SN_ERR_SRVTO, SN_FINST_C,
-				  503, error_message(s, HTTP_ERR_503));
-	else if (err_type & SI_ET_CONN_ERR)
-		http_server_error(s, si, SN_ERR_SRVCL, SN_FINST_C,
-				  503, error_message(s, HTTP_ERR_503));
-	else /* SI_ET_CONN_OTHER and others */
-		http_server_error(s, si, SN_ERR_INTERNAL, SN_FINST_C,
-				  500, error_message(s, HTTP_ERR_500));
-}
-
-extern const char sess_term_cond[8];
-extern const char sess_fin_state[8];
-extern const char *monthname[12];
-const char sess_cookie[8]     = "NIDVEO67";	/* No cookie, Invalid cookie, cookie for a Down server, Valid cookie, Expired cookie, Old cookie, unknown */
-const char sess_set_cookie[8] = "NPDIRU67";	/* No set-cookie, Set-cookie found and left unchanged (passive),
-						   Set-cookie Deleted, Set-Cookie Inserted, Set-cookie Rewritten,
-						   Set-cookie Updated, unknown, unknown */
-struct pool_head *pool2_requri;
-struct pool_head *pool2_capture;
-
-void http_sess_clflog(struct session *s)
-{
-	char pn[INET6_ADDRSTRLEN + strlen(":65535")];
-	struct proxy *fe = s->fe;
-	struct proxy *be = s->be;
-	struct proxy *prx_log;
-	struct http_txn *txn = &s->txn;
-	int tolog, level, err;
-	char *uri, *h;
-	char *svid;
-	struct tm tm;
-	static char tmpline[MAX_SYSLOG_LEN];
-	int hdr;
-	size_t w;
-	int t_request;
-
-	prx_log = fe;
-	err = (s->flags & (SN_ERR_MASK | SN_REDISP)) ||
-		(s->conn_retries != be->conn_retries) ||
-		txn->status >= 500;
-
-	if (s->cli_addr.ss_family == AF_INET)
-		inet_ntop(AF_INET,
-		          (const void *)&((struct sockaddr_in *)&s->cli_addr)->sin_addr,
-		          pn, sizeof(pn));
-	else
-		inet_ntop(AF_INET6,
-		          (const void *)&((struct sockaddr_in6 *)(&s->cli_addr))->sin6_addr,
-		          pn, sizeof(pn));
-
-	get_gmtime(s->logs.accept_date.tv_sec, &tm);
-
-	/* FIXME: let's limit ourselves to frontend logging for now. */
-	tolog = fe->to_log;
-
-	h = tmpline;
-
-	w = snprintf(h, sizeof(tmpline),
-	             "%s - - [%02d/%s/%04d:%02d:%02d:%02d +0000]",
-	             pn,
-	             tm.tm_mday, monthname[tm.tm_mon], tm.tm_year+1900,
-	             tm.tm_hour, tm.tm_min, tm.tm_sec);
-	if (w < 0 || w >= sizeof(tmpline) - (h - tmpline))
-		goto trunc;
-	h += w;
-
-	if (h >= tmpline + sizeof(tmpline) - 4)
-		goto trunc;
-
-	*(h++) = ' ';
-	*(h++) = '\"';
-	uri = txn->uri ? txn->uri : "<BADREQ>";
-	h = encode_string(h, tmpline + sizeof(tmpline) - 1,
-	                  '#', url_encode_map, uri);
-	*(h++) = '\"';
-
-	w = snprintf(h, sizeof(tmpline) - (h - tmpline), " %d %lld", txn->status, s->logs.bytes_out);
-	if (w < 0 || w >= sizeof(tmpline) - (h - tmpline))
-		goto trunc;
-	h += w;
-
-	if (h >= tmpline + sizeof(tmpline) - 9)
-		goto trunc;
-	memcpy(h, " \"-\" \"-\"", 8);
-	h += 8;
-
-	w = snprintf(h, sizeof(tmpline) - (h - tmpline),
-	             " %d %03d",
-	             (s->cli_addr.ss_family == AF_INET) ?
-	             ntohs(((struct sockaddr_in *)&s->cli_addr)->sin_port) :
-	             ntohs(((struct sockaddr_in6 *)&s->cli_addr)->sin6_port),
-	             (int)s->logs.accept_date.tv_usec/1000);
-	if (w < 0 || w >= sizeof(tmpline) - (h - tmpline))
-		goto trunc;
-	h += w;
-
-	w = strlen(fe->id);
-	if (h >= tmpline + sizeof(tmpline) - 4 - w)
-		goto trunc;
-	*(h++) = ' ';
-	*(h++) = '\"';
-	memcpy(h, fe->id, w);
-	h += w;
-	*(h++) = '\"';
-
-	w = strlen(be->id);
-	if (h >= tmpline + sizeof(tmpline) - 4 - w)
-		goto trunc;
-	*(h++) = ' ';
-	*(h++) = '\"';
-	memcpy(h, be->id, w);
-	h += w;
-	*(h++) = '\"';
-
-	svid = (tolog & LW_SVID) ?
-		(s->data_source != DATA_SRC_STATS) ?
-		(s->srv != NULL) ? s->srv->id : "<NOSRV>" : "<STATS>" : "-";
-
-	w = strlen(svid);
-	if (h >= tmpline + sizeof(tmpline) - 4 - w)
-		goto trunc;
-	*(h++) = ' ';
-	*(h++) = '\"';
-	memcpy(h, svid, w);
-	h += w;
-	*(h++) = '\"';
-
-	t_request = -1;
-	if (tv_isge(&s->logs.tv_request, &s->logs.tv_accept))
-		t_request = tv_ms_elapsed(&s->logs.tv_accept, &s->logs.tv_request);
-	w = snprintf(h, sizeof(tmpline) - (h - tmpline),
-	             " %d %ld %ld %ld %ld",
-	             t_request,
-	             (s->logs.t_queue >= 0) ? s->logs.t_queue - t_request : -1,
-	             (s->logs.t_connect >= 0) ? s->logs.t_connect - s->logs.t_queue : -1,
-	             (s->logs.t_data >= 0) ? s->logs.t_data - s->logs.t_connect : -1,
-	             s->logs.t_close);
-	if (w < 0 || w >= sizeof(tmpline) - (h - tmpline))
-		goto trunc;
-	h += w;
-
-	if (h >= tmpline + sizeof(tmpline) - 8)
-		goto trunc;
-	*(h++) = ' ';
-	*(h++) = '\"';
-	*(h++) = sess_term_cond[(s->flags & SN_ERR_MASK) >> SN_ERR_SHIFT];
-	*(h++) = sess_fin_state[(s->flags & SN_FINST_MASK) >> SN_FINST_SHIFT];
-	*(h++) = (be->options & PR_O_COOK_ANY) ? sess_cookie[(txn->flags & TX_CK_MASK) >> TX_CK_SHIFT] : '-',
-	*(h++) = (be->options & PR_O_COOK_ANY) ? sess_set_cookie[(txn->flags & TX_SCK_MASK) >> TX_SCK_SHIFT] : '-';
-	*(h++) = '\"';
-
-	w = snprintf(h, sizeof(tmpline) - (h - tmpline),
-	             " %d %d %d %d %d %ld %ld",
-	             actconn, fe->feconn, be->beconn, s->srv ? s->srv->cur_sess : 0,
-	             (s->conn_retries > 0) ? (be->conn_retries - s->conn_retries) : be->conn_retries,
-	             s->logs.srv_queue_size, s->logs.prx_queue_size);
-
-	if (w < 0 || w >= sizeof(tmpline) - (h - tmpline))
-		goto trunc;
-	h += w;
-
-	if (txn->cli_cookie) {
-		w = strlen(txn->cli_cookie);
-		if (h >= tmpline + sizeof(tmpline) - 4 - w)
-			goto trunc;
-		*(h++) = ' ';
-		*(h++) = '\"';
-		memcpy(h, txn->cli_cookie, w);
-		h += w;
-		*(h++) = '\"';
-	} else {
-		if (h >= tmpline + sizeof(tmpline) - 5)
-			goto trunc;
-		memcpy(h, " \"-\"", 4);
-		h += 4;
-	}
-
-	if (txn->srv_cookie) {
-		w = strlen(txn->srv_cookie);
-		if (h >= tmpline + sizeof(tmpline) - 4 - w)
-			goto trunc;
-		*(h++) = ' ';
-		*(h++) = '\"';
-		memcpy(h, txn->srv_cookie, w);
-		h += w;
-		*(h++) = '\"';
-	} else {
-		if (h >= tmpline + sizeof(tmpline) - 5)
-			goto trunc;
-		memcpy(h, " \"-\"", 4);
-		h += 4;
-	}
-
-	if ((fe->to_log & LW_REQHDR) && txn->req.cap) {
-		for (hdr = 0; hdr < fe->nb_req_cap; hdr++) {
-			if (h >= sizeof (tmpline) + tmpline - 4)
-				goto trunc;
-			if (txn->req.cap[hdr] != NULL) {
-				*(h++) = ' ';
-				*(h++) = '\"';
-				h = encode_string(h, tmpline + sizeof(tmpline) - 2,
-						'#', hdr_encode_map, txn->req.cap[hdr]);
-				*(h++) = '\"';
-			} else {
-				memcpy(h, " \"-\"", 4);
-				h += 4;
-			}
-		}
-	}
-
-	if ((fe->to_log & LW_RSPHDR) && txn->rsp.cap) {
-		for (hdr = 0; hdr < fe->nb_rsp_cap; hdr++) {
-			if (h >= sizeof (tmpline) + tmpline - 4)
-				goto trunc;
-			if (txn->rsp.cap[hdr] != NULL) {
-				*(h++) = ' ';
-				*(h++) = '\"';
-				h = encode_string(h, tmpline + sizeof(tmpline) - 2,
-						'#', hdr_encode_map, txn->rsp.cap[hdr]);
-				*(h++) = '\"';
-			} else {
-				memcpy(h, " \"-\"", 4);
-				h += 4;
-			}
-		}
-	}
-
-trunc:
-	*h = '\0';
-
-	level = LOG_INFO;
-	if (err && (fe->options2 & PR_O2_LOGERRORS))
-		level = LOG_ERR;
-
-	send_log(prx_log, level, "%s\n", tmpline);
-
-	s->logs.logwait = 0;
-}
-
-/*
- * send a log for the session when we have enough info about it.
- * Will not log if the frontend has no log defined.
- */
-void http_sess_log(struct session *s)
-{
-	char pn[INET6_ADDRSTRLEN + strlen(":65535")];
-	struct proxy *fe = s->fe;
-	struct proxy *be = s->be;
-	struct proxy *prx_log;
-	struct http_txn *txn = &s->txn;
-	int tolog, level, err;
-	char *uri, *h;
-	char *svid;
-	struct tm tm;
-	static char tmpline[MAX_SYSLOG_LEN];
-	int t_request;
-	int hdr;
-
-	/* if we don't want to log normal traffic, return now */
-	err = (s->flags & (SN_ERR_MASK | SN_REDISP)) ||
-		(s->conn_retries != be->conn_retries) ||
-		txn->status >= 500;
-	if (!err && (fe->options2 & PR_O2_NOLOGNORM))
-		return;
-
-	if (fe->logfac1 < 0 && fe->logfac2 < 0)
-		return;
-	prx_log = fe;
-
-	if (prx_log->options2 & PR_O2_CLFLOG)
-		return http_sess_clflog(s);
-
-	if (s->cli_addr.ss_family == AF_INET)
-		inet_ntop(AF_INET,
-			  (const void *)&((struct sockaddr_in *)&s->cli_addr)->sin_addr,
-			  pn, sizeof(pn));
-	else
-		inet_ntop(AF_INET6,
-			  (const void *)&((struct sockaddr_in6 *)(&s->cli_addr))->sin6_addr,
-			  pn, sizeof(pn));
-
-	get_localtime(s->logs.accept_date.tv_sec, &tm);
-
-	/* FIXME: let's limit ourselves to frontend logging for now. */
-	tolog = fe->to_log;
-
-	h = tmpline;
-	if (fe->to_log & LW_REQHDR &&
-	    txn->req.cap &&
-	    (h < tmpline + sizeof(tmpline) - 10)) {
-		*(h++) = ' ';
-		*(h++) = '{';
-		for (hdr = 0; hdr < fe->nb_req_cap; hdr++) {
-			if (hdr)
-				*(h++) = '|';
-			if (txn->req.cap[hdr] != NULL)
-				h = encode_string(h, tmpline + sizeof(tmpline) - 7,
-						  '#', hdr_encode_map, txn->req.cap[hdr]);
-		}
-		*(h++) = '}';
-	}
-
-	if (fe->to_log & LW_RSPHDR &&
-	    txn->rsp.cap &&
-	    (h < tmpline + sizeof(tmpline) - 7)) {
-		*(h++) = ' ';
-		*(h++) = '{';
-		for (hdr = 0; hdr < fe->nb_rsp_cap; hdr++) {
-			if (hdr)
-				*(h++) = '|';
-			if (txn->rsp.cap[hdr] != NULL)
-				h = encode_string(h, tmpline + sizeof(tmpline) - 4,
-						  '#', hdr_encode_map, txn->rsp.cap[hdr]);
-		}
-		*(h++) = '}';
-	}
-
-	if (h < tmpline + sizeof(tmpline) - 4) {
-		*(h++) = ' ';
-		*(h++) = '"';
-		uri = txn->uri ? txn->uri : "<BADREQ>";
-		h = encode_string(h, tmpline + sizeof(tmpline) - 1,
-				  '#', url_encode_map, uri);
-		*(h++) = '"';
-	}
-	*h = '\0';
-
-	svid = (tolog & LW_SVID) ?
-		(s->data_source != DATA_SRC_STATS) ?
-		(s->srv != NULL) ? s->srv->id : "<NOSRV>" : "<STATS>" : "-";
-
-	t_request = -1;
-	if (tv_isge(&s->logs.tv_request, &s->logs.tv_accept))
-		t_request = tv_ms_elapsed(&s->logs.tv_accept, &s->logs.tv_request);
-
-	level = LOG_INFO;
-	if (err && (fe->options2 & PR_O2_LOGERRORS))
-		level = LOG_ERR;
-
-	send_log(prx_log, level,
-		 "%s:%d [%02d/%s/%04d:%02d:%02d:%02d.%03d]"
-		 " %s %s/%s %d/%ld/%ld/%ld/%s%ld %d %s%lld"
-		 " %s %s %c%c%c%c %d/%d/%d/%d/%s%u %ld/%ld%s\n",
-		 pn,
-		 (s->cli_addr.ss_family == AF_INET) ?
-		 ntohs(((struct sockaddr_in *)&s->cli_addr)->sin_port) :
-		 ntohs(((struct sockaddr_in6 *)&s->cli_addr)->sin6_port),
-		 tm.tm_mday, monthname[tm.tm_mon], tm.tm_year+1900,
-		 tm.tm_hour, tm.tm_min, tm.tm_sec, (int)s->logs.accept_date.tv_usec/1000,
-		 fe->id, be->id, svid,
-		 t_request,
-		 (s->logs.t_queue >= 0) ? s->logs.t_queue - t_request : -1,
-		 (s->logs.t_connect >= 0) ? s->logs.t_connect - s->logs.t_queue : -1,
-		 (s->logs.t_data >= 0) ? s->logs.t_data - s->logs.t_connect : -1,
-		 (tolog & LW_BYTES) ? "" : "+", s->logs.t_close,
-		 txn->status,
-		 (tolog & LW_BYTES) ? "" : "+", s->logs.bytes_out,
-		 txn->cli_cookie ? txn->cli_cookie : "-",
-		 txn->srv_cookie ? txn->srv_cookie : "-",
-		 sess_term_cond[(s->flags & SN_ERR_MASK) >> SN_ERR_SHIFT],
-		 sess_fin_state[(s->flags & SN_FINST_MASK) >> SN_FINST_SHIFT],
-		 (be->options & PR_O_COOK_ANY) ? sess_cookie[(txn->flags & TX_CK_MASK) >> TX_CK_SHIFT] : '-',
-		 (be->options & PR_O_COOK_ANY) ? sess_set_cookie[(txn->flags & TX_SCK_MASK) >> TX_SCK_SHIFT] : '-',
-		 actconn, fe->feconn, be->beconn, s->srv ? s->srv->cur_sess : 0,
-		 (s->flags & SN_REDISP)?"+":"",
-		 (s->conn_retries>0)?(be->conn_retries - s->conn_retries):be->conn_retries,
-		 s->logs.srv_queue_size, s->logs.prx_queue_size, tmpline);
-
-	s->logs.logwait = 0;
-}
-
-
-/*
- * Capture headers from message starting at <som> according to header list
- * <cap_hdr>, and fill the <idx> structure appropriately.
- */
-void capture_headers(char *som, struct hdr_idx *idx,
-		     char **cap, struct cap_hdr *cap_hdr)
-{
-	char *eol, *sol, *col, *sov;
-	int cur_idx;
-	struct cap_hdr *h;
-	int len;
-
-	sol = som + hdr_idx_first_pos(idx);
-	cur_idx = hdr_idx_first_idx(idx);
-
-	while (cur_idx) {
-		eol = sol + idx->v[cur_idx].len;
-
-		col = sol;
-		while (col < eol && *col != ':')
-			col++;
-
-		sov = col + 1;
-		while (sov < eol && http_is_lws[(unsigned char)*sov])
-			sov++;
-				
-		for (h = cap_hdr; h; h = h->next) {
-			if ((h->namelen == col - sol) &&
-			    (strncasecmp(sol, h->name, h->namelen) == 0)) {
-				if (cap[h->index] == NULL)
-					cap[h->index] =
-						pool_alloc2(h->pool);
-
-				if (cap[h->index] == NULL) {
-					Alert("HTTP capture : out of memory.\n");
-					continue;
-				}
-							
-				len = eol - sov;
-				if (len > h->len)
-					len = h->len;
-							
-				memcpy(cap[h->index], sov, len);
-				cap[h->index][len]=0;
-			}
-		}
-		sol = eol + idx->v[cur_idx].cr + 1;
-		cur_idx = idx->v[cur_idx].next;
-	}
-}
-
-
-/* either we find an LF at <ptr> or we jump to <bad>.
- */
-#define EXPECT_LF_HERE(ptr, bad)	do { if (unlikely(*(ptr) != '\n')) goto bad; } while (0)
-
-/* plays with variables <ptr>, <end> and <state>. Jumps to <good> if OK,
- * otherwise to <http_msg_ood> with <state> set to <st>.
- */
-#define EAT_AND_JUMP_OR_RETURN(good, st)   do { \
-		ptr++;                          \
-		if (likely(ptr < end))          \
-			goto good;              \
-		else {                          \
-			state = (st);           \
-			goto http_msg_ood;      \
-		}                               \
-	} while (0)
-
-
-/*
- * This function parses a status line between <ptr> and <end>, starting with
- * parser state <state>. Only states HTTP_MSG_RPVER, HTTP_MSG_RPVER_SP,
- * HTTP_MSG_RPCODE, HTTP_MSG_RPCODE_SP and HTTP_MSG_RPREASON are handled. Others
- * will give undefined results.
- * Note that it is upon the caller's responsibility to ensure that ptr < end,
- * and that msg->sol points to the beginning of the response.
- * If a complete line is found (which implies that at least one CR or LF is
- * found before <end>, the updated <ptr> is returned, otherwise NULL is
- * returned indicating an incomplete line (which does not mean that parts have
- * not been updated). In the incomplete case, if <ret_ptr> or <ret_state> are
- * non-NULL, they are fed with the new <ptr> and <state> values to be passed
- * upon next call.
- *
- * This function was intentionally designed to be called from
- * http_msg_analyzer() with the lowest overhead. It should integrate perfectly
- * within its state machine and use the same macros, hence the need for same
- * labels and variable names. Note that msg->sol is left unchanged.
- */
-const char *http_parse_stsline(struct http_msg *msg, const char *msg_buf,
-			       unsigned int state, const char *ptr, const char *end,
-			       char **ret_ptr, unsigned int *ret_state)
-{
-	switch (state)	{
-	case HTTP_MSG_RPVER:
-	http_msg_rpver:
-		if (likely(HTTP_IS_VER_TOKEN(*ptr)))
-			EAT_AND_JUMP_OR_RETURN(http_msg_rpver, HTTP_MSG_RPVER);
-
-		if (likely(HTTP_IS_SPHT(*ptr))) {
-			msg->sl.st.v_l = (ptr - msg_buf) - msg->som;
-			EAT_AND_JUMP_OR_RETURN(http_msg_rpver_sp, HTTP_MSG_RPVER_SP);
-		}
-		state = HTTP_MSG_ERROR;
-		break;
-
-	case HTTP_MSG_RPVER_SP:
-	http_msg_rpver_sp:
-		if (likely(!HTTP_IS_LWS(*ptr))) {
-			msg->sl.st.c = (ptr - msg_buf) - msg->som;
-			goto http_msg_rpcode;
-		}
-		if (likely(HTTP_IS_SPHT(*ptr)))
-			EAT_AND_JUMP_OR_RETURN(http_msg_rpver_sp, HTTP_MSG_RPVER_SP);
-		/* so it's a CR/LF, this is invalid */
-		state = HTTP_MSG_ERROR;
-		break;
-
-	case HTTP_MSG_RPCODE:
-	http_msg_rpcode:
-		if (likely(!HTTP_IS_LWS(*ptr)))
-			EAT_AND_JUMP_OR_RETURN(http_msg_rpcode, HTTP_MSG_RPCODE);
-
-		if (likely(HTTP_IS_SPHT(*ptr))) {
-			msg->sl.st.c_l = (ptr - msg_buf) - msg->som - msg->sl.st.c;
-			EAT_AND_JUMP_OR_RETURN(http_msg_rpcode_sp, HTTP_MSG_RPCODE_SP);
-		}
-
-		/* so it's a CR/LF, so there is no reason phrase */
-		msg->sl.st.c_l = (ptr - msg_buf) - msg->som - msg->sl.st.c;
-	http_msg_rsp_reason:
-		/* FIXME: should we support HTTP responses without any reason phrase ? */
-		msg->sl.st.r = (ptr - msg_buf) - msg->som;
-		msg->sl.st.r_l = 0;
-		goto http_msg_rpline_eol;
-
-	case HTTP_MSG_RPCODE_SP:
-	http_msg_rpcode_sp:
-		if (likely(!HTTP_IS_LWS(*ptr))) {
-			msg->sl.st.r = (ptr - msg_buf) - msg->som;
-			goto http_msg_rpreason;
-		}
-		if (likely(HTTP_IS_SPHT(*ptr)))
-			EAT_AND_JUMP_OR_RETURN(http_msg_rpcode_sp, HTTP_MSG_RPCODE_SP);
-		/* so it's a CR/LF, so there is no reason phrase */
-		goto http_msg_rsp_reason;
-
-	case HTTP_MSG_RPREASON:
-	http_msg_rpreason:
-		if (likely(!HTTP_IS_CRLF(*ptr)))
-			EAT_AND_JUMP_OR_RETURN(http_msg_rpreason, HTTP_MSG_RPREASON);
-		msg->sl.st.r_l = (ptr - msg_buf) - msg->som - msg->sl.st.r;
-	http_msg_rpline_eol:
-		/* We have seen the end of line. Note that we do not
-		 * necessarily have the \n yet, but at least we know that we
-		 * have EITHER \r OR \n, otherwise the response would not be
-		 * complete. We can then record the response length and return
-		 * to the caller which will be able to register it.
-		 */
-		msg->sl.st.l = ptr - msg->sol;
-		return ptr;
-
-#ifdef DEBUG_FULL
-	default:
-		fprintf(stderr, "FIXME !!!! impossible state at %s:%d = %d\n", __FILE__, __LINE__, state);
-		exit(1);
-#endif
-	}
-
- http_msg_ood:
-	/* out of valid data */
-	if (ret_state)
-		*ret_state = state;
-	if (ret_ptr)
-		*ret_ptr = (char *)ptr;
-	return NULL;
-}
-
-/*
- * This function parses a request line between <ptr> and <end>, starting with
- * parser state <state>. Only states HTTP_MSG_RQMETH, HTTP_MSG_RQMETH_SP,
- * HTTP_MSG_RQURI, HTTP_MSG_RQURI_SP and HTTP_MSG_RQVER are handled. Others
- * will give undefined results.
- * Note that it is upon the caller's responsibility to ensure that ptr < end,
- * and that msg->sol points to the beginning of the request.
- * If a complete line is found (which implies that at least one CR or LF is
- * found before <end>, the updated <ptr> is returned, otherwise NULL is
- * returned indicating an incomplete line (which does not mean that parts have
- * not been updated). In the incomplete case, if <ret_ptr> or <ret_state> are
- * non-NULL, they are fed with the new <ptr> and <state> values to be passed
- * upon next call.
- *
- * This function was intentionally designed to be called from
- * http_msg_analyzer() with the lowest overhead. It should integrate perfectly
- * within its state machine and use the same macros, hence the need for same
- * labels and variable names. Note that msg->sol is left unchanged.
- */
-const char *http_parse_reqline(struct http_msg *msg, const char *msg_buf,
-			       unsigned int state, const char *ptr, const char *end,
-			       char **ret_ptr, unsigned int *ret_state)
-{
-	switch (state)	{
-	case HTTP_MSG_RQMETH:
-	http_msg_rqmeth:
-		if (likely(HTTP_IS_TOKEN(*ptr)))
-			EAT_AND_JUMP_OR_RETURN(http_msg_rqmeth, HTTP_MSG_RQMETH);
-
-		if (likely(HTTP_IS_SPHT(*ptr))) {
-			msg->sl.rq.m_l = (ptr - msg_buf) - msg->som;
-			EAT_AND_JUMP_OR_RETURN(http_msg_rqmeth_sp, HTTP_MSG_RQMETH_SP);
-		}
-
-		if (likely(HTTP_IS_CRLF(*ptr))) {
-			/* HTTP 0.9 request */
-			msg->sl.rq.m_l = (ptr - msg_buf) - msg->som;
-		http_msg_req09_uri:
-			msg->sl.rq.u = (ptr - msg_buf) - msg->som;
-		http_msg_req09_uri_e:
-			msg->sl.rq.u_l = (ptr - msg_buf) - msg->som - msg->sl.rq.u;
-		http_msg_req09_ver:
-			msg->sl.rq.v = (ptr - msg_buf) - msg->som;
-			msg->sl.rq.v_l = 0;
-			goto http_msg_rqline_eol;
-		}
-		state = HTTP_MSG_ERROR;
-		break;
-
-	case HTTP_MSG_RQMETH_SP:
-	http_msg_rqmeth_sp:
-		if (likely(!HTTP_IS_LWS(*ptr))) {
-			msg->sl.rq.u = (ptr - msg_buf) - msg->som;
-			goto http_msg_rquri;
-		}
-		if (likely(HTTP_IS_SPHT(*ptr)))
-			EAT_AND_JUMP_OR_RETURN(http_msg_rqmeth_sp, HTTP_MSG_RQMETH_SP);
-		/* so it's a CR/LF, meaning an HTTP 0.9 request */
-		goto http_msg_req09_uri;
-
-	case HTTP_MSG_RQURI:
-	http_msg_rquri:
-		if (likely((unsigned char)(*ptr - 33) <= 93)) /* 33 to 126 included */
-			EAT_AND_JUMP_OR_RETURN(http_msg_rquri, HTTP_MSG_RQURI);
-
-		if (likely(HTTP_IS_SPHT(*ptr))) {
-			msg->sl.rq.u_l = (ptr - msg_buf) - msg->som - msg->sl.rq.u;
-			EAT_AND_JUMP_OR_RETURN(http_msg_rquri_sp, HTTP_MSG_RQURI_SP);
-		}
-
-		if (likely((unsigned char)*ptr >= 128)) {
-			/* FIXME: we should control whether we want to allow them, but
-			 * until now they were allowed.
-			 */
-			EAT_AND_JUMP_OR_RETURN(http_msg_rquri, HTTP_MSG_RQURI);
-		}
-
-		if (likely(HTTP_IS_CRLF(*ptr))) {
-			/* so it's a CR/LF, meaning an HTTP 0.9 request */
-			goto http_msg_req09_uri_e;
-		}
-
-		/* OK forbidden chars, 0..31 or 127 */
-		state = HTTP_MSG_ERROR;
-		break;
-
-	case HTTP_MSG_RQURI_SP:
-	http_msg_rquri_sp:
-		if (likely(!HTTP_IS_LWS(*ptr))) {
-			msg->sl.rq.v = (ptr - msg_buf) - msg->som;
-			goto http_msg_rqver;
-		}
-		if (likely(HTTP_IS_SPHT(*ptr)))
-			EAT_AND_JUMP_OR_RETURN(http_msg_rquri_sp, HTTP_MSG_RQURI_SP);
-		/* so it's a CR/LF, meaning an HTTP 0.9 request */
-		goto http_msg_req09_ver;
-
-	case HTTP_MSG_RQVER:
-	http_msg_rqver:
-		if (likely(HTTP_IS_VER_TOKEN(*ptr)))
-			EAT_AND_JUMP_OR_RETURN(http_msg_rqver, HTTP_MSG_RQVER);
-
-		if (likely(HTTP_IS_CRLF(*ptr))) {
-			msg->sl.rq.v_l = (ptr - msg_buf) - msg->som - msg->sl.rq.v;
-		http_msg_rqline_eol:
-			/* We have seen the end of line. Note that we do not
-			 * necessarily have the \n yet, but at least we know that we
-			 * have EITHER \r OR \n, otherwise the request would not be
-			 * complete. We can then record the request length and return
-			 * to the caller which will be able to register it.
-			 */
-			msg->sl.rq.l = ptr - msg->sol;
-			return ptr;
-		}
-
-		/* neither an HTTP_VER token nor a CRLF */
-		state = HTTP_MSG_ERROR;
-		break;
-
-#ifdef DEBUG_FULL
-	default:
-		fprintf(stderr, "FIXME !!!! impossible state at %s:%d = %d\n", __FILE__, __LINE__, state);
-		exit(1);
-#endif
-	}
-
- http_msg_ood:
-	/* out of valid data */
-	if (ret_state)
-		*ret_state = state;
-	if (ret_ptr)
-		*ret_ptr = (char *)ptr;
-	return NULL;
-}
-
-/*
- * Returns the data from Authorization header. Function may be called more
- * than once so data is stored in txn->auth_data. When no header is found
- * or auth method is unknown auth_method is set to HTTP_AUTH_WRONG to avoid
- * searching again for something we are unable to find anyway.
- */
-
-char get_http_auth_buff[BUFSIZE];
-
-int
-get_http_auth(struct session *s)
-{
-
-	struct http_txn *txn = &s->txn;
-	struct chunk auth_method;
-	struct hdr_ctx ctx;
-	char *h, *p;
-	int len;
-
-#ifdef DEBUG_AUTH
-	printf("Auth for session %p: %d\n", s, txn->auth.method);
-#endif
-
-	if (txn->auth.method == HTTP_AUTH_WRONG)
-		return 0;
-
-	if (txn->auth.method)
-		return 1;
-
-	txn->auth.method = HTTP_AUTH_WRONG;
-
-	ctx.idx = 0;
-
-	if (txn->flags & TX_USE_PX_CONN) {
-		h = "Proxy-Authorization";
-		len = strlen(h);
-	} else {
-		h = "Authorization";
-		len = strlen(h);
-	}
-
-	if (!http_find_header2(h, len, txn->req.sol, &txn->hdr_idx, &ctx))
-		return 0;
-
-	h = ctx.line + ctx.val;
-
-	p = memchr(h, ' ', ctx.vlen);
-	if (!p || p == h)
-		return 0;
-
-	chunk_initlen(&auth_method, h, 0, p-h);
-	chunk_initlen(&txn->auth.method_data, p+1, 0, ctx.vlen-(p-h)-1);
-
-	if (!strncasecmp("Basic", auth_method.str, auth_method.len)) {
-
-		len = base64dec(txn->auth.method_data.str, txn->auth.method_data.len,
-				get_http_auth_buff, BUFSIZE - 1);
-
-		if (len < 0)
-			return 0;
-
-
-		get_http_auth_buff[len] = '\0';
-
-		p = strchr(get_http_auth_buff, ':');
-
-		if (!p)
-			return 0;
-
-		txn->auth.user = get_http_auth_buff;
-		*p = '\0';
-		txn->auth.pass = p+1;
-
-		txn->auth.method = HTTP_AUTH_BASIC;
-		return 1;
-	}
-
-	return 0;
-}
-
-
-/*
- * This function parses an HTTP message, either a request or a response,
- * depending on the initial msg->msg_state. It can be preempted everywhere
- * when data are missing and recalled at the exact same location with no
- * information loss. The header index is re-initialized when switching from
- * MSG_R[PQ]BEFORE to MSG_RPVER|MSG_RQMETH. It modifies msg->sol among other
- * fields. Note that msg->som and msg->sol will be initialized after completing
- * the first state, so that none of the msg pointers has to be initialized
- * prior to the first call.
- */
-void http_msg_analyzer(struct buffer *buf, struct http_msg *msg, struct hdr_idx *idx)
-{
-	unsigned int state;       /* updated only when leaving the FSM */
-	register char *ptr, *end; /* request pointers, to avoid dereferences */
-
-	state = msg->msg_state;
-	ptr = buf->lr;
-	end = buf->r;
-
-	if (unlikely(ptr >= end))
-		goto http_msg_ood;
-
-	switch (state)	{
-	/*
-	 * First, states that are specific to the response only.
-	 * We check them first so that request and headers are
-	 * closer to each other (accessed more often).
-	 */
-	case HTTP_MSG_RPBEFORE:
-	http_msg_rpbefore:
-		if (likely(HTTP_IS_TOKEN(*ptr))) {
-			/* we have a start of message, but we have to check
-			 * first if we need to remove some CRLF. We can only
-			 * do this when send_max=0.
-			 */
-			char *beg = buf->w + buf->send_max;
-			if (beg >= buf->data + buf->size)
-				beg -= buf->size;
-			if (unlikely(ptr != beg)) {
-				if (buf->send_max)
-					goto http_msg_ood;
-				/* Remove empty leading lines, as recommended by RFC2616. */
-				buffer_ignore(buf, ptr - beg);
-			}
-			msg->som = ptr - buf->data;
-			msg->sol = ptr;
-			hdr_idx_init(idx);
-			state = HTTP_MSG_RPVER;
-			goto http_msg_rpver;
-		}
-
-		if (unlikely(!HTTP_IS_CRLF(*ptr)))
-			goto http_msg_invalid;
-
-		if (unlikely(*ptr == '\n'))
-			EAT_AND_JUMP_OR_RETURN(http_msg_rpbefore, HTTP_MSG_RPBEFORE);
-		EAT_AND_JUMP_OR_RETURN(http_msg_rpbefore_cr, HTTP_MSG_RPBEFORE_CR);
-		/* stop here */
-
-	case HTTP_MSG_RPBEFORE_CR:
-	http_msg_rpbefore_cr:
-		EXPECT_LF_HERE(ptr, http_msg_invalid);
-		EAT_AND_JUMP_OR_RETURN(http_msg_rpbefore, HTTP_MSG_RPBEFORE);
-		/* stop here */
-
-	case HTTP_MSG_RPVER:
-	http_msg_rpver:
-	case HTTP_MSG_RPVER_SP:
-	case HTTP_MSG_RPCODE:
-	case HTTP_MSG_RPCODE_SP:
-	case HTTP_MSG_RPREASON:
-		ptr = (char *)http_parse_stsline(msg, buf->data, state, ptr, end,
-						 &buf->lr, &msg->msg_state);
-		if (unlikely(!ptr))
-			return;
-
-		/* we have a full response and we know that we have either a CR
-		 * or an LF at <ptr>.
-		 */
-		//fprintf(stderr,"som=%d rq.l=%d *ptr=0x%02x\n", msg->som, msg->sl.st.l, *ptr);
-		hdr_idx_set_start(idx, msg->sl.st.l, *ptr == '\r');
-
-		msg->sol = ptr;
-		if (likely(*ptr == '\r'))
-			EAT_AND_JUMP_OR_RETURN(http_msg_rpline_end, HTTP_MSG_RPLINE_END);
-		goto http_msg_rpline_end;
-
-	case HTTP_MSG_RPLINE_END:
-	http_msg_rpline_end:
-		/* msg->sol must point to the first of CR or LF. */
-		EXPECT_LF_HERE(ptr, http_msg_invalid);
-		EAT_AND_JUMP_OR_RETURN(http_msg_hdr_first, HTTP_MSG_HDR_FIRST);
-		/* stop here */
-
-	/*
-	 * Second, states that are specific to the request only
-	 */
-	case HTTP_MSG_RQBEFORE:
-	http_msg_rqbefore:
-		if (likely(HTTP_IS_TOKEN(*ptr))) {
-			/* we have a start of message, but we have to check
-			 * first if we need to remove some CRLF. We can only
-			 * do this when send_max=0.
-			 */
-			char *beg = buf->w + buf->send_max;
-			if (beg >= buf->data + buf->size)
-				beg -= buf->size;
-			if (likely(ptr != beg)) {
-				if (buf->send_max)
-					goto http_msg_ood;
-				/* Remove empty leading lines, as recommended by RFC2616. */
-				buffer_ignore(buf, ptr - beg);
-			}
-			msg->som = ptr - buf->data;
-			msg->sol = ptr;
-			/* we will need this when keep-alive will be supported
-			   hdr_idx_init(idx);
-			 */
-			state = HTTP_MSG_RQMETH;
-			goto http_msg_rqmeth;
-		}
-
-		if (unlikely(!HTTP_IS_CRLF(*ptr)))
-			goto http_msg_invalid;
-
-		if (unlikely(*ptr == '\n'))
-			EAT_AND_JUMP_OR_RETURN(http_msg_rqbefore, HTTP_MSG_RQBEFORE);
-		EAT_AND_JUMP_OR_RETURN(http_msg_rqbefore_cr, HTTP_MSG_RQBEFORE_CR);
-		/* stop here */
-
-	case HTTP_MSG_RQBEFORE_CR:
-	http_msg_rqbefore_cr:
-		EXPECT_LF_HERE(ptr, http_msg_invalid);
-		EAT_AND_JUMP_OR_RETURN(http_msg_rqbefore, HTTP_MSG_RQBEFORE);
-		/* stop here */
-
-	case HTTP_MSG_RQMETH:
-	http_msg_rqmeth:
-	case HTTP_MSG_RQMETH_SP:
-	case HTTP_MSG_RQURI:
-	case HTTP_MSG_RQURI_SP:
-	case HTTP_MSG_RQVER:
-		ptr = (char *)http_parse_reqline(msg, buf->data, state, ptr, end,
-						 &buf->lr, &msg->msg_state);
-		if (unlikely(!ptr))
-			return;
-
-		/* we have a full request and we know that we have either a CR
-		 * or an LF at <ptr>.
-		 */
-		//fprintf(stderr,"som=%d rq.l=%d *ptr=0x%02x\n", msg->som, msg->sl.rq.l, *ptr);
-		hdr_idx_set_start(idx, msg->sl.rq.l, *ptr == '\r');
-
-		msg->sol = ptr;
-		if (likely(*ptr == '\r'))
-			EAT_AND_JUMP_OR_RETURN(http_msg_rqline_end, HTTP_MSG_RQLINE_END);
-		goto http_msg_rqline_end;
-
-	case HTTP_MSG_RQLINE_END:
-	http_msg_rqline_end:
-		/* check for HTTP/0.9 request : no version information available.
-		 * msg->sol must point to the first of CR or LF.
-		 */
-		if (unlikely(msg->sl.rq.v_l == 0))
-			goto http_msg_last_lf;
-
-		EXPECT_LF_HERE(ptr, http_msg_invalid);
-		EAT_AND_JUMP_OR_RETURN(http_msg_hdr_first, HTTP_MSG_HDR_FIRST);
-		/* stop here */
-
-	/*
-	 * Common states below
-	 */
-	case HTTP_MSG_HDR_FIRST:
-	http_msg_hdr_first:
-		msg->sol = ptr;
-		if (likely(!HTTP_IS_CRLF(*ptr))) {
-			goto http_msg_hdr_name;
-		}
-		
-		if (likely(*ptr == '\r'))
-			EAT_AND_JUMP_OR_RETURN(http_msg_last_lf, HTTP_MSG_LAST_LF);
-		goto http_msg_last_lf;
-
-	case HTTP_MSG_HDR_NAME:
-	http_msg_hdr_name:
-		/* assumes msg->sol points to the first char */
-		if (likely(HTTP_IS_TOKEN(*ptr)))
-			EAT_AND_JUMP_OR_RETURN(http_msg_hdr_name, HTTP_MSG_HDR_NAME);
-
-		if (likely(*ptr == ':'))
-			EAT_AND_JUMP_OR_RETURN(http_msg_hdr_l1_sp, HTTP_MSG_HDR_L1_SP);
-
-		if (likely(msg->err_pos < -1) || *ptr == '\n')
-			goto http_msg_invalid;
-
-		if (msg->err_pos == -1) /* capture error pointer */
-			msg->err_pos = ptr - buf->data; /* >= 0 now */
-
-		/* and we still accept this non-token character */
-		EAT_AND_JUMP_OR_RETURN(http_msg_hdr_name, HTTP_MSG_HDR_NAME);
-
-	case HTTP_MSG_HDR_L1_SP:
-	http_msg_hdr_l1_sp:
-		/* assumes msg->sol points to the first char */
-		if (likely(HTTP_IS_SPHT(*ptr)))
-			EAT_AND_JUMP_OR_RETURN(http_msg_hdr_l1_sp, HTTP_MSG_HDR_L1_SP);
-
-		/* header value can be basically anything except CR/LF */
-		msg->sov = ptr - buf->data;
-
-		if (likely(!HTTP_IS_CRLF(*ptr))) {
-			goto http_msg_hdr_val;
-		}
-			
-		if (likely(*ptr == '\r'))
-			EAT_AND_JUMP_OR_RETURN(http_msg_hdr_l1_lf, HTTP_MSG_HDR_L1_LF);
-		goto http_msg_hdr_l1_lf;
-
-	case HTTP_MSG_HDR_L1_LF:
-	http_msg_hdr_l1_lf:
-		EXPECT_LF_HERE(ptr, http_msg_invalid);
-		EAT_AND_JUMP_OR_RETURN(http_msg_hdr_l1_lws, HTTP_MSG_HDR_L1_LWS);
-
-	case HTTP_MSG_HDR_L1_LWS:
-	http_msg_hdr_l1_lws:
-		if (likely(HTTP_IS_SPHT(*ptr))) {
-			/* replace HT,CR,LF with spaces */
-			for (; buf->data+msg->sov < ptr; msg->sov++)
-				buf->data[msg->sov] = ' ';
-			goto http_msg_hdr_l1_sp;
-		}
-		/* we had a header consisting only in spaces ! */
-		msg->eol = buf->data + msg->sov;
-		goto http_msg_complete_header;
-		
-	case HTTP_MSG_HDR_VAL:
-	http_msg_hdr_val:
-		/* assumes msg->sol points to the first char,
-		 * and msg->sov points to the first character of the
-		 * value.
-		 */
-		if (likely(!HTTP_IS_CRLF(*ptr)))
-			EAT_AND_JUMP_OR_RETURN(http_msg_hdr_val, HTTP_MSG_HDR_VAL);
-
-		msg->eol = ptr;
-		/* Note: we could also copy eol into ->eoh so that we have the
-		 * real header end in case it ends with lots of LWS, but is this
-		 * really needed ?
-		 */
-		if (likely(*ptr == '\r'))
-			EAT_AND_JUMP_OR_RETURN(http_msg_hdr_l2_lf, HTTP_MSG_HDR_L2_LF);
-		goto http_msg_hdr_l2_lf;
-
-	case HTTP_MSG_HDR_L2_LF:
-	http_msg_hdr_l2_lf:
-		EXPECT_LF_HERE(ptr, http_msg_invalid);
-		EAT_AND_JUMP_OR_RETURN(http_msg_hdr_l2_lws, HTTP_MSG_HDR_L2_LWS);
-
-	case HTTP_MSG_HDR_L2_LWS:
-	http_msg_hdr_l2_lws:
-		if (unlikely(HTTP_IS_SPHT(*ptr))) {
-			/* LWS: replace HT,CR,LF with spaces */
-			for (; msg->eol < ptr; msg->eol++)
-				*msg->eol = ' ';
-			goto http_msg_hdr_val;
-		}
-	http_msg_complete_header:
-		/*
-		 * It was a new header, so the last one is finished.
-		 * Assumes msg->sol points to the first char,
-		 * msg->sov points to the first character of the value
-		 * and msg->eol to the first CR or LF so we know how the line
-		 * ends. We insert last header into the index.
-		 */
-		/*
-		  fprintf(stderr,"registering %-2d bytes : ", msg->eol - msg->sol);
-		  write(2, msg->sol, msg->eol-msg->sol);
-		  fprintf(stderr,"\n");
-		*/
-
-		if (unlikely(hdr_idx_add(msg->eol - msg->sol, *msg->eol == '\r',
-					 idx, idx->tail) < 0))
-			goto http_msg_invalid;
-
-		msg->sol = ptr;
-		if (likely(!HTTP_IS_CRLF(*ptr))) {
-			goto http_msg_hdr_name;
-		}
-		
-		if (likely(*ptr == '\r'))
-			EAT_AND_JUMP_OR_RETURN(http_msg_last_lf, HTTP_MSG_LAST_LF);
-		goto http_msg_last_lf;
-
-	case HTTP_MSG_LAST_LF:
-	http_msg_last_lf:
-		/* Assumes msg->sol points to the first of either CR or LF */
-		EXPECT_LF_HERE(ptr, http_msg_invalid);
-		ptr++;
-		buf->lr = ptr;
-		msg->sov = buf->lr - buf->data;
-		msg->eoh = msg->sol - buf->data;
-		msg->sol = buf->data + msg->som;
-		msg->msg_state = HTTP_MSG_BODY;
-		return;
-
-	case HTTP_MSG_ERROR:
-		/* this may only happen if we call http_msg_analyser() twice with an error */
-		break;
-
-#ifdef DEBUG_FULL
-	default:
-		fprintf(stderr, "FIXME !!!! impossible state at %s:%d = %d\n", __FILE__, __LINE__, state);
-		exit(1);
-#endif
-	}
- http_msg_ood:
-	/* out of data */
-	msg->msg_state = state;
-	buf->lr = ptr;
-	return;
-
- http_msg_invalid:
-	/* invalid message */
-	msg->msg_state = HTTP_MSG_ERROR;
-	buf->lr = ptr;
-	return;
-}
-
-/* convert an HTTP/0.9 request into an HTTP/1.0 request. Returns 1 if the
- * conversion succeeded, 0 in case of error. If the request was already 1.X,
- * nothing is done and 1 is returned.
- */
-static int http_upgrade_v09_to_v10(struct buffer *req, struct http_msg *msg, struct http_txn *txn)
-{
-	int delta;
-	char *cur_end;
-
-	if (msg->sl.rq.v_l != 0)
-		return 1;
-
-	cur_end = msg->sol + msg->sl.rq.l;
-	delta = 0;
-
-	if (msg->sl.rq.u_l == 0) {
-		/* if no URI was set, add "/" */
-		delta = buffer_replace2(req, cur_end, cur_end, " /", 2);
-		cur_end += delta;
-		http_msg_move_end(msg, delta);
-	}
-	/* add HTTP version */
-	delta = buffer_replace2(req, cur_end, cur_end, " HTTP/1.0\r\n", 11);
-	http_msg_move_end(msg, delta);
-	cur_end += delta;
-	cur_end = (char *)http_parse_reqline(msg, req->data,
-					     HTTP_MSG_RQMETH,
-					     msg->sol, cur_end + 1,
-					     NULL, NULL);
-	if (unlikely(!cur_end))
-		return 0;
-
-	/* we have a full HTTP/1.0 request now and we know that
-	 * we have either a CR or an LF at <ptr>.
-	 */
-	hdr_idx_set_start(&txn->hdr_idx, msg->sl.rq.l, *cur_end == '\r');
-	return 1;
-}
-
-/* Parse the Connection: header of an HTTP request, looking for both "close"
- * and "keep-alive" values. If a buffer is provided and we already know that
- * some headers may safely be removed, we remove them now. The <to_del> flags
- * are used for that :
- *  - bit 0 means remove "close" headers (in HTTP/1.0 requests/responses)
- *  - bit 1 means remove "keep-alive" headers (in HTTP/1.1 reqs/resp to 1.1).
- * The TX_HDR_CONN_* flags are adjusted in txn->flags depending on what was
- * found, and TX_CON_*_SET is adjusted depending on what is left so only
- * harmless combinations may be removed. Do not call that after changes have
- * been processed. If unused, the buffer can be NULL, and no data will be
- * changed.
- */
-void http_parse_connection_header(struct http_txn *txn, struct http_msg *msg, struct buffer *buf, int to_del)
-{
-	struct hdr_ctx ctx;
-	const char *hdr_val = "Connection";
-	int hdr_len = 10;
-
-	if (txn->flags & TX_HDR_CONN_PRS)
-		return;
-
-	if (unlikely(txn->flags & TX_USE_PX_CONN)) {
-		hdr_val = "Proxy-Connection";
-		hdr_len = 16;
-	}
-
-	ctx.idx = 0;
-	txn->flags &= ~(TX_CON_KAL_SET|TX_CON_CLO_SET);
-	while (http_find_header2(hdr_val, hdr_len, msg->sol, &txn->hdr_idx, &ctx)) {
-		if (ctx.vlen >= 10 && word_match(ctx.line + ctx.val, ctx.vlen, "keep-alive", 10)) {
-			txn->flags |= TX_HDR_CONN_KAL;
-			if ((to_del & 2) && buf)
-				http_remove_header2(msg, buf, &txn->hdr_idx, &ctx);
-			else
-				txn->flags |= TX_CON_KAL_SET;
-		}
-		else if (ctx.vlen >= 5 && word_match(ctx.line + ctx.val, ctx.vlen, "close", 5)) {
-			txn->flags |= TX_HDR_CONN_CLO;
-			if ((to_del & 1) && buf)
-				http_remove_header2(msg, buf, &txn->hdr_idx, &ctx);
-			else
-				txn->flags |= TX_CON_CLO_SET;
-		}
-	}
-
-	txn->flags |= TX_HDR_CONN_PRS;
-	return;
-}
-
-/* Apply desired changes on the Connection: header. Values may be removed and/or
- * added depending on the <wanted> flags, which are exclusively composed of
- * TX_CON_CLO_SET and TX_CON_KAL_SET, depending on what flags are desired. The
- * TX_CON_*_SET flags are adjusted in txn->flags depending on what is left.
- */
-void http_change_connection_header(struct http_txn *txn, struct http_msg *msg, struct buffer *buf, int wanted)
-{
-	struct hdr_ctx ctx;
-	const char *hdr_val = "Connection";
-	int hdr_len = 10;
-
-	ctx.idx = 0;
-
-
-	if (unlikely(txn->flags & TX_USE_PX_CONN)) {
-		hdr_val = "Proxy-Connection";
-		hdr_len = 16;
-	}
-
-	txn->flags &= ~(TX_CON_CLO_SET | TX_CON_KAL_SET);
-	while (http_find_header2(hdr_val, hdr_len, msg->sol, &txn->hdr_idx, &ctx)) {
-		if (ctx.vlen >= 10 && word_match(ctx.line + ctx.val, ctx.vlen, "keep-alive", 10)) {
-			if (wanted & TX_CON_KAL_SET)
-				txn->flags |= TX_CON_KAL_SET;
-			else
-				http_remove_header2(msg, buf, &txn->hdr_idx, &ctx);
-		}
-		else if (ctx.vlen >= 5 && word_match(ctx.line + ctx.val, ctx.vlen, "close", 5)) {
-			if (wanted & TX_CON_CLO_SET)
-				txn->flags |= TX_CON_CLO_SET;
-			else
-				http_remove_header2(msg, buf, &txn->hdr_idx, &ctx);
-		}
-	}
-
-	if (wanted == (txn->flags & (TX_CON_CLO_SET|TX_CON_KAL_SET)))
-		return;
-
-	if ((wanted & TX_CON_CLO_SET) && !(txn->flags & TX_CON_CLO_SET)) {
-		txn->flags |= TX_CON_CLO_SET;
-		hdr_val = "Connection: close";
-		hdr_len  = 17;
-		if (unlikely(txn->flags & TX_USE_PX_CONN)) {
-			hdr_val = "Proxy-Connection: close";
-			hdr_len = 23;
-		}
-		http_header_add_tail2(buf, msg, &txn->hdr_idx, hdr_val, hdr_len);
-	}
-
-	if ((wanted & TX_CON_KAL_SET) && !(txn->flags & TX_CON_KAL_SET)) {
-		txn->flags |= TX_CON_KAL_SET;
-		hdr_val = "Connection: keep-alive";
-		hdr_len = 22;
-		if (unlikely(txn->flags & TX_USE_PX_CONN)) {
-			hdr_val = "Proxy-Connection: keep-alive";
-			hdr_len = 28;
-		}
-		http_header_add_tail2(buf, msg, &txn->hdr_idx, hdr_val, hdr_len);
-	}
-	return;
-}
-
-/* Parse the chunk size at buf->lr. Once done, it adjusts ->lr to point to the
- * first byte of body, and increments msg->sov by the number of bytes parsed,
- * so that we know we can forward between ->som and ->sov. Note that due to
- * possible wrapping at the end of the buffer, it is possible that msg->sov is
- * lower than msg->som.
- * Return >0 on success, 0 when some data is missing, <0 on error.
- * Note: this function is designed to parse wrapped CRLF at the end of the buffer.
- */
-int http_parse_chunk_size(struct buffer *buf, struct http_msg *msg)
-{
-	char *ptr = buf->lr;
-	char *end = buf->data + buf->size;
-	unsigned int chunk = 0;
-
-	/* The chunk size is in the following form, though we are only
-	 * interested in the size and CRLF :
-	 *    1*HEXDIGIT *WSP *[ ';' extensions ] CRLF
-	 */
-	while (1) {
-		int c;
-		if (ptr == buf->r)
-			return 0;
-		c = hex2i(*ptr);
-		if (c < 0) /* not a hex digit anymore */
-			break;
-		if (++ptr >= end)
-			ptr = buf->data;
-		if (chunk & 0xF000000) /* overflow will occur */
-			goto error;
-		chunk = (chunk << 4) + c;
-	}
-
-	/* empty size not allowed */
-	if (ptr == buf->lr)
-		goto error;
-
-	while (http_is_spht[(unsigned char)*ptr]) {
-		if (++ptr >= end)
-			ptr = buf->data;
-		if (ptr == buf->r)
-			return 0;
-	}
-
-	/* Up to there, we know that at least one byte is present at *ptr. Check
-	 * for the end of chunk size.
-	 */
-	while (1) {
-		if (likely(HTTP_IS_CRLF(*ptr))) {
-			/* we now have a CR or an LF at ptr */
-			if (likely(*ptr == '\r')) {
-				if (++ptr >= end)
-					ptr = buf->data;
-				if (ptr == buf->r)
-					return 0;
-			}
-
-			if (*ptr != '\n')
-				goto error;
-			if (++ptr >= end)
-				ptr = buf->data;
-			/* done */
-			break;
-		}
-		else if (*ptr == ';') {
-			/* chunk extension, ends at next CRLF */
-			if (++ptr >= end)
-				ptr = buf->data;
-			if (ptr == buf->r)
-				return 0;
-
-			while (!HTTP_IS_CRLF(*ptr)) {
-				if (++ptr >= end)
-					ptr = buf->data;
-				if (ptr == buf->r)
-					return 0;
-			}
-			/* we have a CRLF now, loop above */
-			continue;
-		}
-		else
-			goto error;
-	}
-
-	/* OK we found our CRLF and now <ptr> points to the next byte,
-	 * which may or may not be present. We save that into ->lr and
-	 * ->sov.
-	 */
-	msg->sov += ptr - buf->lr;
-	buf->lr = ptr;
-	msg->chunk_len = chunk;
-	msg->body_len += chunk;
-	msg->msg_state = chunk ? HTTP_MSG_DATA : HTTP_MSG_TRAILERS;
-	return 1;
- error:
-	msg->err_pos = ptr - buf->data;
-	return -1;
-}
-
-/* This function skips trailers in the buffer <buf> associated with HTTP
- * message <msg>. The first visited position is buf->lr. If the end of
- * the trailers is found, it is automatically scheduled to be forwarded,
- * msg->msg_state switches to HTTP_MSG_DONE, and the function returns >0.
- * If not enough data are available, the function does not change anything
- * except maybe buf->lr and msg->sov if it could parse some lines, and returns
- * zero. If a parse error is encountered, the function returns < 0 and does not
- * change anything except maybe buf->lr and msg->sov. Note that the message
- * must already be in HTTP_MSG_TRAILERS state before calling this function,
- * which implies that all non-trailers data have already been scheduled for
- * forwarding, and that the difference between msg->som and msg->sov exactly
- * matches the length of trailers already parsed and not forwarded. It is also
- * important to note that this function is designed to be able to parse wrapped
- * headers at end of buffer.
- */
-int http_forward_trailers(struct buffer *buf, struct http_msg *msg)
-{
-	/* we have buf->lr which points to next line. Look for CRLF. */
-	while (1) {
-		char *p1 = NULL, *p2 = NULL;
-		char *ptr = buf->lr;
-		int bytes;
-
-		/* scan current line and stop at LF or CRLF */
-		while (1) {
-			if (ptr == buf->r)
-				return 0;
-
-			if (*ptr == '\n') {
-				if (!p1)
-					p1 = ptr;
-				p2 = ptr;
-				break;
-			}
-
-			if (*ptr == '\r') {
-				if (p1) {
-					msg->err_pos = ptr - buf->data;
-					return -1;
-				}
-				p1 = ptr;
-			}
-
-			ptr++;
-			if (ptr >= buf->data + buf->size)
-				ptr = buf->data;
-		}
-
-		/* after LF; point to beginning of next line */
-		p2++;
-		if (p2 >= buf->data + buf->size)
-			p2 = buf->data;
-
-		bytes = p2 - buf->lr;
-		if (bytes < 0)
-			bytes += buf->size;
-
-		/* schedule this line for forwarding */
-		msg->sov += bytes;
-		if (msg->sov >= buf->size)
-			msg->sov -= buf->size;
-
-		if (p1 == buf->lr) {
-			/* LF/CRLF at beginning of line => end of trailers at p2.
-			 * Everything was scheduled for forwarding, there's nothing
-			 * left from this message.
-			 */
-			buf->lr = p2;
-			msg->msg_state = HTTP_MSG_DONE;
-			return 1;
-		}
-		/* OK, next line then */
-		buf->lr = p2;
-	}
-}
-
-/* This function may be called only in HTTP_MSG_DATA_CRLF. It reads the CRLF or
- * a possible LF alone at the end of a chunk. It automatically adjusts msg->sov,
- * ->som, buf->lr in order to include this part into the next forwarding phase.
- * It also sets msg_state to HTTP_MSG_CHUNK_SIZE and returns >0 on success. If
- * not enough data are available, the function does not change anything and
- * returns zero. If a parse error is encountered, the function returns < 0 and
- * does not change anything. Note: this function is designed to parse wrapped
- * CRLF at the end of the buffer.
- */
-int http_skip_chunk_crlf(struct buffer *buf, struct http_msg *msg)
-{
-	char *ptr;
-	int bytes;
-
-	/* NB: we'll check data availabilty at the end. It's not a
-	 * problem because whatever we match first will be checked
-	 * against the correct length.
-	 */
-	bytes = 1;
-	ptr = buf->lr;
-	if (*ptr == '\r') {
-		bytes++;
-		ptr++;
-		if (ptr >= buf->data + buf->size)
-			ptr = buf->data;
-	}
-
-	if (bytes > buf->l - buf->send_max)
-		return 0;
-
-	if (*ptr != '\n') {
-		msg->err_pos = ptr - buf->data;
-		return -1;
-	}
-
-	ptr++;
-	if (ptr >= buf->data + buf->size)
-		ptr = buf->data;
-	buf->lr = ptr;
-	/* prepare the CRLF to be forwarded. msg->som may be before data but we don't care */
-	msg->sov = ptr - buf->data;
-	msg->som = msg->sov - bytes;
-	msg->msg_state = HTTP_MSG_CHUNK_SIZE;
-	return 1;
-}
-
-void http_buffer_heavy_realign(struct buffer *buf, struct http_msg *msg)
-{
-	char *end = buf->data + buf->size;
-	int off = buf->data + buf->size - buf->w;
-
-	/* two possible cases :
-	 *   - the buffer is in one contiguous block, we move it in-place
-	 *   - the buffer is in two blocks, we move it via the swap_buffer
-	 */
-	if (buf->l) {
-		int block1 = buf->l;
-		int block2 = 0;
-		if (buf->r <= buf->w) {
-			/* non-contiguous block */
-			block1 = buf->data + buf->size - buf->w;
-			block2 = buf->r - buf->data;
-		}
-		if (block2)
-			memcpy(swap_buffer, buf->data, block2);
-		memmove(buf->data, buf->w, block1);
-		if (block2)
-			memcpy(buf->data + block1, swap_buffer, block2);
-	}
-
-	/* adjust all known pointers */
-	buf->w    = buf->data;
-	buf->lr  += off; if (buf->lr  >= end) buf->lr  -= buf->size;
-	buf->r   += off; if (buf->r   >= end) buf->r   -= buf->size;
-	msg->sol += off; if (msg->sol >= end) msg->sol -= buf->size;
-	msg->eol += off; if (msg->eol >= end) msg->eol -= buf->size;
-
-	/* adjust relative pointers */
-	msg->som  = 0;
-	msg->eoh += off; if (msg->eoh >= buf->size) msg->eoh -= buf->size;
-	msg->sov += off; if (msg->sov >= buf->size) msg->sov -= buf->size;
-
-	if (msg->err_pos >= 0) {
-		msg->err_pos += off;
-		if (msg->err_pos >= buf->size)
-			msg->err_pos -= buf->size;
-	}
-
-	buf->flags &= ~BF_FULL;
-	if (buf->l >= buffer_max_len(buf))
-		buf->flags |= BF_FULL;
-}
-
-/* This stream analyser waits for a complete HTTP request. It returns 1 if the
- * processing can continue on next analysers, or zero if it either needs more
- * data or wants to immediately abort the request (eg: timeout, error, ...). It
- * is tied to AN_REQ_WAIT_HTTP and may may remove itself from s->req->analysers
- * when it has nothing left to do, and may remove any analyser when it wants to
- * abort.
- */
-int http_wait_for_request(struct session *s, struct buffer *req, int an_bit)
-{
-	/*
-	 * We will parse the partial (or complete) lines.
-	 * We will check the request syntax, and also join multi-line
-	 * headers. An index of all the lines will be elaborated while
-	 * parsing.
-	 *
-	 * For the parsing, we use a 28 states FSM.
-	 *
-	 * Here is the information we currently have :
-	 *   req->data + msg->som  = beginning of request
-	 *   req->data + msg->eoh  = end of processed headers / start of current one
-	 *   msg->eol              = end of current header or line (LF or CRLF)
-	 *   req->lr = first non-visited byte
-	 *   req->r  = end of data
-	 *
-	 * At end of parsing, we may perform a capture of the error (if any), and
-	 * we will set a few fields (msg->sol, txn->meth, sn->flags/SN_REDIRECTABLE).
-	 * We also check for monitor-uri, logging, HTTP/0.9 to 1.0 conversion, and
-	 * finally headers capture.
-	 */
-
-	int cur_idx;
-	int use_close_only;
-	struct http_txn *txn = &s->txn;
-	struct http_msg *msg = &txn->req;
-	struct hdr_ctx ctx;
-
-	DPRINTF(stderr,"[%u] %s: session=%p b=%p, exp(r,w)=%u,%u bf=%08x bl=%d analysers=%02x\n",
-		now_ms, __FUNCTION__,
-		s,
-		req,
-		req->rex, req->wex,
-		req->flags,
-		req->l,
-		req->analysers);
-
-	/* we're speaking HTTP here, so let's speak HTTP to the client */
-	s->srv_error = http_return_srv_error;
-
-	/* There's a protected area at the end of the buffer for rewriting
-	 * purposes. We don't want to start to parse the request if the
-	 * protected area is affected, because we may have to move processed
-	 * data later, which is much more complicated.
-	 */
-	if (req->l && msg->msg_state < HTTP_MSG_ERROR) {
-		if ((txn->flags & TX_NOT_FIRST) &&
-		    unlikely((req->flags & BF_FULL) ||
-			     req->r < req->lr ||
-			     req->r > req->data + req->size - global.tune.maxrewrite)) {
-			if (req->send_max) {
-				if (req->flags & (BF_SHUTW|BF_SHUTW_NOW|BF_WRITE_ERROR|BF_WRITE_TIMEOUT))
-					goto failed_keep_alive;
-				/* some data has still not left the buffer, wake us once that's done */
-				buffer_dont_connect(req);
-				req->flags |= BF_READ_DONTWAIT; /* try to get back here ASAP */
-				return 0;
-			}
-			if (req->l <= req->size - global.tune.maxrewrite)
-				http_buffer_heavy_realign(req, msg);
-		}
-
-		/* Note that we have the same problem with the response ; we
-		 * may want to send a redirect, error or anything which requires
-		 * some spare space. So we'll ensure that we have at least
-		 * maxrewrite bytes available in the response buffer before
-		 * processing that one. This will only affect pipelined
-		 * keep-alive requests.
-		 */
-		if ((txn->flags & TX_NOT_FIRST) &&
-		    unlikely((s->rep->flags & BF_FULL) ||
-			     s->rep->r < s->rep->lr ||
-			     s->rep->r > s->rep->data + s->rep->size - global.tune.maxrewrite)) {
-			if (s->rep->send_max) {
-				if (s->rep->flags & (BF_SHUTW|BF_SHUTW_NOW|BF_WRITE_ERROR|BF_WRITE_TIMEOUT))
-					goto failed_keep_alive;
-				/* don't let a connection request be initiated */
-				buffer_dont_connect(req);
-				s->rep->flags &= ~BF_EXPECT_MORE; /* speed up sending a previous response */
-				return 0;
-			}
-		}
-
-		if (likely(req->lr < req->r))
-			http_msg_analyzer(req, msg, &txn->hdr_idx);
-	}
-
-	/* 1: we might have to print this header in debug mode */
-	if (unlikely((global.mode & MODE_DEBUG) &&
-		     (!(global.mode & MODE_QUIET) || (global.mode & MODE_VERBOSE)) &&
-		     msg->sol &&
-		     (msg->msg_state >= HTTP_MSG_BODY || msg->msg_state == HTTP_MSG_ERROR))) {
-		char *eol, *sol;
-
-		sol = req->data + msg->som;
-		eol = sol + msg->sl.rq.l;
-		debug_hdr("clireq", s, sol, eol);
-
-		sol += hdr_idx_first_pos(&txn->hdr_idx);
-		cur_idx = hdr_idx_first_idx(&txn->hdr_idx);
-
-		while (cur_idx) {
-			eol = sol + txn->hdr_idx.v[cur_idx].len;
-			debug_hdr("clihdr", s, sol, eol);
-			sol = eol + txn->hdr_idx.v[cur_idx].cr + 1;
-			cur_idx = txn->hdr_idx.v[cur_idx].next;
-		}
-	}
-
-
-	/*
-	 * Now we quickly check if we have found a full valid request.
-	 * If not so, we check the FD and buffer states before leaving.
-	 * A full request is indicated by the fact that we have seen
-	 * the double LF/CRLF, so the state is >= HTTP_MSG_BODY. Invalid
-	 * requests are checked first. When waiting for a second request
-	 * on a keep-alive session, if we encounter and error, close, t/o,
-	 * we note the error in the session flags but don't set any state.
-	 * Since the error will be noted there, it will not be counted by
-	 * process_session() as a frontend error.
-	 */
-
-	if (unlikely(msg->msg_state < HTTP_MSG_BODY)) {
-		/*
-		 * First, let's catch bad requests.
-		 */
-		if (unlikely(msg->msg_state == HTTP_MSG_ERROR)) {
-			proxy_inc_fe_req_ctr(s->fe);
-			goto return_bad_req;
-		}
-
-		/* 1: Since we are in header mode, if there's no space
-		 *    left for headers, we won't be able to free more
-		 *    later, so the session will never terminate. We
-		 *    must terminate it now.
-		 */
-		if (unlikely(req->flags & BF_FULL)) {
-			/* FIXME: check if URI is set and return Status
-			 * 414 Request URI too long instead.
-			 */
-			proxy_inc_fe_req_ctr(s->fe);
-			if (msg->err_pos < 0)
-				msg->err_pos = req->l;
-			goto return_bad_req;
-		}
-
-		/* 2: have we encountered a read error ? */
-		else if (req->flags & BF_READ_ERROR) {
-			if (!(s->flags & SN_ERR_MASK))
-				s->flags |= SN_ERR_CLICL;
-
-			if (txn->flags & TX_WAIT_NEXT_RQ)
-				goto failed_keep_alive;
-
-			/* we cannot return any message on error */
-			if (msg->err_pos >= 0)
-				http_capture_bad_message(&s->fe->invalid_req, s, req, msg, msg->msg_state, s->fe);
-
-			msg->msg_state = HTTP_MSG_ERROR;
-			req->analysers = 0;
-
-			proxy_inc_fe_req_ctr(s->fe);
-			s->fe->counters.failed_req++;
-			if (s->listener->counters)
-				s->listener->counters->failed_req++;
-
-			if (!(s->flags & SN_FINST_MASK))
-				s->flags |= SN_FINST_R;
-			return 0;
-		}
-
-		/* 3: has the read timeout expired ? */
-		else if (req->flags & BF_READ_TIMEOUT || tick_is_expired(req->analyse_exp, now_ms)) {
-			if (!(s->flags & SN_ERR_MASK))
-				s->flags |= SN_ERR_CLITO;
-
-			if (txn->flags & TX_WAIT_NEXT_RQ)
-				goto failed_keep_alive;
-
-			/* read timeout : give up with an error message. */
-			if (msg->err_pos >= 0)
-				http_capture_bad_message(&s->fe->invalid_req, s, req, msg, msg->msg_state, s->fe);
-			txn->status = 408;
-			stream_int_retnclose(req->prod, error_message(s, HTTP_ERR_408));
-			msg->msg_state = HTTP_MSG_ERROR;
-			req->analysers = 0;
-
-			proxy_inc_fe_req_ctr(s->fe);
-			s->fe->counters.failed_req++;
-			if (s->listener->counters)
-				s->listener->counters->failed_req++;
-
-			if (!(s->flags & SN_FINST_MASK))
-				s->flags |= SN_FINST_R;
-			return 0;
-		}
-
-		/* 4: have we encountered a close ? */
-		else if (req->flags & BF_SHUTR) {
-			if (!(s->flags & SN_ERR_MASK))
-				s->flags |= SN_ERR_CLICL;
-
-			if (txn->flags & TX_WAIT_NEXT_RQ)
-				goto failed_keep_alive;
-
-			if (msg->err_pos >= 0)
-				http_capture_bad_message(&s->fe->invalid_req, s, req, msg, msg->msg_state, s->fe);
-			txn->status = 400;
-			stream_int_retnclose(req->prod, error_message(s, HTTP_ERR_400));
-			msg->msg_state = HTTP_MSG_ERROR;
-			req->analysers = 0;
-
-			proxy_inc_fe_req_ctr(s->fe);
-			s->fe->counters.failed_req++;
-			if (s->listener->counters)
-				s->listener->counters->failed_req++;
-
-			if (!(s->flags & SN_FINST_MASK))
-				s->flags |= SN_FINST_R;
-			return 0;
-		}
-
-		buffer_dont_connect(req);
-		req->flags |= BF_READ_DONTWAIT; /* try to get back here ASAP */
-		s->rep->flags &= ~BF_EXPECT_MORE; /* speed up sending a previous response */
-#ifdef TCP_QUICKACK
-		if (s->listener->options & LI_O_NOQUICKACK) {
-			/* We need more data, we have to re-enable quick-ack in case we
-			 * previously disabled it, otherwise we might cause the client
-			 * to delay next data.
-			 */
-			setsockopt(s->si[0].fd, IPPROTO_TCP, TCP_QUICKACK, &one, sizeof(one));
-		}
-#endif
-
-		if ((msg->msg_state != HTTP_MSG_RQBEFORE) && (txn->flags & TX_WAIT_NEXT_RQ)) {
-			/* If the client starts to talk, let's fall back to
-			 * request timeout processing.
-			 */
-			txn->flags &= ~TX_WAIT_NEXT_RQ;
-			req->analyse_exp = TICK_ETERNITY;
-		}
-
-		/* just set the request timeout once at the beginning of the request */
-		if (!tick_isset(req->analyse_exp)) {
-			if ((msg->msg_state == HTTP_MSG_RQBEFORE) &&
-			    (txn->flags & TX_WAIT_NEXT_RQ) &&
-			    tick_isset(s->be->timeout.httpka))
-				req->analyse_exp = tick_add(now_ms, s->be->timeout.httpka);
-			else
-				req->analyse_exp = tick_add_ifset(now_ms, s->be->timeout.httpreq);
-		}
-
-		/* we're not ready yet */
-		return 0;
-
-	failed_keep_alive:
-		/* Here we process low-level errors for keep-alive requests. In
-		 * short, if the request is not the first one and it experiences
-		 * a timeout, read error or shutdown, we just silently close so
-		 * that the client can try again.
-		 */
-		txn->status = 0;
-		msg->msg_state = HTTP_MSG_RQBEFORE;
-		req->analysers = 0;
-		s->logs.logwait = 0;
-		s->rep->flags &= ~BF_EXPECT_MORE; /* speed up sending a previous response */
-		stream_int_retnclose(req->prod, NULL);
-		return 0;
-	}
-
-	/* OK now we have a complete HTTP request with indexed headers. Let's
-	 * complete the request parsing by setting a few fields we will need
-	 * later. At this point, we have the last CRLF at req->data + msg->eoh.
-	 * If the request is in HTTP/0.9 form, the rule is still true, and eoh
-	 * points to the CRLF of the request line. req->lr points to the first
-	 * byte after the last LF. msg->sov points to the first
-	 * byte of data. msg->eol cannot be trusted because it may have been
-	 * left uninitialized (for instance in the absence of headers).
-	 */
-
-	proxy_inc_fe_req_ctr(s->fe); /* one more valid request for this FE */
-
-	if (txn->flags & TX_WAIT_NEXT_RQ) {
-		/* kill the pending keep-alive timeout */
-		txn->flags &= ~TX_WAIT_NEXT_RQ;
-		req->analyse_exp = TICK_ETERNITY;
-	}
-
-
-	/* Maybe we found in invalid header name while we were configured not
-	 * to block on that, so we have to capture it now.
-	 */
-	if (unlikely(msg->err_pos >= 0))
-		http_capture_bad_message(&s->fe->invalid_req, s, req, msg, msg->msg_state, s->fe);
-
-	/*
-	 * 1: identify the method
-	 */
-	txn->meth = find_http_meth(msg->sol, msg->sl.rq.m_l);
-
-	/* we can make use of server redirect on GET and HEAD */
-	if (txn->meth == HTTP_METH_GET || txn->meth == HTTP_METH_HEAD)
-		s->flags |= SN_REDIRECTABLE;
-
-	/*
-	 * 2: check if the URI matches the monitor_uri.
-	 * We have to do this for every request which gets in, because
-	 * the monitor-uri is defined by the frontend.
-	 */
-	if (unlikely((s->fe->monitor_uri_len != 0) &&
-		     (s->fe->monitor_uri_len == msg->sl.rq.u_l) &&
-		     !memcmp(msg->sol + msg->sl.rq.u,
-			     s->fe->monitor_uri,
-			     s->fe->monitor_uri_len))) {
-		/*
-		 * We have found the monitor URI
-		 */
-		struct acl_cond *cond;
-
-		s->flags |= SN_MONITOR;
-
-		/* Check if we want to fail this monitor request or not */
-		list_for_each_entry(cond, &s->fe->mon_fail_cond, list) {
-			int ret = acl_exec_cond(cond, s->fe, s, txn, ACL_DIR_REQ);
-
-			ret = acl_pass(ret);
-			if (cond->pol == ACL_COND_UNLESS)
-				ret = !ret;
-
-			if (ret) {
-				/* we fail this request, let's return 503 service unavail */
-				txn->status = 503;
-				stream_int_retnclose(req->prod, error_message(s, HTTP_ERR_503));
-				goto return_prx_cond;
-			}
-		}
-
-		/* nothing to fail, let's reply normaly */
-		txn->status = 200;
-		stream_int_retnclose(req->prod, error_message(s, HTTP_ERR_200));
-		goto return_prx_cond;
-	}
-
-	/*
-	 * 3: Maybe we have to copy the original REQURI for the logs ?
-	 * Note: we cannot log anymore if the request has been
-	 * classified as invalid.
-	 */
-	if (unlikely(s->logs.logwait & LW_REQ)) {
-		/* we have a complete HTTP request that we must log */
-		if ((txn->uri = pool_alloc2(pool2_requri)) != NULL) {
-			int urilen = msg->sl.rq.l;
-
-			if (urilen >= REQURI_LEN)
-				urilen = REQURI_LEN - 1;
-			memcpy(txn->uri, &req->data[msg->som], urilen);
-			txn->uri[urilen] = 0;
-
-			if (!(s->logs.logwait &= ~LW_REQ))
-				s->do_log(s);
-		} else {
-			Alert("HTTP logging : out of memory.\n");
-		}
-	}
-
-	/* 4. We may have to convert HTTP/0.9 requests to HTTP/1.0 */
-	if (unlikely(msg->sl.rq.v_l == 0) && !http_upgrade_v09_to_v10(req, msg, txn))
-		goto return_bad_req;
-
-	/* ... and check if the request is HTTP/1.1 or above */
-	if ((msg->sl.rq.v_l == 8) &&
-	    ((msg->sol[msg->sl.rq.v + 5] > '1') ||
-	     ((msg->sol[msg->sl.rq.v + 5] == '1') &&
-	      (msg->sol[msg->sl.rq.v + 7] >= '1'))))
-		txn->flags |= TX_REQ_VER_11;
-
-	/* "connection" has not been parsed yet */
-	txn->flags &= ~(TX_HDR_CONN_PRS | TX_HDR_CONN_CLO | TX_HDR_CONN_KAL);
-
-	/* if the frontend has "option http-use-proxy-header", we'll check if
-	 * we have what looks like a proxied connection instead of a connection,
-	 * and in this case set the TX_USE_PX_CONN flag to use Proxy-connection.
-	 * Note that this is *not* RFC-compliant, however browsers and proxies
-	 * happen to do that despite being non-standard :-(
-	 * We consider that a request not beginning with either '/' or '*' is
-	 * a proxied connection, which covers both "scheme://location" and
-	 * CONNECT ip:port.
-	 */
-	if ((s->fe->options2 & PR_O2_USE_PXHDR) &&
-	    msg->sol[msg->sl.rq.u] != '/' && msg->sol[msg->sl.rq.u] != '*')
-		txn->flags |= TX_USE_PX_CONN;
-
-	/* transfer length unknown*/
-	txn->flags &= ~TX_REQ_XFER_LEN;
-
-	/* 5: we may need to capture headers */
-	if (unlikely((s->logs.logwait & LW_REQHDR) && txn->req.cap))
-		capture_headers(msg->sol, &txn->hdr_idx,
-				txn->req.cap, s->fe->req_cap);
-
-	/* 6: determine the transfer-length.
-	 * According to RFC2616 #4.4, amended by the HTTPbis working group,
-	 * the presence of a message-body in a REQUEST and its transfer length
-	 * must be determined that way (in order of precedence) :
-	 *   1. The presence of a message-body in a request is signaled by the
-	 *      inclusion of a Content-Length or Transfer-Encoding header field
-	 *      in the request's header fields.  When a request message contains
-	 *      both a message-body of non-zero length and a method that does
-	 *      not define any semantics for that request message-body, then an
-	 *      origin server SHOULD either ignore the message-body or respond
-	 *      with an appropriate error message (e.g., 413).  A proxy or
-	 *      gateway, when presented the same request, SHOULD either forward
-	 *      the request inbound with the message- body or ignore the
-	 *      message-body when determining a response.
-	 *
-	 *   2. If a Transfer-Encoding header field (Section 9.7) is present
-	 *      and the "chunked" transfer-coding (Section 6.2) is used, the
-	 *      transfer-length is defined by the use of this transfer-coding.
-	 *      If a Transfer-Encoding header field is present and the "chunked"
-	 *      transfer-coding is not present, the transfer-length is defined
-	 *      by the sender closing the connection.
-	 *
-	 *   3. If a Content-Length header field is present, its decimal value in
-	 *      OCTETs represents both the entity-length and the transfer-length.
-	 *      If a message is received with both a Transfer-Encoding header
-	 *      field and a Content-Length header field, the latter MUST be ignored.
-	 *
-	 *   4. By the server closing the connection. (Closing the connection
-	 *      cannot be used to indicate the end of a request body, since that
-	 *      would leave no possibility for the server to send back a response.)
-	 *
-	 *   Whenever a transfer-coding is applied to a message-body, the set of
-	 *   transfer-codings MUST include "chunked", unless the message indicates
-	 *   it is terminated by closing the connection.  When the "chunked"
-	 *   transfer-coding is used, it MUST be the last transfer-coding applied
-	 *   to the message-body.
-	 */
-
-	use_close_only = 0;
-	ctx.idx = 0;
-	/* set TE_CHNK and XFER_LEN only if "chunked" is seen last */
-	while ((txn->flags & TX_REQ_VER_11) &&
-	       http_find_header2("Transfer-Encoding", 17, msg->sol, &txn->hdr_idx, &ctx)) {
-		if (ctx.vlen == 7 && strncasecmp(ctx.line + ctx.val, "chunked", 7) == 0)
-			txn->flags |= (TX_REQ_TE_CHNK | TX_REQ_XFER_LEN);
-		else if (txn->flags & TX_REQ_TE_CHNK) {
-			/* bad transfer-encoding (chunked followed by something else) */
-			use_close_only = 1;
-			txn->flags &= ~(TX_REQ_TE_CHNK | TX_REQ_XFER_LEN);
-			break;
-		}
-	}
-
-	ctx.idx = 0;
-	while (!(txn->flags & TX_REQ_TE_CHNK) && !use_close_only &&
-	       http_find_header2("Content-Length", 14, msg->sol, &txn->hdr_idx, &ctx)) {
-		signed long long cl;
-
-		if (!ctx.vlen) {
-			msg->err_pos = ctx.line + ctx.val - req->data;
-			goto return_bad_req;
-		}
-
-		if (strl2llrc(ctx.line + ctx.val, ctx.vlen, &cl)) {
-			msg->err_pos = ctx.line + ctx.val - req->data;
-			goto return_bad_req; /* parse failure */
-		}
-
-		if (cl < 0) {
-			msg->err_pos = ctx.line + ctx.val - req->data;
-			goto return_bad_req;
-		}
-
-		if ((txn->flags & TX_REQ_CNT_LEN) && (msg->chunk_len != cl)) {
-			msg->err_pos = ctx.line + ctx.val - req->data;
-			goto return_bad_req; /* already specified, was different */
-		}
-
-		txn->flags |= TX_REQ_CNT_LEN | TX_REQ_XFER_LEN;
-		msg->body_len = msg->chunk_len = cl;
-	}
-
-	/* bodyless requests have a known length */
-	if (!use_close_only)
-		txn->flags |= TX_REQ_XFER_LEN;
-
-	/* end of job, return OK */
-	req->analysers &= ~an_bit;
-	req->analyse_exp = TICK_ETERNITY;
-	return 1;
-
- return_bad_req:
-	/* We centralize bad requests processing here */
-	if (unlikely(msg->msg_state == HTTP_MSG_ERROR) || msg->err_pos >= 0) {
-		/* we detected a parsing error. We want to archive this request
-		 * in the dedicated proxy area for later troubleshooting.
-		 */
-		http_capture_bad_message(&s->fe->invalid_req, s, req, msg, msg->msg_state, s->fe);
-	}
-
-	txn->req.msg_state = HTTP_MSG_ERROR;
-	txn->status = 400;
-	stream_int_retnclose(req->prod, error_message(s, HTTP_ERR_400));
-
-	s->fe->counters.failed_req++;
-	if (s->listener->counters)
-		s->listener->counters->failed_req++;
-
- return_prx_cond:
-	if (!(s->flags & SN_ERR_MASK))
-		s->flags |= SN_ERR_PRXCOND;
-	if (!(s->flags & SN_FINST_MASK))
-		s->flags |= SN_FINST_R;
-
-	req->analysers = 0;
-	req->analyse_exp = TICK_ETERNITY;
-	return 0;
-}
-
-/* We reached the stats page through a POST request.
- * Parse the posted data and enable/disable servers if necessary.
- * Returns 1 if request was parsed or zero if it needs more data.
- */
-int http_process_req_stat_post(struct session *s, struct buffer *req)
-{
-	struct http_txn *txn = &s->txn;
-	struct proxy *px = NULL;
-	struct server *sv = NULL;
-
-	char key[LINESIZE];
-	int action = ST_ADM_ACTION_NONE;
-	int reprocess = 0;
-
-	int total_servers = 0;
-	int altered_servers = 0;
-
-	char *first_param, *cur_param, *next_param, *end_params;
-	char *st_cur_param = NULL;
-	char *st_next_param = NULL;
-
-	first_param = req->data + txn->req.eoh + 2;
-	end_params  = first_param + txn->req.body_len;
-
-	cur_param = next_param = end_params;
-
-	if (end_params >= req->data + req->size - global.tune.maxrewrite) {
-		/* Prevent buffer overflow */
-		s->data_ctx.stats.st_code = STAT_STATUS_EXCD;
-		return 1;
-	}
-	else if (end_params > req->data + req->l) {
-		/* we need more data */
-		s->data_ctx.stats.st_code = STAT_STATUS_NONE;
-		return 0;
-	}
-
-	*end_params = '\0';
-
-	s->data_ctx.stats.st_code = STAT_STATUS_NONE;
-
-	/*
-	 * Parse the parameters in reverse order to only store the last value.
-	 * From the html form, the backend and the action are at the end.
-	 */
-	while (cur_param > first_param) {
-		char *value;
-		int poffset, plen;
-
-		cur_param--;
-		if ((*cur_param == '&') || (cur_param == first_param)) {
- reprocess_servers:
-			/* Parse the key */
-			poffset = (cur_param != first_param ? 1 : 0);
-			plen = next_param - cur_param + (cur_param == first_param ? 1 : 0);
-			if ((plen > 0) && (plen <= sizeof(key))) {
-				strncpy(key, cur_param + poffset, plen);
-				key[plen - 1] = '\0';
-			} else {
-				s->data_ctx.stats.st_code = STAT_STATUS_EXCD;
-				goto out;
-			}
-
-			/* Parse the value */
-			value = key;
-			while (*value != '\0' && *value != '=') {
-				value++;
-			}
-			if (*value == '=') {
-				/* Ok, a value is found, we can mark the end of the key */
-				*value++ = '\0';
-			}
-
-			if (!url_decode(key) || !url_decode(value))
-				break;
-
-			/* Now we can check the key to see what to do */
-			if (!px && (strcmp(key, "b") == 0)) {
-				if ((px = findproxy(value, PR_CAP_BE)) == NULL) {
-					/* the backend name is unknown or ambiguous (duplicate names) */
-					s->data_ctx.stats.st_code = STAT_STATUS_ERRP;
-					goto out;
-				}
-			}
-			else if (!action && (strcmp(key, "action") == 0)) {
-				if (strcmp(value, "disable") == 0) {
-					action = ST_ADM_ACTION_DISABLE;
-				}
-				else if (strcmp(value, "enable") == 0) {
-					action = ST_ADM_ACTION_ENABLE;
-				}
-				else {
-					s->data_ctx.stats.st_code = STAT_STATUS_ERRP;
-					goto out;
-				}
-			}
-			else if (strcmp(key, "s") == 0) {
-				if (!(px && action)) {
-					/*
-					 * Indicates that we'll need to reprocess the parameters
-					 * as soon as backend and action are known
-					 */
-					if (!reprocess) {
-						st_cur_param  = cur_param;
-						st_next_param = next_param;
-					}
-					reprocess = 1;
-				}
-				else if ((sv = findserver(px, value)) != NULL) {
-					switch (action) {
-					case ST_ADM_ACTION_DISABLE:
-						if ((px->state != PR_STSTOPPED) && !(sv->state & SRV_MAINTAIN)) {
-							/* Not already in maintenance, we can change the server state */
-							sv->state |= SRV_MAINTAIN;
-							set_server_down(sv);
-							altered_servers++;
-							total_servers++;
-						}
-						break;
-					case ST_ADM_ACTION_ENABLE:
-						if ((px->state != PR_STSTOPPED) && (sv->state & SRV_MAINTAIN)) {
-							/* Already in maintenance, we can change the server state */
-							set_server_up(sv);
-							sv->health = sv->rise;	/* up, but will fall down at first failure */
-							altered_servers++;
-							total_servers++;
-						}
-						break;
-					}
-				} else {
-					/* the server name is unknown or ambiguous (duplicate names) */
-					total_servers++;
-				}
-			}
-			if (reprocess && px && action) {
-				/* Now, we know the backend and the action chosen by the user.
-				 * We can safely restart from the first server parameter
-				 * to reprocess them
-				 */
-				cur_param  = st_cur_param;
-				next_param = st_next_param;
-				reprocess = 0;
-				goto reprocess_servers;
-			}
-
-			next_param = cur_param;
-		}
-	}
-
-	if (total_servers == 0) {
-		s->data_ctx.stats.st_code = STAT_STATUS_NONE;
-	}
-	else if (altered_servers == 0) {
-		s->data_ctx.stats.st_code = STAT_STATUS_ERRP;
-	}
-	else if (altered_servers == total_servers) {
-		s->data_ctx.stats.st_code = STAT_STATUS_DONE;
-	}
-	else {
-		s->data_ctx.stats.st_code = STAT_STATUS_PART;
-	}
- out:
-	return 1;
-}
-
-/* This stream analyser runs all HTTP request processing which is common to
- * frontends and backends, which means blocking ACLs, filters, connection-close,
- * reqadd, stats and redirects. This is performed for the designated proxy.
- * It returns 1 if the processing can continue on next analysers, or zero if it
- * either needs more data or wants to immediately abort the request (eg: deny,
- * error, ...).
- */
-int http_process_req_common(struct session *s, struct buffer *req, int an_bit, struct proxy *px)
-{
-	struct http_txn *txn = &s->txn;
-	struct http_msg *msg = &txn->req;
-	struct acl_cond *cond;
-	struct req_acl_rule *req_acl, *req_acl_final = NULL;
-	struct redirect_rule *rule;
-	struct cond_wordlist *wl;
-	int do_stats;
-
-	if (unlikely(msg->msg_state < HTTP_MSG_BODY)) {
-		/* we need more data */
-		buffer_dont_connect(req);
-		return 0;
-	}
-
-	req->analysers &= ~an_bit;
-	req->analyse_exp = TICK_ETERNITY;
-
-	DPRINTF(stderr,"[%u] %s: session=%p b=%p, exp(r,w)=%u,%u bf=%08x bl=%d analysers=%02x\n",
-		now_ms, __FUNCTION__,
-		s,
-		req,
-		req->rex, req->wex,
-		req->flags,
-		req->l,
-		req->analysers);
-
-	/* first check whether we have some ACLs set to block this request */
-	list_for_each_entry(cond, &px->block_cond, list) {
-		int ret = acl_exec_cond(cond, px, s, txn, ACL_DIR_REQ);
-
-		ret = acl_pass(ret);
-		if (cond->pol == ACL_COND_UNLESS)
-			ret = !ret;
-
-		if (ret) {
-			txn->status = 403;
-			/* let's log the request time */
-			s->logs.tv_request = now;
-			stream_int_retnclose(req->prod, error_message(s, HTTP_ERR_403));
-			goto return_prx_cond;
-		}
-	}
-
-	do_stats = stats_check_uri(s, px);
-
-	list_for_each_entry(req_acl, (do_stats?&px->uri_auth->req_acl:&px->req_acl), list) {
-		int ret = 1;
-
-		if (req_acl->action >= PR_REQ_ACL_ACT_MAX)
-			continue;
-
-		/* check condition, but only if attached */
-		if (req_acl->cond) {
-			ret = acl_exec_cond(req_acl->cond, px, s, txn, ACL_DIR_REQ);
-			ret = acl_pass(ret);
-
-			if (req_acl->cond->pol == ACL_COND_UNLESS)
-				ret = !ret;
-		}
-
-		if (ret) {
-			req_acl_final = req_acl;
-			break;
-		}
-	}
-
-	if (req_acl_final && req_acl_final->action == PR_REQ_ACL_ACT_DENY) {
-			txn->status = 403;
-			s->logs.tv_request = now;
-			stream_int_retnclose(req->prod, error_message(s, HTTP_ERR_403));
-			goto return_prx_cond;
-	}
-
-	/* try headers filters */
-	if (px->req_exp != NULL) {
-		if (apply_filters_to_request(s, req, px) < 0)
-			goto return_bad_req;
-
-		/* has the request been denied ? */
-		if (txn->flags & TX_CLDENY) {
-			/* no need to go further */
-			txn->status = 403;
-			/* let's log the request time */
-			s->logs.tv_request = now;
-			stream_int_retnclose(req->prod, error_message(s, HTTP_ERR_403));
-			goto return_prx_cond;
-		}
-
-		/* When a connection is tarpitted, we use the tarpit timeout,
-		 * which may be the same as the connect timeout if unspecified.
-		 * If unset, then set it to zero because we really want it to
-		 * eventually expire. We build the tarpit as an analyser.
-		 */
-		if (txn->flags & TX_CLTARPIT) {
-			buffer_erase(s->req);
-			/* wipe the request out so that we can drop the connection early
-			 * if the client closes first.
-			 */
-			buffer_dont_connect(req);
-			req->analysers = 0; /* remove switching rules etc... */
-			req->analysers |= AN_REQ_HTTP_TARPIT;
-			req->analyse_exp = tick_add_ifset(now_ms,  s->be->timeout.tarpit);
-			if (!req->analyse_exp)
-				req->analyse_exp = tick_add(now_ms, 0);
-			return 1;
-		}
-	}
-
-	/* Until set to anything else, the connection mode is set as TUNNEL. It will
-	 * only change if both the request and the config reference something else.
-	 * Option httpclose by itself does not set a mode, it remains a tunnel mode
-	 * in which headers are mangled. However, if another mode is set, it will
-	 * affect it (eg: server-close/keep-alive + httpclose = close). Note that we
-	 * avoid to redo the same work if FE and BE have the same settings (common).
-	 * The method consists in checking if options changed between the two calls
-	 * (implying that either one is non-null, or one of them is non-null and we
-	 * are there for the first time.
-	 */
-
-	if ((!(txn->flags & TX_HDR_CONN_PRS) &&
-	     (s->fe->options & (PR_O_KEEPALIVE|PR_O_SERVER_CLO|PR_O_HTTP_CLOSE|PR_O_FORCE_CLO))) ||
-	    ((s->fe->options & (PR_O_KEEPALIVE|PR_O_SERVER_CLO|PR_O_HTTP_CLOSE|PR_O_FORCE_CLO)) !=
-	     (s->be->options & (PR_O_KEEPALIVE|PR_O_SERVER_CLO|PR_O_HTTP_CLOSE|PR_O_FORCE_CLO)))) {
-		int tmp = TX_CON_WANT_TUN;
-
-		if ((s->fe->options|s->be->options) & PR_O_KEEPALIVE ||
-		    ((s->fe->options2|s->be->options2) & PR_O2_FAKE_KA))
-			tmp = TX_CON_WANT_KAL;
-		if ((s->fe->options|s->be->options) & PR_O_SERVER_CLO)
-			tmp = TX_CON_WANT_SCL;
-		if ((s->fe->options|s->be->options) & PR_O_FORCE_CLO)
-			tmp = TX_CON_WANT_CLO;
-
-		if ((txn->flags & TX_CON_WANT_MSK) < tmp)
-			txn->flags = (txn->flags & ~TX_CON_WANT_MSK) | tmp;
-
-		if (!(txn->flags & TX_HDR_CONN_PRS)) {
-			/* parse the Connection header and possibly clean it */
-			int to_del = 0;
-			if ((txn->flags & TX_REQ_VER_11) ||
-			    ((txn->flags & TX_CON_WANT_MSK) >= TX_CON_WANT_SCL &&
-			     !((s->fe->options2|s->be->options2) & PR_O2_FAKE_KA)))
-				to_del |= 2; /* remove "keep-alive" */
-			if (!(txn->flags & TX_REQ_VER_11))
-				to_del |= 1; /* remove "close" */
-			http_parse_connection_header(txn, msg, req, to_del);
-		}
-
-		/* check if client or config asks for explicit close in KAL/SCL */
-		if (((txn->flags & TX_CON_WANT_MSK) == TX_CON_WANT_KAL ||
-		     (txn->flags & TX_CON_WANT_MSK) == TX_CON_WANT_SCL) &&
-		    ((txn->flags & TX_HDR_CONN_CLO) ||                         /* "connection: close" */
-		     (txn->flags & (TX_REQ_VER_11|TX_HDR_CONN_KAL)) == 0 ||    /* no "connection: k-a" in 1.0 */
-		     ((s->fe->options|s->be->options) & PR_O_HTTP_CLOSE) ||    /* httpclose+any = forceclose */
-		     !(txn->flags & TX_REQ_XFER_LEN) ||                        /* no length known => close */
-		     s->fe->state == PR_STSTOPPED))                            /* frontend is stopping */
-		    txn->flags = (txn->flags & ~TX_CON_WANT_MSK) | TX_CON_WANT_CLO;
-	}
-
-	/* add request headers from the rule sets in the same order */
-	list_for_each_entry(wl, &px->req_add, list) {
-		if (wl->cond) {
-			int ret = acl_exec_cond(wl->cond, px, s, txn, ACL_DIR_REQ);
-			ret = acl_pass(ret);
-			if (((struct acl_cond *)wl->cond)->pol == ACL_COND_UNLESS)
-				ret = !ret;
-			if (!ret)
-				continue;
-		}
-
-		if (unlikely(http_header_add_tail(req, &txn->req, &txn->hdr_idx, wl->s) < 0))
-			goto return_bad_req;
-	}
-
-	if (req_acl_final && req_acl_final->action == PR_REQ_ACL_ACT_HTTP_AUTH) {
-		struct chunk msg;
-		char *realm = req_acl_final->http_auth.realm;
-
-		if (!realm)
-			realm = do_stats?STATS_DEFAULT_REALM:px->id;
-
-		sprintf(trash, (txn->flags & TX_USE_PX_CONN) ? HTTP_407_fmt : HTTP_401_fmt, realm);
-		chunk_initlen(&msg, trash, trashlen, strlen(trash));
-		txn->status = 401;
-		stream_int_retnclose(req->prod, &msg);
-		goto return_prx_cond;
-	}
-
-	if (do_stats) {
-		struct stats_admin_rule *stats_admin_rule;
-
-		/* We need to provide stats for this request.
-		 * FIXME!!! that one is rather dangerous, we want to
-		 * make it follow standard rules (eg: clear req->analysers).
-		 */
-
-		/* now check whether we have some admin rules for this request */
-		list_for_each_entry(stats_admin_rule, &s->be->uri_auth->admin_rules, list) {
-			int ret = 1;
-
-			if (stats_admin_rule->cond) {
-				ret = acl_exec_cond(stats_admin_rule->cond, s->be, s, &s->txn, ACL_DIR_REQ);
-				ret = acl_pass(ret);
-				if (stats_admin_rule->cond->pol == ACL_COND_UNLESS)
-					ret = !ret;
-			}
-
-			if (ret) {
-				/* no rule, or the rule matches */
-				s->data_ctx.stats.flags |= STAT_ADMIN;
-				break;
-			}
-		}
-
-		/* Was the status page requested with a POST ? */
-		if (txn->meth == HTTP_METH_POST) {
-			if (s->data_ctx.stats.flags & STAT_ADMIN) {
-				if (msg->msg_state < HTTP_MSG_100_SENT) {
-					/* If we have HTTP/1.1 and Expect: 100-continue, then we must
-					 * send an HTTP/1.1 100 Continue intermediate response.
-					 */
-					if (txn->flags & TX_REQ_VER_11) {
-						struct hdr_ctx ctx;
-						ctx.idx = 0;
-						/* Expect is allowed in 1.1, look for it */
-						if (http_find_header2("Expect", 6, msg->sol, &txn->hdr_idx, &ctx) &&
-						    unlikely(ctx.vlen == 12 && strncasecmp(ctx.line+ctx.val, "100-continue", 12) == 0)) {
-							buffer_write(s->rep, http_100_chunk.str, http_100_chunk.len);
-						}
-					}
-					msg->msg_state = HTTP_MSG_100_SENT;
-					s->logs.tv_request = now;  /* update the request timer to reflect full request */
-				}
-				if (!http_process_req_stat_post(s, req)) {
-					/* we need more data */
-					req->analysers |= an_bit;
-					buffer_dont_connect(req);
-					return 0;
-				}
-			} else {
-				s->data_ctx.stats.st_code = STAT_STATUS_DENY;
-			}
-		}
-
-		s->logs.tv_request = now;
-		s->data_source = DATA_SRC_STATS;
-		s->data_state  = DATA_ST_INIT;
-		s->task->nice = -32; /* small boost for HTTP statistics */
-		stream_int_register_handler(s->rep->prod, http_stats_io_handler);
-		s->rep->prod->private = s;
-		s->rep->prod->st0 = s->rep->prod->st1 = 0;
-		req->analysers = 0;
-
-		return 0;
-
-	}
-
-	/* check whether we have some ACLs set to redirect this request */
-	list_for_each_entry(rule, &px->redirect_rules, list) {
-		int ret = ACL_PAT_PASS;
-
-		if (rule->cond) {
-			ret = acl_exec_cond(rule->cond, px, s, txn, ACL_DIR_REQ);
-			ret = acl_pass(ret);
-			if (rule->cond->pol == ACL_COND_UNLESS)
-				ret = !ret;
-		}
-
-		if (ret) {
-			struct chunk rdr = { .str = trash, .size = trashlen, .len = 0 };
-			const char *msg_fmt;
-
-			/* build redirect message */
-			switch(rule->code) {
-			case 303:
-				msg_fmt = HTTP_303;
-				break;
-			case 301:
-				msg_fmt = HTTP_301;
-				break;
-			case 302:
-			default:
-				msg_fmt = HTTP_302;
-				break;
-			}
-
-			if (unlikely(!chunk_strcpy(&rdr, msg_fmt)))
-				goto return_bad_req;
-
-			switch(rule->type) {
-			case REDIRECT_TYPE_PREFIX: {
-				const char *path;
-				int pathlen;
-
-				path = http_get_path(txn);
-				/* build message using path */
-				if (path) {
-					pathlen = txn->req.sl.rq.u_l + (txn->req.sol + txn->req.sl.rq.u) - path;
-					if (rule->flags & REDIRECT_FLAG_DROP_QS) {
-						int qs = 0;
-						while (qs < pathlen) {
-							if (path[qs] == '?') {
-								pathlen = qs;
-								break;
-							}
-							qs++;
-						}
-					}
-				} else {
-					path = "/";
-					pathlen = 1;
-				}
-
-				if (rdr.len + rule->rdr_len + pathlen > rdr.size - 4)
-					goto return_bad_req;
-
-				/* add prefix. Note that if prefix == "/", we don't want to
-				 * add anything, otherwise it makes it hard for the user to
-				 * configure a self-redirection.
-				 */
-				if (rule->rdr_len != 1 || *rule->rdr_str != '/') {
-					memcpy(rdr.str + rdr.len, rule->rdr_str, rule->rdr_len);
-					rdr.len += rule->rdr_len;
-				}
-
-				/* add path */
-				memcpy(rdr.str + rdr.len, path, pathlen);
-				rdr.len += pathlen;
-
-				/* append a slash at the end of the location is needed and missing */
-				if (rdr.len && rdr.str[rdr.len - 1] != '/' &&
-				    (rule->flags & REDIRECT_FLAG_APPEND_SLASH)) {
-					if (rdr.len > rdr.size - 5)
-						goto return_bad_req;
-					rdr.str[rdr.len] = '/';
-					rdr.len++;
-				}
-
-				break;
-			}
-			case REDIRECT_TYPE_LOCATION:
-			default:
-				if (rdr.len + rule->rdr_len > rdr.size - 4)
-					goto return_bad_req;
-
-				/* add location */
-				memcpy(rdr.str + rdr.len, rule->rdr_str, rule->rdr_len);
-				rdr.len += rule->rdr_len;
-				break;
-			}
-
-			if (rule->cookie_len) {
-				memcpy(rdr.str + rdr.len, "\r\nSet-Cookie: ", 14);
-				rdr.len += 14;
-				memcpy(rdr.str + rdr.len, rule->cookie_str, rule->cookie_len);
-				rdr.len += rule->cookie_len;
-				memcpy(rdr.str + rdr.len, "\r\n", 2);
-				rdr.len += 2;
-			}
-
-			/* add end of headers and the keep-alive/close status.
-			 * We may choose to set keep-alive if the Location begins
-			 * with a slash, because the client will come back to the
-			 * same server.
-			 */
-			txn->status = rule->code;
-			/* let's log the request time */
-			s->logs.tv_request = now;
-
-			if (rule->rdr_len >= 1 && *rule->rdr_str == '/' &&
-			    (txn->flags & TX_REQ_XFER_LEN) &&
-			    !(txn->flags & TX_REQ_TE_CHNK) && !txn->req.body_len &&
-			    ((txn->flags & TX_CON_WANT_MSK) == TX_CON_WANT_SCL ||
-			     (txn->flags & TX_CON_WANT_MSK) == TX_CON_WANT_KAL)) {
-				/* keep-alive possible */
-				if (!(txn->flags & TX_REQ_VER_11)) {
-					if (unlikely(txn->flags & TX_USE_PX_CONN)) {
-						memcpy(rdr.str + rdr.len, "\r\nProxy-Connection: keep-alive", 30);
-						rdr.len += 30;
-					} else {
-						memcpy(rdr.str + rdr.len, "\r\nConnection: keep-alive", 24);
-						rdr.len += 24;
-					}
-				}
-				memcpy(rdr.str + rdr.len, "\r\n\r\n", 4);
-				rdr.len += 4;
-				buffer_write(req->prod->ob, rdr.str, rdr.len);
-				/* "eat" the request */
-				buffer_ignore(req, msg->sov - msg->som);
-				msg->som = msg->sov;
-				req->analysers = AN_REQ_HTTP_XFER_BODY;
-				s->rep->analysers = AN_RES_HTTP_XFER_BODY;
-				txn->req.msg_state = HTTP_MSG_CLOSED;
-				txn->rsp.msg_state = HTTP_MSG_DONE;
-				break;
-			} else {
-				/* keep-alive not possible */
-				if (unlikely(txn->flags & TX_USE_PX_CONN)) {
-					memcpy(rdr.str + rdr.len, "\r\nProxy-Connection: close\r\n\r\n", 29);
-					rdr.len += 29;
-				} else {
-					memcpy(rdr.str + rdr.len, "\r\nConnection: close\r\n\r\n", 23);
-					rdr.len += 23;
-				}
-				stream_int_retnclose(req->prod, &rdr);
-				goto return_prx_cond;
-			}
-		}
-	}
-
-	/* POST requests may be accompanied with an "Expect: 100-Continue" header.
-	 * If this happens, then the data will not come immediately, so we must
-	 * send all what we have without waiting. Note that due to the small gain
-	 * in waiting for the body of the request, it's easier to simply put the
-	 * BF_SEND_DONTWAIT flag any time. It's a one-shot flag so it will remove
-	 * itself once used.
-	 */
-	req->flags |= BF_SEND_DONTWAIT;
-
-	/* that's OK for us now, let's move on to next analysers */
-	return 1;
-
- return_bad_req:
-	/* We centralize bad requests processing here */
-	if (unlikely(msg->msg_state == HTTP_MSG_ERROR) || msg->err_pos >= 0) {
-		/* we detected a parsing error. We want to archive this request
-		 * in the dedicated proxy area for later troubleshooting.
-		 */
-		http_capture_bad_message(&s->fe->invalid_req, s, req, msg, msg->msg_state, s->fe);
-	}
-
-	txn->req.msg_state = HTTP_MSG_ERROR;
-	txn->status = 400;
-	stream_int_retnclose(req->prod, error_message(s, HTTP_ERR_400));
-
-	s->fe->counters.failed_req++;
-	if (s->listener->counters)
-		s->listener->counters->failed_req++;
-
- return_prx_cond:
-	if (!(s->flags & SN_ERR_MASK))
-		s->flags |= SN_ERR_PRXCOND;
-	if (!(s->flags & SN_FINST_MASK))
-		s->flags |= SN_FINST_R;
-
-	req->analysers = 0;
-	req->analyse_exp = TICK_ETERNITY;
-	return 0;
-}
-
-/* This function performs all the processing enabled for the current request.
- * It returns 1 if the processing can continue on next analysers, or zero if it
- * needs more data, encounters an error, or wants to immediately abort the
- * request. It relies on buffers flags, and updates s->req->analysers.
- */
-int http_process_request(struct session *s, struct buffer *req, int an_bit)
-{
-	struct http_txn *txn = &s->txn;
-	struct http_msg *msg = &txn->req;
-
-	if (unlikely(msg->msg_state < HTTP_MSG_BODY)) {
-		/* we need more data */
-		buffer_dont_connect(req);
-		return 0;
-	}
-
-	DPRINTF(stderr,"[%u] %s: session=%p b=%p, exp(r,w)=%u,%u bf=%08x bl=%d analysers=%02x\n",
-		now_ms, __FUNCTION__,
-		s,
-		req,
-		req->rex, req->wex,
-		req->flags,
-		req->l,
-		req->analysers);
-
-	/*
-	 * Right now, we know that we have processed the entire headers
-	 * and that unwanted requests have been filtered out. We can do
-	 * whatever we want with the remaining request. Also, now we
-	 * may have separate values for ->fe, ->be.
-	 */
-
-	/*
-	 * If HTTP PROXY is set we simply get remote server address
-	 * parsing incoming request.
-	 */
-	if ((s->be->options & PR_O_HTTP_PROXY) && !(s->flags & SN_ADDR_SET)) {
-		url2sa(msg->sol + msg->sl.rq.u, msg->sl.rq.u_l, &s->srv_addr);
-	}
-
-	/*
-	 * 7: Now we can work with the cookies.
-	 * Note that doing so might move headers in the request, but
-	 * the fields will stay coherent and the URI will not move.
-	 * This should only be performed in the backend.
-	 */
-	if ((s->be->cookie_name || s->be->appsession_name || s->fe->capture_name)
-	    && !(txn->flags & (TX_CLDENY|TX_CLTARPIT)))
-		manage_client_side_cookies(s, req);
-
-	/*
-	 * 8: the appsession cookie was looked up very early in 1.2,
-	 * so let's do the same now.
-	 */
-
-	/* It needs to look into the URI unless persistence must be ignored */
-	if ((txn->sessid == NULL) && s->be->appsession_name && !(s->flags & SN_IGNORE_PRST)) {
-		get_srv_from_appsession(s, msg->sol + msg->sl.rq.u, msg->sl.rq.u_l);
-	}
-
-	/*
-	 * 9: add X-Forwarded-For if either the frontend or the backend
-	 * asks for it.
-	 */
-	if ((s->fe->options | s->be->options) & PR_O_FWDFOR) {
-		struct hdr_ctx ctx = { .idx = 0 };
-
-		if (!((s->fe->options2 | s->be->options2) & PR_O2_FF_ALWAYS) &&
-		    http_find_header2(s->be->fwdfor_hdr_name, s->be->fwdfor_hdr_len, txn->req.sol, &txn->hdr_idx, &ctx)) {
-			/* The header is set to be added only if none is present
-			 * and we found it, so don't do anything.
-			 */
-		}
-		else if (s->cli_addr.ss_family == AF_INET) {
-			/* Add an X-Forwarded-For header unless the source IP is
-			 * in the 'except' network range.
-			 */
-			if ((!s->fe->except_mask.s_addr ||
-			     (((struct sockaddr_in *)&s->cli_addr)->sin_addr.s_addr & s->fe->except_mask.s_addr)
-			     != s->fe->except_net.s_addr) &&
-			    (!s->be->except_mask.s_addr ||
-			     (((struct sockaddr_in *)&s->cli_addr)->sin_addr.s_addr & s->be->except_mask.s_addr)
-			     != s->be->except_net.s_addr)) {
-				int len;
-				unsigned char *pn;
-				pn = (unsigned char *)&((struct sockaddr_in *)&s->cli_addr)->sin_addr;
-
-				/* Note: we rely on the backend to get the header name to be used for
-				 * x-forwarded-for, because the header is really meant for the backends.
-				 * However, if the backend did not specify any option, we have to rely
-				 * on the frontend's header name.
-				 */
-				if (s->be->fwdfor_hdr_len) {
-					len = s->be->fwdfor_hdr_len;
-					memcpy(trash, s->be->fwdfor_hdr_name, len);
-				} else {
-					len = s->fe->fwdfor_hdr_len;
-					memcpy(trash, s->fe->fwdfor_hdr_name, len);
-				}
-				len += sprintf(trash + len, ": %d.%d.%d.%d", pn[0], pn[1], pn[2], pn[3]);
-
-				if (unlikely(http_header_add_tail2(req, &txn->req,
-								   &txn->hdr_idx, trash, len) < 0))
-					goto return_bad_req;
-			}
-		}
-		else if (s->cli_addr.ss_family == AF_INET6) {
-			/* FIXME: for the sake of completeness, we should also support
-			 * 'except' here, although it is mostly useless in this case.
-			 */
-			int len;
-			char pn[INET6_ADDRSTRLEN];
-			inet_ntop(AF_INET6,
-				  (const void *)&((struct sockaddr_in6 *)(&s->cli_addr))->sin6_addr,
-				  pn, sizeof(pn));
-
-			/* Note: we rely on the backend to get the header name to be used for
-			 * x-forwarded-for, because the header is really meant for the backends.
-			 * However, if the backend did not specify any option, we have to rely
-			 * on the frontend's header name.
-			 */
-			if (s->be->fwdfor_hdr_len) {
-				len = s->be->fwdfor_hdr_len;
-				memcpy(trash, s->be->fwdfor_hdr_name, len);
-			} else {
-				len = s->fe->fwdfor_hdr_len;
-				memcpy(trash, s->fe->fwdfor_hdr_name, len);
-			}
-			len += sprintf(trash + len, ": %s", pn);
-
-			if (unlikely(http_header_add_tail2(req, &txn->req,
-							   &txn->hdr_idx, trash, len) < 0))
-				goto return_bad_req;
-		}
-	}
-
-	/*
-	 * 10: add X-Original-To if either the frontend or the backend
-	 * asks for it.
-	 */
-	if ((s->fe->options | s->be->options) & PR_O_ORGTO) {
-
-		/* FIXME: don't know if IPv6 can handle that case too. */
-		if (s->cli_addr.ss_family == AF_INET) {
-			/* Add an X-Original-To header unless the destination IP is
-			 * in the 'except' network range.
-			 */
-			if (!(s->flags & SN_FRT_ADDR_SET))
-				get_frt_addr(s);
-
-			if ((!s->fe->except_mask_to.s_addr ||
-			     (((struct sockaddr_in *)&s->frt_addr)->sin_addr.s_addr & s->fe->except_mask_to.s_addr)
-			     != s->fe->except_to.s_addr) &&
-			    (!s->be->except_mask_to.s_addr ||
-			     (((struct sockaddr_in *)&s->frt_addr)->sin_addr.s_addr & s->be->except_mask_to.s_addr)
-			     != s->be->except_to.s_addr)) {
-				int len;
-				unsigned char *pn;
-				pn = (unsigned char *)&((struct sockaddr_in *)&s->frt_addr)->sin_addr;
-
-				/* Note: we rely on the backend to get the header name to be used for
-				 * x-original-to, because the header is really meant for the backends.
-				 * However, if the backend did not specify any option, we have to rely
-				 * on the frontend's header name.
-				 */
-				if (s->be->orgto_hdr_len) {
-					len = s->be->orgto_hdr_len;
-					memcpy(trash, s->be->orgto_hdr_name, len);
-				} else {
-					len = s->fe->orgto_hdr_len;
-					memcpy(trash, s->fe->orgto_hdr_name, len);
-				}
-				len += sprintf(trash + len, ": %d.%d.%d.%d", pn[0], pn[1], pn[2], pn[3]);
-
-				if (unlikely(http_header_add_tail2(req, &txn->req,
-								   &txn->hdr_idx, trash, len) < 0))
-					goto return_bad_req;
-			}
-		}
-	}
-
-	/* 11: add "Connection: close" or "Connection: keep-alive" if needed and not yet set. */
-	if (((txn->flags & TX_CON_WANT_MSK) != TX_CON_WANT_TUN) ||
-	    ((s->fe->options|s->be->options) & PR_O_HTTP_CLOSE)) {
-		unsigned int want_flags = 0;
-
-		if (txn->flags & TX_REQ_VER_11) {
-			if (((txn->flags & TX_CON_WANT_MSK) >= TX_CON_WANT_SCL ||
-			    ((s->fe->options|s->be->options) & PR_O_HTTP_CLOSE)) &&
-			    !((s->fe->options2|s->be->options2) & PR_O2_FAKE_KA))
-				want_flags |= TX_CON_CLO_SET;
-		} else {
-			if (((txn->flags & TX_CON_WANT_MSK) == TX_CON_WANT_KAL &&
-			     !((s->fe->options|s->be->options) & PR_O_HTTP_CLOSE)) ||
-			    ((s->fe->options2|s->be->options2) & PR_O2_FAKE_KA))
-				want_flags |= TX_CON_KAL_SET;
-		}
-
-		if (want_flags != (txn->flags & (TX_CON_CLO_SET|TX_CON_KAL_SET)))
-			http_change_connection_header(txn, msg, req, want_flags);
-	}
-
-
-	/* If we have no server assigned yet and we're balancing on url_param
-	 * with a POST request, we may be interested in checking the body for
-	 * that parameter. This will be done in another analyser.
-	 */
-	if (!(s->flags & (SN_ASSIGNED|SN_DIRECT)) &&
-	    s->txn.meth == HTTP_METH_POST && s->be->url_param_name != NULL &&
-	    s->be->url_param_post_limit != 0 &&
-	    (txn->flags & (TX_REQ_CNT_LEN|TX_REQ_TE_CHNK))) {
-		buffer_dont_connect(req);
-		req->analysers |= AN_REQ_HTTP_BODY;
-	}
-
-	if (txn->flags & TX_REQ_XFER_LEN) {
-		req->analysers |= AN_REQ_HTTP_XFER_BODY;
-#ifdef TCP_QUICKACK
-		/* We expect some data from the client. Unless we know for sure
-		 * we already have a full request, we have to re-enable quick-ack
-		 * in case we previously disabled it, otherwise we might cause
-		 * the client to delay further data.
-		 */
-		if ((s->listener->options & LI_O_NOQUICKACK) &&
-		    ((txn->flags & TX_REQ_TE_CHNK) ||
-		     (msg->body_len > req->l - txn->req.eoh - 2)))
-			setsockopt(s->si[0].fd, IPPROTO_TCP, TCP_QUICKACK, &one, sizeof(one));
-#endif
-	}
-
-	/*************************************************************
-	 * OK, that's finished for the headers. We have done what we *
-	 * could. Let's switch to the DATA state.                    *
-	 ************************************************************/
-	req->analyse_exp = TICK_ETERNITY;
-	req->analysers &= ~an_bit;
-
-	s->logs.tv_request = now;
-	/* OK let's go on with the BODY now */
-	return 1;
-
- return_bad_req: /* let's centralize all bad requests */
-	if (unlikely(msg->msg_state == HTTP_MSG_ERROR) || msg->err_pos >= 0) {
-		/* we detected a parsing error. We want to archive this request
-		 * in the dedicated proxy area for later troubleshooting.
-		 */
-		http_capture_bad_message(&s->fe->invalid_req, s, req, msg, msg->msg_state, s->fe);
-	}
-
-	txn->req.msg_state = HTTP_MSG_ERROR;
-	txn->status = 400;
-	req->analysers = 0;
-	stream_int_retnclose(req->prod, error_message(s, HTTP_ERR_400));
-
-	s->fe->counters.failed_req++;
-	if (s->listener->counters)
-		s->listener->counters->failed_req++;
-
-	if (!(s->flags & SN_ERR_MASK))
-		s->flags |= SN_ERR_PRXCOND;
-	if (!(s->flags & SN_FINST_MASK))
-		s->flags |= SN_FINST_R;
-	return 0;
-}
-
-/* This function is an analyser which processes the HTTP tarpit. It always
- * returns zero, at the beginning because it prevents any other processing
- * from occurring, and at the end because it terminates the request.
- */
-int http_process_tarpit(struct session *s, struct buffer *req, int an_bit)
-{
-	struct http_txn *txn = &s->txn;
-
-	/* This connection is being tarpitted. The CLIENT side has
-	 * already set the connect expiration date to the right
-	 * timeout. We just have to check that the client is still
-	 * there and that the timeout has not expired.
-	 */
-	buffer_dont_connect(req);
-	if ((req->flags & (BF_SHUTR|BF_READ_ERROR)) == 0 &&
-	    !tick_is_expired(req->analyse_exp, now_ms))
-		return 0;
-
-	/* We will set the queue timer to the time spent, just for
-	 * logging purposes. We fake a 500 server error, so that the
-	 * attacker will not suspect his connection has been tarpitted.
-	 * It will not cause trouble to the logs because we can exclude
-	 * the tarpitted connections by filtering on the 'PT' status flags.
-	 */
-	s->logs.t_queue = tv_ms_elapsed(&s->logs.tv_accept, &now);
-
-	txn->status = 500;
-	if (req->flags != BF_READ_ERROR)
-		stream_int_retnclose(req->prod, error_message(s, HTTP_ERR_500));
-
-	req->analysers = 0;
-	req->analyse_exp = TICK_ETERNITY;
-
-	s->fe->counters.failed_req++;
-	if (s->listener->counters)
-		s->listener->counters->failed_req++;
-
-	if (!(s->flags & SN_ERR_MASK))
-		s->flags |= SN_ERR_PRXCOND;
-	if (!(s->flags & SN_FINST_MASK))
-		s->flags |= SN_FINST_T;
-	return 0;
-}
-
-/* This function is an analyser which processes the HTTP request body. It looks
- * for parameters to be used for the load balancing algorithm (url_param). It
- * must only be called after the standard HTTP request processing has occurred,
- * because it expects the request to be parsed. It returns zero if it needs to
- * read more data, or 1 once it has completed its analysis.
- */
-int http_process_request_body(struct session *s, struct buffer *req, int an_bit)
-{
-	struct http_txn *txn = &s->txn;
-	struct http_msg *msg = &s->txn.req;
-	long long limit = s->be->url_param_post_limit;
-
-	/* We have to parse the HTTP request body to find any required data.
-	 * "balance url_param check_post" should have been the only way to get
-	 * into this. We were brought here after HTTP header analysis, so all
-	 * related structures are ready.
-	 */
-
-	if (unlikely(msg->msg_state < HTTP_MSG_BODY))
-		goto missing_data;
-
-	if (msg->msg_state < HTTP_MSG_100_SENT) {
-		/* If we have HTTP/1.1 and Expect: 100-continue, then we must
-		 * send an HTTP/1.1 100 Continue intermediate response.
-		 */
-		if (txn->flags & TX_REQ_VER_11) {
-			struct hdr_ctx ctx;
-			ctx.idx = 0;
-			/* Expect is allowed in 1.1, look for it */
-			if (http_find_header2("Expect", 6, msg->sol, &txn->hdr_idx, &ctx) &&
-			    unlikely(ctx.vlen == 12 && strncasecmp(ctx.line+ctx.val, "100-continue", 12) == 0)) {
-				buffer_write(s->rep, http_100_chunk.str, http_100_chunk.len);
-			}
-		}
-		msg->msg_state = HTTP_MSG_100_SENT;
-	}
-
-	if (msg->msg_state < HTTP_MSG_CHUNK_SIZE) {
-		/* we have msg->sov which points to the first
-		 * byte of message body. msg->som still points to the beginning
-		 * of the message. We must save the body in req->lr because it
-		 * survives buffer re-alignments.
-		 */
-		req->lr = req->data + msg->sov;
-		if (txn->flags & TX_REQ_TE_CHNK)
-			msg->msg_state = HTTP_MSG_CHUNK_SIZE;
-		else
-			msg->msg_state = HTTP_MSG_DATA;
-	}
-
-	if (msg->msg_state == HTTP_MSG_CHUNK_SIZE) {
-		/* read the chunk size and assign it to ->chunk_len, then
-		 * set ->sov and ->lr to point to the body and switch to DATA or
-		 * TRAILERS state.
-		 */
-		int ret = http_parse_chunk_size(req, msg);
-
-		if (!ret)
-			goto missing_data;
-		else if (ret < 0)
-			goto return_bad_req;
-	}
-
-	/* Now we're in HTTP_MSG_DATA or HTTP_MSG_TRAILERS state.
-	 * The first data byte is in msg->sov.
-	 * We're waiting for at least <url_param_post_limit> bytes after msg->sov.
-	 */
-
-	if (msg->body_len < limit)
-		limit = msg->body_len;
-
-	if (req->l - (msg->sov - msg->som) >= limit)    /* we have enough bytes now */
-		goto http_end;
-
- missing_data:
-	/* we get here if we need to wait for more data */
-	if (req->flags & BF_FULL)
-		goto return_bad_req;
-
-	if ((req->flags & BF_READ_TIMEOUT) || tick_is_expired(req->analyse_exp, now_ms)) {
-		txn->status = 408;
-		stream_int_retnclose(req->prod, error_message(s, HTTP_ERR_408));
-
-		if (!(s->flags & SN_ERR_MASK))
-			s->flags |= SN_ERR_CLITO;
-		if (!(s->flags & SN_FINST_MASK))
-			s->flags |= SN_FINST_D;
-		goto return_err_msg;
-	}
-
-	/* we get here if we need to wait for more data */
-	if (!(req->flags & (BF_FULL | BF_READ_ERROR | BF_SHUTR))) {
-		/* Not enough data. We'll re-use the http-request
-		 * timeout here. Ideally, we should set the timeout
-		 * relative to the accept() date. We just set the
-		 * request timeout once at the beginning of the
-		 * request.
-		 */
-		buffer_dont_connect(req);
-		if (!tick_isset(req->analyse_exp))
-			req->analyse_exp = tick_add_ifset(now_ms, s->be->timeout.httpreq);
-		return 0;
-	}
-
- http_end:
-	/* The situation will not evolve, so let's give up on the analysis. */
-	s->logs.tv_request = now;  /* update the request timer to reflect full request */
-	req->analysers &= ~an_bit;
-	req->analyse_exp = TICK_ETERNITY;
-	return 1;
-
- return_bad_req: /* let's centralize all bad requests */
-	txn->req.msg_state = HTTP_MSG_ERROR;
-	txn->status = 400;
-	stream_int_retnclose(req->prod, error_message(s, HTTP_ERR_400));
-
-	if (!(s->flags & SN_ERR_MASK))
-		s->flags |= SN_ERR_PRXCOND;
-	if (!(s->flags & SN_FINST_MASK))
-		s->flags |= SN_FINST_R;
-
- return_err_msg:
-	req->analysers = 0;
-	s->fe->counters.failed_req++;
-	if (s->listener->counters)
-		s->listener->counters->failed_req++;
-	return 0;
-}
-
-int http_send_name_header(struct http_txn *txn, struct http_msg *msg, struct buffer *buf, struct proxy* be, const char* srv_name) {
-
-	struct hdr_ctx ctx;
-
-	ctx.idx = 0;
-
-	char *hdr_name = be->server_id_hdr_name;
-	int hdr_name_len = be->server_id_hdr_len;
-
-	char *hdr_val;
-
-	while (http_find_header2(hdr_name, hdr_name_len, msg->sol, &txn->hdr_idx, &ctx)) {
-		/* remove any existing values from the header */
-	        http_remove_header2(msg, buf, &txn->hdr_idx, &ctx);
-	}
-
-	/* Add the new header requested with the server value */
-	hdr_val = trash;
-	memcpy(hdr_val, hdr_name, hdr_name_len);
-	hdr_val += hdr_name_len;
-	*hdr_val++ = ':';
-	*hdr_val++ = ' ';
-	hdr_val += strlcpy2(hdr_val, srv_name, trash + trashlen - hdr_val);
-	http_header_add_tail2(buf, msg, &txn->hdr_idx, trash, hdr_val - trash);
-
-	return 0;
-}
-
-/* Terminate current transaction and prepare a new one. This is very tricky
- * right now but it works.
- */
-void http_end_txn_clean_session(struct session *s)
-{
-	/* FIXME: We need a more portable way of releasing a backend's and a
-	 * server's connections. We need a safer way to reinitialize buffer
-	 * flags. We also need a more accurate method for computing per-request
-	 * data.
-	 */
-	http_silent_debug(__LINE__, s);
-
-	s->req->cons->flags |= SI_FL_NOLINGER;
-	s->req->cons->shutr(s->req->cons);
-	s->req->cons->shutw(s->req->cons);
-
-	http_silent_debug(__LINE__, s);
-
-	if (s->flags & SN_BE_ASSIGNED) {
-		s->be->beconn--;
-		if (unlikely(s->srv_conn))
-			sess_change_server(s, NULL);
-	}
-
-	s->logs.t_close = tv_ms_elapsed(&s->logs.tv_accept, &now);
-	session_process_counters(s);
-
-	if (s->txn.status) {
-		int n;
-
-		n = s->txn.status / 100;
-		if (n < 1 || n > 5)
-			n = 0;
-
-		if (s->fe->mode == PR_MODE_HTTP)
-			s->fe->counters.fe.http.rsp[n]++;
-
-		if ((s->flags & SN_BE_ASSIGNED) &&
-		    (s->be->mode == PR_MODE_HTTP))
-			s->be->counters.be.http.rsp[n]++;
-	}
-
-	/* don't count other requests' data */
-	s->logs.bytes_in  -= s->req->l - s->req->send_max;
-	s->logs.bytes_out -= s->rep->l - s->rep->send_max;
-
-	/* let's do a final log if we need it */
-	if (s->logs.logwait &&
-	    !(s->flags & SN_MONITOR) &&
-	    (!(s->fe->options & PR_O_NULLNOLOG) || s->req->total)) {
-		s->do_log(s);
-	}
-
-	s->logs.accept_date = date; /* user-visible date for logging */
-	s->logs.tv_accept = now;  /* corrected date for internal use */
-	tv_zero(&s->logs.tv_request);
-	s->logs.t_queue = -1;
-	s->logs.t_connect = -1;
-	s->logs.t_data = -1;
-	s->logs.t_close = 0;
-	s->logs.prx_queue_size = 0;  /* we get the number of pending conns before us */
-	s->logs.srv_queue_size = 0; /* we will get this number soon */
-
-	s->logs.bytes_in = s->req->total = s->req->l - s->req->send_max;
-	s->logs.bytes_out = s->rep->total = s->rep->l - s->rep->send_max;
-
-	if (s->pend_pos)
-		pendconn_free(s->pend_pos);
-
-	if (s->srv) {
-		if (s->flags & SN_CURR_SESS) {
-			s->flags &= ~SN_CURR_SESS;
-			s->srv->cur_sess--;
-		}
-		if (may_dequeue_tasks(s->srv, s->be))
-			process_srv_queue(s->srv);
-	}
-
-	s->srv = NULL;
-
-	s->req->cons->state     = s->req->cons->prev_state = SI_ST_INI;
-	s->req->cons->fd        = -1; /* just to help with debugging */
-	s->req->cons->err_type  = SI_ET_NONE;
-	s->req->cons->err_loc   = NULL;
-	s->req->cons->exp       = TICK_ETERNITY;
-	s->req->cons->flags     = SI_FL_NONE;
-	s->req->flags &= ~(BF_SHUTW|BF_SHUTW_NOW|BF_AUTO_CONNECT|BF_WRITE_ERROR|BF_STREAMER|BF_STREAMER_FAST|BF_NEVER_WAIT);
-	s->rep->flags &= ~(BF_SHUTR|BF_SHUTR_NOW|BF_READ_ATTACHED|BF_READ_ERROR|BF_READ_NOEXP|BF_STREAMER|BF_STREAMER_FAST|BF_WRITE_PARTIAL|BF_NEVER_WAIT);
-	s->flags &= ~(SN_DIRECT|SN_ASSIGNED|SN_ADDR_SET|SN_BE_ASSIGNED|SN_FORCE_PRST|SN_IGNORE_PRST);
-	s->flags &= ~(SN_CURR_SESS|SN_REDIRECTABLE);
-	s->txn.meth = 0;
-	http_reset_txn(s);
-	s->txn.flags |= TX_NOT_FIRST | TX_WAIT_NEXT_RQ;
-	if (s->be->options2 & PR_O2_INDEPSTR)
-		s->req->cons->flags |= SI_FL_INDEP_STR;
-
-	if (s->fe->options2 & PR_O2_NODELAY) {
-		s->req->flags |= BF_NEVER_WAIT;
-		s->rep->flags |= BF_NEVER_WAIT;
-	}
-
-	/* if the request buffer is not empty, it means we're
-	 * about to process another request, so send pending
-	 * data with MSG_MORE to merge TCP packets when possible.
-	 * Just don't do this if the buffer is close to be full,
-	 * because the request will wait for it to flush a little
-	 * bit before proceeding.
-	 */
-	if (s->req->l > s->req->send_max) {
-		if (s->rep->send_max &&
-		    !(s->rep->flags & BF_FULL) &&
-		    s->rep->r <= s->rep->data + s->rep->size - global.tune.maxrewrite)
-			s->rep->flags |= BF_EXPECT_MORE;
-	}
-
-	/* we're removing the analysers, we MUST re-enable events detection */
-	buffer_auto_read(s->req);
-	buffer_auto_close(s->req);
-	buffer_auto_read(s->rep);
-	buffer_auto_close(s->rep);
-
-	/* make ->lr point to the first non-forwarded byte */
-	s->req->lr = s->req->w + s->req->send_max;
-	if (s->req->lr >= s->req->data + s->req->size)
-		s->req->lr -= s->req->size;
-	s->rep->lr = s->rep->w + s->rep->send_max;
-	if (s->rep->lr >= s->rep->data + s->rep->size)
-		s->rep->lr -= s->req->size;
-
-	s->req->analysers = s->fe->fe_req_ana;
-	s->req->analysers &= ~AN_REQ_DECODE_PROXY;
-	s->rep->analysers = 0;
-
-	http_silent_debug(__LINE__, s);
-}
-
-
-/* This function updates the request state machine according to the response
- * state machine and buffer flags. It returns 1 if it changes anything (flag
- * or state), otherwise zero. It ignores any state before HTTP_MSG_DONE, as
- * it is only used to find when a request/response couple is complete. Both
- * this function and its equivalent should loop until both return zero. It
- * can set its own state to DONE, CLOSING, CLOSED, TUNNEL, ERROR.
- */
-int http_sync_req_state(struct session *s)
-{
-	struct buffer *buf = s->req;
-	struct http_txn *txn = &s->txn;
-	unsigned int old_flags = buf->flags;
-	unsigned int old_state = txn->req.msg_state;
-
-	http_silent_debug(__LINE__, s);
-	if (unlikely(txn->req.msg_state < HTTP_MSG_BODY))
-		return 0;
-
-	if (txn->req.msg_state == HTTP_MSG_DONE) {
-		/* No need to read anymore, the request was completely parsed.
-		 * We can shut the read side unless we want to abort_on_close,
-		 * or we have a POST request. The issue with POST requests is
-		 * that some browsers still send a CRLF after the request, and
-		 * this CRLF must be read so that it does not remain in the kernel
-		 * buffers, otherwise a close could cause an RST on some systems
-		 * (eg: Linux).
-		 */
-		if (!(s->be->options & PR_O_ABRT_CLOSE) && txn->meth != HTTP_METH_POST)
-			buffer_dont_read(buf);
-
-		if (txn->rsp.msg_state == HTTP_MSG_ERROR)
-			goto wait_other_side;
-
-		if (txn->rsp.msg_state < HTTP_MSG_DONE) {
-			/* The server has not finished to respond, so we
-			 * don't want to move in order not to upset it.
-			 */
-			goto wait_other_side;
-		}
-
-		if (txn->rsp.msg_state == HTTP_MSG_TUNNEL) {
-			/* if any side switches to tunnel mode, the other one does too */
-			buffer_auto_read(buf);
-			txn->req.msg_state = HTTP_MSG_TUNNEL;
-			goto wait_other_side;
-		}
-
-		/* When we get here, it means that both the request and the
-		 * response have finished receiving. Depending on the connection
-		 * mode, we'll have to wait for the last bytes to leave in either
-		 * direction, and sometimes for a close to be effective.
-		 */
-
-		if ((txn->flags & TX_CON_WANT_MSK) == TX_CON_WANT_SCL) {
-			/* Server-close mode : queue a connection close to the server */
-			if (!(buf->flags & (BF_SHUTW|BF_SHUTW_NOW)))
-				buffer_shutw_now(buf);
-		}
-		else if ((txn->flags & TX_CON_WANT_MSK) == TX_CON_WANT_CLO) {
-			/* Option forceclose is set, or either side wants to close,
-			 * let's enforce it now that we're not expecting any new
-			 * data to come. The caller knows the session is complete
-			 * once both states are CLOSED.
-			 */
-			if (!(buf->flags & (BF_SHUTW|BF_SHUTW_NOW))) {
-				buffer_shutr_now(buf);
-				buffer_shutw_now(buf);
-			}
-		}
-		else {
-			/* The last possible modes are keep-alive and tunnel. Since tunnel
-			 * mode does not set the body analyser, we can't reach this place
-			 * in tunnel mode, so we're left with keep-alive only.
-			 * This mode is currently not implemented, we switch to tunnel mode.
-			 */
-			buffer_auto_read(buf);
-			txn->req.msg_state = HTTP_MSG_TUNNEL;
-		}
-
-		if (buf->flags & (BF_SHUTW|BF_SHUTW_NOW)) {
-			/* if we've just closed an output, let's switch */
-			buf->cons->flags |= SI_FL_NOLINGER;  /* we want to close ASAP */
-
-			if (!(buf->flags & BF_OUT_EMPTY)) {
-				txn->req.msg_state = HTTP_MSG_CLOSING;
-				goto http_msg_closing;
-			}
-			else {
-				txn->req.msg_state = HTTP_MSG_CLOSED;
-				goto http_msg_closed;
-			}
-		}
-		goto wait_other_side;
-	}
-
-	if (txn->req.msg_state == HTTP_MSG_CLOSING) {
-	http_msg_closing:
-		/* nothing else to forward, just waiting for the output buffer
-		 * to be empty and for the shutw_now to take effect.
-		 */
-		if (buf->flags & BF_OUT_EMPTY) {
-			txn->req.msg_state = HTTP_MSG_CLOSED;
-			goto http_msg_closed;
-		}
-		else if (buf->flags & BF_SHUTW) {
-			txn->req.msg_state = HTTP_MSG_ERROR;
-			goto wait_other_side;
-		}
-	}
-
-	if (txn->req.msg_state == HTTP_MSG_CLOSED) {
-	http_msg_closed:
-		goto wait_other_side;
-	}
-
- wait_other_side:
-	http_silent_debug(__LINE__, s);
-	return txn->req.msg_state != old_state || buf->flags != old_flags;
-}
-
-
-/* This function updates the response state machine according to the request
- * state machine and buffer flags. It returns 1 if it changes anything (flag
- * or state), otherwise zero. It ignores any state before HTTP_MSG_DONE, as
- * it is only used to find when a request/response couple is complete. Both
- * this function and its equivalent should loop until both return zero. It
- * can set its own state to DONE, CLOSING, CLOSED, TUNNEL, ERROR.
- */
-int http_sync_res_state(struct session *s)
-{
-	struct buffer *buf = s->rep;
-	struct http_txn *txn = &s->txn;
-	unsigned int old_flags = buf->flags;
-	unsigned int old_state = txn->rsp.msg_state;
-
-	http_silent_debug(__LINE__, s);
-	if (unlikely(txn->rsp.msg_state < HTTP_MSG_BODY))
-		return 0;
-
-	if (txn->rsp.msg_state == HTTP_MSG_DONE) {
-		/* In theory, we don't need to read anymore, but we must
-		 * still monitor the server connection for a possible close
-		 * while the request is being uploaded, so we don't disable
-		 * reading.
-		 */
-		/* buffer_dont_read(buf); */
-
-		if (txn->req.msg_state == HTTP_MSG_ERROR)
-			goto wait_other_side;
-
-		if (txn->req.msg_state < HTTP_MSG_DONE) {
-			/* The client seems to still be sending data, probably
-			 * because we got an error response during an upload.
-			 * We have the choice of either breaking the connection
-			 * or letting it pass through. Let's do the later.
-			 */
-			goto wait_other_side;
-		}
-
-		if (txn->req.msg_state == HTTP_MSG_TUNNEL) {
-			/* if any side switches to tunnel mode, the other one does too */
-			buffer_auto_read(buf);
-			txn->rsp.msg_state = HTTP_MSG_TUNNEL;
-			goto wait_other_side;
-		}
-
-		/* When we get here, it means that both the request and the
-		 * response have finished receiving. Depending on the connection
-		 * mode, we'll have to wait for the last bytes to leave in either
-		 * direction, and sometimes for a close to be effective.
-		 */
-
-		if ((txn->flags & TX_CON_WANT_MSK) == TX_CON_WANT_SCL) {
-			/* Server-close mode : shut read and wait for the request
-			 * side to close its output buffer. The caller will detect
-			 * when we're in DONE and the other is in CLOSED and will
-			 * catch that for the final cleanup.
-			 */
-			if (!(buf->flags & (BF_SHUTR|BF_SHUTR_NOW)))
-				buffer_shutr_now(buf);
-		}
-		else if ((txn->flags & TX_CON_WANT_MSK) == TX_CON_WANT_CLO) {
-			/* Option forceclose is set, or either side wants to close,
-			 * let's enforce it now that we're not expecting any new
-			 * data to come. The caller knows the session is complete
-			 * once both states are CLOSED.
-			 */
-			if (!(buf->flags & (BF_SHUTW|BF_SHUTW_NOW))) {
-				buffer_shutr_now(buf);
-				buffer_shutw_now(buf);
-			}
-		}
-		else {
-			/* The last possible modes are keep-alive and tunnel. Since tunnel
-			 * mode does not set the body analyser, we can't reach this place
-			 * in tunnel mode, so we're left with keep-alive only.
-			 * This mode is currently not implemented, we switch to tunnel mode.
-			 */
-			buffer_auto_read(buf);
-			txn->rsp.msg_state = HTTP_MSG_TUNNEL;
-		}
-
-		if (buf->flags & (BF_SHUTW|BF_SHUTW_NOW)) {
-			/* if we've just closed an output, let's switch */
-			if (!(buf->flags & BF_OUT_EMPTY)) {
-				txn->rsp.msg_state = HTTP_MSG_CLOSING;
-				goto http_msg_closing;
-			}
-			else {
-				txn->rsp.msg_state = HTTP_MSG_CLOSED;
-				goto http_msg_closed;
-			}
-		}
-		goto wait_other_side;
-	}
-
-	if (txn->rsp.msg_state == HTTP_MSG_CLOSING) {
-	http_msg_closing:
-		/* nothing else to forward, just waiting for the output buffer
-		 * to be empty and for the shutw_now to take effect.
-		 */
-		if (buf->flags & BF_OUT_EMPTY) {
-			txn->rsp.msg_state = HTTP_MSG_CLOSED;
-			goto http_msg_closed;
-		}
-		else if (buf->flags & BF_SHUTW) {
-			txn->rsp.msg_state = HTTP_MSG_ERROR;
-			s->be->counters.cli_aborts++;
-			if (s->srv)
-				s->srv->counters.cli_aborts++;
-			goto wait_other_side;
-		}
-	}
-
-	if (txn->rsp.msg_state == HTTP_MSG_CLOSED) {
-	http_msg_closed:
-		/* drop any pending data */
-		buffer_ignore(buf, buf->l - buf->send_max);
-		buffer_auto_close(buf);
-		buffer_auto_read(buf);
-		goto wait_other_side;
-	}
-
- wait_other_side:
-	http_silent_debug(__LINE__, s);
-	return txn->rsp.msg_state != old_state || buf->flags != old_flags;
-}
-
-
-/* Resync the request and response state machines. Return 1 if either state
- * changes.
- */
-int http_resync_states(struct session *s)
-{
-	struct http_txn *txn = &s->txn;
-	int old_req_state = txn->req.msg_state;
-	int old_res_state = txn->rsp.msg_state;
-
-	http_silent_debug(__LINE__, s);
-	http_sync_req_state(s);
-	while (1) {
-		http_silent_debug(__LINE__, s);
-		if (!http_sync_res_state(s))
-			break;
-		http_silent_debug(__LINE__, s);
-		if (!http_sync_req_state(s))
-			break;
-	}
-	http_silent_debug(__LINE__, s);
-	/* OK, both state machines agree on a compatible state.
-	 * There are a few cases we're interested in :
-	 *  - HTTP_MSG_TUNNEL on either means we have to disable both analysers
-	 *  - HTTP_MSG_CLOSED on both sides means we've reached the end in both
-	 *    directions, so let's simply disable both analysers.
-	 *  - HTTP_MSG_CLOSED on the response only means we must abort the
-	 *    request.
-	 *  - HTTP_MSG_CLOSED on the request and HTTP_MSG_DONE on the response
-	 *    with server-close mode means we've completed one request and we
-	 *    must re-initialize the server connection.
-	 */
-
-	if (txn->req.msg_state == HTTP_MSG_TUNNEL ||
-	    txn->rsp.msg_state == HTTP_MSG_TUNNEL ||
-	    (txn->req.msg_state == HTTP_MSG_CLOSED &&
-	     txn->rsp.msg_state == HTTP_MSG_CLOSED)) {
-		s->req->analysers = 0;
-		buffer_auto_close(s->req);
-		buffer_auto_read(s->req);
-		s->rep->analysers = 0;
-		buffer_auto_close(s->rep);
-		buffer_auto_read(s->rep);
-	}
-	else if (txn->rsp.msg_state == HTTP_MSG_CLOSED ||
-		 txn->rsp.msg_state == HTTP_MSG_ERROR ||
-		 (s->rep->flags & BF_SHUTW)) {
-		s->rep->analysers = 0;
-		buffer_auto_close(s->rep);
-		buffer_auto_read(s->rep);
-		s->req->analysers = 0;
-		buffer_abort(s->req);
-		buffer_auto_close(s->req);
-		buffer_auto_read(s->req);
-		buffer_ignore(s->req, s->req->l - s->req->send_max);
-	}
-	else if (txn->req.msg_state == HTTP_MSG_CLOSED &&
-		 txn->rsp.msg_state == HTTP_MSG_DONE &&
-		 ((txn->flags & TX_CON_WANT_MSK) == TX_CON_WANT_SCL)) {
-		/* server-close: terminate this server connection and
-		 * reinitialize a fresh-new transaction.
-		 */
-		http_end_txn_clean_session(s);
-	}
-
-	http_silent_debug(__LINE__, s);
-	return txn->req.msg_state != old_req_state ||
-		txn->rsp.msg_state != old_res_state;
-}
-
-/* This function is an analyser which forwards request body (including chunk
- * sizes if any). It is called as soon as we must forward, even if we forward
- * zero byte. The only situation where it must not be called is when we're in
- * tunnel mode and we want to forward till the close. It's used both to forward
- * remaining data and to resync after end of body. It expects the msg_state to
- * be between MSG_BODY and MSG_DONE (inclusive). It returns zero if it needs to
- * read more data, or 1 once we can go on with next request or end the session.
- * When in MSG_DATA or MSG_TRAILERS, it will automatically forward chunk_len
- * bytes of pending data + the headers if not already done (between som and sov).
- * It eventually adjusts som to match sov after the data in between have been sent.
- */
-int http_request_forward_body(struct session *s, struct buffer *req, int an_bit)
-{
-	struct http_txn *txn = &s->txn;
-	struct http_msg *msg = &s->txn.req;
-
-	if (unlikely(msg->msg_state < HTTP_MSG_BODY))
-		return 0;
-
-	if ((req->flags & (BF_READ_ERROR|BF_READ_TIMEOUT|BF_WRITE_ERROR|BF_WRITE_TIMEOUT)) ||
-	    ((req->flags & BF_SHUTW) && (req->to_forward || req->send_max))) {
-		/* Output closed while we were sending data. We must abort. */
-		buffer_ignore(req, req->l - req->send_max);
-		buffer_auto_read(req);
-		buffer_auto_close(req);
-		req->analysers &= ~an_bit;
-		return 1;
-	}
-
-	buffer_dont_close(req);
-
-	/* Note that we don't have to send 100-continue back because we don't
-	 * need the data to complete our job, and it's up to the server to
-	 * decide whether to return 100, 417 or anything else in return of
-	 * an "Expect: 100-continue" header.
-	 */
-
-	if (msg->msg_state < HTTP_MSG_CHUNK_SIZE) {
-		/* we have msg->sov which points to the first
-		 * byte of message body. msg->som still points to the beginning
-		 * of the message. We must save the body in req->lr because it
-		 * survives buffer re-alignments.
-		 */
-		req->lr = req->data + msg->sov;
-		if (txn->flags & TX_REQ_TE_CHNK)
-			msg->msg_state = HTTP_MSG_CHUNK_SIZE;
-		else {
-			msg->msg_state = HTTP_MSG_DATA;
-		}
-	}
-
-	while (1) {
-		int bytes;
-
-		http_silent_debug(__LINE__, s);
-		/* we may have some data pending */
-		bytes = msg->sov - msg->som;
-		if (msg->chunk_len || bytes) {
-			msg->som = msg->sov;
-			if (likely(bytes < 0)) /* sov may have wrapped at the end */
-				bytes += req->size;
-			msg->chunk_len += (unsigned int)bytes;
-			msg->chunk_len -= buffer_forward(req, msg->chunk_len);
-		}
-
-		if (msg->msg_state == HTTP_MSG_DATA) {
-			/* must still forward */
-			if (req->to_forward)
-				goto missing_data;
-
-			/* nothing left to forward */
-			if (txn->flags & TX_REQ_TE_CHNK)
-				msg->msg_state = HTTP_MSG_DATA_CRLF;
-			else
-				msg->msg_state = HTTP_MSG_DONE;
-		}
-		else if (msg->msg_state == HTTP_MSG_CHUNK_SIZE) {
-			/* read the chunk size and assign it to ->chunk_len, then
-			 * set ->sov and ->lr to point to the body and switch to DATA or
-			 * TRAILERS state.
-			 */
-			int ret = http_parse_chunk_size(req, msg);
-
-			if (!ret)
-				goto missing_data;
-			else if (ret < 0) {
-				if (msg->err_pos >= 0)
-					http_capture_bad_message(&s->fe->invalid_req, s, req, msg, HTTP_MSG_CHUNK_SIZE, s->be);
-				goto return_bad_req;
-			}
-			/* otherwise we're in HTTP_MSG_DATA or HTTP_MSG_TRAILERS state */
-		}
-		else if (msg->msg_state == HTTP_MSG_DATA_CRLF) {
-			/* we want the CRLF after the data */
-			int ret;
-
-			req->lr = req->w + req->send_max;
-			if (req->lr >= req->data + req->size)
-				req->lr -= req->size;
-
-			ret = http_skip_chunk_crlf(req, msg);
-
-			if (ret == 0)
-				goto missing_data;
-			else if (ret < 0) {
-				if (msg->err_pos >= 0)
-					http_capture_bad_message(&s->fe->invalid_req, s, req, msg, HTTP_MSG_DATA_CRLF, s->be);
-				goto return_bad_req;
-			}
-			/* we're in MSG_CHUNK_SIZE now */
-		}
-		else if (msg->msg_state == HTTP_MSG_TRAILERS) {
-			int ret = http_forward_trailers(req, msg);
-
-			if (ret == 0)
-				goto missing_data;
-			else if (ret < 0) {
-				if (msg->err_pos >= 0)
-					http_capture_bad_message(&s->fe->invalid_req, s, req, msg, HTTP_MSG_TRAILERS, s->be);
-				goto return_bad_req;
-			}
-			/* we're in HTTP_MSG_DONE now */
-		}
-		else {
-			int old_state = msg->msg_state;
-
-			/* other states, DONE...TUNNEL */
-			if (http_resync_states(s)) {
-				/* some state changes occurred, maybe the analyser
-				 * was disabled too.
-				 */
-				if (unlikely(msg->msg_state == HTTP_MSG_ERROR)) {
-					if (req->flags & BF_SHUTW) {
-						/* request errors are most likely due to
-						 * the server aborting the transfer.
-						 */
-						goto aborted_xfer;
-					}
-					if (msg->err_pos >= 0)
-						http_capture_bad_message(&s->fe->invalid_req, s, req, msg, old_state, s->be);
-					goto return_bad_req;
-				}
-				return 1;
-			}
-
-			/* If "option abortonclose" is set on the backend, we
-			 * want to monitor the client's connection and forward
-			 * any shutdown notification to the server, which will
-			 * decide whether to close or to go on processing the
-			 * request.
-			 */
-			if (s->be->options & PR_O_ABRT_CLOSE) {
-				buffer_auto_read(req);
-				buffer_auto_close(req);
-			}
-			else if (s->txn.meth == HTTP_METH_POST) {
-				/* POST requests may require to read extra CRLF
-				 * sent by broken browsers and which could cause
-				 * an RST to be sent upon close on some systems
-				 * (eg: Linux).
-				 */
-				buffer_auto_read(req);
-			}
-
-			return 0;
-		}
-	}
-
- missing_data:
-	/* stop waiting for data if the input is closed before the end */
-	if (req->flags & BF_SHUTR) {
-		if (!(s->flags & SN_ERR_MASK))
-			s->flags |= SN_ERR_CLICL;
-		if (!(s->flags & SN_FINST_MASK)) {
-			if (txn->rsp.msg_state < HTTP_MSG_ERROR)
-				s->flags |= SN_FINST_H;
-			else
-				s->flags |= SN_FINST_D;
-		}
-
-		s->fe->counters.cli_aborts++;
-		if (s->fe != s->be)
-			s->be->counters.cli_aborts++;
-		if (s->srv)
-			s->srv->counters.cli_aborts++;
-
-		goto return_bad_req_stats_ok;
-	}
-
-	/* waiting for the last bits to leave the buffer */
-	if (req->flags & BF_SHUTW)
-		goto aborted_xfer;
-
-	/* We know that more data are expected, but we couldn't send more that
-	 * what we did. So we always set the BF_EXPECT_MORE flag so that the
-	 * system knows it must not set a PUSH on this first part. Interactive
-	 * modes are already handled by the stream sock layer. We must not do
-	 * this in content-length mode because it could present the MSG_MORE
-	 * flag with the last block of forwarded data, which would cause an
-	 * additional delay to be observed by the receiver.
-	 */
-	if (txn->flags & TX_REQ_TE_CHNK)
-		req->flags |= BF_EXPECT_MORE;
-
-	http_silent_debug(__LINE__, s);
-	return 0;
-
- return_bad_req: /* let's centralize all bad requests */
-	s->fe->counters.failed_req++;
-	if (s->listener->counters)
-		s->listener->counters->failed_req++;
- return_bad_req_stats_ok:
-	txn->req.msg_state = HTTP_MSG_ERROR;
-	if (txn->status) {
-		/* Note: we don't send any error if some data were already sent */
-		stream_int_retnclose(req->prod, NULL);
-	} else {
-		txn->status = 400;
-		stream_int_retnclose(req->prod, error_message(s, HTTP_ERR_400));
-	}
-	req->analysers = 0;
-	s->rep->analysers = 0; /* we're in data phase, we want to abort both directions */
-
-	if (!(s->flags & SN_ERR_MASK))
-		s->flags |= SN_ERR_PRXCOND;
-	if (!(s->flags & SN_FINST_MASK)) {
-		if (txn->rsp.msg_state < HTTP_MSG_ERROR)
-			s->flags |= SN_FINST_H;
-		else
-			s->flags |= SN_FINST_D;
-	}
-	return 0;
-
- aborted_xfer:
-	txn->req.msg_state = HTTP_MSG_ERROR;
-	if (txn->status) {
-		/* Note: we don't send any error if some data were already sent */
-		stream_int_retnclose(req->prod, NULL);
-	} else {
-		txn->status = 502;
-		stream_int_retnclose(req->prod, error_message(s, HTTP_ERR_502));
-	}
-	req->analysers = 0;
-	s->rep->analysers = 0; /* we're in data phase, we want to abort both directions */
-
-	s->fe->counters.srv_aborts++;
-	if (s->fe != s->be)
-		s->be->counters.srv_aborts++;
-	if (s->srv)
-		s->srv->counters.srv_aborts++;
-
-	if (!(s->flags & SN_ERR_MASK))
-		s->flags |= SN_ERR_SRVCL;
-	if (!(s->flags & SN_FINST_MASK)) {
-		if (txn->rsp.msg_state < HTTP_MSG_ERROR)
-			s->flags |= SN_FINST_H;
-		else
-			s->flags |= SN_FINST_D;
-	}
-	return 0;
-}
-
-/* This stream analyser waits for a complete HTTP response. It returns 1 if the
- * processing can continue on next analysers, or zero if it either needs more
- * data or wants to immediately abort the response (eg: timeout, error, ...). It
- * is tied to AN_RES_WAIT_HTTP and may may remove itself from s->rep->analysers
- * when it has nothing left to do, and may remove any analyser when it wants to
- * abort.
- */
-int http_wait_for_response(struct session *s, struct buffer *rep, int an_bit)
-{
-	struct http_txn *txn = &s->txn;
-	struct http_msg *msg = &txn->rsp;
-	struct hdr_ctx ctx;
-	int use_close_only;
-	int cur_idx;
-	int n;
-
-	DPRINTF(stderr,"[%u] %s: session=%p b=%p, exp(r,w)=%u,%u bf=%08x bl=%d analysers=%02x\n",
-		now_ms, __FUNCTION__,
-		s,
-		rep,
-		rep->rex, rep->wex,
-		rep->flags,
-		rep->l,
-		rep->analysers);
-
-	/*
-	 * Now parse the partial (or complete) lines.
-	 * We will check the response syntax, and also join multi-line
-	 * headers. An index of all the lines will be elaborated while
-	 * parsing.
-	 *
-	 * For the parsing, we use a 28 states FSM.
-	 *
-	 * Here is the information we currently have :
-	 *   rep->data + msg->som  = beginning of response
-	 *   rep->data + msg->eoh  = end of processed headers / start of current one
-	 *   msg->eol              = end of current header or line (LF or CRLF)
-	 *   rep->lr = first non-visited byte
-	 *   rep->r  = end of data
-	 * Once we reach MSG_BODY, rep->sol = rep->data + msg->som
-	 */
-
-	/* There's a protected area at the end of the buffer for rewriting
-	 * purposes. We don't want to start to parse the request if the
-	 * protected area is affected, because we may have to move processed
-	 * data later, which is much more complicated.
-	 */
-	if (rep->l && msg->msg_state < HTTP_MSG_ERROR) {
-		if (unlikely((rep->flags & BF_FULL) ||
-			     rep->r < rep->lr ||
-			     rep->r > rep->data + rep->size - global.tune.maxrewrite)) {
-			if (rep->send_max) {
-				/* some data has still not left the buffer, wake us once that's done */
-				if (rep->flags & (BF_SHUTW|BF_SHUTW_NOW|BF_WRITE_ERROR|BF_WRITE_TIMEOUT))
-					goto abort_response;
-				buffer_dont_close(rep);
-				rep->flags |= BF_READ_DONTWAIT; /* try to get back here ASAP */
-				return 0;
-			}
-			if (rep->l <= rep->size - global.tune.maxrewrite)
-				http_buffer_heavy_realign(rep, msg);
-		}
-
-		if (likely(rep->lr < rep->r))
-			http_msg_analyzer(rep, msg, &txn->hdr_idx);
-	}
-
-	/* 1: we might have to print this header in debug mode */
-	if (unlikely((global.mode & MODE_DEBUG) &&
-		     (!(global.mode & MODE_QUIET) || (global.mode & MODE_VERBOSE)) &&
-		     msg->sol &&
-		     (msg->msg_state >= HTTP_MSG_BODY || msg->msg_state == HTTP_MSG_ERROR))) {
-		char *eol, *sol;
-
-		sol = rep->data + msg->som;
-		eol = sol + msg->sl.st.l;
-		debug_hdr("srvrep", s, sol, eol);
-
-		sol += hdr_idx_first_pos(&txn->hdr_idx);
-		cur_idx = hdr_idx_first_idx(&txn->hdr_idx);
-
-		while (cur_idx) {
-			eol = sol + txn->hdr_idx.v[cur_idx].len;
-			debug_hdr("srvhdr", s, sol, eol);
-			sol = eol + txn->hdr_idx.v[cur_idx].cr + 1;
-			cur_idx = txn->hdr_idx.v[cur_idx].next;
-		}
-	}
-
-	/*
-	 * Now we quickly check if we have found a full valid response.
-	 * If not so, we check the FD and buffer states before leaving.
-	 * A full response is indicated by the fact that we have seen
-	 * the double LF/CRLF, so the state is >= HTTP_MSG_BODY. Invalid
-	 * responses are checked first.
-	 *
-	 * Depending on whether the client is still there or not, we
-	 * may send an error response back or not. Note that normally
-	 * we should only check for HTTP status there, and check I/O
-	 * errors somewhere else.
-	 */
-
-	if (unlikely(msg->msg_state < HTTP_MSG_BODY)) {
-		/* Invalid response */
-		if (unlikely(msg->msg_state == HTTP_MSG_ERROR)) {
-			/* we detected a parsing error. We want to archive this response
-			 * in the dedicated proxy area for later troubleshooting.
-			 */
-		hdr_response_bad:
-			if (msg->msg_state == HTTP_MSG_ERROR || msg->err_pos >= 0)
-				http_capture_bad_message(&s->be->invalid_rep, s, rep, msg, msg->msg_state, s->fe);
-
-			s->be->counters.failed_resp++;
-			if (s->srv) {
-				s->srv->counters.failed_resp++;
-				health_adjust(s->srv, HANA_STATUS_HTTP_HDRRSP);
-			}
-		abort_response:
-			buffer_auto_close(rep);
-			rep->analysers = 0;
-			txn->status = 502;
-			rep->prod->flags |= SI_FL_NOLINGER;
-			buffer_ignore(rep, rep->l - rep->send_max);
-			stream_int_retnclose(rep->cons, error_message(s, HTTP_ERR_502));
-
-			if (!(s->flags & SN_ERR_MASK))
-				s->flags |= SN_ERR_PRXCOND;
-			if (!(s->flags & SN_FINST_MASK))
-				s->flags |= SN_FINST_H;
-
-			return 0;
-		}
-
-		/* too large response does not fit in buffer. */
-		else if (rep->flags & BF_FULL) {
-			if (msg->err_pos < 0)
-				msg->err_pos = rep->l;
-			goto hdr_response_bad;
-		}
-
-		/* read error */
-		else if (rep->flags & BF_READ_ERROR) {
-			if (msg->err_pos >= 0)
-				http_capture_bad_message(&s->be->invalid_rep, s, rep, msg, msg->msg_state, s->fe);
-
-			s->be->counters.failed_resp++;
-			if (s->srv) {
-				s->srv->counters.failed_resp++;
-				health_adjust(s->srv, HANA_STATUS_HTTP_READ_ERROR);
-			}
-
-			buffer_auto_close(rep);
-			rep->analysers = 0;
-			txn->status = 502;
-			rep->prod->flags |= SI_FL_NOLINGER;
-			buffer_ignore(rep, rep->l - rep->send_max);
-			stream_int_retnclose(rep->cons, error_message(s, HTTP_ERR_502));
-
-			if (!(s->flags & SN_ERR_MASK))
-				s->flags |= SN_ERR_SRVCL;
-			if (!(s->flags & SN_FINST_MASK))
-				s->flags |= SN_FINST_H;
-			return 0;
-		}
-
-		/* read timeout : return a 504 to the client. */
-		else if (rep->flags & BF_READ_TIMEOUT) {
-			if (msg->err_pos >= 0)
-				http_capture_bad_message(&s->be->invalid_rep, s, rep, msg, msg->msg_state, s->fe);
-
-			s->be->counters.failed_resp++;
-			if (s->srv) {
-				s->srv->counters.failed_resp++;
-				health_adjust(s->srv, HANA_STATUS_HTTP_READ_TIMEOUT);
-			}
-
-			buffer_auto_close(rep);
-			rep->analysers = 0;
-			txn->status = 504;
-			rep->prod->flags |= SI_FL_NOLINGER;
-			buffer_ignore(rep, rep->l - rep->send_max);
-			stream_int_retnclose(rep->cons, error_message(s, HTTP_ERR_504));
-
-			if (!(s->flags & SN_ERR_MASK))
-				s->flags |= SN_ERR_SRVTO;
-			if (!(s->flags & SN_FINST_MASK))
-				s->flags |= SN_FINST_H;
-			return 0;
-		}
-
-		/* close from server, capture the response if the server has started to respond */
-		else if (rep->flags & BF_SHUTR) {
-			if (msg->msg_state >= HTTP_MSG_RPVER || msg->err_pos >= 0)
-				http_capture_bad_message(&s->be->invalid_rep, s, rep, msg, msg->msg_state, s->fe);
-
-			s->be->counters.failed_resp++;
-			if (s->srv) {
-				s->srv->counters.failed_resp++;
-				health_adjust(s->srv, HANA_STATUS_HTTP_BROKEN_PIPE);
-			}
-
-			buffer_auto_close(rep);
-			rep->analysers = 0;
-			txn->status = 502;
-			rep->prod->flags |= SI_FL_NOLINGER;
-			buffer_ignore(rep, rep->l - rep->send_max);
-			stream_int_retnclose(rep->cons, error_message(s, HTTP_ERR_502));
-
-			if (!(s->flags & SN_ERR_MASK))
-				s->flags |= SN_ERR_SRVCL;
-			if (!(s->flags & SN_FINST_MASK))
-				s->flags |= SN_FINST_H;
-			return 0;
-		}
-
-		/* write error to client (we don't send any message then) */
-		else if (rep->flags & BF_WRITE_ERROR) {
-			if (msg->err_pos >= 0)
-				http_capture_bad_message(&s->be->invalid_rep, s, rep, msg, msg->msg_state, s->fe);
-
-			s->be->counters.failed_resp++;
-			rep->analysers = 0;
-			buffer_auto_close(rep);
-
-			if (!(s->flags & SN_ERR_MASK))
-				s->flags |= SN_ERR_CLICL;
-			if (!(s->flags & SN_FINST_MASK))
-				s->flags |= SN_FINST_H;
-
-			/* process_session() will take care of the error */
-			return 0;
-		}
-
-		buffer_dont_close(rep);
-		return 0;
-	}
-
-	/* More interesting part now : we know that we have a complete
-	 * response which at least looks like HTTP. We have an indicator
-	 * of each header's length, so we can parse them quickly.
-	 */
-
-	if (unlikely(msg->err_pos >= 0))
-		http_capture_bad_message(&s->be->invalid_rep, s, rep, msg, msg->msg_state, s->fe);
-
-	/*
-	 * 1: get the status code
-	 */
-	n = msg->sol[msg->sl.st.c] - '0';
-	if (n < 1 || n > 5)
-		n = 0;
-	if (s->srv)
-		s->srv->counters.p.http.rsp[n]++;
-
-	/* check if the response is HTTP/1.1 or above */
-	if ((msg->sl.st.v_l == 8) &&
-	    ((msg->sol[5] > '1') ||
-	     ((msg->sol[5] == '1') &&
-	      (msg->sol[7] >= '1'))))
-		txn->flags |= TX_RES_VER_11;
-
-	/* "connection" has not been parsed yet */
-	txn->flags &= ~(TX_HDR_CONN_PRS|TX_HDR_CONN_CLO|TX_HDR_CONN_KAL|TX_CON_CLO_SET|TX_CON_KAL_SET);
-
-	/* transfer length unknown*/
-	txn->flags &= ~TX_RES_XFER_LEN;
-
-	txn->status = strl2ui(msg->sol + msg->sl.st.c, msg->sl.st.c_l);
-
-	/* Adjust server's health based on status code. Note: status codes 501
-	 * and 505 are triggered on demand by client request, so we must not
-	 * count them as server failures.
-	 */
-	if (s->srv) {
-		if (txn->status >= 100 && (txn->status < 500 || txn->status == 501 || txn->status == 505))
-			health_adjust(s->srv, HANA_STATUS_HTTP_OK);
-		else
-			health_adjust(s->srv, HANA_STATUS_HTTP_STS);
-	}
-
-	/*
-	 * 2: check for cacheability.
-	 */
-
-	switch (txn->status) {
-	case 200:
-	case 203:
-	case 206:
-	case 300:
-	case 301:
-	case 410:
-		/* RFC2616 @13.4:
-		 *   "A response received with a status code of
-		 *    200, 203, 206, 300, 301 or 410 MAY be stored
-		 *    by a cache (...) unless a cache-control
-		 *    directive prohibits caching."
-		 *
-		 * RFC2616 @9.5: POST method :
-		 *   "Responses to this method are not cacheable,
-		 *    unless the response includes appropriate
-		 *    Cache-Control or Expires header fields."
-		 */
-		if (likely(txn->meth != HTTP_METH_POST) &&
-		    (s->be->options & (PR_O_CHK_CACHE|PR_O_COOK_NOC)))
-			txn->flags |= TX_CACHEABLE | TX_CACHE_COOK;
-		break;
-	default:
-		break;
-	}
-
-	/*
-	 * 3: we may need to capture headers
-	 */
-	s->logs.logwait &= ~LW_RESP;
-	if (unlikely((s->logs.logwait & LW_RSPHDR) && txn->rsp.cap))
-		capture_headers(msg->sol, &txn->hdr_idx,
-				txn->rsp.cap, s->fe->rsp_cap);
-
-	/* 4: determine the transfer-length.
-	 * According to RFC2616 #4.4, amended by the HTTPbis working group,
-	 * the presence of a message-body in a RESPONSE and its transfer length
-	 * must be determined that way :
-	 *
-	 *   All responses to the HEAD request method MUST NOT include a
-	 *   message-body, even though the presence of entity-header fields
-	 *   might lead one to believe they do.  All 1xx (informational), 204
-	 *   (No Content), and 304 (Not Modified) responses MUST NOT include a
-	 *   message-body.  All other responses do include a message-body,
-	 *   although it MAY be of zero length.
-	 *
-	 *   1. Any response which "MUST NOT" include a message-body (such as the
-	 *      1xx, 204 and 304 responses and any response to a HEAD request) is
-	 *      always terminated by the first empty line after the header fields,
-	 *      regardless of the entity-header fields present in the message.
-	 *
-	 *   2. If a Transfer-Encoding header field (Section 9.7) is present and
-	 *      the "chunked" transfer-coding (Section 6.2) is used, the
-	 *      transfer-length is defined by the use of this transfer-coding.
-	 *      If a Transfer-Encoding header field is present and the "chunked"
-	 *      transfer-coding is not present, the transfer-length is defined by
-	 *      the sender closing the connection.
-	 *
-	 *   3. If a Content-Length header field is present, its decimal value in
-	 *      OCTETs represents both the entity-length and the transfer-length.
-	 *      If a message is received with both a Transfer-Encoding header
-	 *      field and a Content-Length header field, the latter MUST be ignored.
-	 *
-	 *   4. If the message uses the media type "multipart/byteranges", and
-	 *      the transfer-length is not otherwise specified, then this self-
-	 *      delimiting media type defines the transfer-length.  This media
-	 *      type MUST NOT be used unless the sender knows that the recipient
-	 *      can parse it; the presence in a request of a Range header with
-	 *      multiple byte-range specifiers from a 1.1 client implies that the
-	 *      client can parse multipart/byteranges responses.
-	 *
-	 *   5. By the server closing the connection.
-	 */
-
-	/* Skip parsing if no content length is possible. The response flags
-	 * remain 0 as well as the chunk_len, which may or may not mirror
-	 * the real header value, and we note that we know the response's length.
-	 * FIXME: should we parse anyway and return an error on chunked encoding ?
-	 */
-	if (txn->meth == HTTP_METH_HEAD ||
-	    (txn->status >= 100 && txn->status < 200) ||
-	    txn->status == 204 || txn->status == 304) {
-		txn->flags |= TX_RES_XFER_LEN;
-		goto skip_content_length;
-	}
-
-	use_close_only = 0;
-	ctx.idx = 0;
-	while ((txn->flags & TX_RES_VER_11) &&
-	       http_find_header2("Transfer-Encoding", 17, msg->sol, &txn->hdr_idx, &ctx)) {
-		if (ctx.vlen == 7 && strncasecmp(ctx.line + ctx.val, "chunked", 7) == 0)
-			txn->flags |= (TX_RES_TE_CHNK | TX_RES_XFER_LEN);
-		else if (txn->flags & TX_RES_TE_CHNK) {
-			/* bad transfer-encoding (chunked followed by something else) */
-			use_close_only = 1;
-			txn->flags &= ~(TX_RES_TE_CHNK | TX_RES_XFER_LEN);
-			break;
-		}
-	}
-
-	/* FIXME: below we should remove the content-length header(s) in case of chunked encoding */
-	ctx.idx = 0;
-	while (!(txn->flags & TX_RES_TE_CHNK) && !use_close_only &&
-	       http_find_header2("Content-Length", 14, msg->sol, &txn->hdr_idx, &ctx)) {
-		signed long long cl;
-
-		if (!ctx.vlen) {
-			msg->err_pos = ctx.line + ctx.val - rep->data;
-			goto hdr_response_bad;
-		}
-
-		if (strl2llrc(ctx.line + ctx.val, ctx.vlen, &cl)) {
-			msg->err_pos = ctx.line + ctx.val - rep->data;
-			goto hdr_response_bad; /* parse failure */
-		}
-
-		if (cl < 0) {
-			msg->err_pos = ctx.line + ctx.val - rep->data;
-			goto hdr_response_bad;
-		}
-
-		if ((txn->flags & TX_RES_CNT_LEN) && (msg->chunk_len != cl)) {
-			msg->err_pos = ctx.line + ctx.val - rep->data;
-			goto hdr_response_bad; /* already specified, was different */
-		}
-
-		txn->flags |= TX_RES_CNT_LEN | TX_RES_XFER_LEN;
-		msg->body_len = msg->chunk_len = cl;
-	}
-
-	/* FIXME: we should also implement the multipart/byterange method.
-	 * For now on, we resort to close mode in this case (unknown length).
-	 */
-skip_content_length:
-
-	/* end of job, return OK */
-	rep->analysers &= ~an_bit;
-	rep->analyse_exp = TICK_ETERNITY;
-	buffer_auto_close(rep);
-	return 1;
-}
-
-/* This function performs all the processing enabled for the current response.
- * It normally returns 1 unless it wants to break. It relies on buffers flags,
- * and updates t->rep->analysers. It might make sense to explode it into several
- * other functions. It works like process_request (see indications above).
- */
-int http_process_res_common(struct session *t, struct buffer *rep, int an_bit, struct proxy *px)
-{
-	struct http_txn *txn = &t->txn;
-	struct http_msg *msg = &txn->rsp;
-	struct proxy *cur_proxy;
-	struct cond_wordlist *wl;
-
-	DPRINTF(stderr,"[%u] %s: session=%p b=%p, exp(r,w)=%u,%u bf=%08x bl=%d analysers=%02x\n",
-		now_ms, __FUNCTION__,
-		t,
-		rep,
-		rep->rex, rep->wex,
-		rep->flags,
-		rep->l,
-		rep->analysers);
-
-	if (unlikely(msg->msg_state < HTTP_MSG_BODY))	/* we need more data */
-		return 0;
-
-	rep->analysers &= ~an_bit;
-	rep->analyse_exp = TICK_ETERNITY;
-
-	/* Now we have to check if we need to modify the Connection header.
-	 * This is more difficult on the response than it is on the request,
-	 * because we can have two different HTTP versions and we don't know
-	 * how the client will interprete a response. For instance, let's say
-	 * that the client sends a keep-alive request in HTTP/1.0 and gets an
-	 * HTTP/1.1 response without any header. Maybe it will bound itself to
-	 * HTTP/1.0 because it only knows about it, and will consider the lack
-	 * of header as a close, or maybe it knows HTTP/1.1 and can consider
-	 * the lack of header as a keep-alive. Thus we will use two flags
-	 * indicating how a request MAY be understood by the client. In case
-	 * of multiple possibilities, we'll fix the header to be explicit. If
-	 * ambiguous cases such as both close and keepalive are seen, then we
-	 * will fall back to explicit close. Note that we won't take risks with
-	 * HTTP/1.0 clients which may not necessarily understand keep-alive.
-	 * See doc/internals/connection-header.txt for the complete matrix.
-	 */
-
-	if (unlikely((txn->meth == HTTP_METH_CONNECT && txn->status == 200) ||
-		     txn->status == 101)) {
-		/* Either we've established an explicit tunnel, or we're
-		 * switching the protocol. In both cases, we're very unlikely
-		 * to understand the next protocols. We have to switch to tunnel
-		 * mode, so that we transfer the request and responses then let
-		 * this protocol pass unmodified. When we later implement specific
-		 * parsers for such protocols, we'll want to check the Upgrade
-		 * header which contains information about that protocol for
-		 * responses with status 101 (eg: see RFC2817 about TLS).
-		 */
-		txn->flags = (txn->flags & ~TX_CON_WANT_MSK) | TX_CON_WANT_TUN;
-	}
-	else if ((txn->status >= 200) && !(txn->flags & TX_HDR_CONN_PRS) &&
-		 ((txn->flags & TX_CON_WANT_MSK) != TX_CON_WANT_TUN ||
-		  ((t->fe->options|t->be->options) & PR_O_HTTP_CLOSE))) {
-		int to_del = 0;
-
-		/* on unknown transfer length, we must close */
-		if (!(txn->flags & TX_RES_XFER_LEN) &&
-		    (txn->flags & TX_CON_WANT_MSK) != TX_CON_WANT_TUN)
-			txn->flags = (txn->flags & ~TX_CON_WANT_MSK) | TX_CON_WANT_CLO;
-
-		/* now adjust header transformations depending on current state */
-		if ((txn->flags & TX_CON_WANT_MSK) == TX_CON_WANT_TUN ||
-		    (txn->flags & TX_CON_WANT_MSK) == TX_CON_WANT_CLO) {
-			to_del |= 2; /* remove "keep-alive" on any response */
-			if (!(txn->flags & TX_RES_VER_11))
-				to_del |= 1; /* remove "close" for HTTP/1.0 responses */
-		}
-		else { /* SCL / KAL */
-			to_del |= 1; /* remove "close" on any response */
-			if ((txn->flags & (TX_RES_VER_11|TX_REQ_VER_11)) == (TX_RES_VER_11|TX_REQ_VER_11))
-				to_del |= 2; /* remove "keep-alive" on pure 1.1 responses */
-		}
-
-		/* Parse and remove some headers from the connection header */
-		http_parse_connection_header(txn, msg, rep, to_del);
-
-		/* Some keep-alive responses are converted to Server-close if
-		 * the server wants to close.
-		 */
-		if ((txn->flags & TX_CON_WANT_MSK) == TX_CON_WANT_KAL) {
-			if ((txn->flags & TX_HDR_CONN_CLO) ||
-			    (txn->flags & (TX_HDR_CONN_KAL|TX_RES_VER_11)) == 0)
-				txn->flags = (txn->flags & ~TX_CON_WANT_MSK) | TX_CON_WANT_SCL;
-		}
-	}
-
-	if (1) {
-		/*
-		 * 3: we will have to evaluate the filters.
-		 * As opposed to version 1.2, now they will be evaluated in the
-		 * filters order and not in the header order. This means that
-		 * each filter has to be validated among all headers.
-		 *
-		 * Filters are tried with ->be first, then with ->fe if it is
-		 * different from ->be.
-		 */
-
-		cur_proxy = t->be;
-		while (1) {
-			struct proxy *rule_set = cur_proxy;
-
-			/* try headers filters */
-			if (rule_set->rsp_exp != NULL) {
-				if (apply_filters_to_response(t, rep, rule_set) < 0) {
-				return_bad_resp:
-					if (t->srv) {
-						t->srv->counters.failed_resp++;
-						health_adjust(t->srv, HANA_STATUS_HTTP_RSP);
-					}
-					cur_proxy->counters.failed_resp++;
-				return_srv_prx_502:
-					rep->analysers = 0;
-					txn->status = 502;
-					rep->prod->flags |= SI_FL_NOLINGER;
-					buffer_ignore(rep, rep->l - rep->send_max);
-					stream_int_retnclose(rep->cons, error_message(t, HTTP_ERR_502));
-					if (!(t->flags & SN_ERR_MASK))
-						t->flags |= SN_ERR_PRXCOND;
-					if (!(t->flags & SN_FINST_MASK))
-						t->flags |= SN_FINST_H;
-					return 0;
-				}
-			}
-
-			/* has the response been denied ? */
-			if (txn->flags & TX_SVDENY) {
-				if (t->srv)
-					t->srv->counters.failed_secu++;
-
-				cur_proxy->counters.denied_resp++;
-				if (t->listener->counters)
-					t->listener->counters->denied_resp++;
-
-				goto return_srv_prx_502;
-			}
-
-			/* add response headers from the rule sets in the same order */
-			list_for_each_entry(wl, &rule_set->rsp_add, list) {
-				if (txn->status < 200)
-					break;
-				if (wl->cond) {
-					int ret = acl_exec_cond(wl->cond, px, t, txn, ACL_DIR_RTR);
-					ret = acl_pass(ret);
-					if (((struct acl_cond *)wl->cond)->pol == ACL_COND_UNLESS)
-						ret = !ret;
-					if (!ret)
-						continue;
-				}
-				if (unlikely(http_header_add_tail(rep, &txn->rsp, &txn->hdr_idx, wl->s) < 0))
-					goto return_bad_resp;
-			}
-
-			/* check whether we're already working on the frontend */
-			if (cur_proxy == t->fe)
-				break;
-			cur_proxy = t->fe;
-		}
-
-		/*
-		 * We may be facing a 100-continue response, in which case this
-		 * is not the right response, and we're waiting for the next one.
-		 * Let's allow this response to go to the client and wait for the
-		 * next one.
-		 */
-		if (unlikely(txn->status == 100)) {
-			hdr_idx_init(&txn->hdr_idx);
-			buffer_forward(rep, rep->lr - msg->sol);
-			msg->msg_state = HTTP_MSG_RPBEFORE;
-			txn->status = 0;
-			rep->analysers |= AN_RES_WAIT_HTTP | an_bit;
-			return 1;
-		}
-		else if (unlikely(txn->status < 200))
-			goto skip_header_mangling;
-
-		/* we don't have any 1xx status code now */
-
-		/*
-		 * 4: check for server cookie.
-		 */
-		if (t->be->cookie_name || t->be->appsession_name || t->fe->capture_name ||
-		    (t->be->options & PR_O_CHK_CACHE))
-			manage_server_side_cookies(t, rep);
-
-
-		/*
-		 * 5: check for cache-control or pragma headers if required.
-		 */
-		if ((t->be->options & (PR_O_COOK_NOC | PR_O_CHK_CACHE)) != 0)
-			check_response_for_cacheability(t, rep);
-
-		/*
-		 * 6: add server cookie in the response if needed
-		 */
-		if ((t->srv) && (t->be->options & PR_O_COOK_INS) &&
-		    !((txn->flags & TX_SCK_FOUND) && (t->be->options2 & PR_O2_COOK_PSV)) &&
-		    (!(t->flags & SN_DIRECT) ||
-		     ((t->be->cookie_maxidle || txn->cookie_last_date) &&
-		      (!txn->cookie_last_date || (txn->cookie_last_date - date.tv_sec) < 0)) ||
-		     (t->be->cookie_maxlife && !txn->cookie_first_date) ||  // set the first_date
-		     (!t->be->cookie_maxlife && txn->cookie_first_date)) && // remove the first_date
-		    (!(t->be->options & PR_O_COOK_POST) || (txn->meth == HTTP_METH_POST)) &&
-		    !(t->flags & SN_IGNORE_PRST)) {
-			int len;
-			/* the server is known, it's not the one the client requested, or the
-			 * cookie's last seen date needs to be refreshed. We have to
-			 * insert a set-cookie here, except if we want to insert only on POST
-			 * requests and this one isn't. Note that servers which don't have cookies
-			 * (eg: some backup servers) will return a full cookie removal request.
-			 */
-			if (!t->srv->cookie) {
-				len = sprintf(trash,
-					      "Set-Cookie: %s=; Expires=Thu, 01-Jan-1970 00:00:01 GMT; path=/",
-					      t->be->cookie_name);
-			}
-			else {
-				len = sprintf(trash, "Set-Cookie: %s=%s", t->be->cookie_name, t->srv->cookie);
-
-				if (t->be->cookie_maxidle || t->be->cookie_maxlife) {
-					/* emit last_date, which is mandatory */
-					trash[len++] = COOKIE_DELIM_DATE;
-					s30tob64((date.tv_sec+3) >> 2, trash + len); len += 5;
-					if (t->be->cookie_maxlife) {
-						/* emit first_date, which is either the original one or
-						 * the current date.
-						 */
-						trash[len++] = COOKIE_DELIM_DATE;
-						s30tob64(txn->cookie_first_date ?
-							 txn->cookie_first_date >> 2 :
-							 (date.tv_sec+3) >> 2, trash + len);
-						len += 5;
-					}
-				}
-				len += sprintf(trash + len, "; path=/");
-			}
-
-			if (t->be->cookie_domain)
-				len += sprintf(trash+len, "; domain=%s", t->be->cookie_domain);
-
-			if (unlikely(http_header_add_tail2(rep, &txn->rsp, &txn->hdr_idx,
-							   trash, len) < 0))
-				goto return_bad_resp;
-
-			txn->flags &= ~TX_SCK_MASK;
-			if (t->srv->cookie && (t->flags & SN_DIRECT))
-				/* the server did not change, only the date was updated */
-				txn->flags |= TX_SCK_UPDATED;
-			else
-				txn->flags |= TX_SCK_INSERTED;
-
-			/* Here, we will tell an eventual cache on the client side that we don't
-			 * want it to cache this reply because HTTP/1.0 caches also cache cookies !
-			 * Some caches understand the correct form: 'no-cache="set-cookie"', but
-			 * others don't (eg: apache <= 1.3.26). So we use 'private' instead.
-			 */
-			if ((t->be->options & PR_O_COOK_NOC) && (txn->flags & TX_CACHEABLE)) {
-
-				txn->flags &= ~TX_CACHEABLE & ~TX_CACHE_COOK;
-
-				if (unlikely(http_header_add_tail2(rep, &txn->rsp, &txn->hdr_idx,
-								   "Cache-control: private", 22) < 0))
-					goto return_bad_resp;
-			}
-		}
-
-		/*
-		 * 7: check if result will be cacheable with a cookie.
-		 * We'll block the response if security checks have caught
-		 * nasty things such as a cacheable cookie.
-		 */
-		if (((txn->flags & (TX_CACHEABLE | TX_CACHE_COOK | TX_SCK_PRESENT)) ==
-		     (TX_CACHEABLE | TX_CACHE_COOK | TX_SCK_PRESENT)) &&
-		    (t->be->options & PR_O_CHK_CACHE)) {
-
-			/* we're in presence of a cacheable response containing
-			 * a set-cookie header. We'll block it as requested by
-			 * the 'checkcache' option, and send an alert.
-			 */
-			if (t->srv)
-				t->srv->counters.failed_secu++;
-
-			cur_proxy->counters.denied_resp++;
-			if (t->listener->counters)
-				t->listener->counters->denied_resp++;
-
-			Alert("Blocking cacheable cookie in response from instance %s, server %s.\n",
-			      t->be->id, t->srv?t->srv->id:"<dispatch>");
-			send_log(t->be, LOG_ALERT,
-				 "Blocking cacheable cookie in response from instance %s, server %s.\n",
-				 t->be->id, t->srv?t->srv->id:"<dispatch>");
-			goto return_srv_prx_502;
-		}
-
-		/*
-		 * 8: adjust "Connection: close" or "Connection: keep-alive" if needed.
-		 */
-		if (((txn->flags & TX_CON_WANT_MSK) != TX_CON_WANT_TUN) ||
-		    ((t->fe->options|t->be->options) & PR_O_HTTP_CLOSE)) {
-			unsigned int want_flags = 0;
-
-			if ((txn->flags & TX_CON_WANT_MSK) == TX_CON_WANT_KAL ||
-			    (txn->flags & TX_CON_WANT_MSK) == TX_CON_WANT_SCL) {
-				/* we want a keep-alive response here. Keep-alive header
-				 * required if either side is not 1.1.
-				 */
-				if ((txn->flags & (TX_REQ_VER_11|TX_RES_VER_11)) != (TX_REQ_VER_11|TX_RES_VER_11))
-					want_flags |= TX_CON_KAL_SET;
-			}
-			else {
-				/* we want a close response here. Close header required if
-				 * the server is 1.1, regardless of the client.
-				 */
-				if (txn->flags & TX_RES_VER_11)
-					want_flags |= TX_CON_CLO_SET;
-			}
-
-			if (want_flags != (txn->flags & (TX_CON_CLO_SET|TX_CON_KAL_SET)))
-				http_change_connection_header(txn, msg, rep, want_flags);
-		}
-
-	skip_header_mangling:
-		if ((txn->flags & TX_RES_XFER_LEN) ||
-		    (txn->flags & TX_CON_WANT_MSK) == TX_CON_WANT_TUN)
-			rep->analysers |= AN_RES_HTTP_XFER_BODY;
-
-		/*************************************************************
-		 * OK, that's finished for the headers. We have done what we *
-		 * could. Let's switch to the DATA state.                    *
-		 ************************************************************/
-
-		t->logs.t_data = tv_ms_elapsed(&t->logs.tv_accept, &now);
-
-		/* if the user wants to log as soon as possible, without counting
-		 * bytes from the server, then this is the right moment. We have
-		 * to temporarily assign bytes_out to log what we currently have.
-		 */
-		if (t->fe->to_log && !(t->logs.logwait & LW_BYTES)) {
-			t->logs.t_close = t->logs.t_data; /* to get a valid end date */
-			t->logs.bytes_out = txn->rsp.eoh;
-			t->do_log(t);
-			t->logs.bytes_out = 0;
-		}
-
-		/* Note: we must not try to cheat by jumping directly to DATA,
-		 * otherwise we would not let the client side wake up.
-		 */
-
-		return 1;
-	}
-	return 1;
-}
-
-/* This function is an analyser which forwards response body (including chunk
- * sizes if any). It is called as soon as we must forward, even if we forward
- * zero byte. The only situation where it must not be called is when we're in
- * tunnel mode and we want to forward till the close. It's used both to forward
- * remaining data and to resync after end of body. It expects the msg_state to
- * be between MSG_BODY and MSG_DONE (inclusive). It returns zero if it needs to
- * read more data, or 1 once we can go on with next request or end the session.
- * When in MSG_DATA or MSG_TRAILERS, it will automatically forward chunk_len
- * bytes of pending data + the headers if not already done (between som and sov).
- * It eventually adjusts som to match sov after the data in between have been sent.
- */
-int http_response_forward_body(struct session *s, struct buffer *res, int an_bit)
-{
-	struct http_txn *txn = &s->txn;
-	struct http_msg *msg = &s->txn.rsp;
-	int bytes;
-
-	if (unlikely(msg->msg_state < HTTP_MSG_BODY))
-		return 0;
-
-	if ((res->flags & (BF_READ_ERROR|BF_READ_TIMEOUT|BF_WRITE_ERROR|BF_WRITE_TIMEOUT)) ||
-	    ((res->flags & BF_SHUTW) && (res->to_forward || res->send_max)) ||
-	    !s->req->analysers) {
-		/* in case of error or if the other analyser went away, we can't analyse HTTP anymore */
-		buffer_ignore(res, res->l - res->send_max);
-		buffer_auto_read(res);
-		buffer_auto_close(res);
-		res->analysers &= ~an_bit;
-		return 1;
-	}
-
-	buffer_dont_close(res);
-
-	if (msg->msg_state < HTTP_MSG_CHUNK_SIZE) {
-		/* we have msg->sov which both points to the first
-		 * byte of message body. msg->som still points to the beginning
-		 * of the message. We must save the body in req->lr because it
-		 * survives buffer re-alignments.
-		 */
-		res->lr = res->data + msg->sov;
-		if (txn->flags & TX_RES_TE_CHNK)
-			msg->msg_state = HTTP_MSG_CHUNK_SIZE;
-		else {
-			msg->msg_state = HTTP_MSG_DATA;
-		}
-	}
-
-	while (1) {
-		int bytes;
-
-		http_silent_debug(__LINE__, s);
-		/* we may have some data pending */
-		bytes = msg->sov - msg->som;
-		if (msg->chunk_len || bytes) {
-			msg->som = msg->sov;
-			if (likely(bytes < 0)) /* sov may have wrapped at the end */
-				bytes += res->size;
-			msg->chunk_len += (unsigned int)bytes;
-			msg->chunk_len -= buffer_forward(res, msg->chunk_len);
-		}
-
-
-		if (msg->msg_state == HTTP_MSG_DATA) {
-			/* must still forward */
-			if (res->to_forward)
-				goto missing_data;
-
-			/* nothing left to forward */
-			if (txn->flags & TX_RES_TE_CHNK)
-				msg->msg_state = HTTP_MSG_DATA_CRLF;
-			else
-				msg->msg_state = HTTP_MSG_DONE;
-		}
-		else if (msg->msg_state == HTTP_MSG_CHUNK_SIZE) {
-			/* read the chunk size and assign it to ->chunk_len, then
-			 * set ->sov to point to the body and switch to DATA or TRAILERS state.
-			 */
-			int ret = http_parse_chunk_size(res, msg);
-
-			if (!ret)
-				goto missing_data;
-			else if (ret < 0) {
-				if (msg->err_pos >= 0)
-					http_capture_bad_message(&s->be->invalid_rep, s, res, msg, HTTP_MSG_CHUNK_SIZE, s->fe);
-				goto return_bad_res;
-			}
-			/* otherwise we're in HTTP_MSG_DATA or HTTP_MSG_TRAILERS state */
-		}
-		else if (msg->msg_state == HTTP_MSG_DATA_CRLF) {
-			/* we want the CRLF after the data */
-			int ret;
-
-			res->lr = res->w + res->send_max;
-			if (res->lr >= res->data + res->size)
-				res->lr -= res->size;
-
-			ret = http_skip_chunk_crlf(res, msg);
-
-			if (!ret)
-				goto missing_data;
-			else if (ret < 0) {
-				if (msg->err_pos >= 0)
-					http_capture_bad_message(&s->be->invalid_rep, s, res, msg, HTTP_MSG_DATA_CRLF, s->fe);
-				goto return_bad_res;
-			}
-			/* we're in MSG_CHUNK_SIZE now */
-		}
-		else if (msg->msg_state == HTTP_MSG_TRAILERS) {
-			int ret = http_forward_trailers(res, msg);
-
-			if (ret == 0)
-				goto missing_data;
-			else if (ret < 0) {
-				if (msg->err_pos >= 0)
-					http_capture_bad_message(&s->be->invalid_rep, s, res, msg, HTTP_MSG_TRAILERS, s->fe);
-				goto return_bad_res;
-			}
-			/* we're in HTTP_MSG_DONE now */
-		}
-		else {
-			int old_state = msg->msg_state;
-
-			/* other states, DONE...TUNNEL */
-			if (http_resync_states(s)) {
-				http_silent_debug(__LINE__, s);
-				/* some state changes occurred, maybe the analyser
-				 * was disabled too.
-				 */
-				if (unlikely(msg->msg_state == HTTP_MSG_ERROR)) {
-					if (res->flags & BF_SHUTW) {
-						/* response errors are most likely due to
-						 * the client aborting the transfer.
-						 */
-						goto aborted_xfer;
-					}
-					if (msg->err_pos >= 0)
-						http_capture_bad_message(&s->be->invalid_rep, s, res, msg, old_state, s->fe);
-					goto return_bad_res;
-				}
-				return 1;
-			}
-			return 0;
-		}
-	}
-
- missing_data:
-	/* stop waiting for data if the input is closed before the end */
-	if (res->flags & BF_SHUTR) {
-		if (!(s->flags & SN_ERR_MASK))
-			s->flags |= SN_ERR_SRVCL;
-		s->be->counters.srv_aborts++;
-		if (s->srv)
-			s->srv->counters.srv_aborts++;
-		goto return_bad_res_stats_ok;
-	}
-
-	if (res->flags & BF_SHUTW)
-		goto aborted_xfer;
-
-	/* we need to obey the req analyser, so if it leaves, we must too */
-	if (!s->req->analysers)
-		goto return_bad_res;
-
-	/* forward any pending data */
-	bytes = msg->sov - msg->som;
-	if (msg->chunk_len || bytes) {
-		msg->som = msg->sov;
-		if (likely(bytes < 0)) /* sov may have wrapped at the end */
-			bytes += res->size;
-		msg->chunk_len += (unsigned int)bytes;
-		msg->chunk_len -= buffer_forward(res, msg->chunk_len);
-	}
-
-	/* We know that more data are expected, but we couldn't send more that
-	 * what we did. So we always set the BF_EXPECT_MORE flag so that the
-	 * system knows it must not set a PUSH on this first part. Interactive
-	 * modes are already handled by the stream sock layer. We must not do
-	 * this in content-length mode because it could present the MSG_MORE
-	 * flag with the last block of forwarded data, which would cause an
-	 * additional delay to be observed by the receiver.
-	 */
-	if (txn->flags & TX_RES_TE_CHNK)
-		res->flags |= BF_EXPECT_MORE;
-
-	/* the session handler will take care of timeouts and errors */
-	http_silent_debug(__LINE__, s);
-	return 0;
-
- return_bad_res: /* let's centralize all bad responses */
-	s->be->counters.failed_resp++;
-	if (s->srv)
-		s->srv->counters.failed_resp++;
-
- return_bad_res_stats_ok:
-	txn->rsp.msg_state = HTTP_MSG_ERROR;
-	/* don't send any error message as we're in the body */
-	stream_int_retnclose(res->cons, NULL);
-	res->analysers = 0;
-	s->req->analysers = 0; /* we're in data phase, we want to abort both directions */
-	if (s->srv)
-		health_adjust(s->srv, HANA_STATUS_HTTP_HDRRSP);
-
-	if (!(s->flags & SN_ERR_MASK))
-		s->flags |= SN_ERR_PRXCOND;
-	if (!(s->flags & SN_FINST_MASK))
-		s->flags |= SN_FINST_D;
-	return 0;
-
- aborted_xfer:
-	txn->rsp.msg_state = HTTP_MSG_ERROR;
-	/* don't send any error message as we're in the body */
-	stream_int_retnclose(res->cons, NULL);
-	res->analysers = 0;
-	s->req->analysers = 0; /* we're in data phase, we want to abort both directions */
-
-	s->fe->counters.cli_aborts++;
-	if (s->fe != s->be)
-		s->be->counters.cli_aborts++;
-	if (s->srv)
-		s->srv->counters.cli_aborts++;
-
-	if (!(s->flags & SN_ERR_MASK))
-		s->flags |= SN_ERR_CLICL;
-	if (!(s->flags & SN_FINST_MASK))
-		s->flags |= SN_FINST_D;
-	return 0;
-}
-
-/* Iterate the same filter through all request headers.
- * Returns 1 if this filter can be stopped upon return, otherwise 0.
- * Since it can manage the switch to another backend, it updates the per-proxy
- * DENY stats.
- */
-int apply_filter_to_req_headers(struct session *t, struct buffer *req, struct hdr_exp *exp)
-{
-	char term;
-	char *cur_ptr, *cur_end, *cur_next;
-	int cur_idx, old_idx, last_hdr;
-	struct http_txn *txn = &t->txn;
-	struct hdr_idx_elem *cur_hdr;
-	int len, delta;
-
-	last_hdr = 0;
-
-	cur_next = txn->req.sol + hdr_idx_first_pos(&txn->hdr_idx);
-	old_idx = 0;
-
-	while (!last_hdr) {
-		if (unlikely(txn->flags & (TX_CLDENY | TX_CLTARPIT)))
-			return 1;
-		else if (unlikely(txn->flags & TX_CLALLOW) &&
-			 (exp->action == ACT_ALLOW ||
-			  exp->action == ACT_DENY ||
-			  exp->action == ACT_TARPIT))
-			return 0;
-
-		cur_idx = txn->hdr_idx.v[old_idx].next;
-		if (!cur_idx)
-			break;
-
-		cur_hdr  = &txn->hdr_idx.v[cur_idx];
-		cur_ptr  = cur_next;
-		cur_end  = cur_ptr + cur_hdr->len;
-		cur_next = cur_end + cur_hdr->cr + 1;
-
-		/* Now we have one header between cur_ptr and cur_end,
-		 * and the next header starts at cur_next.
-		 */
-
-		/* The annoying part is that pattern matching needs
-		 * that we modify the contents to null-terminate all
-		 * strings before testing them.
-		 */
-
-		term = *cur_end;
-		*cur_end = '\0';
-
-		if (regexec(exp->preg, cur_ptr, MAX_MATCH, pmatch, 0) == 0) {
-			switch (exp->action) {
-			case ACT_SETBE:
-				/* It is not possible to jump a second time.
-				 * FIXME: should we return an HTTP/500 here so that
-				 * the admin knows there's a problem ?
-				 */
-				if (t->be != t->fe)
-					break;
-
-				/* Swithing Proxy */
-				session_set_backend(t, (struct proxy *)exp->replace);
-				last_hdr = 1;
-				break;
-
-			case ACT_ALLOW:
-				txn->flags |= TX_CLALLOW;
-				last_hdr = 1;
-				break;
-
-			case ACT_DENY:
-				txn->flags |= TX_CLDENY;
-				last_hdr = 1;
-
-				t->be->counters.denied_req++;
-				if (t->listener->counters)
-					t->listener->counters->denied_req++;
-
-				break;
-
-			case ACT_TARPIT:
-				txn->flags |= TX_CLTARPIT;
-				last_hdr = 1;
-
-				t->be->counters.denied_req++;
-				if (t->listener->counters)
-					t->listener->counters->denied_req++;
-
-				break;
-
-			case ACT_REPLACE:
-				len = exp_replace(trash, cur_ptr, exp->replace, pmatch);
-				delta = buffer_replace2(req, cur_ptr, cur_end, trash, len);
-				/* FIXME: if the user adds a newline in the replacement, the
-				 * index will not be recalculated for now, and the new line
-				 * will not be counted as a new header.
-				 */
-
-				cur_end += delta;
-				cur_next += delta;
-				cur_hdr->len += delta;
-				http_msg_move_end(&txn->req, delta);
-				break;
-
-			case ACT_REMOVE:
-				delta = buffer_replace2(req, cur_ptr, cur_next, NULL, 0);
-				cur_next += delta;
-
-				http_msg_move_end(&txn->req, delta);
-				txn->hdr_idx.v[old_idx].next = cur_hdr->next;
-				txn->hdr_idx.used--;
-				cur_hdr->len = 0;
-				cur_end = NULL; /* null-term has been rewritten */
-				cur_idx = old_idx;
-				break;
-
-			}
-		}
-		if (cur_end)
-			*cur_end = term; /* restore the string terminator */
-
-		/* keep the link from this header to next one in case of later
-		 * removal of next header.
-		 */
-		old_idx = cur_idx;
-	}
-	return 0;
-}
-
-
-/* Apply the filter to the request line.
- * Returns 0 if nothing has been done, 1 if the filter has been applied,
- * or -1 if a replacement resulted in an invalid request line.
- * Since it can manage the switch to another backend, it updates the per-proxy
- * DENY stats.
- */
-int apply_filter_to_req_line(struct session *t, struct buffer *req, struct hdr_exp *exp)
-{
-	char term;
-	char *cur_ptr, *cur_end;
-	int done;
-	struct http_txn *txn = &t->txn;
-	int len, delta;
-
-
-	if (unlikely(txn->flags & (TX_CLDENY | TX_CLTARPIT)))
-		return 1;
-	else if (unlikely(txn->flags & TX_CLALLOW) &&
-		 (exp->action == ACT_ALLOW ||
-		  exp->action == ACT_DENY ||
-		  exp->action == ACT_TARPIT))
-		return 0;
-	else if (exp->action == ACT_REMOVE)
-		return 0;
-
-	done = 0;
-
-	cur_ptr = txn->req.sol;
-	cur_end = cur_ptr + txn->req.sl.rq.l;
-
-	/* Now we have the request line between cur_ptr and cur_end */
-
-	/* The annoying part is that pattern matching needs
-	 * that we modify the contents to null-terminate all
-	 * strings before testing them.
-	 */
-
-	term = *cur_end;
-	*cur_end = '\0';
-
-	if (regexec(exp->preg, cur_ptr, MAX_MATCH, pmatch, 0) == 0) {
-		switch (exp->action) {
-		case ACT_SETBE:
-			/* It is not possible to jump a second time.
-			 * FIXME: should we return an HTTP/500 here so that
-			 * the admin knows there's a problem ?
-			 */
-			if (t->be != t->fe)
-				break;
-
-			/* Swithing Proxy */
-			session_set_backend(t, (struct proxy *)exp->replace);
-			done = 1;
-			break;
-
-		case ACT_ALLOW:
-			txn->flags |= TX_CLALLOW;
-			done = 1;
-			break;
-
-		case ACT_DENY:
-			txn->flags |= TX_CLDENY;
-
-			t->be->counters.denied_req++;
-			if (t->listener->counters)
-				t->listener->counters->denied_req++;
-
-			done = 1;
-			break;
-
-		case ACT_TARPIT:
-			txn->flags |= TX_CLTARPIT;
-
-			t->be->counters.denied_req++;
-			if (t->listener->counters)
-				t->listener->counters->denied_req++;
-
-			done = 1;
-			break;
-
-		case ACT_REPLACE:
-			*cur_end = term; /* restore the string terminator */
-			len = exp_replace(trash, cur_ptr, exp->replace, pmatch);
-			delta = buffer_replace2(req, cur_ptr, cur_end, trash, len);
-			/* FIXME: if the user adds a newline in the replacement, the
-			 * index will not be recalculated for now, and the new line
-			 * will not be counted as a new header.
-			 */
-
-			http_msg_move_end(&txn->req, delta);
-			cur_end += delta;
-			cur_end = (char *)http_parse_reqline(&txn->req, req->data,
-							     HTTP_MSG_RQMETH,
-							     cur_ptr, cur_end + 1,
-							     NULL, NULL);
-			if (unlikely(!cur_end))
-				return -1;
-
-			/* we have a full request and we know that we have either a CR
-			 * or an LF at <ptr>.
-			 */
-			txn->meth = find_http_meth(cur_ptr, txn->req.sl.rq.m_l);
-			hdr_idx_set_start(&txn->hdr_idx, txn->req.sl.rq.l, *cur_end == '\r');
-			/* there is no point trying this regex on headers */
-			return 1;
-		}
-	}
-	*cur_end = term; /* restore the string terminator */
-	return done;
-}
-
-
-
-/*
- * Apply all the req filters of proxy <px> to all headers in buffer <req> of session <s>.
- * Returns 0 if everything is alright, or -1 in case a replacement lead to an
- * unparsable request. Since it can manage the switch to another backend, it
- * updates the per-proxy DENY stats.
- */
-int apply_filters_to_request(struct session *s, struct buffer *req, struct proxy *px)
-{
-	struct http_txn *txn = &s->txn;
-	struct hdr_exp *exp;
-
-	for (exp = px->req_exp; exp; exp = exp->next) {
-		int ret;
-
-		/*
-		 * The interleaving of transformations and verdicts
-		 * makes it difficult to decide to continue or stop
-		 * the evaluation.
-		 */
-
-		if (txn->flags & (TX_CLDENY|TX_CLTARPIT))
-			break;
-
-		if ((txn->flags & TX_CLALLOW) &&
-		    (exp->action == ACT_ALLOW || exp->action == ACT_DENY ||
-		     exp->action == ACT_TARPIT || exp->action == ACT_PASS))
-			continue;
-
-		/* if this filter had a condition, evaluate it now and skip to
-		 * next filter if the condition does not match.
-		 */
-		if (exp->cond) {
-			ret = acl_exec_cond(exp->cond, px, s, txn, ACL_DIR_REQ);
-			ret = acl_pass(ret);
-			if (((struct acl_cond *)exp->cond)->pol == ACL_COND_UNLESS)
-				ret = !ret;
-
-			if (!ret)
-				continue;
-		}
-
-		/* Apply the filter to the request line. */
-		ret = apply_filter_to_req_line(s, req, exp);
-		if (unlikely(ret < 0))
-			return -1;
-
-		if (likely(ret == 0)) {
-			/* The filter did not match the request, it can be
-			 * iterated through all headers.
-			 */
-			apply_filter_to_req_headers(s, req, exp);
-		}
-	}
-	return 0;
-}
-
-
-
-/*
- * Try to retrieve the server associated to the appsession.
- * If the server is found, it's assigned to the session.
- */
-void manage_client_side_appsession(struct session *t, const char *buf, int len) {
-	struct http_txn *txn = &t->txn;
-	appsess *asession = NULL;
-	char *sessid_temp = NULL;
-
-	if (len > t->be->appsession_len) {
-		len = t->be->appsession_len;
-	}
-
-	if (t->be->options2 & PR_O2_AS_REQL) {
-		/* request-learn option is enabled : store the sessid in the session for future use */
-		if (txn->sessid != NULL) {
-			/* free previously allocated memory as we don't need the session id found in the URL anymore */
-			pool_free2(apools.sessid, txn->sessid);
-		}
-
-		if ((txn->sessid = pool_alloc2(apools.sessid)) == NULL) {
-			Alert("Not enough memory process_cli():asession->sessid:malloc().\n");
-			send_log(t->be, LOG_ALERT, "Not enough memory process_cli():asession->sessid:malloc().\n");
-			return;
-		}
-
-		memcpy(txn->sessid, buf, len);
-		txn->sessid[len] = 0;
-	}
-
-	if ((sessid_temp = pool_alloc2(apools.sessid)) == NULL) {
-		Alert("Not enough memory process_cli():asession->sessid:malloc().\n");
-		send_log(t->be, LOG_ALERT, "Not enough memory process_cli():asession->sessid:malloc().\n");
-		return;
-	}
-
-	memcpy(sessid_temp, buf, len);
-	sessid_temp[len] = 0;
-
-	asession = appsession_hash_lookup(&(t->be->htbl_proxy), sessid_temp);
-	/* free previously allocated memory */
-	pool_free2(apools.sessid, sessid_temp);
-
-	if (asession != NULL) {
-		asession->expire = tick_add_ifset(now_ms, t->be->timeout.appsession);
-		if (!(t->be->options2 & PR_O2_AS_REQL))
-			asession->request_count++;
-
-		if (asession->serverid != NULL) {
-			struct server *srv = t->be->srv;
-
-			while (srv) {
-				if (strcmp(srv->id, asession->serverid) == 0) {
-					if ((srv->state & SRV_RUNNING) ||
-					    (t->be->options & PR_O_PERSIST) ||
-					    (t->flags & SN_FORCE_PRST)) {
-						/* we found the server and it's usable */
-						txn->flags &= ~TX_CK_MASK;
-						txn->flags |= (srv->state & SRV_RUNNING) ? TX_CK_VALID : TX_CK_DOWN;
-						t->flags |= SN_DIRECT | SN_ASSIGNED;
-						t->srv = srv;
-						break;
-					} else {
-						txn->flags &= ~TX_CK_MASK;
-						txn->flags |= TX_CK_DOWN;
-					}
-				}
-				srv = srv->next;
-			}
-		}
-	}
-}
-
-/* Find the end of a cookie value contained between <s> and <e>. It works the
- * same way as with headers above except that the semi-colon also ends a token.
- * See RFC2965 for more information. Note that it requires a valid header to
- * return a valid result.
- */
-char *find_cookie_value_end(char *s, const char *e)
-{
-	int quoted, qdpair;
-
-	quoted = qdpair = 0;
-	for (; s < e; s++) {
-		if (qdpair)                    qdpair = 0;
-		else if (quoted) {
-			if (*s == '\\')        qdpair = 1;
-			else if (*s == '"')    quoted = 0;
-		}
-		else if (*s == '"')            quoted = 1;
-		else if (*s == ',' || *s == ';') return s;
-	}
-	return s;
-}
-
-/* Delete a value in a header between delimiters <from> and <next> in buffer
- * <buf>. The number of characters displaced is returned, and the pointer to
- * the first delimiter is updated if required. The function tries as much as
- * possible to respect the following principles :
- *  - replace <from> delimiter by the <next> one unless <from> points to a
- *    colon, in which case <next> is simply removed
- *  - set exactly one space character after the new first delimiter, unless
- *    there are not enough characters in the block being moved to do so.
- *  - remove unneeded spaces before the previous delimiter and after the new
- *    one.
- *
- * It is the caller's responsibility to ensure that :
- *   - <from> points to a valid delimiter or the colon ;
- *   - <next> points to a valid delimiter or the final CR/LF ;
- *   - there are non-space chars before <from> ;
- *   - there is a CR/LF at or after <next>.
- */
-int del_hdr_value(struct buffer *buf, char **from, char *next)
-{
-	char *prev = *from;
-
-	if (*prev == ':') {
-		/* We're removing the first value, preserve the colon and add a
-		 * space if possible.
-		 */
-		if (!http_is_crlf[(unsigned char)*next])
-			next++;
-		prev++;
-		if (prev < next)
-			*prev++ = ' ';
-
-		while (http_is_spht[(unsigned char)*next])
-			next++;
-	} else {
-		/* Remove useless spaces before the old delimiter. */
-		while (http_is_spht[(unsigned char)*(prev-1)])
-			prev--;
-		*from = prev;
-
-		/* copy the delimiter and if possible a space if we're
-		 * not at the end of the line.
-		 */
-		if (!http_is_crlf[(unsigned char)*next]) {
-			*prev++ = *next++;
-			if (prev + 1 < next)
-				*prev++ = ' ';
-			while (http_is_spht[(unsigned char)*next])
-				next++;
-		}
-	}
-	return buffer_replace2(buf, prev, next, NULL, 0);
-}
-
-/*
- * Manage client-side cookie. It can impact performance by about 2% so it is
- * desirable to call it only when needed. This code is quite complex because
- * of the multiple very crappy and ambiguous syntaxes we have to support. it
- * highly recommended not to touch this part without a good reason !
- */
-void manage_client_side_cookies(struct session *t, struct buffer *req)
-{
-	struct http_txn *txn = &t->txn;
-	int preserve_hdr;
-	int cur_idx, old_idx;
-	char *hdr_beg, *hdr_end, *hdr_next, *del_from;
-	char *prev, *att_beg, *att_end, *equal, *val_beg, *val_end, *next;
-
-	/* Iterate through the headers, we start with the start line. */
-	old_idx = 0;
-	hdr_next = txn->req.sol + hdr_idx_first_pos(&txn->hdr_idx);
-
-	while ((cur_idx = txn->hdr_idx.v[old_idx].next)) {
-		struct hdr_idx_elem *cur_hdr;
-		int val;
-
-		cur_hdr  = &txn->hdr_idx.v[cur_idx];
-		hdr_beg  = hdr_next;
-		hdr_end  = hdr_beg + cur_hdr->len;
-		hdr_next = hdr_end + cur_hdr->cr + 1;
-
-		/* We have one full header between hdr_beg and hdr_end, and the
-		 * next header starts at hdr_next. We're only interested in
-		 * "Cookie:" headers.
-		 */
-
-		val = http_header_match2(hdr_beg, hdr_end, "Cookie", 6);
-		if (!val) {
-			old_idx = cur_idx;
-			continue;
-		}
-
-		del_from = NULL;  /* nothing to be deleted */
-		preserve_hdr = 0; /* assume we may kill the whole header */
-
-		/* Now look for cookies. Conforming to RFC2109, we have to support
-		 * attributes whose name begin with a '$', and associate them with
-		 * the right cookie, if we want to delete this cookie.
-		 * So there are 3 cases for each cookie read :
-		 * 1) it's a special attribute, beginning with a '$' : ignore it.
-		 * 2) it's a server id cookie that we *MAY* want to delete : save
-		 *    some pointers on it (last semi-colon, beginning of cookie...)
-		 * 3) it's an application cookie : we *MAY* have to delete a previous
-		 *    "special" cookie.
-		 * At the end of loop, if a "special" cookie remains, we may have to
-		 * remove it. If no application cookie persists in the header, we
-		 * *MUST* delete it.
-		 *
-		 * Note: RFC2965 is unclear about the processing of spaces around
-		 * the equal sign in the ATTR=VALUE form. A careful inspection of
-		 * the RFC explicitly allows spaces before it, and not within the
-		 * tokens (attrs or values). An inspection of RFC2109 allows that
-		 * too but section 10.1.3 lets one think that spaces may be allowed
-		 * after the equal sign too, resulting in some (rare) buggy
-		 * implementations trying to do that. So let's do what servers do.
-		 * Latest ietf draft forbids spaces all around. Also, earlier RFCs
-		 * allowed quoted strings in values, with any possible character
-		 * after a backslash, including control chars and delimitors, which
-		 * causes parsing to become ambiguous. Browsers also allow spaces
-		 * within values even without quotes.
-		 *
-		 * We have to keep multiple pointers in order to support cookie
-		 * removal at the beginning, middle or end of header without
-		 * corrupting the header. All of these headers are valid :
-		 *
-		 * Cookie:NAME1=VALUE1;NAME2=VALUE2;NAME3=VALUE3\r\n
-		 * Cookie:NAME1=VALUE1;NAME2_ONLY ;NAME3=VALUE3\r\n
-		 * Cookie:    NAME1  =  VALUE 1  ; NAME2 = VALUE2 ; NAME3 = VALUE3\r\n
-		 * |     |    |    | |  |      | |                                |
-		 * |     |    |    | |  |      | |                     hdr_end <--+
-		 * |     |    |    | |  |      | +--> next
-		 * |     |    |    | |  |      +----> val_end
-		 * |     |    |    | |  +-----------> val_beg
-		 * |     |    |    | +--------------> equal
-		 * |     |    |    +----------------> att_end
-		 * |     |    +---------------------> att_beg
-		 * |     +--------------------------> prev
-		 * +--------------------------------> hdr_beg
-		 */
-
-		for (prev = hdr_beg + 6; prev < hdr_end; prev = next) {
-			/* Iterate through all cookies on this line */
-
-			/* find att_beg */
-			att_beg = prev + 1;
-			while (att_beg < hdr_end && http_is_spht[(unsigned char)*att_beg])
-				att_beg++;
-
-			/* find att_end : this is the first character after the last non
-			 * space before the equal. It may be equal to hdr_end.
-			 */
-			equal = att_end = att_beg;
-
-			while (equal < hdr_end) {
-				if (*equal == '=' || *equal == ',' || *equal == ';')
-					break;
-				if (http_is_spht[(unsigned char)*equal++])
-					continue;
-				att_end = equal;
-			}
-
-			/* here, <equal> points to '=', a delimitor or the end. <att_end>
-			 * is between <att_beg> and <equal>, both may be identical.
-			 */
-
-			/* look for end of cookie if there is an equal sign */
-			if (equal < hdr_end && *equal == '=') {
-				/* look for the beginning of the value */
-				val_beg = equal + 1;
-				while (val_beg < hdr_end && http_is_spht[(unsigned char)*val_beg])
-					val_beg++;
-
-				/* find the end of the value, respecting quotes */
-				next = find_cookie_value_end(val_beg, hdr_end);
-
-				/* make val_end point to the first white space or delimitor after the value */
-				val_end = next;
-				while (val_end > val_beg && http_is_spht[(unsigned char)*(val_end - 1)])
-					val_end--;
-			} else {
-				val_beg = val_end = next = equal;
-			}
-
-			/* We have nothing to do with attributes beginning with '$'. However,
-			 * they will automatically be removed if a header before them is removed,
-			 * since they're supposed to be linked together.
-			 */
-			if (*att_beg == '$')
-				continue;
-
-			/* Ignore cookies with no equal sign */
-			if (equal == next) {
-				/* This is not our cookie, so we must preserve it. But if we already
-				 * scheduled another cookie for removal, we cannot remove the
-				 * complete header, but we can remove the previous block itself.
-				 */
-				preserve_hdr = 1;
-				if (del_from != NULL) {
-					int delta = del_hdr_value(req, &del_from, prev);
-					val_end  += delta;
-					next     += delta;
-					hdr_end  += delta;
-					hdr_next += delta;
-					cur_hdr->len += delta;
-					http_msg_move_end(&txn->req, delta);
-					prev     = del_from;
-					del_from = NULL;
-				}
-				continue;
-			}
-
-			/* if there are spaces around the equal sign, we need to
-			 * strip them otherwise we'll get trouble for cookie captures,
-			 * or even for rewrites. Since this happens extremely rarely,
-			 * it does not hurt performance.
-			 */
-			if (unlikely(att_end != equal || val_beg > equal + 1)) {
-				int stripped_before = 0;
-				int stripped_after = 0;
-
-				if (att_end != equal) {
-					stripped_before = buffer_replace2(req, att_end, equal, NULL, 0);
-					equal   += stripped_before;
-					val_beg += stripped_before;
-				}
-
-				if (val_beg > equal + 1) {
-					stripped_after = buffer_replace2(req, equal + 1, val_beg, NULL, 0);
-					val_beg += stripped_after;
-					stripped_before += stripped_after;
-				}
-
-				val_end      += stripped_before;
-				next         += stripped_before;
-				hdr_end      += stripped_before;
-				hdr_next     += stripped_before;
-				cur_hdr->len += stripped_before;
-				http_msg_move_end(&txn->req, stripped_before);
-			}
-			/* now everything is as on the diagram above */
-
-			/* First, let's see if we want to capture this cookie. We check
-			 * that we don't already have a client side cookie, because we
-			 * can only capture one. Also as an optimisation, we ignore
-			 * cookies shorter than the declared name.
-			 */
-			if (t->fe->capture_name != NULL && txn->cli_cookie == NULL &&
-			    (val_end - att_beg >= t->fe->capture_namelen) &&
-			    memcmp(att_beg, t->fe->capture_name, t->fe->capture_namelen) == 0) {
-				int log_len = val_end - att_beg;
-
-				if ((txn->cli_cookie = pool_alloc2(pool2_capture)) == NULL) {
-					Alert("HTTP logging : out of memory.\n");
-				} else {
-					if (log_len > t->fe->capture_len)
-						log_len = t->fe->capture_len;
-					memcpy(txn->cli_cookie, att_beg, log_len);
-					txn->cli_cookie[log_len] = 0;
-				}
-			}
-
-			/* Persistence cookies in passive, rewrite or insert mode have the
-			 * following form :
-			 *
-			 *    Cookie: NAME=SRV[|<lastseen>[|<firstseen>]]
-			 *
-			 * For cookies in prefix mode, the form is :
-			 *
-			 *    Cookie: NAME=SRV~VALUE
-			 */
-			if ((att_end - att_beg == t->be->cookie_len) && (t->be->cookie_name != NULL) &&
-			    (memcmp(att_beg, t->be->cookie_name, att_end - att_beg) == 0)) {
-				struct server *srv = t->be->srv;
-				char *delim;
-
-				/* if we're in cookie prefix mode, we'll search the delimitor so that we
-				 * have the server ID between val_beg and delim, and the original cookie between
-				 * delim+1 and val_end. Otherwise, delim==val_end :
-				 *
-				 * Cookie: NAME=SRV;          # in all but prefix modes
-				 * Cookie: NAME=SRV~OPAQUE ;  # in prefix mode
-				 * |      ||   ||  |      |+-> next
-				 * |      ||   ||  |      +--> val_end
-				 * |      ||   ||  +---------> delim
-				 * |      ||   |+------------> val_beg
-				 * |      ||   +-------------> att_end = equal
-				 * |      |+-----------------> att_beg
-				 * |      +------------------> prev
-				 * +-------------------------> hdr_beg
-				 */
-
-				if (t->be->options & PR_O_COOK_PFX) {
-					for (delim = val_beg; delim < val_end; delim++)
-						if (*delim == COOKIE_DELIM)
-							break;
-				} else {
-					char *vbar1;
-					delim = val_end;
-					/* Now check if the cookie contains a date field, which would
-					 * appear after a vertical bar ('|') just after the server name
-					 * and before the delimiter.
-					 */
-					vbar1 = memchr(val_beg, COOKIE_DELIM_DATE, val_end - val_beg);
-					if (vbar1) {
-						/* OK, so left of the bar is the server's cookie and
-						 * right is the last seen date. It is a base64 encoded
-						 * 30-bit value representing the UNIX date since the
-						 * epoch in 4-second quantities.
-						 */
-						int val;
-						delim = vbar1++;
-						if (val_end - vbar1 >= 5) {
-							val = b64tos30(vbar1);
-							if (val > 0)
-								txn->cookie_last_date = val << 2;
-						}
-						/* look for a second vertical bar */
-						vbar1 = memchr(vbar1, COOKIE_DELIM_DATE, val_end - vbar1);
-						if (vbar1 && (val_end - vbar1 > 5)) {
-							val = b64tos30(vbar1 + 1);
-							if (val > 0)
-								txn->cookie_first_date = val << 2;
-						}
-					}
-				}
-
-				/* if the cookie has an expiration date and the proxy wants to check
-				 * it, then we do that now. We first check if the cookie is too old,
-				 * then only if it has expired. We detect strict overflow because the
-				 * time resolution here is not great (4 seconds). Cookies with dates
-				 * in the future are ignored if their offset is beyond one day. This
-				 * allows an admin to fix timezone issues without expiring everyone
-				 * and at the same time avoids keeping unwanted side effects for too
-				 * long.
-				 */
-				if (txn->cookie_first_date && t->be->cookie_maxlife &&
-				    (((signed)(date.tv_sec - txn->cookie_first_date) > (signed)t->be->cookie_maxlife) ||
-				     ((signed)(txn->cookie_first_date - date.tv_sec) > 86400))) {
-					txn->flags &= ~TX_CK_MASK;
-					txn->flags |= TX_CK_OLD;
-					delim = val_beg; // let's pretend we have not found the cookie
-					txn->cookie_first_date = 0;
-					txn->cookie_last_date = 0;
-				}
-				else if (txn->cookie_last_date && t->be->cookie_maxidle &&
-					 (((signed)(date.tv_sec - txn->cookie_last_date) > (signed)t->be->cookie_maxidle) ||
-					  ((signed)(txn->cookie_last_date - date.tv_sec) > 86400))) {
-					txn->flags &= ~TX_CK_MASK;
-					txn->flags |= TX_CK_EXPIRED;
-					delim = val_beg; // let's pretend we have not found the cookie
-					txn->cookie_first_date = 0;
-					txn->cookie_last_date = 0;
-				}
-
-				/* Here, we'll look for the first running server which supports the cookie.
-				 * This allows to share a same cookie between several servers, for example
-				 * to dedicate backup servers to specific servers only.
-				 * However, to prevent clients from sticking to cookie-less backup server
-				 * when they have incidentely learned an empty cookie, we simply ignore
-				 * empty cookies and mark them as invalid.
-				 * The same behaviour is applied when persistence must be ignored.
-				 */
-				if ((delim == val_beg) || (t->flags & SN_IGNORE_PRST))
-					srv = NULL;
-
-				while (srv) {
-					if (srv->cookie && (srv->cklen == delim - val_beg) &&
-					    !memcmp(val_beg, srv->cookie, delim - val_beg)) {
-						if ((srv->state & SRV_RUNNING) ||
-						    (t->be->options & PR_O_PERSIST) ||
-						    (t->flags & SN_FORCE_PRST)) {
-							/* we found the server and we can use it */
-							txn->flags &= ~TX_CK_MASK;
-							txn->flags |= (srv->state & SRV_RUNNING) ? TX_CK_VALID : TX_CK_DOWN;
-							t->flags |= SN_DIRECT | SN_ASSIGNED;
-							t->srv = srv;
-							break;
-						} else {
-							/* we found a server, but it's down,
-							 * mark it as such and go on in case
-							 * another one is available.
-							 */
-							txn->flags &= ~TX_CK_MASK;
-							txn->flags |= TX_CK_DOWN;
-						}
-					}
-					srv = srv->next;
-				}
-
-				if (!srv && !(txn->flags & (TX_CK_DOWN|TX_CK_EXPIRED|TX_CK_OLD))) {
-					/* no server matched this cookie */
-					txn->flags &= ~TX_CK_MASK;
-					txn->flags |= TX_CK_INVALID;
-				}
-
-				/* depending on the cookie mode, we may have to either :
-				 * - delete the complete cookie if we're in insert+indirect mode, so that
-				 *   the server never sees it ;
-				 * - remove the server id from the cookie value, and tag the cookie as an
-				 *   application cookie so that it does not get accidentely removed later,
-				 *   if we're in cookie prefix mode
-				 */
-				if ((t->be->options & PR_O_COOK_PFX) && (delim != val_end)) {
-					int delta; /* negative */
-
-					delta = buffer_replace2(req, val_beg, delim + 1, NULL, 0);
-					val_end  += delta;
-					next     += delta;
-					hdr_end  += delta;
-					hdr_next += delta;
-					cur_hdr->len += delta;
-					http_msg_move_end(&txn->req, delta);
-
-					del_from = NULL;
-					preserve_hdr = 1; /* we want to keep this cookie */
-				}
-				else if (del_from == NULL &&
-					 (t->be->options & (PR_O_COOK_INS | PR_O_COOK_IND)) == (PR_O_COOK_INS | PR_O_COOK_IND)) {
-					del_from = prev;
-				}
-			} else {
-				/* This is not our cookie, so we must preserve it. But if we already
-				 * scheduled another cookie for removal, we cannot remove the
-				 * complete header, but we can remove the previous block itself.
-				 */
-				preserve_hdr = 1;
-
-				if (del_from != NULL) {
-					int delta = del_hdr_value(req, &del_from, prev);
-					if (att_beg >= del_from)
-						att_beg += delta;
-					if (att_end >= del_from)
-						att_end += delta;
-					val_beg  += delta;
-					val_end  += delta;
-					next     += delta;
-					hdr_end  += delta;
-					hdr_next += delta;
-					cur_hdr->len += delta;
-					http_msg_move_end(&txn->req, delta);
-					prev     = del_from;
-					del_from = NULL;
-				}
-			}
-
-			/* Look for the appsession cookie unless persistence must be ignored */
-			if (!(t->flags & SN_IGNORE_PRST) && (t->be->appsession_name != NULL)) {
-				int cmp_len, value_len;
-				char *value_begin;
-
-				if (t->be->options2 & PR_O2_AS_PFX) {
-					cmp_len     = MIN(val_end - att_beg, t->be->appsession_name_len);
-					value_begin = att_beg + t->be->appsession_name_len;
-					value_len   = val_end - att_beg - t->be->appsession_name_len;
-				} else {
-					cmp_len     = att_end - att_beg;
-					value_begin = val_beg;
-					value_len   = val_end - val_beg;
-				}
-
-				/* let's see if the cookie is our appcookie */
-				if (cmp_len == t->be->appsession_name_len &&
-				    memcmp(att_beg, t->be->appsession_name, cmp_len) == 0) {
-					manage_client_side_appsession(t, value_begin, value_len);
-				}
-			}
-
-			/* continue with next cookie on this header line */
-			att_beg = next;
-		} /* for each cookie */
-
-		/* There are no more cookies on this line.
-		 * We may still have one (or several) marked for deletion at the
-		 * end of the line. We must do this now in two ways :
-		 *  - if some cookies must be preserved, we only delete from the
-		 *    mark to the end of line ;
-		 *  - if nothing needs to be preserved, simply delete the whole header
-		 */
-		if (del_from) {
-			int delta;
-			if (preserve_hdr) {
-				delta = del_hdr_value(req, &del_from, hdr_end);
-				hdr_end = del_from;
-				cur_hdr->len += delta;
-			} else {
-				delta = buffer_replace2(req, hdr_beg, hdr_next, NULL, 0);
-
-				/* FIXME: this should be a separate function */
-				txn->hdr_idx.v[old_idx].next = cur_hdr->next;
-				txn->hdr_idx.used--;
-				cur_hdr->len = 0;
-				cur_idx = old_idx;
-			}
-			hdr_next += delta;
-			http_msg_move_end(&txn->req, delta);
-		}
-
-		/* check next header */
-		old_idx = cur_idx;
-	}
-}
-
-
-/* Iterate the same filter through all response headers contained in <rtr>.
- * Returns 1 if this filter can be stopped upon return, otherwise 0.
- */
-int apply_filter_to_resp_headers(struct session *t, struct buffer *rtr, struct hdr_exp *exp)
-{
-	char term;
-	char *cur_ptr, *cur_end, *cur_next;
-	int cur_idx, old_idx, last_hdr;
-	struct http_txn *txn = &t->txn;
-	struct hdr_idx_elem *cur_hdr;
-	int len, delta;
-
-	last_hdr = 0;
-
-	cur_next = txn->rsp.sol + hdr_idx_first_pos(&txn->hdr_idx);
-	old_idx = 0;
-
-	while (!last_hdr) {
-		if (unlikely(txn->flags & TX_SVDENY))
-			return 1;
-		else if (unlikely(txn->flags & TX_SVALLOW) &&
-			 (exp->action == ACT_ALLOW ||
-			  exp->action == ACT_DENY))
-			return 0;
-
-		cur_idx = txn->hdr_idx.v[old_idx].next;
-		if (!cur_idx)
-			break;
-
-		cur_hdr  = &txn->hdr_idx.v[cur_idx];
-		cur_ptr  = cur_next;
-		cur_end  = cur_ptr + cur_hdr->len;
-		cur_next = cur_end + cur_hdr->cr + 1;
-
-		/* Now we have one header between cur_ptr and cur_end,
-		 * and the next header starts at cur_next.
-		 */
-
-		/* The annoying part is that pattern matching needs
-		 * that we modify the contents to null-terminate all
-		 * strings before testing them.
-		 */
-
-		term = *cur_end;
-		*cur_end = '\0';
-
-		if (regexec(exp->preg, cur_ptr, MAX_MATCH, pmatch, 0) == 0) {
-			switch (exp->action) {
-			case ACT_ALLOW:
-				txn->flags |= TX_SVALLOW;
-				last_hdr = 1;
-				break;
-
-			case ACT_DENY:
-				txn->flags |= TX_SVDENY;
-				last_hdr = 1;
-				break;
-
-			case ACT_REPLACE:
-				len = exp_replace(trash, cur_ptr, exp->replace, pmatch);
-				delta = buffer_replace2(rtr, cur_ptr, cur_end, trash, len);
-				/* FIXME: if the user adds a newline in the replacement, the
-				 * index will not be recalculated for now, and the new line
-				 * will not be counted as a new header.
-				 */
-
-				cur_end += delta;
-				cur_next += delta;
-				cur_hdr->len += delta;
-				http_msg_move_end(&txn->rsp, delta);
-				break;
-
-			case ACT_REMOVE:
-				delta = buffer_replace2(rtr, cur_ptr, cur_next, NULL, 0);
-				cur_next += delta;
-
-				http_msg_move_end(&txn->rsp, delta);
-				txn->hdr_idx.v[old_idx].next = cur_hdr->next;
-				txn->hdr_idx.used--;
-				cur_hdr->len = 0;
-				cur_end = NULL; /* null-term has been rewritten */
-				cur_idx = old_idx;
-				break;
-
-			}
-		}
-		if (cur_end)
-			*cur_end = term; /* restore the string terminator */
-
-		/* keep the link from this header to next one in case of later
-		 * removal of next header.
-		 */
-		old_idx = cur_idx;
-	}
-	return 0;
-}
-
-
-/* Apply the filter to the status line in the response buffer <rtr>.
- * Returns 0 if nothing has been done, 1 if the filter has been applied,
- * or -1 if a replacement resulted in an invalid status line.
- */
-int apply_filter_to_sts_line(struct session *t, struct buffer *rtr, struct hdr_exp *exp)
-{
-	char term;
-	char *cur_ptr, *cur_end;
-	int done;
-	struct http_txn *txn = &t->txn;
-	int len, delta;
-
-
-	if (unlikely(txn->flags & TX_SVDENY))
-		return 1;
-	else if (unlikely(txn->flags & TX_SVALLOW) &&
-		 (exp->action == ACT_ALLOW ||
-		  exp->action == ACT_DENY))
-		return 0;
-	else if (exp->action == ACT_REMOVE)
-		return 0;
-
-	done = 0;
-
-	cur_ptr = txn->rsp.sol;
-	cur_end = cur_ptr + txn->rsp.sl.st.l;
-
-	/* Now we have the status line between cur_ptr and cur_end */
-
-	/* The annoying part is that pattern matching needs
-	 * that we modify the contents to null-terminate all
-	 * strings before testing them.
-	 */
-
-	term = *cur_end;
-	*cur_end = '\0';
-
-	if (regexec(exp->preg, cur_ptr, MAX_MATCH, pmatch, 0) == 0) {
-		switch (exp->action) {
-		case ACT_ALLOW:
-			txn->flags |= TX_SVALLOW;
-			done = 1;
-			break;
-
-		case ACT_DENY:
-			txn->flags |= TX_SVDENY;
-			done = 1;
-			break;
-
-		case ACT_REPLACE:
-			*cur_end = term; /* restore the string terminator */
-			len = exp_replace(trash, cur_ptr, exp->replace, pmatch);
-			delta = buffer_replace2(rtr, cur_ptr, cur_end, trash, len);
-			/* FIXME: if the user adds a newline in the replacement, the
-			 * index will not be recalculated for now, and the new line
-			 * will not be counted as a new header.
-			 */
-
-			http_msg_move_end(&txn->rsp, delta);
-			cur_end += delta;
-			cur_end = (char *)http_parse_stsline(&txn->rsp, rtr->data,
-							     HTTP_MSG_RPVER,
-							     cur_ptr, cur_end + 1,
-							     NULL, NULL);
-			if (unlikely(!cur_end))
-				return -1;
-
-			/* we have a full respnse and we know that we have either a CR
-			 * or an LF at <ptr>.
-			 */
-			txn->status = strl2ui(txn->rsp.sol + txn->rsp.sl.st.c, txn->rsp.sl.st.c_l);
-			hdr_idx_set_start(&txn->hdr_idx, txn->rsp.sl.st.l, *cur_end == '\r');
-			/* there is no point trying this regex on headers */
-			return 1;
-		}
-	}
-	*cur_end = term; /* restore the string terminator */
-	return done;
-}
-
-
-
-/*
- * Apply all the resp filters of proxy <px> to all headers in buffer <rtr> of session <s>.
- * Returns 0 if everything is alright, or -1 in case a replacement lead to an
- * unparsable response.
- */
-int apply_filters_to_response(struct session *s, struct buffer *rtr, struct proxy *px)
-{
-	struct http_txn *txn = &s->txn;
-	struct hdr_exp *exp;
-
-	for (exp = px->rsp_exp; exp; exp = exp->next) {
-		int ret;
-
-		/*
-		 * The interleaving of transformations and verdicts
-		 * makes it difficult to decide to continue or stop
-		 * the evaluation.
-		 */
-
-		if (txn->flags & TX_SVDENY)
-			break;
-
-		if ((txn->flags & TX_SVALLOW) &&
-		    (exp->action == ACT_ALLOW || exp->action == ACT_DENY ||
-		     exp->action == ACT_PASS)) {
-			exp = exp->next;
-			continue;
-		}
-
-		/* if this filter had a condition, evaluate it now and skip to
-		 * next filter if the condition does not match.
-		 */
-		if (exp->cond) {
-			ret = acl_exec_cond(exp->cond, px, s, txn, ACL_DIR_RTR);
-			ret = acl_pass(ret);
-			if (((struct acl_cond *)exp->cond)->pol == ACL_COND_UNLESS)
-				ret = !ret;
-			if (!ret)
-				continue;
-		}
-
-		/* Apply the filter to the status line. */
-		ret = apply_filter_to_sts_line(s, rtr, exp);
-		if (unlikely(ret < 0))
-			return -1;
-
-		if (likely(ret == 0)) {
-			/* The filter did not match the response, it can be
-			 * iterated through all headers.
-			 */
-			apply_filter_to_resp_headers(s, rtr, exp);
-		}
-	}
-	return 0;
-}
-
-
-/*
- * Manage server-side cookies. It can impact performance by about 2% so it is
- * desirable to call it only when needed. This function is also used when we
- * just need to know if there is a cookie (eg: for check-cache).
- */
-void manage_server_side_cookies(struct session *t, struct buffer *res)
-{
-	struct http_txn *txn = &t->txn;
-	int is_cookie2;
-	int cur_idx, old_idx, delta;
-	char *hdr_beg, *hdr_end, *hdr_next;
-	char *prev, *att_beg, *att_end, *equal, *val_beg, *val_end, *next;
-
-	/* Iterate through the headers.
-	 * we start with the start line.
-	 */
-	old_idx = 0;
-	hdr_next = txn->rsp.sol + hdr_idx_first_pos(&txn->hdr_idx);
-
-	while ((cur_idx = txn->hdr_idx.v[old_idx].next)) {
-		struct hdr_idx_elem *cur_hdr;
-		int val;
-
-		cur_hdr  = &txn->hdr_idx.v[cur_idx];
-		hdr_beg  = hdr_next;
-		hdr_end  = hdr_beg + cur_hdr->len;
-		hdr_next = hdr_end + cur_hdr->cr + 1;
-
-		/* We have one full header between hdr_beg and hdr_end, and the
-		 * next header starts at hdr_next. We're only interested in
-		 * "Set-Cookie" and "Set-Cookie2" headers.
-		 */
-
-		is_cookie2 = 0;
-		prev = hdr_beg + 10;
-		val = http_header_match2(hdr_beg, hdr_end, "Set-Cookie", 10);
-		if (!val) {
-			val = http_header_match2(hdr_beg, hdr_end, "Set-Cookie2", 11);
-			if (!val) {
-				old_idx = cur_idx;
-				continue;
-			}
-			is_cookie2 = 1;
-			prev = hdr_beg + 11;
-		}
-
-		/* OK, right now we know we have a Set-Cookie* at hdr_beg, and
-		 * <prev> points to the colon.
-		 */
-		txn->flags |= TX_SCK_PRESENT;
-
-		/* Maybe we only wanted to see if there was a Set-Cookie (eg:
-		 * check-cache is enabled) and we are not interested in checking
-		 * them. Warning, the cookie capture is declared in the frontend.
-		 */
-		if (t->be->cookie_name == NULL &&
-		    t->be->appsession_name == NULL &&
-		    t->fe->capture_name == NULL)
-			return;
-
-		/* OK so now we know we have to process this response cookie.
-		 * The format of the Set-Cookie header is slightly different
-		 * from the format of the Cookie header in that it does not
-		 * support the comma as a cookie delimiter (thus the header
-		 * cannot be folded) because the Expires attribute described in
-		 * the original Netscape's spec may contain an unquoted date
-		 * with a comma inside. We have to live with this because
-		 * many browsers don't support Max-Age and some browsers don't
-		 * support quoted strings. However the Set-Cookie2 header is
-		 * clean.
-		 *
-		 * We have to keep multiple pointers in order to support cookie
-		 * removal at the beginning, middle or end of header without
-		 * corrupting the header (in case of set-cookie2). A special
-		 * pointer, <scav> points to the beginning of the set-cookie-av
-		 * fields after the first semi-colon. The <next> pointer points
-		 * either to the end of line (set-cookie) or next unquoted comma
-		 * (set-cookie2). All of these headers are valid :
-		 *
-		 * Set-Cookie:    NAME1  =  VALUE 1  ; Secure; Path="/"\r\n
-		 * Set-Cookie:NAME=VALUE; Secure; Expires=Thu, 01-Jan-1970 00:00:01 GMT\r\n
-		 * Set-Cookie: NAME = VALUE ; Secure; Expires=Thu, 01-Jan-1970 00:00:01 GMT\r\n
-		 * Set-Cookie2: NAME1 = VALUE 1 ; Max-Age=0, NAME2=VALUE2; Discard\r\n
-		 * |          | |   | | |     | |          |                      |
-		 * |          | |   | | |     | |          +-> next    hdr_end <--+
-		 * |          | |   | | |     | +------------> scav
-		 * |          | |   | | |     +--------------> val_end
-		 * |          | |   | | +--------------------> val_beg
-		 * |          | |   | +----------------------> equal
-		 * |          | |   +------------------------> att_end
-		 * |          | +----------------------------> att_beg
-		 * |          +------------------------------> prev
-		 * +-----------------------------------------> hdr_beg
-		 */
-
-		for (; prev < hdr_end; prev = next) {
-			/* Iterate through all cookies on this line */
-
-			/* find att_beg */
-			att_beg = prev + 1;
-			while (att_beg < hdr_end && http_is_spht[(unsigned char)*att_beg])
-				att_beg++;
-
-			/* find att_end : this is the first character after the last non
-			 * space before the equal. It may be equal to hdr_end.
-			 */
-			equal = att_end = att_beg;
-
-			while (equal < hdr_end) {
-				if (*equal == '=' || *equal == ';' || (is_cookie2 && *equal == ','))
-					break;
-				if (http_is_spht[(unsigned char)*equal++])
-					continue;
-				att_end = equal;
-			}
-
-			/* here, <equal> points to '=', a delimitor or the end. <att_end>
-			 * is between <att_beg> and <equal>, both may be identical.
-			 */
-
-			/* look for end of cookie if there is an equal sign */
-			if (equal < hdr_end && *equal == '=') {
-				/* look for the beginning of the value */
-				val_beg = equal + 1;
-				while (val_beg < hdr_end && http_is_spht[(unsigned char)*val_beg])
-					val_beg++;
-
-				/* find the end of the value, respecting quotes */
-				next = find_cookie_value_end(val_beg, hdr_end);
-
-				/* make val_end point to the first white space or delimitor after the value */
-				val_end = next;
-				while (val_end > val_beg && http_is_spht[(unsigned char)*(val_end - 1)])
-					val_end--;
-			} else {
-				/* <equal> points to next comma, semi-colon or EOL */
-				val_beg = val_end = next = equal;
-			}
-
-			if (next < hdr_end) {
-				/* Set-Cookie2 supports multiple cookies, and <next> points to
-				 * a colon or semi-colon before the end. So skip all attr-value
-				 * pairs and look for the next comma. For Set-Cookie, since
-				 * commas are permitted in values, skip to the end.
-				 */
-				if (is_cookie2)
-					next = find_hdr_value_end(next, hdr_end);
-				else
-					next = hdr_end;
-			}
-
-			/* Now everything is as on the diagram above */
-
-			/* Ignore cookies with no equal sign */
-			if (equal == val_end)
-				continue;
-
-			/* If there are spaces around the equal sign, we need to
-			 * strip them otherwise we'll get trouble for cookie captures,
-			 * or even for rewrites. Since this happens extremely rarely,
-			 * it does not hurt performance.
-			 */
-			if (unlikely(att_end != equal || val_beg > equal + 1)) {
-				int stripped_before = 0;
-				int stripped_after = 0;
-
-				if (att_end != equal) {
-					stripped_before = buffer_replace2(res, att_end, equal, NULL, 0);
-					equal   += stripped_before;
-					val_beg += stripped_before;
-				}
-
-				if (val_beg > equal + 1) {
-					stripped_after = buffer_replace2(res, equal + 1, val_beg, NULL, 0);
-					val_beg += stripped_after;
-					stripped_before += stripped_after;
-				}
-
-				val_end      += stripped_before;
-				next         += stripped_before;
-				hdr_end      += stripped_before;
-				hdr_next     += stripped_before;
-				cur_hdr->len += stripped_before;
-				http_msg_move_end(&txn->rsp, stripped_before);
-			}
-
-			/* First, let's see if we want to capture this cookie. We check
-			 * that we don't already have a server side cookie, because we
-			 * can only capture one. Also as an optimisation, we ignore
-			 * cookies shorter than the declared name.
-			 */
-			if (t->fe->capture_name != NULL &&
-			    txn->srv_cookie == NULL &&
-			    (val_end - att_beg >= t->fe->capture_namelen) &&
-			    memcmp(att_beg, t->fe->capture_name, t->fe->capture_namelen) == 0) {
-				int log_len = val_end - att_beg;
-				if ((txn->srv_cookie = pool_alloc2(pool2_capture)) == NULL) {
-					Alert("HTTP logging : out of memory.\n");
-				}
-				else {
-					if (log_len > t->fe->capture_len)
-						log_len = t->fe->capture_len;
-					memcpy(txn->srv_cookie, att_beg, log_len);
-					txn->srv_cookie[log_len] = 0;
-				}
-			}
-
-			/* now check if we need to process it for persistence */
-			if (!(t->flags & SN_IGNORE_PRST) &&
-			    (att_end - att_beg == t->be->cookie_len) && (t->be->cookie_name != NULL) &&
-			    (memcmp(att_beg, t->be->cookie_name, att_end - att_beg) == 0)) {
-				/* assume passive cookie by default */
-				txn->flags &= ~TX_SCK_MASK;
-				txn->flags |= TX_SCK_FOUND;
-			
-				/* If the cookie is in insert mode on a known server, we'll delete
-				 * this occurrence because we'll insert another one later.
-				 * We'll delete it too if the "indirect" option is set and we're in
-				 * a direct access.
-				 */
-				if (t->be->options2 & PR_O2_COOK_PSV) {
-					/* The "preserve" flag was set, we don't want to touch the
-					 * server's cookie.
-					 */
-				}
-				else if (((t->srv) && (t->be->options & PR_O_COOK_INS)) ||
-				    ((t->flags & SN_DIRECT) && (t->be->options & PR_O_COOK_IND))) {
-					/* this cookie must be deleted */
-					if (*prev == ':' && next == hdr_end) {
-						/* whole header */
-						delta = buffer_replace2(res, hdr_beg, hdr_next, NULL, 0);
-						txn->hdr_idx.v[old_idx].next = cur_hdr->next;
-						txn->hdr_idx.used--;
-						cur_hdr->len = 0;
-						cur_idx = old_idx;
-						hdr_next += delta;
-						http_msg_move_end(&txn->rsp, delta);
-						/* note: while both invalid now, <next> and <hdr_end>
-						 * are still equal, so the for() will stop as expected.
-						 */
-					} else {
-						/* just remove the value */
-						int delta = del_hdr_value(res, &prev, next);
-						next      = prev;
-						hdr_end  += delta;
-						hdr_next += delta;
-						cur_hdr->len += delta;
-						http_msg_move_end(&txn->rsp, delta);
-					}
-					txn->flags &= ~TX_SCK_MASK;
-					txn->flags |= TX_SCK_DELETED;
-					/* and go on with next cookie */
-				}
-				else if ((t->srv) && (t->srv->cookie) &&
-					 (t->be->options & PR_O_COOK_RW)) {
-					/* replace bytes val_beg->val_end with the cookie name associated
-					 * with this server since we know it.
-					 */
-					delta = buffer_replace2(res, val_beg, val_end, t->srv->cookie, t->srv->cklen);
-					next     += delta;
-					hdr_end  += delta;
-					hdr_next += delta;
-					cur_hdr->len += delta;
-					http_msg_move_end(&txn->rsp, delta);
-
-					txn->flags &= ~TX_SCK_MASK;
-					txn->flags |= TX_SCK_REPLACED;
-				}
-				else if ((t->srv) && (t->srv->cookie) &&
-					 (t->be->options & PR_O_COOK_PFX)) {
-					/* insert the cookie name associated with this server
-					 * before existing cookie, and insert a delimiter between them..
-					 */
-					delta = buffer_replace2(res, val_beg, val_beg, t->srv->cookie, t->srv->cklen + 1);
-					next     += delta;
-					hdr_end  += delta;
-					hdr_next += delta;
-					cur_hdr->len += delta;
-					http_msg_move_end(&txn->rsp, delta);
-
-					val_beg[t->srv->cklen] = COOKIE_DELIM;
-					txn->flags &= ~TX_SCK_MASK;
-					txn->flags |= TX_SCK_REPLACED;
-				}
-			}
-			/* next, let's see if the cookie is our appcookie, unless persistence must be ignored */
-			else if (!(t->flags & SN_IGNORE_PRST) && (t->be->appsession_name != NULL)) {
-				int cmp_len, value_len;
-				char *value_begin;
-
-				if (t->be->options2 & PR_O2_AS_PFX) {
-					cmp_len = MIN(val_end - att_beg, t->be->appsession_name_len);
-					value_begin = att_beg + t->be->appsession_name_len;
-					value_len = MIN(t->be->appsession_len, val_end - att_beg - t->be->appsession_name_len);
-				} else {
-					cmp_len = att_end - att_beg;
-					value_begin = val_beg;
-					value_len = MIN(t->be->appsession_len, val_end - val_beg);
-				}
-
-				if ((cmp_len == t->be->appsession_name_len) &&
-				    (memcmp(att_beg, t->be->appsession_name, t->be->appsession_name_len) == 0)) {
-					/* free a possibly previously allocated memory */
-					pool_free2(apools.sessid, txn->sessid);
-
-					/* Store the sessid in the session for future use */
-					if ((txn->sessid = pool_alloc2(apools.sessid)) == NULL) {
-						Alert("Not enough Memory process_srv():asession->sessid:malloc().\n");
-						send_log(t->be, LOG_ALERT, "Not enough Memory process_srv():asession->sessid:malloc().\n");
-						return;
-					}
-					memcpy(txn->sessid, value_begin, value_len);
-					txn->sessid[value_len] = 0;
-				}
-			}
-			/* that's done for this cookie, check the next one on the same
-			 * line when next != hdr_end (only if is_cookie2).
-			 */
-		}
-		/* check next header */
-		old_idx = cur_idx;
-	}
-
-	if (txn->sessid != NULL) {
-		appsess *asession = NULL;
-		/* only do insert, if lookup fails */
-		asession = appsession_hash_lookup(&(t->be->htbl_proxy), txn->sessid);
-		if (asession == NULL) {
-			size_t server_id_len;
-			if ((asession = pool_alloc2(pool2_appsess)) == NULL) {
-				Alert("Not enough Memory process_srv():asession:calloc().\n");
-				send_log(t->be, LOG_ALERT, "Not enough Memory process_srv():asession:calloc().\n");
-				return;
-			}
-			asession->serverid = NULL; /* to avoid a double free in case of allocation error */
-
-			if ((asession->sessid = pool_alloc2(apools.sessid)) == NULL) {
-				Alert("Not enough Memory process_srv():asession->sessid:malloc().\n");
-				send_log(t->be, LOG_ALERT, "Not enough Memory process_srv():asession->sessid:malloc().\n");
-				t->be->htbl_proxy.destroy(asession);
-				return;
-			}
-			memcpy(asession->sessid, txn->sessid, t->be->appsession_len);
-			asession->sessid[t->be->appsession_len] = 0;
-
-			server_id_len = strlen(t->srv->id) + 1;
-			if ((asession->serverid = pool_alloc2(apools.serverid)) == NULL) {
-				Alert("Not enough Memory process_srv():asession->serverid:malloc().\n");
-				send_log(t->be, LOG_ALERT, "Not enough Memory process_srv():asession->sessid:malloc().\n");
-				t->be->htbl_proxy.destroy(asession);
-				return;
-			}
-			asession->serverid[0] = '\0';
-			memcpy(asession->serverid, t->srv->id, server_id_len);
-
-			asession->request_count = 0;
-			appsession_hash_insert(&(t->be->htbl_proxy), asession);
-		}
-
-		asession->expire = tick_add_ifset(now_ms, t->be->timeout.appsession);
-		asession->request_count++;
-	}
-}
-
-
-/*
- * Check if response is cacheable or not. Updates t->flags.
- */
-void check_response_for_cacheability(struct session *t, struct buffer *rtr)
-{
-	struct http_txn *txn = &t->txn;
-	char *p1, *p2;
-
-	char *cur_ptr, *cur_end, *cur_next;
-	int cur_idx;
-
-	if (!(txn->flags & TX_CACHEABLE))
-		return;
-
-	/* Iterate through the headers.
-	 * we start with the start line.
-	 */
-	cur_idx = 0;
-	cur_next = txn->rsp.sol + hdr_idx_first_pos(&txn->hdr_idx);
-
-	while ((cur_idx = txn->hdr_idx.v[cur_idx].next)) {
-		struct hdr_idx_elem *cur_hdr;
-		int val;
-
-		cur_hdr  = &txn->hdr_idx.v[cur_idx];
-		cur_ptr  = cur_next;
-		cur_end  = cur_ptr + cur_hdr->len;
-		cur_next = cur_end + cur_hdr->cr + 1;
-
-		/* We have one full header between cur_ptr and cur_end, and the
-		 * next header starts at cur_next. We're only interested in
-		 * "Cookie:" headers.
-		 */
-
-		val = http_header_match2(cur_ptr, cur_end, "Pragma", 6);
-		if (val) {
-			if ((cur_end - (cur_ptr + val) >= 8) &&
-			    strncasecmp(cur_ptr + val, "no-cache", 8) == 0) {
-				txn->flags &= ~TX_CACHEABLE & ~TX_CACHE_COOK;
-				return;
-			}
-		}
-
-		val = http_header_match2(cur_ptr, cur_end, "Cache-control", 13);
-		if (!val)
-			continue;
-
-		/* OK, right now we know we have a cache-control header at cur_ptr */
-
-		p1 = cur_ptr + val; /* first non-space char after 'cache-control:' */
-
-		if (p1 >= cur_end)	/* no more info */
-			continue;
-
-		/* p1 is at the beginning of the value */
-		p2 = p1;
-
-		while (p2 < cur_end && *p2 != '=' && *p2 != ',' && !isspace((unsigned char)*p2))
-			p2++;
-
-		/* we have a complete value between p1 and p2 */
-		if (p2 < cur_end && *p2 == '=') {
-			/* we have something of the form no-cache="set-cookie" */
-			if ((cur_end - p1 >= 21) &&
-			    strncasecmp(p1, "no-cache=\"set-cookie", 20) == 0
-			    && (p1[20] == '"' || p1[20] == ','))
-				txn->flags &= ~TX_CACHE_COOK;
-			continue;
-		}
-
-		/* OK, so we know that either p2 points to the end of string or to a comma */
-		if (((p2 - p1 ==  7) && strncasecmp(p1, "private", 7) == 0) ||
-		    ((p2 - p1 ==  8) && strncasecmp(p1, "no-store", 8) == 0) ||
-		    ((p2 - p1 ==  9) && strncasecmp(p1, "max-age=0", 9) == 0) ||
-		    ((p2 - p1 == 10) && strncasecmp(p1, "s-maxage=0", 10) == 0)) {
-			txn->flags &= ~TX_CACHEABLE & ~TX_CACHE_COOK;
-			return;
-		}
-
-		if ((p2 - p1 ==  6) && strncasecmp(p1, "public", 6) == 0) {
-			txn->flags |= TX_CACHEABLE | TX_CACHE_COOK;
-			continue;
-		}
-	}
-}
-
-
-/*
- * Try to retrieve a known appsession in the URI, then the associated server.
- * If the server is found, it's assigned to the session.
- */
-void get_srv_from_appsession(struct session *t, const char *begin, int len)
-{
-	char *end_params, *first_param, *cur_param, *next_param;
-	char separator;
-	int value_len;
-
-	int mode = t->be->options2 & PR_O2_AS_M_ANY;
-
-	if (t->be->appsession_name == NULL ||
-	    (t->txn.meth != HTTP_METH_GET && t->txn.meth != HTTP_METH_POST && t->txn.meth != HTTP_METH_HEAD)) {
-		return;
-	}
-
-	first_param = NULL;
-	switch (mode) {
-	case PR_O2_AS_M_PP:
-		first_param = memchr(begin, ';', len);
-		break;
-	case PR_O2_AS_M_QS:
-		first_param = memchr(begin, '?', len);
-		break;
-	}
-
-	if (first_param == NULL) {
-		return;
-	}
-
-	switch (mode) {
-	case PR_O2_AS_M_PP:
-		if ((end_params = memchr(first_param, '?', len - (begin - first_param))) == NULL) {
-			end_params = (char *) begin + len;
-		}
-		separator = ';';
-		break;
-	case PR_O2_AS_M_QS:
-		end_params = (char *) begin + len;
-		separator = '&';
-		break;
-	default:
-		/* unknown mode, shouldn't happen */
-		return;
-	}
-	
-	cur_param = next_param = end_params;
-	while (cur_param > first_param) {
-		cur_param--;
-		if ((cur_param[0] == separator) || (cur_param == first_param)) {
-			/* let's see if this is the appsession parameter */
-			if ((cur_param + t->be->appsession_name_len + 1 < next_param) &&
-				((t->be->options2 & PR_O2_AS_PFX) || cur_param[t->be->appsession_name_len + 1] == '=') &&
-				(strncasecmp(cur_param + 1, t->be->appsession_name, t->be->appsession_name_len) == 0)) {
-				/* Cool... it's the right one */
-				cur_param += t->be->appsession_name_len + (t->be->options2 & PR_O2_AS_PFX ? 1 : 2);
-				value_len = MIN(t->be->appsession_len, next_param - cur_param);
-				if (value_len > 0) {
-					manage_client_side_appsession(t, cur_param, value_len);
-				}
-				break;
-			}
-			next_param = cur_param;
-		}
-	}
-#if defined(DEBUG_HASH)
-	Alert("get_srv_from_appsession\n");
-	appsession_hash_dump(&(t->be->htbl_proxy));
-#endif
-}
-
-/*
- * In a GET, HEAD or POST request, check if the requested URI matches the stats uri
- * for the current backend.
- *
- * It is assumed that the request is either a HEAD, GET, or POST and that the
- * t->be->uri_auth field is valid.
- *
- * Returns 1 if stats should be provided, otherwise 0.
- */
-int stats_check_uri(struct session *t, struct proxy *backend)
-{
-	struct http_txn *txn = &t->txn;
-	struct uri_auth *uri_auth = backend->uri_auth;
-	char *h;
-
-	if (!uri_auth)
-		return 0;
-
-	if (txn->meth != HTTP_METH_GET && txn->meth != HTTP_METH_HEAD && txn->meth != HTTP_METH_POST)
-		return 0;
-
-	memset(&t->data_ctx.stats, 0, sizeof(t->data_ctx.stats));
-
-	/* check URI size */
-	if (uri_auth->uri_len > txn->req.sl.rq.u_l)
-		return 0;
-
-	h = txn->req.sol + txn->req.sl.rq.u;
-
-	/* the URI is in h */
-	if (memcmp(h, uri_auth->uri_prefix, uri_auth->uri_len) != 0)
-		return 0;
-
-	h += uri_auth->uri_len;
-	while (h <= txn->req.sol + txn->req.sl.rq.u + txn->req.sl.rq.u_l - 3) {
-		if (memcmp(h, ";up", 3) == 0) {
-			t->data_ctx.stats.flags |= STAT_HIDE_DOWN;
-			break;
-		}
-		h++;
-	}
-
-	if (uri_auth->refresh) {
-		h = txn->req.sol + txn->req.sl.rq.u + uri_auth->uri_len;
-		while (h <= txn->req.sol + txn->req.sl.rq.u + txn->req.sl.rq.u_l - 10) {
-			if (memcmp(h, ";norefresh", 10) == 0) {
-				t->data_ctx.stats.flags |= STAT_NO_REFRESH;
-				break;
-			}
-			h++;
-		}
-	}
-
-	h = txn->req.sol + txn->req.sl.rq.u + uri_auth->uri_len;
-	while (h <= txn->req.sol + txn->req.sl.rq.u + txn->req.sl.rq.u_l - 4) {
-		if (memcmp(h, ";csv", 4) == 0) {
-			t->data_ctx.stats.flags |= STAT_FMT_CSV;
-			break;
-		}
-		h++;
-	}
-
-	h = txn->req.sol + txn->req.sl.rq.u + uri_auth->uri_len;
-	while (h <= txn->req.sol + txn->req.sl.rq.u + txn->req.sl.rq.u_l - 8) {
-		if (memcmp(h, ";st=", 4) == 0) {
-			h += 4;
-
-			if (memcmp(h, STAT_STATUS_DONE, 4) == 0)
-				t->data_ctx.stats.st_code = STAT_STATUS_DONE;
-			else if (memcmp(h, STAT_STATUS_NONE, 4) == 0)
-				t->data_ctx.stats.st_code = STAT_STATUS_NONE;
-			else if (memcmp(h, STAT_STATUS_PART, 4) == 0)
-				t->data_ctx.stats.st_code = STAT_STATUS_PART;
-			else if (memcmp(h, STAT_STATUS_ERRP, 4) == 0)
-				t->data_ctx.stats.st_code = STAT_STATUS_ERRP;
-			else if (memcmp(h, STAT_STATUS_EXCD, 4) == 0)
-				t->data_ctx.stats.st_code = STAT_STATUS_EXCD;
-			else if (memcmp(h, STAT_STATUS_DENY, 4) == 0)
-				t->data_ctx.stats.st_code = STAT_STATUS_DENY;
-			else
-				t->data_ctx.stats.st_code = STAT_STATUS_UNKN;
-			break;
-		}
-		h++;
-	}
-
-	t->data_ctx.stats.flags |= STAT_SHOW_STAT | STAT_SHOW_INFO;
-
-	return 1;
-}
-
-/*
- * Capture a bad request or response and archive it in the proxy's structure.
- * WARNING: it's unlikely that we've reached HTTP_MSG_BODY here so we must not
- * assume that msg->sol = buf->data + msg->som.
- */
-void http_capture_bad_message(struct error_snapshot *es, struct session *s,
-                              struct buffer *buf, struct http_msg *msg,
-			      int state, struct proxy *other_end)
-{
-	if (buf->r <= (buf->data + msg->som)) { /* message wraps */
-		int len1 = buf->size - msg->som;
-		es->len = buf->r - (buf->data + msg->som) + buf->size;
-		memcpy(es->buf, buf->data + msg->som, MIN(len1, sizeof(es->buf)));
-		if (es->len > len1 && len1 < sizeof(es->buf))
-			memcpy(es->buf + len1, buf->data, MIN(es->len, sizeof(es->buf)) - len1);
-	}
-	else {
-		es->len = buf->r - (buf->data + msg->som);
-		memcpy(es->buf, buf->data + msg->som, MIN(es->len, sizeof(es->buf)));
-	}
-
-	if (msg->err_pos >= 0)
-		es->pos  = msg->err_pos - msg->som;
-	else if (buf->lr >= (buf->data + msg->som))
-		es->pos  = buf->lr - (buf->data + msg->som);
-	else
-		es->pos  = buf->lr - (buf->data + msg->som) + buf->size;
-
-	es->when = date; // user-visible date
-	es->sid  = s->uniq_id;
-	es->srv  = s->srv;
-	es->oe   = other_end;
-	es->src  = s->cli_addr;
-	es->state = state;
-	es->flags = buf->flags;
-	es->ev_id = error_snapshot_id++;
-}
-
-/* return the IP address pointed to by occurrence <occ> of header <hname> in
- * HTTP message <msg> indexed in <idx>. If <occ> is strictly positive, the
- * occurrence number corresponding to this value is returned. If <occ> is
- * strictly negative, the occurrence number before the end corresponding to
- * this value is returned. If <occ> is null, any value is returned, so it is
- * not recommended to use it that way. Negative occurrences are limited to
- * a small value because it is required to keep them in memory while scanning.
- * IP address 0.0.0.0 is returned if no match is found.
- */
-unsigned int get_ip_from_hdr2(struct http_msg *msg, const char *hname, int hlen, struct hdr_idx *idx, int occ)
-{
-	struct hdr_ctx ctx;
-	unsigned int hdr_hist[MAX_HDR_HISTORY];
-	unsigned int hist_ptr;
-	int found = 0;
-
-	ctx.idx = 0;
-	if (occ >= 0) {
-		while (http_find_header2(hname, hlen, msg->sol, idx, &ctx)) {
-			occ--;
-			if (occ <= 0) {
-				found = 1;
-				break;
-			}
-		}
-		if (!found)
-			return 0;
-		return inetaddr_host_lim(ctx.line+ctx.val, ctx.line+ctx.val+ctx.vlen);
-	}
-
-	/* negative occurrence, we scan all the list then walk back */
-	if (-occ > MAX_HDR_HISTORY)
-		return 0;
-
-	hist_ptr = 0;
-	hdr_hist[hist_ptr] = 0;
-	while (http_find_header2(hname, hlen, msg->sol, idx, &ctx)) {
-		hdr_hist[hist_ptr++] = inetaddr_host_lim(ctx.line+ctx.val, ctx.line+ctx.val+ctx.vlen);
-		if (hist_ptr >= MAX_HDR_HISTORY)
-			hist_ptr = 0;
-		found++;
-	}
-	if (-occ > found)
-		return 0;
-	/* OK now we have the last occurrence in [hist_ptr-1], and we need to
-	 * find occurrence -occ, so we have to check [hist_ptr+occ].
-	 */
-	hist_ptr += occ;
-	if (hist_ptr >= MAX_HDR_HISTORY)
-		hist_ptr -= MAX_HDR_HISTORY;
-	return hdr_hist[hist_ptr];
-}
-
-/*
- * Print a debug line with a header
- */
-void debug_hdr(const char *dir, struct session *t, const char *start, const char *end)
-{
-	int len, max;
-	len = sprintf(trash, "%08x:%s.%s[%04x:%04x]: ", t->uniq_id, t->be->id,
-		      dir, (unsigned  short)t->req->prod->fd, (unsigned short)t->req->cons->fd);
-	max = end - start;
-	UBOUND(max, trashlen - len - 1);
-	len += strlcpy2(trash + len, start, max + 1);
-	trash[len++] = '\n';
-	if (write(1, trash, len) < 0) /* shut gcc warning */;
-}
-
-/*
- * Initialize a new HTTP transaction for session <s>. It is assumed that all
- * the required fields are properly allocated and that we only need to (re)init
- * them. This should be used before processing any new request.
- */
-void http_init_txn(struct session *s)
-{
-	struct http_txn *txn = &s->txn;
-	struct proxy *fe = s->fe;
-
-	txn->flags = 0;
-	txn->status = -1;
-
-	txn->cookie_first_date = 0;
-	txn->cookie_last_date = 0;
-
-	txn->req.sol = txn->req.eol = NULL;
-	txn->req.som = txn->req.eoh = 0; /* relative to the buffer */
-	txn->rsp.sol = txn->rsp.eol = NULL;
-	txn->rsp.som = txn->rsp.eoh = 0; /* relative to the buffer */
-	txn->req.chunk_len = 0LL;
-	txn->req.body_len = 0LL;
-	txn->rsp.chunk_len = 0LL;
-	txn->rsp.body_len = 0LL;
-	txn->req.msg_state = HTTP_MSG_RQBEFORE; /* at the very beginning of the request */
-	txn->rsp.msg_state = HTTP_MSG_RPBEFORE; /* at the very beginning of the response */
-
-	txn->auth.method = HTTP_AUTH_UNKNOWN;
-
-	txn->req.err_pos = txn->rsp.err_pos = -2; /* block buggy requests/responses */
-	if (fe->options2 & PR_O2_REQBUG_OK)
-		txn->req.err_pos = -1;            /* let buggy requests pass */
-
-	if (txn->req.cap)
-		memset(txn->req.cap, 0, fe->nb_req_cap * sizeof(void *));
-
-	if (txn->rsp.cap)
-		memset(txn->rsp.cap, 0, fe->nb_rsp_cap * sizeof(void *));
-
-	if (txn->hdr_idx.v)
-		hdr_idx_init(&txn->hdr_idx);
-}
-
-/* to be used at the end of a transaction */
-void http_end_txn(struct session *s)
-{
-	struct http_txn *txn = &s->txn;
-
-	/* these ones will have been dynamically allocated */
-	pool_free2(pool2_requri, txn->uri);
-	pool_free2(pool2_capture, txn->cli_cookie);
-	pool_free2(pool2_capture, txn->srv_cookie);
-	pool_free2(apools.sessid, txn->sessid);
-
-	txn->sessid = NULL;
-	txn->uri = NULL;
-	txn->srv_cookie = NULL;
-	txn->cli_cookie = NULL;
-
-	if (txn->req.cap) {
-		struct cap_hdr *h;
-		for (h = s->fe->req_cap; h; h = h->next)
-			pool_free2(h->pool, txn->req.cap[h->index]);
-		memset(txn->req.cap, 0, s->fe->nb_req_cap * sizeof(void *));
-	}
-
-	if (txn->rsp.cap) {
-		struct cap_hdr *h;
-		for (h = s->fe->rsp_cap; h; h = h->next)
-			pool_free2(h->pool, txn->rsp.cap[h->index]);
-		memset(txn->rsp.cap, 0, s->fe->nb_rsp_cap * sizeof(void *));
-	}
-
-}
-
-/* to be used at the end of a transaction to prepare a new one */
-void http_reset_txn(struct session *s)
-{
-	http_end_txn(s);
-	http_init_txn(s);
-
-	s->be = s->fe;
-	s->logs.logwait = s->fe->to_log;
-	s->srv = s->prev_srv = s->srv_conn = NULL;
-	/* re-init store persistence */
-	s->store_count = 0;
-
-	s->pend_pos = NULL;
-	s->conn_retries = s->be->conn_retries;
-
-	s->req->flags |= BF_READ_DONTWAIT; /* one read is usually enough */
-
-	/* We must trim any excess data from the response buffer, because we
-	 * may have blocked an invalid response from a server that we don't
-	 * want to accidentely forward once we disable the analysers, nor do
-	 * we want those data to come along with next response. A typical
-	 * example of such data would be from a buggy server responding to
-	 * a HEAD with some data, or sending more than the advertised
-	 * content-length.
-	 */
-	if (unlikely(s->rep->l > s->rep->send_max)) {
-		s->rep->l = s->rep->send_max;
-		s->rep->r = s->rep->w + s->rep->l;
-		if (s->rep->r >= s->rep->data + s->rep->size)
-			s->rep->r -= s->rep->size;
-	}
-
-	s->req->rto = s->fe->timeout.client;
-	s->req->wto = s->be->timeout.server;
-	s->req->cto = s->be->timeout.connect;
-
-	s->rep->rto = s->be->timeout.server;
-	s->rep->wto = s->fe->timeout.client;
-	s->rep->cto = TICK_ETERNITY;
-
-	s->req->rex = TICK_ETERNITY;
-	s->req->wex = TICK_ETERNITY;
-	s->req->analyse_exp = TICK_ETERNITY;
-	s->rep->rex = TICK_ETERNITY;
-	s->rep->wex = TICK_ETERNITY;
-	s->rep->analyse_exp = TICK_ETERNITY;
-}
-
-/************************************************************************/
-/*        The code below is dedicated to ACL parsing and matching       */
-/************************************************************************/
-
-
-
-
-/* 1. Check on METHOD
- * We use the pre-parsed method if it is known, and store its number as an
- * integer. If it is unknown, we use the pointer and the length.
- */
-static int acl_parse_meth(const char **text, struct acl_pattern *pattern, int *opaque)
-{
-	int len, meth;
-
-	len  = strlen(*text);
-	meth = find_http_meth(*text, len);
-
-	pattern->val.i = meth;
-	if (meth == HTTP_METH_OTHER) {
-		pattern->ptr.str = strdup(*text);
-		if (!pattern->ptr.str)
-			return 0;
-		pattern->len = len;
-	}
-	return 1;
-}
-
-static int
-acl_fetch_meth(struct proxy *px, struct session *l4, void *l7, int dir,
-               struct acl_expr *expr, struct acl_test *test)
-{
-	int meth;
-	struct http_txn *txn = l7;
-
-	if (!txn)
-		return 0;
-
-	if (txn->req.msg_state < HTTP_MSG_BODY)
-		return 0;
-
-	meth = txn->meth;
-	test->i = meth;
-	if (meth == HTTP_METH_OTHER) {
-		if (txn->rsp.msg_state != HTTP_MSG_RPBEFORE)
-			/* ensure the indexes are not affected */
-			return 0;
-		test->len = txn->req.sl.rq.m_l;
-		test->ptr = txn->req.sol;
-	}
-	test->flags = ACL_TEST_F_READ_ONLY | ACL_TEST_F_VOL_1ST;
-	return 1;
-}
-
-static int acl_match_meth(struct acl_test *test, struct acl_pattern *pattern)
-{
-	int icase;
-
-	if (test->i != pattern->val.i)
-		return ACL_PAT_FAIL;
-
-	if (test->i != HTTP_METH_OTHER)
-		return ACL_PAT_PASS;
-
-	/* Other method, we must compare the strings */
-	if (pattern->len != test->len)
-		return ACL_PAT_FAIL;
-
-	icase = pattern->flags & ACL_PAT_F_IGNORE_CASE;
-	if ((icase && strncasecmp(pattern->ptr.str, test->ptr, test->len) != 0) ||
-	    (!icase && strncmp(pattern->ptr.str, test->ptr, test->len) != 0))
-		return ACL_PAT_FAIL;
-	return ACL_PAT_PASS;
-}
-
-/* 2. Check on Request/Status Version
- * We simply compare strings here.
- */
-static int acl_parse_ver(const char **text, struct acl_pattern *pattern, int *opaque)
-{
-	pattern->ptr.str = strdup(*text);
-	if (!pattern->ptr.str)
-		return 0;
-	pattern->len = strlen(*text);
-	return 1;
-}
-
-static int
-acl_fetch_rqver(struct proxy *px, struct session *l4, void *l7, int dir,
-                struct acl_expr *expr, struct acl_test *test)
-{
-	struct http_txn *txn = l7;
-	char *ptr;
-	int len;
-
-	if (!txn)
-		return 0;
-
-	if (txn->req.msg_state < HTTP_MSG_BODY)
-		return 0;
-
-	len = txn->req.sl.rq.v_l;
-	ptr = txn->req.sol + txn->req.sl.rq.v;
-
-	while ((len-- > 0) && (*ptr++ != '/'));
-	if (len <= 0)
-		return 0;
-
-	test->ptr = ptr;
-	test->len = len;
-
-	test->flags = ACL_TEST_F_READ_ONLY | ACL_TEST_F_VOL_1ST;
-	return 1;
-}
-
-static int
-acl_fetch_stver(struct proxy *px, struct session *l4, void *l7, int dir,
-                struct acl_expr *expr, struct acl_test *test)
-{
-	struct http_txn *txn = l7;
-	char *ptr;
-	int len;
-
-	if (!txn)
-		return 0;
-
-	if (txn->rsp.msg_state < HTTP_MSG_BODY)
-		return 0;
-
-	len = txn->rsp.sl.st.v_l;
-	ptr = txn->rsp.sol;
-
-	while ((len-- > 0) && (*ptr++ != '/'));
-	if (len <= 0)
-		return 0;
-
-	test->ptr = ptr;
-	test->len = len;
-
-	test->flags = ACL_TEST_F_READ_ONLY | ACL_TEST_F_VOL_1ST;
-	return 1;
-}
-
-/* 3. Check on Status Code. We manipulate integers here. */
-static int
-acl_fetch_stcode(struct proxy *px, struct session *l4, void *l7, int dir,
-                 struct acl_expr *expr, struct acl_test *test)
-{
-	struct http_txn *txn = l7;
-	char *ptr;
-	int len;
-
-	if (!txn)
-		return 0;
-
-	if (txn->rsp.msg_state < HTTP_MSG_BODY)
-		return 0;
-
-	len = txn->rsp.sl.st.c_l;
-	ptr = txn->rsp.sol + txn->rsp.sl.st.c;
-
-	test->i = __strl2ui(ptr, len);
-	test->flags = ACL_TEST_F_VOL_1ST;
-	return 1;
-}
-
-/* 4. Check on URL/URI. A pointer to the URI is stored. */
-static int
-acl_fetch_url(struct proxy *px, struct session *l4, void *l7, int dir,
-              struct acl_expr *expr, struct acl_test *test)
-{
-	struct http_txn *txn = l7;
-
-	if (!txn)
-		return 0;
-
-	if (txn->req.msg_state < HTTP_MSG_BODY)
-		return 0;
-
-	if (txn->rsp.msg_state != HTTP_MSG_RPBEFORE)
-		/* ensure the indexes are not affected */
-		return 0;
-
-	test->len = txn->req.sl.rq.u_l;
-	test->ptr = txn->req.sol + txn->req.sl.rq.u;
-
-	/* we do not need to set READ_ONLY because the data is in a buffer */
-	test->flags = ACL_TEST_F_VOL_1ST;
-	return 1;
-}
-
-static int
-acl_fetch_url_ip(struct proxy *px, struct session *l4, void *l7, int dir,
-		 struct acl_expr *expr, struct acl_test *test)
-{
-	struct http_txn *txn = l7;
-
-	if (!txn)
-		return 0;
-
-	if (txn->req.msg_state < HTTP_MSG_BODY)
-		return 0;
-
-	if (txn->rsp.msg_state != HTTP_MSG_RPBEFORE)
-		/* ensure the indexes are not affected */
-		return 0;
-
-	/* Parse HTTP request */
-	url2sa(txn->req.sol + txn->req.sl.rq.u, txn->req.sl.rq.u_l, &l4->srv_addr);
-	test->ptr = (void *)&((struct sockaddr_in *)&l4->srv_addr)->sin_addr;
-	test->i = AF_INET;
-
-	/*
-	 * If we are parsing url in frontend space, we prepare backend stage
-	 * to not parse again the same url ! optimization lazyness...
-	 */
-	if (px->options & PR_O_HTTP_PROXY)
-		l4->flags |= SN_ADDR_SET;
-
-	test->flags = ACL_TEST_F_READ_ONLY;
-	return 1;
-}
-
-static int
-acl_fetch_url_port(struct proxy *px, struct session *l4, void *l7, int dir,
-		   struct acl_expr *expr, struct acl_test *test)
-{
-	struct http_txn *txn = l7;
-
-	if (!txn)
-		return 0;
-
-	if (txn->req.msg_state < HTTP_MSG_BODY)
-		return 0;
-
-	if (txn->rsp.msg_state != HTTP_MSG_RPBEFORE)
-		/* ensure the indexes are not affected */
-		return 0;
-
-	/* Same optimization as url_ip */
-	url2sa(txn->req.sol + txn->req.sl.rq.u, txn->req.sl.rq.u_l, &l4->srv_addr);
-	test->i = ntohs(((struct sockaddr_in *)&l4->srv_addr)->sin_port);
-
-	if (px->options & PR_O_HTTP_PROXY)
-		l4->flags |= SN_ADDR_SET;
-
-	test->flags = ACL_TEST_F_READ_ONLY;
-	return 1;
-}
-
-/* 5. Check on HTTP header. A pointer to the beginning of the value is returned.
- * This generic function is used by both acl_fetch_chdr() and acl_fetch_shdr().
- */
-static int
-acl_fetch_hdr(struct proxy *px, struct session *l4, void *l7, char *sol,
-              struct acl_expr *expr, struct acl_test *test)
-{
-	struct http_txn *txn = l7;
-	struct hdr_idx *idx = &txn->hdr_idx;
-	struct hdr_ctx *ctx = (struct hdr_ctx *)test->ctx.a;
-
-	if (!txn)
-		return 0;
-
-	if (!(test->flags & ACL_TEST_F_FETCH_MORE))
-		/* search for header from the beginning */
-		ctx->idx = 0;
-
-	if (http_find_header2(expr->arg.str, expr->arg_len, sol, idx, ctx)) {
-		test->flags |= ACL_TEST_F_FETCH_MORE;
-		test->flags |= ACL_TEST_F_VOL_HDR;
-		test->len = ctx->vlen;
-		test->ptr = (char *)ctx->line + ctx->val;
-		return 1;
-	}
-
-	test->flags &= ~ACL_TEST_F_FETCH_MORE;
-	test->flags |= ACL_TEST_F_VOL_HDR;
-	return 0;
-}
-
-static int
-acl_fetch_chdr(struct proxy *px, struct session *l4, void *l7, int dir,
-	       struct acl_expr *expr, struct acl_test *test)
-{
-	struct http_txn *txn = l7;
-
-	if (!txn)
-		return 0;
-
-	if (txn->req.msg_state < HTTP_MSG_BODY)
-		return 0;
-
-	if (txn->rsp.msg_state != HTTP_MSG_RPBEFORE)
-		/* ensure the indexes are not affected */
-		return 0;
-
-	return acl_fetch_hdr(px, l4, txn, txn->req.sol, expr, test);
-}
-
-static int
-acl_fetch_shdr(struct proxy *px, struct session *l4, void *l7, int dir,
-	       struct acl_expr *expr, struct acl_test *test)
-{
-	struct http_txn *txn = l7;
-
-	if (!txn)
-		return 0;
-
-	if (txn->rsp.msg_state < HTTP_MSG_BODY)
-		return 0;
-
-	return acl_fetch_hdr(px, l4, txn, txn->rsp.sol, expr, test);
-}
-
-/* 6. Check on HTTP header count. The number of occurrences is returned.
- * This generic function is used by both acl_fetch_chdr* and acl_fetch_shdr*.
- */
-static int
-acl_fetch_hdr_cnt(struct proxy *px, struct session *l4, void *l7, char *sol,
-                  struct acl_expr *expr, struct acl_test *test)
-{
-	struct http_txn *txn = l7;
-	struct hdr_idx *idx = &txn->hdr_idx;
-	struct hdr_ctx ctx;
-	int cnt;
-
-	if (!txn)
-		return 0;
-
-	ctx.idx = 0;
-	cnt = 0;
-	while (http_find_header2(expr->arg.str, expr->arg_len, sol, idx, &ctx))
-		cnt++;
-
-	test->i = cnt;
-	test->flags = ACL_TEST_F_VOL_HDR;
-	return 1;
-}
-
-static int
-acl_fetch_chdr_cnt(struct proxy *px, struct session *l4, void *l7, int dir,
-		   struct acl_expr *expr, struct acl_test *test)
-{
-	struct http_txn *txn = l7;
-
-	if (!txn)
-		return 0;
-
-	if (txn->req.msg_state < HTTP_MSG_BODY)
-		return 0;
-
-	if (txn->rsp.msg_state != HTTP_MSG_RPBEFORE)
-		/* ensure the indexes are not affected */
-		return 0;
-
-	return acl_fetch_hdr_cnt(px, l4, txn, txn->req.sol, expr, test);
-}
-
-static int
-acl_fetch_shdr_cnt(struct proxy *px, struct session *l4, void *l7, int dir,
-		   struct acl_expr *expr, struct acl_test *test)
-{
-	struct http_txn *txn = l7;
-
-	if (!txn)
-		return 0;
-
-	if (txn->rsp.msg_state < HTTP_MSG_BODY)
-		return 0;
-
-	return acl_fetch_hdr_cnt(px, l4, txn, txn->rsp.sol, expr, test);
-}
-
-/* 7. Check on HTTP header's integer value. The integer value is returned.
- * FIXME: the type is 'int', it may not be appropriate for everything.
- * This generic function is used by both acl_fetch_chdr* and acl_fetch_shdr*.
- */
-static int
-acl_fetch_hdr_val(struct proxy *px, struct session *l4, void *l7, char *sol,
-                  struct acl_expr *expr, struct acl_test *test)
-{
-	struct http_txn *txn = l7;
-	struct hdr_idx *idx = &txn->hdr_idx;
-	struct hdr_ctx *ctx = (struct hdr_ctx *)test->ctx.a;
-
-	if (!txn)
-		return 0;
-
-	if (!(test->flags & ACL_TEST_F_FETCH_MORE))
-		/* search for header from the beginning */
-		ctx->idx = 0;
-
-	if (http_find_header2(expr->arg.str, expr->arg_len, sol, idx, ctx)) {
-		test->flags |= ACL_TEST_F_FETCH_MORE;
-		test->flags |= ACL_TEST_F_VOL_HDR;
-		test->i = strl2ic((char *)ctx->line + ctx->val, ctx->vlen);
-		return 1;
-	}
-
-	test->flags &= ~ACL_TEST_F_FETCH_MORE;
-	test->flags |= ACL_TEST_F_VOL_HDR;
-	return 0;
-}
-
-static int
-acl_fetch_chdr_val(struct proxy *px, struct session *l4, void *l7, int dir,
-		   struct acl_expr *expr, struct acl_test *test)
-{
-	struct http_txn *txn = l7;
-
-	if (!txn)
-		return 0;
-
-	if (txn->req.msg_state < HTTP_MSG_BODY)
-		return 0;
-
-	if (txn->rsp.msg_state != HTTP_MSG_RPBEFORE)
-		/* ensure the indexes are not affected */
-		return 0;
-
-	return acl_fetch_hdr_val(px, l4, txn, txn->req.sol, expr, test);
-}
-
-static int
-acl_fetch_shdr_val(struct proxy *px, struct session *l4, void *l7, int dir,
-		   struct acl_expr *expr, struct acl_test *test)
-{
-	struct http_txn *txn = l7;
-
-	if (!txn)
-		return 0;
-
-	if (txn->rsp.msg_state < HTTP_MSG_BODY)
-		return 0;
-
-	return acl_fetch_hdr_val(px, l4, txn, txn->rsp.sol, expr, test);
-}
-
-/* 7. Check on HTTP header's IPv4 address value. The IPv4 address is returned.
- * This generic function is used by both acl_fetch_chdr* and acl_fetch_shdr*.
- */
-static int
-acl_fetch_hdr_ip(struct proxy *px, struct session *l4, void *l7, char *sol,
-                  struct acl_expr *expr, struct acl_test *test)
-{
-	struct http_txn *txn = l7;
-	struct hdr_idx *idx = &txn->hdr_idx;
-	struct hdr_ctx *ctx = (struct hdr_ctx *)test->ctx.a;
-
-	if (!txn)
-		return 0;
-
-	if (!(test->flags & ACL_TEST_F_FETCH_MORE))
-		/* search for header from the beginning */
-		ctx->idx = 0;
-
-	if (http_find_header2(expr->arg.str, expr->arg_len, sol, idx, ctx)) {
-		test->flags |= ACL_TEST_F_FETCH_MORE;
-		test->flags |= ACL_TEST_F_VOL_HDR;
-		/* Same optimization as url_ip */
-		memset(&l4->srv_addr.sin_addr, 0, sizeof(l4->srv_addr.sin_addr));
-		url2ip((char *)ctx->line + ctx->val, &l4->srv_addr.sin_addr);
-		test->ptr = (void *)&l4->srv_addr.sin_addr;
-		test->i = AF_INET;
-		return 1;
-	}
-
-	test->flags &= ~ACL_TEST_F_FETCH_MORE;
-	test->flags |= ACL_TEST_F_VOL_HDR;
-	return 0;
-}
-
-static int
-acl_fetch_chdr_ip(struct proxy *px, struct session *l4, void *l7, int dir,
-		   struct acl_expr *expr, struct acl_test *test)
-{
-	struct http_txn *txn = l7;
-
-	if (!txn)
-		return 0;
-
-	if (txn->req.msg_state < HTTP_MSG_BODY)
-		return 0;
-
-	if (txn->rsp.msg_state != HTTP_MSG_RPBEFORE)
-		/* ensure the indexes are not affected */
-		return 0;
-
-	return acl_fetch_hdr_ip(px, l4, txn, txn->req.sol, expr, test);
-}
-
-static int
-acl_fetch_shdr_ip(struct proxy *px, struct session *l4, void *l7, int dir,
-		   struct acl_expr *expr, struct acl_test *test)
-{
-	struct http_txn *txn = l7;
-
-	if (!txn)
-		return 0;
-
-	if (txn->rsp.msg_state < HTTP_MSG_BODY)
-		return 0;
-
-	return acl_fetch_hdr_ip(px, l4, txn, txn->rsp.sol, expr, test);
-}
-
-/* 8. Check on URI PATH. A pointer to the PATH is stored. The path starts at
- * the first '/' after the possible hostname, and ends before the possible '?'.
- */
-static int
-acl_fetch_path(struct proxy *px, struct session *l4, void *l7, int dir,
-               struct acl_expr *expr, struct acl_test *test)
-{
-	struct http_txn *txn = l7;
-	char *ptr, *end;
-
-	if (!txn)
-		return 0;
-
-	if (txn->req.msg_state < HTTP_MSG_BODY)
-		return 0;
-
-	if (txn->rsp.msg_state != HTTP_MSG_RPBEFORE)
-		/* ensure the indexes are not affected */
-		return 0;
-
-	end = txn->req.sol + txn->req.sl.rq.u + txn->req.sl.rq.u_l;
-	ptr = http_get_path(txn);
-	if (!ptr)
-		return 0;
-
-	/* OK, we got the '/' ! */
-	test->ptr = ptr;
-
-	while (ptr < end && *ptr != '?')
-		ptr++;
-
-	test->len = ptr - test->ptr;
-
-	/* we do not need to set READ_ONLY because the data is in a buffer */
-	test->flags = ACL_TEST_F_VOL_1ST;
-	return 1;
-}
-
-static int
-acl_fetch_proto_http(struct proxy *px, struct session *s, void *l7, int dir,
-		     struct acl_expr *expr, struct acl_test *test)
-{
-	struct buffer *req = s->req;
-	struct http_txn *txn = &s->txn;
-	struct http_msg *msg = &txn->req;
-
-	/* Note: hdr_idx.v cannot be NULL in this ACL because the ACL is tagged
-	 * as a layer7 ACL, which involves automatic allocation of hdr_idx.
-	 */
-
-	if (!s || !req)
-		return 0;
-
-	if (unlikely(msg->msg_state >= HTTP_MSG_BODY)) {
-		/* Already decoded as OK */
-		test->flags |= ACL_TEST_F_SET_RES_PASS;
-		return 1;
-	}
-
-	/* Try to decode HTTP request */
-	if (likely(req->lr < req->r))
-		http_msg_analyzer(req, msg, &txn->hdr_idx);
-
-	if (unlikely(msg->msg_state < HTTP_MSG_BODY)) {
-		if ((msg->msg_state == HTTP_MSG_ERROR) || (req->flags & BF_FULL)) {
-			test->flags |= ACL_TEST_F_SET_RES_FAIL;
-			return 1;
-		}
-		/* wait for final state */
-		test->flags |= ACL_TEST_F_MAY_CHANGE;
-		return 0;
-	}
-
-	/* OK we got a valid HTTP request. We have some minor preparation to
-	 * perform so that further checks can rely on HTTP tests.
-	 */
-	txn->meth = find_http_meth(msg->sol, msg->sl.rq.m_l);
-	if (txn->meth == HTTP_METH_GET || txn->meth == HTTP_METH_HEAD)
-		s->flags |= SN_REDIRECTABLE;
-
-	if (unlikely(msg->sl.rq.v_l == 0) && !http_upgrade_v09_to_v10(req, msg, txn)) {
-		test->flags |= ACL_TEST_F_SET_RES_FAIL;
-		return 1;
-	}
-
-	test->flags |= ACL_TEST_F_SET_RES_PASS;
-	return 1;
-}
-
-/* return a valid test if the current request is the first one on the connection */
-static int
-acl_fetch_http_first_req(struct proxy *px, struct session *s, void *l7, int dir,
-		     struct acl_expr *expr, struct acl_test *test)
-{
-	if (!s)
-		return 0;
-
-	if (s->txn.flags & TX_NOT_FIRST)
-		test->flags |= ACL_TEST_F_SET_RES_FAIL;
-	else
-		test->flags |= ACL_TEST_F_SET_RES_PASS;
-
-	return 1;
-}
-
-static int
-acl_fetch_http_auth(struct proxy *px, struct session *s, void *l7, int dir,
-		    struct acl_expr *expr, struct acl_test *test)
-{
-
-	if (!s)
-		return 0;
-
-	if (!get_http_auth(s))
-		return 0;
-
-	test->ctx.a[0] = expr->arg.ul;
-	test->ctx.a[1] = s->txn.auth.user;
-	test->ctx.a[2] = s->txn.auth.pass;
-
-	test->flags |= ACL_TEST_F_READ_ONLY | ACL_TEST_F_NULL_MATCH;
-
-	return 1;
-}
-
-/************************************************************************/
-/*             All supported keywords must be declared here.            */
-/************************************************************************/
-
-/* Note: must not be declared <const> as its list will be overwritten */
-static struct acl_kw_list acl_kws = {{ },{
-	{ "req_proto_http", acl_parse_nothing, acl_fetch_proto_http, acl_match_nothing, ACL_USE_L7REQ_PERMANENT },
-
-	{ "method",     acl_parse_meth,  acl_fetch_meth,   acl_match_meth, ACL_USE_L7REQ_PERMANENT },
-	{ "req_ver",    acl_parse_ver,   acl_fetch_rqver,  acl_match_str,  ACL_USE_L7REQ_VOLATILE|ACL_MAY_LOOKUP },
-	{ "resp_ver",   acl_parse_ver,   acl_fetch_stver,  acl_match_str,  ACL_USE_L7RTR_VOLATILE|ACL_MAY_LOOKUP },
-	{ "status",     acl_parse_int,   acl_fetch_stcode, acl_match_int,  ACL_USE_L7RTR_PERMANENT },
-
-	{ "url",        acl_parse_str,   acl_fetch_url,      acl_match_str,  ACL_USE_L7REQ_VOLATILE|ACL_MAY_LOOKUP },
-	{ "url_beg",    acl_parse_str,   acl_fetch_url,      acl_match_beg,  ACL_USE_L7REQ_VOLATILE },
-	{ "url_end",    acl_parse_str,   acl_fetch_url,      acl_match_end,  ACL_USE_L7REQ_VOLATILE },
-	{ "url_sub",    acl_parse_str,   acl_fetch_url,      acl_match_sub,  ACL_USE_L7REQ_VOLATILE },
-	{ "url_dir",    acl_parse_str,   acl_fetch_url,      acl_match_dir,  ACL_USE_L7REQ_VOLATILE },
-	{ "url_dom",    acl_parse_str,   acl_fetch_url,      acl_match_dom,  ACL_USE_L7REQ_VOLATILE },
-	{ "url_reg",    acl_parse_reg,   acl_fetch_url,      acl_match_reg,  ACL_USE_L7REQ_VOLATILE },
-	{ "url_len",    acl_parse_int,   acl_fetch_url,      acl_match_len,  ACL_USE_L7REQ_VOLATILE },
-	{ "url_ip",     acl_parse_ip,    acl_fetch_url_ip,   acl_match_ip,   ACL_USE_L7REQ_VOLATILE|ACL_MAY_LOOKUP },
-	{ "url_port",   acl_parse_int,   acl_fetch_url_port, acl_match_int,  ACL_USE_L7REQ_VOLATILE },
-
-	/* note: we should set hdr* to use ACL_USE_HDR_VOLATILE, and chdr* to use L7REQ_VOLATILE */
-	{ "hdr",        acl_parse_str,   acl_fetch_chdr,    acl_match_str, ACL_USE_L7REQ_VOLATILE|ACL_MAY_LOOKUP },
-	{ "hdr_reg",    acl_parse_reg,   acl_fetch_chdr,    acl_match_reg, ACL_USE_L7REQ_VOLATILE },
-	{ "hdr_beg",    acl_parse_str,   acl_fetch_chdr,    acl_match_beg, ACL_USE_L7REQ_VOLATILE },
-	{ "hdr_end",    acl_parse_str,   acl_fetch_chdr,    acl_match_end, ACL_USE_L7REQ_VOLATILE },
-	{ "hdr_sub",    acl_parse_str,   acl_fetch_chdr,    acl_match_sub, ACL_USE_L7REQ_VOLATILE },
-	{ "hdr_dir",    acl_parse_str,   acl_fetch_chdr,    acl_match_dir, ACL_USE_L7REQ_VOLATILE },
-	{ "hdr_dom",    acl_parse_str,   acl_fetch_chdr,    acl_match_dom, ACL_USE_L7REQ_VOLATILE },
-	{ "hdr_cnt",    acl_parse_int,   acl_fetch_chdr_cnt,acl_match_int, ACL_USE_L7REQ_VOLATILE },
-	{ "hdr_len",    acl_parse_int,   acl_fetch_chdr,    acl_match_len, ACL_USE_L7REQ_VOLATILE },
-	{ "hdr_val",    acl_parse_int,   acl_fetch_chdr_val,acl_match_int, ACL_USE_L7REQ_VOLATILE },
-	{ "hdr_ip",     acl_parse_ip,    acl_fetch_chdr_ip, acl_match_ip,  ACL_USE_L7REQ_VOLATILE|ACL_MAY_LOOKUP },
-
-	{ "shdr",       acl_parse_str,   acl_fetch_shdr,    acl_match_str, ACL_USE_L7RTR_VOLATILE|ACL_MAY_LOOKUP },
-	{ "shdr_reg",   acl_parse_reg,   acl_fetch_shdr,    acl_match_reg, ACL_USE_L7RTR_VOLATILE },
-	{ "shdr_beg",   acl_parse_str,   acl_fetch_shdr,    acl_match_beg, ACL_USE_L7RTR_VOLATILE },
-	{ "shdr_end",   acl_parse_str,   acl_fetch_shdr,    acl_match_end, ACL_USE_L7RTR_VOLATILE },
-	{ "shdr_sub",   acl_parse_str,   acl_fetch_shdr,    acl_match_sub, ACL_USE_L7RTR_VOLATILE },
-	{ "shdr_dir",   acl_parse_str,   acl_fetch_shdr,    acl_match_dir, ACL_USE_L7RTR_VOLATILE },
-	{ "shdr_dom",   acl_parse_str,   acl_fetch_shdr,    acl_match_dom, ACL_USE_L7RTR_VOLATILE },
-	{ "shdr_cnt",   acl_parse_int,   acl_fetch_shdr_cnt,acl_match_int, ACL_USE_L7RTR_VOLATILE },
-	{ "shdr_len",   acl_parse_int,   acl_fetch_shdr,    acl_match_len, ACL_USE_L7RTR_VOLATILE },
-	{ "shdr_val",   acl_parse_int,   acl_fetch_shdr_val,acl_match_int, ACL_USE_L7RTR_VOLATILE },
-	{ "shdr_ip",    acl_parse_ip,    acl_fetch_shdr_ip, acl_match_ip,  ACL_USE_L7RTR_VOLATILE|ACL_MAY_LOOKUP },
-
-	{ "path",       acl_parse_str,   acl_fetch_path,   acl_match_str, ACL_USE_L7REQ_VOLATILE|ACL_MAY_LOOKUP },
-	{ "path_reg",   acl_parse_reg,   acl_fetch_path,   acl_match_reg, ACL_USE_L7REQ_VOLATILE },
-	{ "path_beg",   acl_parse_str,   acl_fetch_path,   acl_match_beg, ACL_USE_L7REQ_VOLATILE },
-	{ "path_end",   acl_parse_str,   acl_fetch_path,   acl_match_end, ACL_USE_L7REQ_VOLATILE },
-	{ "path_sub",   acl_parse_str,   acl_fetch_path,   acl_match_sub, ACL_USE_L7REQ_VOLATILE },
-	{ "path_dir",   acl_parse_str,   acl_fetch_path,   acl_match_dir, ACL_USE_L7REQ_VOLATILE },
-	{ "path_dom",   acl_parse_str,   acl_fetch_path,   acl_match_dom, ACL_USE_L7REQ_VOLATILE },
-	{ "path_len",   acl_parse_int,   acl_fetch_path,   acl_match_len, ACL_USE_L7REQ_VOLATILE },
-
-#if 0
-	{ "line",       acl_parse_str,   acl_fetch_line,   acl_match_str   },
-	{ "line_reg",   acl_parse_reg,   acl_fetch_line,   acl_match_reg   },
-	{ "line_beg",   acl_parse_str,   acl_fetch_line,   acl_match_beg   },
-	{ "line_end",   acl_parse_str,   acl_fetch_line,   acl_match_end   },
-	{ "line_sub",   acl_parse_str,   acl_fetch_line,   acl_match_sub   },
-	{ "line_dir",   acl_parse_str,   acl_fetch_line,   acl_match_dir   },
-	{ "line_dom",   acl_parse_str,   acl_fetch_line,   acl_match_dom   },
-
-	{ "cook",       acl_parse_str,   acl_fetch_cook,   acl_match_str   },
-	{ "cook_reg",   acl_parse_reg,   acl_fetch_cook,   acl_match_reg   },
-	{ "cook_beg",   acl_parse_str,   acl_fetch_cook,   acl_match_beg   },
-	{ "cook_end",   acl_parse_str,   acl_fetch_cook,   acl_match_end   },
-	{ "cook_sub",   acl_parse_str,   acl_fetch_cook,   acl_match_sub   },
-	{ "cook_dir",   acl_parse_str,   acl_fetch_cook,   acl_match_dir   },
-	{ "cook_dom",   acl_parse_str,   acl_fetch_cook,   acl_match_dom   },
-	{ "cook_pst",   acl_parse_none,  acl_fetch_cook,   acl_match_pst   },
-#endif
-
-	{ "http_auth",       acl_parse_nothing, acl_fetch_http_auth, acl_match_auth, ACL_USE_L7REQ_PERMANENT },
-	{ "http_auth_group", acl_parse_strcat,  acl_fetch_http_auth, acl_match_auth, ACL_USE_L7REQ_PERMANENT },
-	{ "http_first_req",  acl_parse_nothing, acl_fetch_http_first_req, acl_match_nothing, ACL_USE_L7REQ_PERMANENT },
-	{ NULL, NULL, NULL, NULL },
-}};
-
-/************************************************************************/
-/*     The code below is dedicated to pattern fetching and matching     */
-/************************************************************************/
-
-/* extract the IP address from the last occurrence of specified header. Note
- * that we should normally first extract the string then convert it to IP,
- * but right now we have all the functions to do this seemlessly, and we will
- * be able to change that later without touching the configuration.
- */
-static int
-pattern_fetch_hdr_ip(struct proxy *px, struct session *l4, void *l7, int dir,
-                  const char *arg, int arg_len, union pattern_data *data)
-{
-	struct http_txn *txn = l7;
-
-	data->ip.s_addr = htonl(get_ip_from_hdr2(&txn->req, arg, arg_len, &txn->hdr_idx, -1));
-	return data->ip.s_addr != 0;
-}
-
-/************************************************************************/
-/*             All supported keywords must be declared here.            */
-/************************************************************************/
-/* Note: must not be declared <const> as its list will be overwritten */
-static struct pattern_fetch_kw_list pattern_fetch_keywords = {{ },{
-	{ "hdr",       pattern_fetch_hdr_ip,   PATTERN_TYPE_IP,   PATTERN_FETCH_REQ },
-	{ NULL, NULL, 0, 0 },
-}};
-
-
-__attribute__((constructor))
-static void __http_protocol_init(void)
-{
-	acl_register_keywords(&acl_kws);
-	pattern_register_fetches(&pattern_fetch_keywords);
-}
-
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/proto_tcp.c b/deps/haproxy-1.4.21/src/proto_tcp.c
deleted file mode 100644
index 84fda20..0000000
--- a/deps/haproxy-1.4.21/src/proto_tcp.c
+++ /dev/null
@@ -1,1162 +0,0 @@
-/*
- * AF_INET/AF_INET6 SOCK_STREAM protocol layer (tcp)
- *
- * Copyright 2000-2010 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <ctype.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <time.h>
-
-#include <sys/param.h>
-#include <sys/socket.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <sys/un.h>
-
-#include <netinet/tcp.h>
-
-#include <common/cfgparse.h>
-#include <common/compat.h>
-#include <common/config.h>
-#include <common/debug.h>
-#include <common/errors.h>
-#include <common/memory.h>
-#include <common/mini-clist.h>
-#include <common/standard.h>
-#include <common/time.h>
-#include <common/version.h>
-
-#include <types/global.h>
-#include <types/server.h>
-
-#include <proto/acl.h>
-#include <proto/backend.h>
-#include <proto/buffers.h>
-#include <proto/checks.h>
-#include <proto/fd.h>
-#include <proto/log.h>
-#include <proto/port_range.h>
-#include <proto/protocols.h>
-#include <proto/proto_tcp.h>
-#include <proto/proxy.h>
-#include <proto/queue.h>
-#include <proto/session.h>
-#include <proto/stream_sock.h>
-#include <proto/task.h>
-
-#ifdef CONFIG_HAP_CTTPROXY
-#include <import/ip_tproxy.h>
-#endif
-
-static int tcp_bind_listeners(struct protocol *proto);
-
-/* Note: must not be declared <const> as its list will be overwritten */
-static struct protocol proto_tcpv4 = {
-	.name = "tcpv4",
-	.sock_domain = AF_INET,
-	.sock_type = SOCK_STREAM,
-	.sock_prot = IPPROTO_TCP,
-	.sock_family = AF_INET,
-	.sock_addrlen = sizeof(struct sockaddr_in),
-	.l3_addrlen = 32/8,
-	.read = &stream_sock_read,
-	.write = &stream_sock_write,
-	.bind_all = tcp_bind_listeners,
-	.unbind_all = unbind_all_listeners,
-	.enable_all = enable_all_listeners,
-	.listeners = LIST_HEAD_INIT(proto_tcpv4.listeners),
-	.nb_listeners = 0,
-};
-
-/* Note: must not be declared <const> as its list will be overwritten */
-static struct protocol proto_tcpv6 = {
-	.name = "tcpv6",
-	.sock_domain = AF_INET6,
-	.sock_type = SOCK_STREAM,
-	.sock_prot = IPPROTO_TCP,
-	.sock_family = AF_INET6,
-	.sock_addrlen = sizeof(struct sockaddr_in6),
-	.l3_addrlen = 128/8,
-	.read = &stream_sock_read,
-	.write = &stream_sock_write,
-	.bind_all = tcp_bind_listeners,
-	.unbind_all = unbind_all_listeners,
-	.enable_all = enable_all_listeners,
-	.listeners = LIST_HEAD_INIT(proto_tcpv6.listeners),
-	.nb_listeners = 0,
-};
-
-
-/* Binds ipv4 address <local> to socket <fd>, unless <flags> is set, in which
- * case we try to bind <remote>. <flags> is a 2-bit field consisting of :
- *  - 0 : ignore remote address (may even be a NULL pointer)
- *  - 1 : use provided address
- *  - 2 : use provided port
- *  - 3 : use both
- *
- * The function supports multiple foreign binding methods :
- *   - linux_tproxy: we directly bind to the foreign address
- *   - cttproxy: we bind to a local address then nat.
- * The second one can be used as a fallback for the first one.
- * This function returns 0 when everything's OK, 1 if it could not bind, to the
- * local address, 2 if it could not bind to the foreign address.
- */
-int tcpv4_bind_socket(int fd, int flags, struct sockaddr_in *local, struct sockaddr_in *remote)
-{
-	struct sockaddr_in bind_addr;
-	int foreign_ok = 0;
-	int ret;
-
-#ifdef CONFIG_HAP_LINUX_TPROXY
-	static int ip_transp_working = 1;
-	if (flags && ip_transp_working) {
-		if (setsockopt(fd, SOL_IP, IP_TRANSPARENT, (char *) &one, sizeof(one)) == 0
-		    || setsockopt(fd, SOL_IP, IP_FREEBIND, (char *) &one, sizeof(one)) == 0)
-			foreign_ok = 1;
-		else
-			ip_transp_working = 0;
-	}
-#endif
-	if (flags) {
-		memset(&bind_addr, 0, sizeof(bind_addr));
-		bind_addr.sin_family = AF_INET;
-		if (flags & 1)
-			bind_addr.sin_addr = remote->sin_addr;
-		if (flags & 2)
-			bind_addr.sin_port = remote->sin_port;
-	}
-
-	setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *) &one, sizeof(one));
-	if (foreign_ok) {
-		ret = bind(fd, (struct sockaddr *)&bind_addr, sizeof(bind_addr));
-		if (ret < 0)
-			return 2;
-	}
-	else {
-		ret = bind(fd, (struct sockaddr *)local, sizeof(*local));
-		if (ret < 0)
-			return 1;
-	}
-
-	if (!flags)
-		return 0;
-
-#ifdef CONFIG_HAP_CTTPROXY
-	if (!foreign_ok) {
-		struct in_tproxy itp1, itp2;
-		memset(&itp1, 0, sizeof(itp1));
-
-		itp1.op = TPROXY_ASSIGN;
-		itp1.v.addr.faddr = bind_addr.sin_addr;
-		itp1.v.addr.fport = bind_addr.sin_port;
-
-		/* set connect flag on socket */
-		itp2.op = TPROXY_FLAGS;
-		itp2.v.flags = ITP_CONNECT | ITP_ONCE;
-
-		if (setsockopt(fd, SOL_IP, IP_TPROXY, &itp1, sizeof(itp1)) != -1 &&
-		    setsockopt(fd, SOL_IP, IP_TPROXY, &itp2, sizeof(itp2)) != -1) {
-			foreign_ok = 1;
-		}
-	}
-#endif
-	if (!foreign_ok)
-		/* we could not bind to a foreign address */
-		return 2;
-
-	return 0;
-}
-
-
-/*
- * This function initiates a connection to the server assigned to this session
- * (s->srv, s->srv_addr). It will assign a server if none is assigned yet. A
- * source address may be pointed to by <from_addr>. Note that this is only used
- * in case of transparent proxying. Normal source bind addresses are still
- * determined locally (due to the possible need of a source port).
- *
- * It can return one of :
- *  - SN_ERR_NONE if everything's OK
- *  - SN_ERR_SRVTO if there are no more servers
- *  - SN_ERR_SRVCL if the connection was refused by the server
- *  - SN_ERR_PRXCOND if the connection has been limited by the proxy (maxconn)
- *  - SN_ERR_RESOURCE if a system resource is lacking (eg: fd limits, ports, ...)
- *  - SN_ERR_INTERNAL for any other purely internal errors
- * Additionnally, in the case of SN_ERR_RESOURCE, an emergency log will be emitted.
- */
-int tcpv4_connect_server(struct stream_interface *si,
-			 struct proxy *be, struct server *srv,
-			 struct sockaddr *srv_addr, struct sockaddr *from_addr)
-{
-	int fd;
-
-	if ((fd = si->fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1) {
-		qfprintf(stderr, "Cannot get a server socket.\n");
-
-		if (errno == ENFILE)
-			send_log(be, LOG_EMERG,
-				 "Proxy %s reached system FD limit at %d. Please check system tunables.\n",
-				 be->id, maxfd);
-		else if (errno == EMFILE)
-			send_log(be, LOG_EMERG,
-				 "Proxy %s reached process FD limit at %d. Please check 'ulimit-n' and restart.\n",
-				 be->id, maxfd);
-		else if (errno == ENOBUFS || errno == ENOMEM)
-			send_log(be, LOG_EMERG,
-				 "Proxy %s reached system memory limit at %d sockets. Please check system tunables.\n",
-				 be->id, maxfd);
-		/* this is a resource error */
-		return SN_ERR_RESOURCE;
-	}
-
-	if (fd >= global.maxsock) {
-		/* do not log anything there, it's a normal condition when this option
-		 * is used to serialize connections to a server !
-		 */
-		Alert("socket(): not enough free sockets. Raise -n argument. Giving up.\n");
-		close(fd);
-		return SN_ERR_PRXCOND; /* it is a configuration limit */
-	}
-
-	if ((fcntl(fd, F_SETFL, O_NONBLOCK)==-1) ||
-	    (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (char *) &one, sizeof(one)) == -1)) {
-		qfprintf(stderr,"Cannot set client socket to non blocking mode.\n");
-		close(fd);
-		return SN_ERR_INTERNAL;
-	}
-
-	if (be->options & PR_O_TCP_SRV_KA)
-		setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (char *) &one, sizeof(one));
-
-	if (be->options & PR_O_TCP_NOLING)
-		si->flags |= SI_FL_NOLINGER;
-
-	/* allow specific binding :
-	 * - server-specific at first
-	 * - proxy-specific next
-	 */
-	if (srv != NULL && srv->state & SRV_BIND_SRC) {
-		int ret, flags = 0;
-
-		switch (srv->state & SRV_TPROXY_MASK) {
-		case SRV_TPROXY_ADDR:
-		case SRV_TPROXY_CLI:
-			flags = 3;
-			break;
-		case SRV_TPROXY_CIP:
-		case SRV_TPROXY_DYN:
-			flags = 1;
-			break;
-		}
-
-#ifdef SO_BINDTODEVICE
-		/* Note: this might fail if not CAP_NET_RAW */
-		if (srv->iface_name)
-			setsockopt(fd, SOL_SOCKET, SO_BINDTODEVICE, srv->iface_name, srv->iface_len + 1);
-#endif
-
-		if (srv->sport_range) {
-			int attempts = 10; /* should be more than enough to find a spare port */
-			struct sockaddr_in src;
-
-			ret = 1;
-			src = srv->source_addr;
-
-			do {
-				/* note: in case of retry, we may have to release a previously
-				 * allocated port, hence this loop's construct.
-				 */
-				port_range_release_port(fdinfo[fd].port_range, fdinfo[fd].local_port);
-				fdinfo[fd].port_range = NULL;
-
-				if (!attempts)
-					break;
-				attempts--;
-
-				fdinfo[fd].local_port = port_range_alloc_port(srv->sport_range);
-				if (!fdinfo[fd].local_port)
-					break;
-
-				fdinfo[fd].port_range = srv->sport_range;
-				src.sin_port = htons(fdinfo[fd].local_port);
-
-				ret = tcpv4_bind_socket(fd, flags, &src, (struct sockaddr_in *)from_addr);
-			} while (ret != 0); /* binding NOK */
-		}
-		else {
-			ret = tcpv4_bind_socket(fd, flags, &srv->source_addr, (struct sockaddr_in *)from_addr);
-		}
-
-		if (ret) {
-			port_range_release_port(fdinfo[fd].port_range, fdinfo[fd].local_port);
-			fdinfo[fd].port_range = NULL;
-			close(fd);
-
-			if (ret == 1) {
-				Alert("Cannot bind to source address before connect() for server %s/%s. Aborting.\n",
-				      be->id, srv->id);
-				send_log(be, LOG_EMERG,
-					 "Cannot bind to source address before connect() for server %s/%s.\n",
-					 be->id, srv->id);
-			} else {
-				Alert("Cannot bind to tproxy source address before connect() for server %s/%s. Aborting.\n",
-				      be->id, srv->id);
-				send_log(be, LOG_EMERG,
-					 "Cannot bind to tproxy source address before connect() for server %s/%s.\n",
-					 be->id, srv->id);
-			}
-			return SN_ERR_RESOURCE;
-		}
-	}
-	else if (be->options & PR_O_BIND_SRC) {
-		int ret, flags = 0;
-
-		switch (be->options & PR_O_TPXY_MASK) {
-		case PR_O_TPXY_ADDR:
-		case PR_O_TPXY_CLI:
-			flags = 3;
-			break;
-		case PR_O_TPXY_CIP:
-		case PR_O_TPXY_DYN:
-			flags = 1;
-			break;
-		}
-
-#ifdef SO_BINDTODEVICE
-		/* Note: this might fail if not CAP_NET_RAW */
-		if (be->iface_name)
-			setsockopt(fd, SOL_SOCKET, SO_BINDTODEVICE, be->iface_name, be->iface_len + 1);
-#endif
-		ret = tcpv4_bind_socket(fd, flags, &be->source_addr, (struct sockaddr_in *)from_addr);
-		if (ret) {
-			close(fd);
-			if (ret == 1) {
-				Alert("Cannot bind to source address before connect() for proxy %s. Aborting.\n",
-				      be->id);
-				send_log(be, LOG_EMERG,
-					 "Cannot bind to source address before connect() for proxy %s.\n",
-					 be->id);
-			} else {
-				Alert("Cannot bind to tproxy source address before connect() for proxy %s. Aborting.\n",
-				      be->id);
-				send_log(be, LOG_EMERG,
-					 "Cannot bind to tproxy source address before connect() for proxy %s.\n",
-					 be->id);
-			}
-			return SN_ERR_RESOURCE;
-		}
-	}
-
-#if defined(TCP_QUICKACK)
-	/* disabling tcp quick ack now allows the first request to leave the
-	 * machine with the first ACK. We only do this if there are pending
-	 * data in the buffer.
-	 */
-	if ((be->options2 & PR_O2_SMARTCON) && si->ob->send_max)
-                setsockopt(fd, IPPROTO_TCP, TCP_QUICKACK, (char *) &zero, sizeof(zero));
-#endif
-
-	if (global.tune.server_sndbuf)
-                setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &global.tune.server_sndbuf, sizeof(global.tune.server_sndbuf));
-
-	if (global.tune.server_rcvbuf)
-                setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &global.tune.server_rcvbuf, sizeof(global.tune.server_rcvbuf));
-
-	if ((connect(fd, (struct sockaddr *)srv_addr, sizeof(struct sockaddr_in)) == -1) &&
-	    (errno != EINPROGRESS) && (errno != EALREADY) && (errno != EISCONN)) {
-
-		if (errno == EAGAIN || errno == EADDRINUSE) {
-			char *msg;
-			if (errno == EAGAIN) /* no free ports left, try again later */
-				msg = "no free ports";
-			else
-				msg = "local address already in use";
-
-			qfprintf(stderr,"Cannot connect: %s.\n",msg);
-			port_range_release_port(fdinfo[fd].port_range, fdinfo[fd].local_port);
-			fdinfo[fd].port_range = NULL;
-			close(fd);
-			send_log(be, LOG_EMERG,
-				 "Connect() failed for server %s/%s: %s.\n",
-				 be->id, srv->id, msg);
-			return SN_ERR_RESOURCE;
-		} else if (errno == ETIMEDOUT) {
-			//qfprintf(stderr,"Connect(): ETIMEDOUT");
-			port_range_release_port(fdinfo[fd].port_range, fdinfo[fd].local_port);
-			fdinfo[fd].port_range = NULL;
-			close(fd);
-			return SN_ERR_SRVTO;
-		} else {
-			// (errno == ECONNREFUSED || errno == ENETUNREACH || errno == EACCES || errno == EPERM)
-			//qfprintf(stderr,"Connect(): %d", errno);
-			port_range_release_port(fdinfo[fd].port_range, fdinfo[fd].local_port);
-			fdinfo[fd].port_range = NULL;
-			close(fd);
-			return SN_ERR_SRVCL;
-		}
-	}
-
-	fdtab[fd].owner = si;
-	fdtab[fd].state = FD_STCONN; /* connection in progress */
-	fdtab[fd].flags = FD_FL_TCP | FD_FL_TCP_NODELAY;
-	fdtab[fd].cb[DIR_RD].f = &stream_sock_read;
-	fdtab[fd].cb[DIR_RD].b = si->ib;
-	fdtab[fd].cb[DIR_WR].f = &stream_sock_write;
-	fdtab[fd].cb[DIR_WR].b = si->ob;
-
-	fdinfo[fd].peeraddr = (struct sockaddr *)srv_addr;
-	fdinfo[fd].peerlen = sizeof(struct sockaddr_in);
-
-	fd_insert(fd);
-	EV_FD_SET(fd, DIR_WR);  /* for connect status */
-
-	si->state = SI_ST_CON;
-	si->flags |= SI_FL_CAP_SPLTCP; /* TCP supports splicing */
-	si->exp = tick_add_ifset(now_ms, be->timeout.connect);
-
-	return SN_ERR_NONE;  /* connection is OK */
-}
-
-
-/* This function tries to bind a TCPv4/v6 listener. It may return a warning or
- * an error message in <err> if the message is at most <errlen> bytes long
- * (including '\0'). The return value is composed from ERR_ABORT, ERR_WARN,
- * ERR_ALERT, ERR_RETRYABLE and ERR_FATAL. ERR_NONE indicates that everything
- * was alright and that no message was returned. ERR_RETRYABLE means that an
- * error occurred but that it may vanish after a retry (eg: port in use), and
- * ERR_FATAL indicates a non-fixable error.ERR_WARN and ERR_ALERT do not alter
- * the meaning of the error, but just indicate that a message is present which
- * should be displayed with the respective level. Last, ERR_ABORT indicates
- * that it's pointless to try to start other listeners. No error message is
- * returned if errlen is NULL.
- */
-int tcp_bind_listener(struct listener *listener, char *errmsg, int errlen)
-{
-	__label__ tcp_return, tcp_close_return;
-	int fd, err;
-	const char *msg = NULL;
-
-	/* ensure we never return garbage */
-	if (errmsg && errlen)
-		*errmsg = 0;
-
-	if (listener->state != LI_ASSIGNED)
-		return ERR_NONE; /* already bound */
-
-	err = ERR_NONE;
-
-	if ((fd = socket(listener->addr.ss_family, SOCK_STREAM, IPPROTO_TCP)) == -1) {
-		err |= ERR_RETRYABLE | ERR_ALERT;
-		msg = "cannot create listening socket";
-		goto tcp_return;
-	}
-
-	if (fd >= global.maxsock) {
-		err |= ERR_FATAL | ERR_ABORT | ERR_ALERT;
-		msg = "not enough free sockets (raise '-n' parameter)";
-		goto tcp_close_return;
-	}
-
-	if (fcntl(fd, F_SETFL, O_NONBLOCK) == -1) {
-		err |= ERR_FATAL | ERR_ALERT;
-		msg = "cannot make socket non-blocking";
-		goto tcp_close_return;
-	}
-
-	if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *) &one, sizeof(one)) == -1) {
-		/* not fatal but should be reported */
-		msg = "cannot do so_reuseaddr";
-		err |= ERR_ALERT;
-	}
-
-	if (listener->options & LI_O_NOLINGER)
-		setsockopt(fd, SOL_SOCKET, SO_LINGER, (struct linger *) &nolinger, sizeof(struct linger));
-
-#ifdef SO_REUSEPORT
-	/* OpenBSD supports this. As it's present in old libc versions of Linux,
-	 * it might return an error that we will silently ignore.
-	 */
-	setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, (char *) &one, sizeof(one));
-#endif
-#ifdef CONFIG_HAP_LINUX_TPROXY
-	if ((listener->options & LI_O_FOREIGN)
-	    && (setsockopt(fd, SOL_IP, IP_TRANSPARENT, (char *) &one, sizeof(one)) == -1)
-	    && (setsockopt(fd, SOL_IP, IP_FREEBIND, (char *) &one, sizeof(one)) == -1)) {
-		msg = "cannot make listening socket transparent";
-		err |= ERR_ALERT;
-	}
-#endif
-#ifdef SO_BINDTODEVICE
-	/* Note: this might fail if not CAP_NET_RAW */
-	if (listener->interface) {
-		if (setsockopt(fd, SOL_SOCKET, SO_BINDTODEVICE,
-			       listener->interface, strlen(listener->interface) + 1) == -1) {
-			msg = "cannot bind listener to device";
-			err |= ERR_WARN;
-		}
-	}
-#endif
-#if defined(TCP_MAXSEG)
-	if (listener->maxseg) {
-		if (setsockopt(fd, IPPROTO_TCP, TCP_MAXSEG,
-			       &listener->maxseg, sizeof(listener->maxseg)) == -1) {
-			msg = "cannot set MSS";
-			err |= ERR_WARN;
-		}
-	}
-#endif
-#if defined(TCP_DEFER_ACCEPT)
-	if (listener->options & LI_O_DEF_ACCEPT) {
-		/* defer accept by up to one second */
-		int accept_delay = 1;
-		if (setsockopt(fd, IPPROTO_TCP, TCP_DEFER_ACCEPT, &accept_delay, sizeof(accept_delay)) == -1) {
-			msg = "cannot enable DEFER_ACCEPT";
-			err |= ERR_WARN;
-		}
-	}
-#endif
-	if (bind(fd, (struct sockaddr *)&listener->addr, listener->proto->sock_addrlen) == -1) {
-		err |= ERR_RETRYABLE | ERR_ALERT;
-		msg = "cannot bind socket";
-		goto tcp_close_return;
-	}
-
-	if (listen(fd, listener->backlog ? listener->backlog : listener->maxconn) == -1) {
-		err |= ERR_RETRYABLE | ERR_ALERT;
-		msg = "cannot listen to socket";
-		goto tcp_close_return;
-	}
-
-#if defined(TCP_QUICKACK)
-	if (listener->options & LI_O_NOQUICKACK)
-		setsockopt(fd, IPPROTO_TCP, TCP_QUICKACK, (char *) &zero, sizeof(zero));
-#endif
-
-	/* the socket is ready */
-	listener->fd = fd;
-	listener->state = LI_LISTEN;
-
-	/* the function for the accept() event */
-	fd_insert(fd);
-	fdtab[fd].cb[DIR_RD].f = listener->accept;
-	fdtab[fd].cb[DIR_WR].f = NULL; /* never called */
-	fdtab[fd].cb[DIR_RD].b = fdtab[fd].cb[DIR_WR].b = NULL;
-	fdtab[fd].owner = listener; /* reference the listener instead of a task */
-	fdtab[fd].state = FD_STLISTEN;
-	fdtab[fd].flags = FD_FL_TCP;
-	if (listener->options & LI_O_NOLINGER)
-		fdtab[fd].flags |= FD_FL_TCP_NOLING;
-
-	fdinfo[fd].peeraddr = NULL;
-	fdinfo[fd].peerlen = 0;
- tcp_return:
-	if (msg && errlen)
-		strlcpy2(errmsg, msg, errlen);
-	return err;
-
- tcp_close_return:
-	close(fd);
-	goto tcp_return;
-}
-
-/* This function creates all TCP sockets bound to the protocol entry <proto>.
- * It is intended to be used as the protocol's bind_all() function.
- * The sockets will be registered but not added to any fd_set, in order not to
- * loose them across the fork(). A call to enable_all_listeners() is needed
- * to complete initialization. The return value is composed from ERR_*.
- */
-static int tcp_bind_listeners(struct protocol *proto)
-{
-	struct listener *listener;
-	int err = ERR_NONE;
-
-	list_for_each_entry(listener, &proto->listeners, proto_list) {
-		err |= tcp_bind_listener(listener, NULL, 0);
-		if ((err & ERR_CODE) == ERR_ABORT)
-			break;
-	}
-
-	return err;
-}
-
-/* Add listener to the list of tcpv4 listeners. The listener's state
- * is automatically updated from LI_INIT to LI_ASSIGNED. The number of
- * listeners is updated. This is the function to use to add a new listener.
- */
-void tcpv4_add_listener(struct listener *listener)
-{
-	if (listener->state != LI_INIT)
-		return;
-	listener->state = LI_ASSIGNED;
-	listener->proto = &proto_tcpv4;
-	LIST_ADDQ(&proto_tcpv4.listeners, &listener->proto_list);
-	proto_tcpv4.nb_listeners++;
-}
-
-/* Add listener to the list of tcpv4 listeners. The listener's state
- * is automatically updated from LI_INIT to LI_ASSIGNED. The number of
- * listeners is updated. This is the function to use to add a new listener.
- */
-void tcpv6_add_listener(struct listener *listener)
-{
-	if (listener->state != LI_INIT)
-		return;
-	listener->state = LI_ASSIGNED;
-	listener->proto = &proto_tcpv6;
-	LIST_ADDQ(&proto_tcpv6.listeners, &listener->proto_list);
-	proto_tcpv6.nb_listeners++;
-}
-
-/* This function performs the TCP request analysis on the current request. It
- * returns 1 if the processing can continue on next analysers, or zero if it
- * needs more data, encounters an error, or wants to immediately abort the
- * request. It relies on buffers flags, and updates s->req->analysers. Its
- * behaviour is rather simple:
- *  - the analyser should check for errors and timeouts, and react as expected.
- *    It does not have to close anything upon error, the caller will. Note that
- *    the caller also knows how to report errors and timeouts.
- *  - if the analyser does not have enough data, it must return 0 without calling
- *    other ones. It should also probably do a buffer_write_dis() to ensure
- *    that unprocessed data will not be forwarded. But that probably depends on
- *    the protocol.
- *  - if an analyser has enough data, it just has to pass on to the next
- *    analyser without using buffer_write_dis() (enabled by default).
- *  - if an analyser thinks it has no added value anymore staying here, it must
- *    reset its bit from the analysers flags in order not to be called anymore.
- *
- * In the future, analysers should be able to indicate that they want to be
- * called after XXX bytes have been received (or transfered), and the min of
- * all's wishes will be used to ring back (unless a special condition occurs).
- */
-int tcp_inspect_request(struct session *s, struct buffer *req, int an_bit)
-{
-	struct tcp_rule *rule;
-	int partial;
-
-	DPRINTF(stderr,"[%u] %s: session=%p b=%p, exp(r,w)=%u,%u bf=%08x bl=%d analysers=%02x\n",
-		now_ms, __FUNCTION__,
-		s,
-		req,
-		req->rex, req->wex,
-		req->flags,
-		req->l,
-		req->analysers);
-
-	/* We don't know whether we have enough data, so must proceed
-	 * this way :
-	 * - iterate through all rules in their declaration order
-	 * - if one rule returns MISS, it means the inspect delay is
-	 *   not over yet, then return immediately, otherwise consider
-	 *   it as a non-match.
-	 * - if one rule returns OK, then return OK
-	 * - if one rule returns KO, then return KO
-	 */
-
-	if (req->flags & (BF_SHUTR|BF_FULL) || !s->fe->tcp_req.inspect_delay || tick_is_expired(req->analyse_exp, now_ms))
-		partial = 0;
-	else
-		partial = ACL_PARTIAL;
-
-	list_for_each_entry(rule, &s->fe->tcp_req.inspect_rules, list) {
-		int ret = ACL_PAT_PASS;
-
-		if (rule->cond) {
-			ret = acl_exec_cond(rule->cond, s->fe, s, &s->txn, ACL_DIR_REQ | partial);
-			if (ret == ACL_PAT_MISS) {
-				buffer_dont_connect(req);
-				/* just set the request timeout once at the beginning of the request */
-				if (!tick_isset(req->analyse_exp) && s->fe->tcp_req.inspect_delay)
-					req->analyse_exp = tick_add_ifset(now_ms, s->fe->tcp_req.inspect_delay);
-				return 0;
-			}
-
-			ret = acl_pass(ret);
-			if (rule->cond->pol == ACL_COND_UNLESS)
-				ret = !ret;
-		}
-
-		if (ret) {
-			/* we have a matching rule. */
-			if (rule->action == TCP_ACT_REJECT) {
-				buffer_abort(req);
-				buffer_abort(s->rep);
-				req->analysers = 0;
-
-				s->fe->counters.denied_req++;
-				if (s->listener->counters)
-					s->listener->counters->denied_req++;
-
-				if (!(s->flags & SN_ERR_MASK))
-					s->flags |= SN_ERR_PRXCOND;
-				if (!(s->flags & SN_FINST_MASK))
-					s->flags |= SN_FINST_R;
-				return 0;
-			}
-				/* otherwise accept */
-			break;
-		}
-	}
-
-	/* if we get there, it means we have no rule which matches, or
-	 * we have an explicit accept, so we apply the default accept.
-	 */
-	req->analysers &= ~an_bit;
-	req->analyse_exp = TICK_ETERNITY;
-	return 1;
-}
-
-/* Apply RDP cookie persistence to the current session. For this, the function
- * tries to extract an RDP cookie from the request buffer, and look for the
- * matching server in the list. If the server is found, it is assigned to the
- * session. This always returns 1, and the analyser removes itself from the
- * list. Nothing is performed if a server was already assigned.
- */
-int tcp_persist_rdp_cookie(struct session *s, struct buffer *req, int an_bit)
-{
-	struct proxy    *px   = s->be;
-	int              ret;
-	struct acl_expr  expr;
-	struct acl_test  test;
-	struct server *srv = px->srv;
-	struct sockaddr_in addr;
-	char *p;
-
-	DPRINTF(stderr,"[%u] %s: session=%p b=%p, exp(r,w)=%u,%u bf=%08x bl=%d analysers=%02x\n",
-		now_ms, __FUNCTION__,
-		s,
-		req,
-		req->rex, req->wex,
-		req->flags,
-		req->l,
-		req->analysers);
-
-	if (s->flags & SN_ASSIGNED)
-		goto no_cookie;
-
-	memset(&expr, 0, sizeof(expr));
-	memset(&test, 0, sizeof(test));
-
-	expr.arg.str = s->be->rdp_cookie_name;
-	expr.arg_len = s->be->rdp_cookie_len;
-
-	ret = acl_fetch_rdp_cookie(px, s, NULL, ACL_DIR_REQ, &expr, &test);
-	if (ret == 0 || (test.flags & ACL_TEST_F_MAY_CHANGE) || test.len == 0)
-		goto no_cookie;
-
-	memset(&addr, 0, sizeof(addr));
-	addr.sin_family = AF_INET;
-
-	/* Considering an rdp cookie detected using acl, test.ptr ended with <cr><lf> and should return */
-	addr.sin_addr.s_addr = strtoul(test.ptr, &p, 10);
-	if (*p != '.')
-		goto no_cookie;
-	p++;
-	addr.sin_port = (unsigned short)strtoul(p, &p, 10);
-	if (*p != '.')
-		goto no_cookie;
-
-	while (srv) {
-		if (memcmp(&addr, &(srv->addr), sizeof(addr)) == 0) {
-			if ((srv->state & SRV_RUNNING) || (px->options & PR_O_PERSIST)) {
-				/* we found the server and it is usable */
-				s->flags |= SN_DIRECT | SN_ASSIGNED;
-				s->srv = srv;
-				break;
-			}
-		}
-		srv = srv->next;
-	}
-
-no_cookie:
-	req->analysers &= ~an_bit;
-	req->analyse_exp = TICK_ETERNITY;
-	return 1;
-}
-
-
-/* This function should be called to parse a line starting with the "tcp-request"
- * keyword.
- */
-static int tcp_parse_tcp_req(char **args, int section_type, struct proxy *curpx,
-			     struct proxy *defpx, char *err, int errlen)
-{
-	const char *ptr = NULL;
-	unsigned int val;
-	int retlen;
-
-	if (!*args[1]) {
-		snprintf(err, errlen, "missing argument for '%s' in %s '%s'",
-			 args[0], proxy_type_str(curpx), curpx->id);
-		return -1;
-	}
-
-	if (!strcmp(args[1], "inspect-delay")) {
-		if (curpx == defpx) {
-			snprintf(err, errlen, "%s %s is not allowed in 'defaults' sections",
-				 args[0], args[1]);
-			return -1;
-		}
-
-		if (!(curpx->cap & PR_CAP_FE)) {
-			snprintf(err, errlen, "%s %s will be ignored because %s '%s' has no %s capability",
-				 args[0], args[1], proxy_type_str(curpx), curpx->id,
-				 "frontend");
-			return 1;
-		}
-
-		if (!*args[2] || (ptr = parse_time_err(args[2], &val, TIME_UNIT_MS))) {
-			retlen = snprintf(err, errlen,
-					  "'%s %s' expects a positive delay in milliseconds, in %s '%s'",
-					  args[0], args[1], proxy_type_str(curpx), curpx->id);
-			if (ptr && retlen < errlen)
-				retlen += snprintf(err+retlen, errlen - retlen,
-						   " (unexpected character '%c')", *ptr);
-			return -1;
-		}
-
-		if (curpx->tcp_req.inspect_delay) {
-			snprintf(err, errlen, "ignoring %s %s (was already defined) in %s '%s'",
-				 args[0], args[1], proxy_type_str(curpx), curpx->id);
-			return 1;
-		}
-		curpx->tcp_req.inspect_delay = val;
-		return 0;
-	}
-
-	if (!strcmp(args[1], "content")) {
-		int action;
-		int warn = 0;
-		int pol = ACL_COND_NONE;
-		struct acl_cond *cond;
-		struct tcp_rule *rule;
-
-		if (curpx == defpx) {
-			snprintf(err, errlen, "%s %s is not allowed in 'defaults' sections",
-				 args[0], args[1]);
-			return -1;
-		}
-
-		if (!strcmp(args[2], "accept"))
-			action = TCP_ACT_ACCEPT;
-		else if (!strcmp(args[2], "reject"))
-			action = TCP_ACT_REJECT;
-		else {
-			retlen = snprintf(err, errlen,
-					  "'%s %s' expects 'accept' or 'reject', in %s '%s' (was '%s')",
-					  args[0], args[1], proxy_type_str(curpx), curpx->id, args[2]);
-			return -1;
-		}
-
-		pol = ACL_COND_NONE;
-		cond = NULL;
-
-		if (strcmp(args[3], "if") == 0 || strcmp(args[3], "unless") == 0) {
-			if ((cond = build_acl_cond(NULL, 0, curpx, (const char **)args+3)) == NULL) {
-				retlen = snprintf(err, errlen,
-						  "error detected in %s '%s' while parsing '%s' condition",
-						  proxy_type_str(curpx), curpx->id, args[3]);
-				return -1;
-			}
-		}
-		else if (*args[3]) {
-			retlen = snprintf(err, errlen,
-					  "'%s %s %s' only accepts 'if' or 'unless', in %s '%s' (was '%s')",
-					  args[0], args[1], args[2], proxy_type_str(curpx), curpx->id, args[3]);
-			return -1;
-		}
-
-		if (cond && (cond->requires & ACL_USE_RTR_ANY)) {
-			struct acl *acl;
-			const char *name;
-
-			acl = cond_find_require(cond, ACL_USE_RTR_ANY);
-			name = acl ? acl->name : "(unknown)";
-
-			retlen = snprintf(err, errlen,
-					  "acl '%s' involves some response-only criteria which will be ignored.",
-					  name);
-			warn++;
-		}
-		rule = (struct tcp_rule *)calloc(1, sizeof(*rule));
-		rule->cond = cond;
-		rule->action = action;
-		LIST_INIT(&rule->list);
-		LIST_ADDQ(&curpx->tcp_req.inspect_rules, &rule->list);
-		return warn;
-	}
-
-	snprintf(err, errlen, "unknown argument '%s' after '%s' in %s '%s'",
-		 args[1], args[0], proxy_type_str(proxy), curpx->id);
-	return -1;
-}
-
-/* return the number of bytes in the request buffer */
-static int
-acl_fetch_req_len(struct proxy *px, struct session *l4, void *l7, int dir,
-		  struct acl_expr *expr, struct acl_test *test)
-{
-	if (!l4 || !l4->req)
-		return 0;
-
-	test->i = l4->req->l;
-	test->flags = ACL_TEST_F_VOLATILE | ACL_TEST_F_MAY_CHANGE;
-	return 1;
-}
-
-/* Return the version of the SSL protocol in the request. It supports both
- * SSLv3 (TLSv1) header format for any message, and SSLv2 header format for
- * the hello message. The SSLv3 format is described in RFC 2246 p49, and the
- * SSLv2 format is described here, and completed p67 of RFC 2246 :
- *    http://wp.netscape.com/eng/security/SSL_2.html
- *
- * Note: this decoder only works with non-wrapping data.
- */
-static int
-acl_fetch_req_ssl_ver(struct proxy *px, struct session *l4, void *l7, int dir,
-			struct acl_expr *expr, struct acl_test *test)
-{
-	int version, bleft, msg_len;
-	const unsigned char *data;
-
-	if (!l4 || !l4->req)
-		return 0;
-
-	msg_len = 0;
-	bleft = l4->req->l;
-	if (!bleft)
-		goto too_short;
-
-	data = (const unsigned char *)l4->req->w;
-	if ((*data >= 0x14 && *data <= 0x17) || (*data == 0xFF)) {
-		/* SSLv3 header format */
-		if (bleft < 5)
-			goto too_short;
-
-		version = (data[1] << 16) + data[2]; /* version: major, minor */
-		msg_len = (data[3] <<  8) + data[4]; /* record length */
-
-		/* format introduced with SSLv3 */
-		if (version < 0x00030000)
-			goto not_ssl;
-
-		/* message length between 1 and 2^14 + 2048 */
-		if (msg_len < 1 || msg_len > ((1<<14) + 2048))
-			goto not_ssl;
-
-		bleft -= 5; data += 5;
-	} else {
-		/* SSLv2 header format, only supported for hello (msg type 1) */
-		int rlen, plen, cilen, silen, chlen;
-
-		if (*data & 0x80) {
-			if (bleft < 3)
-				goto too_short;
-			/* short header format : 15 bits for length */
-			rlen = ((data[0] & 0x7F) << 8) | data[1];
-			plen = 0;
-			bleft -= 2; data += 2;
-		} else {
-			if (bleft < 4)
-				goto too_short;
-			/* long header format : 14 bits for length + pad length */
-			rlen = ((data[0] & 0x3F) << 8) | data[1];
-			plen = data[2];
-			bleft -= 3; data += 2;
-		}
-
-		if (*data != 0x01)
-			goto not_ssl;
-		bleft--; data++;
-
-		if (bleft < 8)
-			goto too_short;
-		version = (data[0] << 16) + data[1]; /* version: major, minor */
-		cilen   = (data[2] <<  8) + data[3]; /* cipher len, multiple of 3 */
-		silen   = (data[4] <<  8) + data[5]; /* session_id_len: 0 or 16 */
-		chlen   = (data[6] <<  8) + data[7]; /* 16<=challenge length<=32 */
-
-		bleft -= 8; data += 8;
-		if (cilen % 3 != 0)
-			goto not_ssl;
-		if (silen && silen != 16)
-			goto not_ssl;
-		if (chlen < 16 || chlen > 32)
-			goto not_ssl;
-		if (rlen != 9 + cilen + silen + chlen)
-			goto not_ssl;
-
-		/* focus on the remaining data length */
-		msg_len = cilen + silen + chlen + plen;
-	}
-	/* We could recursively check that the buffer ends exactly on an SSL
-	 * fragment boundary and that a possible next segment is still SSL,
-	 * but that's a bit pointless. However, we could still check that
-	 * all the part of the request which fits in a buffer is already
-	 * there.
-	 */
-	if (msg_len > buffer_max_len(l4->req) + l4->req->data - l4->req->w)
-		msg_len = buffer_max_len(l4->req) + l4->req->data - l4->req->w;
-
-	if (bleft < msg_len)
-		goto too_short;
-
-	/* OK that's enough. We have at least the whole message, and we have
-	 * the protocol version.
-	 */
-	test->i = version;
-	test->flags = ACL_TEST_F_VOLATILE;
-	return 1;
-
- too_short:
-	test->flags = ACL_TEST_F_MAY_CHANGE;
- not_ssl:
-	return 0;
-}
-
-int
-acl_fetch_rdp_cookie(struct proxy *px, struct session *l4, void *l7, int dir,
-                     struct acl_expr *expr, struct acl_test *test)
-{
-	int bleft;
-	const unsigned char *data;
-
-	if (!l4 || !l4->req)
-		return 0;
-
-	test->flags = 0;
-
-	bleft = l4->req->l;
-	if (bleft <= 11)
-		goto too_short;
-
-	data = (const unsigned char *)l4->req->w + 11;
-	bleft -= 11;
-
-	if (bleft <= 7)
-		goto too_short;
-
-	if (strncasecmp((const char *)data, "Cookie:", 7) != 0)
-		goto not_cookie;
-
-	data += 7;
-	bleft -= 7;
-
-	while (bleft > 0 && *data == ' ') {
-		data++;
-		bleft--;
-	}
-
-	if (expr->arg_len) {
-
-		if (bleft <= expr->arg_len)
-			goto too_short;
-
-		if ((data[expr->arg_len] != '=') ||
-		    strncasecmp(expr->arg.str, (const char *)data, expr->arg_len) != 0)
-			goto not_cookie;
-
-		data += expr->arg_len + 1;
-		bleft -= expr->arg_len + 1;
-	} else {
-		while (bleft > 0 && *data != '=') {
-			if (*data == '\r' || *data == '\n')
-				goto not_cookie;
-			data++;
-			bleft--;
-		}
-
-		if (bleft < 1)
-			goto too_short;
-
-		if (*data != '=')
-			goto not_cookie;
-
-		data++;
-		bleft--;
-	}
-
-	/* data points to cookie value */
-	test->ptr = (char *)data;
-	test->len = 0;
-
-	while (bleft > 0 && *data != '\r') {
-		data++;
-		bleft--;
-	}
-
-	if (bleft < 2)
-		goto too_short;
-
-	if (data[0] != '\r' || data[1] != '\n')
-		goto not_cookie;
-
-	test->len = (char *)data - test->ptr;
-	test->flags = ACL_TEST_F_VOLATILE;
-	return 1;
-
- too_short:
-	test->flags = ACL_TEST_F_MAY_CHANGE;
- not_cookie:
-	return 0;
-}
-
-static int
-acl_fetch_rdp_cookie_cnt(struct proxy *px, struct session *l4, void *l7, int dir,
-			struct acl_expr *expr, struct acl_test *test)
-{
-	int ret;
-
-	ret = acl_fetch_rdp_cookie(px, l4, l7, dir, expr, test);
-
-	test->ptr = NULL;
-	test->len = 0;
-
-	if (test->flags & ACL_TEST_F_MAY_CHANGE)
-		return 0;
-
-	test->flags = ACL_TEST_F_VOLATILE;
-	test->i = ret;
-
-	return 1;
-}
-
-static struct cfg_kw_list cfg_kws = {{ },{
-	{ CFG_LISTEN, "tcp-request", tcp_parse_tcp_req },
-	{ 0, NULL, NULL },
-}};
-
-static struct acl_kw_list acl_kws = {{ },{
-	{ "req_len",      acl_parse_int,        acl_fetch_req_len,     acl_match_int, ACL_USE_L4REQ_VOLATILE },
-	{ "req_ssl_ver",  acl_parse_dotted_ver, acl_fetch_req_ssl_ver, acl_match_int, ACL_USE_L4REQ_VOLATILE },
-	{ "req_rdp_cookie",     acl_parse_str,  acl_fetch_rdp_cookie,     acl_match_str, ACL_USE_L4REQ_VOLATILE|ACL_MAY_LOOKUP },
-	{ "req_rdp_cookie_cnt", acl_parse_int,  acl_fetch_rdp_cookie_cnt, acl_match_int, ACL_USE_L4REQ_VOLATILE },
-	{ NULL, NULL, NULL, NULL },
-}};
-
-__attribute__((constructor))
-static void __tcp_protocol_init(void)
-{
-	protocol_register(&proto_tcpv4);
-	protocol_register(&proto_tcpv6);
-	cfg_register_keywords(&cfg_kws);
-	acl_register_keywords(&acl_kws);
-}
-
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/proto_uxst.c b/deps/haproxy-1.4.21/src/proto_uxst.c
deleted file mode 100644
index eb4a53d..0000000
--- a/deps/haproxy-1.4.21/src/proto_uxst.c
+++ /dev/null
@@ -1,585 +0,0 @@
-/*
- * UNIX SOCK_STREAM protocol layer (uxst)
- *
- * Copyright 2000-2009 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <ctype.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <syslog.h>
-#include <time.h>
-
-#include <sys/param.h>
-#include <sys/socket.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <sys/un.h>
-
-#include <common/compat.h>
-#include <common/config.h>
-#include <common/debug.h>
-#include <common/errors.h>
-#include <common/memory.h>
-#include <common/mini-clist.h>
-#include <common/standard.h>
-#include <common/ticks.h>
-#include <common/time.h>
-#include <common/version.h>
-
-#include <types/global.h>
-
-#include <proto/acl.h>
-#include <proto/backend.h>
-#include <proto/buffers.h>
-#include <proto/dumpstats.h>
-#include <proto/fd.h>
-#include <proto/log.h>
-#include <proto/protocols.h>
-#include <proto/proto_uxst.h>
-#include <proto/queue.h>
-#include <proto/session.h>
-#include <proto/stream_interface.h>
-#include <proto/stream_sock.h>
-#include <proto/task.h>
-
-#ifndef MAXPATHLEN
-#define MAXPATHLEN 128
-#endif
-
-static int uxst_bind_listeners(struct protocol *proto);
-static int uxst_unbind_listeners(struct protocol *proto);
-
-/* Note: must not be declared <const> as its list will be overwritten */
-static struct protocol proto_unix = {
-	.name = "unix_stream",
-	.sock_domain = PF_UNIX,
-	.sock_type = SOCK_STREAM,
-	.sock_prot = 0,
-	.sock_family = AF_UNIX,
-	.sock_addrlen = sizeof(struct sockaddr_un),
-	.l3_addrlen = sizeof(((struct sockaddr_un*)0)->sun_path),/* path len */
-	.read = &stream_sock_read,
-	.write = &stream_sock_write,
-	.bind_all = uxst_bind_listeners,
-	.unbind_all = uxst_unbind_listeners,
-	.enable_all = enable_all_listeners,
-	.disable_all = disable_all_listeners,
-	.listeners = LIST_HEAD_INIT(proto_unix.listeners),
-	.nb_listeners = 0,
-};
-
-/********************************
- * 1) low-level socket functions
- ********************************/
-
-
-/* This function creates a named PF_UNIX stream socket at address <path>. Note
- * that the path cannot be NULL nor empty. <uid> and <gid> different of -1 will
- * be used to change the socket owner. If <mode> is not 0, it will be used to
- * restrict access to the socket. While it is known not to be portable on every
- * OS, it's still useful where it works.
- * It returns the assigned file descriptor, or -1 in the event of an error.
- */
-static int create_uxst_socket(const char *path, uid_t uid, gid_t gid, mode_t mode)
-{
-	char tempname[MAXPATHLEN];
-	char backname[MAXPATHLEN];
-	struct sockaddr_un addr;
-
-	int ret, sock;
-
-	/* 1. create socket names */
-	if (!path[0]) {
-		Alert("Invalid empty name for a UNIX socket. Aborting.\n");
-		goto err_return;
-	}
-
-	ret = snprintf(tempname, MAXPATHLEN, "%s.%d.tmp", path, pid);
-	if (ret < 0 || ret >= MAXPATHLEN) {
-		Alert("name too long for UNIX socket (%s). Aborting.\n", path);
-		goto err_return;
-	}
-
-	ret = snprintf(backname, MAXPATHLEN, "%s.%d.bak", path, pid);
-	if (ret < 0 || ret >= MAXPATHLEN) {
-		Alert("name too long for UNIX socket (%s). Aborting.\n", path);
-		goto err_return;
-	}
-
-	/* 2. clean existing orphaned entries */
-	if (unlink(tempname) < 0 && errno != ENOENT) {
-		Alert("error when trying to unlink previous UNIX socket (%s). Aborting.\n", path);
-		goto err_return;
-	}
-
-	if (unlink(backname) < 0 && errno != ENOENT) {
-		Alert("error when trying to unlink previous UNIX socket (%s). Aborting.\n", path);
-		goto err_return;
-	}
-
-	/* 3. backup existing socket */
-	if (link(path, backname) < 0 && errno != ENOENT) {
-		Alert("error when trying to preserve previous UNIX socket (%s). Aborting.\n", path);
-		goto err_return;
-	}
-
-	/* 4. prepare new socket */
-	addr.sun_family = AF_UNIX;
-	strncpy(addr.sun_path, tempname, sizeof(addr.sun_path));
-	addr.sun_path[sizeof(addr.sun_path) - 1] = 0;
-
-	sock = socket(PF_UNIX, SOCK_STREAM, 0);
-	if (sock < 0) {
-		Alert("cannot create socket for UNIX listener (%s). Aborting.\n", path);
-		goto err_unlink_back;
-	}
-
-	if (sock >= global.maxsock) {
-		Alert("socket(): not enough free sockets for UNIX listener (%s). Raise -n argument. Aborting.\n", path);
-		goto err_unlink_temp;
-	}
-
-	if (fcntl(sock, F_SETFL, O_NONBLOCK) == -1) {
-		Alert("cannot make UNIX socket non-blocking. Aborting.\n");
-		goto err_unlink_temp;
-	}
-
-	if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
-		/* note that bind() creates the socket <tempname> on the file system */
-		Alert("cannot bind socket for UNIX listener (%s). Aborting.\n", path);
-		goto err_unlink_temp;
-	}
-
-	if (((uid != -1 || gid != -1) && (chown(tempname, uid, gid) == -1)) ||
-	    (mode != 0 && chmod(tempname, mode) == -1)) {
-		Alert("cannot change UNIX socket ownership (%s). Aborting.\n", path);
-		goto err_unlink_temp;
-	}
-
-	if (listen(sock, 0) < 0) {
-		Alert("cannot listen to socket for UNIX listener (%s). Aborting.\n", path);
-		goto err_unlink_temp;
-	}
-
-	/* 5. install.
-	 * Point of no return: we are ready, we'll switch the sockets. We don't
-	 * fear loosing the socket <path> because we have a copy of it in
-	 * backname.
-	 */
-	if (rename(tempname, path) < 0) {
-		Alert("cannot switch final and temporary sockets for UNIX listener (%s). Aborting.\n", path);
-		goto err_rename;
-	}
-
-	/* 6. cleanup */
-	unlink(backname); /* no need to keep this one either */
-
-	return sock;
-
- err_rename:
-	ret = rename(backname, path);
-	if (ret < 0 && errno == ENOENT)
-		unlink(path);
- err_unlink_temp:
-	unlink(tempname);
-	close(sock);
- err_unlink_back:
-	unlink(backname);
- err_return:
-	return -1;
-}
-
-/* Tries to destroy the UNIX stream socket <path>. The socket must not be used
- * anymore. It practises best effort, and no error is returned.
- */
-static void destroy_uxst_socket(const char *path)
-{
-	struct sockaddr_un addr;
-	int sock, ret;
-
-	/* We might have been chrooted, so we may not be able to access the
-	 * socket. In order to avoid bothering the other end, we connect with a
-	 * wrong protocol, namely SOCK_DGRAM. The return code from connect()
-	 * is enough to know if the socket is still live or not. If it's live
-	 * in mode SOCK_STREAM, we get EPROTOTYPE or anything else but not
-	 * ECONNREFUSED. In this case, we do not touch it because it's used
-	 * by some other process.
-	 */
-	sock = socket(PF_UNIX, SOCK_DGRAM, 0);
-	if (sock < 0)
-		return;
-
-	addr.sun_family = AF_UNIX;
-	strncpy(addr.sun_path, path, sizeof(addr.sun_path));
-	addr.sun_path[sizeof(addr.sun_path) - 1] = 0;
-	ret = connect(sock, (struct sockaddr *)&addr, sizeof(addr));
-	if (ret < 0 && errno == ECONNREFUSED) {
-		/* Connect failed: the socket still exists but is not used
-		 * anymore. Let's remove this socket now.
-		 */
-		unlink(path);
-	}
-	close(sock);
-}
-
-
-/********************************
- * 2) listener-oriented functions
- ********************************/
-
-
-/* This function creates the UNIX socket associated to the listener. It changes
- * the state from ASSIGNED to LISTEN. The socket is NOT enabled for polling.
- * The return value is composed from ERR_NONE, ERR_RETRYABLE and ERR_FATAL.
- */
-static int uxst_bind_listener(struct listener *listener)
-{
-	int fd;
-
-	if (listener->state != LI_ASSIGNED)
-		return ERR_NONE; /* already bound */
-
-	fd = create_uxst_socket(((struct sockaddr_un *)&listener->addr)->sun_path,
-				listener->perm.ux.uid,
-				listener->perm.ux.gid,
-				listener->perm.ux.mode);
-	if (fd == -1)
-		return ERR_FATAL;
-
-	/* the socket is now listening */
-	listener->fd = fd;
-	listener->state = LI_LISTEN;
-
-	/* the function for the accept() event */
-	fd_insert(fd);
-	fdtab[fd].cb[DIR_RD].f = listener->accept;
-	fdtab[fd].cb[DIR_WR].f = NULL; /* never called */
-	fdtab[fd].cb[DIR_RD].b = fdtab[fd].cb[DIR_WR].b = NULL;
-	fdtab[fd].owner = listener; /* reference the listener instead of a task */
-	fdtab[fd].state = FD_STLISTEN;
-	fdinfo[fd].peeraddr = NULL;
-	fdinfo[fd].peerlen = 0;
-	return ERR_NONE;
-}
-
-/* This function closes the UNIX sockets for the specified listener.
- * The listener enters the LI_ASSIGNED state. It always returns ERR_NONE.
- */
-static int uxst_unbind_listener(struct listener *listener)
-{
-	if (listener->state == LI_READY)
-		EV_FD_CLR(listener->fd, DIR_RD);
-
-	if (listener->state >= LI_LISTEN) {
-		fd_delete(listener->fd);
-		listener->state = LI_ASSIGNED;
-		destroy_uxst_socket(((struct sockaddr_un *)&listener->addr)->sun_path);
-	}
-	return ERR_NONE;
-}
-
-/* Add a listener to the list of unix stream listeners. The listener's state
- * is automatically updated from LI_INIT to LI_ASSIGNED. The number of
- * listeners is updated. This is the function to use to add a new listener.
- */
-void uxst_add_listener(struct listener *listener)
-{
-	if (listener->state != LI_INIT)
-		return;
-	listener->state = LI_ASSIGNED;
-	listener->proto = &proto_unix;
-	LIST_ADDQ(&proto_unix.listeners, &listener->proto_list);
-	proto_unix.nb_listeners++;
-}
-
-/********************************
- * 3) protocol-oriented functions
- ********************************/
-
-
-/* This function creates all UNIX sockets bound to the protocol entry <proto>.
- * It is intended to be used as the protocol's bind_all() function.
- * The sockets will be registered but not added to any fd_set, in order not to
- * loose them across the fork(). A call to uxst_enable_listeners() is needed
- * to complete initialization.
- *
- * The return value is composed from ERR_NONE, ERR_RETRYABLE and ERR_FATAL.
- */
-static int uxst_bind_listeners(struct protocol *proto)
-{
-	struct listener *listener;
-	int err = ERR_NONE;
-
-	list_for_each_entry(listener, &proto->listeners, proto_list) {
-		err |= uxst_bind_listener(listener);
-		if (err != ERR_NONE)
-			continue;
-	}
-	return err;
-}
-
-
-/* This function stops all listening UNIX sockets bound to the protocol
- * <proto>. It does not detaches them from the protocol.
- * It always returns ERR_NONE.
- */
-static int uxst_unbind_listeners(struct protocol *proto)
-{
-	struct listener *listener;
-
-	list_for_each_entry(listener, &proto->listeners, proto_list)
-		uxst_unbind_listener(listener);
-	return ERR_NONE;
-}
-
-
-/********************************
- * 4) high-level functions
- ********************************/
-
-
-/*
- * This function is called on a read event from a listen socket, corresponding
- * to an accept. It tries to accept as many connections as possible.
- * It returns 0. Since we use UNIX sockets on the local system for monitoring
- * purposes and other related things, we do not need to output as many messages
- * as with TCP which can fall under attack.
- */
-int uxst_event_accept(int fd) {
-	struct listener *l = fdtab[fd].owner;
-	struct session *s;
-	struct task *t;
-	int cfd;
-	int max_accept;
-
-	if (global.nbproc > 1)
-		max_accept = 8; /* let other processes catch some connections too */
-	else
-		max_accept = -1;
-
-	while (max_accept--) {
-		struct sockaddr_storage addr;
-		socklen_t laddr = sizeof(addr);
-
-		if ((cfd = accept(fd, (struct sockaddr *)&addr, &laddr)) == -1) {
-			switch (errno) {
-			case EAGAIN:
-			case EINTR:
-			case ECONNABORTED:
-				return 0;	    /* nothing more to accept */
-			case ENFILE:
-				/* Process reached system FD limit. Check system tunables. */
-				return 0;
-			case EMFILE:
-				/* Process reached process FD limit. Check 'ulimit-n'. */
-				return 0;
-			case ENOBUFS:
-			case ENOMEM:
-				/* Process reached system memory limit. Check system tunables. */
-				return 0;
-			default:
-				return 0;
-			}
-		}
-
-		if (l->nbconn >= l->maxconn || actconn >= global.maxconn) {
-			/* too many connections, we shoot this one and return.
-			 * FIXME: it would be better to simply switch the listener's
-			 * state to LI_FULL and disable the FD. We could re-enable
-			 * it upon fd_delete(), but this requires all protocols to
-			 * be switched.
-			 */
-			goto out_close;
-		}
-
-		if ((s = pool_alloc2(pool2_session)) == NULL) {
-			Alert("out of memory in uxst_event_accept().\n");
-			goto out_close;
-		}
-
-		LIST_ADDQ(&sessions, &s->list);
-		LIST_INIT(&s->back_refs);
-
-		s->flags = 0;
-		s->term_trace = 0;
-
-		if ((t = task_new()) == NULL) {
-			Alert("out of memory in uxst_event_accept().\n");
-			goto out_free_session;
-		}
-
-		s->cli_addr = addr;
-
-		/* FIXME: should be checked earlier */
-		if (cfd >= global.maxsock) {
-			Alert("accept(): not enough free sockets. Raise -n argument. Giving up.\n");
-			goto out_free_task;
-		}
-
-		if (fcntl(cfd, F_SETFL, O_NONBLOCK) == -1) {
-			Alert("accept(): cannot set the socket in non blocking mode. Giving up.\n");
-			goto out_free_task;
-		}
-
-		t->process = l->handler;
-		t->context = s;
-		t->nice = l->nice;
-
-		s->task = t;
-		s->listener = l;
-		s->fe = s->be = l->private;
-
-		s->req = s->rep = NULL; /* will be allocated later */
-
-		s->si[0].state = s->si[0].prev_state = SI_ST_EST;
-		s->si[0].err_type = SI_ET_NONE;
-		s->si[0].err_loc = NULL;
-		s->si[0].owner = t;
-		s->si[0].update = stream_sock_data_finish;
-		s->si[0].shutr = stream_sock_shutr;
-		s->si[0].shutw = stream_sock_shutw;
-		s->si[0].chk_rcv = stream_sock_chk_rcv;
-		s->si[0].chk_snd = stream_sock_chk_snd;
-		s->si[0].connect = NULL;
-		s->si[0].iohandler = NULL;
-		s->si[0].fd = cfd;
-		s->si[0].flags = SI_FL_NONE;
-		if (s->fe->options2 & PR_O2_INDEPSTR)
-			s->si[0].flags |= SI_FL_INDEP_STR;
-		s->si[0].exp = TICK_ETERNITY;
-
-		s->si[1].state = s->si[1].prev_state = SI_ST_INI;
-		s->si[1].err_type = SI_ET_NONE;
-		s->si[1].err_loc = NULL;
-		s->si[1].owner = t;
-		s->si[1].exp = TICK_ETERNITY;
-		s->si[1].fd = -1; /* just to help with debugging */
-		s->si[1].flags = SI_FL_NONE;
-		if (s->be->options2 & PR_O2_INDEPSTR)
-			s->si[1].flags |= SI_FL_INDEP_STR;
-
-		stream_int_register_handler(&s->si[1], stats_io_handler);
-		s->si[1].private = s;
-		s->si[1].st1 = 0;
-		s->si[1].st0 = STAT_CLI_INIT;
-
-		s->srv = s->prev_srv = s->srv_conn = NULL;
-		s->pend_pos = NULL;
-
-		s->store_count = 0;
-
-		memset(&s->logs, 0, sizeof(s->logs));
-		memset(&s->txn, 0, sizeof(s->txn));
-
-		s->logs.accept_date = date; /* user-visible date for logging */
-		s->logs.tv_accept = now;  /* corrected date for internal use */
-
-		s->data_state = DATA_ST_INIT;
-		s->data_source = DATA_SRC_NONE;
-		s->uniq_id = totalconn;
-
-		if ((s->req = pool_alloc2(pool2_buffer)) == NULL)
-			goto out_free_task;
-
-		s->req->size = global.tune.bufsize;
-		buffer_init(s->req);
-		s->req->prod = &s->si[0];
-		s->req->cons = &s->si[1];
-		s->si[0].ib = s->si[1].ob = s->req;
-		s->req->flags |= BF_READ_ATTACHED; /* the producer is already connected */
-		s->req->flags |= BF_READ_DONTWAIT; /* we plan to read small requests */
-
-		s->req->analysers = l->analysers;
-
-		s->req->wto = TICK_ETERNITY;
-		s->req->cto = TICK_ETERNITY;
-		s->req->rto = TICK_ETERNITY;
-
-		if ((s->rep = pool_alloc2(pool2_buffer)) == NULL)
-			goto out_free_req;
-
-		s->rep->size = global.tune.bufsize;
-		buffer_init(s->rep);
-
-		s->rep->prod = &s->si[1];
-		s->rep->cons = &s->si[0];
-		s->si[0].ob = s->si[1].ib = s->rep;
-		s->rep->analysers = 0;
-
-		s->rep->rto = TICK_ETERNITY;
-		s->rep->cto = TICK_ETERNITY;
-		s->rep->wto = TICK_ETERNITY;
-
-		s->req->rex = TICK_ETERNITY;
-		s->req->wex = TICK_ETERNITY;
-		s->req->analyse_exp = TICK_ETERNITY;
-		s->rep->rex = TICK_ETERNITY;
-		s->rep->wex = TICK_ETERNITY;
-		s->rep->analyse_exp = TICK_ETERNITY;
-
-		t->expire = TICK_ETERNITY;
-
-		if (l->timeout) {
-			s->req->rto = *l->timeout;
-			s->rep->wto = *l->timeout;
-		}
-
-		fd_insert(cfd);
-		fdtab[cfd].owner = &s->si[0];
-		fdtab[cfd].state = FD_STREADY;
-		fdtab[cfd].cb[DIR_RD].f = l->proto->read;
-		fdtab[cfd].cb[DIR_RD].b = s->req;
-		fdtab[cfd].cb[DIR_WR].f = l->proto->write;
-		fdtab[cfd].cb[DIR_WR].b = s->rep;
-		fdinfo[cfd].peeraddr = (struct sockaddr *)&s->cli_addr;
-		fdinfo[cfd].peerlen = sizeof(s->cli_addr);
-
-		EV_FD_SET(cfd, DIR_RD);
-
-		task_wakeup(t, TASK_WOKEN_INIT);
-
-		l->nbconn++; /* warning! right now, it's up to the handler to decrease this */
-		if (l->nbconn >= l->maxconn) {
-			EV_FD_CLR(l->fd, DIR_RD);
-			l->state = LI_FULL;
-		}
-		actconn++;
-		totalconn++;
-	}
-	return 0;
-
- out_free_req:
-	pool_free2(pool2_buffer, s->req);
- out_free_task:
-	task_free(t);
- out_free_session:
-	LIST_DEL(&s->list);
-	pool_free2(pool2_session, s);
- out_close:
-	close(cfd);
-	return 0;
-}
-
-__attribute__((constructor))
-static void __uxst_protocol_init(void)
-{
-	protocol_register(&proto_unix);
-}
-
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/protocols.c b/deps/haproxy-1.4.21/src/protocols.c
deleted file mode 100644
index 735c384..0000000
--- a/deps/haproxy-1.4.21/src/protocols.c
+++ /dev/null
@@ -1,210 +0,0 @@
-/*
- * Protocol registration functions.
- *
- * Copyright 2000-2008 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <stdio.h>
-#include <string.h>
-
-#include <common/config.h>
-#include <common/errors.h>
-#include <common/mini-clist.h>
-#include <common/standard.h>
-
-#include <proto/fd.h>
-
-/* List head of all registered protocols */
-static struct list protocols = LIST_HEAD_INIT(protocols);
-
-/* This function adds the specified listener's file descriptor to the polling
- * lists if it is in the LI_LISTEN state. The listener enters LI_READY or
- * LI_FULL state depending on its number of connections.
- */
-void enable_listener(struct listener *listener)
-{
-	if (listener->state == LI_LISTEN) {
-		if (listener->nbconn < listener->maxconn) {
-			EV_FD_SET(listener->fd, DIR_RD);
-			listener->state = LI_READY;
-		} else {
-			listener->state = LI_FULL;
-		}
-	}
-}
-
-/* This function removes the specified listener's file descriptor from the
- * polling lists if it is in the LI_READY or in the LI_FULL state. The listener
- * enters LI_LISTEN.
- */
-void disable_listener(struct listener *listener)
-{
-	if (listener->state < LI_READY)
-		return;
-	if (listener->state == LI_READY)
-		EV_FD_CLR(listener->fd, DIR_RD);
-	listener->state = LI_LISTEN;
-}
-
-/* This function adds all of the protocol's listener's file descriptors to the
- * polling lists when they are in the LI_LISTEN state. It is intended to be
- * used as a protocol's generic enable_all() primitive, for use after the
- * fork(). It puts the listeners into LI_READY or LI_FULL states depending on
- * their number of connections. It always returns ERR_NONE.
- */
-int enable_all_listeners(struct protocol *proto)
-{
-	struct listener *listener;
-
-	list_for_each_entry(listener, &proto->listeners, proto_list)
-		enable_listener(listener);
-	return ERR_NONE;
-}
-
-/* This function removes all of the protocol's listener's file descriptors from
- * the polling lists when they are in the LI_READY or LI_FULL states. It is
- * intended to be used as a protocol's generic disable_all() primitive. It puts
- * the listeners into LI_LISTEN, and always returns ERR_NONE.
- */
-int disable_all_listeners(struct protocol *proto)
-{
-	struct listener *listener;
-
-	list_for_each_entry(listener, &proto->listeners, proto_list)
-		disable_listener(listener);
-	return ERR_NONE;
-}
-
-/* This function closes the listening socket for the specified listener,
- * provided that it's already in a listening state. The listener enters the
- * LI_ASSIGNED state. It always returns ERR_NONE. This function is intended
- * to be used as a generic function for standard protocols.
- */
-int unbind_listener(struct listener *listener)
-{
-	if (listener->state == LI_READY)
-		EV_FD_CLR(listener->fd, DIR_RD);
-
-	if (listener->state >= LI_LISTEN) {
-		fd_delete(listener->fd);
-		listener->state = LI_ASSIGNED;
-	}
-	return ERR_NONE;
-}
-
-/* This function closes all listening sockets bound to the protocol <proto>,
- * and the listeners end in LI_ASSIGNED state if they were higher. It does not
- * detach them from the protocol. It always returns ERR_NONE.
- */
-int unbind_all_listeners(struct protocol *proto)
-{
-	struct listener *listener;
-
-	list_for_each_entry(listener, &proto->listeners, proto_list)
-		unbind_listener(listener);
-	return ERR_NONE;
-}
-
-/* Delete a listener from its protocol's list of listeners. The listener's
- * state is automatically updated from LI_ASSIGNED to LI_INIT. The protocol's
- * number of listeners is updated. Note that the listener must have previously
- * been unbound. This is the generic function to use to remove a listener.
- */
-void delete_listener(struct listener *listener)
-{
-	if (listener->state != LI_ASSIGNED)
-		return;
-	listener->state = LI_INIT;
-	LIST_DEL(&listener->proto_list);
-	listener->proto->nb_listeners--;
-}
-
-/* Registers the protocol <proto> */
-void protocol_register(struct protocol *proto)
-{
-	LIST_ADDQ(&protocols, &proto->list);
-}
-
-/* Unregisters the protocol <proto>. Note that all listeners must have
- * previously been unbound.
- */
-void protocol_unregister(struct protocol *proto)
-{
-	LIST_DEL(&proto->list);
-	LIST_INIT(&proto->list);
-}
-
-/* binds all listeners of all registered protocols. Returns a composition
- * of ERR_NONE, ERR_RETRYABLE, ERR_FATAL.
- */
-int protocol_bind_all(void)
-{
-	struct protocol *proto;
-	int err;
-
-	err = 0;
-	list_for_each_entry(proto, &protocols, list) {
-		if (proto->bind_all)
-			err |= proto->bind_all(proto);
-	}
-	return err;
-}
-
-/* unbinds all listeners of all registered protocols. They are also closed.
- * This must be performed before calling exit() in order to get a chance to
- * remove file-system based sockets and pipes.
- * Returns a composition of ERR_NONE, ERR_RETRYABLE, ERR_FATAL.
- */
-int protocol_unbind_all(void)
-{
-	struct protocol *proto;
-	int err;
-
-	err = 0;
-	list_for_each_entry(proto, &protocols, list) {
-		if (proto->unbind_all)
-			err |= proto->unbind_all(proto);
-	}
-	return err;
-}
-
-/* enables all listeners of all registered protocols. This is intended to be
- * used after a fork() to enable reading on all file descriptors. Returns a
- * composition of ERR_NONE, ERR_RETRYABLE, ERR_FATAL.
- */
-int protocol_enable_all(void)
-{
-	struct protocol *proto;
-	int err;
-
-	err = 0;
-	list_for_each_entry(proto, &protocols, list) {
-		if (proto->enable_all)
-			err |= proto->enable_all(proto);
-	}
-	return err;
-}
-
-/* disables all listeners of all registered protocols. This may be used before
- * a fork() to avoid duplicating poll lists. Returns a composition of ERR_NONE,
- * ERR_RETRYABLE, ERR_FATAL.
- */
-int protocol_disable_all(void)
-{
-	struct protocol *proto;
-	int err;
-
-	err = 0;
-	list_for_each_entry(proto, &protocols, list) {
-		if (proto->disable_all)
-			err |= proto->disable_all(proto);
-	}
-	return err;
-}
-
diff --git a/deps/haproxy-1.4.21/src/proxy.c b/deps/haproxy-1.4.21/src/proxy.c
deleted file mode 100644
index 7add630..0000000
--- a/deps/haproxy-1.4.21/src/proxy.c
+++ /dev/null
@@ -1,794 +0,0 @@
-/*
- * Proxy variables and functions.
- *
- * Copyright 2000-2009 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <fcntl.h>
-#include <unistd.h>
-#include <string.h>
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <sys/stat.h>
-
-#include <common/defaults.h>
-#include <common/cfgparse.h>
-#include <common/compat.h>
-#include <common/config.h>
-#include <common/errors.h>
-#include <common/memory.h>
-#include <common/time.h>
-
-#include <types/global.h>
-
-#include <proto/client.h>
-#include <proto/backend.h>
-#include <proto/fd.h>
-#include <proto/hdr_idx.h>
-#include <proto/log.h>
-#include <proto/protocols.h>
-#include <proto/proto_tcp.h>
-#include <proto/proto_http.h>
-#include <proto/proxy.h>
-
-
-int listeners;	/* # of proxy listeners, set by cfgparse, unset by maintain_proxies */
-struct proxy *proxy  = NULL;	/* list of all existing proxies */
-struct eb_root used_proxy_id = EB_ROOT;	/* list of proxy IDs in use */
-unsigned int error_snapshot_id = 0;     /* global ID assigned to each error then incremented */
-
-/*
- * This function returns a string containing a name describing capabilities to
- * report comprehensible error messages. Specifically, it will return the words
- * "frontend", "backend", "ruleset" when appropriate, or "proxy" for all other
- * cases including the proxies declared in "listen" mode.
- */
-const char *proxy_cap_str(int cap)
-{
-	if ((cap & PR_CAP_LISTEN) != PR_CAP_LISTEN) {
-		if (cap & PR_CAP_FE)
-			return "frontend";
-		else if (cap & PR_CAP_BE)
-			return "backend";
-		else if (cap & PR_CAP_RS)
-			return "ruleset";
-	}
-	return "proxy";
-}
-
-/*
- * This function returns a string containing the mode of the proxy in a format
- * suitable for error messages.
- */
-const char *proxy_mode_str(int mode) {
-
-	if (mode == PR_MODE_TCP)
-		return "tcp";
-	else if (mode == PR_MODE_HTTP)
-		return "http";
-	else if (mode == PR_MODE_HEALTH)
-		return "health";
-	else
-		return "unknown";
-}
-
-/*
- * This function scans the list of backends and servers to retrieve the first
- * backend and the first server with the given names, and sets them in both
- * parameters. It returns zero if either is not found, or non-zero and sets
- * the ones it did not found to NULL. If a NULL pointer is passed for the
- * backend, only the pointer to the server will be updated.
- */
-int get_backend_server(const char *bk_name, const char *sv_name,
-		       struct proxy **bk, struct server **sv)
-{
-	struct proxy *p;
-	struct server *s;
-	int pid, sid;
-
-	*sv = NULL;
-
-	pid = 0;
-	if (*bk_name == '#')
-		pid = atoi(bk_name + 1);
-	sid = 0;
-	if (*sv_name == '#')
-		sid = atoi(sv_name + 1);
-
-	for (p = proxy; p; p = p->next)
-		if ((p->cap & PR_CAP_BE) &&
-		    ((pid && p->uuid == pid) ||
-		     (!pid && strcmp(p->id, bk_name) == 0)))
-			break;
-	if (bk)
-		*bk = p;
-	if (!p)
-		return 0;
-
-	for (s = p->srv; s; s = s->next)
-		if ((sid && s->puid == sid) ||
-		    (!sid && strcmp(s->id, sv_name) == 0))
-			break;
-	*sv = s;
-	if (!s)
-		return 0;
-	return 1;
-}
-
-/* This function parses a "timeout" statement in a proxy section. It returns
- * -1 if there is any error, 1 for a warning, otherwise zero. If it does not
- * return zero, it may write an error message into the <err> buffer, for at
- * most <errlen> bytes, trailing zero included. The trailing '\n' must not
- * be written. The function must be called with <args> pointing to the first
- * command line word, with <proxy> pointing to the proxy being parsed, and
- * <defpx> to the default proxy or NULL. As a special case for compatibility
- * with older configs, it also accepts "{cli|srv|con}timeout" in args[0].
- */
-static int proxy_parse_timeout(char **args, int section, struct proxy *proxy,
-			       struct proxy *defpx, char *err, int errlen)
-{
-	unsigned timeout;
-	int retval, cap;
-	const char *res, *name;
-	int *tv = NULL;
-	int *td = NULL;
-
-	retval = 0;
-
-	/* simply skip "timeout" but remain compatible with old form */
-	if (strcmp(args[0], "timeout") == 0)
-		args++;
-
-	name = args[0];
-	if (!strcmp(args[0], "client") || !strcmp(args[0], "clitimeout")) {
-		name = "client";
-		tv = &proxy->timeout.client;
-		td = &defpx->timeout.client;
-		cap = PR_CAP_FE;
-	} else if (!strcmp(args[0], "tarpit")) {
-		tv = &proxy->timeout.tarpit;
-		td = &defpx->timeout.tarpit;
-		cap = PR_CAP_FE | PR_CAP_BE;
-	} else if (!strcmp(args[0], "http-keep-alive")) {
-		tv = &proxy->timeout.httpka;
-		td = &defpx->timeout.httpka;
-		cap = PR_CAP_FE | PR_CAP_BE;
-	} else if (!strcmp(args[0], "http-request")) {
-		tv = &proxy->timeout.httpreq;
-		td = &defpx->timeout.httpreq;
-		cap = PR_CAP_FE | PR_CAP_BE;
-	} else if (!strcmp(args[0], "server") || !strcmp(args[0], "srvtimeout")) {
-		name = "server";
-		tv = &proxy->timeout.server;
-		td = &defpx->timeout.server;
-		cap = PR_CAP_BE;
-	} else if (!strcmp(args[0], "connect") || !strcmp(args[0], "contimeout")) {
-		name = "connect";
-		tv = &proxy->timeout.connect;
-		td = &defpx->timeout.connect;
-		cap = PR_CAP_BE;
-	} else if (!strcmp(args[0], "check")) {
-		tv = &proxy->timeout.check;
-		td = &defpx->timeout.check;
-		cap = PR_CAP_BE;
-	} else if (!strcmp(args[0], "queue")) {
-		tv = &proxy->timeout.queue;
-		td = &defpx->timeout.queue;
-		cap = PR_CAP_BE;
-	} else {
-		snprintf(err, errlen,
-			 "timeout '%s': must be 'client', 'server', 'connect', 'check', "
-			 "'queue', 'http-keep-alive', 'http-request' or 'tarpit'",
-			 args[0]);
-		return -1;
-	}
-
-	if (*args[1] == 0) {
-		snprintf(err, errlen, "%s timeout expects an integer value (in milliseconds)", name);
-		return -1;
-	}
-
-	res = parse_time_err(args[1], &timeout, TIME_UNIT_MS);
-	if (res) {
-		snprintf(err, errlen, "unexpected character '%c' in %s timeout", *res, name);
-		return -1;
-	}
-
-	if (!(proxy->cap & cap)) {
-		snprintf(err, errlen, "%s timeout will be ignored because %s '%s' has no %s capability",
-			 name, proxy_type_str(proxy), proxy->id,
-			 (cap & PR_CAP_BE) ? "backend" : "frontend");
-		retval = 1;
-	}
-	else if (defpx && *tv != *td) {
-		snprintf(err, errlen, "overwriting %s timeout which was already specified", name);
-		retval = 1;
-	}
-
-	*tv = MS_TO_TICKS(timeout);
-	return retval;
-}
-
-/* This function parses a "rate-limit" statement in a proxy section. It returns
- * -1 if there is any error, 1 for a warning, otherwise zero. If it does not
- * return zero, it may write an error message into the <err> buffer, for at
- * most <errlen> bytes, trailing zero included. The trailing '\n' must not
- * be written. The function must be called with <args> pointing to the first
- * command line word, with <proxy> pointing to the proxy being parsed, and
- * <defpx> to the default proxy or NULL.
- */
-static int proxy_parse_rate_limit(char **args, int section, struct proxy *proxy,
-			          struct proxy *defpx, char *err, int errlen)
-{
-	int retval, cap;
-	char *res, *name;
-	unsigned int *tv = NULL;
-	unsigned int *td = NULL;
-	unsigned int val;
-
-	retval = 0;
-
-	/* simply skip "rate-limit" */
-	if (strcmp(args[0], "rate-limit") == 0)
-		args++;
-
-	name = args[0];
-	if (!strcmp(args[0], "sessions")) {
-		name = "sessions";
-		tv = &proxy->fe_sps_lim;
-		td = &defpx->fe_sps_lim;
-		cap = PR_CAP_FE;
-	} else {
-		snprintf(err, errlen,
-			 "%s '%s': must be 'sessions'",
-			 "rate-limit", args[0]);
-		return -1;
-	}
-
-	if (*args[1] == 0) {
-		snprintf(err, errlen, "%s %s expects expects an integer value (in sessions/second)", "rate-limit", name);
-		return -1;
-	}
-
-	val = strtoul(args[1], &res, 0);
-	if (*res) {
-		snprintf(err, errlen, "%s %s: unexpected character '%c' in integer value '%s'", "rate-limit", name, *res, args[1]);
-		return -1;
-	}
-
-	if (!(proxy->cap & cap)) {
-		snprintf(err, errlen, "%s %s will be ignored because %s '%s' has no %s capability",
-			 "rate-limit", name, proxy_type_str(proxy), proxy->id,
-			 (cap & PR_CAP_BE) ? "backend" : "frontend");
-		retval = 1;
-	}
-	else if (defpx && *tv != *td) {
-		snprintf(err, errlen, "overwriting %s %s which was already specified", "rate-limit", name);
-		retval = 1;
-	}
-
-	*tv = val;
-	return retval;
-}
-
-/*
- * This function finds a proxy with matching name, mode and with satisfying
- * capabilities. It also checks if there are more matching proxies with
- * requested name as this often leads into unexpected situations.
- */
-
-struct proxy *findproxy_mode(const char *name, int mode, int cap) {
-
-	struct proxy *curproxy, *target = NULL;
-
-	for (curproxy = proxy; curproxy; curproxy = curproxy->next) {
-		if ((curproxy->cap & cap)!=cap || strcmp(curproxy->id, name))
-			continue;
-
-		if (curproxy->mode != mode &&
-		    !(curproxy->mode == PR_MODE_HTTP && mode == PR_MODE_TCP)) {
-			Alert("Unable to use proxy '%s' with wrong mode, required: %s, has: %s.\n", 
-				name, proxy_mode_str(mode), proxy_mode_str(curproxy->mode));
-			Alert("You may want to use 'mode %s'.\n", proxy_mode_str(mode));
-			return NULL;
-		}
-
-		if (!target) {
-			target = curproxy;
-			continue;
-		}
-
-		Alert("Refusing to use duplicated proxy '%s' with overlapping capabilities: %s/%s!\n",
-			name, proxy_type_str(curproxy), proxy_type_str(target));
-
-		return NULL;
-	}
-
-	return target;
-}
-
-/* Returns a pointer to the proxy matching either name <name>, or id <name> if
- * <name> begins with a '#'. NULL is returned if no match is found, as well as
- * if multiple matches are found (eg: too large capabilities mask).
- */
-struct proxy *findproxy(const char *name, int cap) {
-
-	struct proxy *curproxy, *target = NULL;
-	int pid = 0;
-
-	if (*name == '#')
-		pid = atoi(name + 1);
-
-	for (curproxy = proxy; curproxy; curproxy = curproxy->next) {
-		if ((curproxy->cap & cap) != cap ||
-		    (pid && curproxy->uuid != pid) ||
-		    (!pid && strcmp(curproxy->id, name)))
-			continue;
-
-		if (!target) {
-			target = curproxy;
-			continue;
-		}
-
-		return NULL;
-	}
-
-	return target;
-}
-
-/*
- * This function finds a server with matching name within selected proxy.
- * It also checks if there are more matching servers with
- * requested name as this often leads into unexpected situations.
- */
-
-struct server *findserver(const struct proxy *px, const char *name) {
-
-	struct server *cursrv, *target = NULL;
-
-	if (!px)
-		return NULL;
-
-	for (cursrv = px->srv; cursrv; cursrv = cursrv->next) {
-		if (strcmp(cursrv->id, name))
-			continue;
-
-		if (!target) {
-			target = cursrv;
-			continue;
-		}
-
-		Alert("Refusing to use duplicated server '%s' found in proxy: %s!\n",
-			name, px->id);
-
-		return NULL;
-	}
-
-	return target;
-}
-
-/* This function checks that the designated proxy has no http directives
- * enabled. It will output a warning if there are, and will fix some of them.
- * It returns the number of fatal errors encountered. This should be called
- * at the end of the configuration parsing if the proxy is not in http mode.
- * The <file> argument is used to construct the error message.
- */
-int proxy_cfg_ensure_no_http(struct proxy *curproxy)
-{
-	if (curproxy->cookie_name != NULL) {
-		Warning("config : cookie will be ignored for %s '%s' (needs 'mode http').\n",
-			proxy_type_str(curproxy), curproxy->id);
-	}
-	if (curproxy->rsp_exp != NULL) {
-		Warning("config : server regular expressions will be ignored for %s '%s' (needs 'mode http').\n",
-			proxy_type_str(curproxy), curproxy->id);
-	}
-	if (curproxy->req_exp != NULL) {
-		Warning("config : client regular expressions will be ignored for %s '%s' (needs 'mode http').\n",
-			proxy_type_str(curproxy), curproxy->id);
-	}
-	if (curproxy->monitor_uri != NULL) {
-		Warning("config : monitor-uri will be ignored for %s '%s' (needs 'mode http').\n",
-			proxy_type_str(curproxy), curproxy->id);
-	}
-	if (curproxy->lbprm.algo & BE_LB_NEED_HTTP) {
-		curproxy->lbprm.algo &= ~BE_LB_ALGO;
-		curproxy->lbprm.algo |= BE_LB_ALGO_RR;
-		Warning("config : Layer 7 hash not possible for %s '%s' (needs 'mode http'). Falling back to round robin.\n",
-			proxy_type_str(curproxy), curproxy->id);
-	}
-	if (curproxy->to_log & (LW_REQ | LW_RESP)) {
-		curproxy->to_log &= ~(LW_REQ | LW_RESP);
-		Warning("config : 'option httplog' not usable with %s '%s' (needs 'mode http'). Falling back to 'option tcplog'.\n",
-			proxy_type_str(curproxy), curproxy->id);
-	}
-	return 0;
-}
-
-/*
- * This function creates all proxy sockets. It should be done very early,
- * typically before privileges are dropped. The sockets will be registered
- * but not added to any fd_set, in order not to loose them across the fork().
- * The proxies also start in IDLE state, meaning that it will be
- * maintain_proxies that will finally complete their loading.
- *
- * Its return value is composed from ERR_NONE, ERR_RETRYABLE and ERR_FATAL.
- * Retryable errors will only be printed if <verbose> is not zero.
- */
-int start_proxies(int verbose)
-{
-	struct proxy *curproxy;
-	struct listener *listener;
-	int lerr, err = ERR_NONE;
-	int pxerr;
-	char msg[100];
-
-	for (curproxy = proxy; curproxy != NULL; curproxy = curproxy->next) {
-		if (curproxy->state != PR_STNEW)
-			continue; /* already initialized */
-
-		pxerr = 0;
-		for (listener = curproxy->listen; listener != NULL; listener = listener->next) {
-			if (listener->state != LI_ASSIGNED)
-				continue; /* already started */
-
-			lerr = tcp_bind_listener(listener, msg, sizeof(msg));
-
-			/* errors are reported if <verbose> is set or if they are fatal */
-			if (verbose || (lerr & (ERR_FATAL | ERR_ABORT))) {
-				if (lerr & ERR_ALERT)
-					Alert("Starting %s %s: %s\n",
-					      proxy_type_str(curproxy), curproxy->id, msg);
-				else if (lerr & ERR_WARN)
-					Warning("Starting %s %s: %s\n",
-						proxy_type_str(curproxy), curproxy->id, msg);
-			}
-
-			err |= lerr;
-			if (lerr & (ERR_ABORT | ERR_FATAL)) {
-				pxerr |= 1;
-				break;
-			}
-			else if (lerr & ERR_CODE) {
-				pxerr |= 1;
-				continue;
-			}
-		}
-
-		if (!pxerr) {
-			curproxy->state = PR_STIDLE;
-			send_log(curproxy, LOG_NOTICE, "Proxy %s started.\n", curproxy->id);
-		}
-
-		if (err & ERR_ABORT)
-			break;
-	}
-
-	return err;
-}
-
-
-/*
- * this function enables proxies when there are enough free sessions,
- * or stops them when the table is full. It is designed to be called from the
- * select_loop(). It adjusts the date of next expiration event during stop
- * time if appropriate.
- */
-void maintain_proxies(int *next)
-{
-	struct proxy *p;
-	struct listener *l;
-	unsigned int wait;
-
-	p = proxy;
-
-	/* if there are enough free sessions, we'll activate proxies */
-	if (actconn < global.maxconn) {
-		for (; p; p = p->next) {
-			/* check the various reasons we may find to block the frontend */
-			if (p->feconn >= p->maxconn)
-				goto do_block;
-
-			if (p->fe_sps_lim &&
-			    (wait = next_event_delay(&p->fe_sess_per_sec, p->fe_sps_lim, 1))) {
-				/* we're blocking because a limit was reached on the number of
-				 * requests/s on the frontend. We want to re-check ASAP, which
-				 * means in 1 ms before estimated expiration date, because the
-				 * timer will have settled down. Note that we may already be in
-				 * IDLE state here.
-				 */
-				*next = tick_first(*next, tick_add(now_ms, wait));
-				goto do_block;
-			}
-
-			/* OK we have no reason to block, so let's unblock if we were blocking */
-			if (p->state == PR_STIDLE) {
-				for (l = p->listen; l != NULL; l = l->next)
-					enable_listener(l);
-				p->state = PR_STRUN;
-			}
-			continue;
-
-		do_block:
-			if (p->state == PR_STRUN) {
-				for (l = p->listen; l != NULL; l = l->next)
-					disable_listener(l);
-				p->state = PR_STIDLE;
-			}
-		}
-	}
-	else {  /* block all proxies */
-		while (p) {
-			if (p->state == PR_STRUN) {
-				for (l = p->listen; l != NULL; l = l->next)
-					disable_listener(l);
-				p->state = PR_STIDLE;
-			}
-			p = p->next;
-		}
-	}
-
-	if (stopping) {
-		p = proxy;
-		while (p) {
-			if (p->state != PR_STSTOPPED) {
-				int t;
-				t = tick_remain(now_ms, p->stop_time);
-				if (t == 0) {
-					Warning("Proxy %s stopped (FE: %lld conns, BE: %lld conns).\n",
-						p->id, p->counters.cum_feconn, p->counters.cum_beconn);
-					send_log(p, LOG_WARNING, "Proxy %s stopped (FE: %lld conns, BE: %lld conns).\n",
-						 p->id, p->counters.cum_feconn, p->counters.cum_beconn);
-					stop_proxy(p);
-					/* try to free more memory */
-					pool_gc2();
-				}
-				else {
-					*next = tick_first(*next, p->stop_time);
-				}
-			}
-			p = p->next;
-		}
-	}
-	return;
-}
-
-
-/*
- * this function disables health-check servers so that the process will quickly be ignored
- * by load balancers. Note that if a proxy was already in the PAUSED state, then its grace
- * time will not be used since it would already not listen anymore to the socket.
- */
-void soft_stop(void)
-{
-	struct proxy *p;
-
-	stopping = 1;
-	p = proxy;
-	tv_update_date(0,1); /* else, the old time before select will be used */
-	while (p) {
-		if (p->state != PR_STSTOPPED) {
-			Warning("Stopping %s %s in %d ms.\n", proxy_cap_str(p->cap), p->id, p->grace);
-			send_log(p, LOG_WARNING, "Stopping %s %s in %d ms.\n", proxy_cap_str(p->cap), p->id, p->grace);
-			p->stop_time = tick_add(now_ms, p->grace);
-		}
-		p = p->next;
-	}
-}
-
-
-/*
- * Linux unbinds the listen socket after a SHUT_RD, and ignores SHUT_WR.
- * Solaris refuses either shutdown().
- * OpenBSD ignores SHUT_RD but closes upon SHUT_WR and refuses to rebind.
- * So a common validation path involves SHUT_WR && listen && SHUT_RD.
- * If disabling at least one listener returns an error, then the proxy
- * state is set to PR_STERROR because we don't know how to resume from this.
- */
-void pause_proxy(struct proxy *p)
-{
-	struct listener *l;
-	for (l = p->listen; l != NULL; l = l->next) {
-		if (shutdown(l->fd, SHUT_WR) == 0 &&
-		    listen(l->fd, p->backlog ? p->backlog : p->maxconn) == 0 &&
-		    shutdown(l->fd, SHUT_RD) == 0) {
-			EV_FD_CLR(l->fd, DIR_RD);
-			if (p->state != PR_STERROR)
-				p->state = PR_STPAUSED;
-		}
-		else
-			p->state = PR_STERROR;
-	}
-}
-
-
-/*
- * This function completely stops a proxy and releases its listeners. It has
- * to be called when going down in order to release the ports so that another
- * process may bind to them. It must also be called on disabled proxies at the
- * end of start-up. When all listeners are closed, the proxy is set to the
- * PR_STSTOPPED state.
- */
-void stop_proxy(struct proxy *p)
-{
-	struct listener *l;
-
-	for (l = p->listen; l != NULL; l = l->next) {
-		unbind_listener(l);
-		if (l->state >= LI_ASSIGNED) {
-			delete_listener(l);
-			listeners--;
-		}
-	}
-	p->state = PR_STSTOPPED;
-}
-
-/*
- * This function temporarily disables listening so that another new instance
- * can start listening. It is designed to be called upon reception of a
- * SIGTTOU, after which either a SIGUSR1 can be sent to completely stop
- * the proxy, or a SIGTTIN can be sent to listen again.
- */
-void pause_proxies(void)
-{
-	int err;
-	struct proxy *p;
-
-	err = 0;
-	p = proxy;
-	tv_update_date(0,1); /* else, the old time before select will be used */
-	while (p) {
-		if (p->cap & PR_CAP_FE &&
-		    p->state != PR_STERROR &&
-		    p->state != PR_STSTOPPED &&
-		    p->state != PR_STPAUSED) {
-			Warning("Pausing %s %s.\n", proxy_cap_str(p->cap), p->id);
-			send_log(p, LOG_WARNING, "Pausing %s %s.\n", proxy_cap_str(p->cap), p->id);
-			pause_proxy(p);
-			if (p->state != PR_STPAUSED) {
-				err |= 1;
-				Warning("%s %s failed to enter pause mode.\n", proxy_cap_str(p->cap), p->id);
-				send_log(p, LOG_WARNING, "%s %s failed to enter pause mode.\n", proxy_cap_str(p->cap), p->id);
-			}
-		}
-		p = p->next;
-	}
-	if (err) {
-		Warning("Some proxies refused to pause, performing soft stop now.\n");
-		send_log(p, LOG_WARNING, "Some proxies refused to pause, performing soft stop now.\n");
-		soft_stop();
-	}
-}
-
-
-/*
- * This function reactivates listening. This can be used after a call to
- * sig_pause(), for example when a new instance has failed starting up.
- * It is designed to be called upon reception of a SIGTTIN.
- */
-void listen_proxies(void)
-{
-	struct proxy *p;
-	struct listener *l;
-
-	p = proxy;
-	tv_update_date(0,1); /* else, the old time before select will be used */
-	while (p) {
-		if (p->state == PR_STPAUSED) {
-			Warning("Enabling %s %s.\n", proxy_cap_str(p->cap), p->id);
-			send_log(p, LOG_WARNING, "Enabling %s %s.\n", proxy_cap_str(p->cap), p->id);
-
-			for (l = p->listen; l != NULL; l = l->next) {
-				if (listen(l->fd, p->backlog ? p->backlog : p->maxconn) == 0) {
-					if (actconn < global.maxconn && p->feconn < p->maxconn) {
-						EV_FD_SET(l->fd, DIR_RD);
-						p->state = PR_STRUN;
-					}
-					else
-						p->state = PR_STIDLE;
-				} else {
-					int port;
-
-					if (l->addr.ss_family == AF_INET6)
-						port = ntohs(((struct sockaddr_in6 *)(&l->addr))->sin6_port);
-					else
-						port = ntohs(((struct sockaddr_in *)(&l->addr))->sin_port);
-
-					Warning("Port %d busy while trying to enable %s %s.\n",
-						port, proxy_cap_str(p->cap), p->id);
-					send_log(p, LOG_WARNING, "Port %d busy while trying to enable %s %s.\n",
-						 port, proxy_cap_str(p->cap), p->id);
-					/* Another port might have been enabled. Let's stop everything. */
-					pause_proxy(p);
-					break;
-				}
-			}
-		}
-		p = p->next;
-	}
-}
-
-/* Set current session's backend to <be>. Nothing is done if the
- * session already had a backend assigned, which is indicated by
- * s->flags & SN_BE_ASSIGNED.
- * All flags, stats and counters which need be updated are updated.
- * Returns 1 if done, 0 in case of internal error, eg: lack of resource.
- */
-int session_set_backend(struct session *s, struct proxy *be)
-{
-	if (s->flags & SN_BE_ASSIGNED)
-		return 1;
-	s->be = be;
-	be->beconn++;
-	if (be->beconn > be->counters.beconn_max)
-		be->counters.beconn_max = be->beconn;
-	proxy_inc_be_ctr(be);
-
-	/* assign new parameters to the session from the new backend */
-	s->rep->rto = s->req->wto = be->timeout.server;
-	s->req->cto = be->timeout.connect;
-	s->conn_retries = be->conn_retries;
-	s->si[1].flags &= ~SI_FL_INDEP_STR;
-	if (be->options2 & PR_O2_INDEPSTR)
-		s->si[1].flags |= SI_FL_INDEP_STR;
-
-	if (be->options2 & PR_O2_RSPBUG_OK)
-		s->txn.rsp.err_pos = -1; /* let buggy responses pass */
-	s->flags |= SN_BE_ASSIGNED;
-
-	/* If the target backend requires HTTP processing, we have to allocate
-	 * a struct hdr_idx for it if we did not have one.
-	 */
-	if (unlikely(!s->txn.hdr_idx.v && (be->acl_requires & ACL_USE_L7_ANY))) {
-		if ((s->txn.hdr_idx.v = pool_alloc2(s->fe->hdr_idx_pool)) == NULL)
-			return 0; /* not enough memory */
-
-		/* and now initialize the HTTP transaction state */
-		http_init_txn(s);
-
-		s->txn.hdr_idx.size = MAX_HTTP_HDR;
-		hdr_idx_init(&s->txn.hdr_idx);
-	}
-
-	if (be->options2 & PR_O2_NODELAY) {
-		s->req->flags |= BF_NEVER_WAIT;
-		s->rep->flags |= BF_NEVER_WAIT;
-	}
-
-	/* We want to enable the backend-specific analysers except those which
-	 * were already run as part of the frontend/listener. Note that it would
-	 * be more reliable to store the list of analysers that have been run,
-	 * but what we do here is OK for now.
-	 */
-	s->req->analysers |= be->be_req_ana & ~(s->listener->analysers);
-
-	return 1;
-}
-
-static struct cfg_kw_list cfg_kws = {{ },{
-	{ CFG_LISTEN, "timeout", proxy_parse_timeout },
-	{ CFG_LISTEN, "clitimeout", proxy_parse_timeout },
-	{ CFG_LISTEN, "contimeout", proxy_parse_timeout },
-	{ CFG_LISTEN, "srvtimeout", proxy_parse_timeout },
-	{ CFG_LISTEN, "rate-limit", proxy_parse_rate_limit },
-	{ 0, NULL, NULL },
-}};
-
-__attribute__((constructor))
-static void __proxy_module_init(void)
-{
-	cfg_register_keywords(&cfg_kws);
-}
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/queue.c b/deps/haproxy-1.4.21/src/queue.c
deleted file mode 100644
index 7f33d91..0000000
--- a/deps/haproxy-1.4.21/src/queue.c
+++ /dev/null
@@ -1,192 +0,0 @@
-/*
- * Queue management functions.
- *
- * Copyright 2000-2009 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <common/config.h>
-#include <common/memory.h>
-#include <common/time.h>
-
-#include <proto/queue.h>
-#include <proto/server.h>
-#include <proto/task.h>
-
-
-struct pool_head *pool2_pendconn;
-
-/* perform minimal intializations, report 0 in case of error, 1 if OK. */
-int init_pendconn()
-{
-	pool2_pendconn = create_pool("pendconn", sizeof(struct pendconn), MEM_F_SHARED);
-	return pool2_pendconn != NULL;
-}
-
-/* returns the effective dynamic maxconn for a server, considering the minconn
- * and the proxy's usage relative to its dynamic connections limit. It is
- * expected that 0 < s->minconn <= s->maxconn when this is called. If the
- * server is currently warming up, the slowstart is also applied to the
- * resulting value, which can be lower than minconn in this case, but never
- * less than 1.
- */
-unsigned int srv_dynamic_maxconn(const struct server *s)
-{
-	unsigned int max;
-
-	if (s->proxy->beconn >= s->proxy->fullconn)
-		/* no fullconn or proxy is full */
-		max = s->maxconn;
-	else if (s->minconn == s->maxconn)
-		/* static limit */
-		max = s->maxconn;
-	else max = MAX(s->minconn,
-		       s->proxy->beconn * s->maxconn / s->proxy->fullconn);
-
-	if ((s->state & SRV_WARMINGUP) &&
-	    now.tv_sec < s->last_change + s->slowstart &&
-	    now.tv_sec >= s->last_change) {
-		unsigned int ratio;
-		ratio = 100 * (now.tv_sec - s->last_change) / s->slowstart;
-		max = MAX(1, max * ratio / 100);
-	}
-	return max;
-}
-
-
-/*
- * Manages a server's connection queue. This function will try to dequeue as
- * many pending sessions as possible, and wake them up.
- */
-void process_srv_queue(struct server *s)
-{
-	struct proxy  *p = s->proxy;
-	int maxconn;
-
-	/* First, check if we can handle some connections queued at the proxy. We
-	 * will take as many as we can handle.
-	 */
-
-	maxconn = srv_dynamic_maxconn(s);
-	while (s->served < maxconn) {
-		struct session *sess = pendconn_get_next_sess(s, p);
-		if (sess == NULL)
-			break;
-		task_wakeup(sess->task, TASK_WOKEN_RES);
-	}
-}
-
-/* Detaches the next pending connection from either a server or a proxy, and
- * returns its associated session. If no pending connection is found, NULL is
- * returned. Note that neither <srv> nor <px> may be NULL.
- * Priority is given to the oldest request in the queue if both <srv> and <px>
- * have pending requests. This ensures that no request will be left unserved.
- * The <px> queue is not considered if the server (or a tracked server) is not
- * RUNNING, is disabled, or has a null weight (server going down). The <srv>
- * queue is still considered in this case, because if some connections remain
- * there, it means that some requests have been forced there after it was seen
- * down (eg: due to option persist).
- * The session is immediately marked as "assigned", and both its <srv> and
- * <srv_conn> are set to <srv>,
- */
-struct session *pendconn_get_next_sess(struct server *srv, struct proxy *px)
-{
-	struct pendconn *ps, *pp;
-	struct session *sess;
-	struct server *rsrv;
-
-	rsrv = srv->tracked;
-	if (!rsrv)
-		rsrv = srv;
-
-	ps = pendconn_from_srv(srv);
-	pp = pendconn_from_px(px);
-	/* we want to get the definitive pendconn in <ps> */
-	if (!pp || !srv_is_usable(rsrv->state, rsrv->eweight)) {
-		if (!ps)
-			return NULL;
-	} else {
-		/* pendconn exists in the proxy queue */
-		if (!ps || tv_islt(&pp->sess->logs.tv_request, &ps->sess->logs.tv_request)) {
-			ps = pp;
-			ps->sess->srv = srv;
-		}
-	}
-	sess = ps->sess;
-	pendconn_free(ps);
-
-	/* we want to note that the session has now been assigned a server */
-	sess->flags |= SN_ASSIGNED;
-	sess->srv = srv;
-	sess->srv_conn = srv;
-	srv->served++;
-	if (px->lbprm.server_take_conn)
-		px->lbprm.server_take_conn(srv);
-
-	return sess;
-}
-
-/* Adds the session <sess> to the pending connection list of server <sess>->srv
- * or to the one of <sess>->proxy if srv is NULL. All counters and back pointers
- * are updated accordingly. Returns NULL if no memory is available, otherwise the
- * pendconn itself. If the session was already marked as served, its flag is
- * cleared. It is illegal to call this function with a non-NULL sess->srv_conn.
- */
-struct pendconn *pendconn_add(struct session *sess)
-{
-	struct pendconn *p;
-
-	p = pool_alloc2(pool2_pendconn);
-	if (!p)
-		return NULL;
-
-	sess->pend_pos = p;
-	p->sess = sess;
-	p->srv  = sess->srv;
-
-	if (sess->flags & SN_ASSIGNED && sess->srv) {
-		LIST_ADDQ(&sess->srv->pendconns, &p->list);
-		sess->srv->nbpend++;
-		sess->logs.srv_queue_size += sess->srv->nbpend;
-		if (sess->srv->nbpend > sess->srv->counters.nbpend_max)
-			sess->srv->counters.nbpend_max = sess->srv->nbpend;
-	} else {
-		LIST_ADDQ(&sess->be->pendconns, &p->list);
-		sess->be->nbpend++;
-		sess->logs.prx_queue_size += sess->be->nbpend;
-		if (sess->be->nbpend > sess->be->counters.nbpend_max)
-			sess->be->counters.nbpend_max = sess->be->nbpend;
-	}
-	sess->be->totpend++;
-	return p;
-}
-
-/*
- * Detaches pending connection <p>, decreases the pending count, and frees
- * the pending connection. The connection might have been queued to a specific
- * server as well as to the proxy. The session also gets marked unqueued.
- */
-void pendconn_free(struct pendconn *p)
-{
-	LIST_DEL(&p->list);
-	p->sess->pend_pos = NULL;
-	if (p->srv)
-		p->srv->nbpend--;
-	else
-		p->sess->be->nbpend--;
-	p->sess->be->totpend--;
-	pool_free2(pool2_pendconn, p);
-}
-
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/rbtree.c b/deps/haproxy-1.4.21/src/rbtree.c
deleted file mode 100644
index 86b21ba..0000000
--- a/deps/haproxy-1.4.21/src/rbtree.c
+++ /dev/null
@@ -1,399 +0,0 @@
-/*
-  Red Black Trees
-  (C) 1999  Andrea Arcangeli <andrea@suse.de>
-  (C) 2002  David Woodhouse <dwmw2@infradead.org>
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-
-  linux/lib/rbtree.c
-*/
-
-/*
-#include <linux/rbtree.h>
-#include <linux/module.h>
-*/
-
-#include <stdlib.h>
-#include <common/rbtree.h>
-
-static void __rb_rotate_left(struct rb_node *node, struct rb_root *root)
-{
-	struct rb_node *right = node->rb_right;
-
-	if ((node->rb_right = right->rb_left))
-		right->rb_left->rb_parent = node;
-	right->rb_left = node;
-
-	if ((right->rb_parent = node->rb_parent))
-	{
-		if (node == node->rb_parent->rb_left)
-			node->rb_parent->rb_left = right;
-		else
-			node->rb_parent->rb_right = right;
-	}
-	else
-		root->rb_node = right;
-	node->rb_parent = right;
-}
-
-static void __rb_rotate_right(struct rb_node *node, struct rb_root *root)
-{
-	struct rb_node *left = node->rb_left;
-
-	if ((node->rb_left = left->rb_right))
-		left->rb_right->rb_parent = node;
-	left->rb_right = node;
-
-	if ((left->rb_parent = node->rb_parent))
-	{
-		if (node == node->rb_parent->rb_right)
-			node->rb_parent->rb_right = left;
-		else
-			node->rb_parent->rb_left = left;
-	}
-	else
-		root->rb_node = left;
-	node->rb_parent = left;
-}
-
-void rb_insert_color(struct rb_node *node, struct rb_root *root)
-{
-	struct rb_node *parent, *gparent;
-
-	while ((parent = node->rb_parent) && parent->rb_color == RB_RED)
-	{
-		gparent = parent->rb_parent;
-
-		if (parent == gparent->rb_left)
-		{
-			{
-				register struct rb_node *uncle = gparent->rb_right;
-				if (uncle && uncle->rb_color == RB_RED)
-				{
-					uncle->rb_color = RB_BLACK;
-					parent->rb_color = RB_BLACK;
-					gparent->rb_color = RB_RED;
-					node = gparent;
-					continue;
-				}
-			}
-
-			if (parent->rb_right == node)
-			{
-				register struct rb_node *tmp;
-				__rb_rotate_left(parent, root);
-				tmp = parent;
-				parent = node;
-				node = tmp;
-			}
-
-			parent->rb_color = RB_BLACK;
-			gparent->rb_color = RB_RED;
-			__rb_rotate_right(gparent, root);
-		} else {
-			{
-				register struct rb_node *uncle = gparent->rb_left;
-				if (uncle && uncle->rb_color == RB_RED)
-				{
-					uncle->rb_color = RB_BLACK;
-					parent->rb_color = RB_BLACK;
-					gparent->rb_color = RB_RED;
-					node = gparent;
-					continue;
-				}
-			}
-
-			if (parent->rb_left == node)
-			{
-				register struct rb_node *tmp;
-				__rb_rotate_right(parent, root);
-				tmp = parent;
-				parent = node;
-				node = tmp;
-			}
-
-			parent->rb_color = RB_BLACK;
-			gparent->rb_color = RB_RED;
-			__rb_rotate_left(gparent, root);
-		}
-	}
-
-	root->rb_node->rb_color = RB_BLACK;
-}
-// EXPORT_SYMBOL(rb_insert_color);
-
-static void __rb_erase_color(struct rb_node *node, struct rb_node *parent,
-			     struct rb_root *root)
-{
-	struct rb_node *other;
-
-	while ((!node || node->rb_color == RB_BLACK) && node != root->rb_node)
-	{
-		if (parent->rb_left == node)
-		{
-			other = parent->rb_right;
-			if (other->rb_color == RB_RED)
-			{
-				other->rb_color = RB_BLACK;
-				parent->rb_color = RB_RED;
-				__rb_rotate_left(parent, root);
-				other = parent->rb_right;
-			}
-			if ((!other->rb_left ||
-			     other->rb_left->rb_color == RB_BLACK)
-			    && (!other->rb_right ||
-				other->rb_right->rb_color == RB_BLACK))
-			{
-				other->rb_color = RB_RED;
-				node = parent;
-				parent = node->rb_parent;
-			}
-			else
-			{
-				if (!other->rb_right ||
-				    other->rb_right->rb_color == RB_BLACK)
-				{
-					register struct rb_node *o_left;
-					if ((o_left = other->rb_left))
-						o_left->rb_color = RB_BLACK;
-					other->rb_color = RB_RED;
-					__rb_rotate_right(other, root);
-					other = parent->rb_right;
-				}
-				other->rb_color = parent->rb_color;
-				parent->rb_color = RB_BLACK;
-				if (other->rb_right)
-					other->rb_right->rb_color = RB_BLACK;
-				__rb_rotate_left(parent, root);
-				node = root->rb_node;
-				break;
-			}
-		}
-		else
-		{
-			other = parent->rb_left;
-			if (other->rb_color == RB_RED)
-			{
-				other->rb_color = RB_BLACK;
-				parent->rb_color = RB_RED;
-				__rb_rotate_right(parent, root);
-				other = parent->rb_left;
-			}
-			if ((!other->rb_left ||
-			     other->rb_left->rb_color == RB_BLACK)
-			    && (!other->rb_right ||
-				other->rb_right->rb_color == RB_BLACK))
-			{
-				other->rb_color = RB_RED;
-				node = parent;
-				parent = node->rb_parent;
-			}
-			else
-			{
-				if (!other->rb_left ||
-				    other->rb_left->rb_color == RB_BLACK)
-				{
-					register struct rb_node *o_right;
-					if ((o_right = other->rb_right))
-						o_right->rb_color = RB_BLACK;
-					other->rb_color = RB_RED;
-					__rb_rotate_left(other, root);
-					other = parent->rb_left;
-				}
-				other->rb_color = parent->rb_color;
-				parent->rb_color = RB_BLACK;
-				if (other->rb_left)
-					other->rb_left->rb_color = RB_BLACK;
-				__rb_rotate_right(parent, root);
-				node = root->rb_node;
-				break;
-			}
-		}
-	}
-	if (node)
-		node->rb_color = RB_BLACK;
-}
-
-void rb_erase(struct rb_node *node, struct rb_root *root)
-{
-	struct rb_node *child, *parent;
-	int color;
-
-	if (!node->rb_left)
-		child = node->rb_right;
-	else if (!node->rb_right)
-		child = node->rb_left;
-	else
-	{
-		struct rb_node *old = node, *left;
-
-		node = node->rb_right;
-		while ((left = node->rb_left) != NULL)
-			node = left;
-		child = node->rb_right;
-		parent = node->rb_parent;
-		color = node->rb_color;
-
-		if (child)
-			child->rb_parent = parent;
-		if (parent)
-		{
-			if (parent->rb_left == node)
-				parent->rb_left = child;
-			else
-				parent->rb_right = child;
-		}
-		else
-			root->rb_node = child;
-
-		if (node->rb_parent == old)
-			parent = node;
-		node->rb_parent = old->rb_parent;
-		node->rb_color = old->rb_color;
-		node->rb_right = old->rb_right;
-		node->rb_left = old->rb_left;
-
-		if (old->rb_parent)
-		{
-			if (old->rb_parent->rb_left == old)
-				old->rb_parent->rb_left = node;
-			else
-				old->rb_parent->rb_right = node;
-		} else
-			root->rb_node = node;
-
-		old->rb_left->rb_parent = node;
-		if (old->rb_right)
-			old->rb_right->rb_parent = node;
-		goto color;
-	}
-
-	parent = node->rb_parent;
-	color = node->rb_color;
-
-	if (child)
-		child->rb_parent = parent;
-	if (parent)
-	{
-		if (parent->rb_left == node)
-			parent->rb_left = child;
-		else
-			parent->rb_right = child;
-	}
-	else
-		root->rb_node = child;
-
- color:
-	if (color == RB_BLACK)
-		__rb_erase_color(child, parent, root);
-}
-// EXPORT_SYMBOL(rb_erase);
-
-/*
- * This function returns the first node (in sort order) of the tree.
- */
-struct rb_node *rb_first(struct rb_root *root)
-{
-	struct rb_node	*n;
-
-	n = root->rb_node;
-	if (!n)
-		return NULL;
-	while (n->rb_left)
-		n = n->rb_left;
-	return n;
-}
-// EXPORT_SYMBOL(rb_first);
-
-struct rb_node *rb_last(struct rb_root *root)
-{
-	struct rb_node	*n;
-
-	n = root->rb_node;
-	if (!n)
-		return NULL;
-	while (n->rb_right)
-		n = n->rb_right;
-	return n;
-}
-// EXPORT_SYMBOL(rb_last);
-
-struct rb_node *rb_next(struct rb_node *node)
-{
-	/* If we have a right-hand child, go down and then left as far
-	   as we can. */
-	if (node->rb_right) {
-		node = node->rb_right;
-		while (node->rb_left)
-			node=node->rb_left;
-		return node;
-	}
-
-	/* No right-hand children.  Everything down and left is
-	   smaller than us, so any 'next' node must be in the general
-	   direction of our parent. Go up the tree; any time the
-	   ancestor is a right-hand child of its parent, keep going
-	   up. First time it's a left-hand child of its parent, said
-	   parent is our 'next' node. */
-	while (node->rb_parent && node == node->rb_parent->rb_right)
-		node = node->rb_parent;
-
-	return node->rb_parent;
-}
-// EXPORT_SYMBOL(rb_next);
-
-struct rb_node *rb_prev(struct rb_node *node)
-{
-	/* If we have a left-hand child, go down and then right as far
-	   as we can. */
-	if (node->rb_left) {
-		node = node->rb_left;
-		while (node->rb_right)
-			node=node->rb_right;
-		return node;
-	}
-
-	/* No left-hand children. Go up till we find an ancestor which
-	   is a right-hand child of its parent */
-	while (node->rb_parent && node == node->rb_parent->rb_left)
-		node = node->rb_parent;
-
-	return node->rb_parent;
-}
-// EXPORT_SYMBOL(rb_prev);
-
-void rb_replace_node(struct rb_node *victim, struct rb_node *new,
-		     struct rb_root *root)
-{
-	struct rb_node *parent = victim->rb_parent;
-
-	/* Set the surrounding nodes to point to the replacement */
-	if (parent) {
-		if (victim == parent->rb_left)
-			parent->rb_left = new;
-		else
-			parent->rb_right = new;
-	} else {
-		root->rb_node = new;
-	}
-	if (victim->rb_left)
-		victim->rb_left->rb_parent = new;
-	if (victim->rb_right)
-		victim->rb_right->rb_parent = new;
-
-	/* Copy the pointers/colour from the victim to the replacement */
-	*new = *victim;
-}
-// EXPORT_SYMBOL(rb_replace_node);
diff --git a/deps/haproxy-1.4.21/src/regex.c b/deps/haproxy-1.4.21/src/regex.c
deleted file mode 100644
index 1455fb4..0000000
--- a/deps/haproxy-1.4.21/src/regex.c
+++ /dev/null
@@ -1,132 +0,0 @@
-/*
- * Regex and string management functions.
- *
- * Copyright 2000-2010 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <ctype.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include <common/config.h>
-#include <common/regex.h>
-#include <common/standard.h>
-#include <proto/log.h>
-
-/* regex trash buffer used by various regex tests */
-regmatch_t pmatch[MAX_MATCH];  /* rm_so, rm_eo for regular expressions */
-
-
-int exp_replace(char *dst, char *src, const char *str, const regmatch_t *matches)
-{
-	char *old_dst = dst;
-
-	while (*str) {
-		if (*str == '\\') {
-			str++;
-			if (isdigit((unsigned char)*str)) {
-				int len, num;
-
-				num = *str - '0';
-				str++;
-
-				if (matches[num].rm_eo > -1 && matches[num].rm_so > -1) {
-					len = matches[num].rm_eo - matches[num].rm_so;
-					memcpy(dst, src + matches[num].rm_so, len);
-					dst += len;
-				}
-		
-			} else if (*str == 'x') {
-				unsigned char hex1, hex2;
-				str++;
-
-				hex1 = toupper(*str++) - '0';
-				hex2 = toupper(*str++) - '0';
-
-				if (hex1 > 9) hex1 -= 'A' - '9' - 1;
-				if (hex2 > 9) hex2 -= 'A' - '9' - 1;
-				*dst++ = (hex1<<4) + hex2;
-			} else {
-				*dst++ = *str++;
-			}
-		} else {
-			*dst++ = *str++;
-		}
-	}
-	*dst = '\0';
-	return dst - old_dst;
-}
-
-/* returns NULL if the replacement string <str> is valid, or the pointer to the first error */
-const char *check_replace_string(const char *str)
-{
-	const char *err = NULL;
-	while (*str) {
-		if (*str == '\\') {
-			err = str; /* in case of a backslash, we return the pointer to it */
-			str++;
-			if (!*str)
-				return err;
-			else if (isdigit((unsigned char)*str))
-				err = NULL;
-			else if (*str == 'x') {
-				str++;
-				if (!ishex(*str))
-					return err;
-				str++;
-				if (!ishex(*str))
-					return err;
-				err = NULL;
-			}
-			else {
-				Warning("'\\%c' : deprecated use of a backslash before something not '\\','x' or a digit.\n", *str);
-				err = NULL;
-			}
-		}
-		str++;
-	}
-	return err;
-}
-
-
-/* returns the pointer to an error in the replacement string, or NULL if OK */
-const char *chain_regex(struct hdr_exp **head, const regex_t *preg,
-			int action, const char *replace, void *cond)
-{
-	struct hdr_exp *exp;
-
-	if (replace != NULL) {
-		const char *err;
-		err = check_replace_string(replace);
-		if (err)
-			return err;
-	}
-
-	while (*head != NULL)
-		head = &(*head)->next;
-
-	exp = calloc(1, sizeof(struct hdr_exp));
-
-	exp->preg = preg;
-	exp->replace = replace;
-	exp->action = action;
-	exp->cond = cond;
-	*head = exp;
-
-	return NULL;
-}
-
-
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/server.c b/deps/haproxy-1.4.21/src/server.c
deleted file mode 100644
index 0016c80..0000000
--- a/deps/haproxy-1.4.21/src/server.c
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Server management functions.
- *
- * Copyright 2000-2006 Willy Tarreau <w@1wt.eu>
- * Copyright 2007-2008 Krzysztof Piotr Oledzki <ole@ans.pl>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <common/config.h>
-#include <common/time.h>
-
-#include <proto/server.h>
-
-int srv_downtime(struct server *s) {
-
-	if ((s->state & SRV_RUNNING) && s->last_change < now.tv_sec)		// ignore negative time
-		return s->down_time;
-
-	return now.tv_sec - s->last_change + s->down_time;
-}
-
-int srv_getinter(struct server *s) {
-
-	if ((s->state & SRV_CHECKED) && (s->health == s->rise + s->fall - 1))
-		return s->inter;
-
-	if (!(s->state & SRV_RUNNING) && s->health==0)
-		return (s->downinter)?(s->downinter):(s->inter);
-
-	return (s->fastinter)?(s->fastinter):(s->inter);
-}
-
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/session.c b/deps/haproxy-1.4.21/src/session.c
deleted file mode 100644
index 2d8b281..0000000
--- a/deps/haproxy-1.4.21/src/session.c
+++ /dev/null
@@ -1,1774 +0,0 @@
-/*
- * Server management functions.
- *
- * Copyright 2000-2008 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <stdlib.h>
-
-#include <common/config.h>
-#include <common/debug.h>
-#include <common/memory.h>
-
-#include <types/capture.h>
-#include <types/global.h>
-
-#include <proto/acl.h>
-#include <proto/backend.h>
-#include <proto/buffers.h>
-#include <proto/checks.h>
-#include <proto/dumpstats.h>
-#include <proto/hdr_idx.h>
-#include <proto/log.h>
-#include <proto/session.h>
-#include <proto/pattern.h>
-#include <proto/pipe.h>
-#include <proto/proto_http.h>
-#include <proto/proto_tcp.h>
-#include <proto/proxy.h>
-#include <proto/queue.h>
-#include <proto/server.h>
-#include <proto/stick_table.h>
-#include <proto/stream_interface.h>
-#include <proto/stream_sock.h>
-#include <proto/task.h>
-
-struct pool_head *pool2_session;
-struct list sessions;
-
-/*
- * frees  the context associated to a session. It must have been removed first.
- */
-void session_free(struct session *s)
-{
-	struct http_txn *txn = &s->txn;
-	struct proxy *fe = s->fe;
-	struct bref *bref, *back;
-	int i;
-
-	if (s->pend_pos)
-		pendconn_free(s->pend_pos);
-
-	if (s->srv) { /* there may be requests left pending in queue */
-		if (s->flags & SN_CURR_SESS) {
-			s->flags &= ~SN_CURR_SESS;
-			s->srv->cur_sess--;
-		}
-		if (may_dequeue_tasks(s->srv, s->be))
-			process_srv_queue(s->srv);
-	}
-
-	if (unlikely(s->srv_conn)) {
-		/* the session still has a reserved slot on a server, but
-		 * it should normally be only the same as the one above,
-		 * so this should not happen in fact.
-		 */
-		sess_change_server(s, NULL);
-	}
-
-	if (s->req->pipe)
-		put_pipe(s->req->pipe);
-
-	if (s->rep->pipe)
-		put_pipe(s->rep->pipe);
-
-	pool_free2(pool2_buffer, s->req);
-	pool_free2(pool2_buffer, s->rep);
-
-	http_end_txn(s);
-
-	for (i = 0; i < s->store_count; i++) {
-		if (!s->store[i].ts)
-			continue;
-		stksess_free(s->store[i].table, s->store[i].ts);
-		s->store[i].ts = NULL;
-	}
-
-	if (fe) {
-		pool_free2(fe->hdr_idx_pool, txn->hdr_idx.v);
-		pool_free2(fe->rsp_cap_pool, txn->rsp.cap);
-		pool_free2(fe->req_cap_pool, txn->req.cap);
-	}
-
-	list_for_each_entry_safe(bref, back, &s->back_refs, users) {
-		/* we have to unlink all watchers. We must not relink them if
-		 * this session was the last one in the list.
-		 */
-		LIST_DEL(&bref->users);
-		LIST_INIT(&bref->users);
-		if (s->list.n != &sessions)
-			LIST_ADDQ(&LIST_ELEM(s->list.n, struct session *, list)->back_refs, &bref->users);
-		bref->ref = s->list.n;
-	}
-	LIST_DEL(&s->list);
-	pool_free2(pool2_session, s);
-
-	/* We may want to free the maximum amount of pools if the proxy is stopping */
-	if (fe && unlikely(fe->state == PR_STSTOPPED)) {
-		pool_flush2(pool2_buffer);
-		pool_flush2(fe->hdr_idx_pool);
-		pool_flush2(pool2_requri);
-		pool_flush2(pool2_capture);
-		pool_flush2(pool2_session);
-		pool_flush2(fe->req_cap_pool);
-		pool_flush2(fe->rsp_cap_pool);
-	}
-}
-
-
-/* perform minimal intializations, report 0 in case of error, 1 if OK. */
-int init_session()
-{
-	LIST_INIT(&sessions);
-	pool2_session = create_pool("session", sizeof(struct session), MEM_F_SHARED);
-	return pool2_session != NULL;
-}
-
-void session_process_counters(struct session *s)
-{
-	unsigned long long bytes;
-
-	if (s->req) {
-		bytes = s->req->total - s->logs.bytes_in;
-		s->logs.bytes_in = s->req->total;
-		if (bytes) {
-			s->fe->counters.bytes_in			+= bytes;
-
-			if (s->be != s->fe)
-				s->be->counters.bytes_in		+= bytes;
-
-			if (s->srv)
-				s->srv->counters.bytes_in		+= bytes;
-
-			if (s->listener->counters)
-				s->listener->counters->bytes_in		+= bytes;
-		}
-	}
-
-	if (s->rep) {
-		bytes = s->rep->total - s->logs.bytes_out;
-		s->logs.bytes_out = s->rep->total;
-		if (bytes) {
-			s->fe->counters.bytes_out			+= bytes;
-
-			if (s->be != s->fe)
-				s->be->counters.bytes_out		+= bytes;
-
-			if (s->srv)
-				s->srv->counters.bytes_out		+= bytes;
-
-			if (s->listener->counters)
-				s->listener->counters->bytes_out	+= bytes;
-		}
-	}
-}
-
-/* This function is called with (si->state == SI_ST_CON) meaning that a
- * connection was attempted and that the file descriptor is already allocated.
- * We must check for establishment, error and abort. Possible output states
- * are SI_ST_EST (established), SI_ST_CER (error), SI_ST_DIS (abort), and
- * SI_ST_CON (no change). The function returns 0 if it switches to SI_ST_CER,
- * otherwise 1.
- */
-int sess_update_st_con_tcp(struct session *s, struct stream_interface *si)
-{
-	struct buffer *req = si->ob;
-	struct buffer *rep = si->ib;
-
-	/* If we got an error, or if nothing happened and the connection timed
-	 * out, we must give up. The CER state handler will take care of retry
-	 * attempts and error reports.
-	 */
-	if (unlikely(si->flags & (SI_FL_EXP|SI_FL_ERR))) {
-		si->exp   = TICK_ETERNITY;
-		si->state = SI_ST_CER;
-		si->flags &= ~SI_FL_CAP_SPLICE;
-		fd_delete(si->fd);
-
-		if (si->err_type)
-			return 0;
-
-		si->err_loc = s->srv;
-		if (si->flags & SI_FL_ERR)
-			si->err_type = SI_ET_CONN_ERR;
-		else
-			si->err_type = SI_ET_CONN_TO;
-		return 0;
-	}
-
-	/* OK, maybe we want to abort */
-	if (unlikely((rep->flags & BF_SHUTW) ||
-		     ((req->flags & BF_SHUTW_NOW) && /* FIXME: this should not prevent a connection from establishing */
-		      (((req->flags & (BF_OUT_EMPTY|BF_WRITE_ACTIVITY)) == BF_OUT_EMPTY) ||
-		       s->be->options & PR_O_ABRT_CLOSE)))) {
-		/* give up */
-		si->shutw(si);
-		si->err_type |= SI_ET_CONN_ABRT;
-		si->err_loc  = s->srv;
-		si->flags &= ~SI_FL_CAP_SPLICE;
-		if (s->srv_error)
-			s->srv_error(s, si);
-		return 1;
-	}
-
-	/* we need to wait a bit more if there was no activity either */
-	if (!(req->flags & BF_WRITE_ACTIVITY))
-		return 1;
-
-	/* OK, this means that a connection succeeded. The caller will be
-	 * responsible for handling the transition from CON to EST.
-	 */
-	s->logs.t_connect = tv_ms_elapsed(&s->logs.tv_accept, &now);
-	si->exp      = TICK_ETERNITY;
-	si->state    = SI_ST_EST;
-	si->err_type = SI_ET_NONE;
-	si->err_loc  = NULL;
-	return 1;
-}
-
-/* This function is called with (si->state == SI_ST_CER) meaning that a
- * previous connection attempt has failed and that the file descriptor
- * has already been released. Possible causes include asynchronous error
- * notification and time out. Possible output states are SI_ST_CLO when
- * retries are exhausted, SI_ST_TAR when a delay is wanted before a new
- * connection attempt, SI_ST_ASS when it's wise to retry on the same server,
- * and SI_ST_REQ when an immediate redispatch is wanted. The buffers are
- * marked as in error state. It returns 0.
- */
-int sess_update_st_cer(struct session *s, struct stream_interface *si)
-{
-	/* we probably have to release last session from the server */
-	if (s->srv) {
-		health_adjust(s->srv, HANA_STATUS_L4_ERR);
-
-		if (s->flags & SN_CURR_SESS) {
-			s->flags &= ~SN_CURR_SESS;
-			s->srv->cur_sess--;
-		}
-	}
-
-	/* ensure that we have enough retries left */
-	s->conn_retries--;
-	if (s->conn_retries < 0) {
-		if (!si->err_type) {
-			si->err_type = SI_ET_CONN_ERR;
-			si->err_loc = s->srv;
-		}
-
-		if (s->srv)
-			s->srv->counters.failed_conns++;
-		s->be->counters.failed_conns++;
-		sess_change_server(s, NULL);
-		if (may_dequeue_tasks(s->srv, s->be))
-			process_srv_queue(s->srv);
-
-		/* shutw is enough so stop a connecting socket */
-		si->shutw(si);
-		si->ob->flags |= BF_WRITE_ERROR;
-		si->ib->flags |= BF_READ_ERROR;
-
-		si->state = SI_ST_CLO;
-		if (s->srv_error)
-			s->srv_error(s, si);
-		return 0;
-	}
-
-	/* If the "redispatch" option is set on the backend, we are allowed to
-	 * retry on another server for the last retry. In order to achieve this,
-	 * we must mark the session unassigned, and eventually clear the DIRECT
-	 * bit to ignore any persistence cookie. We won't count a retry nor a
-	 * redispatch yet, because this will depend on what server is selected.
-	 */
-	if (s->srv && s->conn_retries == 0 &&
-	    s->be->options & PR_O_REDISP && !(s->flags & SN_FORCE_PRST)) {
-		sess_change_server(s, NULL);
-		if (may_dequeue_tasks(s->srv, s->be))
-			process_srv_queue(s->srv);
-
-		s->flags &= ~(SN_DIRECT | SN_ASSIGNED | SN_ADDR_SET);
-		s->prev_srv = s->srv;
-		si->state = SI_ST_REQ;
-	} else {
-		if (s->srv)
-			s->srv->counters.retries++;
-		s->be->counters.retries++;
-		si->state = SI_ST_ASS;
-	}
-
-	if (si->flags & SI_FL_ERR) {
-		/* The error was an asynchronous connection error, and we will
-		 * likely have to retry connecting to the same server, most
-		 * likely leading to the same result. To avoid this, we wait
-		 * one second before retrying.
-		 */
-
-		if (!si->err_type)
-			si->err_type = SI_ET_CONN_ERR;
-
-		si->state = SI_ST_TAR;
-		si->exp = tick_add(now_ms, MS_TO_TICKS(1000));
-		return 0;
-	}
-	return 0;
-}
-
-/*
- * This function handles the transition between the SI_ST_CON state and the
- * SI_ST_EST state. It must only be called after switching from SI_ST_CON to
- * SI_ST_EST.
- */
-void sess_establish(struct session *s, struct stream_interface *si)
-{
-	struct buffer *req = si->ob;
-	struct buffer *rep = si->ib;
-
-	if (s->srv)
-		health_adjust(s->srv, HANA_STATUS_L4_OK);
-
-	if (s->be->mode == PR_MODE_TCP) { /* let's allow immediate data connection in this case */
-		/* if the user wants to log as soon as possible, without counting
-		 * bytes from the server, then this is the right moment. */
-		if (s->fe->to_log && !(s->logs.logwait & LW_BYTES)) {
-			s->logs.t_close = s->logs.t_connect; /* to get a valid end date */
-			s->do_log(s);
-		}
-	}
-	else {
-		s->txn.rsp.msg_state = HTTP_MSG_RPBEFORE;
-		/* reset hdr_idx which was already initialized by the request.
-		 * right now, the http parser does it.
-		 * hdr_idx_init(&s->txn.hdr_idx);
-		 */
-	}
-
-	rep->analysers |= s->fe->fe_rsp_ana | s->be->be_rsp_ana;
-	rep->flags |= BF_READ_ATTACHED; /* producer is now attached */
-	req->wex = TICK_ETERNITY;
-}
-
-/* Update stream interface status for input states SI_ST_ASS, SI_ST_QUE, SI_ST_TAR.
- * Other input states are simply ignored.
- * Possible output states are SI_ST_CLO, SI_ST_TAR, SI_ST_ASS, SI_ST_REQ, SI_ST_CON.
- * Flags must have previously been updated for timeouts and other conditions.
- */
-void sess_update_stream_int(struct session *s, struct stream_interface *si)
-{
-	DPRINTF(stderr,"[%u] %s: sess=%p rq=%p, rp=%p, exp(r,w)=%u,%u rqf=%08x rpf=%08x rql=%d rpl=%d cs=%d ss=%d\n",
-		now_ms, __FUNCTION__,
-		s,
-		s->req, s->rep,
-		s->req->rex, s->rep->wex,
-		s->req->flags, s->rep->flags,
-		s->req->l, s->rep->l, s->rep->cons->state, s->req->cons->state);
-
-	if (si->state == SI_ST_ASS) {
-		/* Server assigned to connection request, we have to try to connect now */
-		int conn_err;
-
-		conn_err = connect_server(s);
-		if (conn_err == SN_ERR_NONE) {
-			/* state = SI_ST_CON now */
-			if (s->srv)
-				srv_inc_sess_ctr(s->srv);
-			return;
-		}
-
-		/* We have received a synchronous error. We might have to
-		 * abort, retry immediately or redispatch.
-		 */
-		if (conn_err == SN_ERR_INTERNAL) {
-			if (!si->err_type) {
-				si->err_type = SI_ET_CONN_OTHER;
-				si->err_loc  = s->srv;
-			}
-
-			if (s->srv)
-				srv_inc_sess_ctr(s->srv);
-			if (s->srv)
-				s->srv->counters.failed_conns++;
-			s->be->counters.failed_conns++;
-
-			/* release other sessions waiting for this server */
-			sess_change_server(s, NULL);
-			if (may_dequeue_tasks(s->srv, s->be))
-				process_srv_queue(s->srv);
-
-			/* Failed and not retryable. */
-			si->shutr(si);
-			si->shutw(si);
-			si->ob->flags |= BF_WRITE_ERROR;
-
-			s->logs.t_queue = tv_ms_elapsed(&s->logs.tv_accept, &now);
-
-			/* no session was ever accounted for this server */
-			si->state = SI_ST_CLO;
-			if (s->srv_error)
-				s->srv_error(s, si);
-			return;
-		}
-
-		/* We are facing a retryable error, but we don't want to run a
-		 * turn-around now, as the problem is likely a source port
-		 * allocation problem, so we want to retry now.
-		 */
-		si->state = SI_ST_CER;
-		si->flags &= ~SI_FL_ERR;
-		sess_update_st_cer(s, si);
-		/* now si->state is one of SI_ST_CLO, SI_ST_TAR, SI_ST_ASS, SI_ST_REQ */
-		return;
-	}
-	else if (si->state == SI_ST_QUE) {
-		/* connection request was queued, check for any update */
-		if (!s->pend_pos) {
-			/* The connection is not in the queue anymore. Either
-			 * we have a server connection slot available and we
-			 * go directly to the assigned state, or we need to
-			 * load-balance first and go to the INI state.
-			 */
-			si->exp = TICK_ETERNITY;
-			if (unlikely(!(s->flags & SN_ASSIGNED)))
-				si->state = SI_ST_REQ;
-			else {
-				s->logs.t_queue = tv_ms_elapsed(&s->logs.tv_accept, &now);
-				si->state = SI_ST_ASS;
-			}
-			return;
-		}
-
-		/* Connection request still in queue... */
-		if (si->flags & SI_FL_EXP) {
-			/* ... and timeout expired */
-			si->exp = TICK_ETERNITY;
-			s->logs.t_queue = tv_ms_elapsed(&s->logs.tv_accept, &now);
-			if (s->srv)
-				s->srv->counters.failed_conns++;
-			s->be->counters.failed_conns++;
-			si->shutr(si);
-			si->shutw(si);
-			si->ob->flags |= BF_WRITE_TIMEOUT;
-			if (!si->err_type)
-				si->err_type = SI_ET_QUEUE_TO;
-			si->state = SI_ST_CLO;
-			if (s->srv_error)
-				s->srv_error(s, si);
-			return;
-		}
-
-		/* Connection remains in queue, check if we have to abort it */
-		if ((si->ob->flags & (BF_READ_ERROR)) ||
-		    ((si->ob->flags & BF_SHUTW_NOW) &&   /* empty and client aborted */
-		     (si->ob->flags & BF_OUT_EMPTY || s->be->options & PR_O_ABRT_CLOSE))) {
-			/* give up */
-			si->exp = TICK_ETERNITY;
-			s->logs.t_queue = tv_ms_elapsed(&s->logs.tv_accept, &now);
-			si->shutr(si);
-			si->shutw(si);
-			si->err_type |= SI_ET_QUEUE_ABRT;
-			si->state = SI_ST_CLO;
-			if (s->srv_error)
-				s->srv_error(s, si);
-			return;
-		}
-
-		/* Nothing changed */
-		return;
-	}
-	else if (si->state == SI_ST_TAR) {
-		/* Connection request might be aborted */
-		if ((si->ob->flags & (BF_READ_ERROR)) ||
-		    ((si->ob->flags & BF_SHUTW_NOW) &&  /* empty and client aborted */
-		     (si->ob->flags & BF_OUT_EMPTY || s->be->options & PR_O_ABRT_CLOSE))) {
-			/* give up */
-			si->exp = TICK_ETERNITY;
-			si->shutr(si);
-			si->shutw(si);
-			si->err_type |= SI_ET_CONN_ABRT;
-			si->state = SI_ST_CLO;
-			if (s->srv_error)
-				s->srv_error(s, si);
-			return;
-		}
-
-		if (!(si->flags & SI_FL_EXP))
-			return;  /* still in turn-around */
-
-		si->exp = TICK_ETERNITY;
-
-		/* we keep trying on the same server as long as the session is
-		 * marked "assigned".
-		 * FIXME: Should we force a redispatch attempt when the server is down ?
-		 */
-		if (s->flags & SN_ASSIGNED)
-			si->state = SI_ST_ASS;
-		else
-			si->state = SI_ST_REQ;
-		return;
-	}
-}
-
-/* This function initiates a server connection request on a stream interface
- * already in SI_ST_REQ state. Upon success, the state goes to SI_ST_ASS,
- * indicating that a server has been assigned. It may also return SI_ST_QUE,
- * or SI_ST_CLO upon error.
- */
-static void sess_prepare_conn_req(struct session *s, struct stream_interface *si) {
-	DPRINTF(stderr,"[%u] %s: sess=%p rq=%p, rp=%p, exp(r,w)=%u,%u rqf=%08x rpf=%08x rql=%d rpl=%d cs=%d ss=%d\n",
-		now_ms, __FUNCTION__,
-		s,
-		s->req, s->rep,
-		s->req->rex, s->rep->wex,
-		s->req->flags, s->rep->flags,
-		s->req->l, s->rep->l, s->rep->cons->state, s->req->cons->state);
-
-	if (si->state != SI_ST_REQ)
-		return;
-
-	/* Try to assign a server */
-	if (srv_redispatch_connect(s) != 0) {
-		/* We did not get a server. Either we queued the
-		 * connection request, or we encountered an error.
-		 */
-		if (si->state == SI_ST_QUE)
-			return;
-
-		/* we did not get any server, let's check the cause */
-		si->shutr(si);
-		si->shutw(si);
-		si->ob->flags |= BF_WRITE_ERROR;
-		if (!si->err_type)
-			si->err_type = SI_ET_CONN_OTHER;
-		si->state = SI_ST_CLO;
-		if (s->srv_error)
-			s->srv_error(s, si);
-		return;
-	}
-
-	/* The server is assigned */
-	s->logs.t_queue = tv_ms_elapsed(&s->logs.tv_accept, &now);
-	si->state = SI_ST_ASS;
-}
-
-/* This stream analyser checks the switching rules and changes the backend
- * if appropriate. The default_backend rule is also considered, then the
- * target backend's forced persistence rules are also evaluated last if any.
- * It returns 1 if the processing can continue on next analysers, or zero if it
- * either needs more data or wants to immediately abort the request.
- */
-int process_switching_rules(struct session *s, struct buffer *req, int an_bit)
-{
-	struct persist_rule *prst_rule;
-
-	req->analysers &= ~an_bit;
-	req->analyse_exp = TICK_ETERNITY;
-
-	DPRINTF(stderr,"[%u] %s: session=%p b=%p, exp(r,w)=%u,%u bf=%08x bl=%d analysers=%02x\n",
-		now_ms, __FUNCTION__,
-		s,
-		req,
-		req->rex, req->wex,
-		req->flags,
-		req->l,
-		req->analysers);
-
-	/* now check whether we have some switching rules for this request */
-	if (!(s->flags & SN_BE_ASSIGNED)) {
-		struct switching_rule *rule;
-
-		list_for_each_entry(rule, &s->fe->switching_rules, list) {
-			int ret;
-
-			ret = acl_exec_cond(rule->cond, s->fe, s, &s->txn, ACL_DIR_REQ);
-			ret = acl_pass(ret);
-			if (rule->cond->pol == ACL_COND_UNLESS)
-				ret = !ret;
-
-			if (ret) {
-				if (!session_set_backend(s, rule->be.backend))
-					goto sw_failed;
-				break;
-			}
-		}
-
-		/* To ensure correct connection accounting on the backend, we
-		 * have to assign one if it was not set (eg: a listen). This
-		 * measure also takes care of correctly setting the default
-		 * backend if any.
-		 */
-		if (!(s->flags & SN_BE_ASSIGNED))
-			if (!session_set_backend(s, s->fe->defbe.be ? s->fe->defbe.be : s->be))
-				goto sw_failed;
-	}
-
-	/* we don't want to run the HTTP filters again if the backend has not changed */
-	if (s->fe == s->be)
-		s->req->analysers &= ~AN_REQ_HTTP_PROCESS_BE;
-
-	/* as soon as we know the backend, we must check if we have a matching forced or ignored
-	 * persistence rule, and report that in the session.
-	 */
-	list_for_each_entry(prst_rule, &s->be->persist_rules, list) {
-		int ret = 1;
-
-		if (prst_rule->cond) {
-	                ret = acl_exec_cond(prst_rule->cond, s->be, s, &s->txn, ACL_DIR_REQ);
-			ret = acl_pass(ret);
-			if (prst_rule->cond->pol == ACL_COND_UNLESS)
-				ret = !ret;
-		}
-
-		if (ret) {
-			/* no rule, or the rule matches */
-			if (prst_rule->type == PERSIST_TYPE_FORCE) {
-				s->flags |= SN_FORCE_PRST;
-			} else {
-				s->flags |= SN_IGNORE_PRST;
-			}
-			break;
-		}
-	}
-
-	return 1;
-
- sw_failed:
-	/* immediately abort this request in case of allocation failure */
-	buffer_abort(s->req);
-	buffer_abort(s->rep);
-
-	if (!(s->flags & SN_ERR_MASK))
-		s->flags |= SN_ERR_RESOURCE;
-	if (!(s->flags & SN_FINST_MASK))
-		s->flags |= SN_FINST_R;
-
-	s->txn.status = 500;
-	s->req->analysers = 0;
-	s->req->analyse_exp = TICK_ETERNITY;
-	return 0;
-}
-
-/* This stream analyser works on a request. It applies all sticking rules on
- * it then returns 1. The data must already be present in the buffer otherwise
- * they won't match. It always returns 1.
- */
-int process_sticking_rules(struct session *s, struct buffer *req, int an_bit)
-{
-	struct proxy    *px   = s->be;
-	struct sticking_rule  *rule;
-
-	DPRINTF(stderr,"[%u] %s: session=%p b=%p, exp(r,w)=%u,%u bf=%08x bl=%d analysers=%02x\n",
-		now_ms, __FUNCTION__,
-		s,
-		req,
-		req->rex, req->wex,
-		req->flags,
-		req->l,
-		req->analysers);
-
-	list_for_each_entry(rule, &px->sticking_rules, list) {
-		int ret = 1 ;
-		int i;
-
-		for (i = 0; i < s->store_count; i++) {
-			if (rule->table.t == s->store[i].table)
-				break;
-		}
-
-		if (i !=  s->store_count)
-			continue;
-
-		if (rule->cond) {
-	                ret = acl_exec_cond(rule->cond, px, s, &s->txn, ACL_DIR_REQ);
-			ret = acl_pass(ret);
-			if (rule->cond->pol == ACL_COND_UNLESS)
-				ret = !ret;
-		}
-
-		if (ret) {
-			struct stktable_key *key;
-
-			key = pattern_process_key(px, s, &s->txn, PATTERN_FETCH_REQ, rule->expr, rule->table.t->type);
-			if (!key)
-				continue;
-
-			if (rule->flags & STK_IS_MATCH) {
-				struct stksess *ts;
-
-				if ((ts = stktable_lookup(rule->table.t, key)) != NULL) {
-					if (!(s->flags & SN_ASSIGNED)) {
-						struct eb32_node *node;
-
-						/* srv found in table */
-						node = eb32_lookup(&px->conf.used_server_id, ts->sid);
-						if (node) {
-							struct server *srv;
-
-							srv = container_of(node, struct server, conf.id);
-							if ((srv->state & SRV_RUNNING) ||
-							    (px->options & PR_O_PERSIST) ||
-							    (s->flags & SN_FORCE_PRST)) {
-								s->flags |= SN_DIRECT | SN_ASSIGNED;
-								s->srv = srv;
-							}
-						}
-					}
-					ts->expire = tick_add(now_ms, MS_TO_TICKS(rule->table.t->expire));
-				}
-			}
-			if (rule->flags & STK_IS_STORE) {
-				if (s->store_count < (sizeof(s->store) / sizeof(s->store[0]))) {
-					struct stksess *ts;
-
-					ts = stksess_new(rule->table.t, key);
-					if (ts) {
-						s->store[s->store_count].table = rule->table.t;
-						s->store[s->store_count++].ts = ts;
-					}
-				}
-			}
-		}
-	}
-
-	req->analysers &= ~an_bit;
-	req->analyse_exp = TICK_ETERNITY;
-	return 1;
-}
-
-/* This stream analyser works on a response. It applies all store rules on it
- * then returns 1. The data must already be present in the buffer otherwise
- * they won't match. It always returns 1.
- */
-int process_store_rules(struct session *s, struct buffer *rep, int an_bit)
-{
-	struct proxy    *px   = s->be;
-	struct sticking_rule  *rule;
-	int i;
-
-	DPRINTF(stderr,"[%u] %s: session=%p b=%p, exp(r,w)=%u,%u bf=%08x bl=%d analysers=%02x\n",
-		now_ms, __FUNCTION__,
-		s,
-		rep,
-		rep->rex, rep->wex,
-		rep->flags,
-		rep->l,
-		rep->analysers);
-
-	list_for_each_entry(rule, &px->storersp_rules, list) {
-		int ret = 1 ;
-		int storereqidx = -1;
-
-		for (i = 0; i < s->store_count; i++) {
-			if (rule->table.t == s->store[i].table) {
-				if (!(s->store[i].flags))
-					storereqidx = i;
-				break;
-			}
-		}
-
-		if ((i !=  s->store_count) && (storereqidx == -1))
-			continue;
-
-		if (rule->cond) {
-	                ret = acl_exec_cond(rule->cond, px, s, &s->txn, ACL_DIR_RTR);
-	                ret = acl_pass(ret);
-			if (rule->cond->pol == ACL_COND_UNLESS)
-				ret = !ret;
-		}
-
-		if (ret) {
-			struct stktable_key *key;
-
-			key = pattern_process_key(px, s, &s->txn, PATTERN_FETCH_RTR, rule->expr, rule->table.t->type);
-			if (!key)
-				continue;
-
-			if (storereqidx != -1) {
-				stksess_key(s->store[storereqidx].table, s->store[storereqidx].ts, key);
-				s->store[storereqidx].flags = 1;
-			}
-			else if (s->store_count < (sizeof(s->store) / sizeof(s->store[0]))) {
-				struct stksess *ts;
-
-				ts = stksess_new(rule->table.t, key);
-				if (ts) {
-					s->store[s->store_count].table = rule->table.t;
-					s->store[s->store_count].flags = 1;
-					s->store[s->store_count++].ts = ts;
-				}
-			}
-		}
-	}
-
-	/* process store request and store response */
-	for (i = 0; i < s->store_count; i++) {
-		if (stktable_store(s->store[i].table, s->store[i].ts, s->srv->puid) > 0)
-			stksess_free(s->store[i].table, s->store[i].ts);
-		/* always remove pointer to session to ensure we won't free it again */
-		s->store[i].ts = NULL;
-	}
-	s->store_count = 0; /* everything is stored */
-
-	rep->analysers &= ~an_bit;
-	rep->analyse_exp = TICK_ETERNITY;
-	return 1;
-}
-
-/* This macro is very specific to the function below. See the comments in
- * process_session() below to understand the logic and the tests.
- */
-#define UPDATE_ANALYSERS(real, list, back, flag) {			\
-		list = (((list) & ~(flag)) | ~(back)) & (real);		\
-		back = real;						\
-		if (!(list))						\
-			break;						\
-		if (((list) ^ ((list) & ((list) - 1))) < (flag))	\
-			continue;					\
-}
-
-/* Processes the client, server, request and response jobs of a session task,
- * then puts it back to the wait queue in a clean state, or cleans up its
- * resources if it must be deleted. Returns in <next> the date the task wants
- * to be woken up, or TICK_ETERNITY. In order not to call all functions for
- * nothing too many times, the request and response buffers flags are monitored
- * and each function is called only if at least another function has changed at
- * least one flag it is interested in.
- */
-struct task *process_session(struct task *t)
-{
-	struct session *s = t->context;
-	unsigned int rqf_last, rpf_last;
-	unsigned int req_ana_back;
-
-	//DPRINTF(stderr, "%s:%d: cs=%d ss=%d(%d) rqf=0x%08x rpf=0x%08x\n", __FUNCTION__, __LINE__,
-	//        s->si[0].state, s->si[1].state, s->si[1].err_type, s->req->flags, s->rep->flags);
-
-	/* this data may be no longer valid, clear it */
-	memset(&s->txn.auth, 0, sizeof(s->txn.auth));
-
-	/* This flag must explicitly be set every time */
-	s->req->flags &= ~BF_READ_NOEXP;
-
-	/* Keep a copy of req/rep flags so that we can detect shutdowns */
-	rqf_last = s->req->flags;
-	rpf_last = s->rep->flags;
-
-	/* we don't want the stream interface functions to recursively wake us up */
-	if (s->req->prod->owner == t)
-		s->req->prod->flags |= SI_FL_DONT_WAKE;
-	if (s->req->cons->owner == t)
-		s->req->cons->flags |= SI_FL_DONT_WAKE;
-
-	/* 1a: Check for low level timeouts if needed. We just set a flag on
-	 * stream interfaces when their timeouts have expired.
-	 */
-	if (unlikely(t->state & TASK_WOKEN_TIMER)) {
-		stream_int_check_timeouts(&s->si[0]);
-		stream_int_check_timeouts(&s->si[1]);
-
-		/* check buffer timeouts, and close the corresponding stream interfaces
-		 * for future reads or writes. Note: this will also concern upper layers
-		 * but we do not touch any other flag. We must be careful and correctly
-		 * detect state changes when calling them.
-		 */
-
-		buffer_check_timeouts(s->req);
-
-		if (unlikely((s->req->flags & (BF_SHUTW|BF_WRITE_TIMEOUT)) == BF_WRITE_TIMEOUT)) {
-			s->req->cons->flags |= SI_FL_NOLINGER;
-			s->req->cons->shutw(s->req->cons);
-		}
-
-		if (unlikely((s->req->flags & (BF_SHUTR|BF_READ_TIMEOUT)) == BF_READ_TIMEOUT))
-			s->req->prod->shutr(s->req->prod);
-
-		buffer_check_timeouts(s->rep);
-
-		if (unlikely((s->rep->flags & (BF_SHUTW|BF_WRITE_TIMEOUT)) == BF_WRITE_TIMEOUT)) {
-			s->rep->cons->flags |= SI_FL_NOLINGER;
-			s->rep->cons->shutw(s->rep->cons);
-		}
-
-		if (unlikely((s->rep->flags & (BF_SHUTR|BF_READ_TIMEOUT)) == BF_READ_TIMEOUT))
-			s->rep->prod->shutr(s->rep->prod);
-	}
-
-	/* 1b: check for low-level errors reported at the stream interface.
-	 * First we check if it's a retryable error (in which case we don't
-	 * want to tell the buffer). Otherwise we report the error one level
-	 * upper by setting flags into the buffers. Note that the side towards
-	 * the client cannot have connect (hence retryable) errors. Also, the
-	 * connection setup code must be able to deal with any type of abort.
-	 */
-	if (unlikely(s->si[0].flags & SI_FL_ERR)) {
-		if (s->si[0].state == SI_ST_EST || s->si[0].state == SI_ST_DIS) {
-			s->si[0].shutr(&s->si[0]);
-			s->si[0].shutw(&s->si[0]);
-			stream_int_report_error(&s->si[0]);
-			if (!(s->req->analysers) && !(s->rep->analysers)) {
-				s->be->counters.cli_aborts++;
-				if (s->srv)
-					s->srv->counters.cli_aborts++;
-				if (!(s->flags & SN_ERR_MASK))
-					s->flags |= SN_ERR_CLICL;
-				if (!(s->flags & SN_FINST_MASK))
-					s->flags |= SN_FINST_D;
-			}
-		}
-	}
-
-	if (unlikely(s->si[1].flags & SI_FL_ERR)) {
-		if (s->si[1].state == SI_ST_EST || s->si[1].state == SI_ST_DIS) {
-			s->si[1].shutr(&s->si[1]);
-			s->si[1].shutw(&s->si[1]);
-			stream_int_report_error(&s->si[1]);
-			s->be->counters.failed_resp++;
-			if (s->srv)
-				s->srv->counters.failed_resp++;
-			if (!(s->req->analysers) && !(s->rep->analysers)) {
-				s->be->counters.srv_aborts++;
-				if (s->srv)
-					s->srv->counters.srv_aborts++;
-				if (!(s->flags & SN_ERR_MASK))
-					s->flags |= SN_ERR_SRVCL;
-				if (!(s->flags & SN_FINST_MASK))
-					s->flags |= SN_FINST_D;
-			}
-		}
-		/* note: maybe we should process connection errors here ? */
-	}
-
-	if (s->si[1].state == SI_ST_CON) {
-		/* we were trying to establish a connection on the server side,
-		 * maybe it succeeded, maybe it failed, maybe we timed out, ...
-		 */
-		if (unlikely(!sess_update_st_con_tcp(s, &s->si[1])))
-			sess_update_st_cer(s, &s->si[1]);
-		else if (s->si[1].state == SI_ST_EST)
-			sess_establish(s, &s->si[1]);
-
-		/* state is now one of SI_ST_CON (still in progress), SI_ST_EST
-		 * (established), SI_ST_DIS (abort), SI_ST_CLO (last error),
-		 * SI_ST_ASS/SI_ST_TAR/SI_ST_REQ for retryable errors.
-		 */
-	}
-
-resync_stream_interface:
-	/* Check for connection closure */
-
-	DPRINTF(stderr,
-		"[%u] %s:%d: task=%p s=%p, sfl=0x%08x, rq=%p, rp=%p, exp(r,w)=%u,%u rqf=%08x rpf=%08x rql=%d rpl=%d cs=%d ss=%d, cet=0x%x set=0x%x retr=%d\n",
-		now_ms, __FUNCTION__, __LINE__,
-		t,
-		s, s->flags,
-		s->req, s->rep,
-		s->req->rex, s->rep->wex,
-		s->req->flags, s->rep->flags,
-		s->req->l, s->rep->l, s->rep->cons->state, s->req->cons->state,
-		s->rep->cons->err_type, s->req->cons->err_type,
-		s->conn_retries);
-
-	/* nothing special to be done on client side */
-	if (unlikely(s->req->prod->state == SI_ST_DIS))
-		s->req->prod->state = SI_ST_CLO;
-
-	/* When a server-side connection is released, we have to count it and
-	 * check for pending connections on this server.
-	 */
-	if (unlikely(s->req->cons->state == SI_ST_DIS)) {
-		s->req->cons->state = SI_ST_CLO;
-		if (s->srv) {
-			if (s->flags & SN_CURR_SESS) {
-				s->flags &= ~SN_CURR_SESS;
-				s->srv->cur_sess--;
-			}
-			sess_change_server(s, NULL);
-			if (may_dequeue_tasks(s->srv, s->be))
-				process_srv_queue(s->srv);
-		}
-	}
-
-	/*
-	 * Note: of the transient states (REQ, CER, DIS), only REQ may remain
-	 * at this point.
-	 */
-
- resync_request:
-	/* Analyse request */
-	if ((s->req->flags & BF_MASK_ANALYSER) ||
-	    (s->req->flags ^ rqf_last) & BF_MASK_STATIC) {
-		unsigned int flags = s->req->flags;
-
-		if (s->req->prod->state >= SI_ST_EST) {
-			int max_loops = global.tune.maxpollevents;
-			unsigned int ana_list;
-			unsigned int ana_back;
-
-			/* it's up to the analysers to stop new connections,
-			 * disable reading or closing. Note: if an analyser
-			 * disables any of these bits, it is responsible for
-			 * enabling them again when it disables itself, so
-			 * that other analysers are called in similar conditions.
-			 */
-			buffer_auto_read(s->req);
-			buffer_auto_connect(s->req);
-			buffer_auto_close(s->req);
-
-			/* We will call all analysers for which a bit is set in
-			 * s->req->analysers, following the bit order from LSB
-			 * to MSB. The analysers must remove themselves from
-			 * the list when not needed. Any analyser may return 0
-			 * to break out of the loop, either because of missing
-			 * data to take a decision, or because it decides to
-			 * kill the session. We loop at least once through each
-			 * analyser, and we may loop again if other analysers
-			 * are added in the middle.
-			 *
-			 * We build a list of analysers to run. We evaluate all
-			 * of these analysers in the order of the lower bit to
-			 * the higher bit. This ordering is very important.
-			 * An analyser will often add/remove other analysers,
-			 * including itself. Any changes to itself have no effect
-			 * on the loop. If it removes any other analysers, we
-			 * want those analysers not to be called anymore during
-			 * this loop. If it adds an analyser that is located
-			 * after itself, we want it to be scheduled for being
-			 * processed during the loop. If it adds an analyser
-			 * which is located before it, we want it to switch to
-			 * it immediately, even if it has already been called
-			 * once but removed since.
-			 *
-			 * In order to achieve this, we compare the analyser
-			 * list after the call with a copy of it before the
-			 * call. The work list is fed with analyser bits that
-			 * appeared during the call. Then we compare previous
-			 * work list with the new one, and check the bits that
-			 * appeared. If the lowest of these bits is lower than
-			 * the current bit, it means we have enabled a previous
-			 * analyser and must immediately loop again.
-			 */
-
-			ana_list = ana_back = s->req->analysers;
-			while (ana_list && max_loops--) {
-				/* Warning! ensure that analysers are always placed in ascending order! */
-
-				if (ana_list & AN_REQ_DECODE_PROXY) {
-					if (!frontend_decode_proxy_request(s, s->req, AN_REQ_DECODE_PROXY))
-						break;
-					UPDATE_ANALYSERS(s->req->analysers, ana_list, ana_back, AN_REQ_DECODE_PROXY);
-				}
-
-				if (ana_list & AN_REQ_INSPECT) {
-					if (!tcp_inspect_request(s, s->req, AN_REQ_INSPECT))
-						break;
-					UPDATE_ANALYSERS(s->req->analysers, ana_list, ana_back, AN_REQ_INSPECT);
-				}
-
-				if (ana_list & AN_REQ_WAIT_HTTP) {
-					if (!http_wait_for_request(s, s->req, AN_REQ_WAIT_HTTP))
-						break;
-					UPDATE_ANALYSERS(s->req->analysers, ana_list, ana_back, AN_REQ_WAIT_HTTP);
-				}
-
-				if (ana_list & AN_REQ_HTTP_PROCESS_FE) {
-					if (!http_process_req_common(s, s->req, AN_REQ_HTTP_PROCESS_FE, s->fe))
-						break;
-					UPDATE_ANALYSERS(s->req->analysers, ana_list, ana_back, AN_REQ_HTTP_PROCESS_FE);
-				}
-
-				if (ana_list & AN_REQ_SWITCHING_RULES) {
-					if (!process_switching_rules(s, s->req, AN_REQ_SWITCHING_RULES))
-						break;
-					UPDATE_ANALYSERS(s->req->analysers, ana_list, ana_back, AN_REQ_SWITCHING_RULES);
-				}
-
-				if (ana_list & AN_REQ_HTTP_PROCESS_BE) {
-					if (!http_process_req_common(s, s->req, AN_REQ_HTTP_PROCESS_BE, s->be))
-						break;
-					UPDATE_ANALYSERS(s->req->analysers, ana_list, ana_back, AN_REQ_HTTP_PROCESS_BE);
-				}
-
-				if (ana_list & AN_REQ_HTTP_TARPIT) {
-					if (!http_process_tarpit(s, s->req, AN_REQ_HTTP_TARPIT))
-						break;
-					UPDATE_ANALYSERS(s->req->analysers, ana_list, ana_back, AN_REQ_HTTP_TARPIT);
-				}
-
-				if (ana_list & AN_REQ_HTTP_INNER) {
-					if (!http_process_request(s, s->req, AN_REQ_HTTP_INNER))
-						break;
-					UPDATE_ANALYSERS(s->req->analysers, ana_list, ana_back, AN_REQ_HTTP_INNER);
-				}
-
-				if (ana_list & AN_REQ_HTTP_BODY) {
-					if (!http_process_request_body(s, s->req, AN_REQ_HTTP_BODY))
-						break;
-					UPDATE_ANALYSERS(s->req->analysers, ana_list, ana_back, AN_REQ_HTTP_BODY);
-				}
-
-				if (ana_list & AN_REQ_PRST_RDP_COOKIE) {
-					if (!tcp_persist_rdp_cookie(s, s->req, AN_REQ_PRST_RDP_COOKIE))
-						break;
-					UPDATE_ANALYSERS(s->req->analysers, ana_list, ana_back, AN_REQ_PRST_RDP_COOKIE);
-				}
-
-				if (ana_list & AN_REQ_STICKING_RULES) {
-					if (!process_sticking_rules(s, s->req, AN_REQ_STICKING_RULES))
-						break;
-					UPDATE_ANALYSERS(s->req->analysers, ana_list, ana_back, AN_REQ_STICKING_RULES);
-				}
-
-				if (ana_list & AN_REQ_HTTP_XFER_BODY) {
-					if (!http_request_forward_body(s, s->req, AN_REQ_HTTP_XFER_BODY))
-						break;
-					UPDATE_ANALYSERS(s->req->analysers, ana_list, ana_back, AN_REQ_HTTP_XFER_BODY);
-				}
-				break;
-			}
-		}
-
-		if ((s->req->flags ^ flags) & BF_MASK_STATIC) {
-			rqf_last = s->req->flags;
-			goto resync_request;
-		}
-	}
-
-	/* we'll monitor the request analysers while parsing the response,
-	 * because some response analysers may indirectly enable new request
-	 * analysers (eg: HTTP keep-alive).
-	 */
-	req_ana_back = s->req->analysers;
-
- resync_response:
-	/* Analyse response */
-
-	if (unlikely(s->rep->flags & BF_HIJACK)) {
-		/* In inject mode, we wake up everytime something has
-		 * happened on the write side of the buffer.
-		 */
-		unsigned int flags = s->rep->flags;
-
-		if ((s->rep->flags & (BF_WRITE_PARTIAL|BF_WRITE_ERROR|BF_SHUTW)) &&
-		    !(s->rep->flags & BF_FULL)) {
-			s->rep->hijacker(s, s->rep);
-		}
-
-		if ((s->rep->flags ^ flags) & BF_MASK_STATIC) {
-			rpf_last = s->rep->flags;
-			goto resync_response;
-		}
-	}
-	else if ((s->rep->flags & BF_MASK_ANALYSER) ||
-		 (s->rep->flags ^ rpf_last) & BF_MASK_STATIC) {
-		unsigned int flags = s->rep->flags;
-
-		if (s->rep->prod->state >= SI_ST_EST) {
-			int max_loops = global.tune.maxpollevents;
-			unsigned int ana_list;
-			unsigned int ana_back;
-
-			/* it's up to the analysers to stop disable reading or
-			 * closing. Note: if an analyser disables any of these
-			 * bits, it is responsible for enabling them again when
-			 * it disables itself, so that other analysers are called
-			 * in similar conditions.
-			 */
-			buffer_auto_read(s->rep);
-			buffer_auto_close(s->rep);
-
-			/* We will call all analysers for which a bit is set in
-			 * s->rep->analysers, following the bit order from LSB
-			 * to MSB. The analysers must remove themselves from
-			 * the list when not needed. Any analyser may return 0
-			 * to break out of the loop, either because of missing
-			 * data to take a decision, or because it decides to
-			 * kill the session. We loop at least once through each
-			 * analyser, and we may loop again if other analysers
-			 * are added in the middle.
-			 */
-
-			ana_list = ana_back = s->rep->analysers;
-			while (ana_list && max_loops--) {
-				/* Warning! ensure that analysers are always placed in ascending order! */
-
-				if (ana_list & AN_RES_WAIT_HTTP) {
-					if (!http_wait_for_response(s, s->rep, AN_RES_WAIT_HTTP))
-						break;
-					UPDATE_ANALYSERS(s->rep->analysers, ana_list, ana_back, AN_RES_WAIT_HTTP);
-				}
-
-				if (ana_list & AN_RES_STORE_RULES) {
-					if (!process_store_rules(s, s->rep, AN_RES_STORE_RULES))
-						break;
-					UPDATE_ANALYSERS(s->rep->analysers, ana_list, ana_back, AN_RES_STORE_RULES);
-				}
-
-				if (ana_list & AN_RES_HTTP_PROCESS_BE) {
-					if (!http_process_res_common(s, s->rep, AN_RES_HTTP_PROCESS_BE, s->be))
-						break;
-					UPDATE_ANALYSERS(s->rep->analysers, ana_list, ana_back, AN_RES_HTTP_PROCESS_BE);
-				}
-
-				if (ana_list & AN_RES_HTTP_XFER_BODY) {
-					if (!http_response_forward_body(s, s->rep, AN_RES_HTTP_XFER_BODY))
-						break;
-					UPDATE_ANALYSERS(s->rep->analysers, ana_list, ana_back, AN_RES_HTTP_XFER_BODY);
-				}
-				break;
-			}
-		}
-
-		if ((s->rep->flags ^ flags) & BF_MASK_STATIC) {
-			rpf_last = s->rep->flags;
-			goto resync_response;
-		}
-	}
-
-	/* maybe someone has added some request analysers, so we must check and loop */
-	if (s->req->analysers & ~req_ana_back)
-		goto resync_request;
-
-	/* FIXME: here we should call protocol handlers which rely on
-	 * both buffers.
-	 */
-
-
-	/*
-	 * Now we propagate unhandled errors to the session. Normally
-	 * we're just in a data phase here since it means we have not
-	 * seen any analyser who could set an error status.
-	 */
-	if (!(s->flags & SN_ERR_MASK)) {
-		if (s->req->flags & (BF_READ_ERROR|BF_READ_TIMEOUT|BF_WRITE_ERROR|BF_WRITE_TIMEOUT)) {
-			/* Report it if the client got an error or a read timeout expired */
-			s->req->analysers = 0;
-			if (s->req->flags & BF_READ_ERROR) {
-				s->be->counters.cli_aborts++;
-				if (s->srv)
-					s->srv->counters.cli_aborts++;
-				s->flags |= SN_ERR_CLICL;
-			}
-			else if (s->req->flags & BF_READ_TIMEOUT) {
-				s->be->counters.cli_aborts++;
-				if (s->srv)
-					s->srv->counters.cli_aborts++;
-				s->flags |= SN_ERR_CLITO;
-			}
-			else if (s->req->flags & BF_WRITE_ERROR) {
-				s->be->counters.srv_aborts++;
-				if (s->srv)
-					s->srv->counters.srv_aborts++;
-				s->flags |= SN_ERR_SRVCL;
-			}
-			else {
-				s->be->counters.srv_aborts++;
-				if (s->srv)
-					s->srv->counters.srv_aborts++;
-				s->flags |= SN_ERR_SRVTO;
-			}
-			sess_set_term_flags(s);
-		}
-		else if (s->rep->flags & (BF_READ_ERROR|BF_READ_TIMEOUT|BF_WRITE_ERROR|BF_WRITE_TIMEOUT)) {
-			/* Report it if the server got an error or a read timeout expired */
-			s->rep->analysers = 0;
-			if (s->rep->flags & BF_READ_ERROR) {
-				s->be->counters.srv_aborts++;
-				if (s->srv)
-					s->srv->counters.srv_aborts++;
-				s->flags |= SN_ERR_SRVCL;
-			}
-			else if (s->rep->flags & BF_READ_TIMEOUT) {
-				s->be->counters.srv_aborts++;
-				if (s->srv)
-					s->srv->counters.srv_aborts++;
-				s->flags |= SN_ERR_SRVTO;
-			}
-			else if (s->rep->flags & BF_WRITE_ERROR) {
-				s->be->counters.cli_aborts++;
-				if (s->srv)
-					s->srv->counters.cli_aborts++;
-				s->flags |= SN_ERR_CLICL;
-			}
-			else {
-				s->be->counters.cli_aborts++;
-				if (s->srv)
-					s->srv->counters.cli_aborts++;
-				s->flags |= SN_ERR_CLITO;
-			}
-			sess_set_term_flags(s);
-		}
-	}
-
-	/*
-	 * Here we take care of forwarding unhandled data. This also includes
-	 * connection establishments and shutdown requests.
-	 */
-
-
-	/* If noone is interested in analysing data, it's time to forward
-	 * everything. We configure the buffer to forward indefinitely.
-	 */
-	if (!s->req->analysers &&
-	    !(s->req->flags & (BF_HIJACK|BF_SHUTW|BF_SHUTW_NOW)) &&
-	    (s->req->prod->state >= SI_ST_EST) &&
-	    (s->req->to_forward != BUF_INFINITE_FORWARD)) {
-		/* This buffer is freewheeling, there's no analyser nor hijacker
-		 * attached to it. If any data are left in, we'll permit them to
-		 * move.
-		 */
-		buffer_auto_read(s->req);
-		buffer_auto_connect(s->req);
-		buffer_auto_close(s->req);
-		buffer_flush(s->req);
-
-		/* If the producer is still connected, we'll enable data to flow
-		 * from the producer to the consumer (which might possibly not be
-		 * connected yet).
-		 */
-		if (!(s->req->flags & (BF_SHUTR|BF_SHUTW|BF_SHUTW_NOW)))
-			buffer_forward(s->req, BUF_INFINITE_FORWARD);
-	}
-
-	/* check if it is wise to enable kernel splicing to forward request data */
-	if (!(s->req->flags & (BF_KERN_SPLICING|BF_SHUTR)) &&
-	    s->req->to_forward &&
-	    (global.tune.options & GTUNE_USE_SPLICE) &&
-	    (s->si[0].flags & s->si[1].flags & SI_FL_CAP_SPLICE) &&
-	    (pipes_used < global.maxpipes) &&
-	    (((s->fe->options2|s->be->options2) & PR_O2_SPLIC_REQ) ||
-	     (((s->fe->options2|s->be->options2) & PR_O2_SPLIC_AUT) &&
-	      (s->req->flags & BF_STREAMER_FAST)))) {
-		s->req->flags |= BF_KERN_SPLICING;
-	}
-
-	/* reflect what the L7 analysers have seen last */
-	rqf_last = s->req->flags;
-
-	/*
-	 * Now forward all shutdown requests between both sides of the buffer
-	 */
-
-	/* first, let's check if the request buffer needs to shutdown(write), which may
-	 * happen either because the input is closed or because we want to force a close
-	 * once the server has begun to respond.
-	 */
-	if (unlikely((s->req->flags & (BF_SHUTW|BF_SHUTW_NOW|BF_HIJACK|BF_AUTO_CLOSE|BF_SHUTR)) ==
-		     (BF_AUTO_CLOSE|BF_SHUTR)))
-			buffer_shutw_now(s->req);
-
-	/* shutdown(write) pending */
-	if (unlikely((s->req->flags & (BF_SHUTW|BF_SHUTW_NOW|BF_OUT_EMPTY)) == (BF_SHUTW_NOW|BF_OUT_EMPTY)))
-		s->req->cons->shutw(s->req->cons);
-
-	/* shutdown(write) done on server side, we must stop the client too */
-	if (unlikely((s->req->flags & (BF_SHUTW|BF_SHUTR|BF_SHUTR_NOW)) == BF_SHUTW &&
-		     !s->req->analysers))
-		buffer_shutr_now(s->req);
-
-	/* shutdown(read) pending */
-	if (unlikely((s->req->flags & (BF_SHUTR|BF_SHUTR_NOW)) == BF_SHUTR_NOW))
-		s->req->prod->shutr(s->req->prod);
-
-	/* it's possible that an upper layer has requested a connection setup or abort.
-	 * There are 2 situations where we decide to establish a new connection :
-	 *  - there are data scheduled for emission in the buffer
-	 *  - the BF_AUTO_CONNECT flag is set (active connection)
-	 */
-	if (s->req->cons->state == SI_ST_INI) {
-		if (!(s->req->flags & BF_SHUTW)) {
-			if ((s->req->flags & (BF_AUTO_CONNECT|BF_OUT_EMPTY)) != BF_OUT_EMPTY) {
-				/* If we have a ->connect method, we need to perform a connection request,
-				 * otherwise we immediately switch to the connected state.
-				 */
-				if (s->req->cons->connect)
-					s->req->cons->state = SI_ST_REQ; /* new connection requested */
-				else
-					s->req->cons->state = SI_ST_EST; /* connection established */
-			}
-		}
-		else {
-			s->req->cons->state = SI_ST_CLO; /* shutw+ini = abort */
-			buffer_shutw_now(s->req);        /* fix buffer flags upon abort */
-			buffer_shutr_now(s->rep);
-		}
-	}
-
-
-	/* we may have a pending connection request, or a connection waiting
-	 * for completion.
-	 */
-	if (s->si[1].state >= SI_ST_REQ && s->si[1].state < SI_ST_CON) {
-		do {
-			/* nb: step 1 might switch from QUE to ASS, but we first want
-			 * to give a chance to step 2 to perform a redirect if needed.
-			 */
-			if (s->si[1].state != SI_ST_REQ)
-				sess_update_stream_int(s, &s->si[1]);
-			if (s->si[1].state == SI_ST_REQ)
-				sess_prepare_conn_req(s, &s->si[1]);
-
-			if (s->si[1].state == SI_ST_ASS && s->srv &&
-			    s->srv->rdr_len && (s->flags & SN_REDIRECTABLE))
-				perform_http_redirect(s, &s->si[1]);
-		} while (s->si[1].state == SI_ST_ASS);
-
-		/* Now we can add the server name to a header (if requested) */
-		/* check for HTTP mode and proxy server_name_hdr_name != NULL */
-		if ((s->flags & SN_BE_ASSIGNED) &&
-			(s->be->mode == PR_MODE_HTTP) &&
-			(s->be->server_id_hdr_name != NULL)) {
-
-			http_send_name_header(&s->txn,
-					      &s->txn.req,
-					      s->req,
-					      s->be,
-					      s->srv->id);
-		}
-	}
-
-	/* Benchmarks have shown that it's optimal to do a full resync now */
-	if (s->req->prod->state == SI_ST_DIS || s->req->cons->state == SI_ST_DIS)
-		goto resync_stream_interface;
-
-	/* otherwise wewant to check if we need to resync the req buffer or not */
-	if ((s->req->flags ^ rqf_last) & BF_MASK_STATIC)
-		goto resync_request;
-
-	/* perform output updates to the response buffer */
-
-	/* If noone is interested in analysing data, it's time to forward
-	 * everything. We configure the buffer to forward indefinitely.
-	 */
-	if (!s->rep->analysers &&
-	    !(s->rep->flags & (BF_HIJACK|BF_SHUTW|BF_SHUTW_NOW)) &&
-	    (s->rep->prod->state >= SI_ST_EST) &&
-	    (s->rep->to_forward != BUF_INFINITE_FORWARD)) {
-		/* This buffer is freewheeling, there's no analyser nor hijacker
-		 * attached to it. If any data are left in, we'll permit them to
-		 * move.
-		 */
-		buffer_auto_read(s->rep);
-		buffer_auto_close(s->rep);
-		buffer_flush(s->rep);
-		if (!(s->rep->flags & (BF_SHUTR|BF_SHUTW|BF_SHUTW_NOW)))
-			buffer_forward(s->rep, BUF_INFINITE_FORWARD);
-	}
-
-	/* check if it is wise to enable kernel splicing to forward response data */
-	if (!(s->rep->flags & (BF_KERN_SPLICING|BF_SHUTR)) &&
-	    s->rep->to_forward &&
-	    (global.tune.options & GTUNE_USE_SPLICE) &&
-	    (s->si[0].flags & s->si[1].flags & SI_FL_CAP_SPLICE) &&
-	    (pipes_used < global.maxpipes) &&
-	    (((s->fe->options2|s->be->options2) & PR_O2_SPLIC_RTR) ||
-	     (((s->fe->options2|s->be->options2) & PR_O2_SPLIC_AUT) &&
-	      (s->rep->flags & BF_STREAMER_FAST)))) {
-		s->rep->flags |= BF_KERN_SPLICING;
-	}
-
-	/* reflect what the L7 analysers have seen last */
-	rpf_last = s->rep->flags;
-
-	/*
-	 * Now forward all shutdown requests between both sides of the buffer
-	 */
-
-	/*
-	 * FIXME: this is probably where we should produce error responses.
-	 */
-
-	/* first, let's check if the response buffer needs to shutdown(write) */
-	if (unlikely((s->rep->flags & (BF_SHUTW|BF_SHUTW_NOW|BF_HIJACK|BF_AUTO_CLOSE|BF_SHUTR)) ==
-		     (BF_AUTO_CLOSE|BF_SHUTR)))
-		buffer_shutw_now(s->rep);
-
-	/* shutdown(write) pending */
-	if (unlikely((s->rep->flags & (BF_SHUTW|BF_OUT_EMPTY|BF_SHUTW_NOW)) == (BF_OUT_EMPTY|BF_SHUTW_NOW)))
-		s->rep->cons->shutw(s->rep->cons);
-
-	/* shutdown(write) done on the client side, we must stop the server too */
-	if (unlikely((s->rep->flags & (BF_SHUTW|BF_SHUTR|BF_SHUTR_NOW)) == BF_SHUTW) &&
-	    !s->rep->analysers)
-		buffer_shutr_now(s->rep);
-
-	/* shutdown(read) pending */
-	if (unlikely((s->rep->flags & (BF_SHUTR|BF_SHUTR_NOW)) == BF_SHUTR_NOW))
-		s->rep->prod->shutr(s->rep->prod);
-
-	if (s->req->prod->state == SI_ST_DIS || s->req->cons->state == SI_ST_DIS)
-		goto resync_stream_interface;
-
-	if (s->req->flags != rqf_last)
-		goto resync_request;
-
-	if ((s->rep->flags ^ rpf_last) & BF_MASK_STATIC)
-		goto resync_response;
-
-	/* we're interested in getting wakeups again */
-	s->req->prod->flags &= ~SI_FL_DONT_WAKE;
-	s->req->cons->flags &= ~SI_FL_DONT_WAKE;
-
-	/* This is needed only when debugging is enabled, to indicate
-	 * client-side or server-side close. Please note that in the unlikely
-	 * event where both sides would close at once, the sequence is reported
-	 * on the server side first.
-	 */
-	if (unlikely((global.mode & MODE_DEBUG) &&
-		     (!(global.mode & MODE_QUIET) ||
-		      (global.mode & MODE_VERBOSE)))) {
-		int len;
-
-		if (s->si[1].state == SI_ST_CLO &&
-		    s->si[1].prev_state == SI_ST_EST) {
-			len = sprintf(trash, "%08x:%s.srvcls[%04x:%04x]\n",
-				      s->uniq_id, s->be->id,
-				      (unsigned short)s->si[0].fd,
-				      (unsigned short)s->si[1].fd);
-			if (write(1, trash, len) < 0) /* shut gcc warning */;
-		}
-
-		if (s->si[0].state == SI_ST_CLO &&
-		    s->si[0].prev_state == SI_ST_EST) {
-			len = sprintf(trash, "%08x:%s.clicls[%04x:%04x]\n",
-				      s->uniq_id, s->be->id,
-				      (unsigned short)s->si[0].fd,
-				      (unsigned short)s->si[1].fd);
-			if (write(1, trash, len) < 0) /* shut gcc warning */;
-		}
-	}
-
-	if (likely((s->rep->cons->state != SI_ST_CLO) ||
-		   (s->req->cons->state > SI_ST_INI && s->req->cons->state < SI_ST_CLO))) {
-
-		if ((s->fe->options & PR_O_CONTSTATS) && (s->flags & SN_BE_ASSIGNED))
-			session_process_counters(s);
-
-		if (s->rep->cons->state == SI_ST_EST && !s->rep->cons->iohandler)
-			s->rep->cons->update(s->rep->cons);
-
-		if (s->req->cons->state == SI_ST_EST && !s->req->cons->iohandler)
-			s->req->cons->update(s->req->cons);
-
-		s->req->flags &= ~(BF_READ_NULL|BF_READ_PARTIAL|BF_WRITE_NULL|BF_WRITE_PARTIAL);
-		s->rep->flags &= ~(BF_READ_NULL|BF_READ_PARTIAL|BF_WRITE_NULL|BF_WRITE_PARTIAL);
-		s->si[0].prev_state = s->si[0].state;
-		s->si[1].prev_state = s->si[1].state;
-		s->si[0].flags &= ~(SI_FL_ERR|SI_FL_EXP);
-		s->si[1].flags &= ~(SI_FL_ERR|SI_FL_EXP);
-
-		/* Trick: if a request is being waiting for the server to respond,
-		 * and if we know the server can timeout, we don't want the timeout
-		 * to expire on the client side first, but we're still interested
-		 * in passing data from the client to the server (eg: POST). Thus,
-		 * we can cancel the client's request timeout if the server's
-		 * request timeout is set and the server has not yet sent a response.
-		 */
-
-		if ((s->rep->flags & (BF_AUTO_CLOSE|BF_SHUTR)) == 0 &&
-		    (tick_isset(s->req->wex) || tick_isset(s->rep->rex))) {
-			s->req->flags |= BF_READ_NOEXP;
-			s->req->rex = TICK_ETERNITY;
-		}
-
-		/* Call the second stream interface's I/O handler if it's embedded.
-		 * Note that this one may wake the task up again.
-		 */
-		if (s->req->cons->iohandler) {
-			s->req->cons->iohandler(s->req->cons);
-			if (task_in_rq(t)) {
-				/* If we woke up, we don't want to requeue the
-				 * task to the wait queue, but rather requeue
-				 * it into the runqueue ASAP.
-				 */
-				t->expire = TICK_ETERNITY;
-				return t;
-			}
-		}
-
-		t->expire = tick_first(tick_first(s->req->rex, s->req->wex),
-				       tick_first(s->rep->rex, s->rep->wex));
-		if (s->req->analysers)
-			t->expire = tick_first(t->expire, s->req->analyse_exp);
-
-		if (s->si[0].exp)
-			t->expire = tick_first(t->expire, s->si[0].exp);
-
-		if (s->si[1].exp)
-			t->expire = tick_first(t->expire, s->si[1].exp);
-
-#ifdef DEBUG_FULL
-		fprintf(stderr,
-			"[%u] queuing with exp=%u req->rex=%u req->wex=%u req->ana_exp=%u"
-			" rep->rex=%u rep->wex=%u, si[0].exp=%u, si[1].exp=%u, cs=%d, ss=%d\n",
-			now_ms, t->expire, s->req->rex, s->req->wex, s->req->analyse_exp,
-			s->rep->rex, s->rep->wex, s->si[0].exp, s->si[1].exp, s->si[0].state, s->si[1].state);
-#endif
-
-#ifdef DEBUG_DEV
-		/* this may only happen when no timeout is set or in case of an FSM bug */
-		if (!tick_isset(t->expire))
-			ABORT_NOW();
-#endif
-		return t; /* nothing more to do */
-	}
-
-	s->fe->feconn--;
-	if (s->flags & SN_BE_ASSIGNED)
-		s->be->beconn--;
-	actconn--;
-	s->listener->nbconn--;
-	if (s->listener->state == LI_FULL &&
-	    s->listener->nbconn < s->listener->maxconn) {
-		/* we should reactivate the listener */
-		EV_FD_SET(s->listener->fd, DIR_RD);
-		s->listener->state = LI_READY;
-	}
-
-	if (unlikely((global.mode & MODE_DEBUG) &&
-		     (!(global.mode & MODE_QUIET) || (global.mode & MODE_VERBOSE)))) {
-		int len;
-		len = sprintf(trash, "%08x:%s.closed[%04x:%04x]\n",
-			      s->uniq_id, s->be->id,
-			      (unsigned short)s->req->prod->fd, (unsigned short)s->req->cons->fd);
-		if (write(1, trash, len) < 0) /* shut gcc warning */;
-	}
-
-	s->logs.t_close = tv_ms_elapsed(&s->logs.tv_accept, &now);
-	session_process_counters(s);
-
-	if (s->txn.status) {
-		int n;
-
-		n = s->txn.status / 100;
-		if (n < 1 || n > 5)
-			n = 0;
-
-		if (s->fe->mode == PR_MODE_HTTP)
-			s->fe->counters.fe.http.rsp[n]++;
-
-		if ((s->flags & SN_BE_ASSIGNED) &&
-		    (s->be->mode == PR_MODE_HTTP))
-			s->be->counters.be.http.rsp[n]++;
-	}
-
-	/* let's do a final log if we need it */
-	if (s->logs.logwait &&
-	    !(s->flags & SN_MONITOR) &&
-	    (!(s->fe->options & PR_O_NULLNOLOG) || s->req->total)) {
-		s->do_log(s);
-	}
-
-	/* the task MUST not be in the run queue anymore */
-	session_free(s);
-	task_delete(t);
-	task_free(t);
-	return NULL;
-}
-
-/*
- * This function adjusts sess->srv_conn and maintains the previous and new
- * server's served session counts. Setting newsrv to NULL is enough to release
- * current connection slot. This function also notifies any LB algo which might
- * expect to be informed about any change in the number of active sessions on a
- * server.
- */
-void sess_change_server(struct session *sess, struct server *newsrv)
-{
-	if (sess->srv_conn == newsrv)
-		return;
-
-	if (sess->srv_conn) {
-		sess->srv_conn->served--;
-		if (sess->srv_conn->proxy->lbprm.server_drop_conn)
-			sess->srv_conn->proxy->lbprm.server_drop_conn(sess->srv_conn);
-		sess->srv_conn = NULL;
-	}
-
-	if (newsrv) {
-		newsrv->served++;
-		if (newsrv->proxy->lbprm.server_take_conn)
-			newsrv->proxy->lbprm.server_take_conn(newsrv);
-		sess->srv_conn = newsrv;
-	}
-}
-
-/* Set correct session termination flags in case no analyser has done it. It
- * also counts a failed request if the server state has not reached the request
- * stage.
- */
-void sess_set_term_flags(struct session *s)
-{
-	if (!(s->flags & SN_FINST_MASK)) {
-		if (s->si[1].state < SI_ST_REQ) {
-
-			s->fe->counters.failed_req++;
-			if (s->listener->counters)
-				s->listener->counters->failed_req++;
-
-			s->flags |= SN_FINST_R;
-		}
-		else if (s->si[1].state == SI_ST_QUE)
-			s->flags |= SN_FINST_Q;
-		else if (s->si[1].state < SI_ST_EST)
-			s->flags |= SN_FINST_C;
-		else if (s->si[1].state == SI_ST_EST || s->si[1].prev_state == SI_ST_EST)
-			s->flags |= SN_FINST_D;
-		else
-			s->flags |= SN_FINST_L;
-	}
-}
-
-/* Handle server-side errors for default protocols. It is called whenever a a
- * connection setup is aborted or a request is aborted in queue. It sets the
- * session termination flags so that the caller does not have to worry about
- * them. It's installed as ->srv_error for the server-side stream_interface.
- */
-void default_srv_error(struct session *s, struct stream_interface *si)
-{
-	int err_type = si->err_type;
-	int err = 0, fin = 0;
-
-	if (err_type & SI_ET_QUEUE_ABRT) {
-		err = SN_ERR_CLICL;
-		fin = SN_FINST_Q;
-	}
-	else if (err_type & SI_ET_CONN_ABRT) {
-		err = SN_ERR_CLICL;
-		fin = SN_FINST_C;
-	}
-	else if (err_type & SI_ET_QUEUE_TO) {
-		err = SN_ERR_SRVTO;
-		fin = SN_FINST_Q;
-	}
-	else if (err_type & SI_ET_QUEUE_ERR) {
-		err = SN_ERR_SRVCL;
-		fin = SN_FINST_Q;
-	}
-	else if (err_type & SI_ET_CONN_TO) {
-		err = SN_ERR_SRVTO;
-		fin = SN_FINST_C;
-	}
-	else if (err_type & SI_ET_CONN_ERR) {
-		err = SN_ERR_SRVCL;
-		fin = SN_FINST_C;
-	}
-	else /* SI_ET_CONN_OTHER and others */ {
-		err = SN_ERR_INTERNAL;
-		fin = SN_FINST_C;
-	}
-
-	if (!(s->flags & SN_ERR_MASK))
-		s->flags |= err;
-	if (!(s->flags & SN_FINST_MASK))
-		s->flags |= fin;
-}
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/sessionhash.c b/deps/haproxy-1.4.21/src/sessionhash.c
deleted file mode 100644
index 8068390..0000000
--- a/deps/haproxy-1.4.21/src/sessionhash.c
+++ /dev/null
@@ -1,127 +0,0 @@
-/*
- * HashTable functions.
- *
- * Copyright 2007 Arnaud Cornet
- *
- * This file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License, version 2.1 as published by the Free Software Foundation.
- *
- */
-
-/*
- * quick and dirty AppSession hash table, using sessid as key
- */
-
-#include <common/sessionhash.h>
-#include <string.h>
-#ifdef DEBUG_HASH
-#include <stdio.h>
-#endif
-
-/*
- * This is a bernstein hash derivate
- * returns unsigned int between 0 and (TABLESIZE - 1) inclusive
- */
-unsigned int appsession_hash_f(char *ptr)
-{
-	unsigned int h = 5381;
-
-	while (*ptr) {
-		h = (h << 5) + h + *ptr;
-		ptr++;
-	}
-	return ((h >> 16) ^ h) & TABLEMASK;
-}
-
-int appsession_hash_init(struct appsession_hash *hash,
-		void(*destroy)(appsess*))
-{
-	int i;
-
-	hash->destroy = destroy;
-	hash->table = malloc(TABLESIZE * sizeof(struct list));
-	if (hash->table == NULL)
-		return 0;
-	for (i = 0; i < TABLESIZE; i++)
-		LIST_INIT(&hash->table[i]);
-	return 1;
-}
-
-void appsession_hash_insert(struct appsession_hash *hash, appsess *session)
-{
-	unsigned int idx;
-
-	idx = appsession_hash_f(session->sessid);
-	LIST_ADDQ(&hash->table[idx], &session->hash_list);
-}
-
-appsess *appsession_hash_lookup(struct appsession_hash *hash, char *sessid)
-{
-	unsigned int idx;
-	appsess *item;
-
-	idx = appsession_hash_f(sessid);
-
-	list_for_each_entry(item, &hash->table[idx], hash_list) {
-		if (strcmp(item->sessid, sessid) == 0)
-			return item;
-	}
-	return NULL;
-}
-
-void appsession_hash_remove(struct appsession_hash *hash, appsess *session)
-{
-	unsigned int idx;
-	appsess *item;
-
-	idx = appsession_hash_f(session->sessid);
-
-	/* we don't even need to call _safe because we return at once */
-	list_for_each_entry(item, &hash->table[idx], hash_list) {
-		if (strcmp(item->sessid, session->sessid) == 0) {
-			LIST_DEL(&item->hash_list);
-			hash->destroy(item);
-			return;
-		}
-	}
-}
-
-void appsession_hash_destroy(struct appsession_hash *hash)
-{
-	unsigned int i;
-	appsess *item;
-
-	if (!hash->table)
-		return;
-
-	for (i = 0; i < TABLESIZE; i++) {
-		while (!LIST_ISEMPTY(&hash->table[i])) {
-			item = LIST_ELEM(hash->table[i].n, appsess *,
-					hash_list);
-			hash->destroy(item);
-			LIST_DEL(&item->hash_list);
-		}
-	}
-	free(hash->table);
-	hash->table = NULL;
-	hash->destroy = NULL;
-}
-
-#if defined(DEBUG_HASH)
-void appsession_hash_dump(struct appsession_hash *hash)
-{
-	unsigned int idx;
-	appsess *item;
-
-	printf("Dumping hashtable 0x%p\n", hash);
-	for (idx = 0; idx < TABLESIZE; idx++) {
-		/* we don't even need to call _safe because we return at once */
-		list_for_each_entry(item, &hash->table[idx], hash_list) {
-			printf("\ttable[%d]:\t%s\t-> %s request_count %lu\n", idx, item->sessid,
-					item->serverid, item->request_count);
-		}
-	}
-	printf(".\n");
-}
-#endif
diff --git a/deps/haproxy-1.4.21/src/signal.c b/deps/haproxy-1.4.21/src/signal.c
deleted file mode 100644
index 9825c0d..0000000
--- a/deps/haproxy-1.4.21/src/signal.c
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * Asynchronous signal delivery functions.
- *
- * Copyright 2000-2009 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <signal.h>
-#include <string.h>
-
-#include <proto/signal.h>
-#include <proto/log.h>
-
-/* Principle : we keep an in-order list of the first occurrence of all received
- * signals. All occurrences of a same signal are grouped though. The signal
- * queue does not need to be deeper than the number of signals we can handle.
- * The handlers will be called asynchronously with the signal number. They can
- * check themselves the number of calls by checking the descriptor this signal.
- */
-
-int signal_queue_len; /* length of signal queue, <= MAX_SIGNAL (1 entry per signal max) */
-int signal_queue[MAX_SIGNAL];                     /* in-order queue of received signals */
-struct signal_descriptor signal_state[MAX_SIGNAL];
-sigset_t blocked_sig;
-
-void signal_init()
-{
-	signal_queue_len = 0;
-	memset(signal_queue, 0, sizeof(signal_queue));
-	memset(signal_state, 0, sizeof(signal_state));
-	sigfillset(&blocked_sig);
-}
-
-void signal_handler(int sig)
-{
-	if (sig < 0 || sig > MAX_SIGNAL || !signal_state[sig].handler) {
-		/* unhandled signal */
-		qfprintf(stderr, "Received unhandled signal %d. Signal has been disabled.\n", sig);
-		signal(sig, SIG_IGN);
-		return;
-	}
-
-	if (!signal_state[sig].count) {
-		/* signal was not queued yet */
-		if (signal_queue_len < MAX_SIGNAL)
-			signal_queue[signal_queue_len++] = sig;
-		else
-			qfprintf(stderr, "Signal %d : signal queue is unexpectedly full.\n", sig);
-	}
-	signal_state[sig].count++;
-	signal(sig, signal_handler); /* re-arm signal */
-}
-
-/* Register a handler for signal <sig>. Set it to NULL, SIG_DFL or SIG_IGN to
- * remove the handler. The signal's queue is flushed and the signal is really
- * registered (or unregistered) for the process. The interface is the same as
- * for standard signal delivery, except that the handler does not need to rearm
- * the signal itself (it can disable it however).
- */
-void signal_register(int sig, void (*handler)(int))
-{
-	if (sig < 0 || sig > MAX_SIGNAL) {
-		qfprintf(stderr, "Failed to register signal %d : out of range [0..%d].\n", sig, MAX_SIGNAL);
-		return;
-	}
-
-	signal_state[sig].count = 0;
-	if (handler == NULL)
-		handler = SIG_IGN;
-
-	if (handler != SIG_IGN && handler != SIG_DFL) {
-		signal_state[sig].handler = handler;
-		signal(sig, signal_handler);
-	}
-	else {
-		signal_state[sig].handler = NULL;
-		signal(sig, handler);
-	}
-}
-
-/* Call handlers of all pending signals and clear counts and queue length. The
- * handlers may unregister themselves by calling signal_register() while they
- * are called, just like it is done with normal signal handlers.
- * Note that it is more efficient to call the inline version which checks the
- * queue length before getting here.
- */
-void __signal_process_queue()
-{
-	int sig, cur_pos = 0;
-	struct signal_descriptor *desc;
-	sigset_t old_sig;
-
-	/* block signal delivery during processing */
-	sigprocmask(SIG_SETMASK, &blocked_sig, &old_sig);
-
-	for (cur_pos = 0; cur_pos < signal_queue_len; cur_pos++) {
-		sig  = signal_queue[cur_pos];
-		desc = &signal_state[sig];
-		if (desc->count) {
-			if (desc->handler)
-				desc->handler(sig);
-			desc->count = 0;
-		}
-	}
-	signal_queue_len = 0;
-
-	/* restore signal delivery */
-	sigprocmask(SIG_SETMASK, &old_sig, NULL);
-}
diff --git a/deps/haproxy-1.4.21/src/standard.c b/deps/haproxy-1.4.21/src/standard.c
deleted file mode 100644
index f3b0699..0000000
--- a/deps/haproxy-1.4.21/src/standard.c
+++ /dev/null
@@ -1,1054 +0,0 @@
-/*
- * General purpose functions.
- *
- * Copyright 2000-2010 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <ctype.h>
-#include <netdb.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/socket.h>
-#include <sys/un.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-
-#include <common/config.h>
-#include <common/standard.h>
-#include <eb32tree.h>
-#include <proto/log.h>
-
-/* enough to store 10 integers of :
- *   2^64-1 = 18446744073709551615 or
- *    -2^63 = -9223372036854775808
- *
- * The HTML version needs room for adding the 25 characters
- * '<span class="rls"></span>' around digits at positions 3N+1 in order
- * to add spacing at up to 6 positions : 18 446 744 073 709 551 615
- */
-char itoa_str[10][171];
-
-/*
- * copies at most <size-1> chars from <src> to <dst>. Last char is always
- * set to 0, unless <size> is 0. The number of chars copied is returned
- * (excluding the terminating zero).
- * This code has been optimized for size and speed : on x86, it's 45 bytes
- * long, uses only registers, and consumes only 4 cycles per char.
- */
-int strlcpy2(char *dst, const char *src, int size)
-{
-	char *orig = dst;
-	if (size) {
-		while (--size && (*dst = *src)) {
-			src++; dst++;
-		}
-		*dst = 0;
-	}
-	return dst - orig;
-}
-
-/*
- * This function simply returns a locally allocated string containing
- * the ascii representation for number 'n' in decimal.
- */
-char *ultoa_r(unsigned long n, char *buffer, int size)
-{
-	char *pos;
-	
-	pos = buffer + size - 1;
-	*pos-- = '\0';
-	
-	do {
-		*pos-- = '0' + n % 10;
-		n /= 10;
-	} while (n && pos >= buffer);
-	return pos + 1;
-}
-
-/*
- * This function simply returns a locally allocated string containing
- * the ascii representation for number 'n' in decimal, formatted for
- * HTML output with tags to create visual grouping by 3 digits. The
- * output needs to support at least 171 characters.
- */
-const char *ulltoh_r(unsigned long long n, char *buffer, int size)
-{
-	char *start;
-	int digit = 0;
-	
-	start = buffer + size;
-	*--start = '\0';
-	
-	do {
-		if (digit == 3 && start >= buffer + 7)
-			memcpy(start -= 7, "</span>", 7);
-
-		if (start >= buffer + 1) {
-			*--start = '0' + n % 10;
-			n /= 10;
-		}
-
-		if (digit == 3 && start >= buffer + 18)
-			memcpy(start -= 18, "<span class=\"rls\">", 18);
-
-		if (digit++ == 3)
-			digit = 1;
-	} while (n && start > buffer);
-	return start;
-}
-
-/*
- * This function simply returns a locally allocated string containing the ascii
- * representation for number 'n' in decimal, unless n is 0 in which case it
- * returns the alternate string (or an empty string if the alternate string is
- * NULL). It use is intended for limits reported in reports, where it's
- * desirable not to display anything if there is no limit. Warning! it shares
- * the same vector as ultoa_r().
- */
-const char *limit_r(unsigned long n, char *buffer, int size, const char *alt)
-{
-	return (n) ? ultoa_r(n, buffer, size) : (alt ? alt : "");
-}
-
-/*
- * converts <str> to a struct sockaddr_un* which is locally allocated.
- * The format is "/path", where "/path" is a path to a UNIX domain socket.
- * NULL is returned if the socket path is invalid (too long).
- */
-struct sockaddr_un *str2sun(const char *str)
-{
-	static struct sockaddr_un su;
-	int strsz;	/* length included null */
-
-	memset(&su, 0, sizeof(su));
-	strsz = strlen(str) + 1;
-	if (strsz > sizeof(su.sun_path)) {
-		return NULL;
-	} else {
-		su.sun_family = AF_UNIX;
-		memcpy(su.sun_path, str, strsz);
-	}
-	return &su;
-}
-
-/*
- * Returns non-zero if character <s> is a hex digit (0-9, a-f, A-F), else zero.
- *
- * It looks like this one would be a good candidate for inlining, but this is
- * not interesting because it around 35 bytes long and often called multiple
- * times within the same function.
- */
-int ishex(char s)
-{
-	s -= '0';
-	if ((unsigned char)s <= 9)
-		return 1;
-	s -= 'A' - '0';
-	if ((unsigned char)s <= 5)
-		return 1;
-	s -= 'a' - 'A';
-	if ((unsigned char)s <= 5)
-		return 1;
-	return 0;
-}
-
-/*
- * Return integer equivalent of character <c> for a hex digit (0-9, a-f, A-F),
- * otherwise -1. This compact form helps gcc produce efficient code.
- */
-int hex2i(int c)
-{
-	if ((unsigned char)(c -= '0') > 9) {
-		if ((unsigned char)(c -= 'A' - '0') > 5 &&
-		    (unsigned char)(c -= 'a' - 'A') > 5)
-			c = -11;
-		c += 10;
-	}
-	return c;
-}
-
-/*
- * Checks <name> for invalid characters. Valid chars are [A-Za-z0-9_:.-]. If an
- * invalid character is found, a pointer to it is returned. If everything is
- * fine, NULL is returned.
- */
-const char *invalid_char(const char *name)
-{
-	if (!*name)
-		return name;
-
-	while (*name) {
-		if (!isalnum((int)(unsigned char)*name) && *name != '.' && *name != ':' &&
-		    *name != '_' && *name != '-')
-			return name;
-		name++;
-	}
-	return NULL;
-}
-
-/*
- * Checks <domainname> for invalid characters. Valid chars are [A-Za-z0-9_.-].
- * If an invalid character is found, a pointer to it is returned.
- * If everything is fine, NULL is returned.
- */
-const char *invalid_domainchar(const char *name) {
-
-	if (!*name)
-		return name;
-
-	while (*name) {
-		if (!isalnum((int)(unsigned char)*name) && *name != '.' &&
-		    *name != '_' && *name != '-')
-			return name;
-
-		name++;
-	}
-
-	return NULL;
-}
-
-/*
- * converts <str> to a struct sockaddr_in* which is locally allocated.
- * The format is "addr:port", where "addr" can be a dotted IPv4 address,
- * a host name, or empty or "*" to indicate INADDR_ANY. NULL is returned
- * if the host part cannot be resolved.
- */
-struct sockaddr_in *str2sa(char *str)
-{
-	static struct sockaddr_in sa;
-	struct sockaddr_in *ret = NULL;
-	char *c;
-	int port;
-
-	memset(&sa, 0, sizeof(sa));
-	str = strdup(str);
-	if (str == NULL)
-		goto out;
-
-	if ((c = strrchr(str,':')) != NULL) {
-		*c++ = '\0';
-		port = atol(c);
-	}
-	else
-		port = 0;
-
-	if (*str == '*' || *str == '\0') { /* INADDR_ANY */
-		sa.sin_addr.s_addr = INADDR_ANY;
-	}
-	else if (!inet_pton(AF_INET, str, &sa.sin_addr)) {
-		struct hostent *he = gethostbyname(str);
-		if (!he)
-			goto out;
-		sa.sin_addr = *(struct in_addr *) *(he->h_addr_list);
-	}
-	sa.sin_port   = htons(port);
-	sa.sin_family = AF_INET;
-	ret = &sa;
- out:
-	free(str);
-	return ret;
-}
-
-/*
- * converts <str> to a struct sockaddr_in* which is locally allocated, and a
- * port range consisting in two integers. The low and high end are always set
- * even if the port is unspecified, in which case (0,0) is returned. The low
- * port is set in the sockaddr_in. Thus, it is enough to check the size of the
- * returned range to know if an array must be allocated or not. The format is
- * "addr[:port[-port]]", where "addr" can be a dotted IPv4 address, a host
- * name, or empty or "*" to indicate INADDR_ANY. NULL is returned if the host
- * part cannot be resolved.
- */
-struct sockaddr_in *str2sa_range(char *str, int *low, int *high)
-{
-	static struct sockaddr_in sa;
-	struct sockaddr_in *ret = NULL;
-	char *c;
-	int portl, porth;
-
-	memset(&sa, 0, sizeof(sa));
-	str = strdup(str);
-	if (str == NULL)
-		goto out;
-
-	if ((c = strrchr(str,':')) != NULL) {
-		char *sep;
-		*c++ = '\0';
-		sep = strchr(c, '-');
-		if (sep)
-			*sep++ = '\0';
-		else
-			sep = c;
-		portl = atol(c);
-		porth = atol(sep);
-	}
-	else {
-		portl = 0;
-		porth = 0;
-	}
-
-	if (*str == '*' || *str == '\0') { /* INADDR_ANY */
-		sa.sin_addr.s_addr = INADDR_ANY;
-	}
-	else if (!inet_pton(AF_INET, str, &sa.sin_addr)) {
-		struct hostent *he = gethostbyname(str);
-		if (!he)
-			goto out;
-		sa.sin_addr = *(struct in_addr *) *(he->h_addr_list);
-	}
-	sa.sin_port   = htons(portl);
-	sa.sin_family = AF_INET;
-	ret = &sa;
-
-	*low = portl;
-	*high = porth;
-
- out:
-	free(str);
-	return ret;
-}
-
-/* converts <str> to a struct in_addr containing a network mask. It can be
- * passed in dotted form (255.255.255.0) or in CIDR form (24). It returns 1
- * if the conversion succeeds otherwise non-zero.
- */
-int str2mask(const char *str, struct in_addr *mask)
-{
-	if (strchr(str, '.') != NULL) {	    /* dotted notation */
-		if (!inet_pton(AF_INET, str, mask))
-			return 0;
-	}
-	else { /* mask length */
-		char *err;
-		unsigned long len = strtol(str, &err, 10);
-
-		if (!*str || (err && *err) || (unsigned)len > 32)
-			return 0;
-		if (len)
-			mask->s_addr = htonl(~0UL << (32 - len));
-		else
-			mask->s_addr = 0;
-	}
-	return 1;
-}
-
-/*
- * converts <str> to two struct in_addr* which must be pre-allocated.
- * The format is "addr[/mask]", where "addr" cannot be empty, and mask
- * is optionnal and either in the dotted or CIDR notation.
- * Note: "addr" can also be a hostname. Returns 1 if OK, 0 if error.
- */
-int str2net(const char *str, struct in_addr *addr, struct in_addr *mask)
-{
-	__label__ out_free, out_err;
-	char *c, *s;
-	int ret_val;
-
-	s = strdup(str);
-	if (!s)
-		return 0;
-
-	memset(mask, 0, sizeof(*mask));
-	memset(addr, 0, sizeof(*addr));
-
-	if ((c = strrchr(s, '/')) != NULL) {
-		*c++ = '\0';
-		/* c points to the mask */
-		if (!str2mask(c, mask))
-			goto out_err;
-	}
-	else {
-		mask->s_addr = ~0U;
-	}
-	if (!inet_pton(AF_INET, s, addr)) {
-		struct hostent *he;
-
-		if ((he = gethostbyname(s)) == NULL) {
-			goto out_err;
-		}
-		else
-			*addr = *(struct in_addr *) *(he->h_addr_list);
-	}
-
-	ret_val = 1;
- out_free:
-	free(s);
-	return ret_val;
- out_err:
-	ret_val = 0;
-	goto out_free;
-}
-
-
-/*
- * Parse IP address found in url.
- */
-int url2ip(const char *addr, struct in_addr *dst)
-{
-	int saw_digit, octets, ch;
-	u_char tmp[4], *tp;
-	const char *cp = addr;
-
-	saw_digit = 0;
-	octets = 0;
-	*(tp = tmp) = 0;
-
-	while (*addr) {
-		unsigned char digit = (ch = *addr++) - '0';
-		if (digit > 9 && ch != '.')
-			break;
-		if (digit <= 9) {
-			u_int new = *tp * 10 + digit;
-			if (new > 255)
-				return 0;
-			*tp = new;
-			if (!saw_digit) {
-				if (++octets > 4)
-					return 0;
-				saw_digit = 1;
-			}
-		} else if (ch == '.' && saw_digit) {
-			if (octets == 4)
-				return 0;
-			*++tp = 0;
-			saw_digit = 0;
-		} else
-			return 0;
-	}
-
-	if (octets < 4)
-		return 0;
-
-	memcpy(&dst->s_addr, tmp, 4);
-	return addr-cp-1;
-}
-
-/*
- * Resolve destination server from URL. Convert <str> to a sockaddr_in*.
- */
-int url2sa(const char *url, int ulen, struct sockaddr_in *addr)
-{
-	const char *curr = url, *cp = url;
-	int ret, url_code = 0;
-	unsigned int http_code = 0;
-
-	/* Cleanup the room */
-	addr->sin_family = AF_INET;
-	addr->sin_addr.s_addr = 0;
-	addr->sin_port = 0;
-
-	/* Firstly, try to find :// pattern */
-	while (curr < url+ulen && url_code != 0x3a2f2f) {
-		url_code = ((url_code & 0xffff) << 8);
-		url_code += (unsigned char)*curr++;
-	}
-
-	/* Secondly, if :// pattern is found, verify parsed stuff
-	 * before pattern is matching our http pattern.
-	 * If so parse ip address and port in uri.
-	 * 
-	 * WARNING: Current code doesn't support dynamic async dns resolver.
-	 */
-	if (url_code == 0x3a2f2f) {
-		while (cp < curr - 3)
-			http_code = (http_code << 8) + *cp++;
-		http_code |= 0x20202020;			/* Turn everything to lower case */
-		
-		/* HTTP url matching */
-		if (http_code == 0x68747470) {
-			/* We are looking for IP address. If you want to parse and
-			 * resolve hostname found in url, you can use str2sa(), but
-			 * be warned this can slow down global daemon performances
-			 * while handling lagging dns responses.
-			 */
-			ret = url2ip(curr, &addr->sin_addr);
-			if (!ret)
-				return -1;
-			curr += ret;
-			addr->sin_port = (*curr == ':') ? str2uic(++curr) : 80;
-			addr->sin_port = htons(addr->sin_port);
-		}
-		return 0;
-	}
-
-	return -1;
-}
-
-/* will try to encode the string <string> replacing all characters tagged in
- * <map> with the hexadecimal representation of their ASCII-code (2 digits)
- * prefixed by <escape>, and will store the result between <start> (included)
- * and <stop> (excluded), and will always terminate the string with a '\0'
- * before <stop>. The position of the '\0' is returned if the conversion
- * completes. If bytes are missing between <start> and <stop>, then the
- * conversion will be incomplete and truncated. If <stop> <= <start>, the '\0'
- * cannot even be stored so we return <start> without writing the 0.
- * The input string must also be zero-terminated.
- */
-const char hextab[16] = "0123456789ABCDEF";
-char *encode_string(char *start, char *stop,
-		    const char escape, const fd_set *map,
-		    const char *string)
-{
-	if (start < stop) {
-		stop--; /* reserve one byte for the final '\0' */
-		while (start < stop && *string != '\0') {
-			if (!FD_ISSET((unsigned char)(*string), map))
-				*start++ = *string;
-			else {
-				if (start + 3 >= stop)
-					break;
-				*start++ = escape;
-				*start++ = hextab[(*string >> 4) & 15];
-				*start++ = hextab[*string & 15];
-			}
-			string++;
-		}
-		*start = '\0';
-	}
-	return start;
-}
-
-/* Decode an URL-encoded string in-place. The resulting string might
- * be shorter. If some forbidden characters are found, the conversion is
- * aborted, the string is truncated before the issue and non-zero is returned,
- * otherwise the operation returns non-zero indicating success.
- */
-int url_decode(char *string)
-{
-	char *in, *out;
-	int ret = 0;
-
-	in = string;
-	out = string;
-	while (*in) {
-		switch (*in) {
-		case '+' :
-			*out++ = ' ';
-			break;
-		case '%' :
-			if (!ishex(in[1]) || !ishex(in[2]))
-				goto end;
-			*out++ = (hex2i(in[1]) << 4) + hex2i(in[2]);
-			in += 2;
-			break;
-		default:
-			*out++ = *in;
-			break;
-		}
-		in++;
-	}
-	ret = 1; /* success */
- end:
-	*out = 0;
-	return ret;
-}
-
-unsigned int str2ui(const char *s)
-{
-	return __str2ui(s);
-}
-
-unsigned int str2uic(const char *s)
-{
-	return __str2uic(s);
-}
-
-unsigned int strl2ui(const char *s, int len)
-{
-	return __strl2ui(s, len);
-}
-
-unsigned int strl2uic(const char *s, int len)
-{
-	return __strl2uic(s, len);
-}
-
-unsigned int read_uint(const char **s, const char *end)
-{
-	return __read_uint(s, end);
-}
-
-/* This one is 7 times faster than strtol() on athlon with checks.
- * It returns the value of the number composed of all valid digits read,
- * and can process negative numbers too.
- */
-int strl2ic(const char *s, int len)
-{
-	int i = 0;
-	int j, k;
-
-	if (len > 0) {
-		if (*s != '-') {
-			/* positive number */
-			while (len-- > 0) {
-				j = (*s++) - '0';
-				k = i * 10;
-				if (j > 9)
-					break;
-				i = k + j;
-			}
-		} else {
-			/* negative number */
-			s++;
-			while (--len > 0) {
-				j = (*s++) - '0';
-				k = i * 10;
-				if (j > 9)
-					break;
-				i = k - j;
-			}
-		}
-	}
-	return i;
-}
-
-
-/* This function reads exactly <len> chars from <s> and converts them to a
- * signed integer which it stores into <ret>. It accurately detects any error
- * (truncated string, invalid chars, overflows). It is meant to be used in
- * applications designed for hostile environments. It returns zero when the
- * number has successfully been converted, non-zero otherwise. When an error
- * is returned, the <ret> value is left untouched. It is yet 5 to 40 times
- * faster than strtol().
- */
-int strl2irc(const char *s, int len, int *ret)
-{
-	int i = 0;
-	int j;
-
-	if (!len)
-		return 1;
-
-	if (*s != '-') {
-		/* positive number */
-		while (len-- > 0) {
-			j = (*s++) - '0';
-			if (j > 9)            return 1; /* invalid char */
-			if (i > INT_MAX / 10) return 1; /* check for multiply overflow */
-			i = i * 10;
-			if (i + j < i)        return 1; /* check for addition overflow */
-			i = i + j;
-		}
-	} else {
-		/* negative number */
-		s++;
-		while (--len > 0) {
-			j = (*s++) - '0';
-			if (j > 9)             return 1; /* invalid char */
-			if (i < INT_MIN / 10)  return 1; /* check for multiply overflow */
-			i = i * 10;
-			if (i - j > i)         return 1; /* check for subtract overflow */
-			i = i - j;
-		}
-	}
-	*ret = i;
-	return 0;
-}
-
-
-/* This function reads exactly <len> chars from <s> and converts them to a
- * signed integer which it stores into <ret>. It accurately detects any error
- * (truncated string, invalid chars, overflows). It is meant to be used in
- * applications designed for hostile environments. It returns zero when the
- * number has successfully been converted, non-zero otherwise. When an error
- * is returned, the <ret> value is left untouched. It is about 3 times slower
- * than str2irc().
- */
-#ifndef LLONG_MAX
-#define LLONG_MAX 9223372036854775807LL
-#define LLONG_MIN (-LLONG_MAX - 1LL)
-#endif
-
-int strl2llrc(const char *s, int len, long long *ret)
-{
-	long long i = 0;
-	int j;
-
-	if (!len)
-		return 1;
-
-	if (*s != '-') {
-		/* positive number */
-		while (len-- > 0) {
-			j = (*s++) - '0';
-			if (j > 9)              return 1; /* invalid char */
-			if (i > LLONG_MAX / 10LL) return 1; /* check for multiply overflow */
-			i = i * 10LL;
-			if (i + j < i)          return 1; /* check for addition overflow */
-			i = i + j;
-		}
-	} else {
-		/* negative number */
-		s++;
-		while (--len > 0) {
-			j = (*s++) - '0';
-			if (j > 9)              return 1; /* invalid char */
-			if (i < LLONG_MIN / 10LL) return 1; /* check for multiply overflow */
-			i = i * 10LL;
-			if (i - j > i)          return 1; /* check for subtract overflow */
-			i = i - j;
-		}
-	}
-	*ret = i;
-	return 0;
-}
-
-/* This function parses a time value optionally followed by a unit suffix among
- * "d", "h", "m", "s", "ms" or "us". It converts the value into the unit
- * expected by the caller. The computation does its best to avoid overflows.
- * The value is returned in <ret> if everything is fine, and a NULL is returned
- * by the function. In case of error, a pointer to the error is returned and
- * <ret> is left untouched. Values are automatically rounded up when needed.
- */
-const char *parse_time_err(const char *text, unsigned *ret, unsigned unit_flags)
-{
-	unsigned imult, idiv;
-	unsigned omult, odiv;
-	unsigned value;
-
-	omult = odiv = 1;
-
-	switch (unit_flags & TIME_UNIT_MASK) {
-	case TIME_UNIT_US:   omult = 1000000; break;
-	case TIME_UNIT_MS:   omult = 1000; break;
-	case TIME_UNIT_S:    break;
-	case TIME_UNIT_MIN:  odiv = 60; break;
-	case TIME_UNIT_HOUR: odiv = 3600; break;
-	case TIME_UNIT_DAY:  odiv = 86400; break;
-	default: break;
-	}
-
-	value = 0;
-
-	while (1) {
-		unsigned int j;
-
-		j = *text - '0';
-		if (j > 9)
-			break;
-		text++;
-		value *= 10;
-		value += j;
-	}
-
-	imult = idiv = 1;
-	switch (*text) {
-	case '\0': /* no unit = default unit */
-		imult = omult = idiv = odiv = 1;
-		break;
-	case 's': /* second = unscaled unit */
-		break;
-	case 'u': /* microsecond : "us" */
-		if (text[1] == 's') {
-			idiv = 1000000;
-			text++;
-		}
-		break;
-	case 'm': /* millisecond : "ms" or minute: "m" */
-		if (text[1] == 's') {
-			idiv = 1000;
-			text++;
-		} else
-			imult = 60;
-		break;
-	case 'h': /* hour : "h" */
-		imult = 3600;
-		break;
-	case 'd': /* day : "d" */
-		imult = 86400;
-		break;
-	default:
-		return text;
-		break;
-	}
-
-	if (omult % idiv == 0) { omult /= idiv; idiv = 1; }
-	if (idiv % omult == 0) { idiv /= omult; omult = 1; }
-	if (imult % odiv == 0) { imult /= odiv; odiv = 1; }
-	if (odiv % imult == 0) { odiv /= imult; imult = 1; }
-
-	value = (value * (imult * omult) + (idiv * odiv - 1)) / (idiv * odiv);
-	*ret = value;
-	return NULL;
-}
-
-/* this function converts the string starting at <text> to an unsigned int
- * stored in <ret>. If an error is detected, the pointer to the unexpected
- * character is returned. If the conversio is succesful, NULL is returned.
- */
-const char *parse_size_err(const char *text, unsigned *ret) {
-	unsigned value = 0;
-
-	while (1) {
-		unsigned int j;
-
-		j = *text - '0';
-		if (j > 9)
-			break;
-		if (value > ~0U / 10)
-			return text;
-		value *= 10;
-		if (value > (value + j))
-			return text;
-		value += j;
-		text++;
-	}
-
-	switch (*text) {
-	case '\0':
-		break;
-	case 'K':
-	case 'k':
-		if (value > ~0U >> 10)
-			return text;
-		value = value << 10;
-		break;
-	case 'M':
-	case 'm':
-		if (value > ~0U >> 20)
-			return text;
-		value = value << 20;
-		break;
-	case 'G':
-	case 'g':
-		if (value > ~0U >> 30)
-			return text;
-		value = value << 30;
-		break;
-	default:
-		return text;
-	}
-
-	*ret = value;
-	return NULL;
-}
-
-/* copies at most <n> characters from <src> and always terminates with '\0' */
-char *my_strndup(const char *src, int n)
-{
-	int len = 0;
-	char *ret;
-
-	while (len < n && src[len])
-		len++;
-
-	ret = (char *)malloc(len + 1);
-	if (!ret)
-		return ret;
-	memcpy(ret, src, len);
-	ret[len] = '\0';
-	return ret;
-}
-
-/* This function returns the first unused key greater than or equal to <key> in
- * ID tree <root>. Zero is returned if no place is found.
- */
-unsigned int get_next_id(struct eb_root *root, unsigned int key)
-{
-	struct eb32_node *used;
-
-	do {
-		used = eb32_lookup_ge(root, key);
-		if (!used || used->key > key)
-			return key; /* key is available */
-		key++;
-	} while (key);
-	return key;
-}
-
-/* This function compares a sample word possibly followed by blanks to another
- * clean word. The compare is case-insensitive. 1 is returned if both are equal,
- * otherwise zero. This intends to be used when checking HTTP headers for some
- * values. Note that it validates a word followed only by blanks but does not
- * validate a word followed by blanks then other chars.
- */
-int word_match(const char *sample, int slen, const char *word, int wlen)
-{
-	if (slen < wlen)
-		return 0;
-
-	while (wlen) {
-		char c = *sample ^ *word;
-		if (c && c != ('A' ^ 'a'))
-			return 0;
-		sample++;
-		word++;
-		slen--;
-		wlen--;
-	}
-
-	while (slen) {
-		if (*sample != ' ' && *sample != '\t')
-			return 0;
-		sample++;
-		slen--;
-	}
-	return 1;
-}
-
-/* Converts any text-formatted IPv4 address to a host-order IPv4 address. It
- * is particularly fast because it avoids expensive operations such as
- * multiplies, which are optimized away at the end. It requires a properly
- * formated address though (3 points).
- */
-unsigned int inetaddr_host(const char *text)
-{
-	const unsigned int ascii_zero = ('0' << 24) | ('0' << 16) | ('0' << 8) | '0';
-	register unsigned int dig100, dig10, dig1;
-	int s;
-	const char *p, *d;
-
-	dig1 = dig10 = dig100 = ascii_zero;
-	s = 24;
-
-	p = text;
-	while (1) {
-		if (((unsigned)(*p - '0')) <= 9) {
-			p++;
-			continue;
-		}
-
-		/* here, we have a complete byte between <text> and <p> (exclusive) */
-		if (p == text)
-			goto end;
-
-		d = p - 1;
-		dig1   |= (unsigned int)(*d << s);
-		if (d == text)
-			goto end;
-
-		d--;
-		dig10  |= (unsigned int)(*d << s);
-		if (d == text)
-			goto end;
-
-		d--;
-		dig100 |= (unsigned int)(*d << s);
-	end:
-		if (!s || *p != '.')
-			break;
-
-		s -= 8;
-		text = ++p;
-	}
-
-	dig100 -= ascii_zero;
-	dig10  -= ascii_zero;
-	dig1   -= ascii_zero;
-	return ((dig100 * 10) + dig10) * 10 + dig1;
-}
-
-/*
- * Idem except the first unparsed character has to be passed in <stop>.
- */
-unsigned int inetaddr_host_lim(const char *text, const char *stop)
-{
-	const unsigned int ascii_zero = ('0' << 24) | ('0' << 16) | ('0' << 8) | '0';
-	register unsigned int dig100, dig10, dig1;
-	int s;
-	const char *p, *d;
-
-	dig1 = dig10 = dig100 = ascii_zero;
-	s = 24;
-
-	p = text;
-	while (1) {
-		if (((unsigned)(*p - '0')) <= 9 && p < stop) {
-			p++;
-			continue;
-		}
-
-		/* here, we have a complete byte between <text> and <p> (exclusive) */
-		if (p == text)
-			goto end;
-
-		d = p - 1;
-		dig1   |= (unsigned int)(*d << s);
-		if (d == text)
-			goto end;
-
-		d--;
-		dig10  |= (unsigned int)(*d << s);
-		if (d == text)
-			goto end;
-
-		d--;
-		dig100 |= (unsigned int)(*d << s);
-	end:
-		if (!s || p == stop || *p != '.')
-			break;
-
-		s -= 8;
-		text = ++p;
-	}
-
-	dig100 -= ascii_zero;
-	dig10  -= ascii_zero;
-	dig1   -= ascii_zero;
-	return ((dig100 * 10) + dig10) * 10 + dig1;
-}
-
-/*
- * Idem except the pointer to first unparsed byte is returned into <ret> which
- * must not be NULL.
- */
-unsigned int inetaddr_host_lim_ret(const char *text, char *stop, const char **ret)
-{
-	const unsigned int ascii_zero = ('0' << 24) | ('0' << 16) | ('0' << 8) | '0';
-	register unsigned int dig100, dig10, dig1;
-	int s;
-	const char *p, *d;
-
-	dig1 = dig10 = dig100 = ascii_zero;
-	s = 24;
-
-	p = text;
-	while (1) {
-		if (((unsigned)(*p - '0')) <= 9 && p < stop) {
-			p++;
-			continue;
-		}
-
-		/* here, we have a complete byte between <text> and <p> (exclusive) */
-		if (p == text)
-			goto end;
-
-		d = p - 1;
-		dig1   |= (unsigned int)(*d << s);
-		if (d == text)
-			goto end;
-
-		d--;
-		dig10  |= (unsigned int)(*d << s);
-		if (d == text)
-			goto end;
-
-		d--;
-		dig100 |= (unsigned int)(*d << s);
-	end:
-		if (!s || p == stop || *p != '.')
-			break;
-
-		s -= 8;
-		text = ++p;
-	}
-
-	*ret = p;
-	dig100 -= ascii_zero;
-	dig10  -= ascii_zero;
-	dig1   -= ascii_zero;
-	return ((dig100 * 10) + dig10) * 10 + dig1;
-}
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/stick_table.c b/deps/haproxy-1.4.21/src/stick_table.c
deleted file mode 100644
index 0d70e32..0000000
--- a/deps/haproxy-1.4.21/src/stick_table.c
+++ /dev/null
@@ -1,334 +0,0 @@
-/*
- * Stick tables management functions.
- *
- * Copyright 2009-2010 EXCELIANCE, Emeric Brun <ebrun@exceliance.fr>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <string.h>
-
-#include <common/config.h>
-#include <common/memory.h>
-#include <common/mini-clist.h>
-#include <common/standard.h>
-#include <common/time.h>
-
-#include <ebmbtree.h>
-#include <ebsttree.h>
-
-#include <types/stick_table.h>
-
-#include <proto/proxy.h>
-#include <proto/session.h>
-#include <proto/task.h>
-
-
-/*
- * Free an allocate sticked session <ts>.
- * Decrease table <t> sticked session counter .
- */
-void stksess_free(struct stktable *t, struct stksess *ts)
-{
-	t->current--;
-	pool_free2(t->pool,ts);
-}
-
-/*
- * Init or modify <key> of th sticked session <ts> present in table <t>.
- */
-void stksess_key(struct stktable *t, struct stksess *ts, struct stktable_key *key)
-{
-	if (t->type != STKTABLE_TYPE_STRING)
-		memcpy(ts->keys.key, key->key , t->key_size);
-	else {
-		memcpy(ts->keys.key, key->key, MIN(t->key_size - 1, key->key_len));
-		ts->keys.key[MIN(t->key_size - 1, key->key_len)] = 0;
-	}
-}
-
-
-/*
- * Init sticked session <ts> using <key>.
- */
-struct stksess *stksess_init(struct stktable *t, struct stksess * ts, struct stktable_key *key)
-{
-	ts->keys.node.leaf_p = NULL;
-	ts->exps.node.leaf_p = NULL;
-	ts->sid = 0;
-	stksess_key(t, ts, key);
-
-	return ts;
-}
-
-/*
- * Trash oldest <to_batch> sticked sessions from table <t>
- * Returns number of trashed sticked session.
- */
-static int stktable_trash_oldest(struct stktable *t, int to_batch)
-{
-	struct stksess *ts;
-	struct eb32_node *eb;
-	int batched = 0;
-
-	eb = eb32_lookup_ge(&t->exps, now_ms - TIMER_LOOK_BACK);
-
-	while (batched < to_batch) {
-
-		if (unlikely(!eb)) {
-			/* we might have reached the end of the tree, typically because
-			 * <now_ms> is in the first half and we're first scanning the last
-			 * half. Let's loop back to the beginning of the tree now.
-			 */
-			eb = eb32_first(&t->exps);
-			if (likely(!eb))
-				break;
-		}
-
-		/* timer looks expired, detach it from the queue */
-		ts = eb32_entry(eb, struct stksess, exps);
-		eb = eb32_next(eb);
-
-		eb32_delete(&ts->exps);
-
-		if (ts->expire != ts->exps.key) {
-
-			if (!tick_isset(ts->expire))
-				continue;
-
-			ts->exps.key = ts->expire;
-
-			eb32_insert(&t->exps, &ts->exps);
-
-			if (!eb || eb->key > ts->exps.key)
-				eb = &ts->exps;
-
-			continue;
-		}
-		/* session expired, trash it */
-
-		ebmb_delete(&ts->keys);
-		stksess_free(t, ts);
-		batched++;
-	}
-
-	return batched;
-}
-
-/*
- *  Allocate and initialise a new sticked session.
- *  The new sticked session is returned or NULL in case of lack of memory.
- *  Sticked sessions should only be allocated this way, and must be
- *  freed using stksess_free().
- *  Increase table <t> sticked session counter.
- */
-struct stksess *stksess_new(struct stktable *t, struct stktable_key *key)
-{
-	struct stksess *ts;
-
-	if (unlikely(t->current == t->size)) {
-		if ( t->nopurge )
-			return NULL;
-
-		if (!stktable_trash_oldest(t, t->size >> 8))
-			return NULL;
-	}
-
-	ts = pool_alloc2(t->pool);
-	if (ts) {
-		t->current++;
-		stksess_init(t, ts, key);
-	}
-
-	return ts;
-}
-
-/*
- * Lookup in table <t> for a sticked session identified by <key>.
- * Returns pointer on requested sticked session or NULL if no one found.
- */
-struct stksess *stktable_lookup(struct stktable *t, struct stktable_key *key)
-{
-	struct ebmb_node *eb;
-
-	/* lookup on track session */
-	if (t->type == STKTABLE_TYPE_STRING)
-		eb = ebst_lookup_len(&t->keys, key->key, key->key_len);
-	else
-		eb = ebmb_lookup(&t->keys, key->key, t->key_size);
-
-	if (unlikely(!eb)) {
-		/* no session found */
-		return NULL;
-	}
-
-	/* Existing session, returns server id */
-	return ebmb_entry(eb, struct stksess, keys);
-}
-
-/*
- * Store sticked session if not present in table.
- * Il already present, update the existing session.
- */
-int stktable_store(struct stktable *t, struct stksess *tsess, int sid)
-{
-	struct stksess *ts;
-	struct ebmb_node *eb;
-
-	if (t->type == STKTABLE_TYPE_STRING)
-		eb = ebst_lookup(&(t->keys), (char *)tsess->keys.key);
-	else
-		eb = ebmb_lookup(&(t->keys), tsess->keys.key, t->key_size);
-
-	if (unlikely(!eb)) {
-		tsess->sid = sid;
-		ebmb_insert(&t->keys, &tsess->keys, t->key_size);
-
-		tsess->exps.key = tsess->expire = tick_add(now_ms, MS_TO_TICKS(t->expire));
-		eb32_insert(&t->exps, &tsess->exps);
-
-		if (t->expire) {
-			t->exp_task->expire = t->exp_next = tick_first(tsess->expire, t->exp_next);
-			task_queue(t->exp_task);
-		}
-		return 0;
-	}
-
-	/* Existing track session */
-	ts = ebmb_entry(eb, struct stksess, keys);
-
-	if ( ts->sid != sid )
-		ts->sid = sid;
-	return 1;
-}
-
-/*
- * Trash expired sticked sessions from table <t>.
- */
-static int stktable_trash_expired(struct stktable *t)
-{
-	struct stksess *ts;
-	struct eb32_node *eb;
-
-	eb = eb32_lookup_ge(&t->exps, now_ms - TIMER_LOOK_BACK);
-
-	while (1) {
-		if (unlikely(!eb)) {
-			/* we might have reached the end of the tree, typically because
-			 * <now_ms> is in the first half and we're first scanning the last
-			 * half. Let's loop back to the beginning of the tree now.
-			 */
-			eb = eb32_first(&t->exps);
-			if (likely(!eb))
-				break;
-		}
-
-		if (likely(tick_is_lt(now_ms, eb->key))) {
-			/* timer not expired yet, revisit it later */
-			t->exp_next = eb->key;
-			return t->exp_next;
-		}
-
-		/* timer looks expired, detach it from the queue */
-		ts = eb32_entry(eb, struct stksess, exps);
-		eb = eb32_next(eb);
-
-		eb32_delete(&ts->exps);
-
-		if (!tick_is_expired(ts->expire, now_ms)) {
-			if (!tick_isset(ts->expire))
-				continue;
-
-			ts->exps.key = ts->expire;
-			eb32_insert(&t->exps, &ts->exps);
-
-			if (!eb || eb->key > ts->exps.key)
-				eb = &ts->exps;
-			continue;
-		}
-
-		/* session expired, trash it */
-		ebmb_delete(&ts->keys);
-		stksess_free(t, ts);
-	}
-
-	/* We have found no task to expire in any tree */
-	t->exp_next = TICK_ETERNITY;
-	return t->exp_next;
-}
-
-/*
- * Task processing function to trash expired sticked sessions.
- */
-static struct task *process_table_expire(struct task * task)
-{
-	struct stktable *t = (struct stktable *)task->context;
-
-	task->expire = stktable_trash_expired(t);
-	return task;
-}
-
-/* Perform minimal intializations, report 0 in case of error, 1 if OK. */
-int stktable_init(struct stktable *t)
-{
-	if (t->size) {
-		memset(&t->keys, 0, sizeof(t->keys));
-		memset(&t->exps, 0, sizeof(t->exps));
-
-		t->pool = create_pool("sticktables", sizeof(struct stksess) + t->key_size, MEM_F_SHARED);
-
-		t->exp_next = TICK_ETERNITY;
-		if ( t->expire ) {
-			t->exp_task = task_new();
-			t->exp_task->process = process_table_expire;
-			t->exp_task->expire = TICK_ETERNITY;
-			t->exp_task->context = (void *)t;
-		}
-		return t->pool != NULL;
-	}
-	return 1;
-}
-
-/*
- * Configuration keywords of known table types
- */
-struct stktable_type stktable_types[STKTABLE_TYPES] = { { "ip", 0, 4 } ,
-						        { "integer", 0, 4 },
-						        { "string", STKTABLE_TYPEFLAG_CUSTOMKEYSIZE, 32 } };
-
-
-/*
- * Parse table type configuration.
- * Returns 0 on successful parsing, else 1.
- * <myidx> is set at next configuration <args> index.
- */
-int stktable_parse_type(char **args, int *myidx, unsigned long *type, size_t *key_size)
-{
-	for (*type = 0; *type < STKTABLE_TYPES; (*type)++) {
-		if (strcmp(args[*myidx], stktable_types[*type].kw) != 0)
-			continue;
-
-		*key_size =  stktable_types[*type].default_size;
-		(*myidx)++;
-
-		if (stktable_types[*type].flags & STKTABLE_TYPEFLAG_CUSTOMKEYSIZE) {
-			if (strcmp("len", args[*myidx]) == 0) {
-				(*myidx)++;
-				*key_size = atol(args[*myidx]);
-				if ( !*key_size )
-					break;
-				/* null terminated string needs +1 for '\0'. */
-				(*key_size)++;
-				(*myidx)++;
-			}
-		}
-		return 0;
-	}
-	return 1;
-}
-
-
diff --git a/deps/haproxy-1.4.21/src/stream_interface.c b/deps/haproxy-1.4.21/src/stream_interface.c
deleted file mode 100644
index 8d58737..0000000
--- a/deps/haproxy-1.4.21/src/stream_interface.c
+++ /dev/null
@@ -1,353 +0,0 @@
-/*
- * Functions managing stream_interface structures
- *
- * Copyright 2000-2009 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <errno.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdlib.h>
-
-#include <sys/socket.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-
-#include <common/compat.h>
-#include <common/config.h>
-#include <common/debug.h>
-#include <common/standard.h>
-#include <common/ticks.h>
-#include <common/time.h>
-
-#include <proto/buffers.h>
-#include <proto/client.h>
-#include <proto/fd.h>
-#include <proto/stream_interface.h>
-#include <proto/stream_sock.h>
-#include <proto/task.h>
-
-/*
- * This function only has to be called once after a wakeup event in case of
- * suspected timeout. It controls the stream interface timeouts and sets
- * si->flags accordingly. It does NOT close anything, as this timeout may
- * be used for any purpose. It returns 1 if the timeout fired, otherwise
- * zero.
- */
-int stream_int_check_timeouts(struct stream_interface *si)
-{
-	if (tick_is_expired(si->exp, now_ms)) {
-		si->flags |= SI_FL_EXP;
-		return 1;
-	}
-	return 0;
-}
-
-/* to be called only when in SI_ST_DIS with SI_FL_ERR */
-void stream_int_report_error(struct stream_interface *si)
-{
-	if (!si->err_type)
-		si->err_type = SI_ET_DATA_ERR;
-
-	si->ob->flags |= BF_WRITE_ERROR;
-	si->ib->flags |= BF_READ_ERROR;
-}
-
-/*
- * Returns a message to the client ; the connection is shut down for read,
- * and the request is cleared so that no server connection can be initiated.
- * The buffer is marked for read shutdown on the other side to protect the
- * message, and the buffer write is enabled. The message is contained in a
- * "chunk". If it is null, then an empty message is used. The reply buffer does
- * not need to be empty before this, and its contents will not be overwritten.
- * The primary goal of this function is to return error messages to a client.
- */
-void stream_int_retnclose(struct stream_interface *si, const struct chunk *msg)
-{
-	buffer_auto_read(si->ib);
-	buffer_abort(si->ib);
-	buffer_auto_close(si->ib);
-	buffer_erase(si->ib);
-
-	buffer_cut_tail(si->ob);
-	if (likely(msg && msg->len))
-		buffer_write(si->ob, msg->str, msg->len);
-
-	si->ob->wex = tick_add_ifset(now_ms, si->ob->wto);
-	buffer_auto_read(si->ob);
-	buffer_auto_close(si->ob);
-	buffer_shutr_now(si->ob);
-}
-
-/* default update function for scheduled tasks, not used for embedded tasks */
-void stream_int_update(struct stream_interface *si)
-{
-	DPRINTF(stderr, "%s: si=%p, si->state=%d ib->flags=%08x ob->flags=%08x\n",
-		__FUNCTION__,
-		si, si->state, si->ib->flags, si->ob->flags);
-
-	if (!(si->flags & SI_FL_DONT_WAKE) && si->owner)
-		task_wakeup(si->owner, TASK_WOKEN_IO);
-}
-
-/* default update function for embedded tasks, to be used at the end of the i/o handler */
-void stream_int_update_embedded(struct stream_interface *si)
-{
-	DPRINTF(stderr, "%s: si=%p, si->state=%d ib->flags=%08x ob->flags=%08x\n",
-		__FUNCTION__,
-		si, si->state, si->ib->flags, si->ob->flags);
-
-	if (si->state != SI_ST_EST)
-		return;
-
-	if ((si->ob->flags & (BF_OUT_EMPTY|BF_SHUTW|BF_HIJACK|BF_SHUTW_NOW)) == (BF_OUT_EMPTY|BF_SHUTW_NOW))
-		si->shutw(si);
-
-	if ((si->ob->flags & (BF_FULL|BF_SHUTW|BF_SHUTW_NOW|BF_HIJACK)) == 0)
-		si->flags |= SI_FL_WAIT_DATA;
-
-	/* we're almost sure that we need some space if the buffer is not
-	 * empty, even if it's not full, because the applets can't fill it.
-	 */
-	if ((si->ib->flags & (BF_SHUTR|BF_OUT_EMPTY|BF_DONT_READ)) == 0)
-		si->flags |= SI_FL_WAIT_ROOM;
-
-	if (si->ob->flags & BF_WRITE_ACTIVITY) {
-		if (tick_isset(si->ob->wex))
-			si->ob->wex = tick_add_ifset(now_ms, si->ob->wto);
-	}
-
-	if (si->ib->flags & BF_READ_ACTIVITY ||
-	    (si->ob->flags & BF_WRITE_ACTIVITY && !(si->flags & SI_FL_INDEP_STR))) {
-		if (tick_isset(si->ib->rex))
-			si->ib->rex = tick_add_ifset(now_ms, si->ib->rto);
-	}
-
-	if (likely((si->ob->flags & (BF_SHUTW|BF_WRITE_PARTIAL|BF_FULL|BF_DONT_READ)) == BF_WRITE_PARTIAL &&
-		   (si->ob->prod->flags & SI_FL_WAIT_ROOM)))
-		si->ob->prod->chk_rcv(si->ob->prod);
-
-	if (((si->ib->flags & (BF_READ_PARTIAL|BF_OUT_EMPTY)) == BF_READ_PARTIAL) &&
-	    (si->ib->cons->flags & SI_FL_WAIT_DATA))
-		si->ib->cons->chk_snd(si->ib->cons);
-
-	/* Note that we're trying to wake up in two conditions here :
-	 *  - special event, which needs the holder task attention
-	 *  - status indicating that the applet can go on working. This
-	 *    is rather hard because we might be blocking on output and
-	 *    don't want to wake up on input and vice-versa. The idea is
-	 *    the to only rely the changes the chk_* might have performed.
-	 */
-	if (/* check stream interface changes */
-	    (si->flags & SI_FL_ERR) || si->state != SI_ST_EST || si->ib->cons->state != SI_ST_EST ||
-	    /* check response buffer changes */
-	    (si->ib->flags & (BF_READ_NULL|BF_READ_ERROR|BF_READ_DONTWAIT)) ||
-	    ((si->ib->flags & BF_READ_ACTIVITY) && !si->ib->to_forward) ||
-	    (!(si->ib->flags & BF_FULL) && (si->ib->flags & BF_WRITE_ACTIVITY) && si->ib->to_forward) ||
-	    /* check request buffer changes */
-	    (si->ob->flags & (BF_WRITE_ERROR)) ||
-	    ((si->ob->flags & BF_WRITE_ACTIVITY) && (si->ob->flags & BF_OUT_EMPTY) && !si->ob->to_forward) ||
-	    (si->ob->flags & BF_READ_ACTIVITY)) {
-		if (!(si->flags & SI_FL_DONT_WAKE) && si->owner)
-			task_wakeup(si->owner, TASK_WOKEN_IO);
-	}
-}
-
-/* default shutr function for scheduled tasks */
-void stream_int_shutr(struct stream_interface *si)
-{
-	DPRINTF(stderr, "%s: si=%p, si->state=%d ib->flags=%08x ob->flags=%08x\n",
-		__FUNCTION__,
-		si, si->state, si->ib->flags, si->ob->flags);
-
-	si->ib->flags &= ~BF_SHUTR_NOW;
-	if (si->ib->flags & BF_SHUTR)
-		return;
-	si->ib->flags |= BF_SHUTR;
-	si->ib->rex = TICK_ETERNITY;
-	si->flags &= ~SI_FL_WAIT_ROOM;
-
-	if (si->state != SI_ST_EST && si->state != SI_ST_CON)
-		return;
-
-	if (si->ob->flags & BF_SHUTW) {
-		si->state = SI_ST_DIS;
-		si->exp = TICK_ETERNITY;
-	}
-
-	/* note that if the task exist, it must unregister itself once it runs */
-	if (!(si->flags & SI_FL_DONT_WAKE) && si->owner)
-		task_wakeup(si->owner, TASK_WOKEN_IO);
-}
-
-/* default shutw function for scheduled tasks */
-void stream_int_shutw(struct stream_interface *si)
-{
-	DPRINTF(stderr, "%s: si=%p, si->state=%d ib->flags=%08x ob->flags=%08x\n",
-		__FUNCTION__,
-		si, si->state, si->ib->flags, si->ob->flags);
-
-	si->ob->flags &= ~BF_SHUTW_NOW;
-	if (si->ob->flags & BF_SHUTW)
-		return;
-	si->ob->flags |= BF_SHUTW;
-	si->ob->wex = TICK_ETERNITY;
-	si->flags &= ~SI_FL_WAIT_DATA;
-
-	switch (si->state) {
-	case SI_ST_EST:
-		if (!(si->ib->flags & (BF_SHUTR|BF_DONT_READ)))
-			break;
-
-		/* fall through */
-	case SI_ST_CON:
-	case SI_ST_CER:
-	case SI_ST_QUE:
-	case SI_ST_TAR:
-		si->state = SI_ST_DIS;
-		/* fall through */
-	default:
-		si->flags &= ~SI_FL_WAIT_ROOM;
-		si->ib->flags |= BF_SHUTR;
-		si->ib->rex = TICK_ETERNITY;
-		si->exp = TICK_ETERNITY;
-	}
-
-	/* note that if the task exist, it must unregister itself once it runs */
-	if (!(si->flags & SI_FL_DONT_WAKE) && si->owner)
-		task_wakeup(si->owner, TASK_WOKEN_IO);
-}
-
-/* default chk_rcv function for scheduled tasks */
-void stream_int_chk_rcv(struct stream_interface *si)
-{
-	struct buffer *ib = si->ib;
-
-	DPRINTF(stderr, "%s: si=%p, si->state=%d ib->flags=%08x ob->flags=%08x\n",
-		__FUNCTION__,
-		si, si->state, si->ib->flags, si->ob->flags);
-
-	if (unlikely(si->state != SI_ST_EST || (ib->flags & BF_SHUTR)))
-		return;
-
-	if (ib->flags & (BF_FULL|BF_HIJACK|BF_DONT_READ)) {
-		/* stop reading */
-		if ((ib->flags & (BF_FULL|BF_HIJACK|BF_DONT_READ)) == BF_FULL)
-			si->flags |= SI_FL_WAIT_ROOM;
-	}
-	else {
-		/* (re)start reading */
-		si->flags &= ~SI_FL_WAIT_ROOM;
-		if (!(si->flags & SI_FL_DONT_WAKE) && si->owner)
-			task_wakeup(si->owner, TASK_WOKEN_IO);
-	}
-}
-
-/* default chk_snd function for scheduled tasks */
-void stream_int_chk_snd(struct stream_interface *si)
-{
-	struct buffer *ob = si->ob;
-
-	DPRINTF(stderr, "%s: si=%p, si->state=%d ib->flags=%08x ob->flags=%08x\n",
-		__FUNCTION__,
-		si, si->state, si->ib->flags, si->ob->flags);
-
-	if (unlikely(si->state != SI_ST_EST || (si->ob->flags & BF_SHUTW)))
-		return;
-
-	if (!(si->flags & SI_FL_WAIT_DATA) ||        /* not waiting for data */
-	    (ob->flags & BF_OUT_EMPTY))              /* called with nothing to send ! */
-		return;
-
-	/* Otherwise there are remaining data to be sent in the buffer,
-	 * so we tell the handler.
-	 */
-	si->flags &= ~SI_FL_WAIT_DATA;
-	if (!tick_isset(ob->wex))
-		ob->wex = tick_add_ifset(now_ms, ob->wto);
-
-	if (!(si->flags & SI_FL_DONT_WAKE) && si->owner)
-		task_wakeup(si->owner, TASK_WOKEN_IO);
-}
-
-/* Register a function to handle a stream_interface as part of the stream
- * interface's owner task, which is returned. The SI will wake it up everytime
- * it is solicited. The task's processing function must call the specified
- * function before returning. It must be deleted by the task handler using
- * stream_int_unregister_handler(), possibly from withing the function itself.
- */
-struct task *stream_int_register_handler(struct stream_interface *si,
-					 void (*fct)(struct stream_interface *))
-{
-	DPRINTF(stderr, "registering handler %p for si %p (was %p)\n", fct, si, si->owner);
-
-	si->update  = stream_int_update_embedded;
-	si->shutr   = stream_int_shutr;
-	si->shutw   = stream_int_shutw;
-	si->chk_rcv = stream_int_chk_rcv;
-	si->chk_snd = stream_int_chk_snd;
-	si->connect = NULL;
-	si->iohandler = fct;
-	si->flags |= SI_FL_WAIT_DATA;
-	return si->owner;
-}
-
-/* Register a function to handle a stream_interface as a standalone task. The
- * new task itself is returned and is assigned as si->owner. The stream_interface
- * pointer will be pointed to by the task's context. The handler can be detached
- * by using stream_int_unregister_handler().
- */
-struct task *stream_int_register_handler_task(struct stream_interface *si,
-					      struct task *(*fct)(struct task *))
-{
-	struct task *t;
-
-	DPRINTF(stderr, "registering handler %p for si %p (was %p)\n", fct, si, si->owner);
-
-	si->update  = stream_int_update;
-	si->shutr   = stream_int_shutr;
-	si->shutw   = stream_int_shutw;
-	si->chk_rcv = stream_int_chk_rcv;
-	si->chk_snd = stream_int_chk_snd;
-	si->connect = NULL;
-	si->iohandler = NULL; /* not used when running as an external task */
-	si->flags |= SI_FL_WAIT_DATA;
-
-	t = task_new();
-	si->owner = t;
-	if (!t)
-		return t;
-	t->process = fct;
-	t->context = si;
-	task_wakeup(si->owner, TASK_WOKEN_INIT);
-
-	return t;
-}
-
-/* Unregister a stream interface handler. This must be called by the handler task
- * itself when it detects that it is in the SI_ST_DIS state. This function can
- * both detach standalone handlers and embedded handlers.
- */
-void stream_int_unregister_handler(struct stream_interface *si)
-{
-	if (!si->iohandler && si->owner) {
-		/* external handler : kill the task */
-		task_delete(si->owner);
-		task_free(si->owner);
-	}
-	si->iohandler = NULL;
-	si->owner = NULL;
-}
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/stream_sock.c b/deps/haproxy-1.4.21/src/stream_sock.c
deleted file mode 100644
index 858f8ef..0000000
--- a/deps/haproxy-1.4.21/src/stream_sock.c
+++ /dev/null
@@ -1,1136 +0,0 @@
-/*
- * Functions operating on SOCK_STREAM and buffers.
- *
- * Copyright 2000-2009 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#define _GNU_SOURCE
-#include <errno.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdlib.h>
-
-#include <sys/socket.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-
-#include <netinet/tcp.h>
-
-#include <common/compat.h>
-#include <common/config.h>
-#include <common/debug.h>
-#include <common/standard.h>
-#include <common/ticks.h>
-#include <common/time.h>
-
-#include <proto/buffers.h>
-#include <proto/client.h>
-#include <proto/fd.h>
-#include <proto/pipe.h>
-#include <proto/protocols.h>
-#include <proto/stream_sock.h>
-#include <proto/task.h>
-
-#include <types/global.h>
-
-/* On recent Linux kernels, the splice() syscall may be used for faster data copy.
- * But it's not always defined on some OS versions, and it even happens that some
- * definitions are wrong with some glibc due to an offset bug in syscall().
- */
-
-#if defined(CONFIG_HAP_LINUX_SPLICE)
-#include <unistd.h>
-#include <sys/syscall.h>
-
-#ifndef SPLICE_F_MOVE
-#define SPLICE_F_MOVE           0x1
-#endif
-
-#ifndef SPLICE_F_NONBLOCK
-#define SPLICE_F_NONBLOCK       0x2
-#endif
-
-#ifndef SPLICE_F_MORE
-#define SPLICE_F_MORE           0x4
-#endif
-
-#ifndef __NR_splice
-#if defined(__powerpc__) || defined(__powerpc64__)
-#define __NR_splice             283
-#elif defined(__sparc__) || defined(__sparc64__)
-#define __NR_splice             232
-#elif defined(__x86_64__)
-#define __NR_splice             275
-#elif defined(__alpha__)
-#define __NR_splice             468
-#elif defined (__i386__)
-#define __NR_splice             313
-#else
-#warning unsupported architecture, guessing __NR_splice=313 like x86...
-#define __NR_splice             313
-#endif /* $arch */
-
-_syscall6(int, splice, int, fdin, loff_t *, off_in, int, fdout, loff_t *, off_out, size_t, len, unsigned long, flags)
-
-#endif /* __NR_splice */
-
-/* A pipe contains 16 segments max, and it's common to see segments of 1448 bytes
- * because of timestamps. Use this as a hint for not looping on splice().
- */
-#define SPLICE_FULL_HINT	16*1448
-
-/* how many data we attempt to splice at once when the buffer is configured for
- * infinite forwarding */
-#define MAX_SPLICE_AT_ONCE	(1<<30)
-
-/* Returns :
- *   -1 if splice is not possible or not possible anymore and we must switch to
- *      user-land copy (eg: to_forward reached)
- *    0 when we know that polling is required to get more data (EAGAIN)
- *    1 for all other cases (we can safely try again, or if an activity has been
- *      detected (DATA/NULL/ERR))
- * Sets :
- *   BF_READ_NULL
- *   BF_READ_PARTIAL
- *   BF_WRITE_PARTIAL (during copy)
- *   BF_OUT_EMPTY (during copy)
- *   SI_FL_ERR
- *   SI_FL_WAIT_ROOM
- *   (SI_FL_WAIT_RECV)
- *
- * This function automatically allocates a pipe from the pipe pool. It also
- * carefully ensures to clear b->pipe whenever it leaves the pipe empty.
- */
-static int stream_sock_splice_in(struct buffer *b, struct stream_interface *si)
-{
-	int fd = si->fd;
-	int ret;
-	unsigned long max;
-	int retval = 1;
-
-	if (!b->to_forward)
-		return -1;
-
-	if (!(b->flags & BF_KERN_SPLICING))
-		return -1;
-
-	if (b->l) {
-		/* We're embarrassed, there are already data pending in
-		 * the buffer and we don't want to have them at two
-		 * locations at a time. Let's indicate we need some
-		 * place and ask the consumer to hurry.
-		 */
-		si->flags |= SI_FL_WAIT_ROOM;
-		EV_FD_CLR(fd, DIR_RD);
-		b->rex = TICK_ETERNITY;
-		b->cons->chk_snd(b->cons);
-		return 1;
-	}
-
-	if (unlikely(b->pipe == NULL)) {
-		if (pipes_used >= global.maxpipes || !(b->pipe = get_pipe())) {
-			b->flags &= ~BF_KERN_SPLICING;
-			return -1;
-		}
-	}
-
-	/* At this point, b->pipe is valid */
-
-	while (1) {
-		if (b->to_forward == BUF_INFINITE_FORWARD)
-			max = MAX_SPLICE_AT_ONCE;
-		else
-			max = b->to_forward;
-
-		if (!max) {
-			/* It looks like the buffer + the pipe already contain
-			 * the maximum amount of data to be transferred. Try to
-			 * send those data immediately on the other side if it
-			 * is currently waiting.
-			 */
-			retval = -1; /* end of forwarding */
-			break;
-		}
-
-		ret = splice(fd, NULL, b->pipe->prod, NULL, max,
-			     SPLICE_F_MOVE|SPLICE_F_NONBLOCK);
-
-		if (ret <= 0) {
-			if (ret == 0) {
-				/* connection closed. This is only detected by
-				 * recent kernels (>= 2.6.27.13).
-				 */
-				b->flags |= BF_READ_NULL;
-				retval = 1; /* no need for further polling */
-				break;
-			}
-
-			if (errno == EAGAIN) {
-				/* there are two reasons for EAGAIN :
-				 *   - nothing in the socket buffer (standard)
-				 *   - pipe is full
-				 *   - the connection is closed (kernel < 2.6.27.13)
-				 * Since we don't know if pipe is full, we'll
-				 * stop if the pipe is not empty. Anyway, we
-				 * will almost always fill/empty the pipe.
-				 */
-
-				if (b->pipe->data) {
-					si->flags |= SI_FL_WAIT_ROOM;
-					retval = 1;
-					break;
-				}
-
-				/* We don't know if the connection was closed.
-				 * But if we're called upon POLLIN with an empty
-				 * pipe and get EAGAIN, it is suspect enought to
-				 * try to fall back to the normal recv scheme
-				 * which will be able to deal with the situation.
-				 */
-				retval = -1;
-				break;
-			}
-
-			if (errno == ENOSYS || errno == EINVAL) {
-				/* splice not supported on this end, disable it */
-				b->flags &= ~BF_KERN_SPLICING;
-				si->flags &= ~SI_FL_CAP_SPLICE;
-				put_pipe(b->pipe);
-				b->pipe = NULL;
-				return -1;
-			}
-
-			/* here we have another error */
-			si->flags |= SI_FL_ERR;
-			retval = 1;
-			break;
-		} /* ret <= 0 */
-
-		if (b->to_forward != BUF_INFINITE_FORWARD)
-			b->to_forward -= ret;
-		b->total += ret;
-		b->pipe->data += ret;
-		b->flags |= BF_READ_PARTIAL;
-		b->flags &= ~BF_OUT_EMPTY;
-
-		if (b->pipe->data >= SPLICE_FULL_HINT ||
-		    ret >= global.tune.recv_enough) {
-			/* We've read enough of it for this time. */
-			retval = 1;
-			break;
-		}
-	} /* while */
-
-	if (unlikely(!b->pipe->data)) {
-		put_pipe(b->pipe);
-		b->pipe = NULL;
-	}
-
-	return retval;
-}
-
-#endif /* CONFIG_HAP_LINUX_SPLICE */
-
-
-/*
- * this function is called on a read event from a stream socket.
- * It returns 0 if we have a high confidence that we will not be
- * able to read more data without polling first. Returns non-zero
- * otherwise.
- */
-int stream_sock_read(int fd) {
-	struct stream_interface *si = fdtab[fd].owner;
-	struct buffer *b = si->ib;
-	int ret, max, retval, cur_read;
-	int read_poll = MAX_READ_POLL_LOOPS;
-
-#ifdef DEBUG_FULL
-	fprintf(stderr,"stream_sock_read : fd=%d, ev=0x%02x, owner=%p\n", fd, fdtab[fd].ev, fdtab[fd].owner);
-#endif
-
-	retval = 1;
-
-	/* stop immediately on errors. Note that we DON'T want to stop on
-	 * POLL_ERR, as the poller might report a write error while there
-	 * are still data available in the recv buffer. This typically
-	 * happens when we send too large a request to a backend server
-	 * which rejects it before reading it all.
-	 */
-	if (fdtab[fd].state == FD_STERROR)
-		goto out_error;
-
-	/* stop here if we reached the end of data */
-	if ((fdtab[fd].ev & (FD_POLL_IN|FD_POLL_HUP)) == FD_POLL_HUP)
-		goto out_shutdown_r;
-
-	/* maybe we were called immediately after an asynchronous shutr */
-	if (b->flags & BF_SHUTR)
-		goto out_wakeup;
-
-#if defined(CONFIG_HAP_LINUX_SPLICE)
-	if (b->to_forward >= MIN_SPLICE_FORWARD && b->flags & BF_KERN_SPLICING) {
-
-		/* Under Linux, if FD_POLL_HUP is set, we have reached the end.
-		 * Since older splice() implementations were buggy and returned
-		 * EAGAIN on end of read, let's bypass the call to splice() now.
-		 */
-		if (fdtab[fd].ev & FD_POLL_HUP)
-			goto out_shutdown_r;
-
-		retval = stream_sock_splice_in(b, si);
-
-		if (retval >= 0) {
-			if (si->flags & SI_FL_ERR)
-				goto out_error;
-			if (b->flags & BF_READ_NULL)
-				goto out_shutdown_r;
-			goto out_wakeup;
-		}
-		/* splice not possible (anymore), let's go on on standard copy */
-	}
-#endif
-	cur_read = 0;
-	while (1) {
-		max = buffer_max_len(b) - b->l;
-
-		if (max <= 0) {
-			b->flags |= BF_FULL;
-			si->flags |= SI_FL_WAIT_ROOM;
-			break;
-		}
-
-		/*
-		 * 1. compute the maximum block size we can read at once.
-		 */
-		if (b->l == 0) {
-			/* let's realign the buffer to optimize I/O */
-			b->r = b->w = b->lr = b->data;
-		}
-		else if (b->r > b->w) {
-			/* remaining space wraps at the end, with a moving limit */
-			if (max > b->data + b->size - b->r)
-				max = b->data + b->size - b->r;
-		}
-		/* else max is already OK */
-
-		/*
-		 * 2. read the largest possible block
-		 */
-		ret = recv(fd, b->r, max, 0);
-
-		if (ret > 0) {
-			b->r += ret;
-			b->l += ret;
-			cur_read += ret;
-
-			/* if we're allowed to directly forward data, we must update send_max */
-			if (b->to_forward && !(b->flags & (BF_SHUTW|BF_SHUTW_NOW))) {
-				unsigned long fwd = ret;
-				if (b->to_forward != BUF_INFINITE_FORWARD) {
-					if (fwd > b->to_forward)
-						fwd = b->to_forward;
-					b->to_forward -= fwd;
-				}
-				b->send_max += fwd;
-				b->flags &= ~BF_OUT_EMPTY;
-			}
-
-			if (fdtab[fd].state == FD_STCONN) {
-				fdtab[fd].state = FD_STREADY;
-				si->exp = TICK_ETERNITY;
-			}
-
-			b->flags |= BF_READ_PARTIAL;
-
-			if (b->r == b->data + b->size) {
-				b->r = b->data; /* wrap around the buffer */
-			}
-
-			b->total += ret;
-
-			if (b->l >= buffer_max_len(b)) {
-				/* The buffer is now full, there's no point in going through
-				 * the loop again.
-				 */
-				if (!(b->flags & BF_STREAMER_FAST) && (cur_read == b->l)) {
-					b->xfer_small = 0;
-					b->xfer_large++;
-					if (b->xfer_large >= 3) {
-						/* we call this buffer a fast streamer if it manages
-						 * to be filled in one call 3 consecutive times.
-						 */
-						b->flags |= (BF_STREAMER | BF_STREAMER_FAST);
-						//fputc('+', stderr);
-					}
-				}
-				else if ((b->flags & (BF_STREAMER | BF_STREAMER_FAST)) &&
-					 (cur_read <= b->size / 2)) {
-					b->xfer_large = 0;
-					b->xfer_small++;
-					if (b->xfer_small >= 2) {
-						/* if the buffer has been at least half full twice,
-						 * we receive faster than we send, so at least it
-						 * is not a "fast streamer".
-						 */
-						b->flags &= ~BF_STREAMER_FAST;
-						//fputc('-', stderr);
-					}
-				}
-				else {
-					b->xfer_small = 0;
-					b->xfer_large = 0;
-				}
-
-				b->flags |= BF_FULL;
-				si->flags |= SI_FL_WAIT_ROOM;
-				break;
-			}
-
-			/* if too many bytes were missing from last read, it means that
-			 * it's pointless trying to read again because the system does
-			 * not have them in buffers. BTW, if FD_POLL_HUP was present,
-			 * it means that we have reached the end and that the connection
-			 * is closed.
-			 */
-			if (ret < max) {
-				if ((b->flags & (BF_STREAMER | BF_STREAMER_FAST)) &&
-				    (cur_read <= b->size / 2)) {
-					b->xfer_large = 0;
-					b->xfer_small++;
-					if (b->xfer_small >= 3) {
-						/* we have read less than half of the buffer in
-						 * one pass, and this happened at least 3 times.
-						 * This is definitely not a streamer.
-						 */
-						b->flags &= ~(BF_STREAMER | BF_STREAMER_FAST);
-						//fputc('!', stderr);
-					}
-				}
-				/* unfortunately, on level-triggered events, POLL_HUP
-				 * is generally delivered AFTER the system buffer is
-				 * empty, so this one might never match.
-				 */
-				if (fdtab[fd].ev & FD_POLL_HUP)
-					goto out_shutdown_r;
-
-				/* if a streamer has read few data, it may be because we
-				 * have exhausted system buffers. It's not worth trying
-				 * again.
-				 */
-				if (b->flags & BF_STREAMER)
-					break;
-
-				/* generally if we read something smaller than 1 or 2 MSS,
-				 * it means that either we have exhausted the system's
-				 * buffers (streamer or question-response protocol) or
-				 * that the connection will be closed. Streamers are
-				 * easily detected so we return early. For other cases,
-				 * it's still better to perform a last read to be sure,
-				 * because it may save one complete poll/read/wakeup cycle
-				 * in case of shutdown.
-				 */
-				if (ret < MIN_RET_FOR_READ_LOOP && b->flags & BF_STREAMER)
-					break;
-
-				/* if we read a large block smaller than what we requested,
-				 * it's almost certain we'll never get anything more.
-				 */
-				if (ret >= global.tune.recv_enough)
-					break;
-			}
-
-			if ((b->flags & BF_READ_DONTWAIT) || --read_poll <= 0)
-				break;
-		}
-		else if (ret == 0) {
-			/* connection closed */
-			goto out_shutdown_r;
-		}
-		else if (errno == EAGAIN) {
-			/* Ignore EAGAIN but inform the poller that there is
-			 * nothing to read left if we did not read much, ie
-			 * less than what we were still expecting to read.
-			 * But we may have done some work justifying to notify
-			 * the task.
-			 */
-			if (cur_read < MIN_RET_FOR_READ_LOOP)
-				retval = 0;
-			break;
-		}
-		else {
-			goto out_error;
-		}
-	} /* while (1) */
-
- out_wakeup:
-	/* We might have some data the consumer is waiting for.
-	 * We can do fast-forwarding, but we avoid doing this for partial
-	 * buffers, because it is very likely that it will be done again
-	 * immediately afterwards once the following data is parsed (eg:
-	 * HTTP chunking).
-	 */
-	if ((b->pipe || b->send_max == b->l)
-	    && (b->cons->flags & SI_FL_WAIT_DATA)) {
-		int last_len = b->pipe ? b->pipe->data : 0;
-
-		b->cons->chk_snd(b->cons);
-
-		/* check if the consumer has freed some space */
-		if (!(b->flags & BF_FULL) &&
-		    (!last_len || !b->pipe || b->pipe->data < last_len))
-			si->flags &= ~SI_FL_WAIT_ROOM;
-	}
-
-	if (si->flags & SI_FL_WAIT_ROOM) {
-		EV_FD_CLR(fd, DIR_RD);
-		b->rex = TICK_ETERNITY;
-	}
-	else if ((b->flags & (BF_SHUTR|BF_READ_PARTIAL|BF_FULL|BF_DONT_READ|BF_READ_NOEXP)) == BF_READ_PARTIAL)
-		b->rex = tick_add_ifset(now_ms, b->rto);
-
-	/* we have to wake up if there is a special event or if we don't have
-	 * any more data to forward.
-	 */
-	if ((b->flags & (BF_READ_NULL|BF_READ_ERROR|BF_SHUTR|BF_READ_DONTWAIT)) ||
-	    !b->to_forward ||
-	    si->state != SI_ST_EST ||
-	    b->cons->state != SI_ST_EST ||
-	    (si->flags & SI_FL_ERR))
-		task_wakeup(si->owner, TASK_WOKEN_IO);
-	
-	b->flags &= ~BF_READ_DONTWAIT;
-	fdtab[fd].ev &= ~FD_POLL_IN;
-	return retval;
-
- out_shutdown_r:
-	/* we received a shutdown */
-	fdtab[fd].ev &= ~FD_POLL_HUP;
-	b->flags |= BF_READ_NULL;
-	if (b->flags & BF_AUTO_CLOSE)
-		buffer_shutw_now(b);
-	stream_sock_shutr(si);
-	goto out_wakeup;
-
- out_error:
-	/* Read error on the file descriptor. We mark the FD as STERROR so
-	 * that we don't use it anymore. The error is reported to the stream
-	 * interface which will take proper action. We must not perturbate the
-	 * buffer because the stream interface wants to ensure transparent
-	 * connection retries.
-	 */
-
-	fdtab[fd].state = FD_STERROR;
-	fdtab[fd].ev &= ~FD_POLL_STICKY;
-	EV_FD_REM(fd);
-	si->flags |= SI_FL_ERR;
-	retval = 1;
-	goto out_wakeup;
-}
-
-
-/*
- * This function is called to send buffer data to a stream socket.
- * It returns -1 in case of unrecoverable error, 0 if the caller needs to poll
- * before calling it again, otherwise 1. If a pipe was associated with the
- * buffer and it empties it, it releases it as well.
- */
-static int stream_sock_write_loop(struct stream_interface *si, struct buffer *b)
-{
-	int write_poll = MAX_WRITE_POLL_LOOPS;
-	int retval = 1;
-	int ret, max;
-
-#if defined(CONFIG_HAP_LINUX_SPLICE)
-	while (b->pipe) {
-		ret = splice(b->pipe->cons, NULL, si->fd, NULL, b->pipe->data,
-			     SPLICE_F_MOVE|SPLICE_F_NONBLOCK);
-		if (ret <= 0) {
-			if (ret == 0 || errno == EAGAIN) {
-				retval = 0;
-				return retval;
-			}
-			/* here we have another error */
-			retval = -1;
-			return retval;
-		}
-
-		b->flags |= BF_WRITE_PARTIAL;
-		b->pipe->data -= ret;
-
-		if (!b->pipe->data) {
-			put_pipe(b->pipe);
-			b->pipe = NULL;
-			break;
-		}
-
-		if (--write_poll <= 0)
-			return retval;
-	}
-
-	/* At this point, the pipe is empty, but we may still have data pending
-	 * in the normal buffer.
-	 */
-#endif
-	if (!b->send_max) {
-		b->flags |= BF_OUT_EMPTY;
-		return retval;
-	}
-
-	/* when we're in this loop, we already know that there is no spliced
-	 * data left, and that there are sendable buffered data.
-	 */
-	while (1) {
-		if (b->r > b->w)
-			max = b->r - b->w;
-		else
-			max = b->data + b->size - b->w;
-
-		/* limit the amount of outgoing data if required */
-		if (max > b->send_max)
-			max = b->send_max;
-
-		/* check if we want to inform the kernel that we're interested in
-		 * sending more data after this call. We want this if :
-		 *  - we're about to close after this last send and want to merge
-		 *    the ongoing FIN with the last segment.
-		 *  - we know we can't send everything at once and must get back
-		 *    here because of unaligned data
-		 *  - there is still a finite amount of data to forward
-		 * The test is arranged so that the most common case does only 2
-		 * tests.
-		 */
-
-		if (MSG_NOSIGNAL && MSG_MORE) {
-			unsigned int send_flag = MSG_DONTWAIT | MSG_NOSIGNAL;
-
-			if ((!(b->flags & BF_NEVER_WAIT) &&
-			    ((b->to_forward && b->to_forward != BUF_INFINITE_FORWARD) ||
-			     (b->flags & BF_EXPECT_MORE))) ||
-			    ((b->flags & (BF_SHUTW|BF_SHUTW_NOW|BF_HIJACK)) == BF_SHUTW_NOW && (max == b->send_max)) ||
-			    (max != b->l && max != b->send_max)) {
-				send_flag |= MSG_MORE;
-			}
-
-			/* this flag has precedence over the rest */
-			if (b->flags & BF_SEND_DONTWAIT)
-				send_flag &= ~MSG_MORE;
-
-			ret = send(si->fd, b->w, max, send_flag);
-		} else {
-			int skerr;
-			socklen_t lskerr = sizeof(skerr);
-
-			ret = getsockopt(si->fd, SOL_SOCKET, SO_ERROR, &skerr, &lskerr);
-			if (ret == -1 || skerr)
-				ret = -1;
-			else
-				ret = send(si->fd, b->w, max, MSG_DONTWAIT);
-		}
-
-		if (ret > 0) {
-			if (fdtab[si->fd].state == FD_STCONN) {
-				fdtab[si->fd].state = FD_STREADY;
-				si->exp = TICK_ETERNITY;
-			}
-
-			b->flags |= BF_WRITE_PARTIAL;
-
-			b->w += ret;
-			if (b->w == b->data + b->size)
-				b->w = b->data; /* wrap around the buffer */
-
-			b->l -= ret;
-			if (likely(b->l < buffer_max_len(b)))
-				b->flags &= ~BF_FULL;
-
-			if (likely(!b->l))
-				/* optimize data alignment in the buffer */
-				b->r = b->w = b->lr = b->data;
-
-			b->send_max -= ret;
-			if (!b->send_max) {
-				/* Always clear both flags once everything has been sent, they're one-shot */
-				b->flags &= ~(BF_EXPECT_MORE | BF_SEND_DONTWAIT);
-				if (likely(!b->pipe))
-					b->flags |= BF_OUT_EMPTY;
-				break;
-			}
-
-			/* if the system buffer is full, don't insist */
-			if (ret < max)
-				break;
-
-			if (--write_poll <= 0)
-				break;
-		}
-		else if (ret == 0 || errno == EAGAIN) {
-			/* nothing written, we need to poll for write first */
-			retval = 0;
-			break;
-		}
-		else {
-			/* bad, we got an error */
-			retval = -1;
-			break;
-		}
-	} /* while (1) */
-
-	return retval;
-}
-
-
-/*
- * This function is called on a write event from a stream socket.
- * It returns 0 if the caller needs to poll before calling it again, otherwise
- * non-zero.
- */
-int stream_sock_write(int fd)
-{
-	struct stream_interface *si = fdtab[fd].owner;
-	struct buffer *b = si->ob;
-	int retval = 1;
-
-#ifdef DEBUG_FULL
-	fprintf(stderr,"stream_sock_write : fd=%d, owner=%p\n", fd, fdtab[fd].owner);
-#endif
-
-	retval = 1;
-	if (fdtab[fd].state == FD_STERROR)
-		goto out_error;
-
-	/* we might have been called just after an asynchronous shutw */
-	if (b->flags & BF_SHUTW)
-		goto out_wakeup;
-
-	if (likely(!(b->flags & BF_OUT_EMPTY))) {
-		/* OK there are data waiting to be sent */
-		retval = stream_sock_write_loop(si, b);
-		if (retval < 0)
-			goto out_error;
-	}
-	else  {
-		/* may be we have received a connection acknowledgement in TCP mode without data */
-		if (likely(fdtab[fd].state == FD_STCONN)) {
-			/* We have no data to send to check the connection, and
-			 * getsockopt() will not inform us whether the connection
-			 * is still pending. So we'll reuse connect() to check the
-			 * state of the socket. This has the advantage of givig us
-			 * the following info :
-			 *  - error
-			 *  - connecting (EALREADY, EINPROGRESS)
-			 *  - connected (EISCONN, 0)
-			 */
-			if ((connect(fd, fdinfo[fd].peeraddr, fdinfo[fd].peerlen) == 0))
-				errno = 0;
-
-			if (errno == EALREADY || errno == EINPROGRESS) {
-				retval = 0;
-				goto out_may_wakeup;
-			}
-
-			if (errno && errno != EISCONN)
-				goto out_error;
-
-			/* OK we just need to indicate that we got a connection
-			 * and that we wrote nothing.
-			 */
-			b->flags |= BF_WRITE_NULL;
-			fdtab[fd].state = FD_STREADY;
-			si->exp = TICK_ETERNITY;
-		}
-
-		/* Funny, we were called to write something but there wasn't
-		 * anything. We can get there, for example if we were woken up
-		 * on a write event to finish the splice, but the send_max is 0
-		 * so we cannot write anything from the buffer. Let's disable
-		 * the write event and pretend we never came there.
-		 */
-	}
-
-	if (b->flags & BF_OUT_EMPTY) {
-		/* the connection is established but we can't write. Either the
-		 * buffer is empty, or we just refrain from sending because the
-		 * send_max limit was reached. Maybe we just wrote the last
-		 * chunk and need to close.
-		 */
-		if (((b->flags & (BF_SHUTW|BF_HIJACK|BF_SHUTW_NOW)) == BF_SHUTW_NOW) &&
-		    (si->state == SI_ST_EST)) {
-			stream_sock_shutw(si);
-			goto out_wakeup;
-		}
-		
-		if ((b->flags & (BF_SHUTW|BF_SHUTW_NOW|BF_FULL|BF_HIJACK)) == 0)
-			si->flags |= SI_FL_WAIT_DATA;
-
-		EV_FD_CLR(fd, DIR_WR);
-		b->wex = TICK_ETERNITY;
-	}
-
- out_may_wakeup:
-	if (b->flags & BF_WRITE_ACTIVITY) {
-		/* update timeout if we have written something */
-		if ((b->flags & (BF_OUT_EMPTY|BF_SHUTW|BF_WRITE_PARTIAL)) == BF_WRITE_PARTIAL)
-			b->wex = tick_add_ifset(now_ms, b->wto);
-
-	out_wakeup:
-		if (tick_isset(si->ib->rex) && !(si->flags & SI_FL_INDEP_STR)) {
-			/* Note: to prevent the client from expiring read timeouts
-			 * during writes, we refresh it. We only do this if the
-			 * interface is not configured for "independant streams",
-			 * because for some applications it's better not to do this,
-			 * for instance when continuously exchanging small amounts
-			 * of data which can full the socket buffers long before a
-			 * write timeout is detected.
-			 */
-			si->ib->rex = tick_add_ifset(now_ms, si->ib->rto);
-		}
-
-		/* the producer might be waiting for more room to store data */
-		if (likely((b->flags & (BF_SHUTW|BF_WRITE_PARTIAL|BF_FULL|BF_DONT_READ)) == BF_WRITE_PARTIAL &&
-			   (b->prod->flags & SI_FL_WAIT_ROOM)))
-			b->prod->chk_rcv(b->prod);
-
-		/* we have to wake up if there is a special event or if we don't have
-		 * any more data to forward and it's not planned to send any more.
-		 */
-		if (likely((b->flags & (BF_WRITE_NULL|BF_WRITE_ERROR|BF_SHUTW)) ||
-			   ((b->flags & BF_OUT_EMPTY) && !b->to_forward) ||
-			   si->state != SI_ST_EST ||
-			   b->prod->state != SI_ST_EST))
-			task_wakeup(si->owner, TASK_WOKEN_IO);
-	}
-
-	fdtab[fd].ev &= ~FD_POLL_OUT;
-	return retval;
-
- out_error:
-	/* Write error on the file descriptor. We mark the FD as STERROR so
-	 * that we don't use it anymore. The error is reported to the stream
-	 * interface which will take proper action. We must not perturbate the
-	 * buffer because the stream interface wants to ensure transparent
-	 * connection retries.
-	 */
-
-	fdtab[fd].state = FD_STERROR;
-	fdtab[fd].ev &= ~FD_POLL_STICKY;
-	EV_FD_REM(fd);
-	si->flags |= SI_FL_ERR;
-	task_wakeup(si->owner, TASK_WOKEN_IO);
-	return 1;
-}
-
-/*
- * This function performs a shutdown-write on a stream interface in a connected or
- * init state (it does nothing for other states). It either shuts the write side
- * or closes the file descriptor and marks itself as closed. The buffer flags are
- * updated to reflect the new state. It does also close everything is the SI was
- * marked as being in error state.
- */
-void stream_sock_shutw(struct stream_interface *si)
-{
-	si->ob->flags &= ~BF_SHUTW_NOW;
-	if (si->ob->flags & BF_SHUTW)
-		return;
-	si->ob->flags |= BF_SHUTW;
-	si->ob->wex = TICK_ETERNITY;
-	si->flags &= ~SI_FL_WAIT_DATA;
-
-	switch (si->state) {
-	case SI_ST_EST:
-		/* we have to shut before closing, otherwise some short messages
-		 * may never leave the system, especially when there are remaining
-		 * unread data in the socket input buffer, or when nolinger is set.
-		 * However, if SI_FL_NOLINGER is explicitly set, we know there is
-		 * no risk so we close both sides immediately.
-		 */
-		if (si->flags & SI_FL_ERR) {
-			/* quick close, the socket is already shut. Remove pending flags. */
-			si->flags &= ~SI_FL_NOLINGER;
-		} else if (si->flags & SI_FL_NOLINGER) {
-			si->flags &= ~SI_FL_NOLINGER;
-			setsockopt(si->fd, SOL_SOCKET, SO_LINGER,
-				   (struct linger *) &nolinger, sizeof(struct linger));
-		} else {
-			EV_FD_CLR(si->fd, DIR_WR);
-			shutdown(si->fd, SHUT_WR);
-
-			if (!(si->ib->flags & (BF_SHUTR|BF_DONT_READ)))
-				return;
-		}
-
-		/* fall through */
-	case SI_ST_CON:
-		/* we may have to close a pending connection, and mark the
-		 * response buffer as shutr
-		 */
-		fd_delete(si->fd);
-		/* fall through */
-	case SI_ST_CER:
-	case SI_ST_QUE:
-	case SI_ST_TAR:
-		si->state = SI_ST_DIS;
-	default:
-		si->flags &= ~SI_FL_WAIT_ROOM;
-		si->ib->flags |= BF_SHUTR;
-		si->ib->rex = TICK_ETERNITY;
-		si->exp = TICK_ETERNITY;
-		return;
-	}
-}
-
-/*
- * This function performs a shutdown-read on a stream interface in a connected or
- * init state (it does nothing for other states). It either shuts the read side
- * or closes the file descriptor and marks itself as closed. The buffer flags are
- * updated to reflect the new state.
- */
-void stream_sock_shutr(struct stream_interface *si)
-{
-	si->ib->flags &= ~BF_SHUTR_NOW;
-	if (si->ib->flags & BF_SHUTR)
-		return;
-	si->ib->flags |= BF_SHUTR;
-	si->ib->rex = TICK_ETERNITY;
-	si->flags &= ~SI_FL_WAIT_ROOM;
-
-	if (si->state != SI_ST_EST && si->state != SI_ST_CON)
-		return;
-
-	if (si->ob->flags & BF_SHUTW) {
-		fd_delete(si->fd);
-		si->state = SI_ST_DIS;
-		si->exp = TICK_ETERNITY;
-		return;
-	}
-	EV_FD_CLR(si->fd, DIR_RD);
-	return;
-}
-
-/*
- * Updates a connected stream_sock file descriptor status and timeouts
- * according to the buffers' flags. It should only be called once after the
- * buffer flags have settled down, and before they are cleared. It doesn't
- * harm to call it as often as desired (it just slightly hurts performance).
- */
-void stream_sock_data_finish(struct stream_interface *si)
-{
-	struct buffer *ib = si->ib;
-	struct buffer *ob = si->ob;
-	int fd = si->fd;
-
-	DPRINTF(stderr,"[%u] %s: fd=%d owner=%p ib=%p, ob=%p, exp(r,w)=%u,%u ibf=%08x obf=%08x ibl=%d obl=%d si=%d\n",
-		now_ms, __FUNCTION__,
-		fd, fdtab[fd].owner,
-		ib, ob,
-		ib->rex, ob->wex,
-		ib->flags, ob->flags,
-		ib->l, ob->l, si->state);
-
-	/* Check if we need to close the read side */
-	if (!(ib->flags & BF_SHUTR)) {
-		/* Read not closed, update FD status and timeout for reads */
-		if (ib->flags & (BF_FULL|BF_HIJACK|BF_DONT_READ)) {
-			/* stop reading */
-			if ((ib->flags & (BF_FULL|BF_HIJACK|BF_DONT_READ)) == BF_FULL)
-				si->flags |= SI_FL_WAIT_ROOM;
-			EV_FD_COND_C(fd, DIR_RD);
-			ib->rex = TICK_ETERNITY;
-		}
-		else {
-			/* (re)start reading and update timeout. Note: we don't recompute the timeout
-			 * everytime we get here, otherwise it would risk never to expire. We only
-			 * update it if is was not yet set. The stream socket handler will already
-			 * have updated it if there has been a completed I/O.
-			 */
-			si->flags &= ~SI_FL_WAIT_ROOM;
-			EV_FD_COND_S(fd, DIR_RD);
-			if (!(ib->flags & (BF_READ_NOEXP|BF_DONT_READ)) && !tick_isset(ib->rex))
-				ib->rex = tick_add_ifset(now_ms, ib->rto);
-		}
-	}
-
-	/* Check if we need to close the write side */
-	if (!(ob->flags & BF_SHUTW)) {
-		/* Write not closed, update FD status and timeout for writes */
-		if (ob->flags & BF_OUT_EMPTY) {
-			/* stop writing */
-			if ((ob->flags & (BF_FULL|BF_HIJACK|BF_SHUTW_NOW)) == 0)
-				si->flags |= SI_FL_WAIT_DATA;
-			EV_FD_COND_C(fd, DIR_WR);
-			ob->wex = TICK_ETERNITY;
-		}
-		else {
-			/* (re)start writing and update timeout. Note: we don't recompute the timeout
-			 * everytime we get here, otherwise it would risk never to expire. We only
-			 * update it if is was not yet set. The stream socket handler will already
-			 * have updated it if there has been a completed I/O.
-			 */
-			si->flags &= ~SI_FL_WAIT_DATA;
-			EV_FD_COND_S(fd, DIR_WR);
-			if (!tick_isset(ob->wex)) {
-				ob->wex = tick_add_ifset(now_ms, ob->wto);
-				if (tick_isset(ib->rex) && !(si->flags & SI_FL_INDEP_STR)) {
-					/* Note: depending on the protocol, we don't know if we're waiting
-					 * for incoming data or not. So in order to prevent the socket from
-					 * expiring read timeouts during writes, we refresh the read timeout,
-					 * except if it was already infinite or if we have explicitly setup
-					 * independant streams.
-					 */
-					ib->rex = tick_add_ifset(now_ms, ib->rto);
-				}
-			}
-		}
-	}
-}
-
-/* This function is used for inter-stream-interface calls. It is called by the
- * consumer to inform the producer side that it may be interested in checking
- * for free space in the buffer. Note that it intentionally does not update
- * timeouts, so that we can still check them later at wake-up.
- */
-void stream_sock_chk_rcv(struct stream_interface *si)
-{
-	struct buffer *ib = si->ib;
-
-	DPRINTF(stderr,"[%u] %s: fd=%d owner=%p ib=%p, ob=%p, exp(r,w)=%u,%u ibf=%08x obf=%08x ibl=%d obl=%d si=%d\n",
-		now_ms, __FUNCTION__,
-		si->fd, fdtab[si->fd].owner,
-		ib, si->ob,
-		ib->rex, si->ob->wex,
-		ib->flags, si->ob->flags,
-		ib->l, si->ob->l, si->state);
-
-	if (unlikely(si->state != SI_ST_EST || (ib->flags & BF_SHUTR)))
-		return;
-
-	if (ib->flags & (BF_FULL|BF_HIJACK|BF_DONT_READ)) {
-		/* stop reading */
-		if ((ib->flags & (BF_FULL|BF_HIJACK|BF_DONT_READ)) == BF_FULL)
-			si->flags |= SI_FL_WAIT_ROOM;
-		EV_FD_COND_C(si->fd, DIR_RD);
-	}
-	else {
-		/* (re)start reading */
-		si->flags &= ~SI_FL_WAIT_ROOM;
-		EV_FD_COND_S(si->fd, DIR_RD);
-	}
-}
-
-
-/* This function is used for inter-stream-interface calls. It is called by the
- * producer to inform the consumer side that it may be interested in checking
- * for data in the buffer. Note that it intentionally does not update timeouts,
- * so that we can still check them later at wake-up.
- */
-void stream_sock_chk_snd(struct stream_interface *si)
-{
-	struct buffer *ob = si->ob;
-	int retval;
-
-	DPRINTF(stderr,"[%u] %s: fd=%d owner=%p ib=%p, ob=%p, exp(r,w)=%u,%u ibf=%08x obf=%08x ibl=%d obl=%d si=%d\n",
-		now_ms, __FUNCTION__,
-		si->fd, fdtab[si->fd].owner,
-		si->ib, ob,
-		si->ib->rex, ob->wex,
-		si->ib->flags, ob->flags,
-		si->ib->l, ob->l, si->state);
-
-	if (unlikely(si->state != SI_ST_EST || (ob->flags & BF_SHUTW)))
-		return;
-
-	if (!(si->flags & SI_FL_WAIT_DATA) ||        /* not waiting for data */
-	    (fdtab[si->fd].ev & FD_POLL_OUT) ||      /* we'll be called anyway */
-	    (ob->flags & BF_OUT_EMPTY))              /* called with nothing to send ! */
-		return;
-
-	retval = stream_sock_write_loop(si, ob);
-	/* here, we have :
-	 *   retval < 0 if an error was encountered during write.
-	 *   retval = 0 if we can't write anymore without polling
-	 *   retval = 1 if we're invited to come back when desired
-	 */
-	if (retval < 0) {
-		/* Write error on the file descriptor. We mark the FD as STERROR so
-		 * that we don't use it anymore and we notify the task.
-		 */
-		fdtab[si->fd].state = FD_STERROR;
-		fdtab[si->fd].ev &= ~FD_POLL_STICKY;
-		EV_FD_REM(si->fd);
-		si->flags |= SI_FL_ERR;
-		goto out_wakeup;
-	}
-
-	/* OK, so now we know that retval >= 0 means that some data might have
-	 * been sent, and that we may have to poll first. We have to do that
-	 * too if the buffer is not empty.
-	 */
-	if (ob->flags & BF_OUT_EMPTY) {
-		/* the connection is established but we can't write. Either the
-		 * buffer is empty, or we just refrain from sending because the
-		 * send_max limit was reached. Maybe we just wrote the last
-		 * chunk and need to close.
-		 */
-		if (((ob->flags & (BF_SHUTW|BF_HIJACK|BF_AUTO_CLOSE|BF_SHUTW_NOW)) ==
-		     (BF_AUTO_CLOSE|BF_SHUTW_NOW)) &&
-		    (si->state == SI_ST_EST)) {
-			stream_sock_shutw(si);
-			goto out_wakeup;
-		}
-
-		if ((ob->flags & (BF_SHUTW|BF_SHUTW_NOW|BF_FULL|BF_HIJACK)) == 0)
-			si->flags |= SI_FL_WAIT_DATA;
-		ob->wex = TICK_ETERNITY;
-	}
-	else {
-		/* Otherwise there are remaining data to be sent in the buffer,
-		 * which means we have to poll before doing so.
-		 */
-		EV_FD_COND_S(si->fd, DIR_WR);
-		si->flags &= ~SI_FL_WAIT_DATA;
-		if (!tick_isset(ob->wex))
-			ob->wex = tick_add_ifset(now_ms, ob->wto);
-	}
-
-	if (likely(ob->flags & BF_WRITE_ACTIVITY)) {
-		/* update timeout if we have written something */
-		if ((ob->flags & (BF_OUT_EMPTY|BF_SHUTW|BF_WRITE_PARTIAL)) == BF_WRITE_PARTIAL)
-			ob->wex = tick_add_ifset(now_ms, ob->wto);
-
-		if (tick_isset(si->ib->rex) && !(si->flags & SI_FL_INDEP_STR)) {
-			/* Note: to prevent the client from expiring read timeouts
-			 * during writes, we refresh it. We only do this if the
-			 * interface is not configured for "independant streams",
-			 * because for some applications it's better not to do this,
-			 * for instance when continuously exchanging small amounts
-			 * of data which can full the socket buffers long before a
-			 * write timeout is detected.
-			 */
-			si->ib->rex = tick_add_ifset(now_ms, si->ib->rto);
-		}
-	}
-
-	/* in case of special condition (error, shutdown, end of write...), we
-	 * have to notify the task.
-	 */
-	if (likely((ob->flags & (BF_WRITE_NULL|BF_WRITE_ERROR|BF_SHUTW)) ||
-		   ((ob->flags & BF_OUT_EMPTY) && !ob->to_forward) ||
-		   si->state != SI_ST_EST)) {
-	out_wakeup:
-		if (!(si->flags & SI_FL_DONT_WAKE) && si->owner)
-			task_wakeup(si->owner, TASK_WOKEN_IO);
-	}
-}
-
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/task.c b/deps/haproxy-1.4.21/src/task.c
deleted file mode 100644
index 9b21fd9..0000000
--- a/deps/haproxy-1.4.21/src/task.c
+++ /dev/null
@@ -1,270 +0,0 @@
-/*
- * Task management functions.
- *
- * Copyright 2000-2009 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <string.h>
-
-#include <common/config.h>
-#include <common/memory.h>
-#include <common/mini-clist.h>
-#include <common/standard.h>
-#include <common/time.h>
-#include <eb32tree.h>
-
-#include <proto/proxy.h>
-#include <proto/session.h>
-#include <proto/task.h>
-
-struct pool_head *pool2_task;
-
-unsigned int nb_tasks = 0;
-unsigned int run_queue = 0;
-unsigned int run_queue_cur = 0;    /* copy of the run queue size */
-unsigned int nb_tasks_cur = 0;     /* copy of the tasks count */
-unsigned int niced_tasks = 0;      /* number of niced tasks in the run queue */
-struct eb32_node *last_timer = NULL;  /* optimization: last queued timer */
-
-static struct eb_root timers;      /* sorted timers tree */
-static struct eb_root rqueue;      /* tree constituting the run queue */
-static unsigned int rqueue_ticks;  /* insertion count */
-
-/* Puts the task <t> in run queue at a position depending on t->nice. <t> is
- * returned. The nice value assigns boosts in 32th of the run queue size. A
- * nice value of -1024 sets the task to -run_queue*32, while a nice value of
- * 1024 sets the task to run_queue*32. The state flags are cleared, so the
- * caller will have to set its flags after this call.
- * The task must not already be in the run queue. If unsure, use the safer
- * task_wakeup() function.
- */
-struct task *__task_wakeup(struct task *t)
-{
-	run_queue++;
-	t->rq.key = ++rqueue_ticks;
-
-	if (likely(t->nice)) {
-		int offset;
-
-		niced_tasks++;
-		if (likely(t->nice > 0))
-			offset = (unsigned)((run_queue * (unsigned int)t->nice) / 32U);
-		else
-			offset = -(unsigned)((run_queue * (unsigned int)-t->nice) / 32U);
-		t->rq.key += offset;
-	}
-
-	/* clear state flags at the same time */
-	t->state &= ~TASK_WOKEN_ANY;
-
-	eb32_insert(&rqueue, &t->rq);
-	return t;
-}
-
-/*
- * __task_queue()
- *
- * Inserts a task into the wait queue at the position given by its expiration
- * date. It does not matter if the task was already in the wait queue or not,
- * as it will be unlinked. The task must not have an infinite expiration timer.
- * Last, tasks must not be queued further than the end of the tree, which is
- * between <now_ms> and <now_ms> + 2^31 ms (now+24days in 32bit).
- *
- * This function should not be used directly, it is meant to be called by the
- * inline version of task_queue() which performs a few cheap preliminary tests
- * before deciding to call __task_queue().
- */
-void __task_queue(struct task *task)
-{
-	if (likely(task_in_wq(task)))
-		__task_unlink_wq(task);
-
-	/* the task is not in the queue now */
-	task->wq.key = task->expire;
-#ifdef DEBUG_CHECK_INVALID_EXPIRATION_DATES
-	if (tick_is_lt(task->wq.key, now_ms))
-		/* we're queuing too far away or in the past (most likely) */
-		return;
-#endif
-
-	if (likely(last_timer &&
-		   last_timer->node.bit < 0 &&
-		   last_timer->key == task->wq.key &&
-		   last_timer->node.node_p)) {
-		/* Most often, last queued timer has the same expiration date, so
-		 * if it's not queued at the root, let's queue a dup directly there.
-		 * Note that we can only use dups at the dup tree's root (most
-		 * negative bit).
-		 */
-		eb_insert_dup(&last_timer->node, &task->wq.node);
-		if (task->wq.node.bit < last_timer->node.bit)
-			last_timer = &task->wq;
-		return;
-	}
-	eb32_insert(&timers, &task->wq);
-
-	/* Make sure we don't assign the last_timer to a node-less entry */
-	if (task->wq.node.node_p && (!last_timer || (task->wq.node.bit < last_timer->node.bit)))
-		last_timer = &task->wq;
-	return;
-}
-
-/*
- * Extract all expired timers from the timer queue, and wakes up all
- * associated tasks. Returns the date of next event (or eternity) in <next>.
- */
-void wake_expired_tasks(int *next)
-{
-	struct task *task;
-	struct eb32_node *eb;
-
-	eb = eb32_lookup_ge(&timers, now_ms - TIMER_LOOK_BACK);
-	while (1) {
-		if (unlikely(!eb)) {
-			/* we might have reached the end of the tree, typically because
-			* <now_ms> is in the first half and we're first scanning the last
-			* half. Let's loop back to the beginning of the tree now.
-			*/
-			eb = eb32_first(&timers);
-			if (likely(!eb))
-				break;
-		}
-
-		if (likely(tick_is_lt(now_ms, eb->key))) {
-			/* timer not expired yet, revisit it later */
-			*next = eb->key;
-			return;
-		}
-
-		/* timer looks expired, detach it from the queue */
-		task = eb32_entry(eb, struct task, wq);
-		eb = eb32_next(eb);
-		__task_unlink_wq(task);
-
-		/* It is possible that this task was left at an earlier place in the
-		 * tree because a recent call to task_queue() has not moved it. This
-		 * happens when the new expiration date is later than the old one.
-		 * Since it is very unlikely that we reach a timeout anyway, it's a
-		 * lot cheaper to proceed like this because we almost never update
-		 * the tree. We may also find disabled expiration dates there. Since
-		 * we have detached the task from the tree, we simply call task_queue
-		 * to take care of this. Note that we might occasionally requeue it at
-		 * the same place, before <eb>, so we have to check if this happens,
-		 * and adjust <eb>, otherwise we may skip it which is not what we want.
-		 * We may also not requeue the task (and not point eb at it) if its
-		 * expiration time is not set.
-		 */
-		if (!tick_is_expired(task->expire, now_ms)) {
-			if (!tick_isset(task->expire))
-				continue;
-			__task_queue(task);
-			if (!eb || eb->key > task->wq.key)
-				eb = &task->wq;
-			continue;
-		}
-		task_wakeup(task, TASK_WOKEN_TIMER);
-	}
-
-	/* We have found no task to expire in any tree */
-	*next = TICK_ETERNITY;
-	return;
-}
-
-/* The run queue is chronologically sorted in a tree. An insertion counter is
- * used to assign a position to each task. This counter may be combined with
- * other variables (eg: nice value) to set the final position in the tree. The
- * counter may wrap without a problem, of course. We then limit the number of
- * tasks processed at once to 1/4 of the number of tasks in the queue, and to
- * 200 max in any case, so that general latency remains low and so that task
- * positions have a chance to be considered.
- *
- * The function adjusts <next> if a new event is closer.
- */
-void process_runnable_tasks(int *next)
-{
-	struct task *t;
-	struct eb32_node *eb;
-	unsigned int max_processed;
-	int expire;
-
-	run_queue_cur = run_queue; /* keep a copy for reporting */
-	nb_tasks_cur = nb_tasks;
-	max_processed = run_queue;
-	if (max_processed > 200)
-		max_processed = 200;
-
-	if (likely(niced_tasks))
-		max_processed = (max_processed + 3) / 4;
-
-	expire = *next;
-	eb = eb32_lookup_ge(&rqueue, rqueue_ticks - TIMER_LOOK_BACK);
-	while (max_processed--) {
-		/* Note: this loop is one of the fastest code path in
-		 * the whole program. It should not be re-arranged
-		 * without a good reason.
-		 */
-
-		if (unlikely(!eb)) {
-			/* we might have reached the end of the tree, typically because
-			* <rqueue_ticks> is in the first half and we're first scanning
-			* the last half. Let's loop back to the beginning of the tree now.
-			*/
-			eb = eb32_first(&rqueue);
-			if (likely(!eb))
-				break;
-		}
-
-		/* detach the task from the queue */
-		t = eb32_entry(eb, struct task, rq);
-		eb = eb32_next(eb);
-		__task_unlink_rq(t);
-
-		t->state |= TASK_RUNNING;
-		/* This is an optimisation to help the processor's branch
-		 * predictor take this most common call.
-		 */
-		t->calls++;
-		if (likely(t->process == process_session))
-			t = process_session(t);
-		else
-			t = t->process(t);
-
-		if (likely(t != NULL)) {
-			t->state &= ~TASK_RUNNING;
-			if (t->expire) {
-				task_queue(t);
-				expire = tick_first_2nz(expire, t->expire);
-			}
-
-			/* if the task has put itself back into the run queue, we want to ensure
-			 * it will be served at the proper time, especially if it's reniced.
-			 */
-			if (unlikely(task_in_rq(t)) && (!eb || tick_is_lt(t->rq.key, eb->key))) {
-				eb = eb32_lookup_ge(&rqueue, rqueue_ticks - TIMER_LOOK_BACK);
-			}
-		}
-	}
-	*next = expire;
-}
-
-/* perform minimal intializations, report 0 in case of error, 1 if OK. */
-int init_task()
-{
-	memset(&timers, 0, sizeof(timers));
-	memset(&rqueue, 0, sizeof(rqueue));
-	pool2_task = create_pool("task", sizeof(struct task), MEM_F_SHARED);
-	return pool2_task != NULL;
-}
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/time.c b/deps/haproxy-1.4.21/src/time.c
deleted file mode 100644
index 1b0f72c..0000000
--- a/deps/haproxy-1.4.21/src/time.c
+++ /dev/null
@@ -1,242 +0,0 @@
-/*
- * Time calculation functions.
- *
- * Copyright 2000-2009 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <sys/time.h>
-
-#include <common/config.h>
-#include <common/standard.h>
-#include <common/time.h>
-
-unsigned int   curr_sec_ms;      /* millisecond of current second (0..999) */
-unsigned int   curr_sec_ms_scaled;  /* millisecond of current second (0..2^32-1) */
-unsigned int   now_ms;          /* internal date in milliseconds (may wrap) */
-struct timeval now;             /* internal date is a monotonic function of real clock */
-struct timeval date;            /* the real current date */
-struct timeval start_date;      /* the process's start date */
-
-/*
- * adds <ms> ms to <from>, set the result to <tv> and returns a pointer <tv>
- */
-REGPRM3 struct timeval *_tv_ms_add(struct timeval *tv, const struct timeval *from, int ms)
-{
-	tv->tv_usec = from->tv_usec + (ms % 1000) * 1000;
-	tv->tv_sec  = from->tv_sec  + (ms / 1000);
-	while (tv->tv_usec >= 1000000) {
-		tv->tv_usec -= 1000000;
-		tv->tv_sec++;
-	}
-	return tv;
-}
-
-/*
- * compares <tv1> and <tv2> modulo 1ms: returns 0 if equal, -1 if tv1 < tv2, 1 if tv1 > tv2
- * Must not be used when either argument is eternity. Use tv_ms_cmp2() for that.
- */
-REGPRM2 int _tv_ms_cmp(const struct timeval *tv1, const struct timeval *tv2)
-{
-	return __tv_ms_cmp(tv1, tv2);
-}
-
-/*
- * compares <tv1> and <tv2> modulo 1 ms: returns 0 if equal, -1 if tv1 < tv2, 1 if tv1 > tv2,
- * assuming that TV_ETERNITY is greater than everything.
- */
-REGPRM2 int _tv_ms_cmp2(const struct timeval *tv1, const struct timeval *tv2)
-{
-	return __tv_ms_cmp2(tv1, tv2);
-}
-
-/*
- * compares <tv1> and <tv2> modulo 1 ms: returns 1 if tv1 <= tv2, 0 if tv1 > tv2,
- * assuming that TV_ETERNITY is greater than everything. Returns 0 if tv1 is
- * TV_ETERNITY, and always assumes that tv2 != TV_ETERNITY. Designed to replace
- * occurrences of (tv_ms_cmp2(tv,now) <= 0).
- */
-REGPRM2 int _tv_ms_le2(const struct timeval *tv1, const struct timeval *tv2)
-{
-	return __tv_ms_le2(tv1, tv2);
-}
-
-/*
- * returns the remaining time between tv1=now and event=tv2
- * if tv2 is passed, 0 is returned.
- * Must not be used when either argument is eternity.
- */
-REGPRM2 unsigned long _tv_ms_remain(const struct timeval *tv1, const struct timeval *tv2)
-{
-	return __tv_ms_remain(tv1, tv2);
-}
-
-/*
- * returns the remaining time between tv1=now and event=tv2
- * if tv2 is passed, 0 is returned.
- * Returns TIME_ETERNITY if tv2 is eternity.
- */
-REGPRM2 unsigned long _tv_ms_remain2(const struct timeval *tv1, const struct timeval *tv2)
-{
-	if (tv_iseternity(tv2))
-		return TIME_ETERNITY;
-
-	return __tv_ms_remain(tv1, tv2);
-}
-
-/*
- * Returns the time in ms elapsed between tv1 and tv2, assuming that tv1<=tv2.
- * Must not be used when either argument is eternity.
- */
-REGPRM2 unsigned long _tv_ms_elapsed(const struct timeval *tv1, const struct timeval *tv2)
-{
-	return __tv_ms_elapsed(tv1, tv2);
-}
-
-/*
- * adds <inc> to <from>, set the result to <tv> and returns a pointer <tv>
- */
-REGPRM3 struct timeval *_tv_add(struct timeval *tv, const struct timeval *from, const struct timeval *inc)
-{
-	return __tv_add(tv, from, inc);
-}
-
-/*
- * If <inc> is set, then add it to <from> and set the result to <tv>, then
- * return 1, otherwise return 0. It is meant to be used in if conditions.
- */
-REGPRM3 int _tv_add_ifset(struct timeval *tv, const struct timeval *from, const struct timeval *inc)
-{
-	return __tv_add_ifset(tv, from, inc);
-}
-
-/*
- * Computes the remaining time between tv1=now and event=tv2. if tv2 is passed,
- * 0 is returned. The result is stored into tv.
- */
-REGPRM3 struct timeval *_tv_remain(const struct timeval *tv1, const struct timeval *tv2, struct timeval *tv)
-{
-	return __tv_remain(tv1, tv2, tv);
-}
-
-/*
- * Computes the remaining time between tv1=now and event=tv2. if tv2 is passed,
- * 0 is returned. The result is stored into tv. Returns ETERNITY if tv2 is
- * eternity.
- */
-REGPRM3 struct timeval *_tv_remain2(const struct timeval *tv1, const struct timeval *tv2, struct timeval *tv)
-{
-	return __tv_remain2(tv1, tv2, tv);
-}
-
-/* tv_isle: compares <tv1> and <tv2> : returns 1 if tv1 <= tv2, otherwise 0 */
-REGPRM2 int _tv_isle(const struct timeval *tv1, const struct timeval *tv2)
-{
-	return __tv_isle(tv1, tv2);
-}
-
-/* tv_isgt: compares <tv1> and <tv2> : returns 1 if tv1 > tv2, otherwise 0 */
-REGPRM2 int _tv_isgt(const struct timeval *tv1, const struct timeval *tv2)
-{
-	return __tv_isgt(tv1, tv2);
-}
-
-/* tv_udpate_date: sets <date> to system time, and sets <now> to something as
- * close as possible to real time, following a monotonic function. The main
- * principle consists in detecting backwards and forwards time jumps and adjust
- * an offset to correct them. This function should be called once after each
- * poll, and never farther apart than MAX_DELAY_MS*2. The poll's timeout should
- * be passed in <max_wait>, and the return value in <interrupted> (a non-zero
- * value means that we have not expired the timeout). Calling it with (-1,*)
- * sets both <date> and <now> to current date, and calling it with (0,1) simply
- * updates the values.
- */
-REGPRM2 void tv_update_date(int max_wait, int interrupted)
-{
-	static struct timeval tv_offset; /* warning: signed offset! */
-	struct timeval adjusted, deadline;
-
-	gettimeofday(&date, NULL);
-	if (unlikely(max_wait < 0)) {
-		tv_zero(&tv_offset);
-		adjusted = date;
-		goto to_ms;
-	}
-	__tv_add(&adjusted, &date, &tv_offset);
-	if (unlikely(__tv_islt(&adjusted, &now))) {
-		goto fixup; /* jump in the past */
-	}
-
-	/* OK we did not jump backwards, let's see if we have jumped too far
-	 * forwards. The poll value was in <max_wait>, we accept that plus
-	 * MAX_DELAY_MS to cover additional time.
-	 */
-	_tv_ms_add(&deadline, &now, max_wait + MAX_DELAY_MS);
-	if (likely(__tv_islt(&adjusted, &deadline)))
-		goto to_ms; /* OK time is within expected range */
- fixup:
-	/* Large jump. If the poll was interrupted, we consider that the date
-	 * has not changed (immediate wake-up), otherwise we add the poll
-	 * time-out to the previous date. The new offset is recomputed.
-	 */
-	_tv_ms_add(&adjusted, &now, interrupted ? 0 : max_wait);
-
-	tv_offset.tv_sec  = adjusted.tv_sec  - date.tv_sec;
-	tv_offset.tv_usec = adjusted.tv_usec - date.tv_usec;
-	if (tv_offset.tv_usec < 0) {
-		tv_offset.tv_usec += 1000000;
-		tv_offset.tv_sec--;
-	}
- to_ms:
-	now = adjusted;
-	curr_sec_ms = now.tv_usec / 1000;            /* ms of current second */
-	curr_sec_ms_scaled = curr_sec_ms * 4294971;  /* ms * 2^32 / 1000 */
-	now_ms = now.tv_sec * 1000 + curr_sec_ms;
-	return;
-}
-
-char *human_time(int t, short hz_div) {
-	static char rv[sizeof("24855d23h")+1];	// longest of "23h59m" and "59m59s"
-	char *p = rv;
-	int cnt=2;				// print two numbers
-
-	if (unlikely(t < 0 || hz_div <= 0)) {
-		sprintf(p, "?");
-		return rv;
-	}
-
-	if (unlikely(hz_div > 1))
-		t /= hz_div;
-
-	if (t >= DAY) {
-		p += sprintf(p, "%dd", t / DAY);
-		cnt--;
-	}
-
-	if (cnt && t % DAY / HOUR) {
-		p += sprintf(p, "%dh", t % DAY / HOUR);
-		cnt--;
-	}
-
-	if (cnt && t % HOUR / MINUTE) {
-		p += sprintf(p, "%dm", t % HOUR / MINUTE);
-		cnt--;
-	}
-
-	if ((cnt && t % MINUTE) || !t)					// also display '0s'
-		p += sprintf(p, "%ds", t % MINUTE / SEC);
-
-	return rv;
-}
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/src/uri_auth.c b/deps/haproxy-1.4.21/src/uri_auth.c
deleted file mode 100644
index fdbcef0..0000000
--- a/deps/haproxy-1.4.21/src/uri_auth.c
+++ /dev/null
@@ -1,309 +0,0 @@
-/*
- * URI-based user authentication using the HTTP basic method.
- *
- * Copyright 2006-2007 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <stdlib.h>
-#include <string.h>
-
-#include <common/base64.h>
-#include <common/config.h>
-#include <common/uri_auth.h>
-
-#include <proto/log.h>
-
-/*
- * Initializes a basic uri_auth structure header and returns a pointer to it.
- * Uses the pointer provided if not NULL and not initialized.
- */
-struct uri_auth *stats_check_init_uri_auth(struct uri_auth **root)
-{
-	struct uri_auth *u;
-
-	if (!root || !*root) {
-		if ((u = (struct uri_auth *)calloc(1, sizeof (*u))) == NULL)
-			goto out_u;
-
-		LIST_INIT(&u->req_acl);
-		LIST_INIT(&u->admin_rules);
-	} else
-		u = *root;
-
-	if (!u->uri_prefix) {
-		u->uri_len = strlen(STATS_DEFAULT_URI);
-		if ((u->uri_prefix = strdup(STATS_DEFAULT_URI)) == NULL)
-			goto out_uri;
-	}
-
-	if (root && !*root)
-		*root = u;
-
-	return u;
-
- out_uri:
-	if (!root || !*root)
-		free(u);
- out_u:
-	return NULL;
-}
-
-/*
- * Returns a default uri_auth with <uri> set as the uri_prefix.
- * Uses the pointer provided if not NULL and not initialized.
- */
-struct uri_auth *stats_set_uri(struct uri_auth **root, char *uri)
-{
-	struct uri_auth *u;
-	char *uri_copy;
-	int uri_len;
-
-	uri_len  = strlen(uri);
-	if ((uri_copy = strdup(uri)) == NULL)
-		goto out_uri;
-	
-	if ((u = stats_check_init_uri_auth(root)) == NULL)
-		goto out_u;
-	
-	free(u->uri_prefix);
-	u->uri_prefix = uri_copy;
-	u->uri_len = uri_len;
-	return u;
-
- out_u:
-	free(uri_copy);
- out_uri:
-	return NULL;
-}
-
-/*
- * Returns a default uri_auth with <realm> set as the realm.
- * Uses the pointer provided if not NULL and not initialized.
- */
-struct uri_auth *stats_set_realm(struct uri_auth **root, char *realm)
-{
-	struct uri_auth *u;
-	char *realm_copy;
-
-	if ((realm_copy = strdup(realm)) == NULL)
-		goto out_realm;
-	
-	if ((u = stats_check_init_uri_auth(root)) == NULL)
-		goto out_u;
-	
-	free(u->auth_realm);
-	u->auth_realm = realm_copy;
-	return u;
-
- out_u:
-	free(realm_copy);
- out_realm:
-	return NULL;
-}
-
-/*
- * Returns a default uri_auth with ST_SHNODE flag enabled and
- * <node> set as the name if it is not empty.
- * Uses the pointer provided if not NULL and not initialized.
- */
-struct uri_auth *stats_set_node(struct uri_auth **root, char *name)
-{
-	struct uri_auth *u;
-	char *node_copy = NULL;
-
-	if (name && *name) {
-		node_copy = strdup(name);
-		if (node_copy == NULL)
-			goto out_realm;
-	}
-	
-	if ((u = stats_check_init_uri_auth(root)) == NULL)
-		goto out_u;
-
-	if (!stats_set_flag(root, ST_SHNODE))
-		goto out_u;
-
-	if (node_copy) {	
-		free(u->node);
-		u->node = node_copy;
-	}
-
-	return u;
-
- out_u:
-	free(node_copy);
- out_realm:
-	return NULL;
-}
-
-/*
- * Returns a default uri_auth with ST_SHDESC flag enabled and
- * <description> set as the desc if it is not empty.
- * Uses the pointer provided if not NULL and not initialized.
- */
-struct uri_auth *stats_set_desc(struct uri_auth **root, char *desc)
-{
-	struct uri_auth *u;
-	char *desc_copy = NULL;
-
-	if (desc && *desc) {
-		desc_copy = strdup(desc);
-		if (desc_copy == NULL)
-			goto out_realm;
-	}
-	
-	if ((u = stats_check_init_uri_auth(root)) == NULL)
-		goto out_u;
-
-	if (!stats_set_flag(root, ST_SHDESC))
-		goto out_u;
-
-	if (desc_copy) {
-		free(u->desc);
-		u->desc = desc_copy;
-	}
-
-	return u;
-
- out_u:
-	free(desc_copy);
- out_realm:
-	return NULL;
-}
-
-/*
- * Returns a default uri_auth with the <refresh> refresh interval.
- * Uses the pointer provided if not NULL and not initialized.
- */
-struct uri_auth *stats_set_refresh(struct uri_auth **root, int interval)
-{
-	struct uri_auth *u;
-	
-	if ((u = stats_check_init_uri_auth(root)) != NULL)
-		u->refresh = interval;
-	return u;
-}
-
-/*
- * Returns a default uri_auth with the <flag> set.
- * Uses the pointer provided if not NULL and not initialized.
- */
-struct uri_auth *stats_set_flag(struct uri_auth **root, int flag)
-{
-	struct uri_auth *u;
-	
-	if ((u = stats_check_init_uri_auth(root)) != NULL)
-		u->flags |= flag;
-	return u;
-}
-
-/*
- * Returns a default uri_auth with a <user:passwd> entry added to the list of
- * authorized users. If a matching entry is found, no update will be performed.
- * Uses the pointer provided if not NULL and not initialized.
- */
-struct uri_auth *stats_add_auth(struct uri_auth **root, char *user)
-{
-	struct uri_auth *u;
-	struct auth_users *newuser;
-	char *pass;
-
-	pass = strchr(user, ':');
-	if (pass)
-		*pass++ = '\0';
-	else
-		pass = "";
-
-	if ((u = stats_check_init_uri_auth(root)) == NULL)
-		return NULL;
-
-	if (!u->userlist)
-		u->userlist = (struct userlist *)calloc(1, sizeof(struct userlist));
-
-	if (!u->userlist)
-		return NULL;
-
-	if (!u->userlist->name)
-		u->userlist->name = strdup(".internal-stats-userlist");
-
-	if (!u->userlist->name)
-		return NULL;
-
-	for (newuser = u->userlist->users; newuser; newuser = newuser->next)
-		if (!strcmp(newuser->user, user)) {
-			Warning("uri auth: ignoring duplicated user '%s'.\n",
-				user);
-			return u;
-		}
-
-	newuser = (struct auth_users *)calloc(1, sizeof(struct auth_users));
-	if (!newuser)
-		return NULL;
-
-	newuser->user = strdup(user);
-	newuser->pass = strdup(pass);
-	newuser->flags |= AU_O_INSECURE;
-
-	if (!newuser->user || !newuser->user)
-		return NULL;
-
-	newuser->next = u->userlist->users;
-	u->userlist->users = newuser;
-
-	return u;
-}
-
-/*
- * Returns a default uri_auth with a <scope> entry added to the list of
- * allowed scopes. If a matching entry is found, no update will be performed.
- * Uses the pointer provided if not NULL and not initialized.
- */
-struct uri_auth *stats_add_scope(struct uri_auth **root, char *scope)
-{
-	struct uri_auth *u;
-	char *new_name;
-	struct stat_scope *old_scope, **scope_list;
-
-	if ((u = stats_check_init_uri_auth(root)) == NULL)
-		goto out;
-
-	scope_list = &u->scope;
-	while ((old_scope = *scope_list)) {
-		if (!strcmp(old_scope->px_id, scope))
-			break;
-		scope_list = &old_scope->next;
-	}
-
-	if (!old_scope) {
-		if ((new_name = strdup(scope)) == NULL)
-			goto out_u;
-
-		if ((old_scope = (struct stat_scope *)calloc(1, sizeof(*old_scope))) == NULL)
-			goto out_name;
-
-		old_scope->px_id = new_name;
-		old_scope->px_len = strlen(new_name);
-		*scope_list = old_scope;
-	}
-	return u;
-
- out_name:
-	free(new_name);
- out_u:
-	free(u);
- out:
-	return NULL;
-}
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/deps/haproxy-1.4.21/tests/0000-debug-stats.diff b/deps/haproxy-1.4.21/tests/0000-debug-stats.diff
deleted file mode 100644
index 223df2c..0000000
--- a/deps/haproxy-1.4.21/tests/0000-debug-stats.diff
+++ /dev/null
@@ -1,54 +0,0 @@
-From: Krzysztof Oledzki <ole@ans.pl>
-Date: Sun, 20 Apr 2008 22:19:09 +0200 (CEST)
-Subject: Re: [PATCH]  Flush buffers also where there are exactly 0 bytes left
-
-I'm also attaching a debug patch that helps to trigger this bug.
-
-Without the fix:
-# echo -ne "GET /haproxy?stats;csv;norefresh HTTP/1.0\r\n\r\n"|nc 127.0.0.1=
- 801|wc -c
-16384
-
-With the fix:
-# echo -ne "GET /haproxy?stats;csv;norefresh HTTP/1.0\r\n\r\n"|nc 127.0.0.1=
- 801|wc -c
-33089
-
-Best regards,
-
-diff --git a/src/dumpstats.c b/src/dumpstats.c
-index ddadddd..28bbfce 100644
---- a/src/dumpstats.c
-+++ b/src/dumpstats.c
-@@ -593,6 +593,7 @@ int stats_dump_proxy(struct session *s, struct proxy *px, struct uri_auth *uri)
- 
- 	msg.len = 0;
- 	msg.str = trash;
-+	int i;
- 
- 	switch (s->data_ctx.stats.px_st) {
- 	case DATA_ST_PX_INIT:
-@@ -667,6 +668,13 @@ int stats_dump_proxy(struct session *s, struct proxy *px, struct uri_auth *uri)
- 		/* print the frontend */
- 		if ((px->cap & PR_CAP_FE) &&
- 		    (!(s->data_ctx.stats.flags & STAT_BOUND) || (s->data_ctx.stats.type & (1 << STATS_TYPE_FE)))) {
-+
-+			if (1) {
-+				for (i=0; i<16096; i++)
-+					chunk_printf(&msg, trashlen, "*");
-+
-+				chunk_printf(&msg, trashlen, "\n");
-+#if 0
- 			if (!(s->data_ctx.stats.flags & STAT_FMT_CSV)) {
-				chunk_printf(&msg, trashlen,
- 				     /* name, queue */
-@@ -694,6 +702,7 @@ int stats_dump_proxy(struct session *s, struct proxy *px, struct uri_auth *uri)
- 				     px->failed_req,
- 				     px->state == PR_STRUN ? "OPEN" :
- 				     px->state == PR_STIDLE ? "FULL" : "STOP");
-+#endif
- 			} else {
-				chunk_printf(&msg, trashlen,
- 				     /* pxid, name, queue cur, queue max, */
-
-
diff --git a/deps/haproxy-1.4.21/tests/active-sh.cfg b/deps/haproxy-1.4.21/tests/active-sh.cfg
deleted file mode 100644
index 20aa293..0000000
--- a/deps/haproxy-1.4.21/tests/active-sh.cfg
+++ /dev/null
@@ -1,29 +0,0 @@
-# This is a test configuration.
-# It must load-balance across active servers. Check local apache logs to
-# verify :
-#
-#  tail /var/log/apache/access_log
-
-
-global
-	maxconn		100
-
-listen  sample1
-        mode            http
-        option		httplog
-        option          dontlognull
-        retries         1
-        redispatch
-        contimeout      1000
-        clitimeout      5000
-        srvtimeout      5000
-        maxconn 40000
-        bind :8081
-        balance source
-        server  srv1 127.0.0.1:80 cookie s1 check port 80 inter 1000 fall 1
-        server  srv2 127.0.0.2:80 cookie s2 check port 80 inter 1000 fall 1
-        server  srv3 127.0.0.3:80 cookie s3 check port 80 inter 1000 fall 1
-        #server  srv4 127.0.0.4:80 cookie s4 check port 80 inter 1000 fall 1
-        option  httpclose
-	errorloc 503 /503
-
diff --git a/deps/haproxy-1.4.21/tests/active-srv.cfg b/deps/haproxy-1.4.21/tests/active-srv.cfg
deleted file mode 100644
index ccd9f66..0000000
--- a/deps/haproxy-1.4.21/tests/active-srv.cfg
+++ /dev/null
@@ -1,29 +0,0 @@
-# This is a test configuration.
-# It must load-balance across active servers. Check local apache logs to
-# verify :
-#
-#  tail /var/log/apache/access_log
-
-
-global
-	maxconn		100
-
-listen  sample1
-        mode            http
-        option		httplog
-        option          dontlognull
-        retries         1
-        redispatch
-        contimeout      1000
-        clitimeout      5000
-        srvtimeout      5000
-        maxconn 40000
-        bind :8081
-        balance roundrobin
-        server  srv1 127.0.0.1:80 cookie s1 check port 80 inter 1000 fall 1
-        server  srv2 127.0.0.2:80 cookie s2 check port 80 inter 1000 fall 1
-        server  srv3 127.0.0.3:80 cookie s3 check port 80 inter 1000 fall 1
-        server  srv4 127.0.0.4:80 cookie s4 check port 80 inter 1000 fall 1
-        option  httpclose
-	errorloc 503 /503
-
diff --git a/deps/haproxy-1.4.21/tests/backup-all-sh.cfg b/deps/haproxy-1.4.21/tests/backup-all-sh.cfg
deleted file mode 100644
index e89e556..0000000
--- a/deps/haproxy-1.4.21/tests/backup-all-sh.cfg
+++ /dev/null
@@ -1,35 +0,0 @@
-# This is a test configuration.
-# It must load-balance across backup servers depending on the souce hash.
-# Check local apache logs to verify :
-#
-#  tail /var/log/apache/access_log
-
-
-global
-	maxconn		100
-
-listen  sample1
-        mode            http
-        option		httplog
-        option          dontlognull
-        retries         1
-        redispatch
-        contimeout      1000
-        clitimeout      5000
-        srvtimeout      5000
-        maxconn 40000
-        bind :8081
-        balance source
-	option	allbackups
-        server  srv1 127.0.0.1:80 cookie s1 check port 81 inter 1000 fall 1
-        server  srv2 127.0.0.2:80 cookie s2 check port 81 inter 1000 fall 1
-        server  srv3 127.0.0.3:80 cookie s3 check port 81 inter 1000 fall 1
-        server  srv4 127.0.0.4:80 cookie s4 check port 81 inter 1000 fall 1
-        server  bck1 127.0.1.1:80 cookie b1 check port 80 inter 1000 fall 1 backup
-        server  bck2 127.0.1.2:80 cookie b2 check port 80 inter 1000 fall 1 backup
-        server  bck3 127.0.1.3:80 cookie b3 check port 80 inter 1000 fall 1 backup
-        server  bck4 127.0.1.4:80 cookie b4 check port 80 inter 1000 fall 1 backup
-        server  bck5 127.0.1.5:80 cookie b4 check port 80 inter 1000 fall 1 backup
-        option  httpclose
-	errorloc 503 /503
-
diff --git a/deps/haproxy-1.4.21/tests/backup-all.cfg b/deps/haproxy-1.4.21/tests/backup-all.cfg
deleted file mode 100644
index 9d4cd3d..0000000
--- a/deps/haproxy-1.4.21/tests/backup-all.cfg
+++ /dev/null
@@ -1,34 +0,0 @@
-# This is a test configuration.
-# It must load-balance across backup servers. Check local apache logs to
-# verify :
-#
-#  tail /var/log/apache/access_log
-
-
-global
-	maxconn		100
-
-listen  sample1
-        mode            http
-        option		httplog
-        option          dontlognull
-        retries         1
-        redispatch
-        contimeout      1000
-        clitimeout      5000
-        srvtimeout      5000
-        maxconn 40000
-        bind :8081
-        balance roundrobin
-	option	allbackups
-        server  srv1 127.0.0.1:80 cookie s1 check port 81 inter 1000 fall 1
-        server  srv2 127.0.0.2:80 cookie s2 check port 81 inter 1000 fall 1
-        server  srv3 127.0.0.3:80 cookie s3 check port 81 inter 1000 fall 1
-        server  srv4 127.0.0.4:80 cookie s4 check port 81 inter 1000 fall 1
-        server  bck1 127.0.1.1:80 cookie b1 check port 80 inter 1000 fall 1 backup
-        server  bck2 127.0.1.2:80 cookie b2 check port 80 inter 1000 fall 1 backup
-        server  bck3 127.0.1.3:80 cookie b3 check port 80 inter 1000 fall 1 backup
-        server  bck4 127.0.1.4:80 cookie b4 check port 80 inter 1000 fall 1 backup
-        option  httpclose
-	errorloc 503 /503
-
diff --git a/deps/haproxy-1.4.21/tests/backup-first.cfg b/deps/haproxy-1.4.21/tests/backup-first.cfg
deleted file mode 100644
index f8c88ac..0000000
--- a/deps/haproxy-1.4.21/tests/backup-first.cfg
+++ /dev/null
@@ -1,33 +0,0 @@
-# This is a test configuration.
-# It must use only the first backup server. Check local apache logs to
-# verify :
-#
-#  tail /var/log/apache/access_log
-
-
-global
-	maxconn		100
-
-listen  sample1
-        mode            http
-        option		httplog
-        option          dontlognull
-        retries         1
-        redispatch
-        contimeout      1000
-        clitimeout      5000
-        srvtimeout      5000
-        maxconn 40000
-        bind :8081
-        balance roundrobin
-        server  srv1 127.0.0.1:80 cookie s1 check port 81 inter 1000 fall 1
-        server  srv2 127.0.0.2:80 cookie s2 check port 81 inter 1000 fall 1
-        server  srv3 127.0.0.3:80 cookie s3 check port 81 inter 1000 fall 1
-        server  srv4 127.0.0.4:80 cookie s4 check port 81 inter 1000 fall 1
-        server  bck1 127.0.1.1:80 cookie b1 check port 80 inter 1000 fall 1 backup
-        server  bck2 127.0.1.2:80 cookie b2 check port 80 inter 1000 fall 1 backup
-        server  bck3 127.0.1.3:80 cookie b3 check port 80 inter 1000 fall 1 backup
-        server  bck4 127.0.1.4:80 cookie b4 check port 80 inter 1000 fall 1 backup
-        option  httpclose
-	errorloc 503 /503
-
diff --git a/deps/haproxy-1.4.21/tests/backup-second-sh.cfg b/deps/haproxy-1.4.21/tests/backup-second-sh.cfg
deleted file mode 100644
index 084d2a4..0000000
--- a/deps/haproxy-1.4.21/tests/backup-second-sh.cfg
+++ /dev/null
@@ -1,34 +0,0 @@
-# This is a test configuration.
-# It must use only the first backup server. Check local apache logs to
-# verify :
-#
-#  tail /var/log/apache/access_log
-
-
-global
-	maxconn		100
-
-listen  sample1
-        mode            http
-        option		httplog
-        option          dontlognull
-        retries         1
-        redispatch
-        contimeout      1000
-        clitimeout      5000
-        srvtimeout      5000
-        maxconn 40000
-        bind :8081
-        balance source
-        server  srv1 127.0.0.1:80 cookie s1 check port 81 inter 1000 fall 1
-        server  srv2 127.0.0.2:80 cookie s2 check port 81 inter 1000 fall 1
-        server  srv3 127.0.0.3:80 cookie s3 check port 81 inter 1000 fall 1
-        server  srv4 127.0.0.4:80 cookie s4 check port 81 inter 1000 fall 1
-        server  bck1 127.0.1.1:80 cookie b1 check port 81 inter 1000 fall 1 backup
-        server  bck2 127.0.1.2:80 cookie b2 check port 80 inter 1000 fall 1 backup
-        server  bck3 127.0.1.3:80 cookie b3 check port 80 inter 1000 fall 1 backup
-        server  bck4 127.0.1.4:80 cookie b4 check port 80 inter 1000 fall 1 backup
-        server  bck5 127.0.1.5:80 cookie b5 check port 80 inter 1000 fall 1 backup
-        option  httpclose
-	errorloc 503 /503
-
diff --git a/deps/haproxy-1.4.21/tests/backup-second.cfg b/deps/haproxy-1.4.21/tests/backup-second.cfg
deleted file mode 100644
index 86d1354..0000000
--- a/deps/haproxy-1.4.21/tests/backup-second.cfg
+++ /dev/null
@@ -1,33 +0,0 @@
-# This is a test configuration.
-# It must use only the first backup server. Check local apache logs to
-# verify :
-#
-#  tail /var/log/apache/access_log
-
-
-global
-	maxconn		100
-
-listen  sample1
-        mode            http
-        option		httplog
-        option          dontlognull
-        retries         1
-        redispatch
-        contimeout      1000
-        clitimeout      5000
-        srvtimeout      5000
-        maxconn 40000
-        bind :8081
-        balance roundrobin
-        server  srv1 127.0.0.1:80 cookie s1 check port 81 inter 1000 fall 1
-        server  srv2 127.0.0.2:80 cookie s2 check port 81 inter 1000 fall 1
-        server  srv3 127.0.0.3:80 cookie s3 check port 81 inter 1000 fall 1
-        server  srv4 127.0.0.4:80 cookie s4 check port 81 inter 1000 fall 1
-        server  bck1 127.0.1.1:80 cookie b1 check port 81 inter 1000 fall 1 backup
-        server  bck2 127.0.1.2:80 cookie b2 check port 80 inter 1000 fall 1 backup
-        server  bck3 127.0.1.3:80 cookie b3 check port 80 inter 1000 fall 1 backup
-        server  bck4 127.0.1.4:80 cookie b4 check port 80 inter 1000 fall 1 backup
-        option  httpclose
-	errorloc 503 /503
-
diff --git a/deps/haproxy-1.4.21/tests/basic-test.cfg b/deps/haproxy-1.4.21/tests/basic-test.cfg
deleted file mode 100644
index 818167f..0000000
--- a/deps/haproxy-1.4.21/tests/basic-test.cfg
+++ /dev/null
@@ -1,43 +0,0 @@
-# This is a test configuration.
-# It requires another server running on local port 9000, preferably httpterm
-# with the file 'httpterm-basic.cfg' from the same directory.
-#
-# It will wait for HTTP connections on port 8000 and TCP connections on port
-# 8001. It will load-balance them across active servers, and will be able to
-# validate queuing. Stats are available at URI /?stats.
-
-global
-	maxconn		500
-
-defaults
-        contimeout      1000
-        clitimeout      5000
-        srvtimeout      5000
-        retries         1
-        redispatch
-
-listen  http_1
-        mode            http
-        bind :8000
-        option		httplog
-        option          dontlognull
-        maxconn 400
-        balance roundrobin
-        server  srv1 127.0.0.1:9000 cookie s1 check port 9000 inter 1000 fall 1
-        server  srv2 127.0.0.2:9000 cookie s2 check port 9000 inter 1000 fall 1
-        server  srv3 127.0.0.3:9000 cookie s3 check port 9000 inter 1000 fall 1
-        server  srv4 127.0.0.4:9000 cookie s4 check port 9000 inter 1000 fall 1
-        option  httpclose
-	errorloc 503 /503
-	stats uri /?stats
-
-listen  tcp_1
-        bind :8001
-        mode            tcp
-        maxconn 400
-        balance roundrobin
-        server  srv1 127.0.0.1:9000 cookie s1 check port 9000 inter 1000 fall 1
-        server  srv2 127.0.0.2:9000 cookie s2 check port 9000 inter 1000 fall 1
-        server  srv3 127.0.0.3:9000 cookie s3 check port 9000 inter 1000 fall 1
-        server  srv4 127.0.0.4:9000 cookie s4 check port 9000 inter 1000 fall 1
-
diff --git a/deps/haproxy-1.4.21/tests/defaults.cfg b/deps/haproxy-1.4.21/tests/defaults.cfg
deleted file mode 100644
index 2a4047a..0000000
--- a/deps/haproxy-1.4.21/tests/defaults.cfg
+++ /dev/null
@@ -1,46 +0,0 @@
-global
-	#log 127.0.0.1	local0
-	#log 127.0.0.1	local1 notice
-	#log loghost	local0 info
-	maxconn 4096
-	#chroot /var/empty
-	#uid 11
-	#gid 2
-	#daemon
-	#debug
-	#quiet
-
-defaults applications TCP # :10000-10100,192.168.1.2:3129
-	#bind 127.0.0.1:1234-1237
-	log	global
-       	mode	tcp
-       	#mode	http
-	#option	httplog
-	#option	dontlognull
-	balance roundrobin
-        #server  app1_0 127.0.0.2:0# check inter 100 rise 2 fall 5
-	#        server  app1_1 127.0.0.1:8000 check inter 100 rise 2 fall 5
-        #server  app1_2 127.0.0.1:8001 check inter 100 rise 2 fall 5 backup
-	retries	1
-	maxconn	2000
-	contimeout	5000
-	clitimeout	20000
-	srvtimeout	20000
-
-listen	appli3-relais 127.0.0.1:10000-10100#,192.168.1.2:3129
-	#bind 127.0.0.1:1234-1237
-	#log	global
-       	#mode	tcp
-       	#mode	http
-	#option	httplog
-	#option	dontlognull
-	#balance roundrobin
-        server  app1_0 127.0.0.1:+12000 check port 113 inter 100 rise 2 fall 5
-	#        server  app1_1 127.0.0.1:8000 check inter 100 rise 2 fall 5
-        #server  app1_2 127.0.0.1:8001 check inter 100 rise 2 fall 5 backup
-	#retries	1
-	#maxconn	2000
-	#contimeout	5000
-	#clitimeout	20000
-	#srvtimeout	20000
-
diff --git a/deps/haproxy-1.4.21/tests/filltab25.c b/deps/haproxy-1.4.21/tests/filltab25.c
deleted file mode 100644
index 02802bd..0000000
--- a/deps/haproxy-1.4.21/tests/filltab25.c
+++ /dev/null
@@ -1,399 +0,0 @@
-/*
- * experimental weighted round robin scheduler - (c) 2007 willy tarreau.
- *
- * This filling algorithm is excellent at spreading the servers, as it also
- * takes care of keeping the most uniform distance between occurences of each
- * server, by maximizing this distance. It reduces the number of variables
- * and expensive operations.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include "eb32tree.h"
-
-struct srv {
-	struct eb32_node node;
-	struct eb_root *tree; // we want to know where the server is
-	int num;
-	int w; /* weight */
-	int next, last;
-	int rem;
-} *srv;
-
-/* those trees represent a sliding window of 3 time frames */
-struct eb_root tree_0 = EB_ROOT;
-struct eb_root tree_1 = EB_ROOT;
-struct eb_root tree_2 = EB_ROOT;
-
-struct eb_root *init_tree; /* receives positions 0..sw-1 */
-struct eb_root *next_tree; /* receives positions >= 2sw */
-
-int nsrv;       /* # of servers */
-int nsw, sw;    /* sum of weights */
-int p;          /* current position, between sw..2sw-1 */
-
-/* queue a server in the weights tree */
-void queue_by_weight(struct eb_root *root, struct srv *s) {
-	s->node.key = 255 - s->w;
-	eb32_insert(root, &s->node);
-	s->tree = root;
-}
-
-/* queue a server in the weight tree <root>, except if its weight is 0 */
-void queue_by_weight_0(struct eb_root *root, struct srv *s) {
-	if (s->w) {
-		s->node.key = 255 - s->w;
-		eb32_insert(root, &s->node);
-		s->tree = root;
-	} else {
-		s->tree = NULL;
-	}
-}
-
-static inline void dequeue_srv(struct srv *s) {
-	eb32_delete(&s->node);
-}
-
-/* queues a server into the correct tree depending on ->next */
-void put_srv(struct srv *s) {
-	if (s->w <= 0 ||
-	    s->next >= 2*sw ||    /* delay everything which does not fit into the window */
-	    s->next >= sw+nsw) {  /* and everything which does not fit into the theorical new window */
-		/* put into next tree */
-		s->next -= sw; // readjust next in case we could finally take this back to current.
-		queue_by_weight_0(next_tree, s);
-	} else {
-		// The overflow problem is caused by the scale we want to apply to user weight
-		// to turn it into effective weight. Since this is only used to provide a smooth
-		// slowstart on very low weights (1), it is a pure waste. Thus, we just have to
-		// apply a small scaling factor and warn the user that slowstart is not very smooth
-		// on low weights.
-		// The max key is about ((scale*maxw)*(scale*maxw)*nbsrv)/ratio  (where the ratio is
-		// the arbitrary divide we perform in the examples above). Assuming that ratio==scale,
-		// this translates to maxkey=scale*maxw^2*nbsrv, so
-		//    max_nbsrv=2^32/255^2/scale ~= 66051/scale
-		// Using a scale of 16 is enough to support 4000 servers without overflow, providing
-		// 6% steps during slowstart.
-
-		s->node.key = 256 * s->next + (16*255 + s->rem - s->w) / 16;
-
-		/* check for overflows */
-		if ((int)s->node.key < 0)
-			printf(" OV: srv=%p w=%d rem=%d next=%d key=%d", s, s->w, s->rem, s->next, s->node.key);
-		eb32_insert(&tree_0, &s->node);
-		s->tree = &tree_0;
-	}
-}
-
-/* prepares a server when extracting it from the init tree */
-static inline void get_srv_init(struct srv *s) {
-	s->next = s->rem = 0;
-}
-
-/* prepares a server when extracting it from the next tree */
-static inline void get_srv_next(struct srv *s) {
-	s->next += sw;
-}
-
-/* prepares a server when extracting it from the next tree */
-static inline void get_srv_down(struct srv *s) {
-	s->next = p;
-}
-
-/* prepares a server when extracting it from its tree */
-void get_srv(struct srv *s) {
-	if (s->tree == init_tree) {
-		get_srv_init(s);
-	}
-	else if (s->tree == next_tree) {
-		get_srv_next(s);
-	}
-	else if (s->tree == NULL) {
-		get_srv_down(s);
-	}
-}
-
-
-/* return next server from the current tree, or a server from the init tree
- * if appropriate. If both trees are empty, return NULL.
- */
-struct srv *get_next_server() {
-	struct eb32_node *node;
-	struct srv *s;
-
-	node = eb32_first(&tree_0);
-	s = eb32_entry(node, struct srv, node);
-	
-	if (!node || s->next > p) {
-		/* either we have no server left, or we have a hole */
-		struct eb32_node *node2;
-		node2 = eb32_first(init_tree);
-		if (node2) {
-			node = node2;
-			s = eb32_entry(node, struct srv, node);
-			get_srv_init(s);
-			if (s->w == 0)
-				node = NULL;
-			s->node.key = 0; // do not display random values
-		}
-	}
-	if (node)
-		return s;
-	else
-		return NULL;
-}
-
-void update_position(struct srv *s) {
-	//if (s->tree == init_tree) {
-	if (!s->next) {
-		// first time ever for this server
-		s->last = p;
-		s->next = p + nsw / s->w;
-		s->rem += nsw % s->w;
-
-		if (s->rem >= s->w) {
-			s->rem -= s->w;
-			s->next++;
-		}
-	} else {
-		s->last = s->next;  // or p ?
-		//s->next += sw / s->w;
-		//s->rem += sw % s->w;
-		s->next += nsw / s->w;
-		s->rem += nsw % s->w;
-
-		if (s->rem >= s->w) {
-			s->rem -= s->w;
-			s->next++;
-		}
-	}
-}
-
-
-/* switches trees init_tree and next_tree. init_tree should be empty when
- * this happens, and next_tree filled with servers sorted by weights.
- */
-void switch_trees() {
-	struct eb_root *swap;
-	swap = init_tree;
-	init_tree = next_tree;
-	next_tree = swap;
-	sw = nsw;
-	p = sw;
-}
-
-main(int argc, char **argv) {
-	int conns;
-	int i;
-
-	struct srv *s;
-
-	argc--; argv++;
-	nsrv = argc;
-
-	if (!nsrv)
-		exit(1);
-
-	srv  = (struct srv *)calloc(nsrv, sizeof(struct srv));
-   
-	sw = 0;
-	for (i = 0; i < nsrv; i++) {
-		s = &srv[i];
-		s->num = i;
-		s->w = atol(argv[i]);
-		sw += s->w;
-	}
-
-	nsw = sw;
-
-	init_tree = &tree_1;
-	next_tree = &tree_2;
-
-	/* and insert all the servers in the PREV tree */
-	/* note that it is required to insert them according to
-	 * the reverse order of their weights.
-	 */
-	printf("---------------:");
-	for (i = 0; i < nsrv; i++) {
-		s = &srv[i];
-		queue_by_weight_0(init_tree, s);
-		printf("%2d", s->w);
-	}
-	printf("\n");
-
-	p = sw; // time base of current tree
-	conns = 0;
-	while (1) {
-		struct eb32_node *node;
-
-		printf("%08d|%06d: ", conns, p);
-
-		/* if we have en empty tree, let's first try to collect weights
-		 * which might have changed.
-		 */
-		if (!sw) {
-			if (nsw) {
-				sw = nsw;
-				p = sw;
-				/* do not switch trees, otherwise new servers (from init)
-				 * would end up in next.
-				 */
-				//switch_trees();
-				//printf("bla\n");
-			}
-			else
-				goto next_iteration;
-		}
-
-		s = get_next_server();
-		if (!s) {
-			printf("----------- switch (empty) -- sw=%d -> %d ---------\n", sw, nsw);
-			switch_trees();
-			s = get_next_server();
-			printf("%08d|%06d: ", conns, p);
-
-			if (!s)
-				goto next_iteration;
-		}
-		else if (s->next >= 2*sw) {
-			printf("ARGGGGG! s[%d].next=%d, max=%d\n", s->num, s->next, 2*sw-1);
-		}
-
-		/* now we have THE server we want to put at this position */
-		for (i = 0; i < s->num; i++) {
-			if (srv[i].w > 0)
-				printf(". ");
-			else
-				printf("_ ");
-		}
-		printf("# ");
-		for (i = s->num + 1; i < nsrv; i++) {
-			if (srv[i].w > 0)
-				printf(". ");
-			else
-				printf("_ ");
-		}
-		printf("  : ");
-
-		printf("s=%02d v=%04d w=%03d n=%03d r=%03d ",
-		       s->num, s->node.key, s->w, s->next, s->rem);
-
-		update_position(s);
-		printf(" | next=%03d, rem=%03d ", s->next, s->rem);
-
-		if (s->next >= sw * 2) {
-			dequeue_srv(s);
-			//queue_by_weight(next_tree, s);
-			put_srv(s);
-			printf(" => next (w=%d, n=%d) ", s->w, s->next);
-		}
-		else {
-			printf(" => curr ");
-
-			//s->node.key = s->next;
-			/* we want to ensure that in case of conflicts, servers with
-			 * the highest weights will get served first. Also, we still
-			 * have the remainder to see where the entry expected to be
-			 * inserted.
-			 */
-			//s->node.key = 256 * s->next + 255 - s->w;
-			//s->node.key = sw * s->next + sw / s->w;
-			//s->node.key = sw * s->next + s->rem;  /// seems best (check with filltab15) !
-
-			//s->node.key = (2 * sw * s->next) + s->rem + sw / s->w;
-
-			/* FIXME: must be optimized */
-			dequeue_srv(s);
-			put_srv(s);
-			//eb32i_insert(&tree_0, &s->node);
-			//s->tree = &tree_0;
-		}
-
-	next_iteration:
-		p++;
-		conns++;
-		if (/*conns == 30*/ /**/random()%100 == 0/**/) {
-			int w = /*20*//**/random()%4096/**/;
-			int num = /*1*//**/random()%nsrv/**/;
-			struct srv *s = &srv[num];
-
-			nsw = nsw - s->w + w;
-			//sw=nsw;
-
-			if (s->tree == init_tree) {
-				printf(" -- chgwght1(%d): %d->%d, n=%d --", s->num, s->w, w, s->next);
-				printf("(init)");
-				s->w = w;
-				dequeue_srv(s);
-				queue_by_weight_0(s->tree, s);
-			}
-			else if (s->tree == NULL) {
-				printf(" -- chgwght2(%d): %d->%d, n=%d --", s->num, s->w, w, s->next);
-				printf("(down)");
-				s->w = w;
-				dequeue_srv(s);
-				//queue_by_weight_0(init_tree, s);
-				get_srv(s);
-				s->next = p + (nsw + sw - p) / s->w;
-				put_srv(s);
-			}
-			else {
-				int oldnext;
-
-				/* the server is either active or in the next queue */
-				get_srv(s);
-				printf(" -- chgwght3(%d): %d->%d, n=%d, sw=%d, nsw=%d --", s->num, s->w, w, s->next, sw, nsw);
-
-				oldnext = s->next;
-				s->w = w;
-
-				/* we must measure how far we are from the end of the current window
-				 * and try to fit their as many entries as should theorically be.
-				 */
-
-				//s->w = s->w * (2*sw - p) / sw;
-				if (s->w > 0) {
-					int step = (nsw /*+ sw - p*/) / s->w;
-					s->next = s->last + step;
-					s->rem = 0;
-					if (s->next > oldnext) {
-						s->next = oldnext;
-						printf(" aaaaaaa ");
-					}
-
-					if (s->next < p + 2) {
-						s->next = p + step;
-						printf(" bbbbbb ");
-					}
-				} else {
-					printf(" push -- ");
-					/* push it into the next tree */
-					s->w = 0;
-					s->next = p + sw;
-				}
-
-
-				dequeue_srv(s);
-				printf(" n=%d", s->next);
-				put_srv(s);
-			}
-		}
-
-		printf("\n");
-
-		if (0 && conns % 50000 == 0) {
-			printf("-------- %-5d : changing all weights ----\n", conns);
-
-			for (i = 0; i < nsrv; i++) {
-				int w = i + 1;
-				s = &srv[i];
-				nsw = nsw - s->w + w;
-				s->w = w;
-				dequeue_srv(s);
-				queue_by_weight_0(next_tree, s); // or init_tree ?
-			}
-		}
-
-	}
-}
-
diff --git a/deps/haproxy-1.4.21/tests/hash_results.txt b/deps/haproxy-1.4.21/tests/hash_results.txt
deleted file mode 100644
index 0f14ec9..0000000
--- a/deps/haproxy-1.4.21/tests/hash_results.txt
+++ /dev/null
@@ -1,218 +0,0 @@
-Test:  ./test_hashes  | sort -k 3 -r
-
-Note: haproxy_server_hash should be avoided as it's just a 32 bit XOR.
-
-Athlon @ 1533 MHz, gcc-3.4 -march=i686 :
-	haproxy_server_hash  :   18477000 run/sec
-	SuperFastHash        :    6983511 run/sec
-	hash_djbx33          :    4164334 run/sec
-	bernstein            :    3371838 run/sec
-	kr_hash              :    3257684 run/sec
-	sax_hash             :    3027567 run/sec
-	fnv_hash             :    2818374 run/sec
-	haproxy_uri_hash     :    2108346 run/sec
-	oat_hash             :    2106181 run/sec
-	hashword             :    1936973 run/sec
-	hashpjw              :    1803475 run/sec
-	fnv_32a_str          :    1499198 run/sec
-
-Pentium-M @1700 MHz, gcc-3.4 -march=i686 :
-	haproxy_server_hash  :   15471737 run/sec
-	SuperFastHash        :    8155706 run/sec
-	hash_djbx33          :    4520191 run/sec
-	bernstein            :    3956142 run/sec
-	kr_hash              :    3725125 run/sec
-	fnv_hash             :    3155413 run/sec
-	sax_hash             :    2688323 run/sec
-	oat_hash             :    2452789 run/sec
-	haproxy_uri_hash     :    2010853 run/sec
-	hashword             :    1831441 run/sec
-	hashpjw              :    1737000 run/sec
-	fnv_32a_str          :    1643737 run/sec
-
-Athlon @ 1533 MHz, gcc-4.1 -march=i686 :
-	haproxy_server_hash  :   13592089 run/sec
-	SuperFastHash2       :    8687957 run/sec
-	SuperFastHash        :    7361242 run/sec
-	hash_djbx33          :    5741546 run/sec
-	bernstein            :    3368909 run/sec
-	sax_hash             :    3339880 run/sec
-	kr_hash              :    3277230 run/sec
-	fnv_hash             :    2832402 run/sec
-	hashword             :    2500317 run/sec
-	haproxy_uri_hash     :    2433241 run/sec
-	oat_hash             :    2403118 run/sec
-	hashpjw              :    1881229 run/sec
-	fnv_32a_str          :    1815709 run/sec
-
-Pentium-M @1700 MHz, gcc-4.1 -march=i686 :
-	haproxy_server_hash  :   14128788 run/sec
-	SuperFastHash2       :    8157119 run/sec
-	SuperFastHash        :    7481027 run/sec
-	hash_djbx33          :    5660711 run/sec
-	bernstein            :    3961493 run/sec
-	fnv_hash             :    3590727 run/sec
-	kr_hash              :    3389393 run/sec
-	sax_hash             :    2667227 run/sec
-	oat_hash             :    2348211 run/sec
-	hashword             :    2278856 run/sec
-	haproxy_uri_hash     :    2098022 run/sec
-	hashpjw              :    1846583 run/sec
-	fnv_32a_str          :    1661219 run/sec
-
-Pentium-M @600 MHz, gcc-4.1 -march=i686 :
-	haproxy_server_hash  :    5318468 run/sec
-	SuperFastHash2       :    3126165 run/sec
-	SuperFastHash        :    2729981 run/sec
-	hash_djbx33          :    2042181 run/sec
-	bernstein            :    1422927 run/sec
-	fnv_hash             :    1287736 run/sec
-	kr_hash              :    1217924 run/sec
-	sax_hash             :     949694 run/sec
-	oat_hash             :     837279 run/sec
-	hashword             :     812868 run/sec
-	haproxy_uri_hash     :     747611 run/sec
-	hashpjw              :     659890 run/sec
-	fnv_32a_str          :     590895 run/sec
-
-athlon @ 1.5 GHz, gcc-2.95 -march=i686 :
-	haproxy_server_hash  :   13592864 run/sec
-	SuperFastHash        :    6931251 run/sec
-	bernstein            :    4105179 run/sec
-	hash_djbx33          :    3920059 run/sec
-	kr_hash              :    2985794 run/sec
-	fnv_hash             :    2815457 run/sec
-	sax_hash             :    2791358 run/sec
-	haproxy_uri_hash     :    2786663 run/sec
-	oat_hash             :    2237859 run/sec
-	hashword             :    1985740 run/sec
-	hashpjw              :    1757733 run/sec
-	fnv_32a_str          :    1697299 run/sec
-
-Pentium-M @ 600 MHz, gcc-2.95 -march=i686 :
-	SuperFastHash        :    2934387 run/sec
-	haproxy_server_hash  :    2864668 run/sec
-	hash_djbx33          :    1498043 run/sec
-	bernstein            :    1414993 run/sec
-	kr_hash              :    1297907 run/sec
-	fnv_hash             :    1260343 run/sec
-	sax_hash             :     924764 run/sec
-	oat_hash             :     854545 run/sec
-	haproxy_uri_hash     :     790040 run/sec
-	hashword             :     693501 run/sec
-	hashpjw              :     647346 run/sec
-	fnv_32a_str          :     579691 run/sec
-
-Pentium-M @ 1700 MHz, gcc-2.95 -march=i686 :
-	SuperFastHash        :    8006127 run/sec
-	haproxy_server_hash  :    7834162 run/sec
-	hash_djbx33          :    4186025 run/sec
-	bernstein            :    3941492 run/sec
-	kr_hash              :    3630713 run/sec
-	fnv_hash             :    3507488 run/sec
-	sax_hash             :    2528128 run/sec
-	oat_hash             :    2395188 run/sec
-	haproxy_uri_hash     :    2158924 run/sec
-	hashword             :    1910992 run/sec
-	hashpjw              :    1819894 run/sec
-	fnv_32a_str          :    1629844 run/sec
-
-UltraSparc @ 400 MHz, gcc-3.4.3 :
-	haproxy_server_hash  :    5573220 run/sec
-	SuperFastHash        :    1372714 run/sec
-	bernstein            :    1361733 run/sec
-	hash_djbx33          :    1090373 run/sec
-	sax_hash             :     872499 run/sec
-	oat_hash             :     730354 run/sec
-	kr_hash              :     645431 run/sec
-	haproxy_uri_hash     :     541157 run/sec
-	fnv_32a_str          :     442608 run/sec
-	hashpjw              :     434858 run/sec
-	fnv_hash             :     401945 run/sec
-	hashword             :     340594 run/sec
-
-UltraSparc @ 400 MHz, gcc-3.4.3 -mcpu=v9 :
-	haproxy_server_hash  :    5671183 run/sec
-	bernstein            :    1437122 run/sec
-	hash_djbx33          :    1376294 run/sec
-	SuperFastHash        :    1306634 run/sec
-	sax_hash             :     873650 run/sec
-	kr_hash              :     801439 run/sec
-	oat_hash             :     729920 run/sec
-	haproxy_uri_hash     :     545341 run/sec
-	hashpjw              :     472190 run/sec
-	fnv_32a_str          :     443668 run/sec
-	hashword             :     357295 run/sec
-	fnv_hash             :     208823 run/sec
-
-
-Alpha EV6 @ 466 MHz, gcc-3.3 :
-	haproxy_server_hash  :    2495928 run/sec
-	SuperFastHash        :    2037208 run/sec
-	hash_djbx33          :    1625092 run/sec
-	kr_hash              :    1532206 run/sec
-	bernstein            :    1256746 run/sec
-	haproxy_uri_hash     :     999106 run/sec
-	oat_hash             :     841943 run/sec
-	sax_hash             :     737447 run/sec
-	hashpjw              :     676170 run/sec
-	fnv_hash             :     644054 run/sec
-	fnv_32a_str          :     638526 run/sec
-	hashword             :     421777 run/sec
-
-VIA EPIA @ 533 MHz, gcc-2.95 -march=i586 :
-	haproxy_server_hash  :    1391374 run/sec
-	SuperFastHash        :     912397 run/sec
-	hash_djbx33          :     589868 run/sec
-	kr_hash              :     453706 run/sec
-	bernstein            :     437318 run/sec
-	sax_hash             :     334456 run/sec
-	hashpjw              :     316670 run/sec
-	hashword             :     315476 run/sec
-	haproxy_uri_hash     :     311112 run/sec
-	oat_hash             :     259127 run/sec
-	fnv_32a_str          :     229485 run/sec
-	fnv_hash             :     151620 run/sec
-
-VIA EPIA @ 533 MHz, gcc-3.4 -march=i586 :
-	haproxy_server_hash  :    1660407 run/sec
-	SuperFastHash        :     791981 run/sec
-	hash_djbx33          :     680498 run/sec
-	kr_hash              :     384076 run/sec
-	bernstein            :     377247 run/sec
-	sax_hash             :     355183 run/sec
-	hashpjw              :     298879 run/sec
-	haproxy_uri_hash     :     296748 run/sec
-	oat_hash             :     283932 run/sec
-	hashword             :     269429 run/sec
-	fnv_32a_str          :     204776 run/sec
-	fnv_hash             :     155301 run/sec
-
-Pentium @ 133 MHz, gcc-3.4 -march=i586 :
-	haproxy_server_hash  :     930788 run/sec
-	SuperFastHash        :     344988 run/sec
-	hash_djbx33          :     278996 run/sec
-	bernstein            :     211545 run/sec
-	sax_hash             :     185225 run/sec
-	kr_hash              :     156603 run/sec
-	oat_hash             :     135163 run/sec
-	hashword             :     128518 run/sec
-	fnv_hash             :     107024 run/sec
-	haproxy_uri_hash     :     105523 run/sec
-	fnv_32a_str          :      99913 run/sec
-	hashpjw              :      97860 run/sec
-
-VAX VLC4000 @30 MHz, gcc-2.95 :
-	haproxy_server_hash  :      13208 run/sec
-	hash_djbx33          :      12963 run/sec
-	fnv_hash             :      12150 run/sec
-	SuperFastHash        :      12037 run/sec
-	bernstein            :      11765 run/sec
-	kr_hash              :      11111 run/sec
-	sax_hash             :       7273 run/sec
-	hashword             :       7143 run/sec
-	oat_hash             :       6931 run/sec
-	hashpjw              :       6667 run/sec
-	haproxy_uri_hash     :       5714 run/sec
-	fnv_32a_str          :       4800 run/sec
-
diff --git a/deps/haproxy-1.4.21/tests/httpterm-basic.cfg b/deps/haproxy-1.4.21/tests/httpterm-basic.cfg
deleted file mode 100644
index b875102..0000000
--- a/deps/haproxy-1.4.21/tests/httpterm-basic.cfg
+++ /dev/null
@@ -1,38 +0,0 @@
-global
-	maxconn	500
-	daemon
-	#ulimit-n 80
-	#uid	0
-	#gid	0
-	#chroot	/tmp
-	#nbproc	2
-	#debug
-	#quiet
-
-listen serv9000 0.0.0.0:9000
-	maxconn	30000
-	object weight 1 name test1 code 200 size 1048576
-	#object weight 1 name test1 code 304 size 0 time 50 no-cache
-	#object weight 1 name test2 code 200 size 100 time 50
-	#object weight 1 name test3 code 200 size 1000 time 50
-	#object weight 1 name test4 code 200 size 300 time 50
-	clitimeout	10000
-
-listen serv9001 0.0.0.0:9001
-	maxconn	30000
-	object weight 1 name test1 code 304 size 0
-	#object weight 1 name test1 code 304 size 0 time 50 no-cache
-	#object weight 1 name test2 code 200 size 100 time 50
-	#object weight 1 name test3 code 200 size 1000 time 50
-	#object weight 1 name test4 code 200 size 300 time 50
-	clitimeout	10000
-
-listen serv9002 0.0.0.0:9002
-	maxconn	30000
-	#object weight 1 name test1 code 304 size 0
-	#object weight 1 name test1 code 304 size 0 time 50 no-cache
-	object weight 1 name test2 code 200 size 100 time 500
-	#object weight 1 name test3 code 200 size 1000 time 50
-	#object weight 1 name test4 code 200 size 300 time 50
-	clitimeout	10000
-
diff --git a/deps/haproxy-1.4.21/tests/io_limits.txt b/deps/haproxy-1.4.21/tests/io_limits.txt
deleted file mode 100644
index 03399bc..0000000
--- a/deps/haproxy-1.4.21/tests/io_limits.txt
+++ /dev/null
@@ -1,116 +0,0 @@
----------- epoll without limits --------
-% time     seconds  usecs/call     calls    errors syscall
------- ----------- ----------- --------- --------- ----------------
- 47.19    2.671077          56     48093     22397 recv
- 47.15    2.668840         106     25060      4858 send
-  2.19    0.124020          10     12150           epoll_ctl
-  1.96    0.110904         286       388           epoll_wait
-  0.56    0.031565          47       670           close
-  0.19    0.010481          28       380       350 connect
-  0.15    0.008650          25       350           socket
-  0.14    0.008204          26       320           shutdown
-  0.14    0.007655          22       355        35 accept
-  0.12    0.006871          10       670           setsockopt
-  0.11    0.006194           9       670           fcntl64
-  0.07    0.004148          12       355           brk
-  0.04    0.002055           5       389           gettimeofday
------- ----------- ----------- --------- --------- ----------------
-100.00    5.660664                 89850     27640 total
-
-
----------- sepoll without limit --------
-% time     seconds  usecs/call     calls    errors syscall
------- ----------- ----------- --------- --------- ----------------
- 49.43    2.770682          97     28486      3861 send
- 46.48    2.605336          53     49317     23434 recv
-  2.00    0.111916         206       542           epoll_wait
-  0.65    0.036325          12      3030           epoll_ctl
-  0.45    0.025282          38       670           close
-  0.24    0.013247          34       388       358 connect
-  0.17    0.009544          27       350           socket
-  0.16    0.008734          27       320           shutdown
-  0.11    0.006432          18       357        37 accept
-  0.10    0.005699           9       670           setsockopt
-  0.08    0.004724           7       670           fcntl64
-  0.08    0.004568           6       767           gettimeofday
-  0.06    0.003127           9       356           brk
------- ----------- ----------- --------- --------- ----------------
-100.00    5.605616                 85923     27690 total
-
-
----------- sepoll with send limit only --------
-% time     seconds  usecs/call     calls    errors syscall
------- ----------- ----------- --------- --------- ----------------
- 49.21    2.779349         109     25417       418 send
- 46.94    2.651058          54     49150     23368 recv
-  1.77    0.099863         264       378           epoll_wait
-  0.57    0.032141          14      2351           epoll_ctl
-  0.46    0.025822          39       670           close
-  0.25    0.014300          37       387       357 connect
-  0.19    0.010530          30       350           socket
-  0.15    0.008656          27       320           shutdown
-  0.14    0.008008          23       354        34 accept
-  0.11    0.006051           9       670           setsockopt
-  0.10    0.005461           8       670           fcntl64
-  0.07    0.003842           6       604           gettimeofday
-  0.06    0.003120           9       358           brk
------- ----------- ----------- --------- --------- ----------------
-100.00    5.648201                 81679     24177 total
-
-
----------- sepoll with send + recv limits --------
-Process 3173 attached - interrupt to quit
-Process 3173 detached
-% time     seconds  usecs/call     calls    errors syscall
------- ----------- ----------- --------- --------- ----------------
- 49.09    2.802918         105     26771       596 send
- 47.72    2.724651          89     30761       728 recv
-  1.12    0.063952          55      1169           epoll_wait
-  0.47    0.026810          40       676           close
-  0.44    0.025358          11      2329           epoll_ctl
-  0.21    0.012255          30       403       367 connect
-  0.20    0.011135          35       320           shutdown
-  0.18    0.010313          29       356           socket
-  0.15    0.008614           6      1351           gettimeofday
-  0.13    0.007678          21       360        40 accept
-  0.13    0.007218          11       676           setsockopt
-  0.10    0.005559           8       676           fcntl64
-  0.05    0.002882           9       327           brk
------- ----------- ----------- --------- --------- ----------------
-100.00    5.709343                 66175      1731 total
-
----------- epoll with send+recv limits -----------
-Process 3271 attached - interrupt to quit
-Process 3271 detached
-% time     seconds  usecs/call     calls    errors syscall
------- ----------- ----------- --------- --------- ----------------
- 46.96    2.742476         124     22193           send
- 46.55    2.718027          98     27730           recv
-  2.58    0.150701          11     13331           epoll_ctl
-  2.30    0.134350         135       998           epoll_wait
-  0.52    0.030520          45       673           close
-  0.23    0.013422          42       320           shutdown
-  0.19    0.011282          29       386       353 connect
-  0.19    0.011063          31       353           socket
-  0.12    0.007039          20       359        39 accept
-  0.11    0.006629          10       673           fcntl64
-  0.10    0.005920           9       673           setsockopt
-  0.09    0.005157           5       999           gettimeofday
-  0.05    0.002885           9       335           brk
------- ----------- ----------- --------- --------- ----------------
-100.00    5.839471                 69023       392 total
-
-
-Conclusion
-----------
-epoll         = 89850 syscalls
-sepoll        = 85923 syscalls
-epoll+limits  = 69023 syscalls
-sepoll+limits = 66175 syscalls
-
-=> limits reduce the number of syscalls by 23%
-=> sepoll reduces the number of syscalls by 4%
-=> sepoll reduces the number of epoll_ctl by 83%
-=> limits reduce the number of epoll_ctl by 24%
-=> limits increase the number of epoll_wait by 115%
-
diff --git a/deps/haproxy-1.4.21/tests/ip-hash.c b/deps/haproxy-1.4.21/tests/ip-hash.c
deleted file mode 100644
index 8bb2d48..0000000
--- a/deps/haproxy-1.4.21/tests/ip-hash.c
+++ /dev/null
@@ -1,202 +0,0 @@
-/*
- * Integer hashing tests. These functions work with 32-bit integers, so are
- * perfectly suited for IPv4 addresses. A few tests show that they may also
- * be chained for larger keys (eg: IPv6), this way :
- *   f(x[0-3]) = f(f(f(f(x[0])^x[1])^x[2])^x[3])
- *
- * See also bob jenkin's site for more info on hashing, and check perfect
- * hashing for constants (eg: header names).
- */
-
-#include <stdio.h>
-#include <string.h>
-#include <arpa/inet.h>
-#include <math.h>
-
-#define NSERV   8
-#define MAXLINE 1000
-
-
-int counts_id[NSERV][NSERV];
-uint32_t hash_id( uint32_t a)
-{
-	return a;
-}
-
-/* Full-avalanche integer hashing function from Thomas Wang, suitable for use
- * with a modulo. See below, worth a read !
- * http://www.concentric.net/~Ttwang/tech/inthash.htm
- *
- * See also tests performed by Bob Jenkins (says it's faster than his) :
- * http://burtleburtle.net/bob/hash/integer.html
- *
- * This function is small and fast. It does not seem as smooth as bj6 though.
- * About 0x40 bytes, 6 shifts.
- */
-int counts_tw1[NSERV][NSERV];
-uint32_t hash_tw1(uint32_t a)
-{
-	a += ~(a<<15);
-	a ^=  (a>>10);
-	a +=  (a<<3);
-	a ^=  (a>>6);
-	a += ~(a<<11);
-	a ^=  (a>>16);
-	return a;
-}
-
-/* Thomas Wang's mix function. The multiply is optimized away by the compiler
- * on most platforms.
- * It is about equivalent to the one above.
- */
-int counts_tw2[NSERV][NSERV];
-uint32_t hash_tw2(uint32_t a)
-{
-	a = ~a + (a << 15);
-	a = a ^ (a >> 12);
-	a = a + (a << 2);
-	a = a ^ (a >> 4);
-	a = a * 2057;
-	a = a ^ (a >> 16);
-	return a;
-}
-
-/* Thomas Wang's multiplicative hash function. About 0x30 bytes, and it is
- * extremely fast on recent processors with a fast multiply. However, it
- * must not be used on low bits only, as multiples of 0x00100010 only return
- * even values !
- */
-int counts_tw3[NSERV][NSERV];
-uint32_t hash_tw3(uint32_t a)
-{
-	a = (a ^ 61) ^ (a >> 16);
-	a = a + (a << 3);
-	a = a ^ (a >> 4);
-	a = a * 0x27d4eb2d;
-	a = a ^ (a >> 15);
-	return a;
-}
-
-
-/* Full-avalanche integer hashing function from Bob Jenkins, suitable for use
- * with a modulo. It has a very smooth distribution.
- * http://burtleburtle.net/bob/hash/integer.html
- * About 0x50 bytes, 6 shifts.
- */
-int counts_bj6[NSERV][NSERV];
-int counts_bj6x[NSERV][NSERV];
-uint32_t hash_bj6(uint32_t a)
-{
-	a = (a+0x7ed55d16) + (a<<12);
-	a = (a^0xc761c23c) ^ (a>>19);
-	a = (a+0x165667b1) + (a<<5);
-	a = (a+0xd3a2646c) ^ (a<<9);
-	a = (a+0xfd7046c5) + (a<<3);
-	a = (a^0xb55a4f09) ^ (a>>16);
-	return a;
-}
-
-/* Similar function with one more shift and no magic number. It is slightly
- * slower but provides the overall smoothest distribution.
- * About 0x40 bytes, 7 shifts.
- */
-int counts_bj7[NSERV][NSERV];
-int counts_bj7x[NSERV][NSERV];
-uint32_t hash_bj7(uint32_t a)
-{
-	a -= (a<<6);
-	a ^= (a>>17);
-	a -= (a<<9);
-	a ^= (a<<4);
-	a -= (a<<3);
-	a ^= (a<<10);
-	a ^= (a>>15);
-	return a;
-}
-
-
-void count_hash_results(unsigned long hash, int counts[NSERV][NSERV]) {
-	int srv, nsrv;
-    
-	for (nsrv = 0; nsrv < NSERV; nsrv++) {
-		srv = hash % (nsrv + 1);
-		counts[nsrv][srv]++;
-	}
-}
-
-void dump_hash_results(char *name, int counts[NSERV][NSERV]) {
-	int srv, nsrv;
-	double err, total_err, max_err;
-
-	printf("%s:\n", name);
-	for (nsrv = 0; nsrv < NSERV; nsrv++) {
-		total_err = 0.0;
-		max_err = 0.0;
-		printf("%02d srv: ", nsrv+1);
-		for (srv = 0; srv <= nsrv; srv++) {
-			err = 100.0*(counts[nsrv][srv] - (double)counts[0][0]/(nsrv+1)) / (double)counts[0][0];
-			//printf("%6d ", counts[nsrv][srv]);
-			printf("% 3.1f%%%c ", err,
-			       counts[nsrv][srv]?' ':'*');  /* display '*' when a server is never selected */
-			err = fabs(err);
-			total_err += err;
-			if (err > max_err)
-				max_err = err;
-		}
-		total_err /= (double)(nsrv+1);
-		for (srv = nsrv+1; srv < NSERV; srv++)
-			printf("       ");
-		printf("  avg_err=%3.1f, max_err=%3.1f\n", total_err, max_err);
-	}
-	printf("\n");
-}
-
-int main() {
-	int nr;
-	unsigned int address = 0;
-	unsigned int mask = ~0;
-
-	memset(counts_id, 0, sizeof(counts_id));
-	memset(counts_tw1, 0, sizeof(counts_tw1));
-	memset(counts_tw2, 0, sizeof(counts_tw2));
-	memset(counts_tw3, 0, sizeof(counts_tw3));
-	memset(counts_bj6, 0, sizeof(counts_bj6));
-	memset(counts_bj7, 0, sizeof(counts_bj7));
-
-	address = 0x10000000;
-	mask = 0xffffff00;  // user mask to apply to addresses
-	for (nr = 0; nr < 0x10; nr++) {
-		//address += ~nr;  // semi-random addresses.
-		//address += 1;
-		address += 0x00000100;
-		//address += 0x11111111;
-		//address += 7;
-		//address += 8;
-		//address += 256;
-		//address += 65536;
-		//address += 131072;
-		//address += 0x00100010;   // this increment kills tw3 !
-		count_hash_results(hash_id (address & mask), counts_id);   // 0.69s / 100M
-		count_hash_results(hash_tw1(address & mask), counts_tw1);  // 1.04s / 100M
-		count_hash_results(hash_tw2(address & mask), counts_tw2);  // 1.13s / 100M
-		count_hash_results(hash_tw3(address & mask), counts_tw3);  // 1.01s / 100M
-		count_hash_results(hash_bj6(address & mask), counts_bj6);  // 1.07s / 100M
-		count_hash_results(hash_bj7(address & mask), counts_bj7);  // 1.20s / 100M
-		/* adding the original address after the hash reduces the error
-		 * rate in in presence of very small data sets (eg: 16 source
-		 * addresses for 8 servers). In this case, bj7 is very good.
-		 */
-		count_hash_results(hash_bj6(address & mask)+(address&mask), counts_bj6x); // 1.07s / 100M
-		count_hash_results(hash_bj7(address & mask)+(address&mask), counts_bj7x); // 1.20s / 100M
-	}
-
-	dump_hash_results("hash_id", counts_id);
-	dump_hash_results("hash_tw1", counts_tw1);
-	dump_hash_results("hash_tw2", counts_tw2);
-	dump_hash_results("hash_tw3", counts_tw3);
-	dump_hash_results("hash_bj6", counts_bj6);
-	dump_hash_results("hash_bj6x", counts_bj6x);
-	dump_hash_results("hash_bj7", counts_bj7);
-	dump_hash_results("hash_bj7x", counts_bj7x);
-	return 0;
-}
diff --git a/deps/haproxy-1.4.21/tests/reset.c b/deps/haproxy-1.4.21/tests/reset.c
deleted file mode 100644
index ec09b94..0000000
--- a/deps/haproxy-1.4.21/tests/reset.c
+++ /dev/null
@@ -1,45 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <fcntl.h>
-
-int main(int argc, char **argv) {
-	char *addr;
-	int port;
-	int sock;
-	struct sockaddr_in saddr;
-	const struct linger nolinger = { .l_onoff = 1, .l_linger = 0 };
-
-	if (argc < 4) {
-		fprintf(stderr,
-			"usage : %s <addr> <port> <string>\n"
-			"        This will connect to TCP port <addr>:<port> and send string <string>\n"
-			"        then immediately reset.\n",
-			argv[0]);
-		exit(1);
-	}
-
-	addr = argv[1];
-	port = atoi(argv[2]);
-
-	sock = socket(AF_INET, SOCK_STREAM, 0);
-	bzero(&saddr, sizeof(saddr));
-	saddr.sin_addr.s_addr = inet_addr(addr);
-	saddr.sin_port = htons(port);
-	saddr.sin_family = AF_INET;
-
-	if (connect(sock, (struct sockaddr *)&saddr, sizeof(saddr)) < 0) {
-		perror("connect");
-		exit(1);
-	}
-
-	send(sock, argv[3], strlen(argv[3]), MSG_DONTWAIT | MSG_NOSIGNAL);
-	setsockopt(sock, SOL_SOCKET, SO_LINGER, (struct linger *) &nolinger, sizeof(struct linger));
-	close(sock);
-	exit(0);
-}
diff --git a/deps/haproxy-1.4.21/tests/sessionhash_test.c b/deps/haproxy-1.4.21/tests/sessionhash_test.c
deleted file mode 100644
index cb05f8c..0000000
--- a/deps/haproxy-1.4.21/tests/sessionhash_test.c
+++ /dev/null
@@ -1,54 +0,0 @@
-#include <stdio.h>
-#include <common/sessionhash.h>
-
-int main(int argc, char *argv[])
-{
-	appsess *a, *b, *c, *d, *tmp;
-	struct appsession_hash h;
-	int i;
-
-	a = malloc(sizeof(appsess));
-	b = malloc(sizeof(appsess));
-	c = malloc(sizeof(appsess));
-	d = malloc(sizeof(appsess));
-
-	a->sessid = "abcdefg";
-	b->sessid = "2c";
-	c->sessid = "pe";
-	d->sessid = "abbbbbccccb";
-
-	appsession_hash_init(&h, (void (*)())free);
-	appsession_hash_dump(&h);
-	appsession_hash_insert(&h, a);
-	appsession_hash_insert(&h, b);
-	appsession_hash_insert(&h, c);
-	appsession_hash_insert(&h, d);
-
-	appsession_hash_dump(&h);
-
-	printf("a:     %p\n", a);
-	printf("b:     %p\n", b);
-	printf("c:     %p\n", c);
-	printf("d:     %p\n", d);
-	printf("-------------\n");
-	printf("a:     %p\n", appsession_hash_lookup(&h, "abcdefg"));
-	printf("b:     %p\n", appsession_hash_lookup(&h, "2c"));
-	printf("c:     %p\n", appsession_hash_lookup(&h, "pe"));
-	printf("d:     %p\n", appsession_hash_lookup(&h, "abbbbbccccb"));
-	printf("null:  %p\n", appsession_hash_lookup(&h, "non existant"));
-
-
-	appsession_hash_remove(&h, c);
-	appsession_hash_remove(&h, d);
-
-	appsession_hash_dump(&h);
-
-	printf("-- remove c,d\n");
-	printf("a:     %p\n", appsession_hash_lookup(&h, "abcdefg"));
-	printf("b:     %p\n", appsession_hash_lookup(&h, "2c"));
-	printf("c:     %p\n", appsession_hash_lookup(&h, "pe"));
-	printf("d:     %p\n", appsession_hash_lookup(&h, "abbbbbccccb"));
-	printf("null:  %p\n", appsession_hash_lookup(&h, "non existant"));
-
-	appsession_hash_destroy(&h);
-}
diff --git a/deps/haproxy-1.4.21/tests/sockstat.txt b/deps/haproxy-1.4.21/tests/sockstat.txt
deleted file mode 100644
index 3962ae9..0000000
--- a/deps/haproxy-1.4.21/tests/sockstat.txt
+++ /dev/null
@@ -1,7 +0,0 @@
-willy@pcw:haproxy-1.1.17-pre3$ cat /proc/net/sockstat 
-sockets: used 117
-TCP: inuse 82 orphan 15 tw 561836 alloc 88 mem 75
-UDP: inuse 13
-RAW: inuse 0
-FRAG: inuse 0 memory 0
-
diff --git a/deps/haproxy-1.4.21/tests/test-acl.cfg b/deps/haproxy-1.4.21/tests/test-acl.cfg
deleted file mode 100644
index 6de842a..0000000
--- a/deps/haproxy-1.4.21/tests/test-acl.cfg
+++ /dev/null
@@ -1,26 +0,0 @@
-# This sample configuration tests multiple ACL combinations. It requires
-# HAProxy version 1.3.15 minimum.
-
-global
-	maxconn 100
-
-frontend http-in
-	bind       :8000-8003
-	mode       http
-	clitimeout 30000
-
-	acl p1     dst_port 8001
-	acl p2     dst_port 8002
-	acl p3     dst_port 8003
-	acl d1     dst      127.0.0.1
-	acl d2     dst      127.0.0.2
-	acl d3     dst      127.0.0.3
-
-	redirect location d1&p2|d2&p1   if      d1  p2  or  d2 p1
-	redirect location d1&p1         if      d1  p1
-	redirect location !(d2|d3)      unless  d2      or  d3
-	redirect location d2&!p1        if      d2 !p1
-	redirect location !d2&p1        if     !d2  p1
-	redirect location !!d2          unless !d2
-
-	block if d3
diff --git a/deps/haproxy-1.4.21/tests/test-backlog.cfg b/deps/haproxy-1.4.21/tests/test-backlog.cfg
deleted file mode 100644
index bc4a71e..0000000
--- a/deps/haproxy-1.4.21/tests/test-backlog.cfg
+++ /dev/null
@@ -1,22 +0,0 @@
-# This is a test configuration.
-# It is used to check that the backlog queue works as expected.
-
-global
-	maxconn    200
-        stats timeout 3s
-
-frontend backlog_def
-        mode       http
-        timeout    client  15s
-        maxconn    100
-        bind       :8000
-        option     httpclose
-
-frontend backlog_max
-        mode       http
-        timeout    client  15s
-        maxconn    100
-	backlog    100000
-        bind       :8001
-        option     httpclose
-
diff --git a/deps/haproxy-1.4.21/tests/test-balance.cfg b/deps/haproxy-1.4.21/tests/test-balance.cfg
deleted file mode 100644
index f46e531..0000000
--- a/deps/haproxy-1.4.21/tests/test-balance.cfg
+++ /dev/null
@@ -1,65 +0,0 @@
-# This is a test configuration.
-# It tests the "balance" parser for several parameter combinations.
-
-
-global
-	maxconn		10000
-
-defaults
-	balance
-
-defaults
-	balance roundrobin
-
-defaults
-	balance source
-
-defaults
-	balance uri
-
-defaults
-	balance url_param foo
-
-defaults
-	mode tcp
-
-# must produce an error
-#defaults
-#	balance url_param
-
-backend tcp-bk1
-	balance
-
-backend tcp-bk2
-	balance roundrobin
-
-backend tcp-bk3
-	balance source
-
-backend tcp-bk4
-	balance uri
-
-backend tcp-bk5
-	balance url_param foo
-
-defaults
-	mode http
-
-backend http-bk1
-	balance
-
-backend http-bk2
-	balance roundrobin
-
-backend http-bk3
-	balance source
-
-backend http-bk4
-	balance uri
-
-backend http-bk5
-	balance url_param foo
-
-# must produce an error
-#backend http-bk6
-#	balance url_param
diff --git a/deps/haproxy-1.4.21/tests/test-check-cpu.cfg b/deps/haproxy-1.4.21/tests/test-check-cpu.cfg
deleted file mode 100644
index bf7de2b..0000000
--- a/deps/haproxy-1.4.21/tests/test-check-cpu.cfg
+++ /dev/null
@@ -1,1033 +0,0 @@
-# This is a test configuration.
-# It will provide a stats page on port 8181, with 1000 servers checked on
-# the loopback interface every second. The stats page will reload every
-# 5 seconds.
-
-
-global
-	maxconn		100
-	daemon
-	#nbproc		2
-
-listen  Stats_fnt
-        mode            http
-        bind		:8181
-        clitimeout      5000
-	contimeout	5000
-	srvtimeout	5000
-        maxconn 100
-        option  httpclose
-	balance roundrobin
-	stats uri /
-	stats refresh 5
-	stats scope Thousand_HTTP
-
-# servers created with the following command :
-# for i in $(seq 0 999); do
-#   printf "\tserver 127.0.%d.%03d 127.0.%d.%d:80 weight 10 check inter 1000 fall 2 rise 1\n" \
-#          $[i/250] $[i%250+1] $[i/250] $[i%250+1]
-# done
-backend Thousand_HTTP
-	contimeout 5000
-	srvtimeout 5000
-	balance roundrobin
-	server 127.0.0.001 127.0.0.1:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.002 127.0.0.2:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.003 127.0.0.3:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.004 127.0.0.4:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.005 127.0.0.5:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.006 127.0.0.6:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.007 127.0.0.7:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.008 127.0.0.8:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.009 127.0.0.9:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.010 127.0.0.10:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.011 127.0.0.11:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.012 127.0.0.12:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.013 127.0.0.13:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.014 127.0.0.14:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.015 127.0.0.15:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.016 127.0.0.16:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.017 127.0.0.17:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.018 127.0.0.18:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.019 127.0.0.19:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.020 127.0.0.20:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.021 127.0.0.21:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.022 127.0.0.22:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.023 127.0.0.23:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.024 127.0.0.24:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.025 127.0.0.25:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.026 127.0.0.26:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.027 127.0.0.27:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.028 127.0.0.28:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.029 127.0.0.29:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.030 127.0.0.30:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.031 127.0.0.31:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.032 127.0.0.32:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.033 127.0.0.33:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.034 127.0.0.34:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.035 127.0.0.35:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.036 127.0.0.36:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.037 127.0.0.37:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.038 127.0.0.38:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.039 127.0.0.39:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.040 127.0.0.40:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.041 127.0.0.41:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.042 127.0.0.42:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.043 127.0.0.43:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.044 127.0.0.44:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.045 127.0.0.45:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.046 127.0.0.46:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.047 127.0.0.47:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.048 127.0.0.48:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.049 127.0.0.49:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.050 127.0.0.50:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.051 127.0.0.51:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.052 127.0.0.52:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.053 127.0.0.53:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.054 127.0.0.54:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.055 127.0.0.55:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.056 127.0.0.56:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.057 127.0.0.57:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.058 127.0.0.58:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.059 127.0.0.59:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.060 127.0.0.60:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.061 127.0.0.61:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.062 127.0.0.62:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.063 127.0.0.63:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.064 127.0.0.64:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.065 127.0.0.65:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.066 127.0.0.66:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.067 127.0.0.67:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.068 127.0.0.68:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.069 127.0.0.69:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.070 127.0.0.70:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.071 127.0.0.71:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.072 127.0.0.72:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.073 127.0.0.73:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.074 127.0.0.74:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.075 127.0.0.75:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.076 127.0.0.76:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.077 127.0.0.77:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.078 127.0.0.78:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.079 127.0.0.79:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.080 127.0.0.80:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.081 127.0.0.81:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.082 127.0.0.82:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.083 127.0.0.83:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.084 127.0.0.84:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.085 127.0.0.85:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.086 127.0.0.86:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.087 127.0.0.87:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.088 127.0.0.88:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.089 127.0.0.89:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.090 127.0.0.90:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.091 127.0.0.91:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.092 127.0.0.92:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.093 127.0.0.93:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.094 127.0.0.94:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.095 127.0.0.95:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.096 127.0.0.96:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.097 127.0.0.97:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.098 127.0.0.98:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.099 127.0.0.99:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.100 127.0.0.100:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.101 127.0.0.101:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.102 127.0.0.102:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.103 127.0.0.103:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.104 127.0.0.104:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.105 127.0.0.105:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.106 127.0.0.106:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.107 127.0.0.107:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.108 127.0.0.108:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.109 127.0.0.109:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.110 127.0.0.110:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.111 127.0.0.111:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.112 127.0.0.112:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.113 127.0.0.113:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.114 127.0.0.114:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.115 127.0.0.115:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.116 127.0.0.116:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.117 127.0.0.117:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.118 127.0.0.118:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.119 127.0.0.119:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.120 127.0.0.120:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.121 127.0.0.121:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.122 127.0.0.122:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.123 127.0.0.123:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.124 127.0.0.124:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.125 127.0.0.125:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.126 127.0.0.126:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.127 127.0.0.127:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.128 127.0.0.128:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.129 127.0.0.129:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.130 127.0.0.130:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.131 127.0.0.131:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.132 127.0.0.132:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.133 127.0.0.133:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.134 127.0.0.134:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.135 127.0.0.135:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.136 127.0.0.136:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.137 127.0.0.137:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.138 127.0.0.138:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.139 127.0.0.139:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.140 127.0.0.140:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.141 127.0.0.141:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.142 127.0.0.142:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.143 127.0.0.143:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.144 127.0.0.144:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.145 127.0.0.145:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.146 127.0.0.146:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.147 127.0.0.147:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.148 127.0.0.148:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.149 127.0.0.149:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.150 127.0.0.150:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.151 127.0.0.151:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.152 127.0.0.152:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.153 127.0.0.153:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.154 127.0.0.154:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.155 127.0.0.155:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.156 127.0.0.156:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.157 127.0.0.157:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.158 127.0.0.158:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.159 127.0.0.159:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.160 127.0.0.160:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.161 127.0.0.161:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.162 127.0.0.162:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.163 127.0.0.163:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.164 127.0.0.164:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.165 127.0.0.165:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.166 127.0.0.166:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.167 127.0.0.167:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.168 127.0.0.168:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.169 127.0.0.169:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.170 127.0.0.170:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.171 127.0.0.171:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.172 127.0.0.172:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.173 127.0.0.173:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.174 127.0.0.174:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.175 127.0.0.175:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.176 127.0.0.176:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.177 127.0.0.177:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.178 127.0.0.178:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.179 127.0.0.179:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.180 127.0.0.180:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.181 127.0.0.181:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.182 127.0.0.182:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.183 127.0.0.183:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.184 127.0.0.184:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.185 127.0.0.185:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.186 127.0.0.186:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.187 127.0.0.187:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.188 127.0.0.188:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.189 127.0.0.189:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.190 127.0.0.190:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.191 127.0.0.191:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.192 127.0.0.192:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.193 127.0.0.193:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.194 127.0.0.194:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.195 127.0.0.195:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.196 127.0.0.196:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.197 127.0.0.197:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.198 127.0.0.198:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.199 127.0.0.199:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.200 127.0.0.200:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.201 127.0.0.201:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.202 127.0.0.202:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.203 127.0.0.203:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.204 127.0.0.204:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.205 127.0.0.205:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.206 127.0.0.206:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.207 127.0.0.207:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.208 127.0.0.208:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.209 127.0.0.209:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.210 127.0.0.210:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.211 127.0.0.211:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.212 127.0.0.212:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.213 127.0.0.213:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.214 127.0.0.214:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.215 127.0.0.215:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.216 127.0.0.216:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.217 127.0.0.217:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.218 127.0.0.218:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.219 127.0.0.219:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.220 127.0.0.220:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.221 127.0.0.221:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.222 127.0.0.222:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.223 127.0.0.223:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.224 127.0.0.224:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.225 127.0.0.225:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.226 127.0.0.226:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.227 127.0.0.227:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.228 127.0.0.228:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.229 127.0.0.229:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.230 127.0.0.230:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.231 127.0.0.231:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.232 127.0.0.232:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.233 127.0.0.233:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.234 127.0.0.234:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.235 127.0.0.235:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.236 127.0.0.236:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.237 127.0.0.237:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.238 127.0.0.238:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.239 127.0.0.239:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.240 127.0.0.240:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.241 127.0.0.241:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.242 127.0.0.242:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.243 127.0.0.243:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.244 127.0.0.244:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.245 127.0.0.245:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.246 127.0.0.246:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.247 127.0.0.247:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.248 127.0.0.248:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.249 127.0.0.249:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.0.250 127.0.0.250:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.001 127.0.1.1:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.002 127.0.1.2:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.003 127.0.1.3:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.004 127.0.1.4:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.005 127.0.1.5:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.006 127.0.1.6:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.007 127.0.1.7:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.008 127.0.1.8:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.009 127.0.1.9:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.010 127.0.1.10:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.011 127.0.1.11:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.012 127.0.1.12:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.013 127.0.1.13:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.014 127.0.1.14:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.015 127.0.1.15:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.016 127.0.1.16:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.017 127.0.1.17:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.018 127.0.1.18:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.019 127.0.1.19:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.020 127.0.1.20:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.021 127.0.1.21:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.022 127.0.1.22:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.023 127.0.1.23:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.024 127.0.1.24:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.025 127.0.1.25:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.026 127.0.1.26:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.027 127.0.1.27:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.028 127.0.1.28:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.029 127.0.1.29:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.030 127.0.1.30:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.031 127.0.1.31:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.032 127.0.1.32:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.033 127.0.1.33:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.034 127.0.1.34:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.035 127.0.1.35:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.036 127.0.1.36:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.037 127.0.1.37:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.038 127.0.1.38:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.039 127.0.1.39:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.040 127.0.1.40:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.041 127.0.1.41:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.042 127.0.1.42:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.043 127.0.1.43:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.044 127.0.1.44:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.045 127.0.1.45:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.046 127.0.1.46:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.047 127.0.1.47:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.048 127.0.1.48:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.049 127.0.1.49:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.050 127.0.1.50:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.051 127.0.1.51:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.052 127.0.1.52:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.053 127.0.1.53:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.054 127.0.1.54:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.055 127.0.1.55:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.056 127.0.1.56:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.057 127.0.1.57:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.058 127.0.1.58:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.059 127.0.1.59:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.060 127.0.1.60:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.061 127.0.1.61:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.062 127.0.1.62:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.063 127.0.1.63:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.064 127.0.1.64:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.065 127.0.1.65:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.066 127.0.1.66:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.067 127.0.1.67:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.068 127.0.1.68:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.069 127.0.1.69:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.070 127.0.1.70:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.071 127.0.1.71:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.072 127.0.1.72:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.073 127.0.1.73:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.074 127.0.1.74:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.075 127.0.1.75:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.076 127.0.1.76:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.077 127.0.1.77:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.078 127.0.1.78:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.079 127.0.1.79:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.080 127.0.1.80:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.081 127.0.1.81:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.082 127.0.1.82:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.083 127.0.1.83:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.084 127.0.1.84:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.085 127.0.1.85:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.086 127.0.1.86:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.087 127.0.1.87:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.088 127.0.1.88:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.089 127.0.1.89:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.090 127.0.1.90:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.091 127.0.1.91:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.092 127.0.1.92:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.093 127.0.1.93:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.094 127.0.1.94:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.095 127.0.1.95:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.096 127.0.1.96:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.097 127.0.1.97:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.098 127.0.1.98:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.099 127.0.1.99:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.100 127.0.1.100:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.101 127.0.1.101:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.102 127.0.1.102:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.103 127.0.1.103:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.104 127.0.1.104:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.105 127.0.1.105:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.106 127.0.1.106:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.107 127.0.1.107:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.108 127.0.1.108:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.109 127.0.1.109:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.110 127.0.1.110:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.111 127.0.1.111:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.112 127.0.1.112:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.113 127.0.1.113:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.114 127.0.1.114:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.115 127.0.1.115:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.116 127.0.1.116:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.117 127.0.1.117:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.118 127.0.1.118:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.119 127.0.1.119:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.120 127.0.1.120:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.121 127.0.1.121:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.122 127.0.1.122:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.123 127.0.1.123:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.124 127.0.1.124:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.125 127.0.1.125:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.126 127.0.1.126:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.127 127.0.1.127:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.128 127.0.1.128:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.129 127.0.1.129:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.130 127.0.1.130:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.131 127.0.1.131:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.132 127.0.1.132:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.133 127.0.1.133:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.134 127.0.1.134:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.135 127.0.1.135:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.136 127.0.1.136:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.137 127.0.1.137:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.138 127.0.1.138:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.139 127.0.1.139:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.140 127.0.1.140:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.141 127.0.1.141:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.142 127.0.1.142:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.143 127.0.1.143:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.144 127.0.1.144:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.145 127.0.1.145:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.146 127.0.1.146:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.147 127.0.1.147:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.148 127.0.1.148:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.149 127.0.1.149:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.150 127.0.1.150:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.151 127.0.1.151:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.152 127.0.1.152:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.153 127.0.1.153:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.154 127.0.1.154:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.155 127.0.1.155:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.156 127.0.1.156:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.157 127.0.1.157:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.158 127.0.1.158:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.159 127.0.1.159:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.160 127.0.1.160:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.161 127.0.1.161:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.162 127.0.1.162:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.163 127.0.1.163:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.164 127.0.1.164:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.165 127.0.1.165:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.166 127.0.1.166:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.167 127.0.1.167:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.168 127.0.1.168:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.169 127.0.1.169:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.170 127.0.1.170:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.171 127.0.1.171:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.172 127.0.1.172:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.173 127.0.1.173:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.174 127.0.1.174:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.175 127.0.1.175:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.176 127.0.1.176:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.177 127.0.1.177:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.178 127.0.1.178:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.179 127.0.1.179:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.180 127.0.1.180:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.181 127.0.1.181:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.182 127.0.1.182:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.183 127.0.1.183:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.184 127.0.1.184:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.185 127.0.1.185:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.186 127.0.1.186:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.187 127.0.1.187:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.188 127.0.1.188:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.189 127.0.1.189:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.190 127.0.1.190:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.191 127.0.1.191:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.192 127.0.1.192:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.193 127.0.1.193:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.194 127.0.1.194:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.195 127.0.1.195:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.196 127.0.1.196:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.197 127.0.1.197:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.198 127.0.1.198:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.199 127.0.1.199:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.200 127.0.1.200:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.201 127.0.1.201:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.202 127.0.1.202:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.203 127.0.1.203:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.204 127.0.1.204:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.205 127.0.1.205:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.206 127.0.1.206:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.207 127.0.1.207:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.208 127.0.1.208:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.209 127.0.1.209:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.210 127.0.1.210:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.211 127.0.1.211:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.212 127.0.1.212:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.213 127.0.1.213:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.214 127.0.1.214:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.215 127.0.1.215:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.216 127.0.1.216:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.217 127.0.1.217:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.218 127.0.1.218:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.219 127.0.1.219:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.220 127.0.1.220:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.221 127.0.1.221:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.222 127.0.1.222:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.223 127.0.1.223:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.224 127.0.1.224:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.225 127.0.1.225:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.226 127.0.1.226:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.227 127.0.1.227:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.228 127.0.1.228:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.229 127.0.1.229:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.230 127.0.1.230:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.231 127.0.1.231:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.232 127.0.1.232:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.233 127.0.1.233:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.234 127.0.1.234:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.235 127.0.1.235:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.236 127.0.1.236:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.237 127.0.1.237:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.238 127.0.1.238:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.239 127.0.1.239:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.240 127.0.1.240:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.241 127.0.1.241:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.242 127.0.1.242:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.243 127.0.1.243:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.244 127.0.1.244:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.245 127.0.1.245:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.246 127.0.1.246:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.247 127.0.1.247:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.248 127.0.1.248:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.249 127.0.1.249:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.1.250 127.0.1.250:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.001 127.0.2.1:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.002 127.0.2.2:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.003 127.0.2.3:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.004 127.0.2.4:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.005 127.0.2.5:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.006 127.0.2.6:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.007 127.0.2.7:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.008 127.0.2.8:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.009 127.0.2.9:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.010 127.0.2.10:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.011 127.0.2.11:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.012 127.0.2.12:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.013 127.0.2.13:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.014 127.0.2.14:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.015 127.0.2.15:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.016 127.0.2.16:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.017 127.0.2.17:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.018 127.0.2.18:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.019 127.0.2.19:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.020 127.0.2.20:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.021 127.0.2.21:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.022 127.0.2.22:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.023 127.0.2.23:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.024 127.0.2.24:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.025 127.0.2.25:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.026 127.0.2.26:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.027 127.0.2.27:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.028 127.0.2.28:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.029 127.0.2.29:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.030 127.0.2.30:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.031 127.0.2.31:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.032 127.0.2.32:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.033 127.0.2.33:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.034 127.0.2.34:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.035 127.0.2.35:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.036 127.0.2.36:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.037 127.0.2.37:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.038 127.0.2.38:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.039 127.0.2.39:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.040 127.0.2.40:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.041 127.0.2.41:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.042 127.0.2.42:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.043 127.0.2.43:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.044 127.0.2.44:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.045 127.0.2.45:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.046 127.0.2.46:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.047 127.0.2.47:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.048 127.0.2.48:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.049 127.0.2.49:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.050 127.0.2.50:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.051 127.0.2.51:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.052 127.0.2.52:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.053 127.0.2.53:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.054 127.0.2.54:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.055 127.0.2.55:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.056 127.0.2.56:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.057 127.0.2.57:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.058 127.0.2.58:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.059 127.0.2.59:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.060 127.0.2.60:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.061 127.0.2.61:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.062 127.0.2.62:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.063 127.0.2.63:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.064 127.0.2.64:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.065 127.0.2.65:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.066 127.0.2.66:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.067 127.0.2.67:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.068 127.0.2.68:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.069 127.0.2.69:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.070 127.0.2.70:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.071 127.0.2.71:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.072 127.0.2.72:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.073 127.0.2.73:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.074 127.0.2.74:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.075 127.0.2.75:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.076 127.0.2.76:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.077 127.0.2.77:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.078 127.0.2.78:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.079 127.0.2.79:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.080 127.0.2.80:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.081 127.0.2.81:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.082 127.0.2.82:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.083 127.0.2.83:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.084 127.0.2.84:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.085 127.0.2.85:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.086 127.0.2.86:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.087 127.0.2.87:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.088 127.0.2.88:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.089 127.0.2.89:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.090 127.0.2.90:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.091 127.0.2.91:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.092 127.0.2.92:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.093 127.0.2.93:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.094 127.0.2.94:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.095 127.0.2.95:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.096 127.0.2.96:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.097 127.0.2.97:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.098 127.0.2.98:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.099 127.0.2.99:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.100 127.0.2.100:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.101 127.0.2.101:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.102 127.0.2.102:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.103 127.0.2.103:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.104 127.0.2.104:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.105 127.0.2.105:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.106 127.0.2.106:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.107 127.0.2.107:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.108 127.0.2.108:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.109 127.0.2.109:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.110 127.0.2.110:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.111 127.0.2.111:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.112 127.0.2.112:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.113 127.0.2.113:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.114 127.0.2.114:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.115 127.0.2.115:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.116 127.0.2.116:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.117 127.0.2.117:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.118 127.0.2.118:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.119 127.0.2.119:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.120 127.0.2.120:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.121 127.0.2.121:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.122 127.0.2.122:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.123 127.0.2.123:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.124 127.0.2.124:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.125 127.0.2.125:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.126 127.0.2.126:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.127 127.0.2.127:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.128 127.0.2.128:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.129 127.0.2.129:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.130 127.0.2.130:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.131 127.0.2.131:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.132 127.0.2.132:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.133 127.0.2.133:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.134 127.0.2.134:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.135 127.0.2.135:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.136 127.0.2.136:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.137 127.0.2.137:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.138 127.0.2.138:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.139 127.0.2.139:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.140 127.0.2.140:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.141 127.0.2.141:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.142 127.0.2.142:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.143 127.0.2.143:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.144 127.0.2.144:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.145 127.0.2.145:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.146 127.0.2.146:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.147 127.0.2.147:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.148 127.0.2.148:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.149 127.0.2.149:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.150 127.0.2.150:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.151 127.0.2.151:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.152 127.0.2.152:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.153 127.0.2.153:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.154 127.0.2.154:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.155 127.0.2.155:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.156 127.0.2.156:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.157 127.0.2.157:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.158 127.0.2.158:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.159 127.0.2.159:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.160 127.0.2.160:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.161 127.0.2.161:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.162 127.0.2.162:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.163 127.0.2.163:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.164 127.0.2.164:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.165 127.0.2.165:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.166 127.0.2.166:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.167 127.0.2.167:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.168 127.0.2.168:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.169 127.0.2.169:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.170 127.0.2.170:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.171 127.0.2.171:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.172 127.0.2.172:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.173 127.0.2.173:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.174 127.0.2.174:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.175 127.0.2.175:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.176 127.0.2.176:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.177 127.0.2.177:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.178 127.0.2.178:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.179 127.0.2.179:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.180 127.0.2.180:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.181 127.0.2.181:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.182 127.0.2.182:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.183 127.0.2.183:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.184 127.0.2.184:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.185 127.0.2.185:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.186 127.0.2.186:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.187 127.0.2.187:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.188 127.0.2.188:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.189 127.0.2.189:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.190 127.0.2.190:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.191 127.0.2.191:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.192 127.0.2.192:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.193 127.0.2.193:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.194 127.0.2.194:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.195 127.0.2.195:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.196 127.0.2.196:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.197 127.0.2.197:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.198 127.0.2.198:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.199 127.0.2.199:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.200 127.0.2.200:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.201 127.0.2.201:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.202 127.0.2.202:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.203 127.0.2.203:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.204 127.0.2.204:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.205 127.0.2.205:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.206 127.0.2.206:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.207 127.0.2.207:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.208 127.0.2.208:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.209 127.0.2.209:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.210 127.0.2.210:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.211 127.0.2.211:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.212 127.0.2.212:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.213 127.0.2.213:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.214 127.0.2.214:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.215 127.0.2.215:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.216 127.0.2.216:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.217 127.0.2.217:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.218 127.0.2.218:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.219 127.0.2.219:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.220 127.0.2.220:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.221 127.0.2.221:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.222 127.0.2.222:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.223 127.0.2.223:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.224 127.0.2.224:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.225 127.0.2.225:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.226 127.0.2.226:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.227 127.0.2.227:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.228 127.0.2.228:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.229 127.0.2.229:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.230 127.0.2.230:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.231 127.0.2.231:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.232 127.0.2.232:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.233 127.0.2.233:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.234 127.0.2.234:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.235 127.0.2.235:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.236 127.0.2.236:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.237 127.0.2.237:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.238 127.0.2.238:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.239 127.0.2.239:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.240 127.0.2.240:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.241 127.0.2.241:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.242 127.0.2.242:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.243 127.0.2.243:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.244 127.0.2.244:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.245 127.0.2.245:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.246 127.0.2.246:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.247 127.0.2.247:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.248 127.0.2.248:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.249 127.0.2.249:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.250 127.0.2.250:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.001 127.0.3.1:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.002 127.0.3.2:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.003 127.0.3.3:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.004 127.0.3.4:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.005 127.0.3.5:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.006 127.0.3.6:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.007 127.0.3.7:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.008 127.0.3.8:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.009 127.0.3.9:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.010 127.0.3.10:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.011 127.0.3.11:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.012 127.0.3.12:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.013 127.0.3.13:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.014 127.0.3.14:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.015 127.0.3.15:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.016 127.0.3.16:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.017 127.0.3.17:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.018 127.0.3.18:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.019 127.0.3.19:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.020 127.0.3.20:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.021 127.0.3.21:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.022 127.0.3.22:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.023 127.0.3.23:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.024 127.0.3.24:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.025 127.0.3.25:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.026 127.0.3.26:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.027 127.0.3.27:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.028 127.0.3.28:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.029 127.0.3.29:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.030 127.0.3.30:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.031 127.0.3.31:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.032 127.0.3.32:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.033 127.0.3.33:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.034 127.0.3.34:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.035 127.0.3.35:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.036 127.0.3.36:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.037 127.0.3.37:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.038 127.0.3.38:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.039 127.0.3.39:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.040 127.0.3.40:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.041 127.0.3.41:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.042 127.0.3.42:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.043 127.0.3.43:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.044 127.0.3.44:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.045 127.0.3.45:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.046 127.0.3.46:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.047 127.0.3.47:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.048 127.0.3.48:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.049 127.0.3.49:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.050 127.0.3.50:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.051 127.0.3.51:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.052 127.0.3.52:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.053 127.0.3.53:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.054 127.0.3.54:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.055 127.0.3.55:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.056 127.0.3.56:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.057 127.0.3.57:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.058 127.0.3.58:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.059 127.0.3.59:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.060 127.0.3.60:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.061 127.0.3.61:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.062 127.0.3.62:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.063 127.0.3.63:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.064 127.0.3.64:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.065 127.0.3.65:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.066 127.0.3.66:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.067 127.0.3.67:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.068 127.0.3.68:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.069 127.0.3.69:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.070 127.0.3.70:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.071 127.0.3.71:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.072 127.0.3.72:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.073 127.0.3.73:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.074 127.0.3.74:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.075 127.0.3.75:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.076 127.0.3.76:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.077 127.0.3.77:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.078 127.0.3.78:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.079 127.0.3.79:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.080 127.0.3.80:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.081 127.0.3.81:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.082 127.0.3.82:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.083 127.0.3.83:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.084 127.0.3.84:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.085 127.0.3.85:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.086 127.0.3.86:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.087 127.0.3.87:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.088 127.0.3.88:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.089 127.0.3.89:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.090 127.0.3.90:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.091 127.0.3.91:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.092 127.0.3.92:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.093 127.0.3.93:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.094 127.0.3.94:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.095 127.0.3.95:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.096 127.0.3.96:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.097 127.0.3.97:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.098 127.0.3.98:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.099 127.0.3.99:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.100 127.0.3.100:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.101 127.0.3.101:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.102 127.0.3.102:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.103 127.0.3.103:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.104 127.0.3.104:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.105 127.0.3.105:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.106 127.0.3.106:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.107 127.0.3.107:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.108 127.0.3.108:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.109 127.0.3.109:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.110 127.0.3.110:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.111 127.0.3.111:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.112 127.0.3.112:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.113 127.0.3.113:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.114 127.0.3.114:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.115 127.0.3.115:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.116 127.0.3.116:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.117 127.0.3.117:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.118 127.0.3.118:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.119 127.0.3.119:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.120 127.0.3.120:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.121 127.0.3.121:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.122 127.0.3.122:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.123 127.0.3.123:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.124 127.0.3.124:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.125 127.0.3.125:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.126 127.0.3.126:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.127 127.0.3.127:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.128 127.0.3.128:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.129 127.0.3.129:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.130 127.0.3.130:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.131 127.0.3.131:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.132 127.0.3.132:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.133 127.0.3.133:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.134 127.0.3.134:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.135 127.0.3.135:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.136 127.0.3.136:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.137 127.0.3.137:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.138 127.0.3.138:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.139 127.0.3.139:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.140 127.0.3.140:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.141 127.0.3.141:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.142 127.0.3.142:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.143 127.0.3.143:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.144 127.0.3.144:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.145 127.0.3.145:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.146 127.0.3.146:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.147 127.0.3.147:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.148 127.0.3.148:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.149 127.0.3.149:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.150 127.0.3.150:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.151 127.0.3.151:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.152 127.0.3.152:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.153 127.0.3.153:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.154 127.0.3.154:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.155 127.0.3.155:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.156 127.0.3.156:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.157 127.0.3.157:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.158 127.0.3.158:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.159 127.0.3.159:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.160 127.0.3.160:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.161 127.0.3.161:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.162 127.0.3.162:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.163 127.0.3.163:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.164 127.0.3.164:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.165 127.0.3.165:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.166 127.0.3.166:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.167 127.0.3.167:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.168 127.0.3.168:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.169 127.0.3.169:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.170 127.0.3.170:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.171 127.0.3.171:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.172 127.0.3.172:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.173 127.0.3.173:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.174 127.0.3.174:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.175 127.0.3.175:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.176 127.0.3.176:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.177 127.0.3.177:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.178 127.0.3.178:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.179 127.0.3.179:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.180 127.0.3.180:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.181 127.0.3.181:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.182 127.0.3.182:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.183 127.0.3.183:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.184 127.0.3.184:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.185 127.0.3.185:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.186 127.0.3.186:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.187 127.0.3.187:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.188 127.0.3.188:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.189 127.0.3.189:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.190 127.0.3.190:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.191 127.0.3.191:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.192 127.0.3.192:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.193 127.0.3.193:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.194 127.0.3.194:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.195 127.0.3.195:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.196 127.0.3.196:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.197 127.0.3.197:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.198 127.0.3.198:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.199 127.0.3.199:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.200 127.0.3.200:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.201 127.0.3.201:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.202 127.0.3.202:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.203 127.0.3.203:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.204 127.0.3.204:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.205 127.0.3.205:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.206 127.0.3.206:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.207 127.0.3.207:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.208 127.0.3.208:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.209 127.0.3.209:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.210 127.0.3.210:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.211 127.0.3.211:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.212 127.0.3.212:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.213 127.0.3.213:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.214 127.0.3.214:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.215 127.0.3.215:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.216 127.0.3.216:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.217 127.0.3.217:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.218 127.0.3.218:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.219 127.0.3.219:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.220 127.0.3.220:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.221 127.0.3.221:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.222 127.0.3.222:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.223 127.0.3.223:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.224 127.0.3.224:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.225 127.0.3.225:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.226 127.0.3.226:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.227 127.0.3.227:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.228 127.0.3.228:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.229 127.0.3.229:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.230 127.0.3.230:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.231 127.0.3.231:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.232 127.0.3.232:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.233 127.0.3.233:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.234 127.0.3.234:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.235 127.0.3.235:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.236 127.0.3.236:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.237 127.0.3.237:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.238 127.0.3.238:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.239 127.0.3.239:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.240 127.0.3.240:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.241 127.0.3.241:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.242 127.0.3.242:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.243 127.0.3.243:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.244 127.0.3.244:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.245 127.0.3.245:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.246 127.0.3.246:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.247 127.0.3.247:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.248 127.0.3.248:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.249 127.0.3.249:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.3.250 127.0.3.250:80 weight 10 check inter 1000 fall 2 rise 1
diff --git a/deps/haproxy-1.4.21/tests/test-check-expect.cfg b/deps/haproxy-1.4.21/tests/test-check-expect.cfg
deleted file mode 100644
index 8a799df..0000000
--- a/deps/haproxy-1.4.21/tests/test-check-expect.cfg
+++ /dev/null
@@ -1,87 +0,0 @@
-# This is a test configuration.
-# It is used to involve the various http-check expect features. It queries
-# a local web server for an object which is called the same as the keyword.
-
-global
-	maxconn    500
-        stats socket /tmp/sock1 mode 600 level admin
-        stats timeout 3000
-        stats maxconn 2000
-
-defaults
-        mode            http
-        retries         1
-        option          redispatch
-        timeout connect 1000
-        timeout client  5000
-        timeout server  5000
-        maxconn         400
-        option          http-server-close
-
-listen  stats
-        bind       :8080
-	stats      uri /
-
-backend chk-exp-status-nolb
-	# note: 404 should not produce an error here, just a soft-stop
-	balance roundrobin
-	option     httpchk GET /status
-	http-check disable-on-404
-	http-check expect status 200
-	server s1 127.0.0.1:80 check inter 1000
-
-backend chk-nexp-status-nolb
-	balance roundrobin
-	option     httpchk GET /status
-	http-check disable-on-404
-	http-check expect ! status 200
-	server s1 127.0.0.1:80 check inter 1000
-
-backend chk-exp-status
-	balance roundrobin
-	option     httpchk GET /status
-	http-check expect status 200
-	server s1 127.0.0.1:80 check inter 1000
-
-backend chk-nexp-status
-	balance roundrobin
-	option     httpchk GET /status
-	http-check expect ! status 200
-	server s1 127.0.0.1:80 check inter 1000
-
-backend chk-exp-rstatus
-	balance roundrobin
-	option     httpchk GET /rstatus
-	http-check expect rstatus ^2[0-9][0-9]
-	server s1 127.0.0.1:80 check inter 1000
-
-backend chk-nexp-rstatus
-	balance roundrobin
-	option     httpchk GET /rstatus
-	http-check expect ! rstatus ^2[0-9][0-9]
-	server s1 127.0.0.1:80 check inter 1000
-
-backend chk-exp-string
-	balance roundrobin
-	option     httpchk GET /string
-	http-check expect string this\ is\ ok
-	server s1 127.0.0.1:80 check inter 1000
-
-backend chk-nexp-string
-	balance roundrobin
-	option     httpchk GET /string
-	http-check expect ! string this\ is\ ok
-	server s1 127.0.0.1:80 check inter 1000
-
-backend chk-exp-rstring
-	balance roundrobin
-	option     httpchk GET /rstring
-	http-check expect rstring this\ is\ ok
-	server s1 127.0.0.1:80 check inter 1000
-
-backend chk-nexp-rstring
-	balance roundrobin
-	option     httpchk GET /rstring
-	http-check expect ! rstring this\ is\ ok
-	server s1 127.0.0.1:80 check inter 1000
-
diff --git a/deps/haproxy-1.4.21/tests/test-connection.cfg b/deps/haproxy-1.4.21/tests/test-connection.cfg
deleted file mode 100644
index 8d7d6e7..0000000
--- a/deps/haproxy-1.4.21/tests/test-connection.cfg
+++ /dev/null
@@ -1,42 +0,0 @@
-# This is a test configuration.
-# It is used to check the various connection modes
-
-global
-	maxconn 100
-
-defaults
-	mode	http
-	timeout	client 10000
-	timeout	server 10000
-	timeout connect 10000
-	balance roundrobin
-
-listen httpclose
-	option	httpclose
-	bind	:8001
-	server	srv 127.0.0.1:8080
-	reqadd	X-request:\ mode=httpclose
-	rspadd	X-response:\ mode=httpclose
-
-listen server-close
-	option	http-server-close
-	bind	:8002
-	server	srv 127.0.0.1:8080
-	reqadd	X-request:\ mode=server-close
-	rspadd	X-response:\ mode=server-close
-
-listen httpclose_server-close
-	option	httpclose
-	option	http-server-close
-	bind	:8003
-	server	srv 127.0.0.1:8080
-	reqadd	X-request:\ mode=httpclose+server-close
-	rspadd	X-response:\ mode=httpclose+server-close
-
-listen forceclose
-	option forceclose
-	bind	:8004
-	server	srv 127.0.0.1:8080
-	reqadd	X-request:\ mode=forceclose
-	rspadd	X-response:\ mode=forceclose
-
diff --git a/deps/haproxy-1.4.21/tests/test-cookie-appsess.cfg b/deps/haproxy-1.4.21/tests/test-cookie-appsess.cfg
deleted file mode 100644
index 61e9dbf..0000000
--- a/deps/haproxy-1.4.21/tests/test-cookie-appsess.cfg
+++ /dev/null
@@ -1,36 +0,0 @@
-# Test configuration. It listens on port 8000, forwards to
-# local ports 8001/8002 as two distinct servers, and relies
-# on a server running on local port 8080 to handle the request.
-
-global
-	maxconn 500
-	stats socket /tmp/sock1 mode 777 level admin
-	stats timeout 1d
-
-defaults
-	mode	http
-	option  http-server-close
-	timeout	client 30s
-	timeout server 30s
-	timeout connect 5s
-
-listen test
-	log 127.0.0.1 local0
-	option httplog
-	bind :8000
-	appsession AS len 64 timeout 3h
-	cookie SID insert indirect
-	server s1 127.0.0.1:8001 cookie s1
-	server s2 127.0.0.1:8002 cookie s2
-	capture cookie toto= len 10
-
-listen s1
-	bind 127.0.0.1:8001
-	server srv 127.0.0.1:8080
-	reqadd x-haproxy-used:\ s1
-
-listen s2
-	bind 127.0.0.1:8002
-	server srv 127.0.0.1:8080
-	reqadd x-haproxy-used:\ s2
-
diff --git a/deps/haproxy-1.4.21/tests/test-cookie-indirect.cfg b/deps/haproxy-1.4.21/tests/test-cookie-indirect.cfg
deleted file mode 100644
index a6f0698..0000000
--- a/deps/haproxy-1.4.21/tests/test-cookie-indirect.cfg
+++ /dev/null
@@ -1,47 +0,0 @@
-# Test configuration. It listens on port 8000, forwards to
-# local ports 8001/8002 as two distinct servers, and relies
-# on a server running on local port 8080 to handle the request.
-
-# Example of request that must be handled (taken from RFC2965 and mangled
-# a bit) :
-# POST /acme/process HTTP/1.1
-# Cookie: $Version="1";
-#        Customer="WILE_E_COYOTE"; $Path="/acme";
-#     SID= s2 ; $Path="/";
-#                Part_Number="Rocket_Launcher_0001"; $Path="/acme";
-#                Shipping="FedEx"; $Path="/acme"
-#
-#
-#
-
-global
-	maxconn 500
-	stats socket /tmp/sock1 mode 777 level admin
-	stats timeout 1d
-
-defaults
-	mode	http
-	option  http-server-close
-	timeout	client 30s
-	timeout server 30s
-	timeout connect 5s
-
-listen test
-	log 127.0.0.1 local0
-	option httplog
-	bind :8000
-	cookie SID insert indirect
-	server s1 127.0.0.1:8001 cookie s1
-	server s2 127.0.0.1:8002 cookie s2
-	capture cookie toto= len 10
-
-listen s1
-	bind 127.0.0.1:8001
-	server srv 127.0.0.1:8080
-	reqadd x-haproxy-used:\ s1
-
-listen s2
-	bind 127.0.0.1:8002
-	server srv 127.0.0.1:8080
-	reqadd x-haproxy-used:\ s2
-
diff --git a/deps/haproxy-1.4.21/tests/test-cookie-insert.cfg b/deps/haproxy-1.4.21/tests/test-cookie-insert.cfg
deleted file mode 100644
index 70ce9b0..0000000
--- a/deps/haproxy-1.4.21/tests/test-cookie-insert.cfg
+++ /dev/null
@@ -1,35 +0,0 @@
-# Test configuration. It listens on port 8000, forwards to
-# local ports 8001/8002 as two distinct servers, and relies
-# on a server running on local port 8080 to handle the request.
-
-global
-	maxconn 500
-	stats socket /tmp/sock1 mode 777 level admin
-	stats timeout 1d
-
-defaults
-	mode	http
-	option  http-server-close
-	timeout	client 30s
-	timeout server 30s
-	timeout connect 5s
-
-listen test
-	log 127.0.0.1 local0
-	option httplog
-	bind :8000
-	cookie SID insert
-	server s1 127.0.0.1:8001 cookie s1
-	server s2 127.0.0.1:8002 cookie s2
-	capture cookie toto= len 10
-
-listen s1
-	bind 127.0.0.1:8001
-	server srv 127.0.0.1:8080
-	reqadd x-haproxy-used:\ s1
-
-listen s2
-	bind 127.0.0.1:8002
-	server srv 127.0.0.1:8080
-	reqadd x-haproxy-used:\ s2
-
diff --git a/deps/haproxy-1.4.21/tests/test-cookie-passive.cfg b/deps/haproxy-1.4.21/tests/test-cookie-passive.cfg
deleted file mode 100644
index 7533699..0000000
--- a/deps/haproxy-1.4.21/tests/test-cookie-passive.cfg
+++ /dev/null
@@ -1,35 +0,0 @@
-# Test configuration. It listens on port 8000, forwards to
-# local ports 8001/8002 as two distinct servers, and relies
-# on a server running on local port 8080 to handle the request.
-
-global
-	maxconn 500
-	stats socket /tmp/sock1 mode 777 level admin
-	stats timeout 1d
-
-defaults
-	mode	http
-	option  http-server-close
-	timeout	client 30s
-	timeout server 30s
-	timeout connect 5s
-
-listen test
-	log 127.0.0.1 local0
-	option httplog
-	bind :8000
-	cookie SID
-	server s1 127.0.0.1:8001 cookie s1
-	server s2 127.0.0.1:8002 cookie s2
-	capture cookie toto= len 10
-
-listen s1
-	bind 127.0.0.1:8001
-	server srv 127.0.0.1:8080
-	reqadd x-haproxy-used:\ s1
-
-listen s2
-	bind 127.0.0.1:8002
-	server srv 127.0.0.1:8080
-	reqadd x-haproxy-used:\ s2
-
diff --git a/deps/haproxy-1.4.21/tests/test-cookie-prefix.cfg b/deps/haproxy-1.4.21/tests/test-cookie-prefix.cfg
deleted file mode 100644
index f000521..0000000
--- a/deps/haproxy-1.4.21/tests/test-cookie-prefix.cfg
+++ /dev/null
@@ -1,35 +0,0 @@
-# Test configuration. It listens on port 8000, forwards to
-# local ports 8001/8002 as two distinct servers, and relies
-# on a server running on local port 8080 to handle the request.
-
-global
-	maxconn 500
-	stats socket /tmp/sock1 mode 777 level admin
-	stats timeout 1d
-
-defaults
-	mode	http
-	option  http-server-close
-	timeout	client 30s
-	timeout server 30s
-	timeout connect 5s
-
-listen test
-	log 127.0.0.1 local0
-	option httplog
-	bind :8000
-	cookie SID prefix 
-	server s1 127.0.0.1:8001 cookie s1
-	server s2 127.0.0.1:8002 cookie s2
-	capture cookie toto= len 10
-
-listen s1
-	bind 127.0.0.1:8001
-	server srv 127.0.0.1:8080
-	reqadd x-haproxy-used:\ s1
-
-listen s2
-	bind 127.0.0.1:8002
-	server srv 127.0.0.1:8080
-	reqadd x-haproxy-used:\ s2
-
diff --git a/deps/haproxy-1.4.21/tests/test-cookie-rewrite.cfg b/deps/haproxy-1.4.21/tests/test-cookie-rewrite.cfg
deleted file mode 100644
index 87b3f7f..0000000
--- a/deps/haproxy-1.4.21/tests/test-cookie-rewrite.cfg
+++ /dev/null
@@ -1,35 +0,0 @@
-# Test configuration. It listens on port 8000, forwards to
-# local ports 8001/8002 as two distinct servers, and relies
-# on a server running on local port 8080 to handle the request.
-
-global
-	maxconn 500
-	stats socket /tmp/sock1 mode 777 level admin
-	stats timeout 1d
-
-defaults
-	mode	http
-	option  http-server-close
-	timeout	client 30s
-	timeout server 30s
-	timeout connect 5s
-
-listen test
-	log 127.0.0.1 local0
-	option httplog
-	bind :8000
-	cookie SID rewrite
-	server s1 127.0.0.1:8001 cookie s1
-	server s2 127.0.0.1:8002 cookie s2
-	capture cookie toto= len 10
-
-listen s1
-	bind 127.0.0.1:8001
-	server srv 127.0.0.1:8080
-	reqadd x-haproxy-used:\ s1
-
-listen s2
-	bind 127.0.0.1:8002
-	server srv 127.0.0.1:8080
-	reqadd x-haproxy-used:\ s2
-
diff --git a/deps/haproxy-1.4.21/tests/test-disable-404.cfg b/deps/haproxy-1.4.21/tests/test-disable-404.cfg
deleted file mode 100644
index 25fe292..0000000
--- a/deps/haproxy-1.4.21/tests/test-disable-404.cfg
+++ /dev/null
@@ -1,61 +0,0 @@
-# This is a test configuration.
-# It makes use of a farm built from 4 active servers and 4 backup servers,
-# all listenening to different IP addresses on port 80. Health-checks are
-# TCP only on port 81 so that iptables rules permit easy selection of which
-# servers are enabled or disabled. It checks for the file /alive, and disables
-# the server if the response is 404.
-#
-# Create statistics counters this way :
-#
-#   iptables -N http
-#   iptables -A OUTPUT -p tcp --syn --dport 80 -j http
-#   for i in $(seq 1 8); do iptables -A http -d 127.0.0.$i; done
-#   iptables -A http -d 127.0.0.0/24
-#
-# Consult the statistics using iptables this way:
-#
-#   iptables --line-numbers -nxvL http
-#   iptables -Z http
-# 
-# Block individual servers like this :
-#   iptables -I INPUT -p tcp --dport 81 -d 127.0.0.1 -j DROP
-#
-# Enable each server like this :
-#   touch $SRV_ROOT/alive
-#
-# Disable each server like this :
-#   rm -f $SRV_ROOT/alive
-#
-
-global
-	maxconn    1000
-        stats socket /tmp/sock1 mode 600
-        stats timeout 3000
-        stats maxconn 2000
-
-listen  sample1
-        mode       http
-        retries    1
-        redispatch
-        contimeout 1000
-        clitimeout 5000
-        srvtimeout 5000
-        maxconn    40000
-        bind       :8080
-	cookie     SRV insert indirect nocache
-        #balance    source
-        balance    roundrobin
-	option     allbackups
-        server     act1 127.0.0.1:80 cookie a1 weight 10 check port 81 inter 1000 fall 4
-        server     act2 127.0.0.2:80 cookie a2 weight 20 check port 81 inter 1000 fall 4
-        server     act3 127.0.0.3:80 cookie a3 weight 30 check port 81 inter 1000 fall 4
-        server     act4 127.0.0.4:80 cookie a4 weight 40 check port 81 inter 1000 fall 4
-        server     bck1 127.0.0.5:80 cookie b1 weight 10 check port 81 inter 1000 fall 4 backup
-        server     bck2 127.0.0.6:80 cookie b2 weight 20 check port 81 inter 1000 fall 4 backup
-        server     bck3 127.0.0.7:80 cookie b3 weight 30 check port 81 inter 1000 fall 4 backup
-        server     bck4 127.0.0.8:80 cookie b4 weight 40 check port 81 inter 1000 fall 4 backup
-        option     httpclose
-	stats      uri /stats
-	stats      refresh 5
-	option     httpchk GET /alive
-	http-check disable-on-404
diff --git a/deps/haproxy-1.4.21/tests/test-fsm.cfg b/deps/haproxy-1.4.21/tests/test-fsm.cfg
deleted file mode 100644
index 8fcf265..0000000
--- a/deps/haproxy-1.4.21/tests/test-fsm.cfg
+++ /dev/null
@@ -1,347 +0,0 @@
-# This is a test configuration.
-# It exercises some critical state machine transitions. Start it in debug
-# mode with syslogd listening to UDP socket, facility local0.
-
-########### test#0001: process_cli(), read or write error
-# setup :
-#   server = (printf "HTTP/1.0 200 OK\r\n\r\n";cat /dev/zero) | nc -lp4000
-#   client = (printf "GET / HTTP/1.0\r\n\r\n";cat) | nc 127.1 8001 >/dev/null
-# action : kill client during transfer (Ctrl-C)
-# result : both sides must close, and logs must report "CD" flags with
-#          valid timers and counters. (note: high CPU usage expected)
-# example: 0/0/3/0/5293 200 76420076 - - CD--
-
-########### test#0002: process_cli(), read closed on client side first
-# setup :
-#   server = (printf "HTTP/1.0 200 OK\r\n\r\n";cat /dev/zero) | nc -lp4000
-#   client = (printf "GET / HTTP/1.0\r\n\r\n";cat) | nc 127.1 8001
-# action : end client output during transfer (Ctrl-D)
-# result : client exits, log is emitted immediately, server must be terminated
-#          by hand. Logs indicate "----" with correct timers.
-# example: 0/0/3/0/5293 200 76420076 - - ----
-# note   : test#0003 is triggered immediately after this test
-
-########### test3: process_cli(), read closed on server side first
-# setup :
-#   server = (printf "HTTP/1.0 200 OK\r\n\r\n";cat) | nc -lp4000
-#   client = (printf "GET / HTTP/1.0\r\n\r\n";cat) | nc 127.1 8001
-# action : end server output during transfer (Ctrl-D)
-# result : server exits, log is emitted immediately, client must be terminated
-#          by hand. Logs indicate "----" with correct timers.
-# example: 0/0/3/0/5293 200 76420076 - - ----
-# note   : test#0002 is triggered immediately after this test
-
-########### test4: process_cli(), read timeout on client side
-# setup :
-#   server = (printf "HTTP/1.0 200 OK\r\n\r\n";cat) | nc -lp4000
-#   client = (printf "GET / HTTP/1.0\r\n\r\n";cat) | nc 127.1 8001
-# action : wait at least 7 seconds and check the logs
-# result : log is emitted immediately, client and server must be terminated
-#          by hand. Logs indicate "cD--" with correct timers.
-# example: 0/0/1/0/7006 200 19 - - cD--
-# note   : test#0003 is triggered immediately after this test
-
-########### test5: ability to restart read after a request buffer full
-# setup :
-#   server = (printf "HTTP/1.0 200 OK\r\n\r\n"; cat) | nc -lp4000
-#   client = (printf "GET / HTTP/1.0\r\n\r\n";cat 8k.txt;cat) | nc 127.1 8001
-# action : enter data on the client, press enter, then Ctrl-D
-# result : data transferred to the server, client exits, log is emitted
-#          immediately, server must be terminated by hand. Logs indicate
-#          "----" with correct timers.
-# example: 0/0/0/0/3772 200 19 - - ----
-
-########### test6: ability to restart read after a request buffer partially full
-# setup :
-#   server = (printf "HTTP/1.0 200 OK\r\n\r\n"; cat) | nc -lp4000
-#   client = (printf "GET / HTTP/1.0\r\n\r\n";cat 7k.txt;cat) | nc 127.1 8001
-# action : enter data on the client, press enter, then Ctrl-D
-# result : data transferred to the server, client exits, log is emitted
-#          immediately, server must be terminated by hand. Logs indicate
-#          "----" with correct timers.
-# example: 0/0/0/0/3772 200 19 - - ----
-
-########### test7: ability to restart read after a response buffer full
-# setup :
-#   server = (printf "HTTP/1.0 200 OK\r\n\r\n";cat 8k.txt; cat) | nc -lp4000
-#   client = (printf "GET / HTTP/1.0\r\n\r\n";cat) | nc 127.1 8001
-# action : enter data on the server, press enter, then Ctrl-D
-# result : data transferred to the client, server exits, log is emitted
-#          immediately, client must be terminated by hand. Logs indicate
-#          "----" with correct timers.
-# example: 0/0/0/0/3087 200 8242 - - ----
-
-########### test8: ability to restart read after a response buffer partially full
-# setup :
-#   server = (printf "HTTP/1.0 200 OK\r\n\r\n";cat 7k.txt; cat) | nc -lp4000
-#   client = (printf "GET / HTTP/1.0\r\n\r\n";cat) | nc 127.1 8001
-# action : enter data on the server, press enter, then Ctrl-D
-# result : data transferred to the client, server exits, log is emitted
-#          immediately, client must be terminated by hand. Logs indicate
-#          "----" with correct timers.
-# example: 0/0/0/0/5412 200 7213 - - ----
-
-########### test9: process_cli(), read timeout on empty request
-# setup :
-#   server = (printf "HTTP/1.0 200 OK\r\n\r\n";cat) | nc -lp4000
-#   client = nc 127.1 8001
-# action : wait at least 5 seconds and check the logs
-# result : client returns 408, log is emitted immediately, server must be
-#          terminated by hand. Logs indicate "cR--" with correct timers
-#          and "<BADREQ>"
-# example: -1/-1/-1/-1/5000 408 212 - - cR--
-
-########### test10: process_cli(), read timeout on client headers
-# setup :
-#   server = (printf "HTTP/1.0 200 OK\r\n\r\n";cat) | nc -lp4000
-#   client = (printf "GET / HTTP/1.0\r\nTest: test\r\n";cat) | nc 127.1 8001
-# action : wait at least 5 seconds and check the logs
-# result : client returns 408, log is emitted immediately, both must be
-#          terminated by hand. Logs indicate "cR--" with correct timers
-#          and "<BADREQ>"
-# example: -1/-1/-1/-1/5004 408 212 - - cR--
-
-########### test11: process_cli(), read abort on empty request
-# setup :
-#   server = (printf "HTTP/1.0 200 OK\r\n\r\n";cat) | nc -lp4000
-#   client = echo -n | nc 127.1 8001
-# action : just check the logs after the client immediately returns
-# result : client returns 400, log is emitted immediately, server must be
-#          terminated by hand. Logs indicate "CR--" with correct timers
-#          and "<BADREQ>"
-# example: -1/-1/-1/-1/0 400 187 - - CR--
-
-########### test12: process_cli(), read abort on client headers
-# setup :
-#   server = (printf "HTTP/1.0 200 OK\r\n\r\n";cat) | nc -lp4000
-#   client = (printf "GET / HTTP/1.0\r\nTest: test\r\n") | nc 127.1 8001
-# action : just check the logs after the client immediately returns
-# result : client returns 400, log is emitted immediately, server must be
-#          terminated by hand. Logs indicate "CR--" with correct timers
-#          and "<BADREQ>"
-# example: -1/-1/-1/-1/0 400 187 - - CR--
-
-########### test13: process_srv(), read timeout on empty response
-# setup :
-#   server = nc -lp4000
-#   client = (printf "GET / HTTP/1.0\r\n\r\n"; cat) | nc 127.1 8001
-# action : wait 9 seconds and check response
-# result : client exits with 504, log is emitted immediately, client must be
-#          terminated by hand. Logs indicate "sH--" with correct timers.
-# example: 0/0/0/-1/8002 504 194 - - sH--
-
-########### test14: process_srv(), closed client during response timeout
-# setup :
-#   server = nc6 --half-close -lp4000
-#   client = (printf "GET / HTTP/1.0\r\n\r\n"; sleep 1) | nc 127.1 8001
-# action : wait 9 seconds and check response
-# result : client exits with 504, log is emitted immediately, server exits
-#          immediately. Logs indicate "sH--" with correct timers, which
-#          is 8s regardless of the "sleep 1".
-# example: 0/0/0/-1/8002 504 194 - - sH--
-
-########### test15: process_srv(), client close not causing server close
-# setup :
-#   server = nc6 -lp4000
-#   client = (printf "GET / HTTP/1.0\r\n\r\n"; sleep 1) | nc 127.1 8001
-# action : wait 9 second and check response
-# result : client exits with 504, log is emitted immediately, server exits
-#          immediately. Logs indicate "sH--" with correct timers, which
-#          is 8s regardless of the "sleep 1".
-# example: 0/0/0/-1/8002 504 194 - - sH--
-
-########### test16: process_srv(), read timeout on server headers
-# setup :
-#   server = (printf "HTTP/1.0 200 OK\r\nTest: test\r\n";cat) | nc -lp4000
-#   client = (printf "GET / HTTP/1.0\r\n\r\n"; cat) | nc 127.1 8001
-# action : wait 8 seconds and check response
-# result : client exits with 504, log is emitted immediately, both must be
-#          terminated by hand. Logs indicate "sH--" with correct timers.
-# example: 0/0/0/-1/8004 504 223 - - sH--
-
-########### test17: process_srv(), connection time-out
-# setup :
-#   config = retries 1
-#   server = none
-#   client = (printf "GET / HTTP/1.0\r\n\r\n";cat) | nc 127.1 8002
-# action : wait at least 12 seconds and check the logs
-# result : client returns 503 and must be terminated by hand. Log is emitted
-#          immediately. Logs indicate "sC--" with correct timers.
-# example: 0/0/-1/-1/12001 503 212 - - sC--
-
-########### test18: process_srv(), client close during connection time-out
-# setup :
-#   config = retries 1
-#   server = none
-#   client = (printf "GET / HTTP/1.0\r\n\r\n";sleep 1) | nc 127.1 8002
-# action : wait at least 12 seconds and check the logs
-# result : client returns 503 and automatically closes. Log is emitted
-#          immediately. Logs indicate "sC--" with correct timers.
-# example: 0/0/-1/-1/12001 503 212 - - sC--
-
-########### test19: process_srv(), immediate server close after empty response
-# setup :
-#   server = echo -n | nc -lp4000
-#   client = (printf "GET / HTTP/1.0\r\n\r\n") | nc 127.1 8001
-# action : just check logs after immediate return.
-# result : client and server exit with 502, log is emitted immediately. Logs
-#          indicate "SH--" with correct timers.
-# example: 0/0/0/-1/0 502 204 - - SH--
-
-########### test20: process_srv(), immediate server close after incomplete headers
-# setup :
-#   server = (printf "HTTP/1.0 200 OK\r\nTest: test\r\n") | nc -lp4000
-#   client = (printf "GET / HTTP/1.0\r\n\r\n") | nc 127.1 8001
-# action : just check logs after immediate return.
-# result : client and server exit with 502, log is emitted immediately. Logs
-#          indicate "SH--" with correct timers.
-# example: 0/0/0/-1/0 502 233 - - SH--
-
-########### test21: process_srv(), immediate server close after complete headers
-# setup :
-#   server = (printf "HTTP/1.0 200 OK\r\nTest: test\r\n\r\n") | nc -lp4000
-#   client = (printf "GET / HTTP/1.0\r\n\r\n") | nc 127.1 8001
-# action : just check logs after immediate return.
-# result : client and server exit with 200, log is emitted immediately. Logs
-#          indicate "----" with correct timers.
-# example: 0/0/0/0/0 200 31 - - ----
-
-########### test22: process_srv(), timeout on request body
-# setup :
-#   server = (printf "HTTP/1.0 200 OK\r\nTest: test\r\n\r\n") | nc -lp4000
-#   client = (printf "POST / HTTP/1.0\r\nContent-length: 20\r\n\r\n";cat) | nc 127.1 8001
-# action : wait 7s for the request body to timeout.
-# result : The server receives the request and responds immediately with 200.
-#          Log is emitted after the timeout occurs. Logs indicate "cD--" with correct timers.
-# example: 1/0/0/0/7004 200 31 - - cD--
-
-########### test23: process_srv(), client close on request body
-# setup :
-#   server = (printf "HTTP/1.0 200 OK\r\nTest: test\r\n\r\n") | nc -lp4000
-#   client = (printf "POST / HTTP/1.0\r\nContent-length: 20\r\n\r\n";cat) | nc 127.1 8001
-# action : wait 2s then press Ctrl-C on the client
-# result : The server immediately aborts and the logs are emitted immediately with a 400.
-#          Logs indicate "CD--" with correct timers.
-# example: 1/0/0/0/1696 400 31 - - CD--
-
-########### test24 process_srv(), server close on request body
-# setup :
-#   server = (printf "HTTP/1.0 200 OK\r\nTest: test\r\n\r\n") | nc -lp4000
-#   client = (printf "POST / HTTP/1.0\r\nContent-length: 20\r\n\r\n";cat) | nc 127.1 8001
-# action : wait 2s then press Ctrl-C on the server and press enter a few times on the client
-# result : The logs are emitted immediately with a 200 (server's incomplete response).
-#          Logs indicate "SD--" with correct timers. Client must be terminated by hand.
-# example: 1/0/0/0/2186 200 31 - - SD--
-
-########### test25: process_srv(), client timeout on request body when url_param is used
-# setup :
-#   server = none
-#   client = (printf "POST / HTTP/1.0\r\nContent-length: 20\r\n\r\n";cat) | nc 127.1 8003
-# action : wait 5s for the request body to timeout.
-# result : The client receives a 408 and closes. The log is emitted immediately.
-#           Logs indicate "cD--" with correct timers.
-# example: 0/-1/-1/-1/5003 408 212 - - cD--
-
-########### test26: process_srv(), client abort on request body when url_param is used
-# setup :
-#   server = none
-#   client = (printf "POST / HTTP/1.0\r\nContent-length: 20\r\n\r\n";cat) | nc 127.1 8003
-# action : wait 2s then press Ctrl-C on the client
-# result : The logs are emitted immediately with a 400.
-#          Logs indicate "CD--" with correct timers.
-# example: 594/-1/-1/-1/594 400 187 - - CD--
-
-
-
-global
-	maxconn 100
-	log		127.0.0.1 local0
-	debug
-
-# connect to port 8000 to consult statistics
-listen stats
-        timeout client  5s
-	mode            http
-	bind            :8000
-	balance
-	stats		uri /stat
-
-# connect port 8001 to localhost:4000
-listen  frt8001
-	log		global
-        bind		:8001
-        mode		http
-	option		httplog
-        maxconn		100
-
-        timeout http-request 5s
-        timeout connect 6s
-        timeout client  7s
-        timeout server  8s
-        timeout queue   9s
-
-	balance		roundrobin
-	server		srv4000 127.0.0.1:4000
-
-# connect port 8002 to nowhere
-listen  frt8002
-	log		global
-        bind		:8002
-        mode		http
-	option		httplog
-        maxconn		100
-
-        timeout http-request 5s
-        timeout connect 6s
-        timeout client  7s
-        timeout server  8s
-        timeout queue   9s
-	retries         1
-
-	balance		url_param foo check_post
-	server		srv4000 192.168.255.255:4000
-
-# connect port 8003 to localhost:4000 with url_param
-listen  frt8003
-	log		global
-        bind		:8003
-        mode		http
-	option		httplog
-        maxconn		100
-
-        timeout http-request 5s
-        timeout connect 6s
-        timeout client  7s
-        timeout server  8s
-        timeout queue   9s
-
-	balance		url_param foo check_post
-	server		srv4000 127.0.0.1:4000
-
-
-# listen  frt8002
-# 	log		global
-#         bind		:8002
-#         mode		http
-# 	option		httplog
-#         maxconn		100
-# 
-#         timeout http-request 5s
-#         timeout connect 6s
-#         timeout client  7s
-#         timeout server  8s
-#         timeout queue   9s
-# 
-#         #tcp-request inspect-delay 4s
-#         acl white_list src 127.0.0.2
-# 
-#         tcp-request content accept if white_list
-#         tcp-request content reject if !REQ_CONTENT
-# 
-# 	balance		url_param foo check_post
-# 	#balance	url_param foo #check_post
-# 	server		srv4000 127.0.0.1:4000
-# 
-# 	# control activity this way
-# 	stats		uri /stat
-# 
diff --git a/deps/haproxy-1.4.21/tests/test-fwlc.cfg b/deps/haproxy-1.4.21/tests/test-fwlc.cfg
deleted file mode 100644
index 53a82df..0000000
--- a/deps/haproxy-1.4.21/tests/test-fwlc.cfg
+++ /dev/null
@@ -1,61 +0,0 @@
-# This is a test configuration.
-# It makes use of a farm built from 4 active servers and 4 backup servers,
-# all listenening to different IP addresses on port 80. Health-checks are
-# TCP only on port 81 so that iptables rules permit easy selection of which
-# servers are enabled or disabled.
-#
-# Create statistics counters this way :
-#
-#   iptables -N http
-#   iptables -A OUTPUT -p tcp --syn --dport 80 -j http
-#   for i in $(seq 1 8); do iptables -A http -d 127.0.0.$i; done
-#   iptables -A http -d 127.0.0.0/24
-#
-# Consult the statistics using iptables this way:
-#
-#   iptables --line-numbers -nxvL http
-#   iptables -Z http
-# 
-#
-# Block individual servers like this :
-#   iptables -I INPUT -p tcp --dport 81 -d 127.0.0.1 -j DROP
-#
-
-global
-	maxconn    1000
-        stats socket /tmp/sock1 mode 600
-        stats timeout 3000
-        stats maxconn 2000
-
-listen  sample1
-        mode       tcp
-        retries    1
-        redispatch
-        contimeout 1000
-        clitimeout 120000
-        srvtimeout 120000
-        maxconn    40000
-        bind       :8080
-        balance    leastconn
-	option     allbackups
-        server     act1 127.0.0.1:80 weight 10 maxconn 200 check inter 1000 fall 1
-        server     act2 127.0.0.2:80 weight 20 maxconn 200 check inter 1000 fall 1
-        server     act3 127.0.0.3:80 weight 30 maxconn 200 check inter 1000 fall 1
-        server     act4 127.0.0.4:80 weight 40 maxconn 200 check inter 1000 fall 1
-        server     bck1 127.0.0.5:80 weight 10 check inter 1000 fall 1 backup
-        server     bck2 127.0.0.6:80 weight 20 check inter 1000 fall 1 backup
-        server     bck3 127.0.0.7:80 weight 30 check inter 1000 fall 1 backup
-        server     bck4 127.0.0.8:80 weight 40 check inter 1000 fall 1 backup
-        option     httpclose
-
-listen  sample1
-        mode       http
-        contimeout 1000
-        clitimeout 50000
-        srvtimeout 50000
-        maxconn    40000
-        bind       :8081
-        balance    leastconn
-        option     httpclose
-	stats      uri /stats
-	stats      refresh 5
diff --git a/deps/haproxy-1.4.21/tests/test-fwrr.cfg b/deps/haproxy-1.4.21/tests/test-fwrr.cfg
deleted file mode 100644
index bf203f7..0000000
--- a/deps/haproxy-1.4.21/tests/test-fwrr.cfg
+++ /dev/null
@@ -1,51 +0,0 @@
-# This is a test configuration.
-# It makes use of a farm built from 4 active servers and 4 backup servers,
-# all listenening to different IP addresses on port 80. Health-checks are
-# TCP only on port 81 so that iptables rules permit easy selection of which
-# servers are enabled or disabled.
-#
-# Create statistics counters this way :
-#
-#   iptables -N http
-#   iptables -A OUTPUT -p tcp --syn --dport 80 -j http
-#   for i in $(seq 1 8); do iptables -A http -d 127.0.0.$i; done
-#   iptables -A http -d 127.0.0.0/24
-#
-# Consult the statistics using iptables this way:
-#
-#   iptables --line-numbers -nxvL http
-#   iptables -Z http
-# 
-#
-# Block individual servers like this :
-#   iptables -I INPUT -p tcp --dport 81 -d 127.0.0.1 -j DROP
-#
-
-global
-	maxconn    1000
-        stats socket /tmp/sock1 mode 600
-        stats timeout 3000
-        stats maxconn 2000
-
-listen  sample1
-        mode       http
-        retries    1
-        redispatch
-        contimeout 1000
-        clitimeout 5000
-        srvtimeout 5000
-        maxconn    40000
-        bind       :8080
-        balance    roundrobin
-	option     allbackups
-        server     act1 127.0.0.1:80 weight 10 check port 81 inter 1000 fall 1
-        server     act2 127.0.0.2:80 weight 20 check port 81 inter 1000 fall 1
-        server     act3 127.0.0.3:80 weight 30 check port 81 inter 1000 fall 1
-        server     act4 127.0.0.4:80 weight 40 check port 81 inter 1000 fall 1
-        server     bck1 127.0.0.5:80 weight 10 check port 81 inter 1000 fall 1 backup
-        server     bck2 127.0.0.6:80 weight 20 check port 81 inter 1000 fall 1 backup
-        server     bck3 127.0.0.7:80 weight 30 check port 81 inter 1000 fall 1 backup
-        server     bck4 127.0.0.8:80 weight 40 check port 81 inter 1000 fall 1 backup
-        option     httpclose
-	stats      uri /stats
-	stats      refresh 5
diff --git a/deps/haproxy-1.4.21/tests/test-http-send-name-hdr.cfg b/deps/haproxy-1.4.21/tests/test-http-send-name-hdr.cfg
deleted file mode 100644
index 65fc0d0..0000000
--- a/deps/haproxy-1.4.21/tests/test-http-send-name-hdr.cfg
+++ /dev/null
@@ -1,33 +0,0 @@
-# Test Rewriting Host header
-global
-       maxconn 100
-
-defaults
-	mode http
-	timeout client 10000
-	timeout server 10000
-	timeout connect 10000
-	balance roundrobin
-
-listen send-name-silo-id
-	bind :8001
-
-	# Set the test conditions: Add a new header
-	http-send-name-header X-Silo-Id
-	server srv-silo1 127.0.0.1:8080
-
-	# Add headers containing the correct values for test verification
-	reqadd X-test-server-name-header:\ X-Silo-Id
-	reqadd X-test-server-name-value:\ srv-silo1
-
-listen send-name-host
-	bind :8002
-
-	# Set the test conditions: Replace an existing header
-	http-send-name-header host
-	server srv-host 127.0.0.1:8080
-
-	# Add headers containing the correct values for test verification
-	reqadd X-test-server-name-header:\ Host
-	reqadd X-test-server-name-value:\ srv-host
-
diff --git a/deps/haproxy-1.4.21/tests/test-inspect-smtp.cfg b/deps/haproxy-1.4.21/tests/test-inspect-smtp.cfg
deleted file mode 100644
index 5cfc864..0000000
--- a/deps/haproxy-1.4.21/tests/test-inspect-smtp.cfg
+++ /dev/null
@@ -1,44 +0,0 @@
-# This is a test configuration. It listens on port 8025, waits for an incoming
-# connection, and applies the following rules :
-#   - if the address is in the white list, then accept it and forward the
-#     connection to the server (local port 25)
-#   - if the address is in the black list, then immediately drop it
-#   - otherwise, wait up to 35 seconds. If the client talks during this time,
-#     drop the connection.
-#   - then accept the connection if it passes all the tests.
-#
-# Note that the rules are evaluated at every new chunk of data read, and at
-# delay expiration. Rules which apply to incomplete data don't match as long
-# as the timer has not expired.
-
-listen block-fake-mailers
-	log 127.0.0.1:514 local0
-	option tcplog
-
-	mode tcp
-	bind :8025
-	timeout client 60s
-	timeout server 60s
-	timeout queue  60s
-	timeout connect 5s
-
-	tcp-request inspect-delay 35s
-
-	acl white_list src 127.0.0.2
-	acl black_fast src 127.0.0.3  # those ones are immediately rejected
-	acl black_slow src 127.0.0.4  # those ones are rejected after a delay
-
-	tcp-request content accept if white_list
-	tcp-request content reject if black_fast
-	tcp-request content reject if black_slow WAIT_END
-	tcp-request content reject if REQ_CONTENT
-	# note that it is possible to wait for the end of the analysis period
-	# before rejecting undesired contents
-	# tcp-request content reject if REQ_CONTENT WAIT_END
-
-	# on Linux+transparent proxy patch, it's useful to reuse the client'IP
-	# source 0.0.0.0 usesrc clientip
-
-	balance roundrobin
-	server mail 127.0.0.1:25
-
diff --git a/deps/haproxy-1.4.21/tests/test-inspect-ssl.cfg b/deps/haproxy-1.4.21/tests/test-inspect-ssl.cfg
deleted file mode 100644
index 582d1a2..0000000
--- a/deps/haproxy-1.4.21/tests/test-inspect-ssl.cfg
+++ /dev/null
@@ -1,37 +0,0 @@
-# This is a test configuration. It listens on port 8443, waits for an incoming
-# connection, and applies the following rules :
-#   - if the address is in the white list, then accept it and forward the
-#     connection to the server (local port 443)
-#   - if the address is in the black list, then immediately drop it
-#   - otherwise, wait up to 3 seconds for valid SSL data to come in. If those
-#     data are identified as SSL, the connection is immediately accepted, and
-#     if they are definitely identified as non-SSL, the connection is rejected,
-#     which will happen upon timeout if they still don't match SSL.
-
-listen block-non-ssl
-	log 127.0.0.1:514 local0
-	option tcplog
-
-	mode tcp
-	bind :8443
-	timeout  client 6s
-	timeout  server 6s
-	timeout connect 6s
-
-	tcp-request inspect-delay 4s
-
-	acl white_list src 127.0.0.2
-	acl black_list src 127.0.0.3
-
-	# note: SSLv2 is not used anymore, SSLv3.1 is TLSv1.
-	acl obsolete_ssl  req_ssl_ver   lt 3
-	acl correct_ssl   req_ssl_ver   3.0-3.1
-	acl invalid_ssl   req_ssl_ver   gt 3.1
-
-	tcp-request content accept if white_list
-	tcp-request content reject if black_list
-	tcp-request content reject if !correct_ssl
-
-	balance roundrobin
-	server srv1 127.0.0.1:443
-
diff --git a/deps/haproxy-1.4.21/tests/test-log.cfg b/deps/haproxy-1.4.21/tests/test-log.cfg
deleted file mode 100644
index a8d971c..0000000
--- a/deps/haproxy-1.4.21/tests/test-log.cfg
+++ /dev/null
@@ -1,24 +0,0 @@
-# This is a test configuration.
-# Its purpose is simply to emit logs on the loopback in order to verify
-# that the time is correct. To be used with tcpdump on lo, or with
-# "strace -s100 -esendto".
-
-global
-	log 127.0.0.1:514 local0
-
-defaults
-	balance uri
-	contimeout 5000
-	clitimeout 5000
-	srvtimeout 5000
-
-listen  http
-	log global
-	log 127.0.0.1:514 local0
-	option httplog
-        mode            http
-        bind		:8000
-        option          dontlognull
-	balance roundrobin
-	server	tux 127.0.0.1:65535 check inter 1000
-
diff --git a/deps/haproxy-1.4.21/tests/test-map-ports.cfg b/deps/haproxy-1.4.21/tests/test-map-ports.cfg
deleted file mode 100644
index a273f0e..0000000
--- a/deps/haproxy-1.4.21/tests/test-map-ports.cfg
+++ /dev/null
@@ -1,31 +0,0 @@
-# This is a test configuration.
-# It presents 4 instances using fixed and relative port assignments from
-# ports 8001 to 8004. TCP only is used, and the destination address is not
-# relevant (use netstat -an).
-
-global
-	maxconn		100
-
-defaults
-        mode            tcp
-        clitimeout      15000
-        srvtimeout      15000
-        contimeout      15000
-	balance roundrobin
-
-listen  fixed
-        bind		:8001
-	server s1 1.1.1.1:8001
-
-listen  same
-        bind		:8002
-	server s2 1.1.1.2
-
-listen  plus1000
-        bind		:8003
-	server s3 1.1.1.3:+1000
-
-listen  minus1000
-        bind		:8004
-	server s4 1.1.1.4:-1000
-
diff --git a/deps/haproxy-1.4.21/tests/test-pollers.cfg b/deps/haproxy-1.4.21/tests/test-pollers.cfg
deleted file mode 100644
index 1771715..0000000
--- a/deps/haproxy-1.4.21/tests/test-pollers.cfg
+++ /dev/null
@@ -1,15 +0,0 @@
-# This is the smallest possible configuration. It does not
-# bind to any port, and is enough to check the polling
-# system in use without disturbing any running process.
-#
-# To be used that way:  haproxy -V -f test-pollers.cfg
-
-global
-	#nosepoll
-	#noepoll
-	#nopoll
-
-# fake backend to pass the config checks
-backend dummy
-	balance
-
diff --git a/deps/haproxy-1.4.21/tests/test-redir.cfg b/deps/haproxy-1.4.21/tests/test-redir.cfg
deleted file mode 100644
index 4aebafd..0000000
--- a/deps/haproxy-1.4.21/tests/test-redir.cfg
+++ /dev/null
@@ -1,35 +0,0 @@
-# This is a test configuration.
-# It makes use of a farm built from 4 servers, 3 of which are remote and
-# referenced only via an HTTP redirect (302), and the 4th one is normal.
-# HTTP requests different from GET/HEAD should reach the servers directly
-# while GET/HEAD should get redirected for the 3 first ones.
-
-global
-	#log /dev/log local0
-	maxconn    1000
-        stats socket /tmp/sock1 mode 600
-        stats timeout 3000
-        stats maxconn 2000
-
-listen  sample1
-	#log global
-	#option httplog
-        mode       http
-        retries    1
-        option redispatch
-        contimeout 1000
-        clitimeout 5000
-        srvtimeout 5000
-        maxconn    40000
-        bind       :8080
-        #balance    source
-        balance    roundrobin
-	option     allbackups
-        server     rdr1 127.0.0.1:80 redir http://static1:80 weight 10 check inter 1000 fall 4
-        server     rdr2 127.0.0.2:80 redir http://static2:80 weight 20 check inter 1000 fall 4
-        server     rdr3 127.0.0.3:80 redir http://static3:80 weight 30 check inter 1000 fall 4
-        server     dir4 127.0.0.4:80 redir weight 30 check inter 1000 fall 4
-        option     httpclose
-	stats      uri /stats
-	stats      refresh 5
-
diff --git a/deps/haproxy-1.4.21/tests/test-redirect.cfg b/deps/haproxy-1.4.21/tests/test-redirect.cfg
deleted file mode 100644
index 582a069..0000000
--- a/deps/haproxy-1.4.21/tests/test-redirect.cfg
+++ /dev/null
@@ -1,49 +0,0 @@
-# This is a test configuration.
-# It is used to check the redirect keyword.
-
-global
-	maxconn    400
-        stats timeout 3s
-
-listen  sample1
-        mode       http
-        retries    1
-        option     redispatch
-        timeout    client  1m
-        timeout    connect 5s
-        timeout    server  1m
-        maxconn    400
-        bind       :8000
-
-	acl        url_test1 url_reg test1
-	acl        url_test2 url_reg test2
-	acl        url_test3 url_reg test3
-	acl        url_test4 url_reg test4
-
-	acl        seen hdr_sub(cookie) SEEN=1
-
-	redirect   location /abs/test code 301 if url_test1
-	redirect   prefix   /pfx/test code 302 if url_test2
-	redirect   prefix   /pfx/test code 303 drop-query if url_test3
-
-	redirect   prefix   /  code 302 set-cookie   SEEN=1 if url_test4 !seen
-	redirect   location /  code 302 clear-cookie SEEN=  if url_test4 seen
-
-	### unconditional redirection
-	#redirect   location https://example.com/ if TRUE
-
-	### parser must detect invalid syntaxes below
-	#redirect
-	#redirect   blah
-	#redirect   location 
-	#redirect   location /abs/test
-	#redirect   location /abs/test code
-	#redirect   location /abs/test code 300
-	#redirect   location /abs/test code 301
-	#redirect   location /abs/test code 304
-
-        balance    roundrobin
-        server     act1 127.0.0.1:80 weight 10
-        option     httpclose
-	stats      uri /stats
-	stats      refresh 5000ms
diff --git a/deps/haproxy-1.4.21/tests/test-retries.cfg b/deps/haproxy-1.4.21/tests/test-retries.cfg
deleted file mode 100644
index 588812c..0000000
--- a/deps/haproxy-1.4.21/tests/test-retries.cfg
+++ /dev/null
@@ -1,106 +0,0 @@
-# This is a test configuration.
-# It must load-balance across active servers. Check local apache logs to
-# verify :
-#
-#  tail /var/log/apache/access_log
-
-
-global
-	maxconn		10000
-
-defaults
-	log 127.0.0.1:514 local0
-	balance roundrobin
-	contimeout 3000
-	srvtimeout 20000
-	clitimeout 10000
-        option dontlognull
-
-listen  no_cookie
-        bind   :8000
-	retries 2
-	redispatch
-        mode   http
-	option httplog
-	balance roundrobin
-	server	dead1 1.1.1.1:80
-	server	good1 127.0.0.1:80
-
-# this one sends the connection to dead1, retries, then to good1, assigns
-# the cookie. Subsequent connection will try to s1 again and should try good1.
-listen  cookie
-        bind   :8001
-	retries 2
-	redispatch
-        mode   http
-	option httplog
-	cookie SRV insert indirect nocache
-	balance roundrobin
-	server	dead1 1.1.1.1:80 cookie s1
-	server	good1 127.0.0.1:80 cookie s1
-
-# this one sends the connection to dead1, retries, then to good1, assigns
-# the cookie. Subsequent connection will try to s1 again and will stick to it.
-listen  cookie_persist
-        bind   :8002
-	retries 2
-	redispatch
-	option persist
-        mode   http
-	option httplog
-	cookie SRV insert indirect nocache
-	balance roundrobin
-	server	dead1 1.1.1.1:80 cookie s1
-	server	good1 127.0.0.1:80 cookie s1
-
-frontend frt_default_tcp
-        bind   :8003
-        mode   tcp
-	option httplog
-	default_backend bck_default_tcp
-
-backend bck_default_tcp
-        mode   tcp
-	option httplog
-	retries 2
-	redispatch
-	balance roundrobin
-	contimeout 1000
-	srvtimeout 25000
-	server	dead1 1.1.1.1:80
-	server	good1 127.0.0.1:80
-
-frontend frt_default
-        bind   :8004
-        mode   http
-	option httplog
-	default_backend bck_default
-
-backend bck_default
-        mode   http
-	option httplog
-	retries 2
-	redispatch
-	balance roundrobin
-	contimeout 1000
-	srvtimeout 25000
-	server	dead1 1.1.1.1:80
-	server	good1 127.0.0.1:80
-
-frontend frt_use_back
-        bind   :8005
-        mode   http
-	option httplog
-	use_backend bck_use_back if TRUE
-
-backend bck_use_back
-        mode   http
-	option httplog
-	retries 2
-	redispatch
-	balance roundrobin
-	contimeout 1000
-	srvtimeout 25000
-	server	dead1 1.1.1.1:80
-	server	good1 127.0.0.1:80
-
diff --git a/deps/haproxy-1.4.21/tests/test-sched.cfg b/deps/haproxy-1.4.21/tests/test-sched.cfg
deleted file mode 100644
index 8fd1f2c..0000000
--- a/deps/haproxy-1.4.21/tests/test-sched.cfg
+++ /dev/null
@@ -1,5038 +0,0 @@
-# This is a test configuration.
-# It will provide a stats page on port 8181, with 5000 servers checked on
-# the loopback interface at random intervals. The stats page will reload
-# every 5 seconds. The goal of this test is to check that the scheduler
-# behaves correctly. In order to test it, simply fire tcpdump and select one
-# of the servers to ensure that the check interval is regular and exactly
-# equal to the <inter> parameter. Eg:
-#
-#     sudo tcpdump -tttnpi lo "tcp[13]&2!=0"  and host 127.0.0.2
-
-
-global
-	maxconn		100
-	#daemon
-	#nbproc		2
-
-listen  Stats_fnt
-        mode            http
-        bind		:8181
-        clitimeout      5000
-	contimeout	5000
-	srvtimeout	5000
-        maxconn 100
-        option  httpclose
-	balance roundrobin
-	stats uri /
-	stats refresh 5
-	stats scope Thousand_HTTP
-
-# servers created with the following command :
-# for i in $(seq 0 4999); do
-#   printf "\tserver 127.0.%d.%03d 127.0.%d.%d:80 weight 10 check inter $[RANDOM%10000] fall 2 rise 1\n" \
-#          $[i/250] $[i%250+1] $[i/250] $[i%250+1]
-# done
-backend Thousand_HTTP
-	contimeout 5000
-	srvtimeout 5000
-	balance roundrobin
-	server 127.0.0.001 127.0.0.1:80 weight 10 check inter 2233 fall 2 rise 1
-	server 127.0.0.002 127.0.0.2:80 weight 10 check inter 9145 fall 2 rise 1
-	server 127.0.0.003 127.0.0.3:80 weight 10 check inter 2096 fall 2 rise 1
-	server 127.0.0.004 127.0.0.4:80 weight 10 check inter 3403 fall 2 rise 1
-	server 127.0.0.005 127.0.0.5:80 weight 10 check inter 523 fall 2 rise 1
-	server 127.0.0.006 127.0.0.6:80 weight 10 check inter 9793 fall 2 rise 1
-	server 127.0.0.007 127.0.0.7:80 weight 10 check inter 8684 fall 2 rise 1
-	server 127.0.0.008 127.0.0.8:80 weight 10 check inter 1193 fall 2 rise 1
-	server 127.0.0.009 127.0.0.9:80 weight 10 check inter 8578 fall 2 rise 1
-	server 127.0.0.010 127.0.0.10:80 weight 10 check inter 7588 fall 2 rise 1
-	server 127.0.0.011 127.0.0.11:80 weight 10 check inter 4659 fall 2 rise 1
-	server 127.0.0.012 127.0.0.12:80 weight 10 check inter 7292 fall 2 rise 1
-	server 127.0.0.013 127.0.0.13:80 weight 10 check inter 5239 fall 2 rise 1
-	server 127.0.0.014 127.0.0.14:80 weight 10 check inter 73 fall 2 rise 1
-	server 127.0.0.015 127.0.0.15:80 weight 10 check inter 1041 fall 2 rise 1
-	server 127.0.0.016 127.0.0.16:80 weight 10 check inter 4418 fall 2 rise 1
-	server 127.0.0.017 127.0.0.17:80 weight 10 check inter 4117 fall 2 rise 1
-	server 127.0.0.018 127.0.0.18:80 weight 10 check inter 3695 fall 2 rise 1
-	server 127.0.0.019 127.0.0.19:80 weight 10 check inter 9827 fall 2 rise 1
-	server 127.0.0.020 127.0.0.20:80 weight 10 check inter 9312 fall 2 rise 1
-	server 127.0.0.021 127.0.0.21:80 weight 10 check inter 3288 fall 2 rise 1
-	server 127.0.0.022 127.0.0.22:80 weight 10 check inter 9492 fall 2 rise 1
-	server 127.0.0.023 127.0.0.23:80 weight 10 check inter 280 fall 2 rise 1
-	server 127.0.0.024 127.0.0.24:80 weight 10 check inter 9957 fall 2 rise 1
-	server 127.0.0.025 127.0.0.25:80 weight 10 check inter 395 fall 2 rise 1
-	server 127.0.0.026 127.0.0.26:80 weight 10 check inter 5815 fall 2 rise 1
-	server 127.0.0.027 127.0.0.27:80 weight 10 check inter 4711 fall 2 rise 1
-	server 127.0.0.028 127.0.0.28:80 weight 10 check inter 7141 fall 2 rise 1
-	server 127.0.0.029 127.0.0.29:80 weight 10 check inter 6846 fall 2 rise 1
-	server 127.0.0.030 127.0.0.30:80 weight 10 check inter 1838 fall 2 rise 1
-	server 127.0.0.031 127.0.0.31:80 weight 10 check inter 9104 fall 2 rise 1
-	server 127.0.0.032 127.0.0.32:80 weight 10 check inter 5954 fall 2 rise 1
-	server 127.0.0.033 127.0.0.33:80 weight 10 check inter 138 fall 2 rise 1
-	server 127.0.0.034 127.0.0.34:80 weight 10 check inter 6054 fall 2 rise 1
-	server 127.0.0.035 127.0.0.35:80 weight 10 check inter 2324 fall 2 rise 1
-	server 127.0.0.036 127.0.0.36:80 weight 10 check inter 6426 fall 2 rise 1
-	server 127.0.0.037 127.0.0.37:80 weight 10 check inter 5476 fall 2 rise 1
-	server 127.0.0.038 127.0.0.38:80 weight 10 check inter 5214 fall 2 rise 1
-	server 127.0.0.039 127.0.0.39:80 weight 10 check inter 2292 fall 2 rise 1
-	server 127.0.0.040 127.0.0.40:80 weight 10 check inter 9059 fall 2 rise 1
-	server 127.0.0.041 127.0.0.41:80 weight 10 check inter 9746 fall 2 rise 1
-	server 127.0.0.042 127.0.0.42:80 weight 10 check inter 5571 fall 2 rise 1
-	server 127.0.0.043 127.0.0.43:80 weight 10 check inter 1355 fall 2 rise 1
-	server 127.0.0.044 127.0.0.44:80 weight 10 check inter 5527 fall 2 rise 1
-	server 127.0.0.045 127.0.0.45:80 weight 10 check inter 1777 fall 2 rise 1
-	server 127.0.0.046 127.0.0.46:80 weight 10 check inter 8682 fall 2 rise 1
-	server 127.0.0.047 127.0.0.47:80 weight 10 check inter 9850 fall 2 rise 1
-	server 127.0.0.048 127.0.0.48:80 weight 10 check inter 752 fall 2 rise 1
-	server 127.0.0.049 127.0.0.49:80 weight 10 check inter 8546 fall 2 rise 1
-	server 127.0.0.050 127.0.0.50:80 weight 10 check inter 3007 fall 2 rise 1
-	server 127.0.0.051 127.0.0.51:80 weight 10 check inter 2695 fall 2 rise 1
-	server 127.0.0.052 127.0.0.52:80 weight 10 check inter 641 fall 2 rise 1
-	server 127.0.0.053 127.0.0.53:80 weight 10 check inter 5304 fall 2 rise 1
-	server 127.0.0.054 127.0.0.54:80 weight 10 check inter 5247 fall 2 rise 1
-	server 127.0.0.055 127.0.0.55:80 weight 10 check inter 7540 fall 2 rise 1
-	server 127.0.0.056 127.0.0.56:80 weight 10 check inter 6170 fall 2 rise 1
-	server 127.0.0.057 127.0.0.57:80 weight 10 check inter 8003 fall 2 rise 1
-	server 127.0.0.058 127.0.0.58:80 weight 10 check inter 2664 fall 2 rise 1
-	server 127.0.0.059 127.0.0.59:80 weight 10 check inter 2721 fall 2 rise 1
-	server 127.0.0.060 127.0.0.60:80 weight 10 check inter 665 fall 2 rise 1
-	server 127.0.0.061 127.0.0.61:80 weight 10 check inter 9402 fall 2 rise 1
-	server 127.0.0.062 127.0.0.62:80 weight 10 check inter 6924 fall 2 rise 1
-	server 127.0.0.063 127.0.0.63:80 weight 10 check inter 1217 fall 2 rise 1
-	server 127.0.0.064 127.0.0.64:80 weight 10 check inter 5633 fall 2 rise 1
-	server 127.0.0.065 127.0.0.65:80 weight 10 check inter 1706 fall 2 rise 1
-	server 127.0.0.066 127.0.0.66:80 weight 10 check inter 4743 fall 2 rise 1
-	server 127.0.0.067 127.0.0.67:80 weight 10 check inter 7165 fall 2 rise 1
-	server 127.0.0.068 127.0.0.68:80 weight 10 check inter 4124 fall 2 rise 1
-	server 127.0.0.069 127.0.0.69:80 weight 10 check inter 6481 fall 2 rise 1
-	server 127.0.0.070 127.0.0.70:80 weight 10 check inter 5687 fall 2 rise 1
-	server 127.0.0.071 127.0.0.71:80 weight 10 check inter 8539 fall 2 rise 1
-	server 127.0.0.072 127.0.0.72:80 weight 10 check inter 8047 fall 2 rise 1
-	server 127.0.0.073 127.0.0.73:80 weight 10 check inter 9784 fall 2 rise 1
-	server 127.0.0.074 127.0.0.74:80 weight 10 check inter 2564 fall 2 rise 1
-	server 127.0.0.075 127.0.0.75:80 weight 10 check inter 8972 fall 2 rise 1
-	server 127.0.0.076 127.0.0.76:80 weight 10 check inter 4146 fall 2 rise 1
-	server 127.0.0.077 127.0.0.77:80 weight 10 check inter 1572 fall 2 rise 1
-	server 127.0.0.078 127.0.0.78:80 weight 10 check inter 6947 fall 2 rise 1
-	server 127.0.0.079 127.0.0.79:80 weight 10 check inter 9128 fall 2 rise 1
-	server 127.0.0.080 127.0.0.80:80 weight 10 check inter 2540 fall 2 rise 1
-	server 127.0.0.081 127.0.0.81:80 weight 10 check inter 1148 fall 2 rise 1
-	server 127.0.0.082 127.0.0.82:80 weight 10 check inter 4607 fall 2 rise 1
-	server 127.0.0.083 127.0.0.83:80 weight 10 check inter 8442 fall 2 rise 1
-	server 127.0.0.084 127.0.0.84:80 weight 10 check inter 593 fall 2 rise 1
-	server 127.0.0.085 127.0.0.85:80 weight 10 check inter 6648 fall 2 rise 1
-	server 127.0.0.086 127.0.0.86:80 weight 10 check inter 2946 fall 2 rise 1
-	server 127.0.0.087 127.0.0.87:80 weight 10 check inter 4699 fall 2 rise 1
-	server 127.0.0.088 127.0.0.88:80 weight 10 check inter 8139 fall 2 rise 1
-	server 127.0.0.089 127.0.0.89:80 weight 10 check inter 333 fall 2 rise 1
-	server 127.0.0.090 127.0.0.90:80 weight 10 check inter 6311 fall 2 rise 1
-	server 127.0.0.091 127.0.0.91:80 weight 10 check inter 127 fall 2 rise 1
-	server 127.0.0.092 127.0.0.92:80 weight 10 check inter 7913 fall 2 rise 1
-	server 127.0.0.093 127.0.0.93:80 weight 10 check inter 4907 fall 2 rise 1
-	server 127.0.0.094 127.0.0.94:80 weight 10 check inter 4639 fall 2 rise 1
-	server 127.0.0.095 127.0.0.95:80 weight 10 check inter 4866 fall 2 rise 1
-	server 127.0.0.096 127.0.0.96:80 weight 10 check inter 9978 fall 2 rise 1
-	server 127.0.0.097 127.0.0.97:80 weight 10 check inter 2626 fall 2 rise 1
-	server 127.0.0.098 127.0.0.98:80 weight 10 check inter 3925 fall 2 rise 1
-	server 127.0.0.099 127.0.0.99:80 weight 10 check inter 1393 fall 2 rise 1
-	server 127.0.0.100 127.0.0.100:80 weight 10 check inter 4616 fall 2 rise 1
-	server 127.0.0.101 127.0.0.101:80 weight 10 check inter 744 fall 2 rise 1
-	server 127.0.0.102 127.0.0.102:80 weight 10 check inter 1362 fall 2 rise 1
-	server 127.0.0.103 127.0.0.103:80 weight 10 check inter 5240 fall 2 rise 1
-	server 127.0.0.104 127.0.0.104:80 weight 10 check inter 788 fall 2 rise 1
-	server 127.0.0.105 127.0.0.105:80 weight 10 check inter 1645 fall 2 rise 1
-	server 127.0.0.106 127.0.0.106:80 weight 10 check inter 879 fall 2 rise 1
-	server 127.0.0.107 127.0.0.107:80 weight 10 check inter 47 fall 2 rise 1
-	server 127.0.0.108 127.0.0.108:80 weight 10 check inter 4629 fall 2 rise 1
-	server 127.0.0.109 127.0.0.109:80 weight 10 check inter 312 fall 2 rise 1
-	server 127.0.0.110 127.0.0.110:80 weight 10 check inter 1759 fall 2 rise 1
-	server 127.0.0.111 127.0.0.111:80 weight 10 check inter 5043 fall 2 rise 1
-	server 127.0.0.112 127.0.0.112:80 weight 10 check inter 8912 fall 2 rise 1
-	server 127.0.0.113 127.0.0.113:80 weight 10 check inter 7337 fall 2 rise 1
-	server 127.0.0.114 127.0.0.114:80 weight 10 check inter 6216 fall 2 rise 1
-	server 127.0.0.115 127.0.0.115:80 weight 10 check inter 4709 fall 2 rise 1
-	server 127.0.0.116 127.0.0.116:80 weight 10 check inter 1351 fall 2 rise 1
-	server 127.0.0.117 127.0.0.117:80 weight 10 check inter 526 fall 2 rise 1
-	server 127.0.0.118 127.0.0.118:80 weight 10 check inter 9093 fall 2 rise 1
-	server 127.0.0.119 127.0.0.119:80 weight 10 check inter 2549 fall 2 rise 1
-	server 127.0.0.120 127.0.0.120:80 weight 10 check inter 1601 fall 2 rise 1
-	server 127.0.0.121 127.0.0.121:80 weight 10 check inter 3682 fall 2 rise 1
-	server 127.0.0.122 127.0.0.122:80 weight 10 check inter 1693 fall 2 rise 1
-	server 127.0.0.123 127.0.0.123:80 weight 10 check inter 4252 fall 2 rise 1
-	server 127.0.0.124 127.0.0.124:80 weight 10 check inter 813 fall 2 rise 1
-	server 127.0.0.125 127.0.0.125:80 weight 10 check inter 6968 fall 2 rise 1
-	server 127.0.0.126 127.0.0.126:80 weight 10 check inter 7377 fall 2 rise 1
-	server 127.0.0.127 127.0.0.127:80 weight 10 check inter 4508 fall 2 rise 1
-	server 127.0.0.128 127.0.0.128:80 weight 10 check inter 3142 fall 2 rise 1
-	server 127.0.0.129 127.0.0.129:80 weight 10 check inter 811 fall 2 rise 1
-	server 127.0.0.130 127.0.0.130:80 weight 10 check inter 3095 fall 2 rise 1
-	server 127.0.0.131 127.0.0.131:80 weight 10 check inter 1049 fall 2 rise 1
-	server 127.0.0.132 127.0.0.132:80 weight 10 check inter 1381 fall 2 rise 1
-	server 127.0.0.133 127.0.0.133:80 weight 10 check inter 5779 fall 2 rise 1
-	server 127.0.0.134 127.0.0.134:80 weight 10 check inter 9561 fall 2 rise 1
-	server 127.0.0.135 127.0.0.135:80 weight 10 check inter 3396 fall 2 rise 1
-	server 127.0.0.136 127.0.0.136:80 weight 10 check inter 8890 fall 2 rise 1
-	server 127.0.0.137 127.0.0.137:80 weight 10 check inter 9431 fall 2 rise 1
-	server 127.0.0.138 127.0.0.138:80 weight 10 check inter 9150 fall 2 rise 1
-	server 127.0.0.139 127.0.0.139:80 weight 10 check inter 3915 fall 2 rise 1
-	server 127.0.0.140 127.0.0.140:80 weight 10 check inter 3816 fall 2 rise 1
-	server 127.0.0.141 127.0.0.141:80 weight 10 check inter 1222 fall 2 rise 1
-	server 127.0.0.142 127.0.0.142:80 weight 10 check inter 5476 fall 2 rise 1
-	server 127.0.0.143 127.0.0.143:80 weight 10 check inter 1410 fall 2 rise 1
-	server 127.0.0.144 127.0.0.144:80 weight 10 check inter 3507 fall 2 rise 1
-	server 127.0.0.145 127.0.0.145:80 weight 10 check inter 7523 fall 2 rise 1
-	server 127.0.0.146 127.0.0.146:80 weight 10 check inter 1873 fall 2 rise 1
-	server 127.0.0.147 127.0.0.147:80 weight 10 check inter 3167 fall 2 rise 1
-	server 127.0.0.148 127.0.0.148:80 weight 10 check inter 2154 fall 2 rise 1
-	server 127.0.0.149 127.0.0.149:80 weight 10 check inter 3219 fall 2 rise 1
-	server 127.0.0.150 127.0.0.150:80 weight 10 check inter 4591 fall 2 rise 1
-	server 127.0.0.151 127.0.0.151:80 weight 10 check inter 6761 fall 2 rise 1
-	server 127.0.0.152 127.0.0.152:80 weight 10 check inter 4037 fall 2 rise 1
-	server 127.0.0.153 127.0.0.153:80 weight 10 check inter 2728 fall 2 rise 1
-	server 127.0.0.154 127.0.0.154:80 weight 10 check inter 2833 fall 2 rise 1
-	server 127.0.0.155 127.0.0.155:80 weight 10 check inter 3678 fall 2 rise 1
-	server 127.0.0.156 127.0.0.156:80 weight 10 check inter 3885 fall 2 rise 1
-	server 127.0.0.157 127.0.0.157:80 weight 10 check inter 9500 fall 2 rise 1
-	server 127.0.0.158 127.0.0.158:80 weight 10 check inter 1927 fall 2 rise 1
-	server 127.0.0.159 127.0.0.159:80 weight 10 check inter 2247 fall 2 rise 1
-	server 127.0.0.160 127.0.0.160:80 weight 10 check inter 8253 fall 2 rise 1
-	server 127.0.0.161 127.0.0.161:80 weight 10 check inter 860 fall 2 rise 1
-	server 127.0.0.162 127.0.0.162:80 weight 10 check inter 2534 fall 2 rise 1
-	server 127.0.0.163 127.0.0.163:80 weight 10 check inter 668 fall 2 rise 1
-	server 127.0.0.164 127.0.0.164:80 weight 10 check inter 4957 fall 2 rise 1
-	server 127.0.0.165 127.0.0.165:80 weight 10 check inter 9401 fall 2 rise 1
-	server 127.0.0.166 127.0.0.166:80 weight 10 check inter 7540 fall 2 rise 1
-	server 127.0.0.167 127.0.0.167:80 weight 10 check inter 3351 fall 2 rise 1
-	server 127.0.0.168 127.0.0.168:80 weight 10 check inter 5705 fall 2 rise 1
-	server 127.0.0.169 127.0.0.169:80 weight 10 check inter 9472 fall 2 rise 1
-	server 127.0.0.170 127.0.0.170:80 weight 10 check inter 5718 fall 2 rise 1
-	server 127.0.0.171 127.0.0.171:80 weight 10 check inter 8409 fall 2 rise 1
-	server 127.0.0.172 127.0.0.172:80 weight 10 check inter 1139 fall 2 rise 1
-	server 127.0.0.173 127.0.0.173:80 weight 10 check inter 8901 fall 2 rise 1
-	server 127.0.0.174 127.0.0.174:80 weight 10 check inter 4858 fall 2 rise 1
-	server 127.0.0.175 127.0.0.175:80 weight 10 check inter 1390 fall 2 rise 1
-	server 127.0.0.176 127.0.0.176:80 weight 10 check inter 8941 fall 2 rise 1
-	server 127.0.0.177 127.0.0.177:80 weight 10 check inter 6033 fall 2 rise 1
-	server 127.0.0.178 127.0.0.178:80 weight 10 check inter 867 fall 2 rise 1
-	server 127.0.0.179 127.0.0.179:80 weight 10 check inter 6754 fall 2 rise 1
-	server 127.0.0.180 127.0.0.180:80 weight 10 check inter 5908 fall 2 rise 1
-	server 127.0.0.181 127.0.0.181:80 weight 10 check inter 6848 fall 2 rise 1
-	server 127.0.0.182 127.0.0.182:80 weight 10 check inter 4744 fall 2 rise 1
-	server 127.0.0.183 127.0.0.183:80 weight 10 check inter 656 fall 2 rise 1
-	server 127.0.0.184 127.0.0.184:80 weight 10 check inter 4669 fall 2 rise 1
-	server 127.0.0.185 127.0.0.185:80 weight 10 check inter 9913 fall 2 rise 1
-	server 127.0.0.186 127.0.0.186:80 weight 10 check inter 1772 fall 2 rise 1
-	server 127.0.0.187 127.0.0.187:80 weight 10 check inter 2718 fall 2 rise 1
-	server 127.0.0.188 127.0.0.188:80 weight 10 check inter 1473 fall 2 rise 1
-	server 127.0.0.189 127.0.0.189:80 weight 10 check inter 3948 fall 2 rise 1
-	server 127.0.0.190 127.0.0.190:80 weight 10 check inter 5019 fall 2 rise 1
-	server 127.0.0.191 127.0.0.191:80 weight 10 check inter 602 fall 2 rise 1
-	server 127.0.0.192 127.0.0.192:80 weight 10 check inter 4648 fall 2 rise 1
-	server 127.0.0.193 127.0.0.193:80 weight 10 check inter 2365 fall 2 rise 1
-	server 127.0.0.194 127.0.0.194:80 weight 10 check inter 8841 fall 2 rise 1
-	server 127.0.0.195 127.0.0.195:80 weight 10 check inter 6051 fall 2 rise 1
-	server 127.0.0.196 127.0.0.196:80 weight 10 check inter 6774 fall 2 rise 1
-	server 127.0.0.197 127.0.0.197:80 weight 10 check inter 5267 fall 2 rise 1
-	server 127.0.0.198 127.0.0.198:80 weight 10 check inter 1418 fall 2 rise 1
-	server 127.0.0.199 127.0.0.199:80 weight 10 check inter 8632 fall 2 rise 1
-	server 127.0.0.200 127.0.0.200:80 weight 10 check inter 792 fall 2 rise 1
-	server 127.0.0.201 127.0.0.201:80 weight 10 check inter 9247 fall 2 rise 1
-	server 127.0.0.202 127.0.0.202:80 weight 10 check inter 6321 fall 2 rise 1
-	server 127.0.0.203 127.0.0.203:80 weight 10 check inter 7089 fall 2 rise 1
-	server 127.0.0.204 127.0.0.204:80 weight 10 check inter 4157 fall 2 rise 1
-	server 127.0.0.205 127.0.0.205:80 weight 10 check inter 9948 fall 2 rise 1
-	server 127.0.0.206 127.0.0.206:80 weight 10 check inter 8297 fall 2 rise 1
-	server 127.0.0.207 127.0.0.207:80 weight 10 check inter 8559 fall 2 rise 1
-	server 127.0.0.208 127.0.0.208:80 weight 10 check inter 9573 fall 2 rise 1
-	server 127.0.0.209 127.0.0.209:80 weight 10 check inter 3883 fall 2 rise 1
-	server 127.0.0.210 127.0.0.210:80 weight 10 check inter 8806 fall 2 rise 1
-	server 127.0.0.211 127.0.0.211:80 weight 10 check inter 4132 fall 2 rise 1
-	server 127.0.0.212 127.0.0.212:80 weight 10 check inter 9803 fall 2 rise 1
-	server 127.0.0.213 127.0.0.213:80 weight 10 check inter 9372 fall 2 rise 1
-	server 127.0.0.214 127.0.0.214:80 weight 10 check inter 7561 fall 2 rise 1
-	server 127.0.0.215 127.0.0.215:80 weight 10 check inter 6897 fall 2 rise 1
-	server 127.0.0.216 127.0.0.216:80 weight 10 check inter 6162 fall 2 rise 1
-	server 127.0.0.217 127.0.0.217:80 weight 10 check inter 8828 fall 2 rise 1
-	server 127.0.0.218 127.0.0.218:80 weight 10 check inter 8565 fall 2 rise 1
-	server 127.0.0.219 127.0.0.219:80 weight 10 check inter 2484 fall 2 rise 1
-	server 127.0.0.220 127.0.0.220:80 weight 10 check inter 6048 fall 2 rise 1
-	server 127.0.0.221 127.0.0.221:80 weight 10 check inter 3137 fall 2 rise 1
-	server 127.0.0.222 127.0.0.222:80 weight 10 check inter 2244 fall 2 rise 1
-	server 127.0.0.223 127.0.0.223:80 weight 10 check inter 1438 fall 2 rise 1
-	server 127.0.0.224 127.0.0.224:80 weight 10 check inter 8941 fall 2 rise 1
-	server 127.0.0.225 127.0.0.225:80 weight 10 check inter 3302 fall 2 rise 1
-	server 127.0.0.226 127.0.0.226:80 weight 10 check inter 3864 fall 2 rise 1
-	server 127.0.0.227 127.0.0.227:80 weight 10 check inter 7030 fall 2 rise 1
-	server 127.0.0.228 127.0.0.228:80 weight 10 check inter 3626 fall 2 rise 1
-	server 127.0.0.229 127.0.0.229:80 weight 10 check inter 103 fall 2 rise 1
-	server 127.0.0.230 127.0.0.230:80 weight 10 check inter 5556 fall 2 rise 1
-	server 127.0.0.231 127.0.0.231:80 weight 10 check inter 2112 fall 2 rise 1
-	server 127.0.0.232 127.0.0.232:80 weight 10 check inter 5457 fall 2 rise 1
-	server 127.0.0.233 127.0.0.233:80 weight 10 check inter 1228 fall 2 rise 1
-	server 127.0.0.234 127.0.0.234:80 weight 10 check inter 3638 fall 2 rise 1
-	server 127.0.0.235 127.0.0.235:80 weight 10 check inter 315 fall 2 rise 1
-	server 127.0.0.236 127.0.0.236:80 weight 10 check inter 7488 fall 2 rise 1
-	server 127.0.0.237 127.0.0.237:80 weight 10 check inter 2341 fall 2 rise 1
-	server 127.0.0.238 127.0.0.238:80 weight 10 check inter 4123 fall 2 rise 1
-	server 127.0.0.239 127.0.0.239:80 weight 10 check inter 1372 fall 2 rise 1
-	server 127.0.0.240 127.0.0.240:80 weight 10 check inter 3205 fall 2 rise 1
-	server 127.0.0.241 127.0.0.241:80 weight 10 check inter 1546 fall 2 rise 1
-	server 127.0.0.242 127.0.0.242:80 weight 10 check inter 2080 fall 2 rise 1
-	server 127.0.0.243 127.0.0.243:80 weight 10 check inter 765 fall 2 rise 1
-	server 127.0.0.244 127.0.0.244:80 weight 10 check inter 1928 fall 2 rise 1
-	server 127.0.0.245 127.0.0.245:80 weight 10 check inter 751 fall 2 rise 1
-	server 127.0.0.246 127.0.0.246:80 weight 10 check inter 2681 fall 2 rise 1
-	server 127.0.0.247 127.0.0.247:80 weight 10 check inter 1334 fall 2 rise 1
-	server 127.0.0.248 127.0.0.248:80 weight 10 check inter 156 fall 2 rise 1
-	server 127.0.0.249 127.0.0.249:80 weight 10 check inter 2521 fall 2 rise 1
-	server 127.0.0.250 127.0.0.250:80 weight 10 check inter 9588 fall 2 rise 1
-	server 127.0.1.001 127.0.1.1:80 weight 10 check inter 9815 fall 2 rise 1
-	server 127.0.1.002 127.0.1.2:80 weight 10 check inter 2676 fall 2 rise 1
-	server 127.0.1.003 127.0.1.3:80 weight 10 check inter 4660 fall 2 rise 1
-	server 127.0.1.004 127.0.1.4:80 weight 10 check inter 4667 fall 2 rise 1
-	server 127.0.1.005 127.0.1.5:80 weight 10 check inter 4267 fall 2 rise 1
-	server 127.0.1.006 127.0.1.6:80 weight 10 check inter 5653 fall 2 rise 1
-	server 127.0.1.007 127.0.1.7:80 weight 10 check inter 1104 fall 2 rise 1
-	server 127.0.1.008 127.0.1.8:80 weight 10 check inter 8540 fall 2 rise 1
-	server 127.0.1.009 127.0.1.9:80 weight 10 check inter 6397 fall 2 rise 1
-	server 127.0.1.010 127.0.1.10:80 weight 10 check inter 2127 fall 2 rise 1
-	server 127.0.1.011 127.0.1.11:80 weight 10 check inter 8175 fall 2 rise 1
-	server 127.0.1.012 127.0.1.12:80 weight 10 check inter 3177 fall 2 rise 1
-	server 127.0.1.013 127.0.1.13:80 weight 10 check inter 1542 fall 2 rise 1
-	server 127.0.1.014 127.0.1.14:80 weight 10 check inter 4442 fall 2 rise 1
-	server 127.0.1.015 127.0.1.15:80 weight 10 check inter 4575 fall 2 rise 1
-	server 127.0.1.016 127.0.1.16:80 weight 10 check inter 2206 fall 2 rise 1
-	server 127.0.1.017 127.0.1.17:80 weight 10 check inter 4174 fall 2 rise 1
-	server 127.0.1.018 127.0.1.18:80 weight 10 check inter 6643 fall 2 rise 1
-	server 127.0.1.019 127.0.1.19:80 weight 10 check inter 1592 fall 2 rise 1
-	server 127.0.1.020 127.0.1.20:80 weight 10 check inter 597 fall 2 rise 1
-	server 127.0.1.021 127.0.1.21:80 weight 10 check inter 7630 fall 2 rise 1
-	server 127.0.1.022 127.0.1.22:80 weight 10 check inter 9379 fall 2 rise 1
-	server 127.0.1.023 127.0.1.23:80 weight 10 check inter 1716 fall 2 rise 1
-	server 127.0.1.024 127.0.1.24:80 weight 10 check inter 7867 fall 2 rise 1
-	server 127.0.1.025 127.0.1.25:80 weight 10 check inter 5079 fall 2 rise 1
-	server 127.0.1.026 127.0.1.26:80 weight 10 check inter 196 fall 2 rise 1
-	server 127.0.1.027 127.0.1.27:80 weight 10 check inter 5089 fall 2 rise 1
-	server 127.0.1.028 127.0.1.28:80 weight 10 check inter 9681 fall 2 rise 1
-	server 127.0.1.029 127.0.1.29:80 weight 10 check inter 9157 fall 2 rise 1
-	server 127.0.1.030 127.0.1.30:80 weight 10 check inter 2803 fall 2 rise 1
-	server 127.0.1.031 127.0.1.31:80 weight 10 check inter 6265 fall 2 rise 1
-	server 127.0.1.032 127.0.1.32:80 weight 10 check inter 2002 fall 2 rise 1
-	server 127.0.1.033 127.0.1.33:80 weight 10 check inter 48 fall 2 rise 1
-	server 127.0.1.034 127.0.1.34:80 weight 10 check inter 4547 fall 2 rise 1
-	server 127.0.1.035 127.0.1.35:80 weight 10 check inter 4716 fall 2 rise 1
-	server 127.0.1.036 127.0.1.36:80 weight 10 check inter 2215 fall 2 rise 1
-	server 127.0.1.037 127.0.1.37:80 weight 10 check inter 6249 fall 2 rise 1
-	server 127.0.1.038 127.0.1.38:80 weight 10 check inter 9352 fall 2 rise 1
-	server 127.0.1.039 127.0.1.39:80 weight 10 check inter 5426 fall 2 rise 1
-	server 127.0.1.040 127.0.1.40:80 weight 10 check inter 6285 fall 2 rise 1
-	server 127.0.1.041 127.0.1.41:80 weight 10 check inter 3743 fall 2 rise 1
-	server 127.0.1.042 127.0.1.42:80 weight 10 check inter 1486 fall 2 rise 1
-	server 127.0.1.043 127.0.1.43:80 weight 10 check inter 5122 fall 2 rise 1
-	server 127.0.1.044 127.0.1.44:80 weight 10 check inter 1905 fall 2 rise 1
-	server 127.0.1.045 127.0.1.45:80 weight 10 check inter 2324 fall 2 rise 1
-	server 127.0.1.046 127.0.1.46:80 weight 10 check inter 9773 fall 2 rise 1
-	server 127.0.1.047 127.0.1.47:80 weight 10 check inter 2369 fall 2 rise 1
-	server 127.0.1.048 127.0.1.48:80 weight 10 check inter 4576 fall 2 rise 1
-	server 127.0.1.049 127.0.1.49:80 weight 10 check inter 1555 fall 2 rise 1
-	server 127.0.1.050 127.0.1.50:80 weight 10 check inter 4189 fall 2 rise 1
-	server 127.0.1.051 127.0.1.51:80 weight 10 check inter 1819 fall 2 rise 1
-	server 127.0.1.052 127.0.1.52:80 weight 10 check inter 7617 fall 2 rise 1
-	server 127.0.1.053 127.0.1.53:80 weight 10 check inter 5549 fall 2 rise 1
-	server 127.0.1.054 127.0.1.54:80 weight 10 check inter 6617 fall 2 rise 1
-	server 127.0.1.055 127.0.1.55:80 weight 10 check inter 2707 fall 2 rise 1
-	server 127.0.1.056 127.0.1.56:80 weight 10 check inter 4127 fall 2 rise 1
-	server 127.0.1.057 127.0.1.57:80 weight 10 check inter 9528 fall 2 rise 1
-	server 127.0.1.058 127.0.1.58:80 weight 10 check inter 645 fall 2 rise 1
-	server 127.0.1.059 127.0.1.59:80 weight 10 check inter 4027 fall 2 rise 1
-	server 127.0.1.060 127.0.1.60:80 weight 10 check inter 2536 fall 2 rise 1
-	server 127.0.1.061 127.0.1.61:80 weight 10 check inter 3207 fall 2 rise 1
-	server 127.0.1.062 127.0.1.62:80 weight 10 check inter 6463 fall 2 rise 1
-	server 127.0.1.063 127.0.1.63:80 weight 10 check inter 6482 fall 2 rise 1
-	server 127.0.1.064 127.0.1.64:80 weight 10 check inter 3751 fall 2 rise 1
-	server 127.0.1.065 127.0.1.65:80 weight 10 check inter 5319 fall 2 rise 1
-	server 127.0.1.066 127.0.1.66:80 weight 10 check inter 9143 fall 2 rise 1
-	server 127.0.1.067 127.0.1.67:80 weight 10 check inter 9809 fall 2 rise 1
-	server 127.0.1.068 127.0.1.68:80 weight 10 check inter 7521 fall 2 rise 1
-	server 127.0.1.069 127.0.1.69:80 weight 10 check inter 3887 fall 2 rise 1
-	server 127.0.1.070 127.0.1.70:80 weight 10 check inter 2510 fall 2 rise 1
-	server 127.0.1.071 127.0.1.71:80 weight 10 check inter 2611 fall 2 rise 1
-	server 127.0.1.072 127.0.1.72:80 weight 10 check inter 2369 fall 2 rise 1
-	server 127.0.1.073 127.0.1.73:80 weight 10 check inter 7157 fall 2 rise 1
-	server 127.0.1.074 127.0.1.74:80 weight 10 check inter 9039 fall 2 rise 1
-	server 127.0.1.075 127.0.1.75:80 weight 10 check inter 1352 fall 2 rise 1
-	server 127.0.1.076 127.0.1.76:80 weight 10 check inter 2069 fall 2 rise 1
-	server 127.0.1.077 127.0.1.77:80 weight 10 check inter 7504 fall 2 rise 1
-	server 127.0.1.078 127.0.1.78:80 weight 10 check inter 4144 fall 2 rise 1
-	server 127.0.1.079 127.0.1.79:80 weight 10 check inter 7144 fall 2 rise 1
-	server 127.0.1.080 127.0.1.80:80 weight 10 check inter 1317 fall 2 rise 1
-	server 127.0.1.081 127.0.1.81:80 weight 10 check inter 5537 fall 2 rise 1
-	server 127.0.1.082 127.0.1.82:80 weight 10 check inter 6359 fall 2 rise 1
-	server 127.0.1.083 127.0.1.83:80 weight 10 check inter 1912 fall 2 rise 1
-	server 127.0.1.084 127.0.1.84:80 weight 10 check inter 2246 fall 2 rise 1
-	server 127.0.1.085 127.0.1.85:80 weight 10 check inter 993 fall 2 rise 1
-	server 127.0.1.086 127.0.1.86:80 weight 10 check inter 5181 fall 2 rise 1
-	server 127.0.1.087 127.0.1.87:80 weight 10 check inter 3358 fall 2 rise 1
-	server 127.0.1.088 127.0.1.88:80 weight 10 check inter 2371 fall 2 rise 1
-	server 127.0.1.089 127.0.1.89:80 weight 10 check inter 7833 fall 2 rise 1
-	server 127.0.1.090 127.0.1.90:80 weight 10 check inter 1908 fall 2 rise 1
-	server 127.0.1.091 127.0.1.91:80 weight 10 check inter 2276 fall 2 rise 1
-	server 127.0.1.092 127.0.1.92:80 weight 10 check inter 9622 fall 2 rise 1
-	server 127.0.1.093 127.0.1.93:80 weight 10 check inter 1203 fall 2 rise 1
-	server 127.0.1.094 127.0.1.94:80 weight 10 check inter 2472 fall 2 rise 1
-	server 127.0.1.095 127.0.1.95:80 weight 10 check inter 9054 fall 2 rise 1
-	server 127.0.1.096 127.0.1.96:80 weight 10 check inter 6330 fall 2 rise 1
-	server 127.0.1.097 127.0.1.97:80 weight 10 check inter 724 fall 2 rise 1
-	server 127.0.1.098 127.0.1.98:80 weight 10 check inter 374 fall 2 rise 1
-	server 127.0.1.099 127.0.1.99:80 weight 10 check inter 9515 fall 2 rise 1
-	server 127.0.1.100 127.0.1.100:80 weight 10 check inter 2080 fall 2 rise 1
-	server 127.0.1.101 127.0.1.101:80 weight 10 check inter 6870 fall 2 rise 1
-	server 127.0.1.102 127.0.1.102:80 weight 10 check inter 4878 fall 2 rise 1
-	server 127.0.1.103 127.0.1.103:80 weight 10 check inter 158 fall 2 rise 1
-	server 127.0.1.104 127.0.1.104:80 weight 10 check inter 1779 fall 2 rise 1
-	server 127.0.1.105 127.0.1.105:80 weight 10 check inter 454 fall 2 rise 1
-	server 127.0.1.106 127.0.1.106:80 weight 10 check inter 4714 fall 2 rise 1
-	server 127.0.1.107 127.0.1.107:80 weight 10 check inter 3113 fall 2 rise 1
-	server 127.0.1.108 127.0.1.108:80 weight 10 check inter 1164 fall 2 rise 1
-	server 127.0.1.109 127.0.1.109:80 weight 10 check inter 9475 fall 2 rise 1
-	server 127.0.1.110 127.0.1.110:80 weight 10 check inter 4764 fall 2 rise 1
-	server 127.0.1.111 127.0.1.111:80 weight 10 check inter 894 fall 2 rise 1
-	server 127.0.1.112 127.0.1.112:80 weight 10 check inter 2084 fall 2 rise 1
-	server 127.0.1.113 127.0.1.113:80 weight 10 check inter 8769 fall 2 rise 1
-	server 127.0.1.114 127.0.1.114:80 weight 10 check inter 3674 fall 2 rise 1
-	server 127.0.1.115 127.0.1.115:80 weight 10 check inter 9365 fall 2 rise 1
-	server 127.0.1.116 127.0.1.116:80 weight 10 check inter 1485 fall 2 rise 1
-	server 127.0.1.117 127.0.1.117:80 weight 10 check inter 1937 fall 2 rise 1
-	server 127.0.1.118 127.0.1.118:80 weight 10 check inter 8776 fall 2 rise 1
-	server 127.0.1.119 127.0.1.119:80 weight 10 check inter 6429 fall 2 rise 1
-	server 127.0.1.120 127.0.1.120:80 weight 10 check inter 4896 fall 2 rise 1
-	server 127.0.1.121 127.0.1.121:80 weight 10 check inter 2209 fall 2 rise 1
-	server 127.0.1.122 127.0.1.122:80 weight 10 check inter 2441 fall 2 rise 1
-	server 127.0.1.123 127.0.1.123:80 weight 10 check inter 387 fall 2 rise 1
-	server 127.0.1.124 127.0.1.124:80 weight 10 check inter 2020 fall 2 rise 1
-	server 127.0.1.125 127.0.1.125:80 weight 10 check inter 8514 fall 2 rise 1
-	server 127.0.1.126 127.0.1.126:80 weight 10 check inter 8373 fall 2 rise 1
-	server 127.0.1.127 127.0.1.127:80 weight 10 check inter 2084 fall 2 rise 1
-	server 127.0.1.128 127.0.1.128:80 weight 10 check inter 9251 fall 2 rise 1
-	server 127.0.1.129 127.0.1.129:80 weight 10 check inter 926 fall 2 rise 1
-	server 127.0.1.130 127.0.1.130:80 weight 10 check inter 3673 fall 2 rise 1
-	server 127.0.1.131 127.0.1.131:80 weight 10 check inter 3714 fall 2 rise 1
-	server 127.0.1.132 127.0.1.132:80 weight 10 check inter 5629 fall 2 rise 1
-	server 127.0.1.133 127.0.1.133:80 weight 10 check inter 1461 fall 2 rise 1
-	server 127.0.1.134 127.0.1.134:80 weight 10 check inter 2418 fall 2 rise 1
-	server 127.0.1.135 127.0.1.135:80 weight 10 check inter 6088 fall 2 rise 1
-	server 127.0.1.136 127.0.1.136:80 weight 10 check inter 1352 fall 2 rise 1
-	server 127.0.1.137 127.0.1.137:80 weight 10 check inter 7020 fall 2 rise 1
-	server 127.0.1.138 127.0.1.138:80 weight 10 check inter 1031 fall 2 rise 1
-	server 127.0.1.139 127.0.1.139:80 weight 10 check inter 2494 fall 2 rise 1
-	server 127.0.1.140 127.0.1.140:80 weight 10 check inter 2783 fall 2 rise 1
-	server 127.0.1.141 127.0.1.141:80 weight 10 check inter 8276 fall 2 rise 1
-	server 127.0.1.142 127.0.1.142:80 weight 10 check inter 7818 fall 2 rise 1
-	server 127.0.1.143 127.0.1.143:80 weight 10 check inter 2298 fall 2 rise 1
-	server 127.0.1.144 127.0.1.144:80 weight 10 check inter 1782 fall 2 rise 1
-	server 127.0.1.145 127.0.1.145:80 weight 10 check inter 2395 fall 2 rise 1
-	server 127.0.1.146 127.0.1.146:80 weight 10 check inter 7548 fall 2 rise 1
-	server 127.0.1.147 127.0.1.147:80 weight 10 check inter 1980 fall 2 rise 1
-	server 127.0.1.148 127.0.1.148:80 weight 10 check inter 3966 fall 2 rise 1
-	server 127.0.1.149 127.0.1.149:80 weight 10 check inter 1238 fall 2 rise 1
-	server 127.0.1.150 127.0.1.150:80 weight 10 check inter 5619 fall 2 rise 1
-	server 127.0.1.151 127.0.1.151:80 weight 10 check inter 8600 fall 2 rise 1
-	server 127.0.1.152 127.0.1.152:80 weight 10 check inter 4780 fall 2 rise 1
-	server 127.0.1.153 127.0.1.153:80 weight 10 check inter 6137 fall 2 rise 1
-	server 127.0.1.154 127.0.1.154:80 weight 10 check inter 8828 fall 2 rise 1
-	server 127.0.1.155 127.0.1.155:80 weight 10 check inter 3682 fall 2 rise 1
-	server 127.0.1.156 127.0.1.156:80 weight 10 check inter 2442 fall 2 rise 1
-	server 127.0.1.157 127.0.1.157:80 weight 10 check inter 2620 fall 2 rise 1
-	server 127.0.1.158 127.0.1.158:80 weight 10 check inter 6224 fall 2 rise 1
-	server 127.0.1.159 127.0.1.159:80 weight 10 check inter 4828 fall 2 rise 1
-	server 127.0.1.160 127.0.1.160:80 weight 10 check inter 2811 fall 2 rise 1
-	server 127.0.1.161 127.0.1.161:80 weight 10 check inter 782 fall 2 rise 1
-	server 127.0.1.162 127.0.1.162:80 weight 10 check inter 905 fall 2 rise 1
-	server 127.0.1.163 127.0.1.163:80 weight 10 check inter 895 fall 2 rise 1
-	server 127.0.1.164 127.0.1.164:80 weight 10 check inter 3999 fall 2 rise 1
-	server 127.0.1.165 127.0.1.165:80 weight 10 check inter 7109 fall 2 rise 1
-	server 127.0.1.166 127.0.1.166:80 weight 10 check inter 2833 fall 2 rise 1
-	server 127.0.1.167 127.0.1.167:80 weight 10 check inter 1274 fall 2 rise 1
-	server 127.0.1.168 127.0.1.168:80 weight 10 check inter 3179 fall 2 rise 1
-	server 127.0.1.169 127.0.1.169:80 weight 10 check inter 429 fall 2 rise 1
-	server 127.0.1.170 127.0.1.170:80 weight 10 check inter 1407 fall 2 rise 1
-	server 127.0.1.171 127.0.1.171:80 weight 10 check inter 9117 fall 2 rise 1
-	server 127.0.1.172 127.0.1.172:80 weight 10 check inter 1525 fall 2 rise 1
-	server 127.0.1.173 127.0.1.173:80 weight 10 check inter 4364 fall 2 rise 1
-	server 127.0.1.174 127.0.1.174:80 weight 10 check inter 5696 fall 2 rise 1
-	server 127.0.1.175 127.0.1.175:80 weight 10 check inter 9492 fall 2 rise 1
-	server 127.0.1.176 127.0.1.176:80 weight 10 check inter 6098 fall 2 rise 1
-	server 127.0.1.177 127.0.1.177:80 weight 10 check inter 519 fall 2 rise 1
-	server 127.0.1.178 127.0.1.178:80 weight 10 check inter 6454 fall 2 rise 1
-	server 127.0.1.179 127.0.1.179:80 weight 10 check inter 3397 fall 2 rise 1
-	server 127.0.1.180 127.0.1.180:80 weight 10 check inter 8255 fall 2 rise 1
-	server 127.0.1.181 127.0.1.181:80 weight 10 check inter 3863 fall 2 rise 1
-	server 127.0.1.182 127.0.1.182:80 weight 10 check inter 132 fall 2 rise 1
-	server 127.0.1.183 127.0.1.183:80 weight 10 check inter 8776 fall 2 rise 1
-	server 127.0.1.184 127.0.1.184:80 weight 10 check inter 5890 fall 2 rise 1
-	server 127.0.1.185 127.0.1.185:80 weight 10 check inter 4361 fall 2 rise 1
-	server 127.0.1.186 127.0.1.186:80 weight 10 check inter 3013 fall 2 rise 1
-	server 127.0.1.187 127.0.1.187:80 weight 10 check inter 8857 fall 2 rise 1
-	server 127.0.1.188 127.0.1.188:80 weight 10 check inter 767 fall 2 rise 1
-	server 127.0.1.189 127.0.1.189:80 weight 10 check inter 5880 fall 2 rise 1
-	server 127.0.1.190 127.0.1.190:80 weight 10 check inter 1520 fall 2 rise 1
-	server 127.0.1.191 127.0.1.191:80 weight 10 check inter 8766 fall 2 rise 1
-	server 127.0.1.192 127.0.1.192:80 weight 10 check inter 6393 fall 2 rise 1
-	server 127.0.1.193 127.0.1.193:80 weight 10 check inter 4715 fall 2 rise 1
-	server 127.0.1.194 127.0.1.194:80 weight 10 check inter 5452 fall 2 rise 1
-	server 127.0.1.195 127.0.1.195:80 weight 10 check inter 9849 fall 2 rise 1
-	server 127.0.1.196 127.0.1.196:80 weight 10 check inter 2958 fall 2 rise 1
-	server 127.0.1.197 127.0.1.197:80 weight 10 check inter 5374 fall 2 rise 1
-	server 127.0.1.198 127.0.1.198:80 weight 10 check inter 7266 fall 2 rise 1
-	server 127.0.1.199 127.0.1.199:80 weight 10 check inter 7117 fall 2 rise 1
-	server 127.0.1.200 127.0.1.200:80 weight 10 check inter 8433 fall 2 rise 1
-	server 127.0.1.201 127.0.1.201:80 weight 10 check inter 1057 fall 2 rise 1
-	server 127.0.1.202 127.0.1.202:80 weight 10 check inter 775 fall 2 rise 1
-	server 127.0.1.203 127.0.1.203:80 weight 10 check inter 8448 fall 2 rise 1
-	server 127.0.1.204 127.0.1.204:80 weight 10 check inter 5318 fall 2 rise 1
-	server 127.0.1.205 127.0.1.205:80 weight 10 check inter 7539 fall 2 rise 1
-	server 127.0.1.206 127.0.1.206:80 weight 10 check inter 2535 fall 2 rise 1
-	server 127.0.1.207 127.0.1.207:80 weight 10 check inter 4533 fall 2 rise 1
-	server 127.0.1.208 127.0.1.208:80 weight 10 check inter 2576 fall 2 rise 1
-	server 127.0.1.209 127.0.1.209:80 weight 10 check inter 6812 fall 2 rise 1
-	server 127.0.1.210 127.0.1.210:80 weight 10 check inter 2529 fall 2 rise 1
-	server 127.0.1.211 127.0.1.211:80 weight 10 check inter 326 fall 2 rise 1
-	server 127.0.1.212 127.0.1.212:80 weight 10 check inter 90 fall 2 rise 1
-	server 127.0.1.213 127.0.1.213:80 weight 10 check inter 7965 fall 2 rise 1
-	server 127.0.1.214 127.0.1.214:80 weight 10 check inter 2948 fall 2 rise 1
-	server 127.0.1.215 127.0.1.215:80 weight 10 check inter 9780 fall 2 rise 1
-	server 127.0.1.216 127.0.1.216:80 weight 10 check inter 8408 fall 2 rise 1
-	server 127.0.1.217 127.0.1.217:80 weight 10 check inter 121 fall 2 rise 1
-	server 127.0.1.218 127.0.1.218:80 weight 10 check inter 9532 fall 2 rise 1
-	server 127.0.1.219 127.0.1.219:80 weight 10 check inter 2910 fall 2 rise 1
-	server 127.0.1.220 127.0.1.220:80 weight 10 check inter 6811 fall 2 rise 1
-	server 127.0.1.221 127.0.1.221:80 weight 10 check inter 8303 fall 2 rise 1
-	server 127.0.1.222 127.0.1.222:80 weight 10 check inter 4268 fall 2 rise 1
-	server 127.0.1.223 127.0.1.223:80 weight 10 check inter 4835 fall 2 rise 1
-	server 127.0.1.224 127.0.1.224:80 weight 10 check inter 1862 fall 2 rise 1
-	server 127.0.1.225 127.0.1.225:80 weight 10 check inter 7342 fall 2 rise 1
-	server 127.0.1.226 127.0.1.226:80 weight 10 check inter 7131 fall 2 rise 1
-	server 127.0.1.227 127.0.1.227:80 weight 10 check inter 6904 fall 2 rise 1
-	server 127.0.1.228 127.0.1.228:80 weight 10 check inter 5443 fall 2 rise 1
-	server 127.0.1.229 127.0.1.229:80 weight 10 check inter 2696 fall 2 rise 1
-	server 127.0.1.230 127.0.1.230:80 weight 10 check inter 1375 fall 2 rise 1
-	server 127.0.1.231 127.0.1.231:80 weight 10 check inter 6168 fall 2 rise 1
-	server 127.0.1.232 127.0.1.232:80 weight 10 check inter 8004 fall 2 rise 1
-	server 127.0.1.233 127.0.1.233:80 weight 10 check inter 546 fall 2 rise 1
-	server 127.0.1.234 127.0.1.234:80 weight 10 check inter 506 fall 2 rise 1
-	server 127.0.1.235 127.0.1.235:80 weight 10 check inter 9022 fall 2 rise 1
-	server 127.0.1.236 127.0.1.236:80 weight 10 check inter 331 fall 2 rise 1
-	server 127.0.1.237 127.0.1.237:80 weight 10 check inter 2481 fall 2 rise 1
-	server 127.0.1.238 127.0.1.238:80 weight 10 check inter 8679 fall 2 rise 1
-	server 127.0.1.239 127.0.1.239:80 weight 10 check inter 1699 fall 2 rise 1
-	server 127.0.1.240 127.0.1.240:80 weight 10 check inter 5705 fall 2 rise 1
-	server 127.0.1.241 127.0.1.241:80 weight 10 check inter 675 fall 2 rise 1
-	server 127.0.1.242 127.0.1.242:80 weight 10 check inter 4963 fall 2 rise 1
-	server 127.0.1.243 127.0.1.243:80 weight 10 check inter 4249 fall 2 rise 1
-	server 127.0.1.244 127.0.1.244:80 weight 10 check inter 2375 fall 2 rise 1
-	server 127.0.1.245 127.0.1.245:80 weight 10 check inter 3808 fall 2 rise 1
-	server 127.0.1.246 127.0.1.246:80 weight 10 check inter 1979 fall 2 rise 1
-	server 127.0.1.247 127.0.1.247:80 weight 10 check inter 6659 fall 2 rise 1
-	server 127.0.1.248 127.0.1.248:80 weight 10 check inter 534 fall 2 rise 1
-	server 127.0.1.249 127.0.1.249:80 weight 10 check inter 5152 fall 2 rise 1
-	server 127.0.1.250 127.0.1.250:80 weight 10 check inter 5513 fall 2 rise 1
-	server 127.0.2.001 127.0.2.1:80 weight 10 check inter 3147 fall 2 rise 1
-	server 127.0.2.002 127.0.2.2:80 weight 10 check inter 2022 fall 2 rise 1
-	server 127.0.2.003 127.0.2.3:80 weight 10 check inter 2009 fall 2 rise 1
-	server 127.0.2.004 127.0.2.4:80 weight 10 check inter 686 fall 2 rise 1
-	server 127.0.2.005 127.0.2.5:80 weight 10 check inter 7889 fall 2 rise 1
-	server 127.0.2.006 127.0.2.6:80 weight 10 check inter 7401 fall 2 rise 1
-	server 127.0.2.007 127.0.2.7:80 weight 10 check inter 2847 fall 2 rise 1
-	server 127.0.2.008 127.0.2.8:80 weight 10 check inter 2814 fall 2 rise 1
-	server 127.0.2.009 127.0.2.9:80 weight 10 check inter 9764 fall 2 rise 1
-	server 127.0.2.010 127.0.2.10:80 weight 10 check inter 1557 fall 2 rise 1
-	server 127.0.2.011 127.0.2.11:80 weight 10 check inter 7626 fall 2 rise 1
-	server 127.0.2.012 127.0.2.12:80 weight 10 check inter 7023 fall 2 rise 1
-	server 127.0.2.013 127.0.2.13:80 weight 10 check inter 7666 fall 2 rise 1
-	server 127.0.2.014 127.0.2.14:80 weight 10 check inter 4636 fall 2 rise 1
-	server 127.0.2.015 127.0.2.15:80 weight 10 check inter 3494 fall 2 rise 1
-	server 127.0.2.016 127.0.2.16:80 weight 10 check inter 1791 fall 2 rise 1
-	server 127.0.2.017 127.0.2.17:80 weight 10 check inter 2447 fall 2 rise 1
-	server 127.0.2.018 127.0.2.18:80 weight 10 check inter 8828 fall 2 rise 1
-	server 127.0.2.019 127.0.2.19:80 weight 10 check inter 1517 fall 2 rise 1
-	server 127.0.2.020 127.0.2.20:80 weight 10 check inter 6216 fall 2 rise 1
-	server 127.0.2.021 127.0.2.21:80 weight 10 check inter 9192 fall 2 rise 1
-	server 127.0.2.022 127.0.2.22:80 weight 10 check inter 1828 fall 2 rise 1
-	server 127.0.2.023 127.0.2.23:80 weight 10 check inter 2772 fall 2 rise 1
-	server 127.0.2.024 127.0.2.24:80 weight 10 check inter 5541 fall 2 rise 1
-	server 127.0.2.025 127.0.2.25:80 weight 10 check inter 8020 fall 2 rise 1
-	server 127.0.2.026 127.0.2.26:80 weight 10 check inter 6877 fall 2 rise 1
-	server 127.0.2.027 127.0.2.27:80 weight 10 check inter 1000 fall 2 rise 1
-	server 127.0.2.028 127.0.2.28:80 weight 10 check inter 5809 fall 2 rise 1
-	server 127.0.2.029 127.0.2.29:80 weight 10 check inter 1152 fall 2 rise 1
-	server 127.0.2.030 127.0.2.30:80 weight 10 check inter 8484 fall 2 rise 1
-	server 127.0.2.031 127.0.2.31:80 weight 10 check inter 5223 fall 2 rise 1
-	server 127.0.2.032 127.0.2.32:80 weight 10 check inter 3444 fall 2 rise 1
-	server 127.0.2.033 127.0.2.33:80 weight 10 check inter 2710 fall 2 rise 1
-	server 127.0.2.034 127.0.2.34:80 weight 10 check inter 7786 fall 2 rise 1
-	server 127.0.2.035 127.0.2.35:80 weight 10 check inter 2302 fall 2 rise 1
-	server 127.0.2.036 127.0.2.36:80 weight 10 check inter 8732 fall 2 rise 1
-	server 127.0.2.037 127.0.2.37:80 weight 10 check inter 9474 fall 2 rise 1
-	server 127.0.2.038 127.0.2.38:80 weight 10 check inter 4746 fall 2 rise 1
-	server 127.0.2.039 127.0.2.39:80 weight 10 check inter 1142 fall 2 rise 1
-	server 127.0.2.040 127.0.2.40:80 weight 10 check inter 1965 fall 2 rise 1
-	server 127.0.2.041 127.0.2.41:80 weight 10 check inter 3669 fall 2 rise 1
-	server 127.0.2.042 127.0.2.42:80 weight 10 check inter 8573 fall 2 rise 1
-	server 127.0.2.043 127.0.2.43:80 weight 10 check inter 1901 fall 2 rise 1
-	server 127.0.2.044 127.0.2.44:80 weight 10 check inter 5049 fall 2 rise 1
-	server 127.0.2.045 127.0.2.45:80 weight 10 check inter 5846 fall 2 rise 1
-	server 127.0.2.046 127.0.2.46:80 weight 10 check inter 9087 fall 2 rise 1
-	server 127.0.2.047 127.0.2.47:80 weight 10 check inter 1301 fall 2 rise 1
-	server 127.0.2.048 127.0.2.48:80 weight 10 check inter 2878 fall 2 rise 1
-	server 127.0.2.049 127.0.2.49:80 weight 10 check inter 636 fall 2 rise 1
-	server 127.0.2.050 127.0.2.50:80 weight 10 check inter 8543 fall 2 rise 1
-	server 127.0.2.051 127.0.2.51:80 weight 10 check inter 7392 fall 2 rise 1
-	server 127.0.2.052 127.0.2.52:80 weight 10 check inter 6210 fall 2 rise 1
-	server 127.0.2.053 127.0.2.53:80 weight 10 check inter 4667 fall 2 rise 1
-	server 127.0.2.054 127.0.2.54:80 weight 10 check inter 5306 fall 2 rise 1
-	server 127.0.2.055 127.0.2.55:80 weight 10 check inter 5030 fall 2 rise 1
-	server 127.0.2.056 127.0.2.56:80 weight 10 check inter 9711 fall 2 rise 1
-	server 127.0.2.057 127.0.2.57:80 weight 10 check inter 4801 fall 2 rise 1
-	server 127.0.2.058 127.0.2.58:80 weight 10 check inter 3605 fall 2 rise 1
-	server 127.0.2.059 127.0.2.59:80 weight 10 check inter 5100 fall 2 rise 1
-	server 127.0.2.060 127.0.2.60:80 weight 10 check inter 7534 fall 2 rise 1
-	server 127.0.2.061 127.0.2.61:80 weight 10 check inter 8912 fall 2 rise 1
-	server 127.0.2.062 127.0.2.62:80 weight 10 check inter 4795 fall 2 rise 1
-	server 127.0.2.063 127.0.2.63:80 weight 10 check inter 7365 fall 2 rise 1
-	server 127.0.2.064 127.0.2.64:80 weight 10 check inter 8404 fall 2 rise 1
-	server 127.0.2.065 127.0.2.65:80 weight 10 check inter 7817 fall 2 rise 1
-	server 127.0.2.066 127.0.2.66:80 weight 10 check inter 2652 fall 2 rise 1
-	server 127.0.2.067 127.0.2.67:80 weight 10 check inter 1061 fall 2 rise 1
-	server 127.0.2.068 127.0.2.68:80 weight 10 check inter 7040 fall 2 rise 1
-	server 127.0.2.069 127.0.2.69:80 weight 10 check inter 3357 fall 2 rise 1
-	server 127.0.2.070 127.0.2.70:80 weight 10 check inter 882 fall 2 rise 1
-	server 127.0.2.071 127.0.2.71:80 weight 10 check inter 634 fall 2 rise 1
-	server 127.0.2.072 127.0.2.72:80 weight 10 check inter 2176 fall 2 rise 1
-	server 127.0.2.073 127.0.2.73:80 weight 10 check inter 6932 fall 2 rise 1
-	server 127.0.2.074 127.0.2.74:80 weight 10 check inter 5394 fall 2 rise 1
-	server 127.0.2.075 127.0.2.75:80 weight 10 check inter 6601 fall 2 rise 1
-	server 127.0.2.076 127.0.2.76:80 weight 10 check inter 8038 fall 2 rise 1
-	server 127.0.2.077 127.0.2.77:80 weight 10 check inter 6089 fall 2 rise 1
-	server 127.0.2.078 127.0.2.78:80 weight 10 check inter 2904 fall 2 rise 1
-	server 127.0.2.079 127.0.2.79:80 weight 10 check inter 6633 fall 2 rise 1
-	server 127.0.2.080 127.0.2.80:80 weight 10 check inter 5679 fall 2 rise 1
-	server 127.0.2.081 127.0.2.81:80 weight 10 check inter 1339 fall 2 rise 1
-	server 127.0.2.082 127.0.2.82:80 weight 10 check inter 6079 fall 2 rise 1
-	server 127.0.2.083 127.0.2.83:80 weight 10 check inter 6657 fall 2 rise 1
-	server 127.0.2.084 127.0.2.84:80 weight 10 check inter 5933 fall 2 rise 1
-	server 127.0.2.085 127.0.2.85:80 weight 10 check inter 8004 fall 2 rise 1
-	server 127.0.2.086 127.0.2.86:80 weight 10 check inter 4050 fall 2 rise 1
-	server 127.0.2.087 127.0.2.87:80 weight 10 check inter 7875 fall 2 rise 1
-	server 127.0.2.088 127.0.2.88:80 weight 10 check inter 4441 fall 2 rise 1
-	server 127.0.2.089 127.0.2.89:80 weight 10 check inter 823 fall 2 rise 1
-	server 127.0.2.090 127.0.2.90:80 weight 10 check inter 8661 fall 2 rise 1
-	server 127.0.2.091 127.0.2.91:80 weight 10 check inter 1013 fall 2 rise 1
-	server 127.0.2.092 127.0.2.92:80 weight 10 check inter 6458 fall 2 rise 1
-	server 127.0.2.093 127.0.2.93:80 weight 10 check inter 7820 fall 2 rise 1
-	server 127.0.2.094 127.0.2.94:80 weight 10 check inter 5555 fall 2 rise 1
-	server 127.0.2.095 127.0.2.95:80 weight 10 check inter 1571 fall 2 rise 1
-	server 127.0.2.096 127.0.2.96:80 weight 10 check inter 835 fall 2 rise 1
-	server 127.0.2.097 127.0.2.97:80 weight 10 check inter 4988 fall 2 rise 1
-	server 127.0.2.098 127.0.2.98:80 weight 10 check inter 6806 fall 2 rise 1
-	server 127.0.2.099 127.0.2.99:80 weight 10 check inter 7815 fall 2 rise 1
-	server 127.0.2.100 127.0.2.100:80 weight 10 check inter 4288 fall 2 rise 1
-	server 127.0.2.101 127.0.2.101:80 weight 10 check inter 9995 fall 2 rise 1
-	server 127.0.2.102 127.0.2.102:80 weight 10 check inter 1881 fall 2 rise 1
-	server 127.0.2.103 127.0.2.103:80 weight 10 check inter 6532 fall 2 rise 1
-	server 127.0.2.104 127.0.2.104:80 weight 10 check inter 3631 fall 2 rise 1
-	server 127.0.2.105 127.0.2.105:80 weight 10 check inter 3703 fall 2 rise 1
-	server 127.0.2.106 127.0.2.106:80 weight 10 check inter 861 fall 2 rise 1
-	server 127.0.2.107 127.0.2.107:80 weight 10 check inter 7685 fall 2 rise 1
-	server 127.0.2.108 127.0.2.108:80 weight 10 check inter 2015 fall 2 rise 1
-	server 127.0.2.109 127.0.2.109:80 weight 10 check inter 469 fall 2 rise 1
-	server 127.0.2.110 127.0.2.110:80 weight 10 check inter 8412 fall 2 rise 1
-	server 127.0.2.111 127.0.2.111:80 weight 10 check inter 5112 fall 2 rise 1
-	server 127.0.2.112 127.0.2.112:80 weight 10 check inter 1929 fall 2 rise 1
-	server 127.0.2.113 127.0.2.113:80 weight 10 check inter 2614 fall 2 rise 1
-	server 127.0.2.114 127.0.2.114:80 weight 10 check inter 738 fall 2 rise 1
-	server 127.0.2.115 127.0.2.115:80 weight 10 check inter 9049 fall 2 rise 1
-	server 127.0.2.116 127.0.2.116:80 weight 10 check inter 4401 fall 2 rise 1
-	server 127.0.2.117 127.0.2.117:80 weight 10 check inter 7468 fall 2 rise 1
-	server 127.0.2.118 127.0.2.118:80 weight 10 check inter 3989 fall 2 rise 1
-	server 127.0.2.119 127.0.2.119:80 weight 10 check inter 2992 fall 2 rise 1
-	server 127.0.2.120 127.0.2.120:80 weight 10 check inter 362 fall 2 rise 1
-	server 127.0.2.121 127.0.2.121:80 weight 10 check inter 2623 fall 2 rise 1
-	server 127.0.2.122 127.0.2.122:80 weight 10 check inter 856 fall 2 rise 1
-	server 127.0.2.123 127.0.2.123:80 weight 10 check inter 2987 fall 2 rise 1
-	server 127.0.2.124 127.0.2.124:80 weight 10 check inter 860 fall 2 rise 1
-	server 127.0.2.125 127.0.2.125:80 weight 10 check inter 2445 fall 2 rise 1
-	server 127.0.2.126 127.0.2.126:80 weight 10 check inter 2099 fall 2 rise 1
-	server 127.0.2.127 127.0.2.127:80 weight 10 check inter 169 fall 2 rise 1
-	server 127.0.2.128 127.0.2.128:80 weight 10 check inter 9304 fall 2 rise 1
-	server 127.0.2.129 127.0.2.129:80 weight 10 check inter 3813 fall 2 rise 1
-	server 127.0.2.130 127.0.2.130:80 weight 10 check inter 3136 fall 2 rise 1
-	server 127.0.2.131 127.0.2.131:80 weight 10 check inter 9739 fall 2 rise 1
-	server 127.0.2.132 127.0.2.132:80 weight 10 check inter 9829 fall 2 rise 1
-	server 127.0.2.133 127.0.2.133:80 weight 10 check inter 3762 fall 2 rise 1
-	server 127.0.2.134 127.0.2.134:80 weight 10 check inter 9061 fall 2 rise 1
-	server 127.0.2.135 127.0.2.135:80 weight 10 check inter 9771 fall 2 rise 1
-	server 127.0.2.136 127.0.2.136:80 weight 10 check inter 9106 fall 2 rise 1
-	server 127.0.2.137 127.0.2.137:80 weight 10 check inter 8440 fall 2 rise 1
-	server 127.0.2.138 127.0.2.138:80 weight 10 check inter 6517 fall 2 rise 1
-	server 127.0.2.139 127.0.2.139:80 weight 10 check inter 1530 fall 2 rise 1
-	server 127.0.2.140 127.0.2.140:80 weight 10 check inter 282 fall 2 rise 1
-	server 127.0.2.141 127.0.2.141:80 weight 10 check inter 8816 fall 2 rise 1
-	server 127.0.2.142 127.0.2.142:80 weight 10 check inter 4262 fall 2 rise 1
-	server 127.0.2.143 127.0.2.143:80 weight 10 check inter 1931 fall 2 rise 1
-	server 127.0.2.144 127.0.2.144:80 weight 10 check inter 1494 fall 2 rise 1
-	server 127.0.2.145 127.0.2.145:80 weight 10 check inter 2820 fall 2 rise 1
-	server 127.0.2.146 127.0.2.146:80 weight 10 check inter 6224 fall 2 rise 1
-	server 127.0.2.147 127.0.2.147:80 weight 10 check inter 9184 fall 2 rise 1
-	server 127.0.2.148 127.0.2.148:80 weight 10 check inter 9605 fall 2 rise 1
-	server 127.0.2.149 127.0.2.149:80 weight 10 check inter 6313 fall 2 rise 1
-	server 127.0.2.150 127.0.2.150:80 weight 10 check inter 4602 fall 2 rise 1
-	server 127.0.2.151 127.0.2.151:80 weight 10 check inter 568 fall 2 rise 1
-	server 127.0.2.152 127.0.2.152:80 weight 10 check inter 5164 fall 2 rise 1
-	server 127.0.2.153 127.0.2.153:80 weight 10 check inter 2575 fall 2 rise 1
-	server 127.0.2.154 127.0.2.154:80 weight 10 check inter 6164 fall 2 rise 1
-	server 127.0.2.155 127.0.2.155:80 weight 10 check inter 3989 fall 2 rise 1
-	server 127.0.2.156 127.0.2.156:80 weight 10 check inter 3534 fall 2 rise 1
-	server 127.0.2.157 127.0.2.157:80 weight 10 check inter 1274 fall 2 rise 1
-	server 127.0.2.158 127.0.2.158:80 weight 10 check inter 2083 fall 2 rise 1
-	server 127.0.2.159 127.0.2.159:80 weight 10 check inter 2911 fall 2 rise 1
-	server 127.0.2.160 127.0.2.160:80 weight 10 check inter 6666 fall 2 rise 1
-	server 127.0.2.161 127.0.2.161:80 weight 10 check inter 9725 fall 2 rise 1
-	server 127.0.2.162 127.0.2.162:80 weight 10 check inter 6161 fall 2 rise 1
-	server 127.0.2.163 127.0.2.163:80 weight 10 check inter 6123 fall 2 rise 1
-	server 127.0.2.164 127.0.2.164:80 weight 10 check inter 296 fall 2 rise 1
-	server 127.0.2.165 127.0.2.165:80 weight 10 check inter 4028 fall 2 rise 1
-	server 127.0.2.166 127.0.2.166:80 weight 10 check inter 7297 fall 2 rise 1
-	server 127.0.2.167 127.0.2.167:80 weight 10 check inter 2553 fall 2 rise 1
-	server 127.0.2.168 127.0.2.168:80 weight 10 check inter 9505 fall 2 rise 1
-	server 127.0.2.169 127.0.2.169:80 weight 10 check inter 5902 fall 2 rise 1
-	server 127.0.2.170 127.0.2.170:80 weight 10 check inter 7235 fall 2 rise 1
-	server 127.0.2.171 127.0.2.171:80 weight 10 check inter 6624 fall 2 rise 1
-	server 127.0.2.172 127.0.2.172:80 weight 10 check inter 6816 fall 2 rise 1
-	server 127.0.2.173 127.0.2.173:80 weight 10 check inter 6580 fall 2 rise 1
-	server 127.0.2.174 127.0.2.174:80 weight 10 check inter 4347 fall 2 rise 1
-	server 127.0.2.175 127.0.2.175:80 weight 10 check inter 2473 fall 2 rise 1
-	server 127.0.2.176 127.0.2.176:80 weight 10 check inter 1292 fall 2 rise 1
-	server 127.0.2.177 127.0.2.177:80 weight 10 check inter 4461 fall 2 rise 1
-	server 127.0.2.178 127.0.2.178:80 weight 10 check inter 641 fall 2 rise 1
-	server 127.0.2.179 127.0.2.179:80 weight 10 check inter 3790 fall 2 rise 1
-	server 127.0.2.180 127.0.2.180:80 weight 10 check inter 5747 fall 2 rise 1
-	server 127.0.2.181 127.0.2.181:80 weight 10 check inter 1717 fall 2 rise 1
-	server 127.0.2.182 127.0.2.182:80 weight 10 check inter 8921 fall 2 rise 1
-	server 127.0.2.183 127.0.2.183:80 weight 10 check inter 7585 fall 2 rise 1
-	server 127.0.2.184 127.0.2.184:80 weight 10 check inter 198 fall 2 rise 1
-	server 127.0.2.185 127.0.2.185:80 weight 10 check inter 6129 fall 2 rise 1
-	server 127.0.2.186 127.0.2.186:80 weight 10 check inter 2193 fall 2 rise 1
-	server 127.0.2.187 127.0.2.187:80 weight 10 check inter 3564 fall 2 rise 1
-	server 127.0.2.188 127.0.2.188:80 weight 10 check inter 5175 fall 2 rise 1
-	server 127.0.2.189 127.0.2.189:80 weight 10 check inter 555 fall 2 rise 1
-	server 127.0.2.190 127.0.2.190:80 weight 10 check inter 1180 fall 2 rise 1
-	server 127.0.2.191 127.0.2.191:80 weight 10 check inter 9116 fall 2 rise 1
-	server 127.0.2.192 127.0.2.192:80 weight 10 check inter 9443 fall 2 rise 1
-	server 127.0.2.193 127.0.2.193:80 weight 10 check inter 5693 fall 2 rise 1
-	server 127.0.2.194 127.0.2.194:80 weight 10 check inter 337 fall 2 rise 1
-	server 127.0.2.195 127.0.2.195:80 weight 10 check inter 6669 fall 2 rise 1
-	server 127.0.2.196 127.0.2.196:80 weight 10 check inter 223 fall 2 rise 1
-	server 127.0.2.197 127.0.2.197:80 weight 10 check inter 1311 fall 2 rise 1
-	server 127.0.2.198 127.0.2.198:80 weight 10 check inter 5010 fall 2 rise 1
-	server 127.0.2.199 127.0.2.199:80 weight 10 check inter 5572 fall 2 rise 1
-	server 127.0.2.200 127.0.2.200:80 weight 10 check inter 5555 fall 2 rise 1
-	server 127.0.2.201 127.0.2.201:80 weight 10 check inter 9458 fall 2 rise 1
-	server 127.0.2.202 127.0.2.202:80 weight 10 check inter 6125 fall 2 rise 1
-	server 127.0.2.203 127.0.2.203:80 weight 10 check inter 6334 fall 2 rise 1
-	server 127.0.2.204 127.0.2.204:80 weight 10 check inter 2873 fall 2 rise 1
-	server 127.0.2.205 127.0.2.205:80 weight 10 check inter 4200 fall 2 rise 1
-	server 127.0.2.206 127.0.2.206:80 weight 10 check inter 1653 fall 2 rise 1
-	server 127.0.2.207 127.0.2.207:80 weight 10 check inter 4459 fall 2 rise 1
-	server 127.0.2.208 127.0.2.208:80 weight 10 check inter 3605 fall 2 rise 1
-	server 127.0.2.209 127.0.2.209:80 weight 10 check inter 9273 fall 2 rise 1
-	server 127.0.2.210 127.0.2.210:80 weight 10 check inter 2030 fall 2 rise 1
-	server 127.0.2.211 127.0.2.211:80 weight 10 check inter 10 fall 2 rise 1
-	server 127.0.2.212 127.0.2.212:80 weight 10 check inter 1538 fall 2 rise 1
-	server 127.0.2.213 127.0.2.213:80 weight 10 check inter 5847 fall 2 rise 1
-	server 127.0.2.214 127.0.2.214:80 weight 10 check inter 7995 fall 2 rise 1
-	server 127.0.2.215 127.0.2.215:80 weight 10 check inter 1220 fall 2 rise 1
-	server 127.0.2.216 127.0.2.216:80 weight 10 check inter 1104 fall 2 rise 1
-	server 127.0.2.217 127.0.2.217:80 weight 10 check inter 9036 fall 2 rise 1
-	server 127.0.2.218 127.0.2.218:80 weight 10 check inter 3719 fall 2 rise 1
-	server 127.0.2.219 127.0.2.219:80 weight 10 check inter 6136 fall 2 rise 1
-	server 127.0.2.220 127.0.2.220:80 weight 10 check inter 9294 fall 2 rise 1
-	server 127.0.2.221 127.0.2.221:80 weight 10 check inter 4920 fall 2 rise 1
-	server 127.0.2.222 127.0.2.222:80 weight 10 check inter 4149 fall 2 rise 1
-	server 127.0.2.223 127.0.2.223:80 weight 10 check inter 3833 fall 2 rise 1
-	server 127.0.2.224 127.0.2.224:80 weight 10 check inter 3977 fall 2 rise 1
-	server 127.0.2.225 127.0.2.225:80 weight 10 check inter 524 fall 2 rise 1
-	server 127.0.2.226 127.0.2.226:80 weight 10 check inter 7289 fall 2 rise 1
-	server 127.0.2.227 127.0.2.227:80 weight 10 check inter 425 fall 2 rise 1
-	server 127.0.2.228 127.0.2.228:80 weight 10 check inter 4195 fall 2 rise 1
-	server 127.0.2.229 127.0.2.229:80 weight 10 check inter 5589 fall 2 rise 1
-	server 127.0.2.230 127.0.2.230:80 weight 10 check inter 8642 fall 2 rise 1
-	server 127.0.2.231 127.0.2.231:80 weight 10 check inter 788 fall 2 rise 1
-	server 127.0.2.232 127.0.2.232:80 weight 10 check inter 6114 fall 2 rise 1
-	server 127.0.2.233 127.0.2.233:80 weight 10 check inter 2778 fall 2 rise 1
-	server 127.0.2.234 127.0.2.234:80 weight 10 check inter 5166 fall 2 rise 1
-	server 127.0.2.235 127.0.2.235:80 weight 10 check inter 8909 fall 2 rise 1
-	server 127.0.2.236 127.0.2.236:80 weight 10 check inter 381 fall 2 rise 1
-	server 127.0.2.237 127.0.2.237:80 weight 10 check inter 8805 fall 2 rise 1
-	server 127.0.2.238 127.0.2.238:80 weight 10 check inter 8876 fall 2 rise 1
-	server 127.0.2.239 127.0.2.239:80 weight 10 check inter 3033 fall 2 rise 1
-	server 127.0.2.240 127.0.2.240:80 weight 10 check inter 4375 fall 2 rise 1
-	server 127.0.2.241 127.0.2.241:80 weight 10 check inter 7601 fall 2 rise 1
-	server 127.0.2.242 127.0.2.242:80 weight 10 check inter 2831 fall 2 rise 1
-	server 127.0.2.243 127.0.2.243:80 weight 10 check inter 4333 fall 2 rise 1
-	server 127.0.2.244 127.0.2.244:80 weight 10 check inter 9129 fall 2 rise 1
-	server 127.0.2.245 127.0.2.245:80 weight 10 check inter 9255 fall 2 rise 1
-	server 127.0.2.246 127.0.2.246:80 weight 10 check inter 6423 fall 2 rise 1
-	server 127.0.2.247 127.0.2.247:80 weight 10 check inter 5448 fall 2 rise 1
-	server 127.0.2.248 127.0.2.248:80 weight 10 check inter 8881 fall 2 rise 1
-	server 127.0.2.249 127.0.2.249:80 weight 10 check inter 120 fall 2 rise 1
-	server 127.0.2.250 127.0.2.250:80 weight 10 check inter 992 fall 2 rise 1
-	server 127.0.3.001 127.0.3.1:80 weight 10 check inter 6544 fall 2 rise 1
-	server 127.0.3.002 127.0.3.2:80 weight 10 check inter 4541 fall 2 rise 1
-	server 127.0.3.003 127.0.3.3:80 weight 10 check inter 8457 fall 2 rise 1
-	server 127.0.3.004 127.0.3.4:80 weight 10 check inter 5463 fall 2 rise 1
-	server 127.0.3.005 127.0.3.5:80 weight 10 check inter 3374 fall 2 rise 1
-	server 127.0.3.006 127.0.3.6:80 weight 10 check inter 9206 fall 2 rise 1
-	server 127.0.3.007 127.0.3.7:80 weight 10 check inter 1634 fall 2 rise 1
-	server 127.0.3.008 127.0.3.8:80 weight 10 check inter 272 fall 2 rise 1
-	server 127.0.3.009 127.0.3.9:80 weight 10 check inter 4089 fall 2 rise 1
-	server 127.0.3.010 127.0.3.10:80 weight 10 check inter 236 fall 2 rise 1
-	server 127.0.3.011 127.0.3.11:80 weight 10 check inter 6294 fall 2 rise 1
-	server 127.0.3.012 127.0.3.12:80 weight 10 check inter 953 fall 2 rise 1
-	server 127.0.3.013 127.0.3.13:80 weight 10 check inter 4195 fall 2 rise 1
-	server 127.0.3.014 127.0.3.14:80 weight 10 check inter 7093 fall 2 rise 1
-	server 127.0.3.015 127.0.3.15:80 weight 10 check inter 2608 fall 2 rise 1
-	server 127.0.3.016 127.0.3.16:80 weight 10 check inter 9036 fall 2 rise 1
-	server 127.0.3.017 127.0.3.17:80 weight 10 check inter 245 fall 2 rise 1
-	server 127.0.3.018 127.0.3.18:80 weight 10 check inter 5780 fall 2 rise 1
-	server 127.0.3.019 127.0.3.19:80 weight 10 check inter 4209 fall 2 rise 1
-	server 127.0.3.020 127.0.3.20:80 weight 10 check inter 3335 fall 2 rise 1
-	server 127.0.3.021 127.0.3.21:80 weight 10 check inter 2907 fall 2 rise 1
-	server 127.0.3.022 127.0.3.22:80 weight 10 check inter 1067 fall 2 rise 1
-	server 127.0.3.023 127.0.3.23:80 weight 10 check inter 5627 fall 2 rise 1
-	server 127.0.3.024 127.0.3.24:80 weight 10 check inter 2651 fall 2 rise 1
-	server 127.0.3.025 127.0.3.25:80 weight 10 check inter 3663 fall 2 rise 1
-	server 127.0.3.026 127.0.3.26:80 weight 10 check inter 2418 fall 2 rise 1
-	server 127.0.3.027 127.0.3.27:80 weight 10 check inter 4717 fall 2 rise 1
-	server 127.0.3.028 127.0.3.28:80 weight 10 check inter 9590 fall 2 rise 1
-	server 127.0.3.029 127.0.3.29:80 weight 10 check inter 2742 fall 2 rise 1
-	server 127.0.3.030 127.0.3.30:80 weight 10 check inter 5427 fall 2 rise 1
-	server 127.0.3.031 127.0.3.31:80 weight 10 check inter 4045 fall 2 rise 1
-	server 127.0.3.032 127.0.3.32:80 weight 10 check inter 7585 fall 2 rise 1
-	server 127.0.3.033 127.0.3.33:80 weight 10 check inter 8973 fall 2 rise 1
-	server 127.0.3.034 127.0.3.34:80 weight 10 check inter 9610 fall 2 rise 1
-	server 127.0.3.035 127.0.3.35:80 weight 10 check inter 4711 fall 2 rise 1
-	server 127.0.3.036 127.0.3.36:80 weight 10 check inter 1449 fall 2 rise 1
-	server 127.0.3.037 127.0.3.37:80 weight 10 check inter 5314 fall 2 rise 1
-	server 127.0.3.038 127.0.3.38:80 weight 10 check inter 9424 fall 2 rise 1
-	server 127.0.3.039 127.0.3.39:80 weight 10 check inter 8439 fall 2 rise 1
-	server 127.0.3.040 127.0.3.40:80 weight 10 check inter 2479 fall 2 rise 1
-	server 127.0.3.041 127.0.3.41:80 weight 10 check inter 2003 fall 2 rise 1
-	server 127.0.3.042 127.0.3.42:80 weight 10 check inter 8114 fall 2 rise 1
-	server 127.0.3.043 127.0.3.43:80 weight 10 check inter 2312 fall 2 rise 1
-	server 127.0.3.044 127.0.3.44:80 weight 10 check inter 9950 fall 2 rise 1
-	server 127.0.3.045 127.0.3.45:80 weight 10 check inter 7511 fall 2 rise 1
-	server 127.0.3.046 127.0.3.46:80 weight 10 check inter 5299 fall 2 rise 1
-	server 127.0.3.047 127.0.3.47:80 weight 10 check inter 3226 fall 2 rise 1
-	server 127.0.3.048 127.0.3.48:80 weight 10 check inter 4047 fall 2 rise 1
-	server 127.0.3.049 127.0.3.49:80 weight 10 check inter 8349 fall 2 rise 1
-	server 127.0.3.050 127.0.3.50:80 weight 10 check inter 4486 fall 2 rise 1
-	server 127.0.3.051 127.0.3.51:80 weight 10 check inter 918 fall 2 rise 1
-	server 127.0.3.052 127.0.3.52:80 weight 10 check inter 7598 fall 2 rise 1
-	server 127.0.3.053 127.0.3.53:80 weight 10 check inter 7288 fall 2 rise 1
-	server 127.0.3.054 127.0.3.54:80 weight 10 check inter 9274 fall 2 rise 1
-	server 127.0.3.055 127.0.3.55:80 weight 10 check inter 7073 fall 2 rise 1
-	server 127.0.3.056 127.0.3.56:80 weight 10 check inter 8266 fall 2 rise 1
-	server 127.0.3.057 127.0.3.57:80 weight 10 check inter 7015 fall 2 rise 1
-	server 127.0.3.058 127.0.3.58:80 weight 10 check inter 4275 fall 2 rise 1
-	server 127.0.3.059 127.0.3.59:80 weight 10 check inter 4465 fall 2 rise 1
-	server 127.0.3.060 127.0.3.60:80 weight 10 check inter 6431 fall 2 rise 1
-	server 127.0.3.061 127.0.3.61:80 weight 10 check inter 2374 fall 2 rise 1
-	server 127.0.3.062 127.0.3.62:80 weight 10 check inter 2460 fall 2 rise 1
-	server 127.0.3.063 127.0.3.63:80 weight 10 check inter 5779 fall 2 rise 1
-	server 127.0.3.064 127.0.3.64:80 weight 10 check inter 5316 fall 2 rise 1
-	server 127.0.3.065 127.0.3.65:80 weight 10 check inter 8023 fall 2 rise 1
-	server 127.0.3.066 127.0.3.66:80 weight 10 check inter 9407 fall 2 rise 1
-	server 127.0.3.067 127.0.3.67:80 weight 10 check inter 3913 fall 2 rise 1
-	server 127.0.3.068 127.0.3.68:80 weight 10 check inter 3684 fall 2 rise 1
-	server 127.0.3.069 127.0.3.69:80 weight 10 check inter 5726 fall 2 rise 1
-	server 127.0.3.070 127.0.3.70:80 weight 10 check inter 4288 fall 2 rise 1
-	server 127.0.3.071 127.0.3.71:80 weight 10 check inter 8964 fall 2 rise 1
-	server 127.0.3.072 127.0.3.72:80 weight 10 check inter 4269 fall 2 rise 1
-	server 127.0.3.073 127.0.3.73:80 weight 10 check inter 623 fall 2 rise 1
-	server 127.0.3.074 127.0.3.74:80 weight 10 check inter 1037 fall 2 rise 1
-	server 127.0.3.075 127.0.3.75:80 weight 10 check inter 3685 fall 2 rise 1
-	server 127.0.3.076 127.0.3.76:80 weight 10 check inter 2729 fall 2 rise 1
-	server 127.0.3.077 127.0.3.77:80 weight 10 check inter 3720 fall 2 rise 1
-	server 127.0.3.078 127.0.3.78:80 weight 10 check inter 134 fall 2 rise 1
-	server 127.0.3.079 127.0.3.79:80 weight 10 check inter 290 fall 2 rise 1
-	server 127.0.3.080 127.0.3.80:80 weight 10 check inter 6448 fall 2 rise 1
-	server 127.0.3.081 127.0.3.81:80 weight 10 check inter 8878 fall 2 rise 1
-	server 127.0.3.082 127.0.3.82:80 weight 10 check inter 8123 fall 2 rise 1
-	server 127.0.3.083 127.0.3.83:80 weight 10 check inter 1659 fall 2 rise 1
-	server 127.0.3.084 127.0.3.84:80 weight 10 check inter 5018 fall 2 rise 1
-	server 127.0.3.085 127.0.3.85:80 weight 10 check inter 7881 fall 2 rise 1
-	server 127.0.3.086 127.0.3.86:80 weight 10 check inter 5482 fall 2 rise 1
-	server 127.0.3.087 127.0.3.87:80 weight 10 check inter 1498 fall 2 rise 1
-	server 127.0.3.088 127.0.3.88:80 weight 10 check inter 853 fall 2 rise 1
-	server 127.0.3.089 127.0.3.89:80 weight 10 check inter 8286 fall 2 rise 1
-	server 127.0.3.090 127.0.3.90:80 weight 10 check inter 9317 fall 2 rise 1
-	server 127.0.3.091 127.0.3.91:80 weight 10 check inter 4652 fall 2 rise 1
-	server 127.0.3.092 127.0.3.92:80 weight 10 check inter 3899 fall 2 rise 1
-	server 127.0.3.093 127.0.3.93:80 weight 10 check inter 1040 fall 2 rise 1
-	server 127.0.3.094 127.0.3.94:80 weight 10 check inter 1526 fall 2 rise 1
-	server 127.0.3.095 127.0.3.95:80 weight 10 check inter 595 fall 2 rise 1
-	server 127.0.3.096 127.0.3.96:80 weight 10 check inter 2096 fall 2 rise 1
-	server 127.0.3.097 127.0.3.97:80 weight 10 check inter 406 fall 2 rise 1
-	server 127.0.3.098 127.0.3.98:80 weight 10 check inter 2274 fall 2 rise 1
-	server 127.0.3.099 127.0.3.99:80 weight 10 check inter 8519 fall 2 rise 1
-	server 127.0.3.100 127.0.3.100:80 weight 10 check inter 63 fall 2 rise 1
-	server 127.0.3.101 127.0.3.101:80 weight 10 check inter 4714 fall 2 rise 1
-	server 127.0.3.102 127.0.3.102:80 weight 10 check inter 8814 fall 2 rise 1
-	server 127.0.3.103 127.0.3.103:80 weight 10 check inter 1536 fall 2 rise 1
-	server 127.0.3.104 127.0.3.104:80 weight 10 check inter 3170 fall 2 rise 1
-	server 127.0.3.105 127.0.3.105:80 weight 10 check inter 1287 fall 2 rise 1
-	server 127.0.3.106 127.0.3.106:80 weight 10 check inter 9493 fall 2 rise 1
-	server 127.0.3.107 127.0.3.107:80 weight 10 check inter 5443 fall 2 rise 1
-	server 127.0.3.108 127.0.3.108:80 weight 10 check inter 8867 fall 2 rise 1
-	server 127.0.3.109 127.0.3.109:80 weight 10 check inter 7072 fall 2 rise 1
-	server 127.0.3.110 127.0.3.110:80 weight 10 check inter 6356 fall 2 rise 1
-	server 127.0.3.111 127.0.3.111:80 weight 10 check inter 9760 fall 2 rise 1
-	server 127.0.3.112 127.0.3.112:80 weight 10 check inter 6886 fall 2 rise 1
-	server 127.0.3.113 127.0.3.113:80 weight 10 check inter 2368 fall 2 rise 1
-	server 127.0.3.114 127.0.3.114:80 weight 10 check inter 7291 fall 2 rise 1
-	server 127.0.3.115 127.0.3.115:80 weight 10 check inter 3080 fall 2 rise 1
-	server 127.0.3.116 127.0.3.116:80 weight 10 check inter 2498 fall 2 rise 1
-	server 127.0.3.117 127.0.3.117:80 weight 10 check inter 4885 fall 2 rise 1
-	server 127.0.3.118 127.0.3.118:80 weight 10 check inter 468 fall 2 rise 1
-	server 127.0.3.119 127.0.3.119:80 weight 10 check inter 8767 fall 2 rise 1
-	server 127.0.3.120 127.0.3.120:80 weight 10 check inter 1523 fall 2 rise 1
-	server 127.0.3.121 127.0.3.121:80 weight 10 check inter 9020 fall 2 rise 1
-	server 127.0.3.122 127.0.3.122:80 weight 10 check inter 2833 fall 2 rise 1
-	server 127.0.3.123 127.0.3.123:80 weight 10 check inter 885 fall 2 rise 1
-	server 127.0.3.124 127.0.3.124:80 weight 10 check inter 2497 fall 2 rise 1
-	server 127.0.3.125 127.0.3.125:80 weight 10 check inter 5003 fall 2 rise 1
-	server 127.0.3.126 127.0.3.126:80 weight 10 check inter 5063 fall 2 rise 1
-	server 127.0.3.127 127.0.3.127:80 weight 10 check inter 5140 fall 2 rise 1
-	server 127.0.3.128 127.0.3.128:80 weight 10 check inter 1310 fall 2 rise 1
-	server 127.0.3.129 127.0.3.129:80 weight 10 check inter 481 fall 2 rise 1
-	server 127.0.3.130 127.0.3.130:80 weight 10 check inter 1069 fall 2 rise 1
-	server 127.0.3.131 127.0.3.131:80 weight 10 check inter 2137 fall 2 rise 1
-	server 127.0.3.132 127.0.3.132:80 weight 10 check inter 6498 fall 2 rise 1
-	server 127.0.3.133 127.0.3.133:80 weight 10 check inter 8110 fall 2 rise 1
-	server 127.0.3.134 127.0.3.134:80 weight 10 check inter 7842 fall 2 rise 1
-	server 127.0.3.135 127.0.3.135:80 weight 10 check inter 5858 fall 2 rise 1
-	server 127.0.3.136 127.0.3.136:80 weight 10 check inter 8343 fall 2 rise 1
-	server 127.0.3.137 127.0.3.137:80 weight 10 check inter 2977 fall 2 rise 1
-	server 127.0.3.138 127.0.3.138:80 weight 10 check inter 4641 fall 2 rise 1
-	server 127.0.3.139 127.0.3.139:80 weight 10 check inter 6540 fall 2 rise 1
-	server 127.0.3.140 127.0.3.140:80 weight 10 check inter 9796 fall 2 rise 1
-	server 127.0.3.141 127.0.3.141:80 weight 10 check inter 3077 fall 2 rise 1
-	server 127.0.3.142 127.0.3.142:80 weight 10 check inter 5782 fall 2 rise 1
-	server 127.0.3.143 127.0.3.143:80 weight 10 check inter 7898 fall 2 rise 1
-	server 127.0.3.144 127.0.3.144:80 weight 10 check inter 3177 fall 2 rise 1
-	server 127.0.3.145 127.0.3.145:80 weight 10 check inter 7003 fall 2 rise 1
-	server 127.0.3.146 127.0.3.146:80 weight 10 check inter 7102 fall 2 rise 1
-	server 127.0.3.147 127.0.3.147:80 weight 10 check inter 1285 fall 2 rise 1
-	server 127.0.3.148 127.0.3.148:80 weight 10 check inter 495 fall 2 rise 1
-	server 127.0.3.149 127.0.3.149:80 weight 10 check inter 5302 fall 2 rise 1
-	server 127.0.3.150 127.0.3.150:80 weight 10 check inter 3136 fall 2 rise 1
-	server 127.0.3.151 127.0.3.151:80 weight 10 check inter 4582 fall 2 rise 1
-	server 127.0.3.152 127.0.3.152:80 weight 10 check inter 5789 fall 2 rise 1
-	server 127.0.3.153 127.0.3.153:80 weight 10 check inter 2872 fall 2 rise 1
-	server 127.0.3.154 127.0.3.154:80 weight 10 check inter 7389 fall 2 rise 1
-	server 127.0.3.155 127.0.3.155:80 weight 10 check inter 996 fall 2 rise 1
-	server 127.0.3.156 127.0.3.156:80 weight 10 check inter 6282 fall 2 rise 1
-	server 127.0.3.157 127.0.3.157:80 weight 10 check inter 9024 fall 2 rise 1
-	server 127.0.3.158 127.0.3.158:80 weight 10 check inter 8104 fall 2 rise 1
-	server 127.0.3.159 127.0.3.159:80 weight 10 check inter 8062 fall 2 rise 1
-	server 127.0.3.160 127.0.3.160:80 weight 10 check inter 7974 fall 2 rise 1
-	server 127.0.3.161 127.0.3.161:80 weight 10 check inter 7489 fall 2 rise 1
-	server 127.0.3.162 127.0.3.162:80 weight 10 check inter 390 fall 2 rise 1
-	server 127.0.3.163 127.0.3.163:80 weight 10 check inter 599 fall 2 rise 1
-	server 127.0.3.164 127.0.3.164:80 weight 10 check inter 9686 fall 2 rise 1
-	server 127.0.3.165 127.0.3.165:80 weight 10 check inter 3009 fall 2 rise 1
-	server 127.0.3.166 127.0.3.166:80 weight 10 check inter 4340 fall 2 rise 1
-	server 127.0.3.167 127.0.3.167:80 weight 10 check inter 868 fall 2 rise 1
-	server 127.0.3.168 127.0.3.168:80 weight 10 check inter 1651 fall 2 rise 1
-	server 127.0.3.169 127.0.3.169:80 weight 10 check inter 2326 fall 2 rise 1
-	server 127.0.3.170 127.0.3.170:80 weight 10 check inter 2155 fall 2 rise 1
-	server 127.0.3.171 127.0.3.171:80 weight 10 check inter 5383 fall 2 rise 1
-	server 127.0.3.172 127.0.3.172:80 weight 10 check inter 2194 fall 2 rise 1
-	server 127.0.3.173 127.0.3.173:80 weight 10 check inter 5744 fall 2 rise 1
-	server 127.0.3.174 127.0.3.174:80 weight 10 check inter 1125 fall 2 rise 1
-	server 127.0.3.175 127.0.3.175:80 weight 10 check inter 1274 fall 2 rise 1
-	server 127.0.3.176 127.0.3.176:80 weight 10 check inter 306 fall 2 rise 1
-	server 127.0.3.177 127.0.3.177:80 weight 10 check inter 3078 fall 2 rise 1
-	server 127.0.3.178 127.0.3.178:80 weight 10 check inter 6108 fall 2 rise 1
-	server 127.0.3.179 127.0.3.179:80 weight 10 check inter 9066 fall 2 rise 1
-	server 127.0.3.180 127.0.3.180:80 weight 10 check inter 1944 fall 2 rise 1
-	server 127.0.3.181 127.0.3.181:80 weight 10 check inter 9090 fall 2 rise 1
-	server 127.0.3.182 127.0.3.182:80 weight 10 check inter 7750 fall 2 rise 1
-	server 127.0.3.183 127.0.3.183:80 weight 10 check inter 7721 fall 2 rise 1
-	server 127.0.3.184 127.0.3.184:80 weight 10 check inter 6330 fall 2 rise 1
-	server 127.0.3.185 127.0.3.185:80 weight 10 check inter 6684 fall 2 rise 1
-	server 127.0.3.186 127.0.3.186:80 weight 10 check inter 1762 fall 2 rise 1
-	server 127.0.3.187 127.0.3.187:80 weight 10 check inter 1201 fall 2 rise 1
-	server 127.0.3.188 127.0.3.188:80 weight 10 check inter 7325 fall 2 rise 1
-	server 127.0.3.189 127.0.3.189:80 weight 10 check inter 9127 fall 2 rise 1
-	server 127.0.3.190 127.0.3.190:80 weight 10 check inter 5506 fall 2 rise 1
-	server 127.0.3.191 127.0.3.191:80 weight 10 check inter 6617 fall 2 rise 1
-	server 127.0.3.192 127.0.3.192:80 weight 10 check inter 7038 fall 2 rise 1
-	server 127.0.3.193 127.0.3.193:80 weight 10 check inter 2781 fall 2 rise 1
-	server 127.0.3.194 127.0.3.194:80 weight 10 check inter 8278 fall 2 rise 1
-	server 127.0.3.195 127.0.3.195:80 weight 10 check inter 6425 fall 2 rise 1
-	server 127.0.3.196 127.0.3.196:80 weight 10 check inter 2643 fall 2 rise 1
-	server 127.0.3.197 127.0.3.197:80 weight 10 check inter 540 fall 2 rise 1
-	server 127.0.3.198 127.0.3.198:80 weight 10 check inter 1100 fall 2 rise 1
-	server 127.0.3.199 127.0.3.199:80 weight 10 check inter 6878 fall 2 rise 1
-	server 127.0.3.200 127.0.3.200:80 weight 10 check inter 9359 fall 2 rise 1
-	server 127.0.3.201 127.0.3.201:80 weight 10 check inter 5309 fall 2 rise 1
-	server 127.0.3.202 127.0.3.202:80 weight 10 check inter 6682 fall 2 rise 1
-	server 127.0.3.203 127.0.3.203:80 weight 10 check inter 4301 fall 2 rise 1
-	server 127.0.3.204 127.0.3.204:80 weight 10 check inter 3528 fall 2 rise 1
-	server 127.0.3.205 127.0.3.205:80 weight 10 check inter 7576 fall 2 rise 1
-	server 127.0.3.206 127.0.3.206:80 weight 10 check inter 7687 fall 2 rise 1
-	server 127.0.3.207 127.0.3.207:80 weight 10 check inter 7830 fall 2 rise 1
-	server 127.0.3.208 127.0.3.208:80 weight 10 check inter 425 fall 2 rise 1
-	server 127.0.3.209 127.0.3.209:80 weight 10 check inter 3002 fall 2 rise 1
-	server 127.0.3.210 127.0.3.210:80 weight 10 check inter 4604 fall 2 rise 1
-	server 127.0.3.211 127.0.3.211:80 weight 10 check inter 5904 fall 2 rise 1
-	server 127.0.3.212 127.0.3.212:80 weight 10 check inter 4405 fall 2 rise 1
-	server 127.0.3.213 127.0.3.213:80 weight 10 check inter 3009 fall 2 rise 1
-	server 127.0.3.214 127.0.3.214:80 weight 10 check inter 1166 fall 2 rise 1
-	server 127.0.3.215 127.0.3.215:80 weight 10 check inter 7262 fall 2 rise 1
-	server 127.0.3.216 127.0.3.216:80 weight 10 check inter 226 fall 2 rise 1
-	server 127.0.3.217 127.0.3.217:80 weight 10 check inter 1101 fall 2 rise 1
-	server 127.0.3.218 127.0.3.218:80 weight 10 check inter 3704 fall 2 rise 1
-	server 127.0.3.219 127.0.3.219:80 weight 10 check inter 2709 fall 2 rise 1
-	server 127.0.3.220 127.0.3.220:80 weight 10 check inter 1250 fall 2 rise 1
-	server 127.0.3.221 127.0.3.221:80 weight 10 check inter 7063 fall 2 rise 1
-	server 127.0.3.222 127.0.3.222:80 weight 10 check inter 251 fall 2 rise 1
-	server 127.0.3.223 127.0.3.223:80 weight 10 check inter 1133 fall 2 rise 1
-	server 127.0.3.224 127.0.3.224:80 weight 10 check inter 2320 fall 2 rise 1
-	server 127.0.3.225 127.0.3.225:80 weight 10 check inter 5358 fall 2 rise 1
-	server 127.0.3.226 127.0.3.226:80 weight 10 check inter 1749 fall 2 rise 1
-	server 127.0.3.227 127.0.3.227:80 weight 10 check inter 8824 fall 2 rise 1
-	server 127.0.3.228 127.0.3.228:80 weight 10 check inter 9167 fall 2 rise 1
-	server 127.0.3.229 127.0.3.229:80 weight 10 check inter 326 fall 2 rise 1
-	server 127.0.3.230 127.0.3.230:80 weight 10 check inter 6274 fall 2 rise 1
-	server 127.0.3.231 127.0.3.231:80 weight 10 check inter 7270 fall 2 rise 1
-	server 127.0.3.232 127.0.3.232:80 weight 10 check inter 2131 fall 2 rise 1
-	server 127.0.3.233 127.0.3.233:80 weight 10 check inter 5551 fall 2 rise 1
-	server 127.0.3.234 127.0.3.234:80 weight 10 check inter 1845 fall 2 rise 1
-	server 127.0.3.235 127.0.3.235:80 weight 10 check inter 612 fall 2 rise 1
-	server 127.0.3.236 127.0.3.236:80 weight 10 check inter 4811 fall 2 rise 1
-	server 127.0.3.237 127.0.3.237:80 weight 10 check inter 5110 fall 2 rise 1
-	server 127.0.3.238 127.0.3.238:80 weight 10 check inter 3365 fall 2 rise 1
-	server 127.0.3.239 127.0.3.239:80 weight 10 check inter 280 fall 2 rise 1
-	server 127.0.3.240 127.0.3.240:80 weight 10 check inter 85 fall 2 rise 1
-	server 127.0.3.241 127.0.3.241:80 weight 10 check inter 5134 fall 2 rise 1
-	server 127.0.3.242 127.0.3.242:80 weight 10 check inter 9096 fall 2 rise 1
-	server 127.0.3.243 127.0.3.243:80 weight 10 check inter 3502 fall 2 rise 1
-	server 127.0.3.244 127.0.3.244:80 weight 10 check inter 5151 fall 2 rise 1
-	server 127.0.3.245 127.0.3.245:80 weight 10 check inter 6781 fall 2 rise 1
-	server 127.0.3.246 127.0.3.246:80 weight 10 check inter 5600 fall 2 rise 1
-	server 127.0.3.247 127.0.3.247:80 weight 10 check inter 5359 fall 2 rise 1
-	server 127.0.3.248 127.0.3.248:80 weight 10 check inter 4494 fall 2 rise 1
-	server 127.0.3.249 127.0.3.249:80 weight 10 check inter 2726 fall 2 rise 1
-	server 127.0.3.250 127.0.3.250:80 weight 10 check inter 2711 fall 2 rise 1
-	server 127.0.4.001 127.0.4.1:80 weight 10 check inter 6182 fall 2 rise 1
-	server 127.0.4.002 127.0.4.2:80 weight 10 check inter 4466 fall 2 rise 1
-	server 127.0.4.003 127.0.4.3:80 weight 10 check inter 1385 fall 2 rise 1
-	server 127.0.4.004 127.0.4.4:80 weight 10 check inter 684 fall 2 rise 1
-	server 127.0.4.005 127.0.4.5:80 weight 10 check inter 7779 fall 2 rise 1
-	server 127.0.4.006 127.0.4.6:80 weight 10 check inter 5876 fall 2 rise 1
-	server 127.0.4.007 127.0.4.7:80 weight 10 check inter 1868 fall 2 rise 1
-	server 127.0.4.008 127.0.4.8:80 weight 10 check inter 9563 fall 2 rise 1
-	server 127.0.4.009 127.0.4.9:80 weight 10 check inter 6459 fall 2 rise 1
-	server 127.0.4.010 127.0.4.10:80 weight 10 check inter 5541 fall 2 rise 1
-	server 127.0.4.011 127.0.4.11:80 weight 10 check inter 7720 fall 2 rise 1
-	server 127.0.4.012 127.0.4.12:80 weight 10 check inter 6142 fall 2 rise 1
-	server 127.0.4.013 127.0.4.13:80 weight 10 check inter 5734 fall 2 rise 1
-	server 127.0.4.014 127.0.4.14:80 weight 10 check inter 565 fall 2 rise 1
-	server 127.0.4.015 127.0.4.15:80 weight 10 check inter 4324 fall 2 rise 1
-	server 127.0.4.016 127.0.4.16:80 weight 10 check inter 4710 fall 2 rise 1
-	server 127.0.4.017 127.0.4.17:80 weight 10 check inter 5558 fall 2 rise 1
-	server 127.0.4.018 127.0.4.18:80 weight 10 check inter 613 fall 2 rise 1
-	server 127.0.4.019 127.0.4.19:80 weight 10 check inter 6146 fall 2 rise 1
-	server 127.0.4.020 127.0.4.20:80 weight 10 check inter 4183 fall 2 rise 1
-	server 127.0.4.021 127.0.4.21:80 weight 10 check inter 9943 fall 2 rise 1
-	server 127.0.4.022 127.0.4.22:80 weight 10 check inter 238 fall 2 rise 1
-	server 127.0.4.023 127.0.4.23:80 weight 10 check inter 1644 fall 2 rise 1
-	server 127.0.4.024 127.0.4.24:80 weight 10 check inter 598 fall 2 rise 1
-	server 127.0.4.025 127.0.4.25:80 weight 10 check inter 7484 fall 2 rise 1
-	server 127.0.4.026 127.0.4.26:80 weight 10 check inter 3310 fall 2 rise 1
-	server 127.0.4.027 127.0.4.27:80 weight 10 check inter 9692 fall 2 rise 1
-	server 127.0.4.028 127.0.4.28:80 weight 10 check inter 5860 fall 2 rise 1
-	server 127.0.4.029 127.0.4.29:80 weight 10 check inter 7236 fall 2 rise 1
-	server 127.0.4.030 127.0.4.30:80 weight 10 check inter 550 fall 2 rise 1
-	server 127.0.4.031 127.0.4.31:80 weight 10 check inter 4733 fall 2 rise 1
-	server 127.0.4.032 127.0.4.32:80 weight 10 check inter 1719 fall 2 rise 1
-	server 127.0.4.033 127.0.4.33:80 weight 10 check inter 3438 fall 2 rise 1
-	server 127.0.4.034 127.0.4.34:80 weight 10 check inter 4164 fall 2 rise 1
-	server 127.0.4.035 127.0.4.35:80 weight 10 check inter 6373 fall 2 rise 1
-	server 127.0.4.036 127.0.4.36:80 weight 10 check inter 2205 fall 2 rise 1
-	server 127.0.4.037 127.0.4.37:80 weight 10 check inter 4721 fall 2 rise 1
-	server 127.0.4.038 127.0.4.38:80 weight 10 check inter 8625 fall 2 rise 1
-	server 127.0.4.039 127.0.4.39:80 weight 10 check inter 1071 fall 2 rise 1
-	server 127.0.4.040 127.0.4.40:80 weight 10 check inter 9456 fall 2 rise 1
-	server 127.0.4.041 127.0.4.41:80 weight 10 check inter 4682 fall 2 rise 1
-	server 127.0.4.042 127.0.4.42:80 weight 10 check inter 2666 fall 2 rise 1
-	server 127.0.4.043 127.0.4.43:80 weight 10 check inter 2106 fall 2 rise 1
-	server 127.0.4.044 127.0.4.44:80 weight 10 check inter 6808 fall 2 rise 1
-	server 127.0.4.045 127.0.4.45:80 weight 10 check inter 9028 fall 2 rise 1
-	server 127.0.4.046 127.0.4.46:80 weight 10 check inter 6895 fall 2 rise 1
-	server 127.0.4.047 127.0.4.47:80 weight 10 check inter 7780 fall 2 rise 1
-	server 127.0.4.048 127.0.4.48:80 weight 10 check inter 2387 fall 2 rise 1
-	server 127.0.4.049 127.0.4.49:80 weight 10 check inter 4298 fall 2 rise 1
-	server 127.0.4.050 127.0.4.50:80 weight 10 check inter 3518 fall 2 rise 1
-	server 127.0.4.051 127.0.4.51:80 weight 10 check inter 4212 fall 2 rise 1
-	server 127.0.4.052 127.0.4.52:80 weight 10 check inter 3221 fall 2 rise 1
-	server 127.0.4.053 127.0.4.53:80 weight 10 check inter 5676 fall 2 rise 1
-	server 127.0.4.054 127.0.4.54:80 weight 10 check inter 77 fall 2 rise 1
-	server 127.0.4.055 127.0.4.55:80 weight 10 check inter 5114 fall 2 rise 1
-	server 127.0.4.056 127.0.4.56:80 weight 10 check inter 800 fall 2 rise 1
-	server 127.0.4.057 127.0.4.57:80 weight 10 check inter 2930 fall 2 rise 1
-	server 127.0.4.058 127.0.4.58:80 weight 10 check inter 489 fall 2 rise 1
-	server 127.0.4.059 127.0.4.59:80 weight 10 check inter 1222 fall 2 rise 1
-	server 127.0.4.060 127.0.4.60:80 weight 10 check inter 9345 fall 2 rise 1
-	server 127.0.4.061 127.0.4.61:80 weight 10 check inter 1187 fall 2 rise 1
-	server 127.0.4.062 127.0.4.62:80 weight 10 check inter 9745 fall 2 rise 1
-	server 127.0.4.063 127.0.4.63:80 weight 10 check inter 3483 fall 2 rise 1
-	server 127.0.4.064 127.0.4.64:80 weight 10 check inter 5408 fall 2 rise 1
-	server 127.0.4.065 127.0.4.65:80 weight 10 check inter 5748 fall 2 rise 1
-	server 127.0.4.066 127.0.4.66:80 weight 10 check inter 3857 fall 2 rise 1
-	server 127.0.4.067 127.0.4.67:80 weight 10 check inter 7570 fall 2 rise 1
-	server 127.0.4.068 127.0.4.68:80 weight 10 check inter 1110 fall 2 rise 1
-	server 127.0.4.069 127.0.4.69:80 weight 10 check inter 4273 fall 2 rise 1
-	server 127.0.4.070 127.0.4.70:80 weight 10 check inter 8656 fall 2 rise 1
-	server 127.0.4.071 127.0.4.71:80 weight 10 check inter 6606 fall 2 rise 1
-	server 127.0.4.072 127.0.4.72:80 weight 10 check inter 5372 fall 2 rise 1
-	server 127.0.4.073 127.0.4.73:80 weight 10 check inter 5533 fall 2 rise 1
-	server 127.0.4.074 127.0.4.74:80 weight 10 check inter 6696 fall 2 rise 1
-	server 127.0.4.075 127.0.4.75:80 weight 10 check inter 9668 fall 2 rise 1
-	server 127.0.4.076 127.0.4.76:80 weight 10 check inter 9736 fall 2 rise 1
-	server 127.0.4.077 127.0.4.77:80 weight 10 check inter 4218 fall 2 rise 1
-	server 127.0.4.078 127.0.4.78:80 weight 10 check inter 3289 fall 2 rise 1
-	server 127.0.4.079 127.0.4.79:80 weight 10 check inter 1414 fall 2 rise 1
-	server 127.0.4.080 127.0.4.80:80 weight 10 check inter 7126 fall 2 rise 1
-	server 127.0.4.081 127.0.4.81:80 weight 10 check inter 6984 fall 2 rise 1
-	server 127.0.4.082 127.0.4.82:80 weight 10 check inter 9661 fall 2 rise 1
-	server 127.0.4.083 127.0.4.83:80 weight 10 check inter 4099 fall 2 rise 1
-	server 127.0.4.084 127.0.4.84:80 weight 10 check inter 4455 fall 2 rise 1
-	server 127.0.4.085 127.0.4.85:80 weight 10 check inter 2173 fall 2 rise 1
-	server 127.0.4.086 127.0.4.86:80 weight 10 check inter 9353 fall 2 rise 1
-	server 127.0.4.087 127.0.4.87:80 weight 10 check inter 3008 fall 2 rise 1
-	server 127.0.4.088 127.0.4.88:80 weight 10 check inter 8668 fall 2 rise 1
-	server 127.0.4.089 127.0.4.89:80 weight 10 check inter 4376 fall 2 rise 1
-	server 127.0.4.090 127.0.4.90:80 weight 10 check inter 7384 fall 2 rise 1
-	server 127.0.4.091 127.0.4.91:80 weight 10 check inter 421 fall 2 rise 1
-	server 127.0.4.092 127.0.4.92:80 weight 10 check inter 1585 fall 2 rise 1
-	server 127.0.4.093 127.0.4.93:80 weight 10 check inter 8582 fall 2 rise 1
-	server 127.0.4.094 127.0.4.94:80 weight 10 check inter 5063 fall 2 rise 1
-	server 127.0.4.095 127.0.4.95:80 weight 10 check inter 1912 fall 2 rise 1
-	server 127.0.4.096 127.0.4.96:80 weight 10 check inter 202 fall 2 rise 1
-	server 127.0.4.097 127.0.4.97:80 weight 10 check inter 9376 fall 2 rise 1
-	server 127.0.4.098 127.0.4.98:80 weight 10 check inter 9536 fall 2 rise 1
-	server 127.0.4.099 127.0.4.99:80 weight 10 check inter 1785 fall 2 rise 1
-	server 127.0.4.100 127.0.4.100:80 weight 10 check inter 6287 fall 2 rise 1
-	server 127.0.4.101 127.0.4.101:80 weight 10 check inter 6283 fall 2 rise 1
-	server 127.0.4.102 127.0.4.102:80 weight 10 check inter 1223 fall 2 rise 1
-	server 127.0.4.103 127.0.4.103:80 weight 10 check inter 9762 fall 2 rise 1
-	server 127.0.4.104 127.0.4.104:80 weight 10 check inter 8535 fall 2 rise 1
-	server 127.0.4.105 127.0.4.105:80 weight 10 check inter 3277 fall 2 rise 1
-	server 127.0.4.106 127.0.4.106:80 weight 10 check inter 1799 fall 2 rise 1
-	server 127.0.4.107 127.0.4.107:80 weight 10 check inter 1245 fall 2 rise 1
-	server 127.0.4.108 127.0.4.108:80 weight 10 check inter 8981 fall 2 rise 1
-	server 127.0.4.109 127.0.4.109:80 weight 10 check inter 6976 fall 2 rise 1
-	server 127.0.4.110 127.0.4.110:80 weight 10 check inter 1850 fall 2 rise 1
-	server 127.0.4.111 127.0.4.111:80 weight 10 check inter 3907 fall 2 rise 1
-	server 127.0.4.112 127.0.4.112:80 weight 10 check inter 1221 fall 2 rise 1
-	server 127.0.4.113 127.0.4.113:80 weight 10 check inter 7688 fall 2 rise 1
-	server 127.0.4.114 127.0.4.114:80 weight 10 check inter 3194 fall 2 rise 1
-	server 127.0.4.115 127.0.4.115:80 weight 10 check inter 4632 fall 2 rise 1
-	server 127.0.4.116 127.0.4.116:80 weight 10 check inter 1685 fall 2 rise 1
-	server 127.0.4.117 127.0.4.117:80 weight 10 check inter 9972 fall 2 rise 1
-	server 127.0.4.118 127.0.4.118:80 weight 10 check inter 3290 fall 2 rise 1
-	server 127.0.4.119 127.0.4.119:80 weight 10 check inter 3208 fall 2 rise 1
-	server 127.0.4.120 127.0.4.120:80 weight 10 check inter 9379 fall 2 rise 1
-	server 127.0.4.121 127.0.4.121:80 weight 10 check inter 7511 fall 2 rise 1
-	server 127.0.4.122 127.0.4.122:80 weight 10 check inter 2708 fall 2 rise 1
-	server 127.0.4.123 127.0.4.123:80 weight 10 check inter 2063 fall 2 rise 1
-	server 127.0.4.124 127.0.4.124:80 weight 10 check inter 7931 fall 2 rise 1
-	server 127.0.4.125 127.0.4.125:80 weight 10 check inter 6627 fall 2 rise 1
-	server 127.0.4.126 127.0.4.126:80 weight 10 check inter 9425 fall 2 rise 1
-	server 127.0.4.127 127.0.4.127:80 weight 10 check inter 6139 fall 2 rise 1
-	server 127.0.4.128 127.0.4.128:80 weight 10 check inter 5965 fall 2 rise 1
-	server 127.0.4.129 127.0.4.129:80 weight 10 check inter 6202 fall 2 rise 1
-	server 127.0.4.130 127.0.4.130:80 weight 10 check inter 9050 fall 2 rise 1
-	server 127.0.4.131 127.0.4.131:80 weight 10 check inter 4322 fall 2 rise 1
-	server 127.0.4.132 127.0.4.132:80 weight 10 check inter 1984 fall 2 rise 1
-	server 127.0.4.133 127.0.4.133:80 weight 10 check inter 3669 fall 2 rise 1
-	server 127.0.4.134 127.0.4.134:80 weight 10 check inter 8753 fall 2 rise 1
-	server 127.0.4.135 127.0.4.135:80 weight 10 check inter 6707 fall 2 rise 1
-	server 127.0.4.136 127.0.4.136:80 weight 10 check inter 5305 fall 2 rise 1
-	server 127.0.4.137 127.0.4.137:80 weight 10 check inter 3328 fall 2 rise 1
-	server 127.0.4.138 127.0.4.138:80 weight 10 check inter 1230 fall 2 rise 1
-	server 127.0.4.139 127.0.4.139:80 weight 10 check inter 5550 fall 2 rise 1
-	server 127.0.4.140 127.0.4.140:80 weight 10 check inter 6729 fall 2 rise 1
-	server 127.0.4.141 127.0.4.141:80 weight 10 check inter 3276 fall 2 rise 1
-	server 127.0.4.142 127.0.4.142:80 weight 10 check inter 6314 fall 2 rise 1
-	server 127.0.4.143 127.0.4.143:80 weight 10 check inter 3282 fall 2 rise 1
-	server 127.0.4.144 127.0.4.144:80 weight 10 check inter 5945 fall 2 rise 1
-	server 127.0.4.145 127.0.4.145:80 weight 10 check inter 7170 fall 2 rise 1
-	server 127.0.4.146 127.0.4.146:80 weight 10 check inter 126 fall 2 rise 1
-	server 127.0.4.147 127.0.4.147:80 weight 10 check inter 363 fall 2 rise 1
-	server 127.0.4.148 127.0.4.148:80 weight 10 check inter 6839 fall 2 rise 1
-	server 127.0.4.149 127.0.4.149:80 weight 10 check inter 4376 fall 2 rise 1
-	server 127.0.4.150 127.0.4.150:80 weight 10 check inter 4282 fall 2 rise 1
-	server 127.0.4.151 127.0.4.151:80 weight 10 check inter 7400 fall 2 rise 1
-	server 127.0.4.152 127.0.4.152:80 weight 10 check inter 4318 fall 2 rise 1
-	server 127.0.4.153 127.0.4.153:80 weight 10 check inter 3013 fall 2 rise 1
-	server 127.0.4.154 127.0.4.154:80 weight 10 check inter 420 fall 2 rise 1
-	server 127.0.4.155 127.0.4.155:80 weight 10 check inter 9421 fall 2 rise 1
-	server 127.0.4.156 127.0.4.156:80 weight 10 check inter 1862 fall 2 rise 1
-	server 127.0.4.157 127.0.4.157:80 weight 10 check inter 7300 fall 2 rise 1
-	server 127.0.4.158 127.0.4.158:80 weight 10 check inter 7382 fall 2 rise 1
-	server 127.0.4.159 127.0.4.159:80 weight 10 check inter 4397 fall 2 rise 1
-	server 127.0.4.160 127.0.4.160:80 weight 10 check inter 9841 fall 2 rise 1
-	server 127.0.4.161 127.0.4.161:80 weight 10 check inter 5867 fall 2 rise 1
-	server 127.0.4.162 127.0.4.162:80 weight 10 check inter 2726 fall 2 rise 1
-	server 127.0.4.163 127.0.4.163:80 weight 10 check inter 1749 fall 2 rise 1
-	server 127.0.4.164 127.0.4.164:80 weight 10 check inter 9505 fall 2 rise 1
-	server 127.0.4.165 127.0.4.165:80 weight 10 check inter 2424 fall 2 rise 1
-	server 127.0.4.166 127.0.4.166:80 weight 10 check inter 836 fall 2 rise 1
-	server 127.0.4.167 127.0.4.167:80 weight 10 check inter 8488 fall 2 rise 1
-	server 127.0.4.168 127.0.4.168:80 weight 10 check inter 4857 fall 2 rise 1
-	server 127.0.4.169 127.0.4.169:80 weight 10 check inter 8864 fall 2 rise 1
-	server 127.0.4.170 127.0.4.170:80 weight 10 check inter 6261 fall 2 rise 1
-	server 127.0.4.171 127.0.4.171:80 weight 10 check inter 8719 fall 2 rise 1
-	server 127.0.4.172 127.0.4.172:80 weight 10 check inter 4986 fall 2 rise 1
-	server 127.0.4.173 127.0.4.173:80 weight 10 check inter 9399 fall 2 rise 1
-	server 127.0.4.174 127.0.4.174:80 weight 10 check inter 7586 fall 2 rise 1
-	server 127.0.4.175 127.0.4.175:80 weight 10 check inter 749 fall 2 rise 1
-	server 127.0.4.176 127.0.4.176:80 weight 10 check inter 474 fall 2 rise 1
-	server 127.0.4.177 127.0.4.177:80 weight 10 check inter 5647 fall 2 rise 1
-	server 127.0.4.178 127.0.4.178:80 weight 10 check inter 3408 fall 2 rise 1
-	server 127.0.4.179 127.0.4.179:80 weight 10 check inter 2643 fall 2 rise 1
-	server 127.0.4.180 127.0.4.180:80 weight 10 check inter 8900 fall 2 rise 1
-	server 127.0.4.181 127.0.4.181:80 weight 10 check inter 2065 fall 2 rise 1
-	server 127.0.4.182 127.0.4.182:80 weight 10 check inter 1886 fall 2 rise 1
-	server 127.0.4.183 127.0.4.183:80 weight 10 check inter 3224 fall 2 rise 1
-	server 127.0.4.184 127.0.4.184:80 weight 10 check inter 6611 fall 2 rise 1
-	server 127.0.4.185 127.0.4.185:80 weight 10 check inter 8252 fall 2 rise 1
-	server 127.0.4.186 127.0.4.186:80 weight 10 check inter 1873 fall 2 rise 1
-	server 127.0.4.187 127.0.4.187:80 weight 10 check inter 9798 fall 2 rise 1
-	server 127.0.4.188 127.0.4.188:80 weight 10 check inter 9452 fall 2 rise 1
-	server 127.0.4.189 127.0.4.189:80 weight 10 check inter 3952 fall 2 rise 1
-	server 127.0.4.190 127.0.4.190:80 weight 10 check inter 8959 fall 2 rise 1
-	server 127.0.4.191 127.0.4.191:80 weight 10 check inter 2565 fall 2 rise 1
-	server 127.0.4.192 127.0.4.192:80 weight 10 check inter 2413 fall 2 rise 1
-	server 127.0.4.193 127.0.4.193:80 weight 10 check inter 4698 fall 2 rise 1
-	server 127.0.4.194 127.0.4.194:80 weight 10 check inter 2748 fall 2 rise 1
-	server 127.0.4.195 127.0.4.195:80 weight 10 check inter 4665 fall 2 rise 1
-	server 127.0.4.196 127.0.4.196:80 weight 10 check inter 1049 fall 2 rise 1
-	server 127.0.4.197 127.0.4.197:80 weight 10 check inter 4381 fall 2 rise 1
-	server 127.0.4.198 127.0.4.198:80 weight 10 check inter 1464 fall 2 rise 1
-	server 127.0.4.199 127.0.4.199:80 weight 10 check inter 1034 fall 2 rise 1
-	server 127.0.4.200 127.0.4.200:80 weight 10 check inter 9809 fall 2 rise 1
-	server 127.0.4.201 127.0.4.201:80 weight 10 check inter 8676 fall 2 rise 1
-	server 127.0.4.202 127.0.4.202:80 weight 10 check inter 6181 fall 2 rise 1
-	server 127.0.4.203 127.0.4.203:80 weight 10 check inter 919 fall 2 rise 1
-	server 127.0.4.204 127.0.4.204:80 weight 10 check inter 1122 fall 2 rise 1
-	server 127.0.4.205 127.0.4.205:80 weight 10 check inter 7466 fall 2 rise 1
-	server 127.0.4.206 127.0.4.206:80 weight 10 check inter 3738 fall 2 rise 1
-	server 127.0.4.207 127.0.4.207:80 weight 10 check inter 1322 fall 2 rise 1
-	server 127.0.4.208 127.0.4.208:80 weight 10 check inter 9569 fall 2 rise 1
-	server 127.0.4.209 127.0.4.209:80 weight 10 check inter 2790 fall 2 rise 1
-	server 127.0.4.210 127.0.4.210:80 weight 10 check inter 7849 fall 2 rise 1
-	server 127.0.4.211 127.0.4.211:80 weight 10 check inter 3017 fall 2 rise 1
-	server 127.0.4.212 127.0.4.212:80 weight 10 check inter 4982 fall 2 rise 1
-	server 127.0.4.213 127.0.4.213:80 weight 10 check inter 4487 fall 2 rise 1
-	server 127.0.4.214 127.0.4.214:80 weight 10 check inter 1760 fall 2 rise 1
-	server 127.0.4.215 127.0.4.215:80 weight 10 check inter 434 fall 2 rise 1
-	server 127.0.4.216 127.0.4.216:80 weight 10 check inter 1131 fall 2 rise 1
-	server 127.0.4.217 127.0.4.217:80 weight 10 check inter 1747 fall 2 rise 1
-	server 127.0.4.218 127.0.4.218:80 weight 10 check inter 2594 fall 2 rise 1
-	server 127.0.4.219 127.0.4.219:80 weight 10 check inter 8995 fall 2 rise 1
-	server 127.0.4.220 127.0.4.220:80 weight 10 check inter 9363 fall 2 rise 1
-	server 127.0.4.221 127.0.4.221:80 weight 10 check inter 7472 fall 2 rise 1
-	server 127.0.4.222 127.0.4.222:80 weight 10 check inter 3043 fall 2 rise 1
-	server 127.0.4.223 127.0.4.223:80 weight 10 check inter 3101 fall 2 rise 1
-	server 127.0.4.224 127.0.4.224:80 weight 10 check inter 475 fall 2 rise 1
-	server 127.0.4.225 127.0.4.225:80 weight 10 check inter 174 fall 2 rise 1
-	server 127.0.4.226 127.0.4.226:80 weight 10 check inter 8245 fall 2 rise 1
-	server 127.0.4.227 127.0.4.227:80 weight 10 check inter 9399 fall 2 rise 1
-	server 127.0.4.228 127.0.4.228:80 weight 10 check inter 1410 fall 2 rise 1
-	server 127.0.4.229 127.0.4.229:80 weight 10 check inter 8907 fall 2 rise 1
-	server 127.0.4.230 127.0.4.230:80 weight 10 check inter 4565 fall 2 rise 1
-	server 127.0.4.231 127.0.4.231:80 weight 10 check inter 5153 fall 2 rise 1
-	server 127.0.4.232 127.0.4.232:80 weight 10 check inter 6216 fall 2 rise 1
-	server 127.0.4.233 127.0.4.233:80 weight 10 check inter 6548 fall 2 rise 1
-	server 127.0.4.234 127.0.4.234:80 weight 10 check inter 9365 fall 2 rise 1
-	server 127.0.4.235 127.0.4.235:80 weight 10 check inter 9119 fall 2 rise 1
-	server 127.0.4.236 127.0.4.236:80 weight 10 check inter 5095 fall 2 rise 1
-	server 127.0.4.237 127.0.4.237:80 weight 10 check inter 2668 fall 2 rise 1
-	server 127.0.4.238 127.0.4.238:80 weight 10 check inter 8 fall 2 rise 1
-	server 127.0.4.239 127.0.4.239:80 weight 10 check inter 8737 fall 2 rise 1
-	server 127.0.4.240 127.0.4.240:80 weight 10 check inter 356 fall 2 rise 1
-	server 127.0.4.241 127.0.4.241:80 weight 10 check inter 4959 fall 2 rise 1
-	server 127.0.4.242 127.0.4.242:80 weight 10 check inter 6272 fall 2 rise 1
-	server 127.0.4.243 127.0.4.243:80 weight 10 check inter 2597 fall 2 rise 1
-	server 127.0.4.244 127.0.4.244:80 weight 10 check inter 324 fall 2 rise 1
-	server 127.0.4.245 127.0.4.245:80 weight 10 check inter 1699 fall 2 rise 1
-	server 127.0.4.246 127.0.4.246:80 weight 10 check inter 3335 fall 2 rise 1
-	server 127.0.4.247 127.0.4.247:80 weight 10 check inter 892 fall 2 rise 1
-	server 127.0.4.248 127.0.4.248:80 weight 10 check inter 6190 fall 2 rise 1
-	server 127.0.4.249 127.0.4.249:80 weight 10 check inter 2547 fall 2 rise 1
-	server 127.0.4.250 127.0.4.250:80 weight 10 check inter 2735 fall 2 rise 1
-	server 127.0.5.001 127.0.5.1:80 weight 10 check inter 4076 fall 2 rise 1
-	server 127.0.5.002 127.0.5.2:80 weight 10 check inter 2853 fall 2 rise 1
-	server 127.0.5.003 127.0.5.3:80 weight 10 check inter 1818 fall 2 rise 1
-	server 127.0.5.004 127.0.5.4:80 weight 10 check inter 1226 fall 2 rise 1
-	server 127.0.5.005 127.0.5.5:80 weight 10 check inter 7179 fall 2 rise 1
-	server 127.0.5.006 127.0.5.6:80 weight 10 check inter 5330 fall 2 rise 1
-	server 127.0.5.007 127.0.5.7:80 weight 10 check inter 4770 fall 2 rise 1
-	server 127.0.5.008 127.0.5.8:80 weight 10 check inter 5737 fall 2 rise 1
-	server 127.0.5.009 127.0.5.9:80 weight 10 check inter 774 fall 2 rise 1
-	server 127.0.5.010 127.0.5.10:80 weight 10 check inter 739 fall 2 rise 1
-	server 127.0.5.011 127.0.5.11:80 weight 10 check inter 1210 fall 2 rise 1
-	server 127.0.5.012 127.0.5.12:80 weight 10 check inter 5701 fall 2 rise 1
-	server 127.0.5.013 127.0.5.13:80 weight 10 check inter 9300 fall 2 rise 1
-	server 127.0.5.014 127.0.5.14:80 weight 10 check inter 181 fall 2 rise 1
-	server 127.0.5.015 127.0.5.15:80 weight 10 check inter 5721 fall 2 rise 1
-	server 127.0.5.016 127.0.5.16:80 weight 10 check inter 9438 fall 2 rise 1
-	server 127.0.5.017 127.0.5.17:80 weight 10 check inter 7711 fall 2 rise 1
-	server 127.0.5.018 127.0.5.18:80 weight 10 check inter 4995 fall 2 rise 1
-	server 127.0.5.019 127.0.5.19:80 weight 10 check inter 7733 fall 2 rise 1
-	server 127.0.5.020 127.0.5.20:80 weight 10 check inter 8807 fall 2 rise 1
-	server 127.0.5.021 127.0.5.21:80 weight 10 check inter 7772 fall 2 rise 1
-	server 127.0.5.022 127.0.5.22:80 weight 10 check inter 12 fall 2 rise 1
-	server 127.0.5.023 127.0.5.23:80 weight 10 check inter 2434 fall 2 rise 1
-	server 127.0.5.024 127.0.5.24:80 weight 10 check inter 5054 fall 2 rise 1
-	server 127.0.5.025 127.0.5.25:80 weight 10 check inter 8222 fall 2 rise 1
-	server 127.0.5.026 127.0.5.26:80 weight 10 check inter 9989 fall 2 rise 1
-	server 127.0.5.027 127.0.5.27:80 weight 10 check inter 6827 fall 2 rise 1
-	server 127.0.5.028 127.0.5.28:80 weight 10 check inter 6604 fall 2 rise 1
-	server 127.0.5.029 127.0.5.29:80 weight 10 check inter 1342 fall 2 rise 1
-	server 127.0.5.030 127.0.5.30:80 weight 10 check inter 4612 fall 2 rise 1
-	server 127.0.5.031 127.0.5.31:80 weight 10 check inter 2546 fall 2 rise 1
-	server 127.0.5.032 127.0.5.32:80 weight 10 check inter 7697 fall 2 rise 1
-	server 127.0.5.033 127.0.5.33:80 weight 10 check inter 601 fall 2 rise 1
-	server 127.0.5.034 127.0.5.34:80 weight 10 check inter 2072 fall 2 rise 1
-	server 127.0.5.035 127.0.5.35:80 weight 10 check inter 9560 fall 2 rise 1
-	server 127.0.5.036 127.0.5.36:80 weight 10 check inter 1197 fall 2 rise 1
-	server 127.0.5.037 127.0.5.37:80 weight 10 check inter 9783 fall 2 rise 1
-	server 127.0.5.038 127.0.5.38:80 weight 10 check inter 4489 fall 2 rise 1
-	server 127.0.5.039 127.0.5.39:80 weight 10 check inter 4875 fall 2 rise 1
-	server 127.0.5.040 127.0.5.40:80 weight 10 check inter 1454 fall 2 rise 1
-	server 127.0.5.041 127.0.5.41:80 weight 10 check inter 415 fall 2 rise 1
-	server 127.0.5.042 127.0.5.42:80 weight 10 check inter 9011 fall 2 rise 1
-	server 127.0.5.043 127.0.5.43:80 weight 10 check inter 9570 fall 2 rise 1
-	server 127.0.5.044 127.0.5.44:80 weight 10 check inter 3133 fall 2 rise 1
-	server 127.0.5.045 127.0.5.45:80 weight 10 check inter 4045 fall 2 rise 1
-	server 127.0.5.046 127.0.5.46:80 weight 10 check inter 5714 fall 2 rise 1
-	server 127.0.5.047 127.0.5.47:80 weight 10 check inter 585 fall 2 rise 1
-	server 127.0.5.048 127.0.5.48:80 weight 10 check inter 807 fall 2 rise 1
-	server 127.0.5.049 127.0.5.49:80 weight 10 check inter 3422 fall 2 rise 1
-	server 127.0.5.050 127.0.5.50:80 weight 10 check inter 1500 fall 2 rise 1
-	server 127.0.5.051 127.0.5.51:80 weight 10 check inter 6765 fall 2 rise 1
-	server 127.0.5.052 127.0.5.52:80 weight 10 check inter 6940 fall 2 rise 1
-	server 127.0.5.053 127.0.5.53:80 weight 10 check inter 9153 fall 2 rise 1
-	server 127.0.5.054 127.0.5.54:80 weight 10 check inter 1921 fall 2 rise 1
-	server 127.0.5.055 127.0.5.55:80 weight 10 check inter 487 fall 2 rise 1
-	server 127.0.5.056 127.0.5.56:80 weight 10 check inter 1354 fall 2 rise 1
-	server 127.0.5.057 127.0.5.57:80 weight 10 check inter 765 fall 2 rise 1
-	server 127.0.5.058 127.0.5.58:80 weight 10 check inter 1635 fall 2 rise 1
-	server 127.0.5.059 127.0.5.59:80 weight 10 check inter 537 fall 2 rise 1
-	server 127.0.5.060 127.0.5.60:80 weight 10 check inter 7030 fall 2 rise 1
-	server 127.0.5.061 127.0.5.61:80 weight 10 check inter 4482 fall 2 rise 1
-	server 127.0.5.062 127.0.5.62:80 weight 10 check inter 2661 fall 2 rise 1
-	server 127.0.5.063 127.0.5.63:80 weight 10 check inter 4170 fall 2 rise 1
-	server 127.0.5.064 127.0.5.64:80 weight 10 check inter 6431 fall 2 rise 1
-	server 127.0.5.065 127.0.5.65:80 weight 10 check inter 8161 fall 2 rise 1
-	server 127.0.5.066 127.0.5.66:80 weight 10 check inter 6229 fall 2 rise 1
-	server 127.0.5.067 127.0.5.67:80 weight 10 check inter 5265 fall 2 rise 1
-	server 127.0.5.068 127.0.5.68:80 weight 10 check inter 1651 fall 2 rise 1
-	server 127.0.5.069 127.0.5.69:80 weight 10 check inter 9083 fall 2 rise 1
-	server 127.0.5.070 127.0.5.70:80 weight 10 check inter 9978 fall 2 rise 1
-	server 127.0.5.071 127.0.5.71:80 weight 10 check inter 6338 fall 2 rise 1
-	server 127.0.5.072 127.0.5.72:80 weight 10 check inter 719 fall 2 rise 1
-	server 127.0.5.073 127.0.5.73:80 weight 10 check inter 2906 fall 2 rise 1
-	server 127.0.5.074 127.0.5.74:80 weight 10 check inter 4332 fall 2 rise 1
-	server 127.0.5.075 127.0.5.75:80 weight 10 check inter 2572 fall 2 rise 1
-	server 127.0.5.076 127.0.5.76:80 weight 10 check inter 9527 fall 2 rise 1
-	server 127.0.5.077 127.0.5.77:80 weight 10 check inter 7601 fall 2 rise 1
-	server 127.0.5.078 127.0.5.78:80 weight 10 check inter 6869 fall 2 rise 1
-	server 127.0.5.079 127.0.5.79:80 weight 10 check inter 526 fall 2 rise 1
-	server 127.0.5.080 127.0.5.80:80 weight 10 check inter 9737 fall 2 rise 1
-	server 127.0.5.081 127.0.5.81:80 weight 10 check inter 5941 fall 2 rise 1
-	server 127.0.5.082 127.0.5.82:80 weight 10 check inter 7883 fall 2 rise 1
-	server 127.0.5.083 127.0.5.83:80 weight 10 check inter 8637 fall 2 rise 1
-	server 127.0.5.084 127.0.5.84:80 weight 10 check inter 8385 fall 2 rise 1
-	server 127.0.5.085 127.0.5.85:80 weight 10 check inter 5720 fall 2 rise 1
-	server 127.0.5.086 127.0.5.86:80 weight 10 check inter 1211 fall 2 rise 1
-	server 127.0.5.087 127.0.5.87:80 weight 10 check inter 5543 fall 2 rise 1
-	server 127.0.5.088 127.0.5.88:80 weight 10 check inter 348 fall 2 rise 1
-	server 127.0.5.089 127.0.5.89:80 weight 10 check inter 4058 fall 2 rise 1
-	server 127.0.5.090 127.0.5.90:80 weight 10 check inter 1044 fall 2 rise 1
-	server 127.0.5.091 127.0.5.91:80 weight 10 check inter 4868 fall 2 rise 1
-	server 127.0.5.092 127.0.5.92:80 weight 10 check inter 7246 fall 2 rise 1
-	server 127.0.5.093 127.0.5.93:80 weight 10 check inter 4046 fall 2 rise 1
-	server 127.0.5.094 127.0.5.94:80 weight 10 check inter 8345 fall 2 rise 1
-	server 127.0.5.095 127.0.5.95:80 weight 10 check inter 994 fall 2 rise 1
-	server 127.0.5.096 127.0.5.96:80 weight 10 check inter 5906 fall 2 rise 1
-	server 127.0.5.097 127.0.5.97:80 weight 10 check inter 9309 fall 2 rise 1
-	server 127.0.5.098 127.0.5.98:80 weight 10 check inter 2660 fall 2 rise 1
-	server 127.0.5.099 127.0.5.99:80 weight 10 check inter 413 fall 2 rise 1
-	server 127.0.5.100 127.0.5.100:80 weight 10 check inter 4613 fall 2 rise 1
-	server 127.0.5.101 127.0.5.101:80 weight 10 check inter 2589 fall 2 rise 1
-	server 127.0.5.102 127.0.5.102:80 weight 10 check inter 4491 fall 2 rise 1
-	server 127.0.5.103 127.0.5.103:80 weight 10 check inter 1696 fall 2 rise 1
-	server 127.0.5.104 127.0.5.104:80 weight 10 check inter 6865 fall 2 rise 1
-	server 127.0.5.105 127.0.5.105:80 weight 10 check inter 2399 fall 2 rise 1
-	server 127.0.5.106 127.0.5.106:80 weight 10 check inter 4628 fall 2 rise 1
-	server 127.0.5.107 127.0.5.107:80 weight 10 check inter 4638 fall 2 rise 1
-	server 127.0.5.108 127.0.5.108:80 weight 10 check inter 6410 fall 2 rise 1
-	server 127.0.5.109 127.0.5.109:80 weight 10 check inter 3067 fall 2 rise 1
-	server 127.0.5.110 127.0.5.110:80 weight 10 check inter 1143 fall 2 rise 1
-	server 127.0.5.111 127.0.5.111:80 weight 10 check inter 8847 fall 2 rise 1
-	server 127.0.5.112 127.0.5.112:80 weight 10 check inter 2203 fall 2 rise 1
-	server 127.0.5.113 127.0.5.113:80 weight 10 check inter 8988 fall 2 rise 1
-	server 127.0.5.114 127.0.5.114:80 weight 10 check inter 8 fall 2 rise 1
-	server 127.0.5.115 127.0.5.115:80 weight 10 check inter 828 fall 2 rise 1
-	server 127.0.5.116 127.0.5.116:80 weight 10 check inter 4286 fall 2 rise 1
-	server 127.0.5.117 127.0.5.117:80 weight 10 check inter 5195 fall 2 rise 1
-	server 127.0.5.118 127.0.5.118:80 weight 10 check inter 913 fall 2 rise 1
-	server 127.0.5.119 127.0.5.119:80 weight 10 check inter 6249 fall 2 rise 1
-	server 127.0.5.120 127.0.5.120:80 weight 10 check inter 3533 fall 2 rise 1
-	server 127.0.5.121 127.0.5.121:80 weight 10 check inter 8732 fall 2 rise 1
-	server 127.0.5.122 127.0.5.122:80 weight 10 check inter 1058 fall 2 rise 1
-	server 127.0.5.123 127.0.5.123:80 weight 10 check inter 3860 fall 2 rise 1
-	server 127.0.5.124 127.0.5.124:80 weight 10 check inter 8747 fall 2 rise 1
-	server 127.0.5.125 127.0.5.125:80 weight 10 check inter 6955 fall 2 rise 1
-	server 127.0.5.126 127.0.5.126:80 weight 10 check inter 8648 fall 2 rise 1
-	server 127.0.5.127 127.0.5.127:80 weight 10 check inter 6050 fall 2 rise 1
-	server 127.0.5.128 127.0.5.128:80 weight 10 check inter 9409 fall 2 rise 1
-	server 127.0.5.129 127.0.5.129:80 weight 10 check inter 6164 fall 2 rise 1
-	server 127.0.5.130 127.0.5.130:80 weight 10 check inter 8526 fall 2 rise 1
-	server 127.0.5.131 127.0.5.131:80 weight 10 check inter 2948 fall 2 rise 1
-	server 127.0.5.132 127.0.5.132:80 weight 10 check inter 7578 fall 2 rise 1
-	server 127.0.5.133 127.0.5.133:80 weight 10 check inter 8229 fall 2 rise 1
-	server 127.0.5.134 127.0.5.134:80 weight 10 check inter 2469 fall 2 rise 1
-	server 127.0.5.135 127.0.5.135:80 weight 10 check inter 2940 fall 2 rise 1
-	server 127.0.5.136 127.0.5.136:80 weight 10 check inter 4014 fall 2 rise 1
-	server 127.0.5.137 127.0.5.137:80 weight 10 check inter 3237 fall 2 rise 1
-	server 127.0.5.138 127.0.5.138:80 weight 10 check inter 8724 fall 2 rise 1
-	server 127.0.5.139 127.0.5.139:80 weight 10 check inter 3266 fall 2 rise 1
-	server 127.0.5.140 127.0.5.140:80 weight 10 check inter 6319 fall 2 rise 1
-	server 127.0.5.141 127.0.5.141:80 weight 10 check inter 1185 fall 2 rise 1
-	server 127.0.5.142 127.0.5.142:80 weight 10 check inter 9473 fall 2 rise 1
-	server 127.0.5.143 127.0.5.143:80 weight 10 check inter 5540 fall 2 rise 1
-	server 127.0.5.144 127.0.5.144:80 weight 10 check inter 7733 fall 2 rise 1
-	server 127.0.5.145 127.0.5.145:80 weight 10 check inter 7546 fall 2 rise 1
-	server 127.0.5.146 127.0.5.146:80 weight 10 check inter 9099 fall 2 rise 1
-	server 127.0.5.147 127.0.5.147:80 weight 10 check inter 1121 fall 2 rise 1
-	server 127.0.5.148 127.0.5.148:80 weight 10 check inter 2954 fall 2 rise 1
-	server 127.0.5.149 127.0.5.149:80 weight 10 check inter 176 fall 2 rise 1
-	server 127.0.5.150 127.0.5.150:80 weight 10 check inter 9645 fall 2 rise 1
-	server 127.0.5.151 127.0.5.151:80 weight 10 check inter 7941 fall 2 rise 1
-	server 127.0.5.152 127.0.5.152:80 weight 10 check inter 420 fall 2 rise 1
-	server 127.0.5.153 127.0.5.153:80 weight 10 check inter 6684 fall 2 rise 1
-	server 127.0.5.154 127.0.5.154:80 weight 10 check inter 8179 fall 2 rise 1
-	server 127.0.5.155 127.0.5.155:80 weight 10 check inter 162 fall 2 rise 1
-	server 127.0.5.156 127.0.5.156:80 weight 10 check inter 8502 fall 2 rise 1
-	server 127.0.5.157 127.0.5.157:80 weight 10 check inter 5008 fall 2 rise 1
-	server 127.0.5.158 127.0.5.158:80 weight 10 check inter 2297 fall 2 rise 1
-	server 127.0.5.159 127.0.5.159:80 weight 10 check inter 6290 fall 2 rise 1
-	server 127.0.5.160 127.0.5.160:80 weight 10 check inter 8245 fall 2 rise 1
-	server 127.0.5.161 127.0.5.161:80 weight 10 check inter 6576 fall 2 rise 1
-	server 127.0.5.162 127.0.5.162:80 weight 10 check inter 9113 fall 2 rise 1
-	server 127.0.5.163 127.0.5.163:80 weight 10 check inter 494 fall 2 rise 1
-	server 127.0.5.164 127.0.5.164:80 weight 10 check inter 9675 fall 2 rise 1
-	server 127.0.5.165 127.0.5.165:80 weight 10 check inter 3277 fall 2 rise 1
-	server 127.0.5.166 127.0.5.166:80 weight 10 check inter 2864 fall 2 rise 1
-	server 127.0.5.167 127.0.5.167:80 weight 10 check inter 8750 fall 2 rise 1
-	server 127.0.5.168 127.0.5.168:80 weight 10 check inter 2606 fall 2 rise 1
-	server 127.0.5.169 127.0.5.169:80 weight 10 check inter 6565 fall 2 rise 1
-	server 127.0.5.170 127.0.5.170:80 weight 10 check inter 2501 fall 2 rise 1
-	server 127.0.5.171 127.0.5.171:80 weight 10 check inter 3487 fall 2 rise 1
-	server 127.0.5.172 127.0.5.172:80 weight 10 check inter 5118 fall 2 rise 1
-	server 127.0.5.173 127.0.5.173:80 weight 10 check inter 9276 fall 2 rise 1
-	server 127.0.5.174 127.0.5.174:80 weight 10 check inter 2841 fall 2 rise 1
-	server 127.0.5.175 127.0.5.175:80 weight 10 check inter 54 fall 2 rise 1
-	server 127.0.5.176 127.0.5.176:80 weight 10 check inter 4944 fall 2 rise 1
-	server 127.0.5.177 127.0.5.177:80 weight 10 check inter 9560 fall 2 rise 1
-	server 127.0.5.178 127.0.5.178:80 weight 10 check inter 4508 fall 2 rise 1
-	server 127.0.5.179 127.0.5.179:80 weight 10 check inter 7606 fall 2 rise 1
-	server 127.0.5.180 127.0.5.180:80 weight 10 check inter 9869 fall 2 rise 1
-	server 127.0.5.181 127.0.5.181:80 weight 10 check inter 912 fall 2 rise 1
-	server 127.0.5.182 127.0.5.182:80 weight 10 check inter 3926 fall 2 rise 1
-	server 127.0.5.183 127.0.5.183:80 weight 10 check inter 2643 fall 2 rise 1
-	server 127.0.5.184 127.0.5.184:80 weight 10 check inter 6842 fall 2 rise 1
-	server 127.0.5.185 127.0.5.185:80 weight 10 check inter 5538 fall 2 rise 1
-	server 127.0.5.186 127.0.5.186:80 weight 10 check inter 8736 fall 2 rise 1
-	server 127.0.5.187 127.0.5.187:80 weight 10 check inter 5028 fall 2 rise 1
-	server 127.0.5.188 127.0.5.188:80 weight 10 check inter 2342 fall 2 rise 1
-	server 127.0.5.189 127.0.5.189:80 weight 10 check inter 4887 fall 2 rise 1
-	server 127.0.5.190 127.0.5.190:80 weight 10 check inter 4230 fall 2 rise 1
-	server 127.0.5.191 127.0.5.191:80 weight 10 check inter 6426 fall 2 rise 1
-	server 127.0.5.192 127.0.5.192:80 weight 10 check inter 37 fall 2 rise 1
-	server 127.0.5.193 127.0.5.193:80 weight 10 check inter 6887 fall 2 rise 1
-	server 127.0.5.194 127.0.5.194:80 weight 10 check inter 2302 fall 2 rise 1
-	server 127.0.5.195 127.0.5.195:80 weight 10 check inter 9908 fall 2 rise 1
-	server 127.0.5.196 127.0.5.196:80 weight 10 check inter 9967 fall 2 rise 1
-	server 127.0.5.197 127.0.5.197:80 weight 10 check inter 955 fall 2 rise 1
-	server 127.0.5.198 127.0.5.198:80 weight 10 check inter 8069 fall 2 rise 1
-	server 127.0.5.199 127.0.5.199:80 weight 10 check inter 4494 fall 2 rise 1
-	server 127.0.5.200 127.0.5.200:80 weight 10 check inter 5560 fall 2 rise 1
-	server 127.0.5.201 127.0.5.201:80 weight 10 check inter 2023 fall 2 rise 1
-	server 127.0.5.202 127.0.5.202:80 weight 10 check inter 2733 fall 2 rise 1
-	server 127.0.5.203 127.0.5.203:80 weight 10 check inter 1709 fall 2 rise 1
-	server 127.0.5.204 127.0.5.204:80 weight 10 check inter 1373 fall 2 rise 1
-	server 127.0.5.205 127.0.5.205:80 weight 10 check inter 611 fall 2 rise 1
-	server 127.0.5.206 127.0.5.206:80 weight 10 check inter 5672 fall 2 rise 1
-	server 127.0.5.207 127.0.5.207:80 weight 10 check inter 4059 fall 2 rise 1
-	server 127.0.5.208 127.0.5.208:80 weight 10 check inter 7699 fall 2 rise 1
-	server 127.0.5.209 127.0.5.209:80 weight 10 check inter 2542 fall 2 rise 1
-	server 127.0.5.210 127.0.5.210:80 weight 10 check inter 5411 fall 2 rise 1
-	server 127.0.5.211 127.0.5.211:80 weight 10 check inter 6979 fall 2 rise 1
-	server 127.0.5.212 127.0.5.212:80 weight 10 check inter 2144 fall 2 rise 1
-	server 127.0.5.213 127.0.5.213:80 weight 10 check inter 9762 fall 2 rise 1
-	server 127.0.5.214 127.0.5.214:80 weight 10 check inter 9252 fall 2 rise 1
-	server 127.0.5.215 127.0.5.215:80 weight 10 check inter 9067 fall 2 rise 1
-	server 127.0.5.216 127.0.5.216:80 weight 10 check inter 3878 fall 2 rise 1
-	server 127.0.5.217 127.0.5.217:80 weight 10 check inter 4182 fall 2 rise 1
-	server 127.0.5.218 127.0.5.218:80 weight 10 check inter 8882 fall 2 rise 1
-	server 127.0.5.219 127.0.5.219:80 weight 10 check inter 8948 fall 2 rise 1
-	server 127.0.5.220 127.0.5.220:80 weight 10 check inter 1571 fall 2 rise 1
-	server 127.0.5.221 127.0.5.221:80 weight 10 check inter 5381 fall 2 rise 1
-	server 127.0.5.222 127.0.5.222:80 weight 10 check inter 8358 fall 2 rise 1
-	server 127.0.5.223 127.0.5.223:80 weight 10 check inter 6787 fall 2 rise 1
-	server 127.0.5.224 127.0.5.224:80 weight 10 check inter 7658 fall 2 rise 1
-	server 127.0.5.225 127.0.5.225:80 weight 10 check inter 7473 fall 2 rise 1
-	server 127.0.5.226 127.0.5.226:80 weight 10 check inter 4101 fall 2 rise 1
-	server 127.0.5.227 127.0.5.227:80 weight 10 check inter 6653 fall 2 rise 1
-	server 127.0.5.228 127.0.5.228:80 weight 10 check inter 1919 fall 2 rise 1
-	server 127.0.5.229 127.0.5.229:80 weight 10 check inter 5528 fall 2 rise 1
-	server 127.0.5.230 127.0.5.230:80 weight 10 check inter 2218 fall 2 rise 1
-	server 127.0.5.231 127.0.5.231:80 weight 10 check inter 4996 fall 2 rise 1
-	server 127.0.5.232 127.0.5.232:80 weight 10 check inter 4884 fall 2 rise 1
-	server 127.0.5.233 127.0.5.233:80 weight 10 check inter 7746 fall 2 rise 1
-	server 127.0.5.234 127.0.5.234:80 weight 10 check inter 485 fall 2 rise 1
-	server 127.0.5.235 127.0.5.235:80 weight 10 check inter 9108 fall 2 rise 1
-	server 127.0.5.236 127.0.5.236:80 weight 10 check inter 822 fall 2 rise 1
-	server 127.0.5.237 127.0.5.237:80 weight 10 check inter 7808 fall 2 rise 1
-	server 127.0.5.238 127.0.5.238:80 weight 10 check inter 1366 fall 2 rise 1
-	server 127.0.5.239 127.0.5.239:80 weight 10 check inter 7613 fall 2 rise 1
-	server 127.0.5.240 127.0.5.240:80 weight 10 check inter 3415 fall 2 rise 1
-	server 127.0.5.241 127.0.5.241:80 weight 10 check inter 2500 fall 2 rise 1
-	server 127.0.5.242 127.0.5.242:80 weight 10 check inter 6344 fall 2 rise 1
-	server 127.0.5.243 127.0.5.243:80 weight 10 check inter 6238 fall 2 rise 1
-	server 127.0.5.244 127.0.5.244:80 weight 10 check inter 9594 fall 2 rise 1
-	server 127.0.5.245 127.0.5.245:80 weight 10 check inter 3967 fall 2 rise 1
-	server 127.0.5.246 127.0.5.246:80 weight 10 check inter 8398 fall 2 rise 1
-	server 127.0.5.247 127.0.5.247:80 weight 10 check inter 5381 fall 2 rise 1
-	server 127.0.5.248 127.0.5.248:80 weight 10 check inter 1697 fall 2 rise 1
-	server 127.0.5.249 127.0.5.249:80 weight 10 check inter 2767 fall 2 rise 1
-	server 127.0.5.250 127.0.5.250:80 weight 10 check inter 2895 fall 2 rise 1
-	server 127.0.6.001 127.0.6.1:80 weight 10 check inter 9321 fall 2 rise 1
-	server 127.0.6.002 127.0.6.2:80 weight 10 check inter 3590 fall 2 rise 1
-	server 127.0.6.003 127.0.6.3:80 weight 10 check inter 5701 fall 2 rise 1
-	server 127.0.6.004 127.0.6.4:80 weight 10 check inter 7568 fall 2 rise 1
-	server 127.0.6.005 127.0.6.5:80 weight 10 check inter 5460 fall 2 rise 1
-	server 127.0.6.006 127.0.6.6:80 weight 10 check inter 299 fall 2 rise 1
-	server 127.0.6.007 127.0.6.7:80 weight 10 check inter 4440 fall 2 rise 1
-	server 127.0.6.008 127.0.6.8:80 weight 10 check inter 4805 fall 2 rise 1
-	server 127.0.6.009 127.0.6.9:80 weight 10 check inter 2033 fall 2 rise 1
-	server 127.0.6.010 127.0.6.10:80 weight 10 check inter 6162 fall 2 rise 1
-	server 127.0.6.011 127.0.6.11:80 weight 10 check inter 7211 fall 2 rise 1
-	server 127.0.6.012 127.0.6.12:80 weight 10 check inter 2888 fall 2 rise 1
-	server 127.0.6.013 127.0.6.13:80 weight 10 check inter 4537 fall 2 rise 1
-	server 127.0.6.014 127.0.6.14:80 weight 10 check inter 6139 fall 2 rise 1
-	server 127.0.6.015 127.0.6.15:80 weight 10 check inter 5903 fall 2 rise 1
-	server 127.0.6.016 127.0.6.16:80 weight 10 check inter 7717 fall 2 rise 1
-	server 127.0.6.017 127.0.6.17:80 weight 10 check inter 5469 fall 2 rise 1
-	server 127.0.6.018 127.0.6.18:80 weight 10 check inter 6369 fall 2 rise 1
-	server 127.0.6.019 127.0.6.19:80 weight 10 check inter 1129 fall 2 rise 1
-	server 127.0.6.020 127.0.6.20:80 weight 10 check inter 2299 fall 2 rise 1
-	server 127.0.6.021 127.0.6.21:80 weight 10 check inter 2995 fall 2 rise 1
-	server 127.0.6.022 127.0.6.22:80 weight 10 check inter 7523 fall 2 rise 1
-	server 127.0.6.023 127.0.6.23:80 weight 10 check inter 5633 fall 2 rise 1
-	server 127.0.6.024 127.0.6.24:80 weight 10 check inter 4435 fall 2 rise 1
-	server 127.0.6.025 127.0.6.25:80 weight 10 check inter 9921 fall 2 rise 1
-	server 127.0.6.026 127.0.6.26:80 weight 10 check inter 6436 fall 2 rise 1
-	server 127.0.6.027 127.0.6.27:80 weight 10 check inter 1183 fall 2 rise 1
-	server 127.0.6.028 127.0.6.28:80 weight 10 check inter 2046 fall 2 rise 1
-	server 127.0.6.029 127.0.6.29:80 weight 10 check inter 1978 fall 2 rise 1
-	server 127.0.6.030 127.0.6.30:80 weight 10 check inter 2946 fall 2 rise 1
-	server 127.0.6.031 127.0.6.31:80 weight 10 check inter 2710 fall 2 rise 1
-	server 127.0.6.032 127.0.6.32:80 weight 10 check inter 416 fall 2 rise 1
-	server 127.0.6.033 127.0.6.33:80 weight 10 check inter 2779 fall 2 rise 1
-	server 127.0.6.034 127.0.6.34:80 weight 10 check inter 1270 fall 2 rise 1
-	server 127.0.6.035 127.0.6.35:80 weight 10 check inter 7165 fall 2 rise 1
-	server 127.0.6.036 127.0.6.36:80 weight 10 check inter 6494 fall 2 rise 1
-	server 127.0.6.037 127.0.6.37:80 weight 10 check inter 1685 fall 2 rise 1
-	server 127.0.6.038 127.0.6.38:80 weight 10 check inter 5168 fall 2 rise 1
-	server 127.0.6.039 127.0.6.39:80 weight 10 check inter 690 fall 2 rise 1
-	server 127.0.6.040 127.0.6.40:80 weight 10 check inter 8376 fall 2 rise 1
-	server 127.0.6.041 127.0.6.41:80 weight 10 check inter 2120 fall 2 rise 1
-	server 127.0.6.042 127.0.6.42:80 weight 10 check inter 7728 fall 2 rise 1
-	server 127.0.6.043 127.0.6.43:80 weight 10 check inter 5565 fall 2 rise 1
-	server 127.0.6.044 127.0.6.44:80 weight 10 check inter 4935 fall 2 rise 1
-	server 127.0.6.045 127.0.6.45:80 weight 10 check inter 1316 fall 2 rise 1
-	server 127.0.6.046 127.0.6.46:80 weight 10 check inter 132 fall 2 rise 1
-	server 127.0.6.047 127.0.6.47:80 weight 10 check inter 9926 fall 2 rise 1
-	server 127.0.6.048 127.0.6.48:80 weight 10 check inter 4517 fall 2 rise 1
-	server 127.0.6.049 127.0.6.49:80 weight 10 check inter 8111 fall 2 rise 1
-	server 127.0.6.050 127.0.6.50:80 weight 10 check inter 2549 fall 2 rise 1
-	server 127.0.6.051 127.0.6.51:80 weight 10 check inter 2950 fall 2 rise 1
-	server 127.0.6.052 127.0.6.52:80 weight 10 check inter 2591 fall 2 rise 1
-	server 127.0.6.053 127.0.6.53:80 weight 10 check inter 7477 fall 2 rise 1
-	server 127.0.6.054 127.0.6.54:80 weight 10 check inter 1776 fall 2 rise 1
-	server 127.0.6.055 127.0.6.55:80 weight 10 check inter 3246 fall 2 rise 1
-	server 127.0.6.056 127.0.6.56:80 weight 10 check inter 2172 fall 2 rise 1
-	server 127.0.6.057 127.0.6.57:80 weight 10 check inter 3938 fall 2 rise 1
-	server 127.0.6.058 127.0.6.58:80 weight 10 check inter 1285 fall 2 rise 1
-	server 127.0.6.059 127.0.6.59:80 weight 10 check inter 1178 fall 2 rise 1
-	server 127.0.6.060 127.0.6.60:80 weight 10 check inter 922 fall 2 rise 1
-	server 127.0.6.061 127.0.6.61:80 weight 10 check inter 401 fall 2 rise 1
-	server 127.0.6.062 127.0.6.62:80 weight 10 check inter 9361 fall 2 rise 1
-	server 127.0.6.063 127.0.6.63:80 weight 10 check inter 6690 fall 2 rise 1
-	server 127.0.6.064 127.0.6.64:80 weight 10 check inter 6445 fall 2 rise 1
-	server 127.0.6.065 127.0.6.65:80 weight 10 check inter 2867 fall 2 rise 1
-	server 127.0.6.066 127.0.6.66:80 weight 10 check inter 6348 fall 2 rise 1
-	server 127.0.6.067 127.0.6.67:80 weight 10 check inter 5974 fall 2 rise 1
-	server 127.0.6.068 127.0.6.68:80 weight 10 check inter 3206 fall 2 rise 1
-	server 127.0.6.069 127.0.6.69:80 weight 10 check inter 6926 fall 2 rise 1
-	server 127.0.6.070 127.0.6.70:80 weight 10 check inter 5794 fall 2 rise 1
-	server 127.0.6.071 127.0.6.71:80 weight 10 check inter 2087 fall 2 rise 1
-	server 127.0.6.072 127.0.6.72:80 weight 10 check inter 8597 fall 2 rise 1
-	server 127.0.6.073 127.0.6.73:80 weight 10 check inter 4362 fall 2 rise 1
-	server 127.0.6.074 127.0.6.74:80 weight 10 check inter 4354 fall 2 rise 1
-	server 127.0.6.075 127.0.6.75:80 weight 10 check inter 3334 fall 2 rise 1
-	server 127.0.6.076 127.0.6.76:80 weight 10 check inter 6655 fall 2 rise 1
-	server 127.0.6.077 127.0.6.77:80 weight 10 check inter 221 fall 2 rise 1
-	server 127.0.6.078 127.0.6.78:80 weight 10 check inter 8456 fall 2 rise 1
-	server 127.0.6.079 127.0.6.79:80 weight 10 check inter 3438 fall 2 rise 1
-	server 127.0.6.080 127.0.6.80:80 weight 10 check inter 5261 fall 2 rise 1
-	server 127.0.6.081 127.0.6.81:80 weight 10 check inter 194 fall 2 rise 1
-	server 127.0.6.082 127.0.6.82:80 weight 10 check inter 3835 fall 2 rise 1
-	server 127.0.6.083 127.0.6.83:80 weight 10 check inter 8832 fall 2 rise 1
-	server 127.0.6.084 127.0.6.84:80 weight 10 check inter 9802 fall 2 rise 1
-	server 127.0.6.085 127.0.6.85:80 weight 10 check inter 1179 fall 2 rise 1
-	server 127.0.6.086 127.0.6.86:80 weight 10 check inter 8709 fall 2 rise 1
-	server 127.0.6.087 127.0.6.87:80 weight 10 check inter 9602 fall 2 rise 1
-	server 127.0.6.088 127.0.6.88:80 weight 10 check inter 4635 fall 2 rise 1
-	server 127.0.6.089 127.0.6.89:80 weight 10 check inter 4507 fall 2 rise 1
-	server 127.0.6.090 127.0.6.90:80 weight 10 check inter 2694 fall 2 rise 1
-	server 127.0.6.091 127.0.6.91:80 weight 10 check inter 8599 fall 2 rise 1
-	server 127.0.6.092 127.0.6.92:80 weight 10 check inter 6428 fall 2 rise 1
-	server 127.0.6.093 127.0.6.93:80 weight 10 check inter 1650 fall 2 rise 1
-	server 127.0.6.094 127.0.6.94:80 weight 10 check inter 695 fall 2 rise 1
-	server 127.0.6.095 127.0.6.95:80 weight 10 check inter 3116 fall 2 rise 1
-	server 127.0.6.096 127.0.6.96:80 weight 10 check inter 270 fall 2 rise 1
-	server 127.0.6.097 127.0.6.97:80 weight 10 check inter 5127 fall 2 rise 1
-	server 127.0.6.098 127.0.6.98:80 weight 10 check inter 6031 fall 2 rise 1
-	server 127.0.6.099 127.0.6.99:80 weight 10 check inter 8744 fall 2 rise 1
-	server 127.0.6.100 127.0.6.100:80 weight 10 check inter 290 fall 2 rise 1
-	server 127.0.6.101 127.0.6.101:80 weight 10 check inter 6567 fall 2 rise 1
-	server 127.0.6.102 127.0.6.102:80 weight 10 check inter 3720 fall 2 rise 1
-	server 127.0.6.103 127.0.6.103:80 weight 10 check inter 4065 fall 2 rise 1
-	server 127.0.6.104 127.0.6.104:80 weight 10 check inter 1844 fall 2 rise 1
-	server 127.0.6.105 127.0.6.105:80 weight 10 check inter 976 fall 2 rise 1
-	server 127.0.6.106 127.0.6.106:80 weight 10 check inter 2639 fall 2 rise 1
-	server 127.0.6.107 127.0.6.107:80 weight 10 check inter 7070 fall 2 rise 1
-	server 127.0.6.108 127.0.6.108:80 weight 10 check inter 8088 fall 2 rise 1
-	server 127.0.6.109 127.0.6.109:80 weight 10 check inter 3900 fall 2 rise 1
-	server 127.0.6.110 127.0.6.110:80 weight 10 check inter 1790 fall 2 rise 1
-	server 127.0.6.111 127.0.6.111:80 weight 10 check inter 5168 fall 2 rise 1
-	server 127.0.6.112 127.0.6.112:80 weight 10 check inter 2453 fall 2 rise 1
-	server 127.0.6.113 127.0.6.113:80 weight 10 check inter 7950 fall 2 rise 1
-	server 127.0.6.114 127.0.6.114:80 weight 10 check inter 1865 fall 2 rise 1
-	server 127.0.6.115 127.0.6.115:80 weight 10 check inter 8143 fall 2 rise 1
-	server 127.0.6.116 127.0.6.116:80 weight 10 check inter 6004 fall 2 rise 1
-	server 127.0.6.117 127.0.6.117:80 weight 10 check inter 7517 fall 2 rise 1
-	server 127.0.6.118 127.0.6.118:80 weight 10 check inter 8875 fall 2 rise 1
-	server 127.0.6.119 127.0.6.119:80 weight 10 check inter 7462 fall 2 rise 1
-	server 127.0.6.120 127.0.6.120:80 weight 10 check inter 2263 fall 2 rise 1
-	server 127.0.6.121 127.0.6.121:80 weight 10 check inter 5380 fall 2 rise 1
-	server 127.0.6.122 127.0.6.122:80 weight 10 check inter 3614 fall 2 rise 1
-	server 127.0.6.123 127.0.6.123:80 weight 10 check inter 207 fall 2 rise 1
-	server 127.0.6.124 127.0.6.124:80 weight 10 check inter 4474 fall 2 rise 1
-	server 127.0.6.125 127.0.6.125:80 weight 10 check inter 6181 fall 2 rise 1
-	server 127.0.6.126 127.0.6.126:80 weight 10 check inter 252 fall 2 rise 1
-	server 127.0.6.127 127.0.6.127:80 weight 10 check inter 1660 fall 2 rise 1
-	server 127.0.6.128 127.0.6.128:80 weight 10 check inter 7611 fall 2 rise 1
-	server 127.0.6.129 127.0.6.129:80 weight 10 check inter 945 fall 2 rise 1
-	server 127.0.6.130 127.0.6.130:80 weight 10 check inter 9160 fall 2 rise 1
-	server 127.0.6.131 127.0.6.131:80 weight 10 check inter 8666 fall 2 rise 1
-	server 127.0.6.132 127.0.6.132:80 weight 10 check inter 6536 fall 2 rise 1
-	server 127.0.6.133 127.0.6.133:80 weight 10 check inter 8217 fall 2 rise 1
-	server 127.0.6.134 127.0.6.134:80 weight 10 check inter 1275 fall 2 rise 1
-	server 127.0.6.135 127.0.6.135:80 weight 10 check inter 2246 fall 2 rise 1
-	server 127.0.6.136 127.0.6.136:80 weight 10 check inter 2620 fall 2 rise 1
-	server 127.0.6.137 127.0.6.137:80 weight 10 check inter 5553 fall 2 rise 1
-	server 127.0.6.138 127.0.6.138:80 weight 10 check inter 1888 fall 2 rise 1
-	server 127.0.6.139 127.0.6.139:80 weight 10 check inter 9276 fall 2 rise 1
-	server 127.0.6.140 127.0.6.140:80 weight 10 check inter 8249 fall 2 rise 1
-	server 127.0.6.141 127.0.6.141:80 weight 10 check inter 617 fall 2 rise 1
-	server 127.0.6.142 127.0.6.142:80 weight 10 check inter 8831 fall 2 rise 1
-	server 127.0.6.143 127.0.6.143:80 weight 10 check inter 1268 fall 2 rise 1
-	server 127.0.6.144 127.0.6.144:80 weight 10 check inter 9493 fall 2 rise 1
-	server 127.0.6.145 127.0.6.145:80 weight 10 check inter 683 fall 2 rise 1
-	server 127.0.6.146 127.0.6.146:80 weight 10 check inter 2682 fall 2 rise 1
-	server 127.0.6.147 127.0.6.147:80 weight 10 check inter 3435 fall 2 rise 1
-	server 127.0.6.148 127.0.6.148:80 weight 10 check inter 9477 fall 2 rise 1
-	server 127.0.6.149 127.0.6.149:80 weight 10 check inter 8292 fall 2 rise 1
-	server 127.0.6.150 127.0.6.150:80 weight 10 check inter 9145 fall 2 rise 1
-	server 127.0.6.151 127.0.6.151:80 weight 10 check inter 850 fall 2 rise 1
-	server 127.0.6.152 127.0.6.152:80 weight 10 check inter 3626 fall 2 rise 1
-	server 127.0.6.153 127.0.6.153:80 weight 10 check inter 8915 fall 2 rise 1
-	server 127.0.6.154 127.0.6.154:80 weight 10 check inter 4165 fall 2 rise 1
-	server 127.0.6.155 127.0.6.155:80 weight 10 check inter 5945 fall 2 rise 1
-	server 127.0.6.156 127.0.6.156:80 weight 10 check inter 4413 fall 2 rise 1
-	server 127.0.6.157 127.0.6.157:80 weight 10 check inter 1139 fall 2 rise 1
-	server 127.0.6.158 127.0.6.158:80 weight 10 check inter 2119 fall 2 rise 1
-	server 127.0.6.159 127.0.6.159:80 weight 10 check inter 8794 fall 2 rise 1
-	server 127.0.6.160 127.0.6.160:80 weight 10 check inter 1243 fall 2 rise 1
-	server 127.0.6.161 127.0.6.161:80 weight 10 check inter 312 fall 2 rise 1
-	server 127.0.6.162 127.0.6.162:80 weight 10 check inter 6206 fall 2 rise 1
-	server 127.0.6.163 127.0.6.163:80 weight 10 check inter 9349 fall 2 rise 1
-	server 127.0.6.164 127.0.6.164:80 weight 10 check inter 2481 fall 2 rise 1
-	server 127.0.6.165 127.0.6.165:80 weight 10 check inter 3402 fall 2 rise 1
-	server 127.0.6.166 127.0.6.166:80 weight 10 check inter 4338 fall 2 rise 1
-	server 127.0.6.167 127.0.6.167:80 weight 10 check inter 6287 fall 2 rise 1
-	server 127.0.6.168 127.0.6.168:80 weight 10 check inter 5255 fall 2 rise 1
-	server 127.0.6.169 127.0.6.169:80 weight 10 check inter 6453 fall 2 rise 1
-	server 127.0.6.170 127.0.6.170:80 weight 10 check inter 5804 fall 2 rise 1
-	server 127.0.6.171 127.0.6.171:80 weight 10 check inter 1801 fall 2 rise 1
-	server 127.0.6.172 127.0.6.172:80 weight 10 check inter 5132 fall 2 rise 1
-	server 127.0.6.173 127.0.6.173:80 weight 10 check inter 3629 fall 2 rise 1
-	server 127.0.6.174 127.0.6.174:80 weight 10 check inter 6290 fall 2 rise 1
-	server 127.0.6.175 127.0.6.175:80 weight 10 check inter 7457 fall 2 rise 1
-	server 127.0.6.176 127.0.6.176:80 weight 10 check inter 1301 fall 2 rise 1
-	server 127.0.6.177 127.0.6.177:80 weight 10 check inter 770 fall 2 rise 1
-	server 127.0.6.178 127.0.6.178:80 weight 10 check inter 9492 fall 2 rise 1
-	server 127.0.6.179 127.0.6.179:80 weight 10 check inter 2139 fall 2 rise 1
-	server 127.0.6.180 127.0.6.180:80 weight 10 check inter 245 fall 2 rise 1
-	server 127.0.6.181 127.0.6.181:80 weight 10 check inter 4759 fall 2 rise 1
-	server 127.0.6.182 127.0.6.182:80 weight 10 check inter 4407 fall 2 rise 1
-	server 127.0.6.183 127.0.6.183:80 weight 10 check inter 590 fall 2 rise 1
-	server 127.0.6.184 127.0.6.184:80 weight 10 check inter 4346 fall 2 rise 1
-	server 127.0.6.185 127.0.6.185:80 weight 10 check inter 7777 fall 2 rise 1
-	server 127.0.6.186 127.0.6.186:80 weight 10 check inter 1636 fall 2 rise 1
-	server 127.0.6.187 127.0.6.187:80 weight 10 check inter 7871 fall 2 rise 1
-	server 127.0.6.188 127.0.6.188:80 weight 10 check inter 2877 fall 2 rise 1
-	server 127.0.6.189 127.0.6.189:80 weight 10 check inter 354 fall 2 rise 1
-	server 127.0.6.190 127.0.6.190:80 weight 10 check inter 1168 fall 2 rise 1
-	server 127.0.6.191 127.0.6.191:80 weight 10 check inter 3949 fall 2 rise 1
-	server 127.0.6.192 127.0.6.192:80 weight 10 check inter 6536 fall 2 rise 1
-	server 127.0.6.193 127.0.6.193:80 weight 10 check inter 2452 fall 2 rise 1
-	server 127.0.6.194 127.0.6.194:80 weight 10 check inter 3114 fall 2 rise 1
-	server 127.0.6.195 127.0.6.195:80 weight 10 check inter 2049 fall 2 rise 1
-	server 127.0.6.196 127.0.6.196:80 weight 10 check inter 7638 fall 2 rise 1
-	server 127.0.6.197 127.0.6.197:80 weight 10 check inter 3108 fall 2 rise 1
-	server 127.0.6.198 127.0.6.198:80 weight 10 check inter 2342 fall 2 rise 1
-	server 127.0.6.199 127.0.6.199:80 weight 10 check inter 9875 fall 2 rise 1
-	server 127.0.6.200 127.0.6.200:80 weight 10 check inter 4971 fall 2 rise 1
-	server 127.0.6.201 127.0.6.201:80 weight 10 check inter 7876 fall 2 rise 1
-	server 127.0.6.202 127.0.6.202:80 weight 10 check inter 2492 fall 2 rise 1
-	server 127.0.6.203 127.0.6.203:80 weight 10 check inter 4141 fall 2 rise 1
-	server 127.0.6.204 127.0.6.204:80 weight 10 check inter 168 fall 2 rise 1
-	server 127.0.6.205 127.0.6.205:80 weight 10 check inter 110 fall 2 rise 1
-	server 127.0.6.206 127.0.6.206:80 weight 10 check inter 4431 fall 2 rise 1
-	server 127.0.6.207 127.0.6.207:80 weight 10 check inter 5184 fall 2 rise 1
-	server 127.0.6.208 127.0.6.208:80 weight 10 check inter 3693 fall 2 rise 1
-	server 127.0.6.209 127.0.6.209:80 weight 10 check inter 889 fall 2 rise 1
-	server 127.0.6.210 127.0.6.210:80 weight 10 check inter 5439 fall 2 rise 1
-	server 127.0.6.211 127.0.6.211:80 weight 10 check inter 1032 fall 2 rise 1
-	server 127.0.6.212 127.0.6.212:80 weight 10 check inter 7307 fall 2 rise 1
-	server 127.0.6.213 127.0.6.213:80 weight 10 check inter 4862 fall 2 rise 1
-	server 127.0.6.214 127.0.6.214:80 weight 10 check inter 3102 fall 2 rise 1
-	server 127.0.6.215 127.0.6.215:80 weight 10 check inter 7697 fall 2 rise 1
-	server 127.0.6.216 127.0.6.216:80 weight 10 check inter 5409 fall 2 rise 1
-	server 127.0.6.217 127.0.6.217:80 weight 10 check inter 7703 fall 2 rise 1
-	server 127.0.6.218 127.0.6.218:80 weight 10 check inter 7714 fall 2 rise 1
-	server 127.0.6.219 127.0.6.219:80 weight 10 check inter 7383 fall 2 rise 1
-	server 127.0.6.220 127.0.6.220:80 weight 10 check inter 7171 fall 2 rise 1
-	server 127.0.6.221 127.0.6.221:80 weight 10 check inter 9884 fall 2 rise 1
-	server 127.0.6.222 127.0.6.222:80 weight 10 check inter 288 fall 2 rise 1
-	server 127.0.6.223 127.0.6.223:80 weight 10 check inter 590 fall 2 rise 1
-	server 127.0.6.224 127.0.6.224:80 weight 10 check inter 9753 fall 2 rise 1
-	server 127.0.6.225 127.0.6.225:80 weight 10 check inter 6269 fall 2 rise 1
-	server 127.0.6.226 127.0.6.226:80 weight 10 check inter 7458 fall 2 rise 1
-	server 127.0.6.227 127.0.6.227:80 weight 10 check inter 133 fall 2 rise 1
-	server 127.0.6.228 127.0.6.228:80 weight 10 check inter 2189 fall 2 rise 1
-	server 127.0.6.229 127.0.6.229:80 weight 10 check inter 7774 fall 2 rise 1
-	server 127.0.6.230 127.0.6.230:80 weight 10 check inter 9966 fall 2 rise 1
-	server 127.0.6.231 127.0.6.231:80 weight 10 check inter 5195 fall 2 rise 1
-	server 127.0.6.232 127.0.6.232:80 weight 10 check inter 1282 fall 2 rise 1
-	server 127.0.6.233 127.0.6.233:80 weight 10 check inter 2630 fall 2 rise 1
-	server 127.0.6.234 127.0.6.234:80 weight 10 check inter 7223 fall 2 rise 1
-	server 127.0.6.235 127.0.6.235:80 weight 10 check inter 7903 fall 2 rise 1
-	server 127.0.6.236 127.0.6.236:80 weight 10 check inter 4836 fall 2 rise 1
-	server 127.0.6.237 127.0.6.237:80 weight 10 check inter 2230 fall 2 rise 1
-	server 127.0.6.238 127.0.6.238:80 weight 10 check inter 9839 fall 2 rise 1
-	server 127.0.6.239 127.0.6.239:80 weight 10 check inter 4393 fall 2 rise 1
-	server 127.0.6.240 127.0.6.240:80 weight 10 check inter 612 fall 2 rise 1
-	server 127.0.6.241 127.0.6.241:80 weight 10 check inter 6794 fall 2 rise 1
-	server 127.0.6.242 127.0.6.242:80 weight 10 check inter 5299 fall 2 rise 1
-	server 127.0.6.243 127.0.6.243:80 weight 10 check inter 2842 fall 2 rise 1
-	server 127.0.6.244 127.0.6.244:80 weight 10 check inter 3105 fall 2 rise 1
-	server 127.0.6.245 127.0.6.245:80 weight 10 check inter 1537 fall 2 rise 1
-	server 127.0.6.246 127.0.6.246:80 weight 10 check inter 4453 fall 2 rise 1
-	server 127.0.6.247 127.0.6.247:80 weight 10 check inter 9988 fall 2 rise 1
-	server 127.0.6.248 127.0.6.248:80 weight 10 check inter 5925 fall 2 rise 1
-	server 127.0.6.249 127.0.6.249:80 weight 10 check inter 268 fall 2 rise 1
-	server 127.0.6.250 127.0.6.250:80 weight 10 check inter 1256 fall 2 rise 1
-	server 127.0.7.001 127.0.7.1:80 weight 10 check inter 9065 fall 2 rise 1
-	server 127.0.7.002 127.0.7.2:80 weight 10 check inter 9109 fall 2 rise 1
-	server 127.0.7.003 127.0.7.3:80 weight 10 check inter 6936 fall 2 rise 1
-	server 127.0.7.004 127.0.7.4:80 weight 10 check inter 4222 fall 2 rise 1
-	server 127.0.7.005 127.0.7.5:80 weight 10 check inter 7909 fall 2 rise 1
-	server 127.0.7.006 127.0.7.6:80 weight 10 check inter 4214 fall 2 rise 1
-	server 127.0.7.007 127.0.7.7:80 weight 10 check inter 9899 fall 2 rise 1
-	server 127.0.7.008 127.0.7.8:80 weight 10 check inter 6753 fall 2 rise 1
-	server 127.0.7.009 127.0.7.9:80 weight 10 check inter 4618 fall 2 rise 1
-	server 127.0.7.010 127.0.7.10:80 weight 10 check inter 9135 fall 2 rise 1
-	server 127.0.7.011 127.0.7.11:80 weight 10 check inter 1761 fall 2 rise 1
-	server 127.0.7.012 127.0.7.12:80 weight 10 check inter 8210 fall 2 rise 1
-	server 127.0.7.013 127.0.7.13:80 weight 10 check inter 159 fall 2 rise 1
-	server 127.0.7.014 127.0.7.14:80 weight 10 check inter 4594 fall 2 rise 1
-	server 127.0.7.015 127.0.7.15:80 weight 10 check inter 2756 fall 2 rise 1
-	server 127.0.7.016 127.0.7.16:80 weight 10 check inter 7973 fall 2 rise 1
-	server 127.0.7.017 127.0.7.17:80 weight 10 check inter 5112 fall 2 rise 1
-	server 127.0.7.018 127.0.7.18:80 weight 10 check inter 1290 fall 2 rise 1
-	server 127.0.7.019 127.0.7.19:80 weight 10 check inter 7772 fall 2 rise 1
-	server 127.0.7.020 127.0.7.20:80 weight 10 check inter 1578 fall 2 rise 1
-	server 127.0.7.021 127.0.7.21:80 weight 10 check inter 9060 fall 2 rise 1
-	server 127.0.7.022 127.0.7.22:80 weight 10 check inter 292 fall 2 rise 1
-	server 127.0.7.023 127.0.7.23:80 weight 10 check inter 76 fall 2 rise 1
-	server 127.0.7.024 127.0.7.24:80 weight 10 check inter 1018 fall 2 rise 1
-	server 127.0.7.025 127.0.7.25:80 weight 10 check inter 6873 fall 2 rise 1
-	server 127.0.7.026 127.0.7.26:80 weight 10 check inter 4589 fall 2 rise 1
-	server 127.0.7.027 127.0.7.27:80 weight 10 check inter 6104 fall 2 rise 1
-	server 127.0.7.028 127.0.7.28:80 weight 10 check inter 1237 fall 2 rise 1
-	server 127.0.7.029 127.0.7.29:80 weight 10 check inter 3775 fall 2 rise 1
-	server 127.0.7.030 127.0.7.30:80 weight 10 check inter 4832 fall 2 rise 1
-	server 127.0.7.031 127.0.7.31:80 weight 10 check inter 1816 fall 2 rise 1
-	server 127.0.7.032 127.0.7.32:80 weight 10 check inter 3821 fall 2 rise 1
-	server 127.0.7.033 127.0.7.33:80 weight 10 check inter 2383 fall 2 rise 1
-	server 127.0.7.034 127.0.7.34:80 weight 10 check inter 6716 fall 2 rise 1
-	server 127.0.7.035 127.0.7.35:80 weight 10 check inter 3710 fall 2 rise 1
-	server 127.0.7.036 127.0.7.36:80 weight 10 check inter 7426 fall 2 rise 1
-	server 127.0.7.037 127.0.7.37:80 weight 10 check inter 1897 fall 2 rise 1
-	server 127.0.7.038 127.0.7.38:80 weight 10 check inter 4134 fall 2 rise 1
-	server 127.0.7.039 127.0.7.39:80 weight 10 check inter 2855 fall 2 rise 1
-	server 127.0.7.040 127.0.7.40:80 weight 10 check inter 7373 fall 2 rise 1
-	server 127.0.7.041 127.0.7.41:80 weight 10 check inter 5864 fall 2 rise 1
-	server 127.0.7.042 127.0.7.42:80 weight 10 check inter 2148 fall 2 rise 1
-	server 127.0.7.043 127.0.7.43:80 weight 10 check inter 1651 fall 2 rise 1
-	server 127.0.7.044 127.0.7.44:80 weight 10 check inter 1627 fall 2 rise 1
-	server 127.0.7.045 127.0.7.45:80 weight 10 check inter 9479 fall 2 rise 1
-	server 127.0.7.046 127.0.7.46:80 weight 10 check inter 7909 fall 2 rise 1
-	server 127.0.7.047 127.0.7.47:80 weight 10 check inter 9972 fall 2 rise 1
-	server 127.0.7.048 127.0.7.48:80 weight 10 check inter 8815 fall 2 rise 1
-	server 127.0.7.049 127.0.7.49:80 weight 10 check inter 7136 fall 2 rise 1
-	server 127.0.7.050 127.0.7.50:80 weight 10 check inter 3425 fall 2 rise 1
-	server 127.0.7.051 127.0.7.51:80 weight 10 check inter 2281 fall 2 rise 1
-	server 127.0.7.052 127.0.7.52:80 weight 10 check inter 566 fall 2 rise 1
-	server 127.0.7.053 127.0.7.53:80 weight 10 check inter 1656 fall 2 rise 1
-	server 127.0.7.054 127.0.7.54:80 weight 10 check inter 1859 fall 2 rise 1
-	server 127.0.7.055 127.0.7.55:80 weight 10 check inter 2631 fall 2 rise 1
-	server 127.0.7.056 127.0.7.56:80 weight 10 check inter 7241 fall 2 rise 1
-	server 127.0.7.057 127.0.7.57:80 weight 10 check inter 76 fall 2 rise 1
-	server 127.0.7.058 127.0.7.58:80 weight 10 check inter 7689 fall 2 rise 1
-	server 127.0.7.059 127.0.7.59:80 weight 10 check inter 2108 fall 2 rise 1
-	server 127.0.7.060 127.0.7.60:80 weight 10 check inter 1477 fall 2 rise 1
-	server 127.0.7.061 127.0.7.61:80 weight 10 check inter 9401 fall 2 rise 1
-	server 127.0.7.062 127.0.7.62:80 weight 10 check inter 9192 fall 2 rise 1
-	server 127.0.7.063 127.0.7.63:80 weight 10 check inter 2835 fall 2 rise 1
-	server 127.0.7.064 127.0.7.64:80 weight 10 check inter 3066 fall 2 rise 1
-	server 127.0.7.065 127.0.7.65:80 weight 10 check inter 3375 fall 2 rise 1
-	server 127.0.7.066 127.0.7.66:80 weight 10 check inter 9760 fall 2 rise 1
-	server 127.0.7.067 127.0.7.67:80 weight 10 check inter 3559 fall 2 rise 1
-	server 127.0.7.068 127.0.7.68:80 weight 10 check inter 6213 fall 2 rise 1
-	server 127.0.7.069 127.0.7.69:80 weight 10 check inter 7043 fall 2 rise 1
-	server 127.0.7.070 127.0.7.70:80 weight 10 check inter 787 fall 2 rise 1
-	server 127.0.7.071 127.0.7.71:80 weight 10 check inter 2184 fall 2 rise 1
-	server 127.0.7.072 127.0.7.72:80 weight 10 check inter 3934 fall 2 rise 1
-	server 127.0.7.073 127.0.7.73:80 weight 10 check inter 4647 fall 2 rise 1
-	server 127.0.7.074 127.0.7.74:80 weight 10 check inter 1108 fall 2 rise 1
-	server 127.0.7.075 127.0.7.75:80 weight 10 check inter 7950 fall 2 rise 1
-	server 127.0.7.076 127.0.7.76:80 weight 10 check inter 17 fall 2 rise 1
-	server 127.0.7.077 127.0.7.77:80 weight 10 check inter 826 fall 2 rise 1
-	server 127.0.7.078 127.0.7.78:80 weight 10 check inter 9585 fall 2 rise 1
-	server 127.0.7.079 127.0.7.79:80 weight 10 check inter 5232 fall 2 rise 1
-	server 127.0.7.080 127.0.7.80:80 weight 10 check inter 9293 fall 2 rise 1
-	server 127.0.7.081 127.0.7.81:80 weight 10 check inter 8526 fall 2 rise 1
-	server 127.0.7.082 127.0.7.82:80 weight 10 check inter 1344 fall 2 rise 1
-	server 127.0.7.083 127.0.7.83:80 weight 10 check inter 5219 fall 2 rise 1
-	server 127.0.7.084 127.0.7.84:80 weight 10 check inter 206 fall 2 rise 1
-	server 127.0.7.085 127.0.7.85:80 weight 10 check inter 8686 fall 2 rise 1
-	server 127.0.7.086 127.0.7.86:80 weight 10 check inter 9803 fall 2 rise 1
-	server 127.0.7.087 127.0.7.87:80 weight 10 check inter 9428 fall 2 rise 1
-	server 127.0.7.088 127.0.7.88:80 weight 10 check inter 7482 fall 2 rise 1
-	server 127.0.7.089 127.0.7.89:80 weight 10 check inter 4284 fall 2 rise 1
-	server 127.0.7.090 127.0.7.90:80 weight 10 check inter 4539 fall 2 rise 1
-	server 127.0.7.091 127.0.7.91:80 weight 10 check inter 2548 fall 2 rise 1
-	server 127.0.7.092 127.0.7.92:80 weight 10 check inter 9518 fall 2 rise 1
-	server 127.0.7.093 127.0.7.93:80 weight 10 check inter 171 fall 2 rise 1
-	server 127.0.7.094 127.0.7.94:80 weight 10 check inter 5894 fall 2 rise 1
-	server 127.0.7.095 127.0.7.95:80 weight 10 check inter 8582 fall 2 rise 1
-	server 127.0.7.096 127.0.7.96:80 weight 10 check inter 2118 fall 2 rise 1
-	server 127.0.7.097 127.0.7.97:80 weight 10 check inter 4033 fall 2 rise 1
-	server 127.0.7.098 127.0.7.98:80 weight 10 check inter 1449 fall 2 rise 1
-	server 127.0.7.099 127.0.7.99:80 weight 10 check inter 2057 fall 2 rise 1
-	server 127.0.7.100 127.0.7.100:80 weight 10 check inter 2143 fall 2 rise 1
-	server 127.0.7.101 127.0.7.101:80 weight 10 check inter 3563 fall 2 rise 1
-	server 127.0.7.102 127.0.7.102:80 weight 10 check inter 3571 fall 2 rise 1
-	server 127.0.7.103 127.0.7.103:80 weight 10 check inter 8006 fall 2 rise 1
-	server 127.0.7.104 127.0.7.104:80 weight 10 check inter 7149 fall 2 rise 1
-	server 127.0.7.105 127.0.7.105:80 weight 10 check inter 9390 fall 2 rise 1
-	server 127.0.7.106 127.0.7.106:80 weight 10 check inter 3175 fall 2 rise 1
-	server 127.0.7.107 127.0.7.107:80 weight 10 check inter 617 fall 2 rise 1
-	server 127.0.7.108 127.0.7.108:80 weight 10 check inter 9499 fall 2 rise 1
-	server 127.0.7.109 127.0.7.109:80 weight 10 check inter 4209 fall 2 rise 1
-	server 127.0.7.110 127.0.7.110:80 weight 10 check inter 7807 fall 2 rise 1
-	server 127.0.7.111 127.0.7.111:80 weight 10 check inter 8095 fall 2 rise 1
-	server 127.0.7.112 127.0.7.112:80 weight 10 check inter 581 fall 2 rise 1
-	server 127.0.7.113 127.0.7.113:80 weight 10 check inter 411 fall 2 rise 1
-	server 127.0.7.114 127.0.7.114:80 weight 10 check inter 9664 fall 2 rise 1
-	server 127.0.7.115 127.0.7.115:80 weight 10 check inter 8276 fall 2 rise 1
-	server 127.0.7.116 127.0.7.116:80 weight 10 check inter 2983 fall 2 rise 1
-	server 127.0.7.117 127.0.7.117:80 weight 10 check inter 2382 fall 2 rise 1
-	server 127.0.7.118 127.0.7.118:80 weight 10 check inter 8434 fall 2 rise 1
-	server 127.0.7.119 127.0.7.119:80 weight 10 check inter 8505 fall 2 rise 1
-	server 127.0.7.120 127.0.7.120:80 weight 10 check inter 5188 fall 2 rise 1
-	server 127.0.7.121 127.0.7.121:80 weight 10 check inter 8976 fall 2 rise 1
-	server 127.0.7.122 127.0.7.122:80 weight 10 check inter 9021 fall 2 rise 1
-	server 127.0.7.123 127.0.7.123:80 weight 10 check inter 1576 fall 2 rise 1
-	server 127.0.7.124 127.0.7.124:80 weight 10 check inter 6023 fall 2 rise 1
-	server 127.0.7.125 127.0.7.125:80 weight 10 check inter 3421 fall 2 rise 1
-	server 127.0.7.126 127.0.7.126:80 weight 10 check inter 9954 fall 2 rise 1
-	server 127.0.7.127 127.0.7.127:80 weight 10 check inter 151 fall 2 rise 1
-	server 127.0.7.128 127.0.7.128:80 weight 10 check inter 5738 fall 2 rise 1
-	server 127.0.7.129 127.0.7.129:80 weight 10 check inter 8463 fall 2 rise 1
-	server 127.0.7.130 127.0.7.130:80 weight 10 check inter 2270 fall 2 rise 1
-	server 127.0.7.131 127.0.7.131:80 weight 10 check inter 4238 fall 2 rise 1
-	server 127.0.7.132 127.0.7.132:80 weight 10 check inter 7559 fall 2 rise 1
-	server 127.0.7.133 127.0.7.133:80 weight 10 check inter 5704 fall 2 rise 1
-	server 127.0.7.134 127.0.7.134:80 weight 10 check inter 7248 fall 2 rise 1
-	server 127.0.7.135 127.0.7.135:80 weight 10 check inter 9049 fall 2 rise 1
-	server 127.0.7.136 127.0.7.136:80 weight 10 check inter 7665 fall 2 rise 1
-	server 127.0.7.137 127.0.7.137:80 weight 10 check inter 5093 fall 2 rise 1
-	server 127.0.7.138 127.0.7.138:80 weight 10 check inter 8948 fall 2 rise 1
-	server 127.0.7.139 127.0.7.139:80 weight 10 check inter 6300 fall 2 rise 1
-	server 127.0.7.140 127.0.7.140:80 weight 10 check inter 4209 fall 2 rise 1
-	server 127.0.7.141 127.0.7.141:80 weight 10 check inter 4291 fall 2 rise 1
-	server 127.0.7.142 127.0.7.142:80 weight 10 check inter 8887 fall 2 rise 1
-	server 127.0.7.143 127.0.7.143:80 weight 10 check inter 8426 fall 2 rise 1
-	server 127.0.7.144 127.0.7.144:80 weight 10 check inter 3794 fall 2 rise 1
-	server 127.0.7.145 127.0.7.145:80 weight 10 check inter 7103 fall 2 rise 1
-	server 127.0.7.146 127.0.7.146:80 weight 10 check inter 9210 fall 2 rise 1
-	server 127.0.7.147 127.0.7.147:80 weight 10 check inter 4291 fall 2 rise 1
-	server 127.0.7.148 127.0.7.148:80 weight 10 check inter 6635 fall 2 rise 1
-	server 127.0.7.149 127.0.7.149:80 weight 10 check inter 3471 fall 2 rise 1
-	server 127.0.7.150 127.0.7.150:80 weight 10 check inter 4658 fall 2 rise 1
-	server 127.0.7.151 127.0.7.151:80 weight 10 check inter 3744 fall 2 rise 1
-	server 127.0.7.152 127.0.7.152:80 weight 10 check inter 976 fall 2 rise 1
-	server 127.0.7.153 127.0.7.153:80 weight 10 check inter 5745 fall 2 rise 1
-	server 127.0.7.154 127.0.7.154:80 weight 10 check inter 1221 fall 2 rise 1
-	server 127.0.7.155 127.0.7.155:80 weight 10 check inter 3872 fall 2 rise 1
-	server 127.0.7.156 127.0.7.156:80 weight 10 check inter 1368 fall 2 rise 1
-	server 127.0.7.157 127.0.7.157:80 weight 10 check inter 519 fall 2 rise 1
-	server 127.0.7.158 127.0.7.158:80 weight 10 check inter 6212 fall 2 rise 1
-	server 127.0.7.159 127.0.7.159:80 weight 10 check inter 6176 fall 2 rise 1
-	server 127.0.7.160 127.0.7.160:80 weight 10 check inter 3085 fall 2 rise 1
-	server 127.0.7.161 127.0.7.161:80 weight 10 check inter 111 fall 2 rise 1
-	server 127.0.7.162 127.0.7.162:80 weight 10 check inter 6153 fall 2 rise 1
-	server 127.0.7.163 127.0.7.163:80 weight 10 check inter 3517 fall 2 rise 1
-	server 127.0.7.164 127.0.7.164:80 weight 10 check inter 1125 fall 2 rise 1
-	server 127.0.7.165 127.0.7.165:80 weight 10 check inter 1748 fall 2 rise 1
-	server 127.0.7.166 127.0.7.166:80 weight 10 check inter 6400 fall 2 rise 1
-	server 127.0.7.167 127.0.7.167:80 weight 10 check inter 8809 fall 2 rise 1
-	server 127.0.7.168 127.0.7.168:80 weight 10 check inter 8834 fall 2 rise 1
-	server 127.0.7.169 127.0.7.169:80 weight 10 check inter 2710 fall 2 rise 1
-	server 127.0.7.170 127.0.7.170:80 weight 10 check inter 773 fall 2 rise 1
-	server 127.0.7.171 127.0.7.171:80 weight 10 check inter 3871 fall 2 rise 1
-	server 127.0.7.172 127.0.7.172:80 weight 10 check inter 7372 fall 2 rise 1
-	server 127.0.7.173 127.0.7.173:80 weight 10 check inter 842 fall 2 rise 1
-	server 127.0.7.174 127.0.7.174:80 weight 10 check inter 1729 fall 2 rise 1
-	server 127.0.7.175 127.0.7.175:80 weight 10 check inter 4695 fall 2 rise 1
-	server 127.0.7.176 127.0.7.176:80 weight 10 check inter 4441 fall 2 rise 1
-	server 127.0.7.177 127.0.7.177:80 weight 10 check inter 9489 fall 2 rise 1
-	server 127.0.7.178 127.0.7.178:80 weight 10 check inter 7012 fall 2 rise 1
-	server 127.0.7.179 127.0.7.179:80 weight 10 check inter 5560 fall 2 rise 1
-	server 127.0.7.180 127.0.7.180:80 weight 10 check inter 2450 fall 2 rise 1
-	server 127.0.7.181 127.0.7.181:80 weight 10 check inter 2250 fall 2 rise 1
-	server 127.0.7.182 127.0.7.182:80 weight 10 check inter 3505 fall 2 rise 1
-	server 127.0.7.183 127.0.7.183:80 weight 10 check inter 3792 fall 2 rise 1
-	server 127.0.7.184 127.0.7.184:80 weight 10 check inter 9862 fall 2 rise 1
-	server 127.0.7.185 127.0.7.185:80 weight 10 check inter 3831 fall 2 rise 1
-	server 127.0.7.186 127.0.7.186:80 weight 10 check inter 5740 fall 2 rise 1
-	server 127.0.7.187 127.0.7.187:80 weight 10 check inter 6964 fall 2 rise 1
-	server 127.0.7.188 127.0.7.188:80 weight 10 check inter 554 fall 2 rise 1
-	server 127.0.7.189 127.0.7.189:80 weight 10 check inter 8560 fall 2 rise 1
-	server 127.0.7.190 127.0.7.190:80 weight 10 check inter 4868 fall 2 rise 1
-	server 127.0.7.191 127.0.7.191:80 weight 10 check inter 6664 fall 2 rise 1
-	server 127.0.7.192 127.0.7.192:80 weight 10 check inter 8791 fall 2 rise 1
-	server 127.0.7.193 127.0.7.193:80 weight 10 check inter 8378 fall 2 rise 1
-	server 127.0.7.194 127.0.7.194:80 weight 10 check inter 8769 fall 2 rise 1
-	server 127.0.7.195 127.0.7.195:80 weight 10 check inter 3838 fall 2 rise 1
-	server 127.0.7.196 127.0.7.196:80 weight 10 check inter 9522 fall 2 rise 1
-	server 127.0.7.197 127.0.7.197:80 weight 10 check inter 164 fall 2 rise 1
-	server 127.0.7.198 127.0.7.198:80 weight 10 check inter 972 fall 2 rise 1
-	server 127.0.7.199 127.0.7.199:80 weight 10 check inter 9391 fall 2 rise 1
-	server 127.0.7.200 127.0.7.200:80 weight 10 check inter 105 fall 2 rise 1
-	server 127.0.7.201 127.0.7.201:80 weight 10 check inter 2535 fall 2 rise 1
-	server 127.0.7.202 127.0.7.202:80 weight 10 check inter 7201 fall 2 rise 1
-	server 127.0.7.203 127.0.7.203:80 weight 10 check inter 3354 fall 2 rise 1
-	server 127.0.7.204 127.0.7.204:80 weight 10 check inter 4691 fall 2 rise 1
-	server 127.0.7.205 127.0.7.205:80 weight 10 check inter 1052 fall 2 rise 1
-	server 127.0.7.206 127.0.7.206:80 weight 10 check inter 7829 fall 2 rise 1
-	server 127.0.7.207 127.0.7.207:80 weight 10 check inter 144 fall 2 rise 1
-	server 127.0.7.208 127.0.7.208:80 weight 10 check inter 2436 fall 2 rise 1
-	server 127.0.7.209 127.0.7.209:80 weight 10 check inter 4410 fall 2 rise 1
-	server 127.0.7.210 127.0.7.210:80 weight 10 check inter 4615 fall 2 rise 1
-	server 127.0.7.211 127.0.7.211:80 weight 10 check inter 9371 fall 2 rise 1
-	server 127.0.7.212 127.0.7.212:80 weight 10 check inter 8035 fall 2 rise 1
-	server 127.0.7.213 127.0.7.213:80 weight 10 check inter 9206 fall 2 rise 1
-	server 127.0.7.214 127.0.7.214:80 weight 10 check inter 5368 fall 2 rise 1
-	server 127.0.7.215 127.0.7.215:80 weight 10 check inter 1441 fall 2 rise 1
-	server 127.0.7.216 127.0.7.216:80 weight 10 check inter 6796 fall 2 rise 1
-	server 127.0.7.217 127.0.7.217:80 weight 10 check inter 7354 fall 2 rise 1
-	server 127.0.7.218 127.0.7.218:80 weight 10 check inter 7850 fall 2 rise 1
-	server 127.0.7.219 127.0.7.219:80 weight 10 check inter 6141 fall 2 rise 1
-	server 127.0.7.220 127.0.7.220:80 weight 10 check inter 1060 fall 2 rise 1
-	server 127.0.7.221 127.0.7.221:80 weight 10 check inter 3137 fall 2 rise 1
-	server 127.0.7.222 127.0.7.222:80 weight 10 check inter 4250 fall 2 rise 1
-	server 127.0.7.223 127.0.7.223:80 weight 10 check inter 9160 fall 2 rise 1
-	server 127.0.7.224 127.0.7.224:80 weight 10 check inter 6353 fall 2 rise 1
-	server 127.0.7.225 127.0.7.225:80 weight 10 check inter 6471 fall 2 rise 1
-	server 127.0.7.226 127.0.7.226:80 weight 10 check inter 9230 fall 2 rise 1
-	server 127.0.7.227 127.0.7.227:80 weight 10 check inter 7529 fall 2 rise 1
-	server 127.0.7.228 127.0.7.228:80 weight 10 check inter 213 fall 2 rise 1
-	server 127.0.7.229 127.0.7.229:80 weight 10 check inter 1763 fall 2 rise 1
-	server 127.0.7.230 127.0.7.230:80 weight 10 check inter 6268 fall 2 rise 1
-	server 127.0.7.231 127.0.7.231:80 weight 10 check inter 5970 fall 2 rise 1
-	server 127.0.7.232 127.0.7.232:80 weight 10 check inter 3630 fall 2 rise 1
-	server 127.0.7.233 127.0.7.233:80 weight 10 check inter 9745 fall 2 rise 1
-	server 127.0.7.234 127.0.7.234:80 weight 10 check inter 1296 fall 2 rise 1
-	server 127.0.7.235 127.0.7.235:80 weight 10 check inter 9766 fall 2 rise 1
-	server 127.0.7.236 127.0.7.236:80 weight 10 check inter 5422 fall 2 rise 1
-	server 127.0.7.237 127.0.7.237:80 weight 10 check inter 4449 fall 2 rise 1
-	server 127.0.7.238 127.0.7.238:80 weight 10 check inter 6811 fall 2 rise 1
-	server 127.0.7.239 127.0.7.239:80 weight 10 check inter 9387 fall 2 rise 1
-	server 127.0.7.240 127.0.7.240:80 weight 10 check inter 395 fall 2 rise 1
-	server 127.0.7.241 127.0.7.241:80 weight 10 check inter 2514 fall 2 rise 1
-	server 127.0.7.242 127.0.7.242:80 weight 10 check inter 9771 fall 2 rise 1
-	server 127.0.7.243 127.0.7.243:80 weight 10 check inter 8628 fall 2 rise 1
-	server 127.0.7.244 127.0.7.244:80 weight 10 check inter 3478 fall 2 rise 1
-	server 127.0.7.245 127.0.7.245:80 weight 10 check inter 8861 fall 2 rise 1
-	server 127.0.7.246 127.0.7.246:80 weight 10 check inter 7695 fall 2 rise 1
-	server 127.0.7.247 127.0.7.247:80 weight 10 check inter 1484 fall 2 rise 1
-	server 127.0.7.248 127.0.7.248:80 weight 10 check inter 8364 fall 2 rise 1
-	server 127.0.7.249 127.0.7.249:80 weight 10 check inter 5313 fall 2 rise 1
-	server 127.0.7.250 127.0.7.250:80 weight 10 check inter 7335 fall 2 rise 1
-	server 127.0.8.001 127.0.8.1:80 weight 10 check inter 609 fall 2 rise 1
-	server 127.0.8.002 127.0.8.2:80 weight 10 check inter 3919 fall 2 rise 1
-	server 127.0.8.003 127.0.8.3:80 weight 10 check inter 3873 fall 2 rise 1
-	server 127.0.8.004 127.0.8.4:80 weight 10 check inter 9742 fall 2 rise 1
-	server 127.0.8.005 127.0.8.5:80 weight 10 check inter 4278 fall 2 rise 1
-	server 127.0.8.006 127.0.8.6:80 weight 10 check inter 6434 fall 2 rise 1
-	server 127.0.8.007 127.0.8.7:80 weight 10 check inter 3551 fall 2 rise 1
-	server 127.0.8.008 127.0.8.8:80 weight 10 check inter 3927 fall 2 rise 1
-	server 127.0.8.009 127.0.8.9:80 weight 10 check inter 9143 fall 2 rise 1
-	server 127.0.8.010 127.0.8.10:80 weight 10 check inter 9750 fall 2 rise 1
-	server 127.0.8.011 127.0.8.11:80 weight 10 check inter 7543 fall 2 rise 1
-	server 127.0.8.012 127.0.8.12:80 weight 10 check inter 2953 fall 2 rise 1
-	server 127.0.8.013 127.0.8.13:80 weight 10 check inter 1258 fall 2 rise 1
-	server 127.0.8.014 127.0.8.14:80 weight 10 check inter 8728 fall 2 rise 1
-	server 127.0.8.015 127.0.8.15:80 weight 10 check inter 4396 fall 2 rise 1
-	server 127.0.8.016 127.0.8.16:80 weight 10 check inter 6793 fall 2 rise 1
-	server 127.0.8.017 127.0.8.17:80 weight 10 check inter 9274 fall 2 rise 1
-	server 127.0.8.018 127.0.8.18:80 weight 10 check inter 7910 fall 2 rise 1
-	server 127.0.8.019 127.0.8.19:80 weight 10 check inter 755 fall 2 rise 1
-	server 127.0.8.020 127.0.8.20:80 weight 10 check inter 891 fall 2 rise 1
-	server 127.0.8.021 127.0.8.21:80 weight 10 check inter 1810 fall 2 rise 1
-	server 127.0.8.022 127.0.8.22:80 weight 10 check inter 2565 fall 2 rise 1
-	server 127.0.8.023 127.0.8.23:80 weight 10 check inter 401 fall 2 rise 1
-	server 127.0.8.024 127.0.8.24:80 weight 10 check inter 9208 fall 2 rise 1
-	server 127.0.8.025 127.0.8.25:80 weight 10 check inter 3996 fall 2 rise 1
-	server 127.0.8.026 127.0.8.26:80 weight 10 check inter 724 fall 2 rise 1
-	server 127.0.8.027 127.0.8.27:80 weight 10 check inter 9765 fall 2 rise 1
-	server 127.0.8.028 127.0.8.28:80 weight 10 check inter 1599 fall 2 rise 1
-	server 127.0.8.029 127.0.8.29:80 weight 10 check inter 7319 fall 2 rise 1
-	server 127.0.8.030 127.0.8.30:80 weight 10 check inter 1086 fall 2 rise 1
-	server 127.0.8.031 127.0.8.31:80 weight 10 check inter 1589 fall 2 rise 1
-	server 127.0.8.032 127.0.8.32:80 weight 10 check inter 2955 fall 2 rise 1
-	server 127.0.8.033 127.0.8.33:80 weight 10 check inter 9034 fall 2 rise 1
-	server 127.0.8.034 127.0.8.34:80 weight 10 check inter 946 fall 2 rise 1
-	server 127.0.8.035 127.0.8.35:80 weight 10 check inter 4425 fall 2 rise 1
-	server 127.0.8.036 127.0.8.36:80 weight 10 check inter 7624 fall 2 rise 1
-	server 127.0.8.037 127.0.8.37:80 weight 10 check inter 8476 fall 2 rise 1
-	server 127.0.8.038 127.0.8.38:80 weight 10 check inter 2403 fall 2 rise 1
-	server 127.0.8.039 127.0.8.39:80 weight 10 check inter 5354 fall 2 rise 1
-	server 127.0.8.040 127.0.8.40:80 weight 10 check inter 2694 fall 2 rise 1
-	server 127.0.8.041 127.0.8.41:80 weight 10 check inter 7150 fall 2 rise 1
-	server 127.0.8.042 127.0.8.42:80 weight 10 check inter 7167 fall 2 rise 1
-	server 127.0.8.043 127.0.8.43:80 weight 10 check inter 5305 fall 2 rise 1
-	server 127.0.8.044 127.0.8.44:80 weight 10 check inter 4281 fall 2 rise 1
-	server 127.0.8.045 127.0.8.45:80 weight 10 check inter 3807 fall 2 rise 1
-	server 127.0.8.046 127.0.8.46:80 weight 10 check inter 6351 fall 2 rise 1
-	server 127.0.8.047 127.0.8.47:80 weight 10 check inter 6959 fall 2 rise 1
-	server 127.0.8.048 127.0.8.48:80 weight 10 check inter 4710 fall 2 rise 1
-	server 127.0.8.049 127.0.8.49:80 weight 10 check inter 7502 fall 2 rise 1
-	server 127.0.8.050 127.0.8.50:80 weight 10 check inter 211 fall 2 rise 1
-	server 127.0.8.051 127.0.8.51:80 weight 10 check inter 6488 fall 2 rise 1
-	server 127.0.8.052 127.0.8.52:80 weight 10 check inter 9341 fall 2 rise 1
-	server 127.0.8.053 127.0.8.53:80 weight 10 check inter 2637 fall 2 rise 1
-	server 127.0.8.054 127.0.8.54:80 weight 10 check inter 7594 fall 2 rise 1
-	server 127.0.8.055 127.0.8.55:80 weight 10 check inter 4014 fall 2 rise 1
-	server 127.0.8.056 127.0.8.56:80 weight 10 check inter 8630 fall 2 rise 1
-	server 127.0.8.057 127.0.8.57:80 weight 10 check inter 58 fall 2 rise 1
-	server 127.0.8.058 127.0.8.58:80 weight 10 check inter 1428 fall 2 rise 1
-	server 127.0.8.059 127.0.8.59:80 weight 10 check inter 3430 fall 2 rise 1
-	server 127.0.8.060 127.0.8.60:80 weight 10 check inter 2478 fall 2 rise 1
-	server 127.0.8.061 127.0.8.61:80 weight 10 check inter 5420 fall 2 rise 1
-	server 127.0.8.062 127.0.8.62:80 weight 10 check inter 8649 fall 2 rise 1
-	server 127.0.8.063 127.0.8.63:80 weight 10 check inter 4941 fall 2 rise 1
-	server 127.0.8.064 127.0.8.64:80 weight 10 check inter 5214 fall 2 rise 1
-	server 127.0.8.065 127.0.8.65:80 weight 10 check inter 6767 fall 2 rise 1
-	server 127.0.8.066 127.0.8.66:80 weight 10 check inter 3046 fall 2 rise 1
-	server 127.0.8.067 127.0.8.67:80 weight 10 check inter 8641 fall 2 rise 1
-	server 127.0.8.068 127.0.8.68:80 weight 10 check inter 4000 fall 2 rise 1
-	server 127.0.8.069 127.0.8.69:80 weight 10 check inter 5744 fall 2 rise 1
-	server 127.0.8.070 127.0.8.70:80 weight 10 check inter 3723 fall 2 rise 1
-	server 127.0.8.071 127.0.8.71:80 weight 10 check inter 8031 fall 2 rise 1
-	server 127.0.8.072 127.0.8.72:80 weight 10 check inter 7105 fall 2 rise 1
-	server 127.0.8.073 127.0.8.73:80 weight 10 check inter 2248 fall 2 rise 1
-	server 127.0.8.074 127.0.8.74:80 weight 10 check inter 5045 fall 2 rise 1
-	server 127.0.8.075 127.0.8.75:80 weight 10 check inter 8576 fall 2 rise 1
-	server 127.0.8.076 127.0.8.76:80 weight 10 check inter 6101 fall 2 rise 1
-	server 127.0.8.077 127.0.8.77:80 weight 10 check inter 5241 fall 2 rise 1
-	server 127.0.8.078 127.0.8.78:80 weight 10 check inter 2924 fall 2 rise 1
-	server 127.0.8.079 127.0.8.79:80 weight 10 check inter 19 fall 2 rise 1
-	server 127.0.8.080 127.0.8.80:80 weight 10 check inter 2269 fall 2 rise 1
-	server 127.0.8.081 127.0.8.81:80 weight 10 check inter 2298 fall 2 rise 1
-	server 127.0.8.082 127.0.8.82:80 weight 10 check inter 2235 fall 2 rise 1
-	server 127.0.8.083 127.0.8.83:80 weight 10 check inter 3896 fall 2 rise 1
-	server 127.0.8.084 127.0.8.84:80 weight 10 check inter 7865 fall 2 rise 1
-	server 127.0.8.085 127.0.8.85:80 weight 10 check inter 162 fall 2 rise 1
-	server 127.0.8.086 127.0.8.86:80 weight 10 check inter 9603 fall 2 rise 1
-	server 127.0.8.087 127.0.8.87:80 weight 10 check inter 6946 fall 2 rise 1
-	server 127.0.8.088 127.0.8.88:80 weight 10 check inter 2717 fall 2 rise 1
-	server 127.0.8.089 127.0.8.89:80 weight 10 check inter 854 fall 2 rise 1
-	server 127.0.8.090 127.0.8.90:80 weight 10 check inter 1871 fall 2 rise 1
-	server 127.0.8.091 127.0.8.91:80 weight 10 check inter 938 fall 2 rise 1
-	server 127.0.8.092 127.0.8.92:80 weight 10 check inter 6629 fall 2 rise 1
-	server 127.0.8.093 127.0.8.93:80 weight 10 check inter 2562 fall 2 rise 1
-	server 127.0.8.094 127.0.8.94:80 weight 10 check inter 9142 fall 2 rise 1
-	server 127.0.8.095 127.0.8.95:80 weight 10 check inter 1779 fall 2 rise 1
-	server 127.0.8.096 127.0.8.96:80 weight 10 check inter 5288 fall 2 rise 1
-	server 127.0.8.097 127.0.8.97:80 weight 10 check inter 8617 fall 2 rise 1
-	server 127.0.8.098 127.0.8.98:80 weight 10 check inter 834 fall 2 rise 1
-	server 127.0.8.099 127.0.8.99:80 weight 10 check inter 9937 fall 2 rise 1
-	server 127.0.8.100 127.0.8.100:80 weight 10 check inter 334 fall 2 rise 1
-	server 127.0.8.101 127.0.8.101:80 weight 10 check inter 5916 fall 2 rise 1
-	server 127.0.8.102 127.0.8.102:80 weight 10 check inter 5330 fall 2 rise 1
-	server 127.0.8.103 127.0.8.103:80 weight 10 check inter 9848 fall 2 rise 1
-	server 127.0.8.104 127.0.8.104:80 weight 10 check inter 4945 fall 2 rise 1
-	server 127.0.8.105 127.0.8.105:80 weight 10 check inter 4588 fall 2 rise 1
-	server 127.0.8.106 127.0.8.106:80 weight 10 check inter 2290 fall 2 rise 1
-	server 127.0.8.107 127.0.8.107:80 weight 10 check inter 4918 fall 2 rise 1
-	server 127.0.8.108 127.0.8.108:80 weight 10 check inter 6853 fall 2 rise 1
-	server 127.0.8.109 127.0.8.109:80 weight 10 check inter 3025 fall 2 rise 1
-	server 127.0.8.110 127.0.8.110:80 weight 10 check inter 966 fall 2 rise 1
-	server 127.0.8.111 127.0.8.111:80 weight 10 check inter 5503 fall 2 rise 1
-	server 127.0.8.112 127.0.8.112:80 weight 10 check inter 135 fall 2 rise 1
-	server 127.0.8.113 127.0.8.113:80 weight 10 check inter 2662 fall 2 rise 1
-	server 127.0.8.114 127.0.8.114:80 weight 10 check inter 6377 fall 2 rise 1
-	server 127.0.8.115 127.0.8.115:80 weight 10 check inter 2029 fall 2 rise 1
-	server 127.0.8.116 127.0.8.116:80 weight 10 check inter 6454 fall 2 rise 1
-	server 127.0.8.117 127.0.8.117:80 weight 10 check inter 8522 fall 2 rise 1
-	server 127.0.8.118 127.0.8.118:80 weight 10 check inter 1576 fall 2 rise 1
-	server 127.0.8.119 127.0.8.119:80 weight 10 check inter 2132 fall 2 rise 1
-	server 127.0.8.120 127.0.8.120:80 weight 10 check inter 5125 fall 2 rise 1
-	server 127.0.8.121 127.0.8.121:80 weight 10 check inter 4344 fall 2 rise 1
-	server 127.0.8.122 127.0.8.122:80 weight 10 check inter 812 fall 2 rise 1
-	server 127.0.8.123 127.0.8.123:80 weight 10 check inter 3559 fall 2 rise 1
-	server 127.0.8.124 127.0.8.124:80 weight 10 check inter 2940 fall 2 rise 1
-	server 127.0.8.125 127.0.8.125:80 weight 10 check inter 8593 fall 2 rise 1
-	server 127.0.8.126 127.0.8.126:80 weight 10 check inter 587 fall 2 rise 1
-	server 127.0.8.127 127.0.8.127:80 weight 10 check inter 3389 fall 2 rise 1
-	server 127.0.8.128 127.0.8.128:80 weight 10 check inter 8865 fall 2 rise 1
-	server 127.0.8.129 127.0.8.129:80 weight 10 check inter 3310 fall 2 rise 1
-	server 127.0.8.130 127.0.8.130:80 weight 10 check inter 4015 fall 2 rise 1
-	server 127.0.8.131 127.0.8.131:80 weight 10 check inter 4688 fall 2 rise 1
-	server 127.0.8.132 127.0.8.132:80 weight 10 check inter 3449 fall 2 rise 1
-	server 127.0.8.133 127.0.8.133:80 weight 10 check inter 4663 fall 2 rise 1
-	server 127.0.8.134 127.0.8.134:80 weight 10 check inter 6561 fall 2 rise 1
-	server 127.0.8.135 127.0.8.135:80 weight 10 check inter 9483 fall 2 rise 1
-	server 127.0.8.136 127.0.8.136:80 weight 10 check inter 8511 fall 2 rise 1
-	server 127.0.8.137 127.0.8.137:80 weight 10 check inter 2707 fall 2 rise 1
-	server 127.0.8.138 127.0.8.138:80 weight 10 check inter 3053 fall 2 rise 1
-	server 127.0.8.139 127.0.8.139:80 weight 10 check inter 385 fall 2 rise 1
-	server 127.0.8.140 127.0.8.140:80 weight 10 check inter 5872 fall 2 rise 1
-	server 127.0.8.141 127.0.8.141:80 weight 10 check inter 2157 fall 2 rise 1
-	server 127.0.8.142 127.0.8.142:80 weight 10 check inter 5701 fall 2 rise 1
-	server 127.0.8.143 127.0.8.143:80 weight 10 check inter 4061 fall 2 rise 1
-	server 127.0.8.144 127.0.8.144:80 weight 10 check inter 9021 fall 2 rise 1
-	server 127.0.8.145 127.0.8.145:80 weight 10 check inter 2587 fall 2 rise 1
-	server 127.0.8.146 127.0.8.146:80 weight 10 check inter 6883 fall 2 rise 1
-	server 127.0.8.147 127.0.8.147:80 weight 10 check inter 125 fall 2 rise 1
-	server 127.0.8.148 127.0.8.148:80 weight 10 check inter 3230 fall 2 rise 1
-	server 127.0.8.149 127.0.8.149:80 weight 10 check inter 9390 fall 2 rise 1
-	server 127.0.8.150 127.0.8.150:80 weight 10 check inter 6431 fall 2 rise 1
-	server 127.0.8.151 127.0.8.151:80 weight 10 check inter 8462 fall 2 rise 1
-	server 127.0.8.152 127.0.8.152:80 weight 10 check inter 1254 fall 2 rise 1
-	server 127.0.8.153 127.0.8.153:80 weight 10 check inter 712 fall 2 rise 1
-	server 127.0.8.154 127.0.8.154:80 weight 10 check inter 3332 fall 2 rise 1
-	server 127.0.8.155 127.0.8.155:80 weight 10 check inter 9366 fall 2 rise 1
-	server 127.0.8.156 127.0.8.156:80 weight 10 check inter 2890 fall 2 rise 1
-	server 127.0.8.157 127.0.8.157:80 weight 10 check inter 6433 fall 2 rise 1
-	server 127.0.8.158 127.0.8.158:80 weight 10 check inter 2643 fall 2 rise 1
-	server 127.0.8.159 127.0.8.159:80 weight 10 check inter 3171 fall 2 rise 1
-	server 127.0.8.160 127.0.8.160:80 weight 10 check inter 3377 fall 2 rise 1
-	server 127.0.8.161 127.0.8.161:80 weight 10 check inter 1800 fall 2 rise 1
-	server 127.0.8.162 127.0.8.162:80 weight 10 check inter 3076 fall 2 rise 1
-	server 127.0.8.163 127.0.8.163:80 weight 10 check inter 6071 fall 2 rise 1
-	server 127.0.8.164 127.0.8.164:80 weight 10 check inter 9995 fall 2 rise 1
-	server 127.0.8.165 127.0.8.165:80 weight 10 check inter 7962 fall 2 rise 1
-	server 127.0.8.166 127.0.8.166:80 weight 10 check inter 1152 fall 2 rise 1
-	server 127.0.8.167 127.0.8.167:80 weight 10 check inter 7728 fall 2 rise 1
-	server 127.0.8.168 127.0.8.168:80 weight 10 check inter 769 fall 2 rise 1
-	server 127.0.8.169 127.0.8.169:80 weight 10 check inter 2899 fall 2 rise 1
-	server 127.0.8.170 127.0.8.170:80 weight 10 check inter 575 fall 2 rise 1
-	server 127.0.8.171 127.0.8.171:80 weight 10 check inter 2297 fall 2 rise 1
-	server 127.0.8.172 127.0.8.172:80 weight 10 check inter 2320 fall 2 rise 1
-	server 127.0.8.173 127.0.8.173:80 weight 10 check inter 711 fall 2 rise 1
-	server 127.0.8.174 127.0.8.174:80 weight 10 check inter 9522 fall 2 rise 1
-	server 127.0.8.175 127.0.8.175:80 weight 10 check inter 7379 fall 2 rise 1
-	server 127.0.8.176 127.0.8.176:80 weight 10 check inter 309 fall 2 rise 1
-	server 127.0.8.177 127.0.8.177:80 weight 10 check inter 9984 fall 2 rise 1
-	server 127.0.8.178 127.0.8.178:80 weight 10 check inter 3249 fall 2 rise 1
-	server 127.0.8.179 127.0.8.179:80 weight 10 check inter 9761 fall 2 rise 1
-	server 127.0.8.180 127.0.8.180:80 weight 10 check inter 1671 fall 2 rise 1
-	server 127.0.8.181 127.0.8.181:80 weight 10 check inter 277 fall 2 rise 1
-	server 127.0.8.182 127.0.8.182:80 weight 10 check inter 8722 fall 2 rise 1
-	server 127.0.8.183 127.0.8.183:80 weight 10 check inter 8629 fall 2 rise 1
-	server 127.0.8.184 127.0.8.184:80 weight 10 check inter 9944 fall 2 rise 1
-	server 127.0.8.185 127.0.8.185:80 weight 10 check inter 6831 fall 2 rise 1
-	server 127.0.8.186 127.0.8.186:80 weight 10 check inter 9758 fall 2 rise 1
-	server 127.0.8.187 127.0.8.187:80 weight 10 check inter 7694 fall 2 rise 1
-	server 127.0.8.188 127.0.8.188:80 weight 10 check inter 553 fall 2 rise 1
-	server 127.0.8.189 127.0.8.189:80 weight 10 check inter 7611 fall 2 rise 1
-	server 127.0.8.190 127.0.8.190:80 weight 10 check inter 4900 fall 2 rise 1
-	server 127.0.8.191 127.0.8.191:80 weight 10 check inter 2175 fall 2 rise 1
-	server 127.0.8.192 127.0.8.192:80 weight 10 check inter 9696 fall 2 rise 1
-	server 127.0.8.193 127.0.8.193:80 weight 10 check inter 1725 fall 2 rise 1
-	server 127.0.8.194 127.0.8.194:80 weight 10 check inter 9289 fall 2 rise 1
-	server 127.0.8.195 127.0.8.195:80 weight 10 check inter 5758 fall 2 rise 1
-	server 127.0.8.196 127.0.8.196:80 weight 10 check inter 4746 fall 2 rise 1
-	server 127.0.8.197 127.0.8.197:80 weight 10 check inter 9323 fall 2 rise 1
-	server 127.0.8.198 127.0.8.198:80 weight 10 check inter 2774 fall 2 rise 1
-	server 127.0.8.199 127.0.8.199:80 weight 10 check inter 7488 fall 2 rise 1
-	server 127.0.8.200 127.0.8.200:80 weight 10 check inter 1968 fall 2 rise 1
-	server 127.0.8.201 127.0.8.201:80 weight 10 check inter 5382 fall 2 rise 1
-	server 127.0.8.202 127.0.8.202:80 weight 10 check inter 7807 fall 2 rise 1
-	server 127.0.8.203 127.0.8.203:80 weight 10 check inter 9239 fall 2 rise 1
-	server 127.0.8.204 127.0.8.204:80 weight 10 check inter 5180 fall 2 rise 1
-	server 127.0.8.205 127.0.8.205:80 weight 10 check inter 5366 fall 2 rise 1
-	server 127.0.8.206 127.0.8.206:80 weight 10 check inter 6453 fall 2 rise 1
-	server 127.0.8.207 127.0.8.207:80 weight 10 check inter 3098 fall 2 rise 1
-	server 127.0.8.208 127.0.8.208:80 weight 10 check inter 4360 fall 2 rise 1
-	server 127.0.8.209 127.0.8.209:80 weight 10 check inter 6684 fall 2 rise 1
-	server 127.0.8.210 127.0.8.210:80 weight 10 check inter 2987 fall 2 rise 1
-	server 127.0.8.211 127.0.8.211:80 weight 10 check inter 2704 fall 2 rise 1
-	server 127.0.8.212 127.0.8.212:80 weight 10 check inter 2315 fall 2 rise 1
-	server 127.0.8.213 127.0.8.213:80 weight 10 check inter 8999 fall 2 rise 1
-	server 127.0.8.214 127.0.8.214:80 weight 10 check inter 8473 fall 2 rise 1
-	server 127.0.8.215 127.0.8.215:80 weight 10 check inter 1284 fall 2 rise 1
-	server 127.0.8.216 127.0.8.216:80 weight 10 check inter 7314 fall 2 rise 1
-	server 127.0.8.217 127.0.8.217:80 weight 10 check inter 6259 fall 2 rise 1
-	server 127.0.8.218 127.0.8.218:80 weight 10 check inter 9506 fall 2 rise 1
-	server 127.0.8.219 127.0.8.219:80 weight 10 check inter 3608 fall 2 rise 1
-	server 127.0.8.220 127.0.8.220:80 weight 10 check inter 896 fall 2 rise 1
-	server 127.0.8.221 127.0.8.221:80 weight 10 check inter 5653 fall 2 rise 1
-	server 127.0.8.222 127.0.8.222:80 weight 10 check inter 1350 fall 2 rise 1
-	server 127.0.8.223 127.0.8.223:80 weight 10 check inter 9095 fall 2 rise 1
-	server 127.0.8.224 127.0.8.224:80 weight 10 check inter 437 fall 2 rise 1
-	server 127.0.8.225 127.0.8.225:80 weight 10 check inter 4647 fall 2 rise 1
-	server 127.0.8.226 127.0.8.226:80 weight 10 check inter 4711 fall 2 rise 1
-	server 127.0.8.227 127.0.8.227:80 weight 10 check inter 1148 fall 2 rise 1
-	server 127.0.8.228 127.0.8.228:80 weight 10 check inter 7840 fall 2 rise 1
-	server 127.0.8.229 127.0.8.229:80 weight 10 check inter 3636 fall 2 rise 1
-	server 127.0.8.230 127.0.8.230:80 weight 10 check inter 6731 fall 2 rise 1
-	server 127.0.8.231 127.0.8.231:80 weight 10 check inter 2083 fall 2 rise 1
-	server 127.0.8.232 127.0.8.232:80 weight 10 check inter 8564 fall 2 rise 1
-	server 127.0.8.233 127.0.8.233:80 weight 10 check inter 4290 fall 2 rise 1
-	server 127.0.8.234 127.0.8.234:80 weight 10 check inter 2326 fall 2 rise 1
-	server 127.0.8.235 127.0.8.235:80 weight 10 check inter 2755 fall 2 rise 1
-	server 127.0.8.236 127.0.8.236:80 weight 10 check inter 7100 fall 2 rise 1
-	server 127.0.8.237 127.0.8.237:80 weight 10 check inter 7571 fall 2 rise 1
-	server 127.0.8.238 127.0.8.238:80 weight 10 check inter 453 fall 2 rise 1
-	server 127.0.8.239 127.0.8.239:80 weight 10 check inter 969 fall 2 rise 1
-	server 127.0.8.240 127.0.8.240:80 weight 10 check inter 8814 fall 2 rise 1
-	server 127.0.8.241 127.0.8.241:80 weight 10 check inter 2282 fall 2 rise 1
-	server 127.0.8.242 127.0.8.242:80 weight 10 check inter 5466 fall 2 rise 1
-	server 127.0.8.243 127.0.8.243:80 weight 10 check inter 7523 fall 2 rise 1
-	server 127.0.8.244 127.0.8.244:80 weight 10 check inter 9360 fall 2 rise 1
-	server 127.0.8.245 127.0.8.245:80 weight 10 check inter 1981 fall 2 rise 1
-	server 127.0.8.246 127.0.8.246:80 weight 10 check inter 4571 fall 2 rise 1
-	server 127.0.8.247 127.0.8.247:80 weight 10 check inter 4417 fall 2 rise 1
-	server 127.0.8.248 127.0.8.248:80 weight 10 check inter 158 fall 2 rise 1
-	server 127.0.8.249 127.0.8.249:80 weight 10 check inter 9246 fall 2 rise 1
-	server 127.0.8.250 127.0.8.250:80 weight 10 check inter 7241 fall 2 rise 1
-	server 127.0.9.001 127.0.9.1:80 weight 10 check inter 3436 fall 2 rise 1
-	server 127.0.9.002 127.0.9.2:80 weight 10 check inter 3175 fall 2 rise 1
-	server 127.0.9.003 127.0.9.3:80 weight 10 check inter 2697 fall 2 rise 1
-	server 127.0.9.004 127.0.9.4:80 weight 10 check inter 5921 fall 2 rise 1
-	server 127.0.9.005 127.0.9.5:80 weight 10 check inter 1971 fall 2 rise 1
-	server 127.0.9.006 127.0.9.6:80 weight 10 check inter 9962 fall 2 rise 1
-	server 127.0.9.007 127.0.9.7:80 weight 10 check inter 7118 fall 2 rise 1
-	server 127.0.9.008 127.0.9.8:80 weight 10 check inter 2181 fall 2 rise 1
-	server 127.0.9.009 127.0.9.9:80 weight 10 check inter 9210 fall 2 rise 1
-	server 127.0.9.010 127.0.9.10:80 weight 10 check inter 6467 fall 2 rise 1
-	server 127.0.9.011 127.0.9.11:80 weight 10 check inter 3324 fall 2 rise 1
-	server 127.0.9.012 127.0.9.12:80 weight 10 check inter 1032 fall 2 rise 1
-	server 127.0.9.013 127.0.9.13:80 weight 10 check inter 6945 fall 2 rise 1
-	server 127.0.9.014 127.0.9.14:80 weight 10 check inter 3222 fall 2 rise 1
-	server 127.0.9.015 127.0.9.15:80 weight 10 check inter 1521 fall 2 rise 1
-	server 127.0.9.016 127.0.9.16:80 weight 10 check inter 6955 fall 2 rise 1
-	server 127.0.9.017 127.0.9.17:80 weight 10 check inter 6725 fall 2 rise 1
-	server 127.0.9.018 127.0.9.18:80 weight 10 check inter 5015 fall 2 rise 1
-	server 127.0.9.019 127.0.9.19:80 weight 10 check inter 7380 fall 2 rise 1
-	server 127.0.9.020 127.0.9.20:80 weight 10 check inter 5418 fall 2 rise 1
-	server 127.0.9.021 127.0.9.21:80 weight 10 check inter 89 fall 2 rise 1
-	server 127.0.9.022 127.0.9.22:80 weight 10 check inter 9215 fall 2 rise 1
-	server 127.0.9.023 127.0.9.23:80 weight 10 check inter 1983 fall 2 rise 1
-	server 127.0.9.024 127.0.9.24:80 weight 10 check inter 2534 fall 2 rise 1
-	server 127.0.9.025 127.0.9.25:80 weight 10 check inter 1282 fall 2 rise 1
-	server 127.0.9.026 127.0.9.26:80 weight 10 check inter 6832 fall 2 rise 1
-	server 127.0.9.027 127.0.9.27:80 weight 10 check inter 3181 fall 2 rise 1
-	server 127.0.9.028 127.0.9.28:80 weight 10 check inter 3073 fall 2 rise 1
-	server 127.0.9.029 127.0.9.29:80 weight 10 check inter 901 fall 2 rise 1
-	server 127.0.9.030 127.0.9.30:80 weight 10 check inter 9778 fall 2 rise 1
-	server 127.0.9.031 127.0.9.31:80 weight 10 check inter 8263 fall 2 rise 1
-	server 127.0.9.032 127.0.9.32:80 weight 10 check inter 3947 fall 2 rise 1
-	server 127.0.9.033 127.0.9.33:80 weight 10 check inter 7538 fall 2 rise 1
-	server 127.0.9.034 127.0.9.34:80 weight 10 check inter 7541 fall 2 rise 1
-	server 127.0.9.035 127.0.9.35:80 weight 10 check inter 9486 fall 2 rise 1
-	server 127.0.9.036 127.0.9.36:80 weight 10 check inter 6943 fall 2 rise 1
-	server 127.0.9.037 127.0.9.37:80 weight 10 check inter 2029 fall 2 rise 1
-	server 127.0.9.038 127.0.9.38:80 weight 10 check inter 3302 fall 2 rise 1
-	server 127.0.9.039 127.0.9.39:80 weight 10 check inter 9608 fall 2 rise 1
-	server 127.0.9.040 127.0.9.40:80 weight 10 check inter 860 fall 2 rise 1
-	server 127.0.9.041 127.0.9.41:80 weight 10 check inter 4336 fall 2 rise 1
-	server 127.0.9.042 127.0.9.42:80 weight 10 check inter 8717 fall 2 rise 1
-	server 127.0.9.043 127.0.9.43:80 weight 10 check inter 3883 fall 2 rise 1
-	server 127.0.9.044 127.0.9.44:80 weight 10 check inter 2548 fall 2 rise 1
-	server 127.0.9.045 127.0.9.45:80 weight 10 check inter 5153 fall 2 rise 1
-	server 127.0.9.046 127.0.9.46:80 weight 10 check inter 3116 fall 2 rise 1
-	server 127.0.9.047 127.0.9.47:80 weight 10 check inter 4587 fall 2 rise 1
-	server 127.0.9.048 127.0.9.48:80 weight 10 check inter 5303 fall 2 rise 1
-	server 127.0.9.049 127.0.9.49:80 weight 10 check inter 5220 fall 2 rise 1
-	server 127.0.9.050 127.0.9.50:80 weight 10 check inter 9527 fall 2 rise 1
-	server 127.0.9.051 127.0.9.51:80 weight 10 check inter 7923 fall 2 rise 1
-	server 127.0.9.052 127.0.9.52:80 weight 10 check inter 4109 fall 2 rise 1
-	server 127.0.9.053 127.0.9.53:80 weight 10 check inter 5506 fall 2 rise 1
-	server 127.0.9.054 127.0.9.54:80 weight 10 check inter 5619 fall 2 rise 1
-	server 127.0.9.055 127.0.9.55:80 weight 10 check inter 8756 fall 2 rise 1
-	server 127.0.9.056 127.0.9.56:80 weight 10 check inter 9590 fall 2 rise 1
-	server 127.0.9.057 127.0.9.57:80 weight 10 check inter 6773 fall 2 rise 1
-	server 127.0.9.058 127.0.9.58:80 weight 10 check inter 8577 fall 2 rise 1
-	server 127.0.9.059 127.0.9.59:80 weight 10 check inter 9633 fall 2 rise 1
-	server 127.0.9.060 127.0.9.60:80 weight 10 check inter 2737 fall 2 rise 1
-	server 127.0.9.061 127.0.9.61:80 weight 10 check inter 8488 fall 2 rise 1
-	server 127.0.9.062 127.0.9.62:80 weight 10 check inter 3688 fall 2 rise 1
-	server 127.0.9.063 127.0.9.63:80 weight 10 check inter 6935 fall 2 rise 1
-	server 127.0.9.064 127.0.9.64:80 weight 10 check inter 1391 fall 2 rise 1
-	server 127.0.9.065 127.0.9.65:80 weight 10 check inter 2001 fall 2 rise 1
-	server 127.0.9.066 127.0.9.66:80 weight 10 check inter 9508 fall 2 rise 1
-	server 127.0.9.067 127.0.9.67:80 weight 10 check inter 5997 fall 2 rise 1
-	server 127.0.9.068 127.0.9.68:80 weight 10 check inter 9909 fall 2 rise 1
-	server 127.0.9.069 127.0.9.69:80 weight 10 check inter 9835 fall 2 rise 1
-	server 127.0.9.070 127.0.9.70:80 weight 10 check inter 5536 fall 2 rise 1
-	server 127.0.9.071 127.0.9.71:80 weight 10 check inter 6511 fall 2 rise 1
-	server 127.0.9.072 127.0.9.72:80 weight 10 check inter 5155 fall 2 rise 1
-	server 127.0.9.073 127.0.9.73:80 weight 10 check inter 3253 fall 2 rise 1
-	server 127.0.9.074 127.0.9.74:80 weight 10 check inter 2500 fall 2 rise 1
-	server 127.0.9.075 127.0.9.75:80 weight 10 check inter 9417 fall 2 rise 1
-	server 127.0.9.076 127.0.9.76:80 weight 10 check inter 3624 fall 2 rise 1
-	server 127.0.9.077 127.0.9.77:80 weight 10 check inter 1900 fall 2 rise 1
-	server 127.0.9.078 127.0.9.78:80 weight 10 check inter 6095 fall 2 rise 1
-	server 127.0.9.079 127.0.9.79:80 weight 10 check inter 1526 fall 2 rise 1
-	server 127.0.9.080 127.0.9.80:80 weight 10 check inter 4529 fall 2 rise 1
-	server 127.0.9.081 127.0.9.81:80 weight 10 check inter 6346 fall 2 rise 1
-	server 127.0.9.082 127.0.9.82:80 weight 10 check inter 2755 fall 2 rise 1
-	server 127.0.9.083 127.0.9.83:80 weight 10 check inter 9863 fall 2 rise 1
-	server 127.0.9.084 127.0.9.84:80 weight 10 check inter 1989 fall 2 rise 1
-	server 127.0.9.085 127.0.9.85:80 weight 10 check inter 1611 fall 2 rise 1
-	server 127.0.9.086 127.0.9.86:80 weight 10 check inter 2594 fall 2 rise 1
-	server 127.0.9.087 127.0.9.87:80 weight 10 check inter 9490 fall 2 rise 1
-	server 127.0.9.088 127.0.9.88:80 weight 10 check inter 8354 fall 2 rise 1
-	server 127.0.9.089 127.0.9.89:80 weight 10 check inter 3587 fall 2 rise 1
-	server 127.0.9.090 127.0.9.90:80 weight 10 check inter 9340 fall 2 rise 1
-	server 127.0.9.091 127.0.9.91:80 weight 10 check inter 1440 fall 2 rise 1
-	server 127.0.9.092 127.0.9.92:80 weight 10 check inter 3958 fall 2 rise 1
-	server 127.0.9.093 127.0.9.93:80 weight 10 check inter 8113 fall 2 rise 1
-	server 127.0.9.094 127.0.9.94:80 weight 10 check inter 1142 fall 2 rise 1
-	server 127.0.9.095 127.0.9.95:80 weight 10 check inter 6644 fall 2 rise 1
-	server 127.0.9.096 127.0.9.96:80 weight 10 check inter 2125 fall 2 rise 1
-	server 127.0.9.097 127.0.9.97:80 weight 10 check inter 6946 fall 2 rise 1
-	server 127.0.9.098 127.0.9.98:80 weight 10 check inter 1642 fall 2 rise 1
-	server 127.0.9.099 127.0.9.99:80 weight 10 check inter 6348 fall 2 rise 1
-	server 127.0.9.100 127.0.9.100:80 weight 10 check inter 4717 fall 2 rise 1
-	server 127.0.9.101 127.0.9.101:80 weight 10 check inter 838 fall 2 rise 1
-	server 127.0.9.102 127.0.9.102:80 weight 10 check inter 2417 fall 2 rise 1
-	server 127.0.9.103 127.0.9.103:80 weight 10 check inter 4441 fall 2 rise 1
-	server 127.0.9.104 127.0.9.104:80 weight 10 check inter 5795 fall 2 rise 1
-	server 127.0.9.105 127.0.9.105:80 weight 10 check inter 8418 fall 2 rise 1
-	server 127.0.9.106 127.0.9.106:80 weight 10 check inter 3857 fall 2 rise 1
-	server 127.0.9.107 127.0.9.107:80 weight 10 check inter 8799 fall 2 rise 1
-	server 127.0.9.108 127.0.9.108:80 weight 10 check inter 8235 fall 2 rise 1
-	server 127.0.9.109 127.0.9.109:80 weight 10 check inter 5562 fall 2 rise 1
-	server 127.0.9.110 127.0.9.110:80 weight 10 check inter 54 fall 2 rise 1
-	server 127.0.9.111 127.0.9.111:80 weight 10 check inter 3228 fall 2 rise 1
-	server 127.0.9.112 127.0.9.112:80 weight 10 check inter 2577 fall 2 rise 1
-	server 127.0.9.113 127.0.9.113:80 weight 10 check inter 2236 fall 2 rise 1
-	server 127.0.9.114 127.0.9.114:80 weight 10 check inter 6018 fall 2 rise 1
-	server 127.0.9.115 127.0.9.115:80 weight 10 check inter 2472 fall 2 rise 1
-	server 127.0.9.116 127.0.9.116:80 weight 10 check inter 6155 fall 2 rise 1
-	server 127.0.9.117 127.0.9.117:80 weight 10 check inter 2141 fall 2 rise 1
-	server 127.0.9.118 127.0.9.118:80 weight 10 check inter 2612 fall 2 rise 1
-	server 127.0.9.119 127.0.9.119:80 weight 10 check inter 7760 fall 2 rise 1
-	server 127.0.9.120 127.0.9.120:80 weight 10 check inter 5795 fall 2 rise 1
-	server 127.0.9.121 127.0.9.121:80 weight 10 check inter 9813 fall 2 rise 1
-	server 127.0.9.122 127.0.9.122:80 weight 10 check inter 3690 fall 2 rise 1
-	server 127.0.9.123 127.0.9.123:80 weight 10 check inter 4546 fall 2 rise 1
-	server 127.0.9.124 127.0.9.124:80 weight 10 check inter 1526 fall 2 rise 1
-	server 127.0.9.125 127.0.9.125:80 weight 10 check inter 4522 fall 2 rise 1
-	server 127.0.9.126 127.0.9.126:80 weight 10 check inter 7606 fall 2 rise 1
-	server 127.0.9.127 127.0.9.127:80 weight 10 check inter 4392 fall 2 rise 1
-	server 127.0.9.128 127.0.9.128:80 weight 10 check inter 9485 fall 2 rise 1
-	server 127.0.9.129 127.0.9.129:80 weight 10 check inter 988 fall 2 rise 1
-	server 127.0.9.130 127.0.9.130:80 weight 10 check inter 7409 fall 2 rise 1
-	server 127.0.9.131 127.0.9.131:80 weight 10 check inter 4965 fall 2 rise 1
-	server 127.0.9.132 127.0.9.132:80 weight 10 check inter 8430 fall 2 rise 1
-	server 127.0.9.133 127.0.9.133:80 weight 10 check inter 8133 fall 2 rise 1
-	server 127.0.9.134 127.0.9.134:80 weight 10 check inter 1442 fall 2 rise 1
-	server 127.0.9.135 127.0.9.135:80 weight 10 check inter 2240 fall 2 rise 1
-	server 127.0.9.136 127.0.9.136:80 weight 10 check inter 1523 fall 2 rise 1
-	server 127.0.9.137 127.0.9.137:80 weight 10 check inter 8015 fall 2 rise 1
-	server 127.0.9.138 127.0.9.138:80 weight 10 check inter 1420 fall 2 rise 1
-	server 127.0.9.139 127.0.9.139:80 weight 10 check inter 6739 fall 2 rise 1
-	server 127.0.9.140 127.0.9.140:80 weight 10 check inter 4757 fall 2 rise 1
-	server 127.0.9.141 127.0.9.141:80 weight 10 check inter 8323 fall 2 rise 1
-	server 127.0.9.142 127.0.9.142:80 weight 10 check inter 795 fall 2 rise 1
-	server 127.0.9.143 127.0.9.143:80 weight 10 check inter 3875 fall 2 rise 1
-	server 127.0.9.144 127.0.9.144:80 weight 10 check inter 944 fall 2 rise 1
-	server 127.0.9.145 127.0.9.145:80 weight 10 check inter 757 fall 2 rise 1
-	server 127.0.9.146 127.0.9.146:80 weight 10 check inter 2157 fall 2 rise 1
-	server 127.0.9.147 127.0.9.147:80 weight 10 check inter 5326 fall 2 rise 1
-	server 127.0.9.148 127.0.9.148:80 weight 10 check inter 6406 fall 2 rise 1
-	server 127.0.9.149 127.0.9.149:80 weight 10 check inter 2320 fall 2 rise 1
-	server 127.0.9.150 127.0.9.150:80 weight 10 check inter 5425 fall 2 rise 1
-	server 127.0.9.151 127.0.9.151:80 weight 10 check inter 9366 fall 2 rise 1
-	server 127.0.9.152 127.0.9.152:80 weight 10 check inter 5200 fall 2 rise 1
-	server 127.0.9.153 127.0.9.153:80 weight 10 check inter 2035 fall 2 rise 1
-	server 127.0.9.154 127.0.9.154:80 weight 10 check inter 1553 fall 2 rise 1
-	server 127.0.9.155 127.0.9.155:80 weight 10 check inter 2431 fall 2 rise 1
-	server 127.0.9.156 127.0.9.156:80 weight 10 check inter 2937 fall 2 rise 1
-	server 127.0.9.157 127.0.9.157:80 weight 10 check inter 5640 fall 2 rise 1
-	server 127.0.9.158 127.0.9.158:80 weight 10 check inter 7518 fall 2 rise 1
-	server 127.0.9.159 127.0.9.159:80 weight 10 check inter 4937 fall 2 rise 1
-	server 127.0.9.160 127.0.9.160:80 weight 10 check inter 4825 fall 2 rise 1
-	server 127.0.9.161 127.0.9.161:80 weight 10 check inter 1241 fall 2 rise 1
-	server 127.0.9.162 127.0.9.162:80 weight 10 check inter 95 fall 2 rise 1
-	server 127.0.9.163 127.0.9.163:80 weight 10 check inter 6574 fall 2 rise 1
-	server 127.0.9.164 127.0.9.164:80 weight 10 check inter 817 fall 2 rise 1
-	server 127.0.9.165 127.0.9.165:80 weight 10 check inter 2465 fall 2 rise 1
-	server 127.0.9.166 127.0.9.166:80 weight 10 check inter 9081 fall 2 rise 1
-	server 127.0.9.167 127.0.9.167:80 weight 10 check inter 7131 fall 2 rise 1
-	server 127.0.9.168 127.0.9.168:80 weight 10 check inter 7403 fall 2 rise 1
-	server 127.0.9.169 127.0.9.169:80 weight 10 check inter 9795 fall 2 rise 1
-	server 127.0.9.170 127.0.9.170:80 weight 10 check inter 6413 fall 2 rise 1
-	server 127.0.9.171 127.0.9.171:80 weight 10 check inter 1023 fall 2 rise 1
-	server 127.0.9.172 127.0.9.172:80 weight 10 check inter 1503 fall 2 rise 1
-	server 127.0.9.173 127.0.9.173:80 weight 10 check inter 2782 fall 2 rise 1
-	server 127.0.9.174 127.0.9.174:80 weight 10 check inter 4165 fall 2 rise 1
-	server 127.0.9.175 127.0.9.175:80 weight 10 check inter 6037 fall 2 rise 1
-	server 127.0.9.176 127.0.9.176:80 weight 10 check inter 6373 fall 2 rise 1
-	server 127.0.9.177 127.0.9.177:80 weight 10 check inter 8267 fall 2 rise 1
-	server 127.0.9.178 127.0.9.178:80 weight 10 check inter 4909 fall 2 rise 1
-	server 127.0.9.179 127.0.9.179:80 weight 10 check inter 8305 fall 2 rise 1
-	server 127.0.9.180 127.0.9.180:80 weight 10 check inter 4175 fall 2 rise 1
-	server 127.0.9.181 127.0.9.181:80 weight 10 check inter 2876 fall 2 rise 1
-	server 127.0.9.182 127.0.9.182:80 weight 10 check inter 9761 fall 2 rise 1
-	server 127.0.9.183 127.0.9.183:80 weight 10 check inter 1260 fall 2 rise 1
-	server 127.0.9.184 127.0.9.184:80 weight 10 check inter 7874 fall 2 rise 1
-	server 127.0.9.185 127.0.9.185:80 weight 10 check inter 8100 fall 2 rise 1
-	server 127.0.9.186 127.0.9.186:80 weight 10 check inter 986 fall 2 rise 1
-	server 127.0.9.187 127.0.9.187:80 weight 10 check inter 9951 fall 2 rise 1
-	server 127.0.9.188 127.0.9.188:80 weight 10 check inter 88 fall 2 rise 1
-	server 127.0.9.189 127.0.9.189:80 weight 10 check inter 1510 fall 2 rise 1
-	server 127.0.9.190 127.0.9.190:80 weight 10 check inter 9831 fall 2 rise 1
-	server 127.0.9.191 127.0.9.191:80 weight 10 check inter 6961 fall 2 rise 1
-	server 127.0.9.192 127.0.9.192:80 weight 10 check inter 1350 fall 2 rise 1
-	server 127.0.9.193 127.0.9.193:80 weight 10 check inter 6078 fall 2 rise 1
-	server 127.0.9.194 127.0.9.194:80 weight 10 check inter 8349 fall 2 rise 1
-	server 127.0.9.195 127.0.9.195:80 weight 10 check inter 8977 fall 2 rise 1
-	server 127.0.9.196 127.0.9.196:80 weight 10 check inter 7742 fall 2 rise 1
-	server 127.0.9.197 127.0.9.197:80 weight 10 check inter 3922 fall 2 rise 1
-	server 127.0.9.198 127.0.9.198:80 weight 10 check inter 3551 fall 2 rise 1
-	server 127.0.9.199 127.0.9.199:80 weight 10 check inter 8563 fall 2 rise 1
-	server 127.0.9.200 127.0.9.200:80 weight 10 check inter 6516 fall 2 rise 1
-	server 127.0.9.201 127.0.9.201:80 weight 10 check inter 4471 fall 2 rise 1
-	server 127.0.9.202 127.0.9.202:80 weight 10 check inter 2652 fall 2 rise 1
-	server 127.0.9.203 127.0.9.203:80 weight 10 check inter 5274 fall 2 rise 1
-	server 127.0.9.204 127.0.9.204:80 weight 10 check inter 3953 fall 2 rise 1
-	server 127.0.9.205 127.0.9.205:80 weight 10 check inter 1955 fall 2 rise 1
-	server 127.0.9.206 127.0.9.206:80 weight 10 check inter 6684 fall 2 rise 1
-	server 127.0.9.207 127.0.9.207:80 weight 10 check inter 1737 fall 2 rise 1
-	server 127.0.9.208 127.0.9.208:80 weight 10 check inter 7465 fall 2 rise 1
-	server 127.0.9.209 127.0.9.209:80 weight 10 check inter 5159 fall 2 rise 1
-	server 127.0.9.210 127.0.9.210:80 weight 10 check inter 600 fall 2 rise 1
-	server 127.0.9.211 127.0.9.211:80 weight 10 check inter 9898 fall 2 rise 1
-	server 127.0.9.212 127.0.9.212:80 weight 10 check inter 829 fall 2 rise 1
-	server 127.0.9.213 127.0.9.213:80 weight 10 check inter 8792 fall 2 rise 1
-	server 127.0.9.214 127.0.9.214:80 weight 10 check inter 5020 fall 2 rise 1
-	server 127.0.9.215 127.0.9.215:80 weight 10 check inter 5386 fall 2 rise 1
-	server 127.0.9.216 127.0.9.216:80 weight 10 check inter 8672 fall 2 rise 1
-	server 127.0.9.217 127.0.9.217:80 weight 10 check inter 7121 fall 2 rise 1
-	server 127.0.9.218 127.0.9.218:80 weight 10 check inter 1565 fall 2 rise 1
-	server 127.0.9.219 127.0.9.219:80 weight 10 check inter 3963 fall 2 rise 1
-	server 127.0.9.220 127.0.9.220:80 weight 10 check inter 3738 fall 2 rise 1
-	server 127.0.9.221 127.0.9.221:80 weight 10 check inter 9818 fall 2 rise 1
-	server 127.0.9.222 127.0.9.222:80 weight 10 check inter 1401 fall 2 rise 1
-	server 127.0.9.223 127.0.9.223:80 weight 10 check inter 3064 fall 2 rise 1
-	server 127.0.9.224 127.0.9.224:80 weight 10 check inter 4750 fall 2 rise 1
-	server 127.0.9.225 127.0.9.225:80 weight 10 check inter 678 fall 2 rise 1
-	server 127.0.9.226 127.0.9.226:80 weight 10 check inter 6180 fall 2 rise 1
-	server 127.0.9.227 127.0.9.227:80 weight 10 check inter 3045 fall 2 rise 1
-	server 127.0.9.228 127.0.9.228:80 weight 10 check inter 7771 fall 2 rise 1
-	server 127.0.9.229 127.0.9.229:80 weight 10 check inter 5776 fall 2 rise 1
-	server 127.0.9.230 127.0.9.230:80 weight 10 check inter 9276 fall 2 rise 1
-	server 127.0.9.231 127.0.9.231:80 weight 10 check inter 5438 fall 2 rise 1
-	server 127.0.9.232 127.0.9.232:80 weight 10 check inter 9957 fall 2 rise 1
-	server 127.0.9.233 127.0.9.233:80 weight 10 check inter 6787 fall 2 rise 1
-	server 127.0.9.234 127.0.9.234:80 weight 10 check inter 2081 fall 2 rise 1
-	server 127.0.9.235 127.0.9.235:80 weight 10 check inter 653 fall 2 rise 1
-	server 127.0.9.236 127.0.9.236:80 weight 10 check inter 4753 fall 2 rise 1
-	server 127.0.9.237 127.0.9.237:80 weight 10 check inter 8204 fall 2 rise 1
-	server 127.0.9.238 127.0.9.238:80 weight 10 check inter 3847 fall 2 rise 1
-	server 127.0.9.239 127.0.9.239:80 weight 10 check inter 2456 fall 2 rise 1
-	server 127.0.9.240 127.0.9.240:80 weight 10 check inter 2531 fall 2 rise 1
-	server 127.0.9.241 127.0.9.241:80 weight 10 check inter 3088 fall 2 rise 1
-	server 127.0.9.242 127.0.9.242:80 weight 10 check inter 5383 fall 2 rise 1
-	server 127.0.9.243 127.0.9.243:80 weight 10 check inter 3360 fall 2 rise 1
-	server 127.0.9.244 127.0.9.244:80 weight 10 check inter 9368 fall 2 rise 1
-	server 127.0.9.245 127.0.9.245:80 weight 10 check inter 6093 fall 2 rise 1
-	server 127.0.9.246 127.0.9.246:80 weight 10 check inter 649 fall 2 rise 1
-	server 127.0.9.247 127.0.9.247:80 weight 10 check inter 4841 fall 2 rise 1
-	server 127.0.9.248 127.0.9.248:80 weight 10 check inter 3235 fall 2 rise 1
-	server 127.0.9.249 127.0.9.249:80 weight 10 check inter 6705 fall 2 rise 1
-	server 127.0.9.250 127.0.9.250:80 weight 10 check inter 4834 fall 2 rise 1
-	server 127.0.10.001 127.0.10.1:80 weight 10 check inter 2698 fall 2 rise 1
-	server 127.0.10.002 127.0.10.2:80 weight 10 check inter 5655 fall 2 rise 1
-	server 127.0.10.003 127.0.10.3:80 weight 10 check inter 365 fall 2 rise 1
-	server 127.0.10.004 127.0.10.4:80 weight 10 check inter 1901 fall 2 rise 1
-	server 127.0.10.005 127.0.10.5:80 weight 10 check inter 3604 fall 2 rise 1
-	server 127.0.10.006 127.0.10.6:80 weight 10 check inter 4264 fall 2 rise 1
-	server 127.0.10.007 127.0.10.7:80 weight 10 check inter 407 fall 2 rise 1
-	server 127.0.10.008 127.0.10.8:80 weight 10 check inter 7418 fall 2 rise 1
-	server 127.0.10.009 127.0.10.9:80 weight 10 check inter 5491 fall 2 rise 1
-	server 127.0.10.010 127.0.10.10:80 weight 10 check inter 9410 fall 2 rise 1
-	server 127.0.10.011 127.0.10.11:80 weight 10 check inter 7874 fall 2 rise 1
-	server 127.0.10.012 127.0.10.12:80 weight 10 check inter 6889 fall 2 rise 1
-	server 127.0.10.013 127.0.10.13:80 weight 10 check inter 3350 fall 2 rise 1
-	server 127.0.10.014 127.0.10.14:80 weight 10 check inter 679 fall 2 rise 1
-	server 127.0.10.015 127.0.10.15:80 weight 10 check inter 9983 fall 2 rise 1
-	server 127.0.10.016 127.0.10.16:80 weight 10 check inter 9236 fall 2 rise 1
-	server 127.0.10.017 127.0.10.17:80 weight 10 check inter 4158 fall 2 rise 1
-	server 127.0.10.018 127.0.10.18:80 weight 10 check inter 5418 fall 2 rise 1
-	server 127.0.10.019 127.0.10.19:80 weight 10 check inter 1535 fall 2 rise 1
-	server 127.0.10.020 127.0.10.20:80 weight 10 check inter 8432 fall 2 rise 1
-	server 127.0.10.021 127.0.10.21:80 weight 10 check inter 6360 fall 2 rise 1
-	server 127.0.10.022 127.0.10.22:80 weight 10 check inter 1740 fall 2 rise 1
-	server 127.0.10.023 127.0.10.23:80 weight 10 check inter 2207 fall 2 rise 1
-	server 127.0.10.024 127.0.10.24:80 weight 10 check inter 6306 fall 2 rise 1
-	server 127.0.10.025 127.0.10.25:80 weight 10 check inter 6090 fall 2 rise 1
-	server 127.0.10.026 127.0.10.26:80 weight 10 check inter 2729 fall 2 rise 1
-	server 127.0.10.027 127.0.10.27:80 weight 10 check inter 3986 fall 2 rise 1
-	server 127.0.10.028 127.0.10.28:80 weight 10 check inter 6770 fall 2 rise 1
-	server 127.0.10.029 127.0.10.29:80 weight 10 check inter 4944 fall 2 rise 1
-	server 127.0.10.030 127.0.10.30:80 weight 10 check inter 754 fall 2 rise 1
-	server 127.0.10.031 127.0.10.31:80 weight 10 check inter 8494 fall 2 rise 1
-	server 127.0.10.032 127.0.10.32:80 weight 10 check inter 1089 fall 2 rise 1
-	server 127.0.10.033 127.0.10.33:80 weight 10 check inter 1924 fall 2 rise 1
-	server 127.0.10.034 127.0.10.34:80 weight 10 check inter 936 fall 2 rise 1
-	server 127.0.10.035 127.0.10.35:80 weight 10 check inter 598 fall 2 rise 1
-	server 127.0.10.036 127.0.10.36:80 weight 10 check inter 1673 fall 2 rise 1
-	server 127.0.10.037 127.0.10.37:80 weight 10 check inter 7327 fall 2 rise 1
-	server 127.0.10.038 127.0.10.38:80 weight 10 check inter 5453 fall 2 rise 1
-	server 127.0.10.039 127.0.10.39:80 weight 10 check inter 7434 fall 2 rise 1
-	server 127.0.10.040 127.0.10.40:80 weight 10 check inter 6792 fall 2 rise 1
-	server 127.0.10.041 127.0.10.41:80 weight 10 check inter 3329 fall 2 rise 1
-	server 127.0.10.042 127.0.10.42:80 weight 10 check inter 27 fall 2 rise 1
-	server 127.0.10.043 127.0.10.43:80 weight 10 check inter 3249 fall 2 rise 1
-	server 127.0.10.044 127.0.10.44:80 weight 10 check inter 1532 fall 2 rise 1
-	server 127.0.10.045 127.0.10.45:80 weight 10 check inter 1810 fall 2 rise 1
-	server 127.0.10.046 127.0.10.46:80 weight 10 check inter 1345 fall 2 rise 1
-	server 127.0.10.047 127.0.10.47:80 weight 10 check inter 8562 fall 2 rise 1
-	server 127.0.10.048 127.0.10.48:80 weight 10 check inter 1245 fall 2 rise 1
-	server 127.0.10.049 127.0.10.49:80 weight 10 check inter 5863 fall 2 rise 1
-	server 127.0.10.050 127.0.10.50:80 weight 10 check inter 5697 fall 2 rise 1
-	server 127.0.10.051 127.0.10.51:80 weight 10 check inter 1301 fall 2 rise 1
-	server 127.0.10.052 127.0.10.52:80 weight 10 check inter 3886 fall 2 rise 1
-	server 127.0.10.053 127.0.10.53:80 weight 10 check inter 1075 fall 2 rise 1
-	server 127.0.10.054 127.0.10.54:80 weight 10 check inter 507 fall 2 rise 1
-	server 127.0.10.055 127.0.10.55:80 weight 10 check inter 1164 fall 2 rise 1
-	server 127.0.10.056 127.0.10.56:80 weight 10 check inter 3009 fall 2 rise 1
-	server 127.0.10.057 127.0.10.57:80 weight 10 check inter 7491 fall 2 rise 1
-	server 127.0.10.058 127.0.10.58:80 weight 10 check inter 3783 fall 2 rise 1
-	server 127.0.10.059 127.0.10.59:80 weight 10 check inter 1025 fall 2 rise 1
-	server 127.0.10.060 127.0.10.60:80 weight 10 check inter 781 fall 2 rise 1
-	server 127.0.10.061 127.0.10.61:80 weight 10 check inter 7703 fall 2 rise 1
-	server 127.0.10.062 127.0.10.62:80 weight 10 check inter 8437 fall 2 rise 1
-	server 127.0.10.063 127.0.10.63:80 weight 10 check inter 7086 fall 2 rise 1
-	server 127.0.10.064 127.0.10.64:80 weight 10 check inter 1521 fall 2 rise 1
-	server 127.0.10.065 127.0.10.65:80 weight 10 check inter 3249 fall 2 rise 1
-	server 127.0.10.066 127.0.10.66:80 weight 10 check inter 149 fall 2 rise 1
-	server 127.0.10.067 127.0.10.67:80 weight 10 check inter 78 fall 2 rise 1
-	server 127.0.10.068 127.0.10.68:80 weight 10 check inter 38 fall 2 rise 1
-	server 127.0.10.069 127.0.10.69:80 weight 10 check inter 5199 fall 2 rise 1
-	server 127.0.10.070 127.0.10.70:80 weight 10 check inter 6357 fall 2 rise 1
-	server 127.0.10.071 127.0.10.71:80 weight 10 check inter 9655 fall 2 rise 1
-	server 127.0.10.072 127.0.10.72:80 weight 10 check inter 8854 fall 2 rise 1
-	server 127.0.10.073 127.0.10.73:80 weight 10 check inter 6649 fall 2 rise 1
-	server 127.0.10.074 127.0.10.74:80 weight 10 check inter 6925 fall 2 rise 1
-	server 127.0.10.075 127.0.10.75:80 weight 10 check inter 1508 fall 2 rise 1
-	server 127.0.10.076 127.0.10.76:80 weight 10 check inter 7326 fall 2 rise 1
-	server 127.0.10.077 127.0.10.77:80 weight 10 check inter 8090 fall 2 rise 1
-	server 127.0.10.078 127.0.10.78:80 weight 10 check inter 3708 fall 2 rise 1
-	server 127.0.10.079 127.0.10.79:80 weight 10 check inter 5525 fall 2 rise 1
-	server 127.0.10.080 127.0.10.80:80 weight 10 check inter 596 fall 2 rise 1
-	server 127.0.10.081 127.0.10.81:80 weight 10 check inter 8910 fall 2 rise 1
-	server 127.0.10.082 127.0.10.82:80 weight 10 check inter 1441 fall 2 rise 1
-	server 127.0.10.083 127.0.10.83:80 weight 10 check inter 2805 fall 2 rise 1
-	server 127.0.10.084 127.0.10.84:80 weight 10 check inter 8168 fall 2 rise 1
-	server 127.0.10.085 127.0.10.85:80 weight 10 check inter 5376 fall 2 rise 1
-	server 127.0.10.086 127.0.10.86:80 weight 10 check inter 569 fall 2 rise 1
-	server 127.0.10.087 127.0.10.87:80 weight 10 check inter 2639 fall 2 rise 1
-	server 127.0.10.088 127.0.10.88:80 weight 10 check inter 2188 fall 2 rise 1
-	server 127.0.10.089 127.0.10.89:80 weight 10 check inter 5568 fall 2 rise 1
-	server 127.0.10.090 127.0.10.90:80 weight 10 check inter 4267 fall 2 rise 1
-	server 127.0.10.091 127.0.10.91:80 weight 10 check inter 1711 fall 2 rise 1
-	server 127.0.10.092 127.0.10.92:80 weight 10 check inter 7988 fall 2 rise 1
-	server 127.0.10.093 127.0.10.93:80 weight 10 check inter 1814 fall 2 rise 1
-	server 127.0.10.094 127.0.10.94:80 weight 10 check inter 7045 fall 2 rise 1
-	server 127.0.10.095 127.0.10.95:80 weight 10 check inter 6650 fall 2 rise 1
-	server 127.0.10.096 127.0.10.96:80 weight 10 check inter 9916 fall 2 rise 1
-	server 127.0.10.097 127.0.10.97:80 weight 10 check inter 8585 fall 2 rise 1
-	server 127.0.10.098 127.0.10.98:80 weight 10 check inter 8260 fall 2 rise 1
-	server 127.0.10.099 127.0.10.99:80 weight 10 check inter 1549 fall 2 rise 1
-	server 127.0.10.100 127.0.10.100:80 weight 10 check inter 8060 fall 2 rise 1
-	server 127.0.10.101 127.0.10.101:80 weight 10 check inter 2110 fall 2 rise 1
-	server 127.0.10.102 127.0.10.102:80 weight 10 check inter 4102 fall 2 rise 1
-	server 127.0.10.103 127.0.10.103:80 weight 10 check inter 1766 fall 2 rise 1
-	server 127.0.10.104 127.0.10.104:80 weight 10 check inter 748 fall 2 rise 1
-	server 127.0.10.105 127.0.10.105:80 weight 10 check inter 8610 fall 2 rise 1
-	server 127.0.10.106 127.0.10.106:80 weight 10 check inter 7345 fall 2 rise 1
-	server 127.0.10.107 127.0.10.107:80 weight 10 check inter 8213 fall 2 rise 1
-	server 127.0.10.108 127.0.10.108:80 weight 10 check inter 4599 fall 2 rise 1
-	server 127.0.10.109 127.0.10.109:80 weight 10 check inter 2310 fall 2 rise 1
-	server 127.0.10.110 127.0.10.110:80 weight 10 check inter 3071 fall 2 rise 1
-	server 127.0.10.111 127.0.10.111:80 weight 10 check inter 7903 fall 2 rise 1
-	server 127.0.10.112 127.0.10.112:80 weight 10 check inter 2369 fall 2 rise 1
-	server 127.0.10.113 127.0.10.113:80 weight 10 check inter 3981 fall 2 rise 1
-	server 127.0.10.114 127.0.10.114:80 weight 10 check inter 3967 fall 2 rise 1
-	server 127.0.10.115 127.0.10.115:80 weight 10 check inter 697 fall 2 rise 1
-	server 127.0.10.116 127.0.10.116:80 weight 10 check inter 2679 fall 2 rise 1
-	server 127.0.10.117 127.0.10.117:80 weight 10 check inter 5799 fall 2 rise 1
-	server 127.0.10.118 127.0.10.118:80 weight 10 check inter 1677 fall 2 rise 1
-	server 127.0.10.119 127.0.10.119:80 weight 10 check inter 5039 fall 2 rise 1
-	server 127.0.10.120 127.0.10.120:80 weight 10 check inter 6971 fall 2 rise 1
-	server 127.0.10.121 127.0.10.121:80 weight 10 check inter 8634 fall 2 rise 1
-	server 127.0.10.122 127.0.10.122:80 weight 10 check inter 8620 fall 2 rise 1
-	server 127.0.10.123 127.0.10.123:80 weight 10 check inter 1591 fall 2 rise 1
-	server 127.0.10.124 127.0.10.124:80 weight 10 check inter 3741 fall 2 rise 1
-	server 127.0.10.125 127.0.10.125:80 weight 10 check inter 5429 fall 2 rise 1
-	server 127.0.10.126 127.0.10.126:80 weight 10 check inter 889 fall 2 rise 1
-	server 127.0.10.127 127.0.10.127:80 weight 10 check inter 7081 fall 2 rise 1
-	server 127.0.10.128 127.0.10.128:80 weight 10 check inter 5417 fall 2 rise 1
-	server 127.0.10.129 127.0.10.129:80 weight 10 check inter 8453 fall 2 rise 1
-	server 127.0.10.130 127.0.10.130:80 weight 10 check inter 9104 fall 2 rise 1
-	server 127.0.10.131 127.0.10.131:80 weight 10 check inter 7099 fall 2 rise 1
-	server 127.0.10.132 127.0.10.132:80 weight 10 check inter 5778 fall 2 rise 1
-	server 127.0.10.133 127.0.10.133:80 weight 10 check inter 708 fall 2 rise 1
-	server 127.0.10.134 127.0.10.134:80 weight 10 check inter 6602 fall 2 rise 1
-	server 127.0.10.135 127.0.10.135:80 weight 10 check inter 4190 fall 2 rise 1
-	server 127.0.10.136 127.0.10.136:80 weight 10 check inter 4978 fall 2 rise 1
-	server 127.0.10.137 127.0.10.137:80 weight 10 check inter 2676 fall 2 rise 1
-	server 127.0.10.138 127.0.10.138:80 weight 10 check inter 157 fall 2 rise 1
-	server 127.0.10.139 127.0.10.139:80 weight 10 check inter 5498 fall 2 rise 1
-	server 127.0.10.140 127.0.10.140:80 weight 10 check inter 9886 fall 2 rise 1
-	server 127.0.10.141 127.0.10.141:80 weight 10 check inter 7887 fall 2 rise 1
-	server 127.0.10.142 127.0.10.142:80 weight 10 check inter 7218 fall 2 rise 1
-	server 127.0.10.143 127.0.10.143:80 weight 10 check inter 8458 fall 2 rise 1
-	server 127.0.10.144 127.0.10.144:80 weight 10 check inter 9771 fall 2 rise 1
-	server 127.0.10.145 127.0.10.145:80 weight 10 check inter 363 fall 2 rise 1
-	server 127.0.10.146 127.0.10.146:80 weight 10 check inter 3461 fall 2 rise 1
-	server 127.0.10.147 127.0.10.147:80 weight 10 check inter 1734 fall 2 rise 1
-	server 127.0.10.148 127.0.10.148:80 weight 10 check inter 3332 fall 2 rise 1
-	server 127.0.10.149 127.0.10.149:80 weight 10 check inter 32 fall 2 rise 1
-	server 127.0.10.150 127.0.10.150:80 weight 10 check inter 1599 fall 2 rise 1
-	server 127.0.10.151 127.0.10.151:80 weight 10 check inter 805 fall 2 rise 1
-	server 127.0.10.152 127.0.10.152:80 weight 10 check inter 2006 fall 2 rise 1
-	server 127.0.10.153 127.0.10.153:80 weight 10 check inter 8074 fall 2 rise 1
-	server 127.0.10.154 127.0.10.154:80 weight 10 check inter 5683 fall 2 rise 1
-	server 127.0.10.155 127.0.10.155:80 weight 10 check inter 9391 fall 2 rise 1
-	server 127.0.10.156 127.0.10.156:80 weight 10 check inter 4065 fall 2 rise 1
-	server 127.0.10.157 127.0.10.157:80 weight 10 check inter 3389 fall 2 rise 1
-	server 127.0.10.158 127.0.10.158:80 weight 10 check inter 2298 fall 2 rise 1
-	server 127.0.10.159 127.0.10.159:80 weight 10 check inter 4004 fall 2 rise 1
-	server 127.0.10.160 127.0.10.160:80 weight 10 check inter 2527 fall 2 rise 1
-	server 127.0.10.161 127.0.10.161:80 weight 10 check inter 5372 fall 2 rise 1
-	server 127.0.10.162 127.0.10.162:80 weight 10 check inter 4750 fall 2 rise 1
-	server 127.0.10.163 127.0.10.163:80 weight 10 check inter 927 fall 2 rise 1
-	server 127.0.10.164 127.0.10.164:80 weight 10 check inter 9442 fall 2 rise 1
-	server 127.0.10.165 127.0.10.165:80 weight 10 check inter 6487 fall 2 rise 1
-	server 127.0.10.166 127.0.10.166:80 weight 10 check inter 2553 fall 2 rise 1
-	server 127.0.10.167 127.0.10.167:80 weight 10 check inter 5847 fall 2 rise 1
-	server 127.0.10.168 127.0.10.168:80 weight 10 check inter 2176 fall 2 rise 1
-	server 127.0.10.169 127.0.10.169:80 weight 10 check inter 919 fall 2 rise 1
-	server 127.0.10.170 127.0.10.170:80 weight 10 check inter 1404 fall 2 rise 1
-	server 127.0.10.171 127.0.10.171:80 weight 10 check inter 5915 fall 2 rise 1
-	server 127.0.10.172 127.0.10.172:80 weight 10 check inter 7005 fall 2 rise 1
-	server 127.0.10.173 127.0.10.173:80 weight 10 check inter 6619 fall 2 rise 1
-	server 127.0.10.174 127.0.10.174:80 weight 10 check inter 3022 fall 2 rise 1
-	server 127.0.10.175 127.0.10.175:80 weight 10 check inter 1211 fall 2 rise 1
-	server 127.0.10.176 127.0.10.176:80 weight 10 check inter 5836 fall 2 rise 1
-	server 127.0.10.177 127.0.10.177:80 weight 10 check inter 417 fall 2 rise 1
-	server 127.0.10.178 127.0.10.178:80 weight 10 check inter 43 fall 2 rise 1
-	server 127.0.10.179 127.0.10.179:80 weight 10 check inter 3095 fall 2 rise 1
-	server 127.0.10.180 127.0.10.180:80 weight 10 check inter 2245 fall 2 rise 1
-	server 127.0.10.181 127.0.10.181:80 weight 10 check inter 7987 fall 2 rise 1
-	server 127.0.10.182 127.0.10.182:80 weight 10 check inter 9960 fall 2 rise 1
-	server 127.0.10.183 127.0.10.183:80 weight 10 check inter 3640 fall 2 rise 1
-	server 127.0.10.184 127.0.10.184:80 weight 10 check inter 69 fall 2 rise 1
-	server 127.0.10.185 127.0.10.185:80 weight 10 check inter 1111 fall 2 rise 1
-	server 127.0.10.186 127.0.10.186:80 weight 10 check inter 1463 fall 2 rise 1
-	server 127.0.10.187 127.0.10.187:80 weight 10 check inter 1488 fall 2 rise 1
-	server 127.0.10.188 127.0.10.188:80 weight 10 check inter 2265 fall 2 rise 1
-	server 127.0.10.189 127.0.10.189:80 weight 10 check inter 2757 fall 2 rise 1
-	server 127.0.10.190 127.0.10.190:80 weight 10 check inter 7151 fall 2 rise 1
-	server 127.0.10.191 127.0.10.191:80 weight 10 check inter 2611 fall 2 rise 1
-	server 127.0.10.192 127.0.10.192:80 weight 10 check inter 5576 fall 2 rise 1
-	server 127.0.10.193 127.0.10.193:80 weight 10 check inter 8774 fall 2 rise 1
-	server 127.0.10.194 127.0.10.194:80 weight 10 check inter 8905 fall 2 rise 1
-	server 127.0.10.195 127.0.10.195:80 weight 10 check inter 7650 fall 2 rise 1
-	server 127.0.10.196 127.0.10.196:80 weight 10 check inter 9811 fall 2 rise 1
-	server 127.0.10.197 127.0.10.197:80 weight 10 check inter 5472 fall 2 rise 1
-	server 127.0.10.198 127.0.10.198:80 weight 10 check inter 5898 fall 2 rise 1
-	server 127.0.10.199 127.0.10.199:80 weight 10 check inter 2459 fall 2 rise 1
-	server 127.0.10.200 127.0.10.200:80 weight 10 check inter 30 fall 2 rise 1
-	server 127.0.10.201 127.0.10.201:80 weight 10 check inter 180 fall 2 rise 1
-	server 127.0.10.202 127.0.10.202:80 weight 10 check inter 4292 fall 2 rise 1
-	server 127.0.10.203 127.0.10.203:80 weight 10 check inter 4130 fall 2 rise 1
-	server 127.0.10.204 127.0.10.204:80 weight 10 check inter 443 fall 2 rise 1
-	server 127.0.10.205 127.0.10.205:80 weight 10 check inter 9764 fall 2 rise 1
-	server 127.0.10.206 127.0.10.206:80 weight 10 check inter 8139 fall 2 rise 1
-	server 127.0.10.207 127.0.10.207:80 weight 10 check inter 6989 fall 2 rise 1
-	server 127.0.10.208 127.0.10.208:80 weight 10 check inter 1723 fall 2 rise 1
-	server 127.0.10.209 127.0.10.209:80 weight 10 check inter 6805 fall 2 rise 1
-	server 127.0.10.210 127.0.10.210:80 weight 10 check inter 3768 fall 2 rise 1
-	server 127.0.10.211 127.0.10.211:80 weight 10 check inter 9602 fall 2 rise 1
-	server 127.0.10.212 127.0.10.212:80 weight 10 check inter 515 fall 2 rise 1
-	server 127.0.10.213 127.0.10.213:80 weight 10 check inter 729 fall 2 rise 1
-	server 127.0.10.214 127.0.10.214:80 weight 10 check inter 8863 fall 2 rise 1
-	server 127.0.10.215 127.0.10.215:80 weight 10 check inter 2978 fall 2 rise 1
-	server 127.0.10.216 127.0.10.216:80 weight 10 check inter 7600 fall 2 rise 1
-	server 127.0.10.217 127.0.10.217:80 weight 10 check inter 2505 fall 2 rise 1
-	server 127.0.10.218 127.0.10.218:80 weight 10 check inter 6368 fall 2 rise 1
-	server 127.0.10.219 127.0.10.219:80 weight 10 check inter 6370 fall 2 rise 1
-	server 127.0.10.220 127.0.10.220:80 weight 10 check inter 2315 fall 2 rise 1
-	server 127.0.10.221 127.0.10.221:80 weight 10 check inter 6213 fall 2 rise 1
-	server 127.0.10.222 127.0.10.222:80 weight 10 check inter 2113 fall 2 rise 1
-	server 127.0.10.223 127.0.10.223:80 weight 10 check inter 1053 fall 2 rise 1
-	server 127.0.10.224 127.0.10.224:80 weight 10 check inter 4250 fall 2 rise 1
-	server 127.0.10.225 127.0.10.225:80 weight 10 check inter 7323 fall 2 rise 1
-	server 127.0.10.226 127.0.10.226:80 weight 10 check inter 9670 fall 2 rise 1
-	server 127.0.10.227 127.0.10.227:80 weight 10 check inter 6764 fall 2 rise 1
-	server 127.0.10.228 127.0.10.228:80 weight 10 check inter 8317 fall 2 rise 1
-	server 127.0.10.229 127.0.10.229:80 weight 10 check inter 4840 fall 2 rise 1
-	server 127.0.10.230 127.0.10.230:80 weight 10 check inter 2438 fall 2 rise 1
-	server 127.0.10.231 127.0.10.231:80 weight 10 check inter 2704 fall 2 rise 1
-	server 127.0.10.232 127.0.10.232:80 weight 10 check inter 7123 fall 2 rise 1
-	server 127.0.10.233 127.0.10.233:80 weight 10 check inter 8674 fall 2 rise 1
-	server 127.0.10.234 127.0.10.234:80 weight 10 check inter 1965 fall 2 rise 1
-	server 127.0.10.235 127.0.10.235:80 weight 10 check inter 9685 fall 2 rise 1
-	server 127.0.10.236 127.0.10.236:80 weight 10 check inter 1968 fall 2 rise 1
-	server 127.0.10.237 127.0.10.237:80 weight 10 check inter 8033 fall 2 rise 1
-	server 127.0.10.238 127.0.10.238:80 weight 10 check inter 5472 fall 2 rise 1
-	server 127.0.10.239 127.0.10.239:80 weight 10 check inter 9574 fall 2 rise 1
-	server 127.0.10.240 127.0.10.240:80 weight 10 check inter 2879 fall 2 rise 1
-	server 127.0.10.241 127.0.10.241:80 weight 10 check inter 5265 fall 2 rise 1
-	server 127.0.10.242 127.0.10.242:80 weight 10 check inter 3556 fall 2 rise 1
-	server 127.0.10.243 127.0.10.243:80 weight 10 check inter 2656 fall 2 rise 1
-	server 127.0.10.244 127.0.10.244:80 weight 10 check inter 982 fall 2 rise 1
-	server 127.0.10.245 127.0.10.245:80 weight 10 check inter 4313 fall 2 rise 1
-	server 127.0.10.246 127.0.10.246:80 weight 10 check inter 6733 fall 2 rise 1
-	server 127.0.10.247 127.0.10.247:80 weight 10 check inter 5049 fall 2 rise 1
-	server 127.0.10.248 127.0.10.248:80 weight 10 check inter 9791 fall 2 rise 1
-	server 127.0.10.249 127.0.10.249:80 weight 10 check inter 8392 fall 2 rise 1
-	server 127.0.10.250 127.0.10.250:80 weight 10 check inter 743 fall 2 rise 1
-	server 127.0.11.001 127.0.11.1:80 weight 10 check inter 7405 fall 2 rise 1
-	server 127.0.11.002 127.0.11.2:80 weight 10 check inter 5472 fall 2 rise 1
-	server 127.0.11.003 127.0.11.3:80 weight 10 check inter 9733 fall 2 rise 1
-	server 127.0.11.004 127.0.11.4:80 weight 10 check inter 4631 fall 2 rise 1
-	server 127.0.11.005 127.0.11.5:80 weight 10 check inter 1515 fall 2 rise 1
-	server 127.0.11.006 127.0.11.6:80 weight 10 check inter 6367 fall 2 rise 1
-	server 127.0.11.007 127.0.11.7:80 weight 10 check inter 1059 fall 2 rise 1
-	server 127.0.11.008 127.0.11.8:80 weight 10 check inter 2319 fall 2 rise 1
-	server 127.0.11.009 127.0.11.9:80 weight 10 check inter 2644 fall 2 rise 1
-	server 127.0.11.010 127.0.11.10:80 weight 10 check inter 3671 fall 2 rise 1
-	server 127.0.11.011 127.0.11.11:80 weight 10 check inter 3990 fall 2 rise 1
-	server 127.0.11.012 127.0.11.12:80 weight 10 check inter 3220 fall 2 rise 1
-	server 127.0.11.013 127.0.11.13:80 weight 10 check inter 9295 fall 2 rise 1
-	server 127.0.11.014 127.0.11.14:80 weight 10 check inter 1865 fall 2 rise 1
-	server 127.0.11.015 127.0.11.15:80 weight 10 check inter 9384 fall 2 rise 1
-	server 127.0.11.016 127.0.11.16:80 weight 10 check inter 1967 fall 2 rise 1
-	server 127.0.11.017 127.0.11.17:80 weight 10 check inter 2540 fall 2 rise 1
-	server 127.0.11.018 127.0.11.18:80 weight 10 check inter 4019 fall 2 rise 1
-	server 127.0.11.019 127.0.11.19:80 weight 10 check inter 6058 fall 2 rise 1
-	server 127.0.11.020 127.0.11.20:80 weight 10 check inter 9781 fall 2 rise 1
-	server 127.0.11.021 127.0.11.21:80 weight 10 check inter 4015 fall 2 rise 1
-	server 127.0.11.022 127.0.11.22:80 weight 10 check inter 3953 fall 2 rise 1
-	server 127.0.11.023 127.0.11.23:80 weight 10 check inter 1836 fall 2 rise 1
-	server 127.0.11.024 127.0.11.24:80 weight 10 check inter 3800 fall 2 rise 1
-	server 127.0.11.025 127.0.11.25:80 weight 10 check inter 6841 fall 2 rise 1
-	server 127.0.11.026 127.0.11.26:80 weight 10 check inter 2694 fall 2 rise 1
-	server 127.0.11.027 127.0.11.27:80 weight 10 check inter 8715 fall 2 rise 1
-	server 127.0.11.028 127.0.11.28:80 weight 10 check inter 9 fall 2 rise 1
-	server 127.0.11.029 127.0.11.29:80 weight 10 check inter 6277 fall 2 rise 1
-	server 127.0.11.030 127.0.11.30:80 weight 10 check inter 2729 fall 2 rise 1
-	server 127.0.11.031 127.0.11.31:80 weight 10 check inter 4141 fall 2 rise 1
-	server 127.0.11.032 127.0.11.32:80 weight 10 check inter 9332 fall 2 rise 1
-	server 127.0.11.033 127.0.11.33:80 weight 10 check inter 2840 fall 2 rise 1
-	server 127.0.11.034 127.0.11.34:80 weight 10 check inter 896 fall 2 rise 1
-	server 127.0.11.035 127.0.11.35:80 weight 10 check inter 7677 fall 2 rise 1
-	server 127.0.11.036 127.0.11.36:80 weight 10 check inter 5705 fall 2 rise 1
-	server 127.0.11.037 127.0.11.37:80 weight 10 check inter 4677 fall 2 rise 1
-	server 127.0.11.038 127.0.11.38:80 weight 10 check inter 6797 fall 2 rise 1
-	server 127.0.11.039 127.0.11.39:80 weight 10 check inter 7559 fall 2 rise 1
-	server 127.0.11.040 127.0.11.40:80 weight 10 check inter 2060 fall 2 rise 1
-	server 127.0.11.041 127.0.11.41:80 weight 10 check inter 1779 fall 2 rise 1
-	server 127.0.11.042 127.0.11.42:80 weight 10 check inter 795 fall 2 rise 1
-	server 127.0.11.043 127.0.11.43:80 weight 10 check inter 6242 fall 2 rise 1
-	server 127.0.11.044 127.0.11.44:80 weight 10 check inter 5612 fall 2 rise 1
-	server 127.0.11.045 127.0.11.45:80 weight 10 check inter 6207 fall 2 rise 1
-	server 127.0.11.046 127.0.11.46:80 weight 10 check inter 5255 fall 2 rise 1
-	server 127.0.11.047 127.0.11.47:80 weight 10 check inter 6672 fall 2 rise 1
-	server 127.0.11.048 127.0.11.48:80 weight 10 check inter 3476 fall 2 rise 1
-	server 127.0.11.049 127.0.11.49:80 weight 10 check inter 2001 fall 2 rise 1
-	server 127.0.11.050 127.0.11.50:80 weight 10 check inter 6318 fall 2 rise 1
-	server 127.0.11.051 127.0.11.51:80 weight 10 check inter 3464 fall 2 rise 1
-	server 127.0.11.052 127.0.11.52:80 weight 10 check inter 1075 fall 2 rise 1
-	server 127.0.11.053 127.0.11.53:80 weight 10 check inter 6624 fall 2 rise 1
-	server 127.0.11.054 127.0.11.54:80 weight 10 check inter 1114 fall 2 rise 1
-	server 127.0.11.055 127.0.11.55:80 weight 10 check inter 3934 fall 2 rise 1
-	server 127.0.11.056 127.0.11.56:80 weight 10 check inter 4987 fall 2 rise 1
-	server 127.0.11.057 127.0.11.57:80 weight 10 check inter 8852 fall 2 rise 1
-	server 127.0.11.058 127.0.11.58:80 weight 10 check inter 6444 fall 2 rise 1
-	server 127.0.11.059 127.0.11.59:80 weight 10 check inter 599 fall 2 rise 1
-	server 127.0.11.060 127.0.11.60:80 weight 10 check inter 1451 fall 2 rise 1
-	server 127.0.11.061 127.0.11.61:80 weight 10 check inter 5424 fall 2 rise 1
-	server 127.0.11.062 127.0.11.62:80 weight 10 check inter 3400 fall 2 rise 1
-	server 127.0.11.063 127.0.11.63:80 weight 10 check inter 2030 fall 2 rise 1
-	server 127.0.11.064 127.0.11.64:80 weight 10 check inter 1278 fall 2 rise 1
-	server 127.0.11.065 127.0.11.65:80 weight 10 check inter 5803 fall 2 rise 1
-	server 127.0.11.066 127.0.11.66:80 weight 10 check inter 563 fall 2 rise 1
-	server 127.0.11.067 127.0.11.67:80 weight 10 check inter 3861 fall 2 rise 1
-	server 127.0.11.068 127.0.11.68:80 weight 10 check inter 7120 fall 2 rise 1
-	server 127.0.11.069 127.0.11.69:80 weight 10 check inter 2483 fall 2 rise 1
-	server 127.0.11.070 127.0.11.70:80 weight 10 check inter 1310 fall 2 rise 1
-	server 127.0.11.071 127.0.11.71:80 weight 10 check inter 5773 fall 2 rise 1
-	server 127.0.11.072 127.0.11.72:80 weight 10 check inter 8500 fall 2 rise 1
-	server 127.0.11.073 127.0.11.73:80 weight 10 check inter 3840 fall 2 rise 1
-	server 127.0.11.074 127.0.11.74:80 weight 10 check inter 815 fall 2 rise 1
-	server 127.0.11.075 127.0.11.75:80 weight 10 check inter 1604 fall 2 rise 1
-	server 127.0.11.076 127.0.11.76:80 weight 10 check inter 9463 fall 2 rise 1
-	server 127.0.11.077 127.0.11.77:80 weight 10 check inter 8682 fall 2 rise 1
-	server 127.0.11.078 127.0.11.78:80 weight 10 check inter 6420 fall 2 rise 1
-	server 127.0.11.079 127.0.11.79:80 weight 10 check inter 9666 fall 2 rise 1
-	server 127.0.11.080 127.0.11.80:80 weight 10 check inter 8369 fall 2 rise 1
-	server 127.0.11.081 127.0.11.81:80 weight 10 check inter 7786 fall 2 rise 1
-	server 127.0.11.082 127.0.11.82:80 weight 10 check inter 9255 fall 2 rise 1
-	server 127.0.11.083 127.0.11.83:80 weight 10 check inter 3793 fall 2 rise 1
-	server 127.0.11.084 127.0.11.84:80 weight 10 check inter 7377 fall 2 rise 1
-	server 127.0.11.085 127.0.11.85:80 weight 10 check inter 4976 fall 2 rise 1
-	server 127.0.11.086 127.0.11.86:80 weight 10 check inter 1424 fall 2 rise 1
-	server 127.0.11.087 127.0.11.87:80 weight 10 check inter 975 fall 2 rise 1
-	server 127.0.11.088 127.0.11.88:80 weight 10 check inter 5845 fall 2 rise 1
-	server 127.0.11.089 127.0.11.89:80 weight 10 check inter 7498 fall 2 rise 1
-	server 127.0.11.090 127.0.11.90:80 weight 10 check inter 6461 fall 2 rise 1
-	server 127.0.11.091 127.0.11.91:80 weight 10 check inter 1621 fall 2 rise 1
-	server 127.0.11.092 127.0.11.92:80 weight 10 check inter 9068 fall 2 rise 1
-	server 127.0.11.093 127.0.11.93:80 weight 10 check inter 1440 fall 2 rise 1
-	server 127.0.11.094 127.0.11.94:80 weight 10 check inter 306 fall 2 rise 1
-	server 127.0.11.095 127.0.11.95:80 weight 10 check inter 1877 fall 2 rise 1
-	server 127.0.11.096 127.0.11.96:80 weight 10 check inter 1197 fall 2 rise 1
-	server 127.0.11.097 127.0.11.97:80 weight 10 check inter 9840 fall 2 rise 1
-	server 127.0.11.098 127.0.11.98:80 weight 10 check inter 4353 fall 2 rise 1
-	server 127.0.11.099 127.0.11.99:80 weight 10 check inter 8790 fall 2 rise 1
-	server 127.0.11.100 127.0.11.100:80 weight 10 check inter 4212 fall 2 rise 1
-	server 127.0.11.101 127.0.11.101:80 weight 10 check inter 908 fall 2 rise 1
-	server 127.0.11.102 127.0.11.102:80 weight 10 check inter 5496 fall 2 rise 1
-	server 127.0.11.103 127.0.11.103:80 weight 10 check inter 6655 fall 2 rise 1
-	server 127.0.11.104 127.0.11.104:80 weight 10 check inter 5647 fall 2 rise 1
-	server 127.0.11.105 127.0.11.105:80 weight 10 check inter 5077 fall 2 rise 1
-	server 127.0.11.106 127.0.11.106:80 weight 10 check inter 9373 fall 2 rise 1
-	server 127.0.11.107 127.0.11.107:80 weight 10 check inter 5077 fall 2 rise 1
-	server 127.0.11.108 127.0.11.108:80 weight 10 check inter 6476 fall 2 rise 1
-	server 127.0.11.109 127.0.11.109:80 weight 10 check inter 7685 fall 2 rise 1
-	server 127.0.11.110 127.0.11.110:80 weight 10 check inter 9850 fall 2 rise 1
-	server 127.0.11.111 127.0.11.111:80 weight 10 check inter 6100 fall 2 rise 1
-	server 127.0.11.112 127.0.11.112:80 weight 10 check inter 5696 fall 2 rise 1
-	server 127.0.11.113 127.0.11.113:80 weight 10 check inter 1728 fall 2 rise 1
-	server 127.0.11.114 127.0.11.114:80 weight 10 check inter 7736 fall 2 rise 1
-	server 127.0.11.115 127.0.11.115:80 weight 10 check inter 4511 fall 2 rise 1
-	server 127.0.11.116 127.0.11.116:80 weight 10 check inter 5799 fall 2 rise 1
-	server 127.0.11.117 127.0.11.117:80 weight 10 check inter 7913 fall 2 rise 1
-	server 127.0.11.118 127.0.11.118:80 weight 10 check inter 1772 fall 2 rise 1
-	server 127.0.11.119 127.0.11.119:80 weight 10 check inter 3752 fall 2 rise 1
-	server 127.0.11.120 127.0.11.120:80 weight 10 check inter 1200 fall 2 rise 1
-	server 127.0.11.121 127.0.11.121:80 weight 10 check inter 4771 fall 2 rise 1
-	server 127.0.11.122 127.0.11.122:80 weight 10 check inter 1492 fall 2 rise 1
-	server 127.0.11.123 127.0.11.123:80 weight 10 check inter 9054 fall 2 rise 1
-	server 127.0.11.124 127.0.11.124:80 weight 10 check inter 9956 fall 2 rise 1
-	server 127.0.11.125 127.0.11.125:80 weight 10 check inter 2846 fall 2 rise 1
-	server 127.0.11.126 127.0.11.126:80 weight 10 check inter 2849 fall 2 rise 1
-	server 127.0.11.127 127.0.11.127:80 weight 10 check inter 8265 fall 2 rise 1
-	server 127.0.11.128 127.0.11.128:80 weight 10 check inter 7034 fall 2 rise 1
-	server 127.0.11.129 127.0.11.129:80 weight 10 check inter 7837 fall 2 rise 1
-	server 127.0.11.130 127.0.11.130:80 weight 10 check inter 9426 fall 2 rise 1
-	server 127.0.11.131 127.0.11.131:80 weight 10 check inter 5191 fall 2 rise 1
-	server 127.0.11.132 127.0.11.132:80 weight 10 check inter 7563 fall 2 rise 1
-	server 127.0.11.133 127.0.11.133:80 weight 10 check inter 6121 fall 2 rise 1
-	server 127.0.11.134 127.0.11.134:80 weight 10 check inter 308 fall 2 rise 1
-	server 127.0.11.135 127.0.11.135:80 weight 10 check inter 9764 fall 2 rise 1
-	server 127.0.11.136 127.0.11.136:80 weight 10 check inter 214 fall 2 rise 1
-	server 127.0.11.137 127.0.11.137:80 weight 10 check inter 2152 fall 2 rise 1
-	server 127.0.11.138 127.0.11.138:80 weight 10 check inter 5547 fall 2 rise 1
-	server 127.0.11.139 127.0.11.139:80 weight 10 check inter 43 fall 2 rise 1
-	server 127.0.11.140 127.0.11.140:80 weight 10 check inter 6372 fall 2 rise 1
-	server 127.0.11.141 127.0.11.141:80 weight 10 check inter 5451 fall 2 rise 1
-	server 127.0.11.142 127.0.11.142:80 weight 10 check inter 4319 fall 2 rise 1
-	server 127.0.11.143 127.0.11.143:80 weight 10 check inter 1248 fall 2 rise 1
-	server 127.0.11.144 127.0.11.144:80 weight 10 check inter 6136 fall 2 rise 1
-	server 127.0.11.145 127.0.11.145:80 weight 10 check inter 538 fall 2 rise 1
-	server 127.0.11.146 127.0.11.146:80 weight 10 check inter 2871 fall 2 rise 1
-	server 127.0.11.147 127.0.11.147:80 weight 10 check inter 5305 fall 2 rise 1
-	server 127.0.11.148 127.0.11.148:80 weight 10 check inter 4238 fall 2 rise 1
-	server 127.0.11.149 127.0.11.149:80 weight 10 check inter 2768 fall 2 rise 1
-	server 127.0.11.150 127.0.11.150:80 weight 10 check inter 4406 fall 2 rise 1
-	server 127.0.11.151 127.0.11.151:80 weight 10 check inter 591 fall 2 rise 1
-	server 127.0.11.152 127.0.11.152:80 weight 10 check inter 1345 fall 2 rise 1
-	server 127.0.11.153 127.0.11.153:80 weight 10 check inter 2006 fall 2 rise 1
-	server 127.0.11.154 127.0.11.154:80 weight 10 check inter 9256 fall 2 rise 1
-	server 127.0.11.155 127.0.11.155:80 weight 10 check inter 697 fall 2 rise 1
-	server 127.0.11.156 127.0.11.156:80 weight 10 check inter 3690 fall 2 rise 1
-	server 127.0.11.157 127.0.11.157:80 weight 10 check inter 8353 fall 2 rise 1
-	server 127.0.11.158 127.0.11.158:80 weight 10 check inter 8555 fall 2 rise 1
-	server 127.0.11.159 127.0.11.159:80 weight 10 check inter 2691 fall 2 rise 1
-	server 127.0.11.160 127.0.11.160:80 weight 10 check inter 2204 fall 2 rise 1
-	server 127.0.11.161 127.0.11.161:80 weight 10 check inter 331 fall 2 rise 1
-	server 127.0.11.162 127.0.11.162:80 weight 10 check inter 846 fall 2 rise 1
-	server 127.0.11.163 127.0.11.163:80 weight 10 check inter 2480 fall 2 rise 1
-	server 127.0.11.164 127.0.11.164:80 weight 10 check inter 6848 fall 2 rise 1
-	server 127.0.11.165 127.0.11.165:80 weight 10 check inter 3858 fall 2 rise 1
-	server 127.0.11.166 127.0.11.166:80 weight 10 check inter 9290 fall 2 rise 1
-	server 127.0.11.167 127.0.11.167:80 weight 10 check inter 7732 fall 2 rise 1
-	server 127.0.11.168 127.0.11.168:80 weight 10 check inter 7776 fall 2 rise 1
-	server 127.0.11.169 127.0.11.169:80 weight 10 check inter 3842 fall 2 rise 1
-	server 127.0.11.170 127.0.11.170:80 weight 10 check inter 162 fall 2 rise 1
-	server 127.0.11.171 127.0.11.171:80 weight 10 check inter 7648 fall 2 rise 1
-	server 127.0.11.172 127.0.11.172:80 weight 10 check inter 4118 fall 2 rise 1
-	server 127.0.11.173 127.0.11.173:80 weight 10 check inter 8242 fall 2 rise 1
-	server 127.0.11.174 127.0.11.174:80 weight 10 check inter 7804 fall 2 rise 1
-	server 127.0.11.175 127.0.11.175:80 weight 10 check inter 1757 fall 2 rise 1
-	server 127.0.11.176 127.0.11.176:80 weight 10 check inter 306 fall 2 rise 1
-	server 127.0.11.177 127.0.11.177:80 weight 10 check inter 5809 fall 2 rise 1
-	server 127.0.11.178 127.0.11.178:80 weight 10 check inter 285 fall 2 rise 1
-	server 127.0.11.179 127.0.11.179:80 weight 10 check inter 5319 fall 2 rise 1
-	server 127.0.11.180 127.0.11.180:80 weight 10 check inter 5838 fall 2 rise 1
-	server 127.0.11.181 127.0.11.181:80 weight 10 check inter 5376 fall 2 rise 1
-	server 127.0.11.182 127.0.11.182:80 weight 10 check inter 9702 fall 2 rise 1
-	server 127.0.11.183 127.0.11.183:80 weight 10 check inter 5662 fall 2 rise 1
-	server 127.0.11.184 127.0.11.184:80 weight 10 check inter 5442 fall 2 rise 1
-	server 127.0.11.185 127.0.11.185:80 weight 10 check inter 8189 fall 2 rise 1
-	server 127.0.11.186 127.0.11.186:80 weight 10 check inter 913 fall 2 rise 1
-	server 127.0.11.187 127.0.11.187:80 weight 10 check inter 5502 fall 2 rise 1
-	server 127.0.11.188 127.0.11.188:80 weight 10 check inter 1702 fall 2 rise 1
-	server 127.0.11.189 127.0.11.189:80 weight 10 check inter 3474 fall 2 rise 1
-	server 127.0.11.190 127.0.11.190:80 weight 10 check inter 6474 fall 2 rise 1
-	server 127.0.11.191 127.0.11.191:80 weight 10 check inter 1417 fall 2 rise 1
-	server 127.0.11.192 127.0.11.192:80 weight 10 check inter 7291 fall 2 rise 1
-	server 127.0.11.193 127.0.11.193:80 weight 10 check inter 5505 fall 2 rise 1
-	server 127.0.11.194 127.0.11.194:80 weight 10 check inter 9261 fall 2 rise 1
-	server 127.0.11.195 127.0.11.195:80 weight 10 check inter 1225 fall 2 rise 1
-	server 127.0.11.196 127.0.11.196:80 weight 10 check inter 6984 fall 2 rise 1
-	server 127.0.11.197 127.0.11.197:80 weight 10 check inter 5582 fall 2 rise 1
-	server 127.0.11.198 127.0.11.198:80 weight 10 check inter 4114 fall 2 rise 1
-	server 127.0.11.199 127.0.11.199:80 weight 10 check inter 3496 fall 2 rise 1
-	server 127.0.11.200 127.0.11.200:80 weight 10 check inter 3846 fall 2 rise 1
-	server 127.0.11.201 127.0.11.201:80 weight 10 check inter 6570 fall 2 rise 1
-	server 127.0.11.202 127.0.11.202:80 weight 10 check inter 5787 fall 2 rise 1
-	server 127.0.11.203 127.0.11.203:80 weight 10 check inter 7419 fall 2 rise 1
-	server 127.0.11.204 127.0.11.204:80 weight 10 check inter 9306 fall 2 rise 1
-	server 127.0.11.205 127.0.11.205:80 weight 10 check inter 819 fall 2 rise 1
-	server 127.0.11.206 127.0.11.206:80 weight 10 check inter 7034 fall 2 rise 1
-	server 127.0.11.207 127.0.11.207:80 weight 10 check inter 3507 fall 2 rise 1
-	server 127.0.11.208 127.0.11.208:80 weight 10 check inter 3222 fall 2 rise 1
-	server 127.0.11.209 127.0.11.209:80 weight 10 check inter 9549 fall 2 rise 1
-	server 127.0.11.210 127.0.11.210:80 weight 10 check inter 1811 fall 2 rise 1
-	server 127.0.11.211 127.0.11.211:80 weight 10 check inter 4849 fall 2 rise 1
-	server 127.0.11.212 127.0.11.212:80 weight 10 check inter 62 fall 2 rise 1
-	server 127.0.11.213 127.0.11.213:80 weight 10 check inter 2831 fall 2 rise 1
-	server 127.0.11.214 127.0.11.214:80 weight 10 check inter 7861 fall 2 rise 1
-	server 127.0.11.215 127.0.11.215:80 weight 10 check inter 3436 fall 2 rise 1
-	server 127.0.11.216 127.0.11.216:80 weight 10 check inter 5354 fall 2 rise 1
-	server 127.0.11.217 127.0.11.217:80 weight 10 check inter 7181 fall 2 rise 1
-	server 127.0.11.218 127.0.11.218:80 weight 10 check inter 7671 fall 2 rise 1
-	server 127.0.11.219 127.0.11.219:80 weight 10 check inter 9109 fall 2 rise 1
-	server 127.0.11.220 127.0.11.220:80 weight 10 check inter 673 fall 2 rise 1
-	server 127.0.11.221 127.0.11.221:80 weight 10 check inter 4985 fall 2 rise 1
-	server 127.0.11.222 127.0.11.222:80 weight 10 check inter 4852 fall 2 rise 1
-	server 127.0.11.223 127.0.11.223:80 weight 10 check inter 1012 fall 2 rise 1
-	server 127.0.11.224 127.0.11.224:80 weight 10 check inter 4512 fall 2 rise 1
-	server 127.0.11.225 127.0.11.225:80 weight 10 check inter 888 fall 2 rise 1
-	server 127.0.11.226 127.0.11.226:80 weight 10 check inter 7686 fall 2 rise 1
-	server 127.0.11.227 127.0.11.227:80 weight 10 check inter 6987 fall 2 rise 1
-	server 127.0.11.228 127.0.11.228:80 weight 10 check inter 9213 fall 2 rise 1
-	server 127.0.11.229 127.0.11.229:80 weight 10 check inter 9558 fall 2 rise 1
-	server 127.0.11.230 127.0.11.230:80 weight 10 check inter 6276 fall 2 rise 1
-	server 127.0.11.231 127.0.11.231:80 weight 10 check inter 8598 fall 2 rise 1
-	server 127.0.11.232 127.0.11.232:80 weight 10 check inter 6639 fall 2 rise 1
-	server 127.0.11.233 127.0.11.233:80 weight 10 check inter 4409 fall 2 rise 1
-	server 127.0.11.234 127.0.11.234:80 weight 10 check inter 1196 fall 2 rise 1
-	server 127.0.11.235 127.0.11.235:80 weight 10 check inter 1109 fall 2 rise 1
-	server 127.0.11.236 127.0.11.236:80 weight 10 check inter 8473 fall 2 rise 1
-	server 127.0.11.237 127.0.11.237:80 weight 10 check inter 6438 fall 2 rise 1
-	server 127.0.11.238 127.0.11.238:80 weight 10 check inter 2399 fall 2 rise 1
-	server 127.0.11.239 127.0.11.239:80 weight 10 check inter 9290 fall 2 rise 1
-	server 127.0.11.240 127.0.11.240:80 weight 10 check inter 9834 fall 2 rise 1
-	server 127.0.11.241 127.0.11.241:80 weight 10 check inter 3110 fall 2 rise 1
-	server 127.0.11.242 127.0.11.242:80 weight 10 check inter 9951 fall 2 rise 1
-	server 127.0.11.243 127.0.11.243:80 weight 10 check inter 1952 fall 2 rise 1
-	server 127.0.11.244 127.0.11.244:80 weight 10 check inter 7158 fall 2 rise 1
-	server 127.0.11.245 127.0.11.245:80 weight 10 check inter 9030 fall 2 rise 1
-	server 127.0.11.246 127.0.11.246:80 weight 10 check inter 1673 fall 2 rise 1
-	server 127.0.11.247 127.0.11.247:80 weight 10 check inter 4225 fall 2 rise 1
-	server 127.0.11.248 127.0.11.248:80 weight 10 check inter 4578 fall 2 rise 1
-	server 127.0.11.249 127.0.11.249:80 weight 10 check inter 4961 fall 2 rise 1
-	server 127.0.11.250 127.0.11.250:80 weight 10 check inter 8641 fall 2 rise 1
-	server 127.0.12.001 127.0.12.1:80 weight 10 check inter 6614 fall 2 rise 1
-	server 127.0.12.002 127.0.12.2:80 weight 10 check inter 8066 fall 2 rise 1
-	server 127.0.12.003 127.0.12.3:80 weight 10 check inter 8157 fall 2 rise 1
-	server 127.0.12.004 127.0.12.4:80 weight 10 check inter 3458 fall 2 rise 1
-	server 127.0.12.005 127.0.12.5:80 weight 10 check inter 6653 fall 2 rise 1
-	server 127.0.12.006 127.0.12.6:80 weight 10 check inter 6019 fall 2 rise 1
-	server 127.0.12.007 127.0.12.7:80 weight 10 check inter 4424 fall 2 rise 1
-	server 127.0.12.008 127.0.12.8:80 weight 10 check inter 6419 fall 2 rise 1
-	server 127.0.12.009 127.0.12.9:80 weight 10 check inter 2012 fall 2 rise 1
-	server 127.0.12.010 127.0.12.10:80 weight 10 check inter 5559 fall 2 rise 1
-	server 127.0.12.011 127.0.12.11:80 weight 10 check inter 1473 fall 2 rise 1
-	server 127.0.12.012 127.0.12.12:80 weight 10 check inter 2632 fall 2 rise 1
-	server 127.0.12.013 127.0.12.13:80 weight 10 check inter 6584 fall 2 rise 1
-	server 127.0.12.014 127.0.12.14:80 weight 10 check inter 7699 fall 2 rise 1
-	server 127.0.12.015 127.0.12.15:80 weight 10 check inter 775 fall 2 rise 1
-	server 127.0.12.016 127.0.12.16:80 weight 10 check inter 8606 fall 2 rise 1
-	server 127.0.12.017 127.0.12.17:80 weight 10 check inter 2692 fall 2 rise 1
-	server 127.0.12.018 127.0.12.18:80 weight 10 check inter 11 fall 2 rise 1
-	server 127.0.12.019 127.0.12.19:80 weight 10 check inter 2386 fall 2 rise 1
-	server 127.0.12.020 127.0.12.20:80 weight 10 check inter 9652 fall 2 rise 1
-	server 127.0.12.021 127.0.12.21:80 weight 10 check inter 6666 fall 2 rise 1
-	server 127.0.12.022 127.0.12.22:80 weight 10 check inter 6728 fall 2 rise 1
-	server 127.0.12.023 127.0.12.23:80 weight 10 check inter 8259 fall 2 rise 1
-	server 127.0.12.024 127.0.12.24:80 weight 10 check inter 26 fall 2 rise 1
-	server 127.0.12.025 127.0.12.25:80 weight 10 check inter 299 fall 2 rise 1
-	server 127.0.12.026 127.0.12.26:80 weight 10 check inter 927 fall 2 rise 1
-	server 127.0.12.027 127.0.12.27:80 weight 10 check inter 8060 fall 2 rise 1
-	server 127.0.12.028 127.0.12.28:80 weight 10 check inter 9290 fall 2 rise 1
-	server 127.0.12.029 127.0.12.29:80 weight 10 check inter 8646 fall 2 rise 1
-	server 127.0.12.030 127.0.12.30:80 weight 10 check inter 6546 fall 2 rise 1
-	server 127.0.12.031 127.0.12.31:80 weight 10 check inter 7919 fall 2 rise 1
-	server 127.0.12.032 127.0.12.32:80 weight 10 check inter 4681 fall 2 rise 1
-	server 127.0.12.033 127.0.12.33:80 weight 10 check inter 2569 fall 2 rise 1
-	server 127.0.12.034 127.0.12.34:80 weight 10 check inter 7666 fall 2 rise 1
-	server 127.0.12.035 127.0.12.35:80 weight 10 check inter 3992 fall 2 rise 1
-	server 127.0.12.036 127.0.12.36:80 weight 10 check inter 2956 fall 2 rise 1
-	server 127.0.12.037 127.0.12.37:80 weight 10 check inter 6587 fall 2 rise 1
-	server 127.0.12.038 127.0.12.38:80 weight 10 check inter 8363 fall 2 rise 1
-	server 127.0.12.039 127.0.12.39:80 weight 10 check inter 8937 fall 2 rise 1
-	server 127.0.12.040 127.0.12.40:80 weight 10 check inter 7498 fall 2 rise 1
-	server 127.0.12.041 127.0.12.41:80 weight 10 check inter 2470 fall 2 rise 1
-	server 127.0.12.042 127.0.12.42:80 weight 10 check inter 6061 fall 2 rise 1
-	server 127.0.12.043 127.0.12.43:80 weight 10 check inter 2121 fall 2 rise 1
-	server 127.0.12.044 127.0.12.44:80 weight 10 check inter 5398 fall 2 rise 1
-	server 127.0.12.045 127.0.12.45:80 weight 10 check inter 5141 fall 2 rise 1
-	server 127.0.12.046 127.0.12.46:80 weight 10 check inter 9579 fall 2 rise 1
-	server 127.0.12.047 127.0.12.47:80 weight 10 check inter 9500 fall 2 rise 1
-	server 127.0.12.048 127.0.12.48:80 weight 10 check inter 281 fall 2 rise 1
-	server 127.0.12.049 127.0.12.49:80 weight 10 check inter 1761 fall 2 rise 1
-	server 127.0.12.050 127.0.12.50:80 weight 10 check inter 326 fall 2 rise 1
-	server 127.0.12.051 127.0.12.51:80 weight 10 check inter 1680 fall 2 rise 1
-	server 127.0.12.052 127.0.12.52:80 weight 10 check inter 8833 fall 2 rise 1
-	server 127.0.12.053 127.0.12.53:80 weight 10 check inter 6268 fall 2 rise 1
-	server 127.0.12.054 127.0.12.54:80 weight 10 check inter 3192 fall 2 rise 1
-	server 127.0.12.055 127.0.12.55:80 weight 10 check inter 6109 fall 2 rise 1
-	server 127.0.12.056 127.0.12.56:80 weight 10 check inter 8028 fall 2 rise 1
-	server 127.0.12.057 127.0.12.57:80 weight 10 check inter 4089 fall 2 rise 1
-	server 127.0.12.058 127.0.12.58:80 weight 10 check inter 3184 fall 2 rise 1
-	server 127.0.12.059 127.0.12.59:80 weight 10 check inter 810 fall 2 rise 1
-	server 127.0.12.060 127.0.12.60:80 weight 10 check inter 9762 fall 2 rise 1
-	server 127.0.12.061 127.0.12.61:80 weight 10 check inter 7617 fall 2 rise 1
-	server 127.0.12.062 127.0.12.62:80 weight 10 check inter 9088 fall 2 rise 1
-	server 127.0.12.063 127.0.12.63:80 weight 10 check inter 4560 fall 2 rise 1
-	server 127.0.12.064 127.0.12.64:80 weight 10 check inter 1157 fall 2 rise 1
-	server 127.0.12.065 127.0.12.65:80 weight 10 check inter 983 fall 2 rise 1
-	server 127.0.12.066 127.0.12.66:80 weight 10 check inter 8504 fall 2 rise 1
-	server 127.0.12.067 127.0.12.67:80 weight 10 check inter 287 fall 2 rise 1
-	server 127.0.12.068 127.0.12.68:80 weight 10 check inter 6602 fall 2 rise 1
-	server 127.0.12.069 127.0.12.69:80 weight 10 check inter 6598 fall 2 rise 1
-	server 127.0.12.070 127.0.12.70:80 weight 10 check inter 8032 fall 2 rise 1
-	server 127.0.12.071 127.0.12.71:80 weight 10 check inter 2130 fall 2 rise 1
-	server 127.0.12.072 127.0.12.72:80 weight 10 check inter 6405 fall 2 rise 1
-	server 127.0.12.073 127.0.12.73:80 weight 10 check inter 9520 fall 2 rise 1
-	server 127.0.12.074 127.0.12.74:80 weight 10 check inter 7079 fall 2 rise 1
-	server 127.0.12.075 127.0.12.75:80 weight 10 check inter 5252 fall 2 rise 1
-	server 127.0.12.076 127.0.12.76:80 weight 10 check inter 9382 fall 2 rise 1
-	server 127.0.12.077 127.0.12.77:80 weight 10 check inter 6725 fall 2 rise 1
-	server 127.0.12.078 127.0.12.78:80 weight 10 check inter 8159 fall 2 rise 1
-	server 127.0.12.079 127.0.12.79:80 weight 10 check inter 6527 fall 2 rise 1
-	server 127.0.12.080 127.0.12.80:80 weight 10 check inter 1925 fall 2 rise 1
-	server 127.0.12.081 127.0.12.81:80 weight 10 check inter 1205 fall 2 rise 1
-	server 127.0.12.082 127.0.12.82:80 weight 10 check inter 9381 fall 2 rise 1
-	server 127.0.12.083 127.0.12.83:80 weight 10 check inter 8600 fall 2 rise 1
-	server 127.0.12.084 127.0.12.84:80 weight 10 check inter 878 fall 2 rise 1
-	server 127.0.12.085 127.0.12.85:80 weight 10 check inter 4566 fall 2 rise 1
-	server 127.0.12.086 127.0.12.86:80 weight 10 check inter 145 fall 2 rise 1
-	server 127.0.12.087 127.0.12.87:80 weight 10 check inter 8188 fall 2 rise 1
-	server 127.0.12.088 127.0.12.88:80 weight 10 check inter 1693 fall 2 rise 1
-	server 127.0.12.089 127.0.12.89:80 weight 10 check inter 5908 fall 2 rise 1
-	server 127.0.12.090 127.0.12.90:80 weight 10 check inter 9298 fall 2 rise 1
-	server 127.0.12.091 127.0.12.91:80 weight 10 check inter 6664 fall 2 rise 1
-	server 127.0.12.092 127.0.12.92:80 weight 10 check inter 3656 fall 2 rise 1
-	server 127.0.12.093 127.0.12.93:80 weight 10 check inter 3436 fall 2 rise 1
-	server 127.0.12.094 127.0.12.94:80 weight 10 check inter 9974 fall 2 rise 1
-	server 127.0.12.095 127.0.12.95:80 weight 10 check inter 1035 fall 2 rise 1
-	server 127.0.12.096 127.0.12.96:80 weight 10 check inter 6879 fall 2 rise 1
-	server 127.0.12.097 127.0.12.97:80 weight 10 check inter 7015 fall 2 rise 1
-	server 127.0.12.098 127.0.12.98:80 weight 10 check inter 5932 fall 2 rise 1
-	server 127.0.12.099 127.0.12.99:80 weight 10 check inter 3341 fall 2 rise 1
-	server 127.0.12.100 127.0.12.100:80 weight 10 check inter 244 fall 2 rise 1
-	server 127.0.12.101 127.0.12.101:80 weight 10 check inter 8311 fall 2 rise 1
-	server 127.0.12.102 127.0.12.102:80 weight 10 check inter 3147 fall 2 rise 1
-	server 127.0.12.103 127.0.12.103:80 weight 10 check inter 1052 fall 2 rise 1
-	server 127.0.12.104 127.0.12.104:80 weight 10 check inter 362 fall 2 rise 1
-	server 127.0.12.105 127.0.12.105:80 weight 10 check inter 5474 fall 2 rise 1
-	server 127.0.12.106 127.0.12.106:80 weight 10 check inter 2990 fall 2 rise 1
-	server 127.0.12.107 127.0.12.107:80 weight 10 check inter 347 fall 2 rise 1
-	server 127.0.12.108 127.0.12.108:80 weight 10 check inter 1984 fall 2 rise 1
-	server 127.0.12.109 127.0.12.109:80 weight 10 check inter 2401 fall 2 rise 1
-	server 127.0.12.110 127.0.12.110:80 weight 10 check inter 4790 fall 2 rise 1
-	server 127.0.12.111 127.0.12.111:80 weight 10 check inter 2681 fall 2 rise 1
-	server 127.0.12.112 127.0.12.112:80 weight 10 check inter 8218 fall 2 rise 1
-	server 127.0.12.113 127.0.12.113:80 weight 10 check inter 9527 fall 2 rise 1
-	server 127.0.12.114 127.0.12.114:80 weight 10 check inter 5149 fall 2 rise 1
-	server 127.0.12.115 127.0.12.115:80 weight 10 check inter 1457 fall 2 rise 1
-	server 127.0.12.116 127.0.12.116:80 weight 10 check inter 2083 fall 2 rise 1
-	server 127.0.12.117 127.0.12.117:80 weight 10 check inter 1106 fall 2 rise 1
-	server 127.0.12.118 127.0.12.118:80 weight 10 check inter 5676 fall 2 rise 1
-	server 127.0.12.119 127.0.12.119:80 weight 10 check inter 8135 fall 2 rise 1
-	server 127.0.12.120 127.0.12.120:80 weight 10 check inter 7733 fall 2 rise 1
-	server 127.0.12.121 127.0.12.121:80 weight 10 check inter 7796 fall 2 rise 1
-	server 127.0.12.122 127.0.12.122:80 weight 10 check inter 5420 fall 2 rise 1
-	server 127.0.12.123 127.0.12.123:80 weight 10 check inter 3502 fall 2 rise 1
-	server 127.0.12.124 127.0.12.124:80 weight 10 check inter 7972 fall 2 rise 1
-	server 127.0.12.125 127.0.12.125:80 weight 10 check inter 3166 fall 2 rise 1
-	server 127.0.12.126 127.0.12.126:80 weight 10 check inter 8604 fall 2 rise 1
-	server 127.0.12.127 127.0.12.127:80 weight 10 check inter 5609 fall 2 rise 1
-	server 127.0.12.128 127.0.12.128:80 weight 10 check inter 9629 fall 2 rise 1
-	server 127.0.12.129 127.0.12.129:80 weight 10 check inter 8049 fall 2 rise 1
-	server 127.0.12.130 127.0.12.130:80 weight 10 check inter 6087 fall 2 rise 1
-	server 127.0.12.131 127.0.12.131:80 weight 10 check inter 7944 fall 2 rise 1
-	server 127.0.12.132 127.0.12.132:80 weight 10 check inter 5090 fall 2 rise 1
-	server 127.0.12.133 127.0.12.133:80 weight 10 check inter 9188 fall 2 rise 1
-	server 127.0.12.134 127.0.12.134:80 weight 10 check inter 1763 fall 2 rise 1
-	server 127.0.12.135 127.0.12.135:80 weight 10 check inter 8703 fall 2 rise 1
-	server 127.0.12.136 127.0.12.136:80 weight 10 check inter 5571 fall 2 rise 1
-	server 127.0.12.137 127.0.12.137:80 weight 10 check inter 2100 fall 2 rise 1
-	server 127.0.12.138 127.0.12.138:80 weight 10 check inter 1722 fall 2 rise 1
-	server 127.0.12.139 127.0.12.139:80 weight 10 check inter 6453 fall 2 rise 1
-	server 127.0.12.140 127.0.12.140:80 weight 10 check inter 1499 fall 2 rise 1
-	server 127.0.12.141 127.0.12.141:80 weight 10 check inter 767 fall 2 rise 1
-	server 127.0.12.142 127.0.12.142:80 weight 10 check inter 7992 fall 2 rise 1
-	server 127.0.12.143 127.0.12.143:80 weight 10 check inter 9201 fall 2 rise 1
-	server 127.0.12.144 127.0.12.144:80 weight 10 check inter 2816 fall 2 rise 1
-	server 127.0.12.145 127.0.12.145:80 weight 10 check inter 223 fall 2 rise 1
-	server 127.0.12.146 127.0.12.146:80 weight 10 check inter 9161 fall 2 rise 1
-	server 127.0.12.147 127.0.12.147:80 weight 10 check inter 7060 fall 2 rise 1
-	server 127.0.12.148 127.0.12.148:80 weight 10 check inter 1336 fall 2 rise 1
-	server 127.0.12.149 127.0.12.149:80 weight 10 check inter 5735 fall 2 rise 1
-	server 127.0.12.150 127.0.12.150:80 weight 10 check inter 7807 fall 2 rise 1
-	server 127.0.12.151 127.0.12.151:80 weight 10 check inter 7239 fall 2 rise 1
-	server 127.0.12.152 127.0.12.152:80 weight 10 check inter 9068 fall 2 rise 1
-	server 127.0.12.153 127.0.12.153:80 weight 10 check inter 4015 fall 2 rise 1
-	server 127.0.12.154 127.0.12.154:80 weight 10 check inter 8486 fall 2 rise 1
-	server 127.0.12.155 127.0.12.155:80 weight 10 check inter 3235 fall 2 rise 1
-	server 127.0.12.156 127.0.12.156:80 weight 10 check inter 3997 fall 2 rise 1
-	server 127.0.12.157 127.0.12.157:80 weight 10 check inter 9711 fall 2 rise 1
-	server 127.0.12.158 127.0.12.158:80 weight 10 check inter 4313 fall 2 rise 1
-	server 127.0.12.159 127.0.12.159:80 weight 10 check inter 4194 fall 2 rise 1
-	server 127.0.12.160 127.0.12.160:80 weight 10 check inter 1705 fall 2 rise 1
-	server 127.0.12.161 127.0.12.161:80 weight 10 check inter 8157 fall 2 rise 1
-	server 127.0.12.162 127.0.12.162:80 weight 10 check inter 5889 fall 2 rise 1
-	server 127.0.12.163 127.0.12.163:80 weight 10 check inter 153 fall 2 rise 1
-	server 127.0.12.164 127.0.12.164:80 weight 10 check inter 476 fall 2 rise 1
-	server 127.0.12.165 127.0.12.165:80 weight 10 check inter 1463 fall 2 rise 1
-	server 127.0.12.166 127.0.12.166:80 weight 10 check inter 1872 fall 2 rise 1
-	server 127.0.12.167 127.0.12.167:80 weight 10 check inter 7426 fall 2 rise 1
-	server 127.0.12.168 127.0.12.168:80 weight 10 check inter 4438 fall 2 rise 1
-	server 127.0.12.169 127.0.12.169:80 weight 10 check inter 623 fall 2 rise 1
-	server 127.0.12.170 127.0.12.170:80 weight 10 check inter 1985 fall 2 rise 1
-	server 127.0.12.171 127.0.12.171:80 weight 10 check inter 8347 fall 2 rise 1
-	server 127.0.12.172 127.0.12.172:80 weight 10 check inter 513 fall 2 rise 1
-	server 127.0.12.173 127.0.12.173:80 weight 10 check inter 9033 fall 2 rise 1
-	server 127.0.12.174 127.0.12.174:80 weight 10 check inter 2382 fall 2 rise 1
-	server 127.0.12.175 127.0.12.175:80 weight 10 check inter 6672 fall 2 rise 1
-	server 127.0.12.176 127.0.12.176:80 weight 10 check inter 8351 fall 2 rise 1
-	server 127.0.12.177 127.0.12.177:80 weight 10 check inter 7942 fall 2 rise 1
-	server 127.0.12.178 127.0.12.178:80 weight 10 check inter 3726 fall 2 rise 1
-	server 127.0.12.179 127.0.12.179:80 weight 10 check inter 713 fall 2 rise 1
-	server 127.0.12.180 127.0.12.180:80 weight 10 check inter 117 fall 2 rise 1
-	server 127.0.12.181 127.0.12.181:80 weight 10 check inter 8606 fall 2 rise 1
-	server 127.0.12.182 127.0.12.182:80 weight 10 check inter 6197 fall 2 rise 1
-	server 127.0.12.183 127.0.12.183:80 weight 10 check inter 1668 fall 2 rise 1
-	server 127.0.12.184 127.0.12.184:80 weight 10 check inter 361 fall 2 rise 1
-	server 127.0.12.185 127.0.12.185:80 weight 10 check inter 2751 fall 2 rise 1
-	server 127.0.12.186 127.0.12.186:80 weight 10 check inter 8985 fall 2 rise 1
-	server 127.0.12.187 127.0.12.187:80 weight 10 check inter 9040 fall 2 rise 1
-	server 127.0.12.188 127.0.12.188:80 weight 10 check inter 1149 fall 2 rise 1
-	server 127.0.12.189 127.0.12.189:80 weight 10 check inter 9048 fall 2 rise 1
-	server 127.0.12.190 127.0.12.190:80 weight 10 check inter 3605 fall 2 rise 1
-	server 127.0.12.191 127.0.12.191:80 weight 10 check inter 350 fall 2 rise 1
-	server 127.0.12.192 127.0.12.192:80 weight 10 check inter 8841 fall 2 rise 1
-	server 127.0.12.193 127.0.12.193:80 weight 10 check inter 868 fall 2 rise 1
-	server 127.0.12.194 127.0.12.194:80 weight 10 check inter 3040 fall 2 rise 1
-	server 127.0.12.195 127.0.12.195:80 weight 10 check inter 56 fall 2 rise 1
-	server 127.0.12.196 127.0.12.196:80 weight 10 check inter 26 fall 2 rise 1
-	server 127.0.12.197 127.0.12.197:80 weight 10 check inter 8743 fall 2 rise 1
-	server 127.0.12.198 127.0.12.198:80 weight 10 check inter 7563 fall 2 rise 1
-	server 127.0.12.199 127.0.12.199:80 weight 10 check inter 4446 fall 2 rise 1
-	server 127.0.12.200 127.0.12.200:80 weight 10 check inter 1116 fall 2 rise 1
-	server 127.0.12.201 127.0.12.201:80 weight 10 check inter 8954 fall 2 rise 1
-	server 127.0.12.202 127.0.12.202:80 weight 10 check inter 6045 fall 2 rise 1
-	server 127.0.12.203 127.0.12.203:80 weight 10 check inter 2069 fall 2 rise 1
-	server 127.0.12.204 127.0.12.204:80 weight 10 check inter 2505 fall 2 rise 1
-	server 127.0.12.205 127.0.12.205:80 weight 10 check inter 1942 fall 2 rise 1
-	server 127.0.12.206 127.0.12.206:80 weight 10 check inter 3583 fall 2 rise 1
-	server 127.0.12.207 127.0.12.207:80 weight 10 check inter 3326 fall 2 rise 1
-	server 127.0.12.208 127.0.12.208:80 weight 10 check inter 9198 fall 2 rise 1
-	server 127.0.12.209 127.0.12.209:80 weight 10 check inter 9554 fall 2 rise 1
-	server 127.0.12.210 127.0.12.210:80 weight 10 check inter 4710 fall 2 rise 1
-	server 127.0.12.211 127.0.12.211:80 weight 10 check inter 8984 fall 2 rise 1
-	server 127.0.12.212 127.0.12.212:80 weight 10 check inter 2498 fall 2 rise 1
-	server 127.0.12.213 127.0.12.213:80 weight 10 check inter 1245 fall 2 rise 1
-	server 127.0.12.214 127.0.12.214:80 weight 10 check inter 436 fall 2 rise 1
-	server 127.0.12.215 127.0.12.215:80 weight 10 check inter 2469 fall 2 rise 1
-	server 127.0.12.216 127.0.12.216:80 weight 10 check inter 5254 fall 2 rise 1
-	server 127.0.12.217 127.0.12.217:80 weight 10 check inter 8875 fall 2 rise 1
-	server 127.0.12.218 127.0.12.218:80 weight 10 check inter 957 fall 2 rise 1
-	server 127.0.12.219 127.0.12.219:80 weight 10 check inter 4285 fall 2 rise 1
-	server 127.0.12.220 127.0.12.220:80 weight 10 check inter 6971 fall 2 rise 1
-	server 127.0.12.221 127.0.12.221:80 weight 10 check inter 223 fall 2 rise 1
-	server 127.0.12.222 127.0.12.222:80 weight 10 check inter 4617 fall 2 rise 1
-	server 127.0.12.223 127.0.12.223:80 weight 10 check inter 4212 fall 2 rise 1
-	server 127.0.12.224 127.0.12.224:80 weight 10 check inter 8518 fall 2 rise 1
-	server 127.0.12.225 127.0.12.225:80 weight 10 check inter 6396 fall 2 rise 1
-	server 127.0.12.226 127.0.12.226:80 weight 10 check inter 1567 fall 2 rise 1
-	server 127.0.12.227 127.0.12.227:80 weight 10 check inter 700 fall 2 rise 1
-	server 127.0.12.228 127.0.12.228:80 weight 10 check inter 8260 fall 2 rise 1
-	server 127.0.12.229 127.0.12.229:80 weight 10 check inter 2172 fall 2 rise 1
-	server 127.0.12.230 127.0.12.230:80 weight 10 check inter 8396 fall 2 rise 1
-	server 127.0.12.231 127.0.12.231:80 weight 10 check inter 1867 fall 2 rise 1
-	server 127.0.12.232 127.0.12.232:80 weight 10 check inter 1502 fall 2 rise 1
-	server 127.0.12.233 127.0.12.233:80 weight 10 check inter 1693 fall 2 rise 1
-	server 127.0.12.234 127.0.12.234:80 weight 10 check inter 1414 fall 2 rise 1
-	server 127.0.12.235 127.0.12.235:80 weight 10 check inter 2154 fall 2 rise 1
-	server 127.0.12.236 127.0.12.236:80 weight 10 check inter 778 fall 2 rise 1
-	server 127.0.12.237 127.0.12.237:80 weight 10 check inter 78 fall 2 rise 1
-	server 127.0.12.238 127.0.12.238:80 weight 10 check inter 3316 fall 2 rise 1
-	server 127.0.12.239 127.0.12.239:80 weight 10 check inter 5043 fall 2 rise 1
-	server 127.0.12.240 127.0.12.240:80 weight 10 check inter 3175 fall 2 rise 1
-	server 127.0.12.241 127.0.12.241:80 weight 10 check inter 1389 fall 2 rise 1
-	server 127.0.12.242 127.0.12.242:80 weight 10 check inter 8761 fall 2 rise 1
-	server 127.0.12.243 127.0.12.243:80 weight 10 check inter 9704 fall 2 rise 1
-	server 127.0.12.244 127.0.12.244:80 weight 10 check inter 7911 fall 2 rise 1
-	server 127.0.12.245 127.0.12.245:80 weight 10 check inter 9950 fall 2 rise 1
-	server 127.0.12.246 127.0.12.246:80 weight 10 check inter 7284 fall 2 rise 1
-	server 127.0.12.247 127.0.12.247:80 weight 10 check inter 5571 fall 2 rise 1
-	server 127.0.12.248 127.0.12.248:80 weight 10 check inter 9130 fall 2 rise 1
-	server 127.0.12.249 127.0.12.249:80 weight 10 check inter 9483 fall 2 rise 1
-	server 127.0.12.250 127.0.12.250:80 weight 10 check inter 921 fall 2 rise 1
-	server 127.0.13.001 127.0.13.1:80 weight 10 check inter 7441 fall 2 rise 1
-	server 127.0.13.002 127.0.13.2:80 weight 10 check inter 6062 fall 2 rise 1
-	server 127.0.13.003 127.0.13.3:80 weight 10 check inter 2590 fall 2 rise 1
-	server 127.0.13.004 127.0.13.4:80 weight 10 check inter 957 fall 2 rise 1
-	server 127.0.13.005 127.0.13.5:80 weight 10 check inter 4637 fall 2 rise 1
-	server 127.0.13.006 127.0.13.6:80 weight 10 check inter 7192 fall 2 rise 1
-	server 127.0.13.007 127.0.13.7:80 weight 10 check inter 4415 fall 2 rise 1
-	server 127.0.13.008 127.0.13.8:80 weight 10 check inter 7971 fall 2 rise 1
-	server 127.0.13.009 127.0.13.9:80 weight 10 check inter 1934 fall 2 rise 1
-	server 127.0.13.010 127.0.13.10:80 weight 10 check inter 5057 fall 2 rise 1
-	server 127.0.13.011 127.0.13.11:80 weight 10 check inter 5966 fall 2 rise 1
-	server 127.0.13.012 127.0.13.12:80 weight 10 check inter 8330 fall 2 rise 1
-	server 127.0.13.013 127.0.13.13:80 weight 10 check inter 2208 fall 2 rise 1
-	server 127.0.13.014 127.0.13.14:80 weight 10 check inter 4930 fall 2 rise 1
-	server 127.0.13.015 127.0.13.15:80 weight 10 check inter 5664 fall 2 rise 1
-	server 127.0.13.016 127.0.13.16:80 weight 10 check inter 4691 fall 2 rise 1
-	server 127.0.13.017 127.0.13.17:80 weight 10 check inter 1635 fall 2 rise 1
-	server 127.0.13.018 127.0.13.18:80 weight 10 check inter 9533 fall 2 rise 1
-	server 127.0.13.019 127.0.13.19:80 weight 10 check inter 4330 fall 2 rise 1
-	server 127.0.13.020 127.0.13.20:80 weight 10 check inter 468 fall 2 rise 1
-	server 127.0.13.021 127.0.13.21:80 weight 10 check inter 9814 fall 2 rise 1
-	server 127.0.13.022 127.0.13.22:80 weight 10 check inter 5377 fall 2 rise 1
-	server 127.0.13.023 127.0.13.23:80 weight 10 check inter 6462 fall 2 rise 1
-	server 127.0.13.024 127.0.13.24:80 weight 10 check inter 542 fall 2 rise 1
-	server 127.0.13.025 127.0.13.25:80 weight 10 check inter 9202 fall 2 rise 1
-	server 127.0.13.026 127.0.13.26:80 weight 10 check inter 6683 fall 2 rise 1
-	server 127.0.13.027 127.0.13.27:80 weight 10 check inter 4088 fall 2 rise 1
-	server 127.0.13.028 127.0.13.28:80 weight 10 check inter 5133 fall 2 rise 1
-	server 127.0.13.029 127.0.13.29:80 weight 10 check inter 1782 fall 2 rise 1
-	server 127.0.13.030 127.0.13.30:80 weight 10 check inter 812 fall 2 rise 1
-	server 127.0.13.031 127.0.13.31:80 weight 10 check inter 8359 fall 2 rise 1
-	server 127.0.13.032 127.0.13.32:80 weight 10 check inter 21 fall 2 rise 1
-	server 127.0.13.033 127.0.13.33:80 weight 10 check inter 4405 fall 2 rise 1
-	server 127.0.13.034 127.0.13.34:80 weight 10 check inter 1151 fall 2 rise 1
-	server 127.0.13.035 127.0.13.35:80 weight 10 check inter 1340 fall 2 rise 1
-	server 127.0.13.036 127.0.13.36:80 weight 10 check inter 2327 fall 2 rise 1
-	server 127.0.13.037 127.0.13.37:80 weight 10 check inter 1521 fall 2 rise 1
-	server 127.0.13.038 127.0.13.38:80 weight 10 check inter 7527 fall 2 rise 1
-	server 127.0.13.039 127.0.13.39:80 weight 10 check inter 5748 fall 2 rise 1
-	server 127.0.13.040 127.0.13.40:80 weight 10 check inter 614 fall 2 rise 1
-	server 127.0.13.041 127.0.13.41:80 weight 10 check inter 2102 fall 2 rise 1
-	server 127.0.13.042 127.0.13.42:80 weight 10 check inter 123 fall 2 rise 1
-	server 127.0.13.043 127.0.13.43:80 weight 10 check inter 182 fall 2 rise 1
-	server 127.0.13.044 127.0.13.44:80 weight 10 check inter 8493 fall 2 rise 1
-	server 127.0.13.045 127.0.13.45:80 weight 10 check inter 7334 fall 2 rise 1
-	server 127.0.13.046 127.0.13.46:80 weight 10 check inter 2481 fall 2 rise 1
-	server 127.0.13.047 127.0.13.47:80 weight 10 check inter 1611 fall 2 rise 1
-	server 127.0.13.048 127.0.13.48:80 weight 10 check inter 493 fall 2 rise 1
-	server 127.0.13.049 127.0.13.49:80 weight 10 check inter 3112 fall 2 rise 1
-	server 127.0.13.050 127.0.13.50:80 weight 10 check inter 27 fall 2 rise 1
-	server 127.0.13.051 127.0.13.51:80 weight 10 check inter 1424 fall 2 rise 1
-	server 127.0.13.052 127.0.13.52:80 weight 10 check inter 9399 fall 2 rise 1
-	server 127.0.13.053 127.0.13.53:80 weight 10 check inter 512 fall 2 rise 1
-	server 127.0.13.054 127.0.13.54:80 weight 10 check inter 1571 fall 2 rise 1
-	server 127.0.13.055 127.0.13.55:80 weight 10 check inter 1709 fall 2 rise 1
-	server 127.0.13.056 127.0.13.56:80 weight 10 check inter 1037 fall 2 rise 1
-	server 127.0.13.057 127.0.13.57:80 weight 10 check inter 7837 fall 2 rise 1
-	server 127.0.13.058 127.0.13.58:80 weight 10 check inter 664 fall 2 rise 1
-	server 127.0.13.059 127.0.13.59:80 weight 10 check inter 4403 fall 2 rise 1
-	server 127.0.13.060 127.0.13.60:80 weight 10 check inter 7849 fall 2 rise 1
-	server 127.0.13.061 127.0.13.61:80 weight 10 check inter 9557 fall 2 rise 1
-	server 127.0.13.062 127.0.13.62:80 weight 10 check inter 8102 fall 2 rise 1
-	server 127.0.13.063 127.0.13.63:80 weight 10 check inter 3207 fall 2 rise 1
-	server 127.0.13.064 127.0.13.64:80 weight 10 check inter 9114 fall 2 rise 1
-	server 127.0.13.065 127.0.13.65:80 weight 10 check inter 641 fall 2 rise 1
-	server 127.0.13.066 127.0.13.66:80 weight 10 check inter 7559 fall 2 rise 1
-	server 127.0.13.067 127.0.13.67:80 weight 10 check inter 1969 fall 2 rise 1
-	server 127.0.13.068 127.0.13.68:80 weight 10 check inter 3906 fall 2 rise 1
-	server 127.0.13.069 127.0.13.69:80 weight 10 check inter 711 fall 2 rise 1
-	server 127.0.13.070 127.0.13.70:80 weight 10 check inter 6699 fall 2 rise 1
-	server 127.0.13.071 127.0.13.71:80 weight 10 check inter 8979 fall 2 rise 1
-	server 127.0.13.072 127.0.13.72:80 weight 10 check inter 336 fall 2 rise 1
-	server 127.0.13.073 127.0.13.73:80 weight 10 check inter 5275 fall 2 rise 1
-	server 127.0.13.074 127.0.13.74:80 weight 10 check inter 8521 fall 2 rise 1
-	server 127.0.13.075 127.0.13.75:80 weight 10 check inter 7946 fall 2 rise 1
-	server 127.0.13.076 127.0.13.76:80 weight 10 check inter 4414 fall 2 rise 1
-	server 127.0.13.077 127.0.13.77:80 weight 10 check inter 6757 fall 2 rise 1
-	server 127.0.13.078 127.0.13.78:80 weight 10 check inter 4211 fall 2 rise 1
-	server 127.0.13.079 127.0.13.79:80 weight 10 check inter 6966 fall 2 rise 1
-	server 127.0.13.080 127.0.13.80:80 weight 10 check inter 4219 fall 2 rise 1
-	server 127.0.13.081 127.0.13.81:80 weight 10 check inter 2145 fall 2 rise 1
-	server 127.0.13.082 127.0.13.82:80 weight 10 check inter 8874 fall 2 rise 1
-	server 127.0.13.083 127.0.13.83:80 weight 10 check inter 8394 fall 2 rise 1
-	server 127.0.13.084 127.0.13.84:80 weight 10 check inter 566 fall 2 rise 1
-	server 127.0.13.085 127.0.13.85:80 weight 10 check inter 425 fall 2 rise 1
-	server 127.0.13.086 127.0.13.86:80 weight 10 check inter 2039 fall 2 rise 1
-	server 127.0.13.087 127.0.13.87:80 weight 10 check inter 3522 fall 2 rise 1
-	server 127.0.13.088 127.0.13.88:80 weight 10 check inter 2015 fall 2 rise 1
-	server 127.0.13.089 127.0.13.89:80 weight 10 check inter 1698 fall 2 rise 1
-	server 127.0.13.090 127.0.13.90:80 weight 10 check inter 8132 fall 2 rise 1
-	server 127.0.13.091 127.0.13.91:80 weight 10 check inter 3639 fall 2 rise 1
-	server 127.0.13.092 127.0.13.92:80 weight 10 check inter 5389 fall 2 rise 1
-	server 127.0.13.093 127.0.13.93:80 weight 10 check inter 9465 fall 2 rise 1
-	server 127.0.13.094 127.0.13.94:80 weight 10 check inter 6078 fall 2 rise 1
-	server 127.0.13.095 127.0.13.95:80 weight 10 check inter 3956 fall 2 rise 1
-	server 127.0.13.096 127.0.13.96:80 weight 10 check inter 5375 fall 2 rise 1
-	server 127.0.13.097 127.0.13.97:80 weight 10 check inter 7340 fall 2 rise 1
-	server 127.0.13.098 127.0.13.98:80 weight 10 check inter 3196 fall 2 rise 1
-	server 127.0.13.099 127.0.13.99:80 weight 10 check inter 3045 fall 2 rise 1
-	server 127.0.13.100 127.0.13.100:80 weight 10 check inter 9731 fall 2 rise 1
-	server 127.0.13.101 127.0.13.101:80 weight 10 check inter 168 fall 2 rise 1
-	server 127.0.13.102 127.0.13.102:80 weight 10 check inter 5324 fall 2 rise 1
-	server 127.0.13.103 127.0.13.103:80 weight 10 check inter 3845 fall 2 rise 1
-	server 127.0.13.104 127.0.13.104:80 weight 10 check inter 7064 fall 2 rise 1
-	server 127.0.13.105 127.0.13.105:80 weight 10 check inter 2326 fall 2 rise 1
-	server 127.0.13.106 127.0.13.106:80 weight 10 check inter 674 fall 2 rise 1
-	server 127.0.13.107 127.0.13.107:80 weight 10 check inter 2692 fall 2 rise 1
-	server 127.0.13.108 127.0.13.108:80 weight 10 check inter 1556 fall 2 rise 1
-	server 127.0.13.109 127.0.13.109:80 weight 10 check inter 4868 fall 2 rise 1
-	server 127.0.13.110 127.0.13.110:80 weight 10 check inter 1920 fall 2 rise 1
-	server 127.0.13.111 127.0.13.111:80 weight 10 check inter 8618 fall 2 rise 1
-	server 127.0.13.112 127.0.13.112:80 weight 10 check inter 4821 fall 2 rise 1
-	server 127.0.13.113 127.0.13.113:80 weight 10 check inter 2789 fall 2 rise 1
-	server 127.0.13.114 127.0.13.114:80 weight 10 check inter 8051 fall 2 rise 1
-	server 127.0.13.115 127.0.13.115:80 weight 10 check inter 8111 fall 2 rise 1
-	server 127.0.13.116 127.0.13.116:80 weight 10 check inter 4360 fall 2 rise 1
-	server 127.0.13.117 127.0.13.117:80 weight 10 check inter 9416 fall 2 rise 1
-	server 127.0.13.118 127.0.13.118:80 weight 10 check inter 3267 fall 2 rise 1
-	server 127.0.13.119 127.0.13.119:80 weight 10 check inter 518 fall 2 rise 1
-	server 127.0.13.120 127.0.13.120:80 weight 10 check inter 6027 fall 2 rise 1
-	server 127.0.13.121 127.0.13.121:80 weight 10 check inter 8137 fall 2 rise 1
-	server 127.0.13.122 127.0.13.122:80 weight 10 check inter 1657 fall 2 rise 1
-	server 127.0.13.123 127.0.13.123:80 weight 10 check inter 5916 fall 2 rise 1
-	server 127.0.13.124 127.0.13.124:80 weight 10 check inter 3187 fall 2 rise 1
-	server 127.0.13.125 127.0.13.125:80 weight 10 check inter 9722 fall 2 rise 1
-	server 127.0.13.126 127.0.13.126:80 weight 10 check inter 494 fall 2 rise 1
-	server 127.0.13.127 127.0.13.127:80 weight 10 check inter 7221 fall 2 rise 1
-	server 127.0.13.128 127.0.13.128:80 weight 10 check inter 2300 fall 2 rise 1
-	server 127.0.13.129 127.0.13.129:80 weight 10 check inter 4191 fall 2 rise 1
-	server 127.0.13.130 127.0.13.130:80 weight 10 check inter 6871 fall 2 rise 1
-	server 127.0.13.131 127.0.13.131:80 weight 10 check inter 1745 fall 2 rise 1
-	server 127.0.13.132 127.0.13.132:80 weight 10 check inter 9316 fall 2 rise 1
-	server 127.0.13.133 127.0.13.133:80 weight 10 check inter 7196 fall 2 rise 1
-	server 127.0.13.134 127.0.13.134:80 weight 10 check inter 5762 fall 2 rise 1
-	server 127.0.13.135 127.0.13.135:80 weight 10 check inter 9536 fall 2 rise 1
-	server 127.0.13.136 127.0.13.136:80 weight 10 check inter 5975 fall 2 rise 1
-	server 127.0.13.137 127.0.13.137:80 weight 10 check inter 2623 fall 2 rise 1
-	server 127.0.13.138 127.0.13.138:80 weight 10 check inter 9600 fall 2 rise 1
-	server 127.0.13.139 127.0.13.139:80 weight 10 check inter 5387 fall 2 rise 1
-	server 127.0.13.140 127.0.13.140:80 weight 10 check inter 7016 fall 2 rise 1
-	server 127.0.13.141 127.0.13.141:80 weight 10 check inter 3709 fall 2 rise 1
-	server 127.0.13.142 127.0.13.142:80 weight 10 check inter 8080 fall 2 rise 1
-	server 127.0.13.143 127.0.13.143:80 weight 10 check inter 2910 fall 2 rise 1
-	server 127.0.13.144 127.0.13.144:80 weight 10 check inter 2036 fall 2 rise 1
-	server 127.0.13.145 127.0.13.145:80 weight 10 check inter 3133 fall 2 rise 1
-	server 127.0.13.146 127.0.13.146:80 weight 10 check inter 4895 fall 2 rise 1
-	server 127.0.13.147 127.0.13.147:80 weight 10 check inter 3751 fall 2 rise 1
-	server 127.0.13.148 127.0.13.148:80 weight 10 check inter 1110 fall 2 rise 1
-	server 127.0.13.149 127.0.13.149:80 weight 10 check inter 534 fall 2 rise 1
-	server 127.0.13.150 127.0.13.150:80 weight 10 check inter 3489 fall 2 rise 1
-	server 127.0.13.151 127.0.13.151:80 weight 10 check inter 5231 fall 2 rise 1
-	server 127.0.13.152 127.0.13.152:80 weight 10 check inter 3642 fall 2 rise 1
-	server 127.0.13.153 127.0.13.153:80 weight 10 check inter 8538 fall 2 rise 1
-	server 127.0.13.154 127.0.13.154:80 weight 10 check inter 1933 fall 2 rise 1
-	server 127.0.13.155 127.0.13.155:80 weight 10 check inter 123 fall 2 rise 1
-	server 127.0.13.156 127.0.13.156:80 weight 10 check inter 8306 fall 2 rise 1
-	server 127.0.13.157 127.0.13.157:80 weight 10 check inter 3423 fall 2 rise 1
-	server 127.0.13.158 127.0.13.158:80 weight 10 check inter 8844 fall 2 rise 1
-	server 127.0.13.159 127.0.13.159:80 weight 10 check inter 3537 fall 2 rise 1
-	server 127.0.13.160 127.0.13.160:80 weight 10 check inter 8634 fall 2 rise 1
-	server 127.0.13.161 127.0.13.161:80 weight 10 check inter 4914 fall 2 rise 1
-	server 127.0.13.162 127.0.13.162:80 weight 10 check inter 1680 fall 2 rise 1
-	server 127.0.13.163 127.0.13.163:80 weight 10 check inter 7243 fall 2 rise 1
-	server 127.0.13.164 127.0.13.164:80 weight 10 check inter 8269 fall 2 rise 1
-	server 127.0.13.165 127.0.13.165:80 weight 10 check inter 5050 fall 2 rise 1
-	server 127.0.13.166 127.0.13.166:80 weight 10 check inter 2117 fall 2 rise 1
-	server 127.0.13.167 127.0.13.167:80 weight 10 check inter 1934 fall 2 rise 1
-	server 127.0.13.168 127.0.13.168:80 weight 10 check inter 8563 fall 2 rise 1
-	server 127.0.13.169 127.0.13.169:80 weight 10 check inter 1261 fall 2 rise 1
-	server 127.0.13.170 127.0.13.170:80 weight 10 check inter 905 fall 2 rise 1
-	server 127.0.13.171 127.0.13.171:80 weight 10 check inter 3911 fall 2 rise 1
-	server 127.0.13.172 127.0.13.172:80 weight 10 check inter 7825 fall 2 rise 1
-	server 127.0.13.173 127.0.13.173:80 weight 10 check inter 7429 fall 2 rise 1
-	server 127.0.13.174 127.0.13.174:80 weight 10 check inter 5210 fall 2 rise 1
-	server 127.0.13.175 127.0.13.175:80 weight 10 check inter 2874 fall 2 rise 1
-	server 127.0.13.176 127.0.13.176:80 weight 10 check inter 9151 fall 2 rise 1
-	server 127.0.13.177 127.0.13.177:80 weight 10 check inter 2529 fall 2 rise 1
-	server 127.0.13.178 127.0.13.178:80 weight 10 check inter 9332 fall 2 rise 1
-	server 127.0.13.179 127.0.13.179:80 weight 10 check inter 1562 fall 2 rise 1
-	server 127.0.13.180 127.0.13.180:80 weight 10 check inter 2775 fall 2 rise 1
-	server 127.0.13.181 127.0.13.181:80 weight 10 check inter 1707 fall 2 rise 1
-	server 127.0.13.182 127.0.13.182:80 weight 10 check inter 9911 fall 2 rise 1
-	server 127.0.13.183 127.0.13.183:80 weight 10 check inter 9655 fall 2 rise 1
-	server 127.0.13.184 127.0.13.184:80 weight 10 check inter 4515 fall 2 rise 1
-	server 127.0.13.185 127.0.13.185:80 weight 10 check inter 12 fall 2 rise 1
-	server 127.0.13.186 127.0.13.186:80 weight 10 check inter 5018 fall 2 rise 1
-	server 127.0.13.187 127.0.13.187:80 weight 10 check inter 6523 fall 2 rise 1
-	server 127.0.13.188 127.0.13.188:80 weight 10 check inter 2211 fall 2 rise 1
-	server 127.0.13.189 127.0.13.189:80 weight 10 check inter 8546 fall 2 rise 1
-	server 127.0.13.190 127.0.13.190:80 weight 10 check inter 7601 fall 2 rise 1
-	server 127.0.13.191 127.0.13.191:80 weight 10 check inter 8435 fall 2 rise 1
-	server 127.0.13.192 127.0.13.192:80 weight 10 check inter 3905 fall 2 rise 1
-	server 127.0.13.193 127.0.13.193:80 weight 10 check inter 4492 fall 2 rise 1
-	server 127.0.13.194 127.0.13.194:80 weight 10 check inter 8848 fall 2 rise 1
-	server 127.0.13.195 127.0.13.195:80 weight 10 check inter 93 fall 2 rise 1
-	server 127.0.13.196 127.0.13.196:80 weight 10 check inter 7669 fall 2 rise 1
-	server 127.0.13.197 127.0.13.197:80 weight 10 check inter 6331 fall 2 rise 1
-	server 127.0.13.198 127.0.13.198:80 weight 10 check inter 1933 fall 2 rise 1
-	server 127.0.13.199 127.0.13.199:80 weight 10 check inter 9142 fall 2 rise 1
-	server 127.0.13.200 127.0.13.200:80 weight 10 check inter 7111 fall 2 rise 1
-	server 127.0.13.201 127.0.13.201:80 weight 10 check inter 2905 fall 2 rise 1
-	server 127.0.13.202 127.0.13.202:80 weight 10 check inter 1094 fall 2 rise 1
-	server 127.0.13.203 127.0.13.203:80 weight 10 check inter 5377 fall 2 rise 1
-	server 127.0.13.204 127.0.13.204:80 weight 10 check inter 5416 fall 2 rise 1
-	server 127.0.13.205 127.0.13.205:80 weight 10 check inter 7831 fall 2 rise 1
-	server 127.0.13.206 127.0.13.206:80 weight 10 check inter 9272 fall 2 rise 1
-	server 127.0.13.207 127.0.13.207:80 weight 10 check inter 8230 fall 2 rise 1
-	server 127.0.13.208 127.0.13.208:80 weight 10 check inter 7471 fall 2 rise 1
-	server 127.0.13.209 127.0.13.209:80 weight 10 check inter 8824 fall 2 rise 1
-	server 127.0.13.210 127.0.13.210:80 weight 10 check inter 3883 fall 2 rise 1
-	server 127.0.13.211 127.0.13.211:80 weight 10 check inter 864 fall 2 rise 1
-	server 127.0.13.212 127.0.13.212:80 weight 10 check inter 1252 fall 2 rise 1
-	server 127.0.13.213 127.0.13.213:80 weight 10 check inter 206 fall 2 rise 1
-	server 127.0.13.214 127.0.13.214:80 weight 10 check inter 414 fall 2 rise 1
-	server 127.0.13.215 127.0.13.215:80 weight 10 check inter 6933 fall 2 rise 1
-	server 127.0.13.216 127.0.13.216:80 weight 10 check inter 782 fall 2 rise 1
-	server 127.0.13.217 127.0.13.217:80 weight 10 check inter 3704 fall 2 rise 1
-	server 127.0.13.218 127.0.13.218:80 weight 10 check inter 9558 fall 2 rise 1
-	server 127.0.13.219 127.0.13.219:80 weight 10 check inter 2916 fall 2 rise 1
-	server 127.0.13.220 127.0.13.220:80 weight 10 check inter 1838 fall 2 rise 1
-	server 127.0.13.221 127.0.13.221:80 weight 10 check inter 7944 fall 2 rise 1
-	server 127.0.13.222 127.0.13.222:80 weight 10 check inter 4982 fall 2 rise 1
-	server 127.0.13.223 127.0.13.223:80 weight 10 check inter 8592 fall 2 rise 1
-	server 127.0.13.224 127.0.13.224:80 weight 10 check inter 3960 fall 2 rise 1
-	server 127.0.13.225 127.0.13.225:80 weight 10 check inter 3638 fall 2 rise 1
-	server 127.0.13.226 127.0.13.226:80 weight 10 check inter 493 fall 2 rise 1
-	server 127.0.13.227 127.0.13.227:80 weight 10 check inter 3918 fall 2 rise 1
-	server 127.0.13.228 127.0.13.228:80 weight 10 check inter 228 fall 2 rise 1
-	server 127.0.13.229 127.0.13.229:80 weight 10 check inter 8519 fall 2 rise 1
-	server 127.0.13.230 127.0.13.230:80 weight 10 check inter 1730 fall 2 rise 1
-	server 127.0.13.231 127.0.13.231:80 weight 10 check inter 416 fall 2 rise 1
-	server 127.0.13.232 127.0.13.232:80 weight 10 check inter 1912 fall 2 rise 1
-	server 127.0.13.233 127.0.13.233:80 weight 10 check inter 2411 fall 2 rise 1
-	server 127.0.13.234 127.0.13.234:80 weight 10 check inter 3728 fall 2 rise 1
-	server 127.0.13.235 127.0.13.235:80 weight 10 check inter 5503 fall 2 rise 1
-	server 127.0.13.236 127.0.13.236:80 weight 10 check inter 3924 fall 2 rise 1
-	server 127.0.13.237 127.0.13.237:80 weight 10 check inter 1593 fall 2 rise 1
-	server 127.0.13.238 127.0.13.238:80 weight 10 check inter 2433 fall 2 rise 1
-	server 127.0.13.239 127.0.13.239:80 weight 10 check inter 8155 fall 2 rise 1
-	server 127.0.13.240 127.0.13.240:80 weight 10 check inter 1851 fall 2 rise 1
-	server 127.0.13.241 127.0.13.241:80 weight 10 check inter 8363 fall 2 rise 1
-	server 127.0.13.242 127.0.13.242:80 weight 10 check inter 9196 fall 2 rise 1
-	server 127.0.13.243 127.0.13.243:80 weight 10 check inter 1282 fall 2 rise 1
-	server 127.0.13.244 127.0.13.244:80 weight 10 check inter 5604 fall 2 rise 1
-	server 127.0.13.245 127.0.13.245:80 weight 10 check inter 953 fall 2 rise 1
-	server 127.0.13.246 127.0.13.246:80 weight 10 check inter 8462 fall 2 rise 1
-	server 127.0.13.247 127.0.13.247:80 weight 10 check inter 737 fall 2 rise 1
-	server 127.0.13.248 127.0.13.248:80 weight 10 check inter 6436 fall 2 rise 1
-	server 127.0.13.249 127.0.13.249:80 weight 10 check inter 9254 fall 2 rise 1
-	server 127.0.13.250 127.0.13.250:80 weight 10 check inter 9562 fall 2 rise 1
-	server 127.0.14.001 127.0.14.1:80 weight 10 check inter 7406 fall 2 rise 1
-	server 127.0.14.002 127.0.14.2:80 weight 10 check inter 217 fall 2 rise 1
-	server 127.0.14.003 127.0.14.3:80 weight 10 check inter 2124 fall 2 rise 1
-	server 127.0.14.004 127.0.14.4:80 weight 10 check inter 2641 fall 2 rise 1
-	server 127.0.14.005 127.0.14.5:80 weight 10 check inter 2913 fall 2 rise 1
-	server 127.0.14.006 127.0.14.6:80 weight 10 check inter 2663 fall 2 rise 1
-	server 127.0.14.007 127.0.14.7:80 weight 10 check inter 7096 fall 2 rise 1
-	server 127.0.14.008 127.0.14.8:80 weight 10 check inter 256 fall 2 rise 1
-	server 127.0.14.009 127.0.14.9:80 weight 10 check inter 9878 fall 2 rise 1
-	server 127.0.14.010 127.0.14.10:80 weight 10 check inter 8595 fall 2 rise 1
-	server 127.0.14.011 127.0.14.11:80 weight 10 check inter 3974 fall 2 rise 1
-	server 127.0.14.012 127.0.14.12:80 weight 10 check inter 8075 fall 2 rise 1
-	server 127.0.14.013 127.0.14.13:80 weight 10 check inter 7236 fall 2 rise 1
-	server 127.0.14.014 127.0.14.14:80 weight 10 check inter 9585 fall 2 rise 1
-	server 127.0.14.015 127.0.14.15:80 weight 10 check inter 4203 fall 2 rise 1
-	server 127.0.14.016 127.0.14.16:80 weight 10 check inter 493 fall 2 rise 1
-	server 127.0.14.017 127.0.14.17:80 weight 10 check inter 3083 fall 2 rise 1
-	server 127.0.14.018 127.0.14.18:80 weight 10 check inter 6349 fall 2 rise 1
-	server 127.0.14.019 127.0.14.19:80 weight 10 check inter 7508 fall 2 rise 1
-	server 127.0.14.020 127.0.14.20:80 weight 10 check inter 1373 fall 2 rise 1
-	server 127.0.14.021 127.0.14.21:80 weight 10 check inter 8511 fall 2 rise 1
-	server 127.0.14.022 127.0.14.22:80 weight 10 check inter 5163 fall 2 rise 1
-	server 127.0.14.023 127.0.14.23:80 weight 10 check inter 1521 fall 2 rise 1
-	server 127.0.14.024 127.0.14.24:80 weight 10 check inter 2975 fall 2 rise 1
-	server 127.0.14.025 127.0.14.25:80 weight 10 check inter 1047 fall 2 rise 1
-	server 127.0.14.026 127.0.14.26:80 weight 10 check inter 9296 fall 2 rise 1
-	server 127.0.14.027 127.0.14.27:80 weight 10 check inter 9281 fall 2 rise 1
-	server 127.0.14.028 127.0.14.28:80 weight 10 check inter 9887 fall 2 rise 1
-	server 127.0.14.029 127.0.14.29:80 weight 10 check inter 356 fall 2 rise 1
-	server 127.0.14.030 127.0.14.30:80 weight 10 check inter 717 fall 2 rise 1
-	server 127.0.14.031 127.0.14.31:80 weight 10 check inter 4797 fall 2 rise 1
-	server 127.0.14.032 127.0.14.32:80 weight 10 check inter 8862 fall 2 rise 1
-	server 127.0.14.033 127.0.14.33:80 weight 10 check inter 9473 fall 2 rise 1
-	server 127.0.14.034 127.0.14.34:80 weight 10 check inter 3086 fall 2 rise 1
-	server 127.0.14.035 127.0.14.35:80 weight 10 check inter 932 fall 2 rise 1
-	server 127.0.14.036 127.0.14.36:80 weight 10 check inter 9515 fall 2 rise 1
-	server 127.0.14.037 127.0.14.37:80 weight 10 check inter 6991 fall 2 rise 1
-	server 127.0.14.038 127.0.14.38:80 weight 10 check inter 199 fall 2 rise 1
-	server 127.0.14.039 127.0.14.39:80 weight 10 check inter 8106 fall 2 rise 1
-	server 127.0.14.040 127.0.14.40:80 weight 10 check inter 5440 fall 2 rise 1
-	server 127.0.14.041 127.0.14.41:80 weight 10 check inter 2206 fall 2 rise 1
-	server 127.0.14.042 127.0.14.42:80 weight 10 check inter 7049 fall 2 rise 1
-	server 127.0.14.043 127.0.14.43:80 weight 10 check inter 2703 fall 2 rise 1
-	server 127.0.14.044 127.0.14.44:80 weight 10 check inter 9906 fall 2 rise 1
-	server 127.0.14.045 127.0.14.45:80 weight 10 check inter 7771 fall 2 rise 1
-	server 127.0.14.046 127.0.14.46:80 weight 10 check inter 4759 fall 2 rise 1
-	server 127.0.14.047 127.0.14.47:80 weight 10 check inter 2896 fall 2 rise 1
-	server 127.0.14.048 127.0.14.48:80 weight 10 check inter 134 fall 2 rise 1
-	server 127.0.14.049 127.0.14.49:80 weight 10 check inter 2748 fall 2 rise 1
-	server 127.0.14.050 127.0.14.50:80 weight 10 check inter 5628 fall 2 rise 1
-	server 127.0.14.051 127.0.14.51:80 weight 10 check inter 4784 fall 2 rise 1
-	server 127.0.14.052 127.0.14.52:80 weight 10 check inter 8979 fall 2 rise 1
-	server 127.0.14.053 127.0.14.53:80 weight 10 check inter 4620 fall 2 rise 1
-	server 127.0.14.054 127.0.14.54:80 weight 10 check inter 9368 fall 2 rise 1
-	server 127.0.14.055 127.0.14.55:80 weight 10 check inter 9940 fall 2 rise 1
-	server 127.0.14.056 127.0.14.56:80 weight 10 check inter 6588 fall 2 rise 1
-	server 127.0.14.057 127.0.14.57:80 weight 10 check inter 8695 fall 2 rise 1
-	server 127.0.14.058 127.0.14.58:80 weight 10 check inter 191 fall 2 rise 1
-	server 127.0.14.059 127.0.14.59:80 weight 10 check inter 2641 fall 2 rise 1
-	server 127.0.14.060 127.0.14.60:80 weight 10 check inter 7802 fall 2 rise 1
-	server 127.0.14.061 127.0.14.61:80 weight 10 check inter 68 fall 2 rise 1
-	server 127.0.14.062 127.0.14.62:80 weight 10 check inter 880 fall 2 rise 1
-	server 127.0.14.063 127.0.14.63:80 weight 10 check inter 9734 fall 2 rise 1
-	server 127.0.14.064 127.0.14.64:80 weight 10 check inter 2186 fall 2 rise 1
-	server 127.0.14.065 127.0.14.65:80 weight 10 check inter 3366 fall 2 rise 1
-	server 127.0.14.066 127.0.14.66:80 weight 10 check inter 581 fall 2 rise 1
-	server 127.0.14.067 127.0.14.67:80 weight 10 check inter 169 fall 2 rise 1
-	server 127.0.14.068 127.0.14.68:80 weight 10 check inter 2444 fall 2 rise 1
-	server 127.0.14.069 127.0.14.69:80 weight 10 check inter 3105 fall 2 rise 1
-	server 127.0.14.070 127.0.14.70:80 weight 10 check inter 9231 fall 2 rise 1
-	server 127.0.14.071 127.0.14.71:80 weight 10 check inter 1171 fall 2 rise 1
-	server 127.0.14.072 127.0.14.72:80 weight 10 check inter 3175 fall 2 rise 1
-	server 127.0.14.073 127.0.14.73:80 weight 10 check inter 972 fall 2 rise 1
-	server 127.0.14.074 127.0.14.74:80 weight 10 check inter 2575 fall 2 rise 1
-	server 127.0.14.075 127.0.14.75:80 weight 10 check inter 2363 fall 2 rise 1
-	server 127.0.14.076 127.0.14.76:80 weight 10 check inter 8973 fall 2 rise 1
-	server 127.0.14.077 127.0.14.77:80 weight 10 check inter 9643 fall 2 rise 1
-	server 127.0.14.078 127.0.14.78:80 weight 10 check inter 2852 fall 2 rise 1
-	server 127.0.14.079 127.0.14.79:80 weight 10 check inter 2675 fall 2 rise 1
-	server 127.0.14.080 127.0.14.80:80 weight 10 check inter 5059 fall 2 rise 1
-	server 127.0.14.081 127.0.14.81:80 weight 10 check inter 1130 fall 2 rise 1
-	server 127.0.14.082 127.0.14.82:80 weight 10 check inter 1864 fall 2 rise 1
-	server 127.0.14.083 127.0.14.83:80 weight 10 check inter 1972 fall 2 rise 1
-	server 127.0.14.084 127.0.14.84:80 weight 10 check inter 9885 fall 2 rise 1
-	server 127.0.14.085 127.0.14.85:80 weight 10 check inter 5721 fall 2 rise 1
-	server 127.0.14.086 127.0.14.86:80 weight 10 check inter 1674 fall 2 rise 1
-	server 127.0.14.087 127.0.14.87:80 weight 10 check inter 5450 fall 2 rise 1
-	server 127.0.14.088 127.0.14.88:80 weight 10 check inter 5690 fall 2 rise 1
-	server 127.0.14.089 127.0.14.89:80 weight 10 check inter 3066 fall 2 rise 1
-	server 127.0.14.090 127.0.14.90:80 weight 10 check inter 8857 fall 2 rise 1
-	server 127.0.14.091 127.0.14.91:80 weight 10 check inter 7823 fall 2 rise 1
-	server 127.0.14.092 127.0.14.92:80 weight 10 check inter 4293 fall 2 rise 1
-	server 127.0.14.093 127.0.14.93:80 weight 10 check inter 843 fall 2 rise 1
-	server 127.0.14.094 127.0.14.94:80 weight 10 check inter 3269 fall 2 rise 1
-	server 127.0.14.095 127.0.14.95:80 weight 10 check inter 7497 fall 2 rise 1
-	server 127.0.14.096 127.0.14.96:80 weight 10 check inter 1319 fall 2 rise 1
-	server 127.0.14.097 127.0.14.97:80 weight 10 check inter 9172 fall 2 rise 1
-	server 127.0.14.098 127.0.14.98:80 weight 10 check inter 5541 fall 2 rise 1
-	server 127.0.14.099 127.0.14.99:80 weight 10 check inter 9443 fall 2 rise 1
-	server 127.0.14.100 127.0.14.100:80 weight 10 check inter 5548 fall 2 rise 1
-	server 127.0.14.101 127.0.14.101:80 weight 10 check inter 223 fall 2 rise 1
-	server 127.0.14.102 127.0.14.102:80 weight 10 check inter 4280 fall 2 rise 1
-	server 127.0.14.103 127.0.14.103:80 weight 10 check inter 9292 fall 2 rise 1
-	server 127.0.14.104 127.0.14.104:80 weight 10 check inter 8716 fall 2 rise 1
-	server 127.0.14.105 127.0.14.105:80 weight 10 check inter 2090 fall 2 rise 1
-	server 127.0.14.106 127.0.14.106:80 weight 10 check inter 3788 fall 2 rise 1
-	server 127.0.14.107 127.0.14.107:80 weight 10 check inter 7185 fall 2 rise 1
-	server 127.0.14.108 127.0.14.108:80 weight 10 check inter 470 fall 2 rise 1
-	server 127.0.14.109 127.0.14.109:80 weight 10 check inter 4398 fall 2 rise 1
-	server 127.0.14.110 127.0.14.110:80 weight 10 check inter 8368 fall 2 rise 1
-	server 127.0.14.111 127.0.14.111:80 weight 10 check inter 3451 fall 2 rise 1
-	server 127.0.14.112 127.0.14.112:80 weight 10 check inter 4732 fall 2 rise 1
-	server 127.0.14.113 127.0.14.113:80 weight 10 check inter 9005 fall 2 rise 1
-	server 127.0.14.114 127.0.14.114:80 weight 10 check inter 9562 fall 2 rise 1
-	server 127.0.14.115 127.0.14.115:80 weight 10 check inter 809 fall 2 rise 1
-	server 127.0.14.116 127.0.14.116:80 weight 10 check inter 2161 fall 2 rise 1
-	server 127.0.14.117 127.0.14.117:80 weight 10 check inter 510 fall 2 rise 1
-	server 127.0.14.118 127.0.14.118:80 weight 10 check inter 2840 fall 2 rise 1
-	server 127.0.14.119 127.0.14.119:80 weight 10 check inter 4988 fall 2 rise 1
-	server 127.0.14.120 127.0.14.120:80 weight 10 check inter 9603 fall 2 rise 1
-	server 127.0.14.121 127.0.14.121:80 weight 10 check inter 8840 fall 2 rise 1
-	server 127.0.14.122 127.0.14.122:80 weight 10 check inter 4727 fall 2 rise 1
-	server 127.0.14.123 127.0.14.123:80 weight 10 check inter 7572 fall 2 rise 1
-	server 127.0.14.124 127.0.14.124:80 weight 10 check inter 424 fall 2 rise 1
-	server 127.0.14.125 127.0.14.125:80 weight 10 check inter 336 fall 2 rise 1
-	server 127.0.14.126 127.0.14.126:80 weight 10 check inter 2245 fall 2 rise 1
-	server 127.0.14.127 127.0.14.127:80 weight 10 check inter 13 fall 2 rise 1
-	server 127.0.14.128 127.0.14.128:80 weight 10 check inter 6171 fall 2 rise 1
-	server 127.0.14.129 127.0.14.129:80 weight 10 check inter 50 fall 2 rise 1
-	server 127.0.14.130 127.0.14.130:80 weight 10 check inter 4135 fall 2 rise 1
-	server 127.0.14.131 127.0.14.131:80 weight 10 check inter 8777 fall 2 rise 1
-	server 127.0.14.132 127.0.14.132:80 weight 10 check inter 1923 fall 2 rise 1
-	server 127.0.14.133 127.0.14.133:80 weight 10 check inter 2305 fall 2 rise 1
-	server 127.0.14.134 127.0.14.134:80 weight 10 check inter 7881 fall 2 rise 1
-	server 127.0.14.135 127.0.14.135:80 weight 10 check inter 9500 fall 2 rise 1
-	server 127.0.14.136 127.0.14.136:80 weight 10 check inter 4375 fall 2 rise 1
-	server 127.0.14.137 127.0.14.137:80 weight 10 check inter 6239 fall 2 rise 1
-	server 127.0.14.138 127.0.14.138:80 weight 10 check inter 9241 fall 2 rise 1
-	server 127.0.14.139 127.0.14.139:80 weight 10 check inter 7354 fall 2 rise 1
-	server 127.0.14.140 127.0.14.140:80 weight 10 check inter 5795 fall 2 rise 1
-	server 127.0.14.141 127.0.14.141:80 weight 10 check inter 8571 fall 2 rise 1
-	server 127.0.14.142 127.0.14.142:80 weight 10 check inter 8290 fall 2 rise 1
-	server 127.0.14.143 127.0.14.143:80 weight 10 check inter 6401 fall 2 rise 1
-	server 127.0.14.144 127.0.14.144:80 weight 10 check inter 6745 fall 2 rise 1
-	server 127.0.14.145 127.0.14.145:80 weight 10 check inter 4686 fall 2 rise 1
-	server 127.0.14.146 127.0.14.146:80 weight 10 check inter 393 fall 2 rise 1
-	server 127.0.14.147 127.0.14.147:80 weight 10 check inter 2374 fall 2 rise 1
-	server 127.0.14.148 127.0.14.148:80 weight 10 check inter 5624 fall 2 rise 1
-	server 127.0.14.149 127.0.14.149:80 weight 10 check inter 2676 fall 2 rise 1
-	server 127.0.14.150 127.0.14.150:80 weight 10 check inter 4410 fall 2 rise 1
-	server 127.0.14.151 127.0.14.151:80 weight 10 check inter 5681 fall 2 rise 1
-	server 127.0.14.152 127.0.14.152:80 weight 10 check inter 1934 fall 2 rise 1
-	server 127.0.14.153 127.0.14.153:80 weight 10 check inter 8234 fall 2 rise 1
-	server 127.0.14.154 127.0.14.154:80 weight 10 check inter 2704 fall 2 rise 1
-	server 127.0.14.155 127.0.14.155:80 weight 10 check inter 1208 fall 2 rise 1
-	server 127.0.14.156 127.0.14.156:80 weight 10 check inter 6237 fall 2 rise 1
-	server 127.0.14.157 127.0.14.157:80 weight 10 check inter 2891 fall 2 rise 1
-	server 127.0.14.158 127.0.14.158:80 weight 10 check inter 5719 fall 2 rise 1
-	server 127.0.14.159 127.0.14.159:80 weight 10 check inter 2171 fall 2 rise 1
-	server 127.0.14.160 127.0.14.160:80 weight 10 check inter 2014 fall 2 rise 1
-	server 127.0.14.161 127.0.14.161:80 weight 10 check inter 2235 fall 2 rise 1
-	server 127.0.14.162 127.0.14.162:80 weight 10 check inter 3537 fall 2 rise 1
-	server 127.0.14.163 127.0.14.163:80 weight 10 check inter 8612 fall 2 rise 1
-	server 127.0.14.164 127.0.14.164:80 weight 10 check inter 873 fall 2 rise 1
-	server 127.0.14.165 127.0.14.165:80 weight 10 check inter 8928 fall 2 rise 1
-	server 127.0.14.166 127.0.14.166:80 weight 10 check inter 7818 fall 2 rise 1
-	server 127.0.14.167 127.0.14.167:80 weight 10 check inter 4557 fall 2 rise 1
-	server 127.0.14.168 127.0.14.168:80 weight 10 check inter 3359 fall 2 rise 1
-	server 127.0.14.169 127.0.14.169:80 weight 10 check inter 2707 fall 2 rise 1
-	server 127.0.14.170 127.0.14.170:80 weight 10 check inter 9117 fall 2 rise 1
-	server 127.0.14.171 127.0.14.171:80 weight 10 check inter 9630 fall 2 rise 1
-	server 127.0.14.172 127.0.14.172:80 weight 10 check inter 3630 fall 2 rise 1
-	server 127.0.14.173 127.0.14.173:80 weight 10 check inter 4315 fall 2 rise 1
-	server 127.0.14.174 127.0.14.174:80 weight 10 check inter 3154 fall 2 rise 1
-	server 127.0.14.175 127.0.14.175:80 weight 10 check inter 1197 fall 2 rise 1
-	server 127.0.14.176 127.0.14.176:80 weight 10 check inter 1282 fall 2 rise 1
-	server 127.0.14.177 127.0.14.177:80 weight 10 check inter 2324 fall 2 rise 1
-	server 127.0.14.178 127.0.14.178:80 weight 10 check inter 8734 fall 2 rise 1
-	server 127.0.14.179 127.0.14.179:80 weight 10 check inter 5397 fall 2 rise 1
-	server 127.0.14.180 127.0.14.180:80 weight 10 check inter 4603 fall 2 rise 1
-	server 127.0.14.181 127.0.14.181:80 weight 10 check inter 1521 fall 2 rise 1
-	server 127.0.14.182 127.0.14.182:80 weight 10 check inter 1481 fall 2 rise 1
-	server 127.0.14.183 127.0.14.183:80 weight 10 check inter 5922 fall 2 rise 1
-	server 127.0.14.184 127.0.14.184:80 weight 10 check inter 4419 fall 2 rise 1
-	server 127.0.14.185 127.0.14.185:80 weight 10 check inter 4839 fall 2 rise 1
-	server 127.0.14.186 127.0.14.186:80 weight 10 check inter 9325 fall 2 rise 1
-	server 127.0.14.187 127.0.14.187:80 weight 10 check inter 8466 fall 2 rise 1
-	server 127.0.14.188 127.0.14.188:80 weight 10 check inter 7979 fall 2 rise 1
-	server 127.0.14.189 127.0.14.189:80 weight 10 check inter 2309 fall 2 rise 1
-	server 127.0.14.190 127.0.14.190:80 weight 10 check inter 2387 fall 2 rise 1
-	server 127.0.14.191 127.0.14.191:80 weight 10 check inter 3963 fall 2 rise 1
-	server 127.0.14.192 127.0.14.192:80 weight 10 check inter 1178 fall 2 rise 1
-	server 127.0.14.193 127.0.14.193:80 weight 10 check inter 5028 fall 2 rise 1
-	server 127.0.14.194 127.0.14.194:80 weight 10 check inter 7022 fall 2 rise 1
-	server 127.0.14.195 127.0.14.195:80 weight 10 check inter 3196 fall 2 rise 1
-	server 127.0.14.196 127.0.14.196:80 weight 10 check inter 3446 fall 2 rise 1
-	server 127.0.14.197 127.0.14.197:80 weight 10 check inter 7426 fall 2 rise 1
-	server 127.0.14.198 127.0.14.198:80 weight 10 check inter 964 fall 2 rise 1
-	server 127.0.14.199 127.0.14.199:80 weight 10 check inter 4020 fall 2 rise 1
-	server 127.0.14.200 127.0.14.200:80 weight 10 check inter 8702 fall 2 rise 1
-	server 127.0.14.201 127.0.14.201:80 weight 10 check inter 3855 fall 2 rise 1
-	server 127.0.14.202 127.0.14.202:80 weight 10 check inter 6304 fall 2 rise 1
-	server 127.0.14.203 127.0.14.203:80 weight 10 check inter 1189 fall 2 rise 1
-	server 127.0.14.204 127.0.14.204:80 weight 10 check inter 557 fall 2 rise 1
-	server 127.0.14.205 127.0.14.205:80 weight 10 check inter 7076 fall 2 rise 1
-	server 127.0.14.206 127.0.14.206:80 weight 10 check inter 9817 fall 2 rise 1
-	server 127.0.14.207 127.0.14.207:80 weight 10 check inter 4311 fall 2 rise 1
-	server 127.0.14.208 127.0.14.208:80 weight 10 check inter 3887 fall 2 rise 1
-	server 127.0.14.209 127.0.14.209:80 weight 10 check inter 838 fall 2 rise 1
-	server 127.0.14.210 127.0.14.210:80 weight 10 check inter 2288 fall 2 rise 1
-	server 127.0.14.211 127.0.14.211:80 weight 10 check inter 716 fall 2 rise 1
-	server 127.0.14.212 127.0.14.212:80 weight 10 check inter 6864 fall 2 rise 1
-	server 127.0.14.213 127.0.14.213:80 weight 10 check inter 1343 fall 2 rise 1
-	server 127.0.14.214 127.0.14.214:80 weight 10 check inter 9932 fall 2 rise 1
-	server 127.0.14.215 127.0.14.215:80 weight 10 check inter 8135 fall 2 rise 1
-	server 127.0.14.216 127.0.14.216:80 weight 10 check inter 9689 fall 2 rise 1
-	server 127.0.14.217 127.0.14.217:80 weight 10 check inter 9783 fall 2 rise 1
-	server 127.0.14.218 127.0.14.218:80 weight 10 check inter 5525 fall 2 rise 1
-	server 127.0.14.219 127.0.14.219:80 weight 10 check inter 1195 fall 2 rise 1
-	server 127.0.14.220 127.0.14.220:80 weight 10 check inter 874 fall 2 rise 1
-	server 127.0.14.221 127.0.14.221:80 weight 10 check inter 1844 fall 2 rise 1
-	server 127.0.14.222 127.0.14.222:80 weight 10 check inter 6194 fall 2 rise 1
-	server 127.0.14.223 127.0.14.223:80 weight 10 check inter 36 fall 2 rise 1
-	server 127.0.14.224 127.0.14.224:80 weight 10 check inter 9654 fall 2 rise 1
-	server 127.0.14.225 127.0.14.225:80 weight 10 check inter 806 fall 2 rise 1
-	server 127.0.14.226 127.0.14.226:80 weight 10 check inter 564 fall 2 rise 1
-	server 127.0.14.227 127.0.14.227:80 weight 10 check inter 2728 fall 2 rise 1
-	server 127.0.14.228 127.0.14.228:80 weight 10 check inter 4129 fall 2 rise 1
-	server 127.0.14.229 127.0.14.229:80 weight 10 check inter 9057 fall 2 rise 1
-	server 127.0.14.230 127.0.14.230:80 weight 10 check inter 7743 fall 2 rise 1
-	server 127.0.14.231 127.0.14.231:80 weight 10 check inter 7644 fall 2 rise 1
-	server 127.0.14.232 127.0.14.232:80 weight 10 check inter 8795 fall 2 rise 1
-	server 127.0.14.233 127.0.14.233:80 weight 10 check inter 9577 fall 2 rise 1
-	server 127.0.14.234 127.0.14.234:80 weight 10 check inter 8091 fall 2 rise 1
-	server 127.0.14.235 127.0.14.235:80 weight 10 check inter 4086 fall 2 rise 1
-	server 127.0.14.236 127.0.14.236:80 weight 10 check inter 5977 fall 2 rise 1
-	server 127.0.14.237 127.0.14.237:80 weight 10 check inter 5152 fall 2 rise 1
-	server 127.0.14.238 127.0.14.238:80 weight 10 check inter 3150 fall 2 rise 1
-	server 127.0.14.239 127.0.14.239:80 weight 10 check inter 2406 fall 2 rise 1
-	server 127.0.14.240 127.0.14.240:80 weight 10 check inter 9927 fall 2 rise 1
-	server 127.0.14.241 127.0.14.241:80 weight 10 check inter 6063 fall 2 rise 1
-	server 127.0.14.242 127.0.14.242:80 weight 10 check inter 9767 fall 2 rise 1
-	server 127.0.14.243 127.0.14.243:80 weight 10 check inter 9587 fall 2 rise 1
-	server 127.0.14.244 127.0.14.244:80 weight 10 check inter 9152 fall 2 rise 1
-	server 127.0.14.245 127.0.14.245:80 weight 10 check inter 5893 fall 2 rise 1
-	server 127.0.14.246 127.0.14.246:80 weight 10 check inter 3659 fall 2 rise 1
-	server 127.0.14.247 127.0.14.247:80 weight 10 check inter 3239 fall 2 rise 1
-	server 127.0.14.248 127.0.14.248:80 weight 10 check inter 1898 fall 2 rise 1
-	server 127.0.14.249 127.0.14.249:80 weight 10 check inter 7266 fall 2 rise 1
-	server 127.0.14.250 127.0.14.250:80 weight 10 check inter 2177 fall 2 rise 1
-	server 127.0.15.001 127.0.15.1:80 weight 10 check inter 1658 fall 2 rise 1
-	server 127.0.15.002 127.0.15.2:80 weight 10 check inter 4658 fall 2 rise 1
-	server 127.0.15.003 127.0.15.3:80 weight 10 check inter 5906 fall 2 rise 1
-	server 127.0.15.004 127.0.15.4:80 weight 10 check inter 2940 fall 2 rise 1
-	server 127.0.15.005 127.0.15.5:80 weight 10 check inter 7376 fall 2 rise 1
-	server 127.0.15.006 127.0.15.6:80 weight 10 check inter 490 fall 2 rise 1
-	server 127.0.15.007 127.0.15.7:80 weight 10 check inter 9482 fall 2 rise 1
-	server 127.0.15.008 127.0.15.8:80 weight 10 check inter 4539 fall 2 rise 1
-	server 127.0.15.009 127.0.15.9:80 weight 10 check inter 6753 fall 2 rise 1
-	server 127.0.15.010 127.0.15.10:80 weight 10 check inter 1924 fall 2 rise 1
-	server 127.0.15.011 127.0.15.11:80 weight 10 check inter 4532 fall 2 rise 1
-	server 127.0.15.012 127.0.15.12:80 weight 10 check inter 8289 fall 2 rise 1
-	server 127.0.15.013 127.0.15.13:80 weight 10 check inter 7515 fall 2 rise 1
-	server 127.0.15.014 127.0.15.14:80 weight 10 check inter 4621 fall 2 rise 1
-	server 127.0.15.015 127.0.15.15:80 weight 10 check inter 5611 fall 2 rise 1
-	server 127.0.15.016 127.0.15.16:80 weight 10 check inter 3397 fall 2 rise 1
-	server 127.0.15.017 127.0.15.17:80 weight 10 check inter 2490 fall 2 rise 1
-	server 127.0.15.018 127.0.15.18:80 weight 10 check inter 4426 fall 2 rise 1
-	server 127.0.15.019 127.0.15.19:80 weight 10 check inter 4597 fall 2 rise 1
-	server 127.0.15.020 127.0.15.20:80 weight 10 check inter 8810 fall 2 rise 1
-	server 127.0.15.021 127.0.15.21:80 weight 10 check inter 8947 fall 2 rise 1
-	server 127.0.15.022 127.0.15.22:80 weight 10 check inter 2900 fall 2 rise 1
-	server 127.0.15.023 127.0.15.23:80 weight 10 check inter 3060 fall 2 rise 1
-	server 127.0.15.024 127.0.15.24:80 weight 10 check inter 3212 fall 2 rise 1
-	server 127.0.15.025 127.0.15.25:80 weight 10 check inter 2612 fall 2 rise 1
-	server 127.0.15.026 127.0.15.26:80 weight 10 check inter 7187 fall 2 rise 1
-	server 127.0.15.027 127.0.15.27:80 weight 10 check inter 75 fall 2 rise 1
-	server 127.0.15.028 127.0.15.28:80 weight 10 check inter 5647 fall 2 rise 1
-	server 127.0.15.029 127.0.15.29:80 weight 10 check inter 3419 fall 2 rise 1
-	server 127.0.15.030 127.0.15.30:80 weight 10 check inter 1628 fall 2 rise 1
-	server 127.0.15.031 127.0.15.31:80 weight 10 check inter 4560 fall 2 rise 1
-	server 127.0.15.032 127.0.15.32:80 weight 10 check inter 4552 fall 2 rise 1
-	server 127.0.15.033 127.0.15.33:80 weight 10 check inter 1465 fall 2 rise 1
-	server 127.0.15.034 127.0.15.34:80 weight 10 check inter 5274 fall 2 rise 1
-	server 127.0.15.035 127.0.15.35:80 weight 10 check inter 6662 fall 2 rise 1
-	server 127.0.15.036 127.0.15.36:80 weight 10 check inter 3672 fall 2 rise 1
-	server 127.0.15.037 127.0.15.37:80 weight 10 check inter 5924 fall 2 rise 1
-	server 127.0.15.038 127.0.15.38:80 weight 10 check inter 4862 fall 2 rise 1
-	server 127.0.15.039 127.0.15.39:80 weight 10 check inter 9575 fall 2 rise 1
-	server 127.0.15.040 127.0.15.40:80 weight 10 check inter 3723 fall 2 rise 1
-	server 127.0.15.041 127.0.15.41:80 weight 10 check inter 2463 fall 2 rise 1
-	server 127.0.15.042 127.0.15.42:80 weight 10 check inter 2038 fall 2 rise 1
-	server 127.0.15.043 127.0.15.43:80 weight 10 check inter 1251 fall 2 rise 1
-	server 127.0.15.044 127.0.15.44:80 weight 10 check inter 7365 fall 2 rise 1
-	server 127.0.15.045 127.0.15.45:80 weight 10 check inter 3146 fall 2 rise 1
-	server 127.0.15.046 127.0.15.46:80 weight 10 check inter 8061 fall 2 rise 1
-	server 127.0.15.047 127.0.15.47:80 weight 10 check inter 3532 fall 2 rise 1
-	server 127.0.15.048 127.0.15.48:80 weight 10 check inter 9383 fall 2 rise 1
-	server 127.0.15.049 127.0.15.49:80 weight 10 check inter 985 fall 2 rise 1
-	server 127.0.15.050 127.0.15.50:80 weight 10 check inter 7720 fall 2 rise 1
-	server 127.0.15.051 127.0.15.51:80 weight 10 check inter 8157 fall 2 rise 1
-	server 127.0.15.052 127.0.15.52:80 weight 10 check inter 6004 fall 2 rise 1
-	server 127.0.15.053 127.0.15.53:80 weight 10 check inter 8662 fall 2 rise 1
-	server 127.0.15.054 127.0.15.54:80 weight 10 check inter 1661 fall 2 rise 1
-	server 127.0.15.055 127.0.15.55:80 weight 10 check inter 8270 fall 2 rise 1
-	server 127.0.15.056 127.0.15.56:80 weight 10 check inter 5671 fall 2 rise 1
-	server 127.0.15.057 127.0.15.57:80 weight 10 check inter 3573 fall 2 rise 1
-	server 127.0.15.058 127.0.15.58:80 weight 10 check inter 8433 fall 2 rise 1
-	server 127.0.15.059 127.0.15.59:80 weight 10 check inter 1017 fall 2 rise 1
-	server 127.0.15.060 127.0.15.60:80 weight 10 check inter 1360 fall 2 rise 1
-	server 127.0.15.061 127.0.15.61:80 weight 10 check inter 9355 fall 2 rise 1
-	server 127.0.15.062 127.0.15.62:80 weight 10 check inter 984 fall 2 rise 1
-	server 127.0.15.063 127.0.15.63:80 weight 10 check inter 2009 fall 2 rise 1
-	server 127.0.15.064 127.0.15.64:80 weight 10 check inter 7858 fall 2 rise 1
-	server 127.0.15.065 127.0.15.65:80 weight 10 check inter 9870 fall 2 rise 1
-	server 127.0.15.066 127.0.15.66:80 weight 10 check inter 4876 fall 2 rise 1
-	server 127.0.15.067 127.0.15.67:80 weight 10 check inter 4664 fall 2 rise 1
-	server 127.0.15.068 127.0.15.68:80 weight 10 check inter 5758 fall 2 rise 1
-	server 127.0.15.069 127.0.15.69:80 weight 10 check inter 9659 fall 2 rise 1
-	server 127.0.15.070 127.0.15.70:80 weight 10 check inter 6537 fall 2 rise 1
-	server 127.0.15.071 127.0.15.71:80 weight 10 check inter 2677 fall 2 rise 1
-	server 127.0.15.072 127.0.15.72:80 weight 10 check inter 2830 fall 2 rise 1
-	server 127.0.15.073 127.0.15.73:80 weight 10 check inter 1929 fall 2 rise 1
-	server 127.0.15.074 127.0.15.74:80 weight 10 check inter 4190 fall 2 rise 1
-	server 127.0.15.075 127.0.15.75:80 weight 10 check inter 6071 fall 2 rise 1
-	server 127.0.15.076 127.0.15.76:80 weight 10 check inter 4976 fall 2 rise 1
-	server 127.0.15.077 127.0.15.77:80 weight 10 check inter 9153 fall 2 rise 1
-	server 127.0.15.078 127.0.15.78:80 weight 10 check inter 5284 fall 2 rise 1
-	server 127.0.15.079 127.0.15.79:80 weight 10 check inter 5220 fall 2 rise 1
-	server 127.0.15.080 127.0.15.80:80 weight 10 check inter 3768 fall 2 rise 1
-	server 127.0.15.081 127.0.15.81:80 weight 10 check inter 3498 fall 2 rise 1
-	server 127.0.15.082 127.0.15.82:80 weight 10 check inter 6651 fall 2 rise 1
-	server 127.0.15.083 127.0.15.83:80 weight 10 check inter 2496 fall 2 rise 1
-	server 127.0.15.084 127.0.15.84:80 weight 10 check inter 4725 fall 2 rise 1
-	server 127.0.15.085 127.0.15.85:80 weight 10 check inter 4774 fall 2 rise 1
-	server 127.0.15.086 127.0.15.86:80 weight 10 check inter 2121 fall 2 rise 1
-	server 127.0.15.087 127.0.15.87:80 weight 10 check inter 2902 fall 2 rise 1
-	server 127.0.15.088 127.0.15.88:80 weight 10 check inter 751 fall 2 rise 1
-	server 127.0.15.089 127.0.15.89:80 weight 10 check inter 2831 fall 2 rise 1
-	server 127.0.15.090 127.0.15.90:80 weight 10 check inter 6562 fall 2 rise 1
-	server 127.0.15.091 127.0.15.91:80 weight 10 check inter 8072 fall 2 rise 1
-	server 127.0.15.092 127.0.15.92:80 weight 10 check inter 8117 fall 2 rise 1
-	server 127.0.15.093 127.0.15.93:80 weight 10 check inter 223 fall 2 rise 1
-	server 127.0.15.094 127.0.15.94:80 weight 10 check inter 8503 fall 2 rise 1
-	server 127.0.15.095 127.0.15.95:80 weight 10 check inter 262 fall 2 rise 1
-	server 127.0.15.096 127.0.15.96:80 weight 10 check inter 8936 fall 2 rise 1
-	server 127.0.15.097 127.0.15.97:80 weight 10 check inter 1009 fall 2 rise 1
-	server 127.0.15.098 127.0.15.98:80 weight 10 check inter 7358 fall 2 rise 1
-	server 127.0.15.099 127.0.15.99:80 weight 10 check inter 5456 fall 2 rise 1
-	server 127.0.15.100 127.0.15.100:80 weight 10 check inter 9047 fall 2 rise 1
-	server 127.0.15.101 127.0.15.101:80 weight 10 check inter 1051 fall 2 rise 1
-	server 127.0.15.102 127.0.15.102:80 weight 10 check inter 9109 fall 2 rise 1
-	server 127.0.15.103 127.0.15.103:80 weight 10 check inter 684 fall 2 rise 1
-	server 127.0.15.104 127.0.15.104:80 weight 10 check inter 969 fall 2 rise 1
-	server 127.0.15.105 127.0.15.105:80 weight 10 check inter 2104 fall 2 rise 1
-	server 127.0.15.106 127.0.15.106:80 weight 10 check inter 8774 fall 2 rise 1
-	server 127.0.15.107 127.0.15.107:80 weight 10 check inter 9766 fall 2 rise 1
-	server 127.0.15.108 127.0.15.108:80 weight 10 check inter 1917 fall 2 rise 1
-	server 127.0.15.109 127.0.15.109:80 weight 10 check inter 4808 fall 2 rise 1
-	server 127.0.15.110 127.0.15.110:80 weight 10 check inter 3352 fall 2 rise 1
-	server 127.0.15.111 127.0.15.111:80 weight 10 check inter 2859 fall 2 rise 1
-	server 127.0.15.112 127.0.15.112:80 weight 10 check inter 8049 fall 2 rise 1
-	server 127.0.15.113 127.0.15.113:80 weight 10 check inter 4374 fall 2 rise 1
-	server 127.0.15.114 127.0.15.114:80 weight 10 check inter 5451 fall 2 rise 1
-	server 127.0.15.115 127.0.15.115:80 weight 10 check inter 964 fall 2 rise 1
-	server 127.0.15.116 127.0.15.116:80 weight 10 check inter 8516 fall 2 rise 1
-	server 127.0.15.117 127.0.15.117:80 weight 10 check inter 6236 fall 2 rise 1
-	server 127.0.15.118 127.0.15.118:80 weight 10 check inter 1090 fall 2 rise 1
-	server 127.0.15.119 127.0.15.119:80 weight 10 check inter 2307 fall 2 rise 1
-	server 127.0.15.120 127.0.15.120:80 weight 10 check inter 3068 fall 2 rise 1
-	server 127.0.15.121 127.0.15.121:80 weight 10 check inter 3929 fall 2 rise 1
-	server 127.0.15.122 127.0.15.122:80 weight 10 check inter 6990 fall 2 rise 1
-	server 127.0.15.123 127.0.15.123:80 weight 10 check inter 6206 fall 2 rise 1
-	server 127.0.15.124 127.0.15.124:80 weight 10 check inter 2950 fall 2 rise 1
-	server 127.0.15.125 127.0.15.125:80 weight 10 check inter 1998 fall 2 rise 1
-	server 127.0.15.126 127.0.15.126:80 weight 10 check inter 9775 fall 2 rise 1
-	server 127.0.15.127 127.0.15.127:80 weight 10 check inter 1342 fall 2 rise 1
-	server 127.0.15.128 127.0.15.128:80 weight 10 check inter 7330 fall 2 rise 1
-	server 127.0.15.129 127.0.15.129:80 weight 10 check inter 3900 fall 2 rise 1
-	server 127.0.15.130 127.0.15.130:80 weight 10 check inter 8362 fall 2 rise 1
-	server 127.0.15.131 127.0.15.131:80 weight 10 check inter 8502 fall 2 rise 1
-	server 127.0.15.132 127.0.15.132:80 weight 10 check inter 5242 fall 2 rise 1
-	server 127.0.15.133 127.0.15.133:80 weight 10 check inter 3837 fall 2 rise 1
-	server 127.0.15.134 127.0.15.134:80 weight 10 check inter 7064 fall 2 rise 1
-	server 127.0.15.135 127.0.15.135:80 weight 10 check inter 5797 fall 2 rise 1
-	server 127.0.15.136 127.0.15.136:80 weight 10 check inter 7190 fall 2 rise 1
-	server 127.0.15.137 127.0.15.137:80 weight 10 check inter 7588 fall 2 rise 1
-	server 127.0.15.138 127.0.15.138:80 weight 10 check inter 692 fall 2 rise 1
-	server 127.0.15.139 127.0.15.139:80 weight 10 check inter 2570 fall 2 rise 1
-	server 127.0.15.140 127.0.15.140:80 weight 10 check inter 2529 fall 2 rise 1
-	server 127.0.15.141 127.0.15.141:80 weight 10 check inter 1718 fall 2 rise 1
-	server 127.0.15.142 127.0.15.142:80 weight 10 check inter 9154 fall 2 rise 1
-	server 127.0.15.143 127.0.15.143:80 weight 10 check inter 4474 fall 2 rise 1
-	server 127.0.15.144 127.0.15.144:80 weight 10 check inter 4281 fall 2 rise 1
-	server 127.0.15.145 127.0.15.145:80 weight 10 check inter 69 fall 2 rise 1
-	server 127.0.15.146 127.0.15.146:80 weight 10 check inter 5632 fall 2 rise 1
-	server 127.0.15.147 127.0.15.147:80 weight 10 check inter 1907 fall 2 rise 1
-	server 127.0.15.148 127.0.15.148:80 weight 10 check inter 6169 fall 2 rise 1
-	server 127.0.15.149 127.0.15.149:80 weight 10 check inter 1568 fall 2 rise 1
-	server 127.0.15.150 127.0.15.150:80 weight 10 check inter 734 fall 2 rise 1
-	server 127.0.15.151 127.0.15.151:80 weight 10 check inter 3837 fall 2 rise 1
-	server 127.0.15.152 127.0.15.152:80 weight 10 check inter 6103 fall 2 rise 1
-	server 127.0.15.153 127.0.15.153:80 weight 10 check inter 9756 fall 2 rise 1
-	server 127.0.15.154 127.0.15.154:80 weight 10 check inter 4109 fall 2 rise 1
-	server 127.0.15.155 127.0.15.155:80 weight 10 check inter 917 fall 2 rise 1
-	server 127.0.15.156 127.0.15.156:80 weight 10 check inter 1980 fall 2 rise 1
-	server 127.0.15.157 127.0.15.157:80 weight 10 check inter 3617 fall 2 rise 1
-	server 127.0.15.158 127.0.15.158:80 weight 10 check inter 217 fall 2 rise 1
-	server 127.0.15.159 127.0.15.159:80 weight 10 check inter 6505 fall 2 rise 1
-	server 127.0.15.160 127.0.15.160:80 weight 10 check inter 4214 fall 2 rise 1
-	server 127.0.15.161 127.0.15.161:80 weight 10 check inter 7973 fall 2 rise 1
-	server 127.0.15.162 127.0.15.162:80 weight 10 check inter 4198 fall 2 rise 1
-	server 127.0.15.163 127.0.15.163:80 weight 10 check inter 2723 fall 2 rise 1
-	server 127.0.15.164 127.0.15.164:80 weight 10 check inter 4064 fall 2 rise 1
-	server 127.0.15.165 127.0.15.165:80 weight 10 check inter 249 fall 2 rise 1
-	server 127.0.15.166 127.0.15.166:80 weight 10 check inter 4716 fall 2 rise 1
-	server 127.0.15.167 127.0.15.167:80 weight 10 check inter 1590 fall 2 rise 1
-	server 127.0.15.168 127.0.15.168:80 weight 10 check inter 2172 fall 2 rise 1
-	server 127.0.15.169 127.0.15.169:80 weight 10 check inter 2325 fall 2 rise 1
-	server 127.0.15.170 127.0.15.170:80 weight 10 check inter 3825 fall 2 rise 1
-	server 127.0.15.171 127.0.15.171:80 weight 10 check inter 6938 fall 2 rise 1
-	server 127.0.15.172 127.0.15.172:80 weight 10 check inter 4710 fall 2 rise 1
-	server 127.0.15.173 127.0.15.173:80 weight 10 check inter 7219 fall 2 rise 1
-	server 127.0.15.174 127.0.15.174:80 weight 10 check inter 7707 fall 2 rise 1
-	server 127.0.15.175 127.0.15.175:80 weight 10 check inter 1159 fall 2 rise 1
-	server 127.0.15.176 127.0.15.176:80 weight 10 check inter 2761 fall 2 rise 1
-	server 127.0.15.177 127.0.15.177:80 weight 10 check inter 4686 fall 2 rise 1
-	server 127.0.15.178 127.0.15.178:80 weight 10 check inter 2146 fall 2 rise 1
-	server 127.0.15.179 127.0.15.179:80 weight 10 check inter 7587 fall 2 rise 1
-	server 127.0.15.180 127.0.15.180:80 weight 10 check inter 2797 fall 2 rise 1
-	server 127.0.15.181 127.0.15.181:80 weight 10 check inter 2250 fall 2 rise 1
-	server 127.0.15.182 127.0.15.182:80 weight 10 check inter 7511 fall 2 rise 1
-	server 127.0.15.183 127.0.15.183:80 weight 10 check inter 6220 fall 2 rise 1
-	server 127.0.15.184 127.0.15.184:80 weight 10 check inter 503 fall 2 rise 1
-	server 127.0.15.185 127.0.15.185:80 weight 10 check inter 848 fall 2 rise 1
-	server 127.0.15.186 127.0.15.186:80 weight 10 check inter 8519 fall 2 rise 1
-	server 127.0.15.187 127.0.15.187:80 weight 10 check inter 6084 fall 2 rise 1
-	server 127.0.15.188 127.0.15.188:80 weight 10 check inter 4878 fall 2 rise 1
-	server 127.0.15.189 127.0.15.189:80 weight 10 check inter 816 fall 2 rise 1
-	server 127.0.15.190 127.0.15.190:80 weight 10 check inter 1677 fall 2 rise 1
-	server 127.0.15.191 127.0.15.191:80 weight 10 check inter 3919 fall 2 rise 1
-	server 127.0.15.192 127.0.15.192:80 weight 10 check inter 703 fall 2 rise 1
-	server 127.0.15.193 127.0.15.193:80 weight 10 check inter 9236 fall 2 rise 1
-	server 127.0.15.194 127.0.15.194:80 weight 10 check inter 1227 fall 2 rise 1
-	server 127.0.15.195 127.0.15.195:80 weight 10 check inter 958 fall 2 rise 1
-	server 127.0.15.196 127.0.15.196:80 weight 10 check inter 480 fall 2 rise 1
-	server 127.0.15.197 127.0.15.197:80 weight 10 check inter 6550 fall 2 rise 1
-	server 127.0.15.198 127.0.15.198:80 weight 10 check inter 4503 fall 2 rise 1
-	server 127.0.15.199 127.0.15.199:80 weight 10 check inter 6409 fall 2 rise 1
-	server 127.0.15.200 127.0.15.200:80 weight 10 check inter 6532 fall 2 rise 1
-	server 127.0.15.201 127.0.15.201:80 weight 10 check inter 674 fall 2 rise 1
-	server 127.0.15.202 127.0.15.202:80 weight 10 check inter 1030 fall 2 rise 1
-	server 127.0.15.203 127.0.15.203:80 weight 10 check inter 6478 fall 2 rise 1
-	server 127.0.15.204 127.0.15.204:80 weight 10 check inter 1604 fall 2 rise 1
-	server 127.0.15.205 127.0.15.205:80 weight 10 check inter 7145 fall 2 rise 1
-	server 127.0.15.206 127.0.15.206:80 weight 10 check inter 3849 fall 2 rise 1
-	server 127.0.15.207 127.0.15.207:80 weight 10 check inter 7084 fall 2 rise 1
-	server 127.0.15.208 127.0.15.208:80 weight 10 check inter 5416 fall 2 rise 1
-	server 127.0.15.209 127.0.15.209:80 weight 10 check inter 7210 fall 2 rise 1
-	server 127.0.15.210 127.0.15.210:80 weight 10 check inter 8921 fall 2 rise 1
-	server 127.0.15.211 127.0.15.211:80 weight 10 check inter 6958 fall 2 rise 1
-	server 127.0.15.212 127.0.15.212:80 weight 10 check inter 9831 fall 2 rise 1
-	server 127.0.15.213 127.0.15.213:80 weight 10 check inter 3793 fall 2 rise 1
-	server 127.0.15.214 127.0.15.214:80 weight 10 check inter 1539 fall 2 rise 1
-	server 127.0.15.215 127.0.15.215:80 weight 10 check inter 184 fall 2 rise 1
-	server 127.0.15.216 127.0.15.216:80 weight 10 check inter 1316 fall 2 rise 1
-	server 127.0.15.217 127.0.15.217:80 weight 10 check inter 2621 fall 2 rise 1
-	server 127.0.15.218 127.0.15.218:80 weight 10 check inter 2564 fall 2 rise 1
-	server 127.0.15.219 127.0.15.219:80 weight 10 check inter 7811 fall 2 rise 1
-	server 127.0.15.220 127.0.15.220:80 weight 10 check inter 9333 fall 2 rise 1
-	server 127.0.15.221 127.0.15.221:80 weight 10 check inter 2290 fall 2 rise 1
-	server 127.0.15.222 127.0.15.222:80 weight 10 check inter 291 fall 2 rise 1
-	server 127.0.15.223 127.0.15.223:80 weight 10 check inter 3753 fall 2 rise 1
-	server 127.0.15.224 127.0.15.224:80 weight 10 check inter 9538 fall 2 rise 1
-	server 127.0.15.225 127.0.15.225:80 weight 10 check inter 6883 fall 2 rise 1
-	server 127.0.15.226 127.0.15.226:80 weight 10 check inter 3714 fall 2 rise 1
-	server 127.0.15.227 127.0.15.227:80 weight 10 check inter 1039 fall 2 rise 1
-	server 127.0.15.228 127.0.15.228:80 weight 10 check inter 4082 fall 2 rise 1
-	server 127.0.15.229 127.0.15.229:80 weight 10 check inter 7501 fall 2 rise 1
-	server 127.0.15.230 127.0.15.230:80 weight 10 check inter 8690 fall 2 rise 1
-	server 127.0.15.231 127.0.15.231:80 weight 10 check inter 4437 fall 2 rise 1
-	server 127.0.15.232 127.0.15.232:80 weight 10 check inter 8054 fall 2 rise 1
-	server 127.0.15.233 127.0.15.233:80 weight 10 check inter 1876 fall 2 rise 1
-	server 127.0.15.234 127.0.15.234:80 weight 10 check inter 8601 fall 2 rise 1
-	server 127.0.15.235 127.0.15.235:80 weight 10 check inter 9791 fall 2 rise 1
-	server 127.0.15.236 127.0.15.236:80 weight 10 check inter 5441 fall 2 rise 1
-	server 127.0.15.237 127.0.15.237:80 weight 10 check inter 1358 fall 2 rise 1
-	server 127.0.15.238 127.0.15.238:80 weight 10 check inter 549 fall 2 rise 1
-	server 127.0.15.239 127.0.15.239:80 weight 10 check inter 3952 fall 2 rise 1
-	server 127.0.15.240 127.0.15.240:80 weight 10 check inter 1342 fall 2 rise 1
-	server 127.0.15.241 127.0.15.241:80 weight 10 check inter 5969 fall 2 rise 1
-	server 127.0.15.242 127.0.15.242:80 weight 10 check inter 1629 fall 2 rise 1
-	server 127.0.15.243 127.0.15.243:80 weight 10 check inter 5659 fall 2 rise 1
-	server 127.0.15.244 127.0.15.244:80 weight 10 check inter 1184 fall 2 rise 1
-	server 127.0.15.245 127.0.15.245:80 weight 10 check inter 7437 fall 2 rise 1
-	server 127.0.15.246 127.0.15.246:80 weight 10 check inter 2763 fall 2 rise 1
-	server 127.0.15.247 127.0.15.247:80 weight 10 check inter 3370 fall 2 rise 1
-	server 127.0.15.248 127.0.15.248:80 weight 10 check inter 9063 fall 2 rise 1
-	server 127.0.15.249 127.0.15.249:80 weight 10 check inter 8138 fall 2 rise 1
-	server 127.0.15.250 127.0.15.250:80 weight 10 check inter 2028 fall 2 rise 1
-	server 127.0.16.001 127.0.16.1:80 weight 10 check inter 1659 fall 2 rise 1
-	server 127.0.16.002 127.0.16.2:80 weight 10 check inter 1048 fall 2 rise 1
-	server 127.0.16.003 127.0.16.3:80 weight 10 check inter 9072 fall 2 rise 1
-	server 127.0.16.004 127.0.16.4:80 weight 10 check inter 323 fall 2 rise 1
-	server 127.0.16.005 127.0.16.5:80 weight 10 check inter 7549 fall 2 rise 1
-	server 127.0.16.006 127.0.16.6:80 weight 10 check inter 3401 fall 2 rise 1
-	server 127.0.16.007 127.0.16.7:80 weight 10 check inter 9448 fall 2 rise 1
-	server 127.0.16.008 127.0.16.8:80 weight 10 check inter 5969 fall 2 rise 1
-	server 127.0.16.009 127.0.16.9:80 weight 10 check inter 1950 fall 2 rise 1
-	server 127.0.16.010 127.0.16.10:80 weight 10 check inter 1407 fall 2 rise 1
-	server 127.0.16.011 127.0.16.11:80 weight 10 check inter 6357 fall 2 rise 1
-	server 127.0.16.012 127.0.16.12:80 weight 10 check inter 2134 fall 2 rise 1
-	server 127.0.16.013 127.0.16.13:80 weight 10 check inter 162 fall 2 rise 1
-	server 127.0.16.014 127.0.16.14:80 weight 10 check inter 6152 fall 2 rise 1
-	server 127.0.16.015 127.0.16.15:80 weight 10 check inter 7282 fall 2 rise 1
-	server 127.0.16.016 127.0.16.16:80 weight 10 check inter 7347 fall 2 rise 1
-	server 127.0.16.017 127.0.16.17:80 weight 10 check inter 3859 fall 2 rise 1
-	server 127.0.16.018 127.0.16.18:80 weight 10 check inter 6472 fall 2 rise 1
-	server 127.0.16.019 127.0.16.19:80 weight 10 check inter 987 fall 2 rise 1
-	server 127.0.16.020 127.0.16.20:80 weight 10 check inter 599 fall 2 rise 1
-	server 127.0.16.021 127.0.16.21:80 weight 10 check inter 4843 fall 2 rise 1
-	server 127.0.16.022 127.0.16.22:80 weight 10 check inter 4036 fall 2 rise 1
-	server 127.0.16.023 127.0.16.23:80 weight 10 check inter 5243 fall 2 rise 1
-	server 127.0.16.024 127.0.16.24:80 weight 10 check inter 2149 fall 2 rise 1
-	server 127.0.16.025 127.0.16.25:80 weight 10 check inter 1555 fall 2 rise 1
-	server 127.0.16.026 127.0.16.26:80 weight 10 check inter 4319 fall 2 rise 1
-	server 127.0.16.027 127.0.16.27:80 weight 10 check inter 1224 fall 2 rise 1
-	server 127.0.16.028 127.0.16.28:80 weight 10 check inter 3720 fall 2 rise 1
-	server 127.0.16.029 127.0.16.29:80 weight 10 check inter 5417 fall 2 rise 1
-	server 127.0.16.030 127.0.16.30:80 weight 10 check inter 360 fall 2 rise 1
-	server 127.0.16.031 127.0.16.31:80 weight 10 check inter 2576 fall 2 rise 1
-	server 127.0.16.032 127.0.16.32:80 weight 10 check inter 2742 fall 2 rise 1
-	server 127.0.16.033 127.0.16.33:80 weight 10 check inter 9874 fall 2 rise 1
-	server 127.0.16.034 127.0.16.34:80 weight 10 check inter 2048 fall 2 rise 1
-	server 127.0.16.035 127.0.16.35:80 weight 10 check inter 6849 fall 2 rise 1
-	server 127.0.16.036 127.0.16.36:80 weight 10 check inter 8629 fall 2 rise 1
-	server 127.0.16.037 127.0.16.37:80 weight 10 check inter 8853 fall 2 rise 1
-	server 127.0.16.038 127.0.16.38:80 weight 10 check inter 4908 fall 2 rise 1
-	server 127.0.16.039 127.0.16.39:80 weight 10 check inter 5884 fall 2 rise 1
-	server 127.0.16.040 127.0.16.40:80 weight 10 check inter 209 fall 2 rise 1
-	server 127.0.16.041 127.0.16.41:80 weight 10 check inter 2132 fall 2 rise 1
-	server 127.0.16.042 127.0.16.42:80 weight 10 check inter 847 fall 2 rise 1
-	server 127.0.16.043 127.0.16.43:80 weight 10 check inter 7640 fall 2 rise 1
-	server 127.0.16.044 127.0.16.44:80 weight 10 check inter 585 fall 2 rise 1
-	server 127.0.16.045 127.0.16.45:80 weight 10 check inter 6680 fall 2 rise 1
-	server 127.0.16.046 127.0.16.46:80 weight 10 check inter 2948 fall 2 rise 1
-	server 127.0.16.047 127.0.16.47:80 weight 10 check inter 1429 fall 2 rise 1
-	server 127.0.16.048 127.0.16.48:80 weight 10 check inter 9820 fall 2 rise 1
-	server 127.0.16.049 127.0.16.49:80 weight 10 check inter 660 fall 2 rise 1
-	server 127.0.16.050 127.0.16.50:80 weight 10 check inter 2959 fall 2 rise 1
-	server 127.0.16.051 127.0.16.51:80 weight 10 check inter 7351 fall 2 rise 1
-	server 127.0.16.052 127.0.16.52:80 weight 10 check inter 4919 fall 2 rise 1
-	server 127.0.16.053 127.0.16.53:80 weight 10 check inter 7606 fall 2 rise 1
-	server 127.0.16.054 127.0.16.54:80 weight 10 check inter 9697 fall 2 rise 1
-	server 127.0.16.055 127.0.16.55:80 weight 10 check inter 8655 fall 2 rise 1
-	server 127.0.16.056 127.0.16.56:80 weight 10 check inter 6875 fall 2 rise 1
-	server 127.0.16.057 127.0.16.57:80 weight 10 check inter 9196 fall 2 rise 1
-	server 127.0.16.058 127.0.16.58:80 weight 10 check inter 3021 fall 2 rise 1
-	server 127.0.16.059 127.0.16.59:80 weight 10 check inter 1688 fall 2 rise 1
-	server 127.0.16.060 127.0.16.60:80 weight 10 check inter 608 fall 2 rise 1
-	server 127.0.16.061 127.0.16.61:80 weight 10 check inter 1805 fall 2 rise 1
-	server 127.0.16.062 127.0.16.62:80 weight 10 check inter 1758 fall 2 rise 1
-	server 127.0.16.063 127.0.16.63:80 weight 10 check inter 5990 fall 2 rise 1
-	server 127.0.16.064 127.0.16.64:80 weight 10 check inter 1212 fall 2 rise 1
-	server 127.0.16.065 127.0.16.65:80 weight 10 check inter 8626 fall 2 rise 1
-	server 127.0.16.066 127.0.16.66:80 weight 10 check inter 5140 fall 2 rise 1
-	server 127.0.16.067 127.0.16.67:80 weight 10 check inter 3647 fall 2 rise 1
-	server 127.0.16.068 127.0.16.68:80 weight 10 check inter 1889 fall 2 rise 1
-	server 127.0.16.069 127.0.16.69:80 weight 10 check inter 5352 fall 2 rise 1
-	server 127.0.16.070 127.0.16.70:80 weight 10 check inter 5538 fall 2 rise 1
-	server 127.0.16.071 127.0.16.71:80 weight 10 check inter 4486 fall 2 rise 1
-	server 127.0.16.072 127.0.16.72:80 weight 10 check inter 1466 fall 2 rise 1
-	server 127.0.16.073 127.0.16.73:80 weight 10 check inter 2247 fall 2 rise 1
-	server 127.0.16.074 127.0.16.74:80 weight 10 check inter 1577 fall 2 rise 1
-	server 127.0.16.075 127.0.16.75:80 weight 10 check inter 7132 fall 2 rise 1
-	server 127.0.16.076 127.0.16.76:80 weight 10 check inter 9620 fall 2 rise 1
-	server 127.0.16.077 127.0.16.77:80 weight 10 check inter 4624 fall 2 rise 1
-	server 127.0.16.078 127.0.16.78:80 weight 10 check inter 4962 fall 2 rise 1
-	server 127.0.16.079 127.0.16.79:80 weight 10 check inter 2661 fall 2 rise 1
-	server 127.0.16.080 127.0.16.80:80 weight 10 check inter 2012 fall 2 rise 1
-	server 127.0.16.081 127.0.16.81:80 weight 10 check inter 1625 fall 2 rise 1
-	server 127.0.16.082 127.0.16.82:80 weight 10 check inter 9486 fall 2 rise 1
-	server 127.0.16.083 127.0.16.83:80 weight 10 check inter 6875 fall 2 rise 1
-	server 127.0.16.084 127.0.16.84:80 weight 10 check inter 7020 fall 2 rise 1
-	server 127.0.16.085 127.0.16.85:80 weight 10 check inter 8695 fall 2 rise 1
-	server 127.0.16.086 127.0.16.86:80 weight 10 check inter 6158 fall 2 rise 1
-	server 127.0.16.087 127.0.16.87:80 weight 10 check inter 1942 fall 2 rise 1
-	server 127.0.16.088 127.0.16.88:80 weight 10 check inter 101 fall 2 rise 1
-	server 127.0.16.089 127.0.16.89:80 weight 10 check inter 7056 fall 2 rise 1
-	server 127.0.16.090 127.0.16.90:80 weight 10 check inter 1857 fall 2 rise 1
-	server 127.0.16.091 127.0.16.91:80 weight 10 check inter 1094 fall 2 rise 1
-	server 127.0.16.092 127.0.16.92:80 weight 10 check inter 8380 fall 2 rise 1
-	server 127.0.16.093 127.0.16.93:80 weight 10 check inter 1086 fall 2 rise 1
-	server 127.0.16.094 127.0.16.94:80 weight 10 check inter 2513 fall 2 rise 1
-	server 127.0.16.095 127.0.16.95:80 weight 10 check inter 8853 fall 2 rise 1
-	server 127.0.16.096 127.0.16.96:80 weight 10 check inter 2916 fall 2 rise 1
-	server 127.0.16.097 127.0.16.97:80 weight 10 check inter 3538 fall 2 rise 1
-	server 127.0.16.098 127.0.16.98:80 weight 10 check inter 6684 fall 2 rise 1
-	server 127.0.16.099 127.0.16.99:80 weight 10 check inter 3216 fall 2 rise 1
-	server 127.0.16.100 127.0.16.100:80 weight 10 check inter 3215 fall 2 rise 1
-	server 127.0.16.101 127.0.16.101:80 weight 10 check inter 2270 fall 2 rise 1
-	server 127.0.16.102 127.0.16.102:80 weight 10 check inter 2243 fall 2 rise 1
-	server 127.0.16.103 127.0.16.103:80 weight 10 check inter 6735 fall 2 rise 1
-	server 127.0.16.104 127.0.16.104:80 weight 10 check inter 7140 fall 2 rise 1
-	server 127.0.16.105 127.0.16.105:80 weight 10 check inter 6881 fall 2 rise 1
-	server 127.0.16.106 127.0.16.106:80 weight 10 check inter 8021 fall 2 rise 1
-	server 127.0.16.107 127.0.16.107:80 weight 10 check inter 9114 fall 2 rise 1
-	server 127.0.16.108 127.0.16.108:80 weight 10 check inter 7407 fall 2 rise 1
-	server 127.0.16.109 127.0.16.109:80 weight 10 check inter 7697 fall 2 rise 1
-	server 127.0.16.110 127.0.16.110:80 weight 10 check inter 3113 fall 2 rise 1
-	server 127.0.16.111 127.0.16.111:80 weight 10 check inter 5274 fall 2 rise 1
-	server 127.0.16.112 127.0.16.112:80 weight 10 check inter 1659 fall 2 rise 1
-	server 127.0.16.113 127.0.16.113:80 weight 10 check inter 6570 fall 2 rise 1
-	server 127.0.16.114 127.0.16.114:80 weight 10 check inter 4189 fall 2 rise 1
-	server 127.0.16.115 127.0.16.115:80 weight 10 check inter 6175 fall 2 rise 1
-	server 127.0.16.116 127.0.16.116:80 weight 10 check inter 3008 fall 2 rise 1
-	server 127.0.16.117 127.0.16.117:80 weight 10 check inter 4872 fall 2 rise 1
-	server 127.0.16.118 127.0.16.118:80 weight 10 check inter 5650 fall 2 rise 1
-	server 127.0.16.119 127.0.16.119:80 weight 10 check inter 4023 fall 2 rise 1
-	server 127.0.16.120 127.0.16.120:80 weight 10 check inter 1709 fall 2 rise 1
-	server 127.0.16.121 127.0.16.121:80 weight 10 check inter 3062 fall 2 rise 1
-	server 127.0.16.122 127.0.16.122:80 weight 10 check inter 644 fall 2 rise 1
-	server 127.0.16.123 127.0.16.123:80 weight 10 check inter 2969 fall 2 rise 1
-	server 127.0.16.124 127.0.16.124:80 weight 10 check inter 8420 fall 2 rise 1
-	server 127.0.16.125 127.0.16.125:80 weight 10 check inter 4884 fall 2 rise 1
-	server 127.0.16.126 127.0.16.126:80 weight 10 check inter 746 fall 2 rise 1
-	server 127.0.16.127 127.0.16.127:80 weight 10 check inter 981 fall 2 rise 1
-	server 127.0.16.128 127.0.16.128:80 weight 10 check inter 7848 fall 2 rise 1
-	server 127.0.16.129 127.0.16.129:80 weight 10 check inter 2458 fall 2 rise 1
-	server 127.0.16.130 127.0.16.130:80 weight 10 check inter 1057 fall 2 rise 1
-	server 127.0.16.131 127.0.16.131:80 weight 10 check inter 573 fall 2 rise 1
-	server 127.0.16.132 127.0.16.132:80 weight 10 check inter 4471 fall 2 rise 1
-	server 127.0.16.133 127.0.16.133:80 weight 10 check inter 7904 fall 2 rise 1
-	server 127.0.16.134 127.0.16.134:80 weight 10 check inter 8072 fall 2 rise 1
-	server 127.0.16.135 127.0.16.135:80 weight 10 check inter 3455 fall 2 rise 1
-	server 127.0.16.136 127.0.16.136:80 weight 10 check inter 7447 fall 2 rise 1
-	server 127.0.16.137 127.0.16.137:80 weight 10 check inter 4537 fall 2 rise 1
-	server 127.0.16.138 127.0.16.138:80 weight 10 check inter 924 fall 2 rise 1
-	server 127.0.16.139 127.0.16.139:80 weight 10 check inter 1897 fall 2 rise 1
-	server 127.0.16.140 127.0.16.140:80 weight 10 check inter 242 fall 2 rise 1
-	server 127.0.16.141 127.0.16.141:80 weight 10 check inter 5443 fall 2 rise 1
-	server 127.0.16.142 127.0.16.142:80 weight 10 check inter 5490 fall 2 rise 1
-	server 127.0.16.143 127.0.16.143:80 weight 10 check inter 2907 fall 2 rise 1
-	server 127.0.16.144 127.0.16.144:80 weight 10 check inter 2705 fall 2 rise 1
-	server 127.0.16.145 127.0.16.145:80 weight 10 check inter 3071 fall 2 rise 1
-	server 127.0.16.146 127.0.16.146:80 weight 10 check inter 454 fall 2 rise 1
-	server 127.0.16.147 127.0.16.147:80 weight 10 check inter 3131 fall 2 rise 1
-	server 127.0.16.148 127.0.16.148:80 weight 10 check inter 4346 fall 2 rise 1
-	server 127.0.16.149 127.0.16.149:80 weight 10 check inter 3200 fall 2 rise 1
-	server 127.0.16.150 127.0.16.150:80 weight 10 check inter 3109 fall 2 rise 1
-	server 127.0.16.151 127.0.16.151:80 weight 10 check inter 3163 fall 2 rise 1
-	server 127.0.16.152 127.0.16.152:80 weight 10 check inter 1177 fall 2 rise 1
-	server 127.0.16.153 127.0.16.153:80 weight 10 check inter 7366 fall 2 rise 1
-	server 127.0.16.154 127.0.16.154:80 weight 10 check inter 5516 fall 2 rise 1
-	server 127.0.16.155 127.0.16.155:80 weight 10 check inter 411 fall 2 rise 1
-	server 127.0.16.156 127.0.16.156:80 weight 10 check inter 1936 fall 2 rise 1
-	server 127.0.16.157 127.0.16.157:80 weight 10 check inter 7896 fall 2 rise 1
-	server 127.0.16.158 127.0.16.158:80 weight 10 check inter 4512 fall 2 rise 1
-	server 127.0.16.159 127.0.16.159:80 weight 10 check inter 2606 fall 2 rise 1
-	server 127.0.16.160 127.0.16.160:80 weight 10 check inter 9438 fall 2 rise 1
-	server 127.0.16.161 127.0.16.161:80 weight 10 check inter 7155 fall 2 rise 1
-	server 127.0.16.162 127.0.16.162:80 weight 10 check inter 6186 fall 2 rise 1
-	server 127.0.16.163 127.0.16.163:80 weight 10 check inter 9229 fall 2 rise 1
-	server 127.0.16.164 127.0.16.164:80 weight 10 check inter 3952 fall 2 rise 1
-	server 127.0.16.165 127.0.16.165:80 weight 10 check inter 852 fall 2 rise 1
-	server 127.0.16.166 127.0.16.166:80 weight 10 check inter 1544 fall 2 rise 1
-	server 127.0.16.167 127.0.16.167:80 weight 10 check inter 350 fall 2 rise 1
-	server 127.0.16.168 127.0.16.168:80 weight 10 check inter 6043 fall 2 rise 1
-	server 127.0.16.169 127.0.16.169:80 weight 10 check inter 1479 fall 2 rise 1
-	server 127.0.16.170 127.0.16.170:80 weight 10 check inter 1813 fall 2 rise 1
-	server 127.0.16.171 127.0.16.171:80 weight 10 check inter 2290 fall 2 rise 1
-	server 127.0.16.172 127.0.16.172:80 weight 10 check inter 1477 fall 2 rise 1
-	server 127.0.16.173 127.0.16.173:80 weight 10 check inter 7710 fall 2 rise 1
-	server 127.0.16.174 127.0.16.174:80 weight 10 check inter 115 fall 2 rise 1
-	server 127.0.16.175 127.0.16.175:80 weight 10 check inter 4081 fall 2 rise 1
-	server 127.0.16.176 127.0.16.176:80 weight 10 check inter 3606 fall 2 rise 1
-	server 127.0.16.177 127.0.16.177:80 weight 10 check inter 2624 fall 2 rise 1
-	server 127.0.16.178 127.0.16.178:80 weight 10 check inter 5214 fall 2 rise 1
-	server 127.0.16.179 127.0.16.179:80 weight 10 check inter 2422 fall 2 rise 1
-	server 127.0.16.180 127.0.16.180:80 weight 10 check inter 7858 fall 2 rise 1
-	server 127.0.16.181 127.0.16.181:80 weight 10 check inter 2119 fall 2 rise 1
-	server 127.0.16.182 127.0.16.182:80 weight 10 check inter 7872 fall 2 rise 1
-	server 127.0.16.183 127.0.16.183:80 weight 10 check inter 5274 fall 2 rise 1
-	server 127.0.16.184 127.0.16.184:80 weight 10 check inter 6339 fall 2 rise 1
-	server 127.0.16.185 127.0.16.185:80 weight 10 check inter 1272 fall 2 rise 1
-	server 127.0.16.186 127.0.16.186:80 weight 10 check inter 6164 fall 2 rise 1
-	server 127.0.16.187 127.0.16.187:80 weight 10 check inter 3938 fall 2 rise 1
-	server 127.0.16.188 127.0.16.188:80 weight 10 check inter 9960 fall 2 rise 1
-	server 127.0.16.189 127.0.16.189:80 weight 10 check inter 7888 fall 2 rise 1
-	server 127.0.16.190 127.0.16.190:80 weight 10 check inter 9035 fall 2 rise 1
-	server 127.0.16.191 127.0.16.191:80 weight 10 check inter 3303 fall 2 rise 1
-	server 127.0.16.192 127.0.16.192:80 weight 10 check inter 95 fall 2 rise 1
-	server 127.0.16.193 127.0.16.193:80 weight 10 check inter 6083 fall 2 rise 1
-	server 127.0.16.194 127.0.16.194:80 weight 10 check inter 8016 fall 2 rise 1
-	server 127.0.16.195 127.0.16.195:80 weight 10 check inter 3961 fall 2 rise 1
-	server 127.0.16.196 127.0.16.196:80 weight 10 check inter 9780 fall 2 rise 1
-	server 127.0.16.197 127.0.16.197:80 weight 10 check inter 8324 fall 2 rise 1
-	server 127.0.16.198 127.0.16.198:80 weight 10 check inter 2812 fall 2 rise 1
-	server 127.0.16.199 127.0.16.199:80 weight 10 check inter 3539 fall 2 rise 1
-	server 127.0.16.200 127.0.16.200:80 weight 10 check inter 2792 fall 2 rise 1
-	server 127.0.16.201 127.0.16.201:80 weight 10 check inter 2355 fall 2 rise 1
-	server 127.0.16.202 127.0.16.202:80 weight 10 check inter 3000 fall 2 rise 1
-	server 127.0.16.203 127.0.16.203:80 weight 10 check inter 5597 fall 2 rise 1
-	server 127.0.16.204 127.0.16.204:80 weight 10 check inter 896 fall 2 rise 1
-	server 127.0.16.205 127.0.16.205:80 weight 10 check inter 186 fall 2 rise 1
-	server 127.0.16.206 127.0.16.206:80 weight 10 check inter 6647 fall 2 rise 1
-	server 127.0.16.207 127.0.16.207:80 weight 10 check inter 7732 fall 2 rise 1
-	server 127.0.16.208 127.0.16.208:80 weight 10 check inter 6258 fall 2 rise 1
-	server 127.0.16.209 127.0.16.209:80 weight 10 check inter 646 fall 2 rise 1
-	server 127.0.16.210 127.0.16.210:80 weight 10 check inter 1727 fall 2 rise 1
-	server 127.0.16.211 127.0.16.211:80 weight 10 check inter 8921 fall 2 rise 1
-	server 127.0.16.212 127.0.16.212:80 weight 10 check inter 2959 fall 2 rise 1
-	server 127.0.16.213 127.0.16.213:80 weight 10 check inter 2070 fall 2 rise 1
-	server 127.0.16.214 127.0.16.214:80 weight 10 check inter 907 fall 2 rise 1
-	server 127.0.16.215 127.0.16.215:80 weight 10 check inter 1148 fall 2 rise 1
-	server 127.0.16.216 127.0.16.216:80 weight 10 check inter 161 fall 2 rise 1
-	server 127.0.16.217 127.0.16.217:80 weight 10 check inter 1076 fall 2 rise 1
-	server 127.0.16.218 127.0.16.218:80 weight 10 check inter 290 fall 2 rise 1
-	server 127.0.16.219 127.0.16.219:80 weight 10 check inter 3638 fall 2 rise 1
-	server 127.0.16.220 127.0.16.220:80 weight 10 check inter 7188 fall 2 rise 1
-	server 127.0.16.221 127.0.16.221:80 weight 10 check inter 2934 fall 2 rise 1
-	server 127.0.16.222 127.0.16.222:80 weight 10 check inter 1172 fall 2 rise 1
-	server 127.0.16.223 127.0.16.223:80 weight 10 check inter 5833 fall 2 rise 1
-	server 127.0.16.224 127.0.16.224:80 weight 10 check inter 9508 fall 2 rise 1
-	server 127.0.16.225 127.0.16.225:80 weight 10 check inter 9924 fall 2 rise 1
-	server 127.0.16.226 127.0.16.226:80 weight 10 check inter 8810 fall 2 rise 1
-	server 127.0.16.227 127.0.16.227:80 weight 10 check inter 3577 fall 2 rise 1
-	server 127.0.16.228 127.0.16.228:80 weight 10 check inter 7130 fall 2 rise 1
-	server 127.0.16.229 127.0.16.229:80 weight 10 check inter 5063 fall 2 rise 1
-	server 127.0.16.230 127.0.16.230:80 weight 10 check inter 1963 fall 2 rise 1
-	server 127.0.16.231 127.0.16.231:80 weight 10 check inter 1255 fall 2 rise 1
-	server 127.0.16.232 127.0.16.232:80 weight 10 check inter 4837 fall 2 rise 1
-	server 127.0.16.233 127.0.16.233:80 weight 10 check inter 6806 fall 2 rise 1
-	server 127.0.16.234 127.0.16.234:80 weight 10 check inter 350 fall 2 rise 1
-	server 127.0.16.235 127.0.16.235:80 weight 10 check inter 5617 fall 2 rise 1
-	server 127.0.16.236 127.0.16.236:80 weight 10 check inter 9802 fall 2 rise 1
-	server 127.0.16.237 127.0.16.237:80 weight 10 check inter 6096 fall 2 rise 1
-	server 127.0.16.238 127.0.16.238:80 weight 10 check inter 7444 fall 2 rise 1
-	server 127.0.16.239 127.0.16.239:80 weight 10 check inter 2139 fall 2 rise 1
-	server 127.0.16.240 127.0.16.240:80 weight 10 check inter 4300 fall 2 rise 1
-	server 127.0.16.241 127.0.16.241:80 weight 10 check inter 312 fall 2 rise 1
-	server 127.0.16.242 127.0.16.242:80 weight 10 check inter 8496 fall 2 rise 1
-	server 127.0.16.243 127.0.16.243:80 weight 10 check inter 7068 fall 2 rise 1
-	server 127.0.16.244 127.0.16.244:80 weight 10 check inter 1659 fall 2 rise 1
-	server 127.0.16.245 127.0.16.245:80 weight 10 check inter 2099 fall 2 rise 1
-	server 127.0.16.246 127.0.16.246:80 weight 10 check inter 8653 fall 2 rise 1
-	server 127.0.16.247 127.0.16.247:80 weight 10 check inter 6456 fall 2 rise 1
-	server 127.0.16.248 127.0.16.248:80 weight 10 check inter 124 fall 2 rise 1
-	server 127.0.16.249 127.0.16.249:80 weight 10 check inter 4227 fall 2 rise 1
-	server 127.0.16.250 127.0.16.250:80 weight 10 check inter 9150 fall 2 rise 1
-	server 127.0.17.001 127.0.17.1:80 weight 10 check inter 2561 fall 2 rise 1
-	server 127.0.17.002 127.0.17.2:80 weight 10 check inter 2603 fall 2 rise 1
-	server 127.0.17.003 127.0.17.3:80 weight 10 check inter 9713 fall 2 rise 1
-	server 127.0.17.004 127.0.17.4:80 weight 10 check inter 7715 fall 2 rise 1
-	server 127.0.17.005 127.0.17.5:80 weight 10 check inter 9532 fall 2 rise 1
-	server 127.0.17.006 127.0.17.6:80 weight 10 check inter 5267 fall 2 rise 1
-	server 127.0.17.007 127.0.17.7:80 weight 10 check inter 3277 fall 2 rise 1
-	server 127.0.17.008 127.0.17.8:80 weight 10 check inter 1617 fall 2 rise 1
-	server 127.0.17.009 127.0.17.9:80 weight 10 check inter 2612 fall 2 rise 1
-	server 127.0.17.010 127.0.17.10:80 weight 10 check inter 7609 fall 2 rise 1
-	server 127.0.17.011 127.0.17.11:80 weight 10 check inter 1653 fall 2 rise 1
-	server 127.0.17.012 127.0.17.12:80 weight 10 check inter 3486 fall 2 rise 1
-	server 127.0.17.013 127.0.17.13:80 weight 10 check inter 3842 fall 2 rise 1
-	server 127.0.17.014 127.0.17.14:80 weight 10 check inter 2764 fall 2 rise 1
-	server 127.0.17.015 127.0.17.15:80 weight 10 check inter 5623 fall 2 rise 1
-	server 127.0.17.016 127.0.17.16:80 weight 10 check inter 511 fall 2 rise 1
-	server 127.0.17.017 127.0.17.17:80 weight 10 check inter 5719 fall 2 rise 1
-	server 127.0.17.018 127.0.17.18:80 weight 10 check inter 7629 fall 2 rise 1
-	server 127.0.17.019 127.0.17.19:80 weight 10 check inter 7270 fall 2 rise 1
-	server 127.0.17.020 127.0.17.20:80 weight 10 check inter 3730 fall 2 rise 1
-	server 127.0.17.021 127.0.17.21:80 weight 10 check inter 3231 fall 2 rise 1
-	server 127.0.17.022 127.0.17.22:80 weight 10 check inter 350 fall 2 rise 1
-	server 127.0.17.023 127.0.17.23:80 weight 10 check inter 414 fall 2 rise 1
-	server 127.0.17.024 127.0.17.24:80 weight 10 check inter 346 fall 2 rise 1
-	server 127.0.17.025 127.0.17.25:80 weight 10 check inter 7030 fall 2 rise 1
-	server 127.0.17.026 127.0.17.26:80 weight 10 check inter 1324 fall 2 rise 1
-	server 127.0.17.027 127.0.17.27:80 weight 10 check inter 4328 fall 2 rise 1
-	server 127.0.17.028 127.0.17.28:80 weight 10 check inter 6414 fall 2 rise 1
-	server 127.0.17.029 127.0.17.29:80 weight 10 check inter 1751 fall 2 rise 1
-	server 127.0.17.030 127.0.17.30:80 weight 10 check inter 2684 fall 2 rise 1
-	server 127.0.17.031 127.0.17.31:80 weight 10 check inter 396 fall 2 rise 1
-	server 127.0.17.032 127.0.17.32:80 weight 10 check inter 2017 fall 2 rise 1
-	server 127.0.17.033 127.0.17.33:80 weight 10 check inter 3321 fall 2 rise 1
-	server 127.0.17.034 127.0.17.34:80 weight 10 check inter 8855 fall 2 rise 1
-	server 127.0.17.035 127.0.17.35:80 weight 10 check inter 9674 fall 2 rise 1
-	server 127.0.17.036 127.0.17.36:80 weight 10 check inter 8159 fall 2 rise 1
-	server 127.0.17.037 127.0.17.37:80 weight 10 check inter 4151 fall 2 rise 1
-	server 127.0.17.038 127.0.17.38:80 weight 10 check inter 2245 fall 2 rise 1
-	server 127.0.17.039 127.0.17.39:80 weight 10 check inter 198 fall 2 rise 1
-	server 127.0.17.040 127.0.17.40:80 weight 10 check inter 268 fall 2 rise 1
-	server 127.0.17.041 127.0.17.41:80 weight 10 check inter 4099 fall 2 rise 1
-	server 127.0.17.042 127.0.17.42:80 weight 10 check inter 9883 fall 2 rise 1
-	server 127.0.17.043 127.0.17.43:80 weight 10 check inter 1750 fall 2 rise 1
-	server 127.0.17.044 127.0.17.44:80 weight 10 check inter 9036 fall 2 rise 1
-	server 127.0.17.045 127.0.17.45:80 weight 10 check inter 2059 fall 2 rise 1
-	server 127.0.17.046 127.0.17.46:80 weight 10 check inter 3364 fall 2 rise 1
-	server 127.0.17.047 127.0.17.47:80 weight 10 check inter 1821 fall 2 rise 1
-	server 127.0.17.048 127.0.17.48:80 weight 10 check inter 8146 fall 2 rise 1
-	server 127.0.17.049 127.0.17.49:80 weight 10 check inter 6695 fall 2 rise 1
-	server 127.0.17.050 127.0.17.50:80 weight 10 check inter 1936 fall 2 rise 1
-	server 127.0.17.051 127.0.17.51:80 weight 10 check inter 3078 fall 2 rise 1
-	server 127.0.17.052 127.0.17.52:80 weight 10 check inter 2201 fall 2 rise 1
-	server 127.0.17.053 127.0.17.53:80 weight 10 check inter 4584 fall 2 rise 1
-	server 127.0.17.054 127.0.17.54:80 weight 10 check inter 5999 fall 2 rise 1
-	server 127.0.17.055 127.0.17.55:80 weight 10 check inter 7504 fall 2 rise 1
-	server 127.0.17.056 127.0.17.56:80 weight 10 check inter 7349 fall 2 rise 1
-	server 127.0.17.057 127.0.17.57:80 weight 10 check inter 240 fall 2 rise 1
-	server 127.0.17.058 127.0.17.58:80 weight 10 check inter 1916 fall 2 rise 1
-	server 127.0.17.059 127.0.17.59:80 weight 10 check inter 3948 fall 2 rise 1
-	server 127.0.17.060 127.0.17.60:80 weight 10 check inter 9431 fall 2 rise 1
-	server 127.0.17.061 127.0.17.61:80 weight 10 check inter 5233 fall 2 rise 1
-	server 127.0.17.062 127.0.17.62:80 weight 10 check inter 505 fall 2 rise 1
-	server 127.0.17.063 127.0.17.63:80 weight 10 check inter 407 fall 2 rise 1
-	server 127.0.17.064 127.0.17.64:80 weight 10 check inter 1714 fall 2 rise 1
-	server 127.0.17.065 127.0.17.65:80 weight 10 check inter 1494 fall 2 rise 1
-	server 127.0.17.066 127.0.17.66:80 weight 10 check inter 111 fall 2 rise 1
-	server 127.0.17.067 127.0.17.67:80 weight 10 check inter 2871 fall 2 rise 1
-	server 127.0.17.068 127.0.17.68:80 weight 10 check inter 5328 fall 2 rise 1
-	server 127.0.17.069 127.0.17.69:80 weight 10 check inter 4324 fall 2 rise 1
-	server 127.0.17.070 127.0.17.70:80 weight 10 check inter 8754 fall 2 rise 1
-	server 127.0.17.071 127.0.17.71:80 weight 10 check inter 1431 fall 2 rise 1
-	server 127.0.17.072 127.0.17.72:80 weight 10 check inter 6611 fall 2 rise 1
-	server 127.0.17.073 127.0.17.73:80 weight 10 check inter 7870 fall 2 rise 1
-	server 127.0.17.074 127.0.17.74:80 weight 10 check inter 5206 fall 2 rise 1
-	server 127.0.17.075 127.0.17.75:80 weight 10 check inter 6547 fall 2 rise 1
-	server 127.0.17.076 127.0.17.76:80 weight 10 check inter 4670 fall 2 rise 1
-	server 127.0.17.077 127.0.17.77:80 weight 10 check inter 1547 fall 2 rise 1
-	server 127.0.17.078 127.0.17.78:80 weight 10 check inter 708 fall 2 rise 1
-	server 127.0.17.079 127.0.17.79:80 weight 10 check inter 5107 fall 2 rise 1
-	server 127.0.17.080 127.0.17.80:80 weight 10 check inter 4239 fall 2 rise 1
-	server 127.0.17.081 127.0.17.81:80 weight 10 check inter 1673 fall 2 rise 1
-	server 127.0.17.082 127.0.17.82:80 weight 10 check inter 106 fall 2 rise 1
-	server 127.0.17.083 127.0.17.83:80 weight 10 check inter 8727 fall 2 rise 1
-	server 127.0.17.084 127.0.17.84:80 weight 10 check inter 5650 fall 2 rise 1
-	server 127.0.17.085 127.0.17.85:80 weight 10 check inter 1885 fall 2 rise 1
-	server 127.0.17.086 127.0.17.86:80 weight 10 check inter 1814 fall 2 rise 1
-	server 127.0.17.087 127.0.17.87:80 weight 10 check inter 9286 fall 2 rise 1
-	server 127.0.17.088 127.0.17.88:80 weight 10 check inter 1431 fall 2 rise 1
-	server 127.0.17.089 127.0.17.89:80 weight 10 check inter 6626 fall 2 rise 1
-	server 127.0.17.090 127.0.17.90:80 weight 10 check inter 4289 fall 2 rise 1
-	server 127.0.17.091 127.0.17.91:80 weight 10 check inter 6455 fall 2 rise 1
-	server 127.0.17.092 127.0.17.92:80 weight 10 check inter 111 fall 2 rise 1
-	server 127.0.17.093 127.0.17.93:80 weight 10 check inter 7213 fall 2 rise 1
-	server 127.0.17.094 127.0.17.94:80 weight 10 check inter 3531 fall 2 rise 1
-	server 127.0.17.095 127.0.17.95:80 weight 10 check inter 5612 fall 2 rise 1
-	server 127.0.17.096 127.0.17.96:80 weight 10 check inter 7385 fall 2 rise 1
-	server 127.0.17.097 127.0.17.97:80 weight 10 check inter 1154 fall 2 rise 1
-	server 127.0.17.098 127.0.17.98:80 weight 10 check inter 6970 fall 2 rise 1
-	server 127.0.17.099 127.0.17.99:80 weight 10 check inter 9666 fall 2 rise 1
-	server 127.0.17.100 127.0.17.100:80 weight 10 check inter 3055 fall 2 rise 1
-	server 127.0.17.101 127.0.17.101:80 weight 10 check inter 2328 fall 2 rise 1
-	server 127.0.17.102 127.0.17.102:80 weight 10 check inter 7618 fall 2 rise 1
-	server 127.0.17.103 127.0.17.103:80 weight 10 check inter 7177 fall 2 rise 1
-	server 127.0.17.104 127.0.17.104:80 weight 10 check inter 8815 fall 2 rise 1
-	server 127.0.17.105 127.0.17.105:80 weight 10 check inter 9485 fall 2 rise 1
-	server 127.0.17.106 127.0.17.106:80 weight 10 check inter 2963 fall 2 rise 1
-	server 127.0.17.107 127.0.17.107:80 weight 10 check inter 1379 fall 2 rise 1
-	server 127.0.17.108 127.0.17.108:80 weight 10 check inter 9146 fall 2 rise 1
-	server 127.0.17.109 127.0.17.109:80 weight 10 check inter 2826 fall 2 rise 1
-	server 127.0.17.110 127.0.17.110:80 weight 10 check inter 9542 fall 2 rise 1
-	server 127.0.17.111 127.0.17.111:80 weight 10 check inter 4638 fall 2 rise 1
-	server 127.0.17.112 127.0.17.112:80 weight 10 check inter 559 fall 2 rise 1
-	server 127.0.17.113 127.0.17.113:80 weight 10 check inter 6740 fall 2 rise 1
-	server 127.0.17.114 127.0.17.114:80 weight 10 check inter 2117 fall 2 rise 1
-	server 127.0.17.115 127.0.17.115:80 weight 10 check inter 5265 fall 2 rise 1
-	server 127.0.17.116 127.0.17.116:80 weight 10 check inter 5109 fall 2 rise 1
-	server 127.0.17.117 127.0.17.117:80 weight 10 check inter 8471 fall 2 rise 1
-	server 127.0.17.118 127.0.17.118:80 weight 10 check inter 7341 fall 2 rise 1
-	server 127.0.17.119 127.0.17.119:80 weight 10 check inter 5689 fall 2 rise 1
-	server 127.0.17.120 127.0.17.120:80 weight 10 check inter 4234 fall 2 rise 1
-	server 127.0.17.121 127.0.17.121:80 weight 10 check inter 147 fall 2 rise 1
-	server 127.0.17.122 127.0.17.122:80 weight 10 check inter 6356 fall 2 rise 1
-	server 127.0.17.123 127.0.17.123:80 weight 10 check inter 417 fall 2 rise 1
-	server 127.0.17.124 127.0.17.124:80 weight 10 check inter 5263 fall 2 rise 1
-	server 127.0.17.125 127.0.17.125:80 weight 10 check inter 8420 fall 2 rise 1
-	server 127.0.17.126 127.0.17.126:80 weight 10 check inter 9610 fall 2 rise 1
-	server 127.0.17.127 127.0.17.127:80 weight 10 check inter 2979 fall 2 rise 1
-	server 127.0.17.128 127.0.17.128:80 weight 10 check inter 3423 fall 2 rise 1
-	server 127.0.17.129 127.0.17.129:80 weight 10 check inter 5939 fall 2 rise 1
-	server 127.0.17.130 127.0.17.130:80 weight 10 check inter 9858 fall 2 rise 1
-	server 127.0.17.131 127.0.17.131:80 weight 10 check inter 3489 fall 2 rise 1
-	server 127.0.17.132 127.0.17.132:80 weight 10 check inter 8499 fall 2 rise 1
-	server 127.0.17.133 127.0.17.133:80 weight 10 check inter 7022 fall 2 rise 1
-	server 127.0.17.134 127.0.17.134:80 weight 10 check inter 7869 fall 2 rise 1
-	server 127.0.17.135 127.0.17.135:80 weight 10 check inter 1554 fall 2 rise 1
-	server 127.0.17.136 127.0.17.136:80 weight 10 check inter 5832 fall 2 rise 1
-	server 127.0.17.137 127.0.17.137:80 weight 10 check inter 5767 fall 2 rise 1
-	server 127.0.17.138 127.0.17.138:80 weight 10 check inter 5131 fall 2 rise 1
-	server 127.0.17.139 127.0.17.139:80 weight 10 check inter 814 fall 2 rise 1
-	server 127.0.17.140 127.0.17.140:80 weight 10 check inter 91 fall 2 rise 1
-	server 127.0.17.141 127.0.17.141:80 weight 10 check inter 5759 fall 2 rise 1
-	server 127.0.17.142 127.0.17.142:80 weight 10 check inter 9120 fall 2 rise 1
-	server 127.0.17.143 127.0.17.143:80 weight 10 check inter 3495 fall 2 rise 1
-	server 127.0.17.144 127.0.17.144:80 weight 10 check inter 9657 fall 2 rise 1
-	server 127.0.17.145 127.0.17.145:80 weight 10 check inter 9249 fall 2 rise 1
-	server 127.0.17.146 127.0.17.146:80 weight 10 check inter 8839 fall 2 rise 1
-	server 127.0.17.147 127.0.17.147:80 weight 10 check inter 8509 fall 2 rise 1
-	server 127.0.17.148 127.0.17.148:80 weight 10 check inter 7705 fall 2 rise 1
-	server 127.0.17.149 127.0.17.149:80 weight 10 check inter 9790 fall 2 rise 1
-	server 127.0.17.150 127.0.17.150:80 weight 10 check inter 1098 fall 2 rise 1
-	server 127.0.17.151 127.0.17.151:80 weight 10 check inter 3328 fall 2 rise 1
-	server 127.0.17.152 127.0.17.152:80 weight 10 check inter 9254 fall 2 rise 1
-	server 127.0.17.153 127.0.17.153:80 weight 10 check inter 3260 fall 2 rise 1
-	server 127.0.17.154 127.0.17.154:80 weight 10 check inter 1389 fall 2 rise 1
-	server 127.0.17.155 127.0.17.155:80 weight 10 check inter 7475 fall 2 rise 1
-	server 127.0.17.156 127.0.17.156:80 weight 10 check inter 1630 fall 2 rise 1
-	server 127.0.17.157 127.0.17.157:80 weight 10 check inter 6158 fall 2 rise 1
-	server 127.0.17.158 127.0.17.158:80 weight 10 check inter 1102 fall 2 rise 1
-	server 127.0.17.159 127.0.17.159:80 weight 10 check inter 1701 fall 2 rise 1
-	server 127.0.17.160 127.0.17.160:80 weight 10 check inter 7772 fall 2 rise 1
-	server 127.0.17.161 127.0.17.161:80 weight 10 check inter 2449 fall 2 rise 1
-	server 127.0.17.162 127.0.17.162:80 weight 10 check inter 6253 fall 2 rise 1
-	server 127.0.17.163 127.0.17.163:80 weight 10 check inter 3614 fall 2 rise 1
-	server 127.0.17.164 127.0.17.164:80 weight 10 check inter 7061 fall 2 rise 1
-	server 127.0.17.165 127.0.17.165:80 weight 10 check inter 5980 fall 2 rise 1
-	server 127.0.17.166 127.0.17.166:80 weight 10 check inter 4747 fall 2 rise 1
-	server 127.0.17.167 127.0.17.167:80 weight 10 check inter 6444 fall 2 rise 1
-	server 127.0.17.168 127.0.17.168:80 weight 10 check inter 7396 fall 2 rise 1
-	server 127.0.17.169 127.0.17.169:80 weight 10 check inter 4805 fall 2 rise 1
-	server 127.0.17.170 127.0.17.170:80 weight 10 check inter 6276 fall 2 rise 1
-	server 127.0.17.171 127.0.17.171:80 weight 10 check inter 796 fall 2 rise 1
-	server 127.0.17.172 127.0.17.172:80 weight 10 check inter 5063 fall 2 rise 1
-	server 127.0.17.173 127.0.17.173:80 weight 10 check inter 6163 fall 2 rise 1
-	server 127.0.17.174 127.0.17.174:80 weight 10 check inter 4907 fall 2 rise 1
-	server 127.0.17.175 127.0.17.175:80 weight 10 check inter 6983 fall 2 rise 1
-	server 127.0.17.176 127.0.17.176:80 weight 10 check inter 4870 fall 2 rise 1
-	server 127.0.17.177 127.0.17.177:80 weight 10 check inter 583 fall 2 rise 1
-	server 127.0.17.178 127.0.17.178:80 weight 10 check inter 8202 fall 2 rise 1
-	server 127.0.17.179 127.0.17.179:80 weight 10 check inter 2881 fall 2 rise 1
-	server 127.0.17.180 127.0.17.180:80 weight 10 check inter 502 fall 2 rise 1
-	server 127.0.17.181 127.0.17.181:80 weight 10 check inter 1706 fall 2 rise 1
-	server 127.0.17.182 127.0.17.182:80 weight 10 check inter 3351 fall 2 rise 1
-	server 127.0.17.183 127.0.17.183:80 weight 10 check inter 5507 fall 2 rise 1
-	server 127.0.17.184 127.0.17.184:80 weight 10 check inter 5234 fall 2 rise 1
-	server 127.0.17.185 127.0.17.185:80 weight 10 check inter 9685 fall 2 rise 1
-	server 127.0.17.186 127.0.17.186:80 weight 10 check inter 5253 fall 2 rise 1
-	server 127.0.17.187 127.0.17.187:80 weight 10 check inter 5107 fall 2 rise 1
-	server 127.0.17.188 127.0.17.188:80 weight 10 check inter 7588 fall 2 rise 1
-	server 127.0.17.189 127.0.17.189:80 weight 10 check inter 914 fall 2 rise 1
-	server 127.0.17.190 127.0.17.190:80 weight 10 check inter 2111 fall 2 rise 1
-	server 127.0.17.191 127.0.17.191:80 weight 10 check inter 425 fall 2 rise 1
-	server 127.0.17.192 127.0.17.192:80 weight 10 check inter 9159 fall 2 rise 1
-	server 127.0.17.193 127.0.17.193:80 weight 10 check inter 8550 fall 2 rise 1
-	server 127.0.17.194 127.0.17.194:80 weight 10 check inter 69 fall 2 rise 1
-	server 127.0.17.195 127.0.17.195:80 weight 10 check inter 9617 fall 2 rise 1
-	server 127.0.17.196 127.0.17.196:80 weight 10 check inter 236 fall 2 rise 1
-	server 127.0.17.197 127.0.17.197:80 weight 10 check inter 7819 fall 2 rise 1
-	server 127.0.17.198 127.0.17.198:80 weight 10 check inter 8004 fall 2 rise 1
-	server 127.0.17.199 127.0.17.199:80 weight 10 check inter 6574 fall 2 rise 1
-	server 127.0.17.200 127.0.17.200:80 weight 10 check inter 4030 fall 2 rise 1
-	server 127.0.17.201 127.0.17.201:80 weight 10 check inter 3183 fall 2 rise 1
-	server 127.0.17.202 127.0.17.202:80 weight 10 check inter 9095 fall 2 rise 1
-	server 127.0.17.203 127.0.17.203:80 weight 10 check inter 7573 fall 2 rise 1
-	server 127.0.17.204 127.0.17.204:80 weight 10 check inter 1558 fall 2 rise 1
-	server 127.0.17.205 127.0.17.205:80 weight 10 check inter 6430 fall 2 rise 1
-	server 127.0.17.206 127.0.17.206:80 weight 10 check inter 4112 fall 2 rise 1
-	server 127.0.17.207 127.0.17.207:80 weight 10 check inter 1557 fall 2 rise 1
-	server 127.0.17.208 127.0.17.208:80 weight 10 check inter 317 fall 2 rise 1
-	server 127.0.17.209 127.0.17.209:80 weight 10 check inter 7856 fall 2 rise 1
-	server 127.0.17.210 127.0.17.210:80 weight 10 check inter 6260 fall 2 rise 1
-	server 127.0.17.211 127.0.17.211:80 weight 10 check inter 8647 fall 2 rise 1
-	server 127.0.17.212 127.0.17.212:80 weight 10 check inter 3269 fall 2 rise 1
-	server 127.0.17.213 127.0.17.213:80 weight 10 check inter 9426 fall 2 rise 1
-	server 127.0.17.214 127.0.17.214:80 weight 10 check inter 5034 fall 2 rise 1
-	server 127.0.17.215 127.0.17.215:80 weight 10 check inter 2218 fall 2 rise 1
-	server 127.0.17.216 127.0.17.216:80 weight 10 check inter 4470 fall 2 rise 1
-	server 127.0.17.217 127.0.17.217:80 weight 10 check inter 6101 fall 2 rise 1
-	server 127.0.17.218 127.0.17.218:80 weight 10 check inter 1938 fall 2 rise 1
-	server 127.0.17.219 127.0.17.219:80 weight 10 check inter 1099 fall 2 rise 1
-	server 127.0.17.220 127.0.17.220:80 weight 10 check inter 1450 fall 2 rise 1
-	server 127.0.17.221 127.0.17.221:80 weight 10 check inter 8057 fall 2 rise 1
-	server 127.0.17.222 127.0.17.222:80 weight 10 check inter 181 fall 2 rise 1
-	server 127.0.17.223 127.0.17.223:80 weight 10 check inter 1719 fall 2 rise 1
-	server 127.0.17.224 127.0.17.224:80 weight 10 check inter 9864 fall 2 rise 1
-	server 127.0.17.225 127.0.17.225:80 weight 10 check inter 3368 fall 2 rise 1
-	server 127.0.17.226 127.0.17.226:80 weight 10 check inter 2272 fall 2 rise 1
-	server 127.0.17.227 127.0.17.227:80 weight 10 check inter 1376 fall 2 rise 1
-	server 127.0.17.228 127.0.17.228:80 weight 10 check inter 2225 fall 2 rise 1
-	server 127.0.17.229 127.0.17.229:80 weight 10 check inter 9874 fall 2 rise 1
-	server 127.0.17.230 127.0.17.230:80 weight 10 check inter 3600 fall 2 rise 1
-	server 127.0.17.231 127.0.17.231:80 weight 10 check inter 9968 fall 2 rise 1
-	server 127.0.17.232 127.0.17.232:80 weight 10 check inter 9803 fall 2 rise 1
-	server 127.0.17.233 127.0.17.233:80 weight 10 check inter 1516 fall 2 rise 1
-	server 127.0.17.234 127.0.17.234:80 weight 10 check inter 3340 fall 2 rise 1
-	server 127.0.17.235 127.0.17.235:80 weight 10 check inter 465 fall 2 rise 1
-	server 127.0.17.236 127.0.17.236:80 weight 10 check inter 8705 fall 2 rise 1
-	server 127.0.17.237 127.0.17.237:80 weight 10 check inter 9367 fall 2 rise 1
-	server 127.0.17.238 127.0.17.238:80 weight 10 check inter 2917 fall 2 rise 1
-	server 127.0.17.239 127.0.17.239:80 weight 10 check inter 1433 fall 2 rise 1
-	server 127.0.17.240 127.0.17.240:80 weight 10 check inter 903 fall 2 rise 1
-	server 127.0.17.241 127.0.17.241:80 weight 10 check inter 9442 fall 2 rise 1
-	server 127.0.17.242 127.0.17.242:80 weight 10 check inter 8895 fall 2 rise 1
-	server 127.0.17.243 127.0.17.243:80 weight 10 check inter 8070 fall 2 rise 1
-	server 127.0.17.244 127.0.17.244:80 weight 10 check inter 4638 fall 2 rise 1
-	server 127.0.17.245 127.0.17.245:80 weight 10 check inter 8575 fall 2 rise 1
-	server 127.0.17.246 127.0.17.246:80 weight 10 check inter 7132 fall 2 rise 1
-	server 127.0.17.247 127.0.17.247:80 weight 10 check inter 2909 fall 2 rise 1
-	server 127.0.17.248 127.0.17.248:80 weight 10 check inter 43 fall 2 rise 1
-	server 127.0.17.249 127.0.17.249:80 weight 10 check inter 1525 fall 2 rise 1
-	server 127.0.17.250 127.0.17.250:80 weight 10 check inter 8029 fall 2 rise 1
-	server 127.0.18.001 127.0.18.1:80 weight 10 check inter 3538 fall 2 rise 1
-	server 127.0.18.002 127.0.18.2:80 weight 10 check inter 5928 fall 2 rise 1
-	server 127.0.18.003 127.0.18.3:80 weight 10 check inter 5067 fall 2 rise 1
-	server 127.0.18.004 127.0.18.4:80 weight 10 check inter 4599 fall 2 rise 1
-	server 127.0.18.005 127.0.18.5:80 weight 10 check inter 375 fall 2 rise 1
-	server 127.0.18.006 127.0.18.6:80 weight 10 check inter 2952 fall 2 rise 1
-	server 127.0.18.007 127.0.18.7:80 weight 10 check inter 64 fall 2 rise 1
-	server 127.0.18.008 127.0.18.8:80 weight 10 check inter 3655 fall 2 rise 1
-	server 127.0.18.009 127.0.18.9:80 weight 10 check inter 4613 fall 2 rise 1
-	server 127.0.18.010 127.0.18.10:80 weight 10 check inter 7163 fall 2 rise 1
-	server 127.0.18.011 127.0.18.11:80 weight 10 check inter 522 fall 2 rise 1
-	server 127.0.18.012 127.0.18.12:80 weight 10 check inter 9238 fall 2 rise 1
-	server 127.0.18.013 127.0.18.13:80 weight 10 check inter 7499 fall 2 rise 1
-	server 127.0.18.014 127.0.18.14:80 weight 10 check inter 6805 fall 2 rise 1
-	server 127.0.18.015 127.0.18.15:80 weight 10 check inter 6149 fall 2 rise 1
-	server 127.0.18.016 127.0.18.16:80 weight 10 check inter 2427 fall 2 rise 1
-	server 127.0.18.017 127.0.18.17:80 weight 10 check inter 1865 fall 2 rise 1
-	server 127.0.18.018 127.0.18.18:80 weight 10 check inter 2799 fall 2 rise 1
-	server 127.0.18.019 127.0.18.19:80 weight 10 check inter 7127 fall 2 rise 1
-	server 127.0.18.020 127.0.18.20:80 weight 10 check inter 3715 fall 2 rise 1
-	server 127.0.18.021 127.0.18.21:80 weight 10 check inter 1979 fall 2 rise 1
-	server 127.0.18.022 127.0.18.22:80 weight 10 check inter 619 fall 2 rise 1
-	server 127.0.18.023 127.0.18.23:80 weight 10 check inter 7749 fall 2 rise 1
-	server 127.0.18.024 127.0.18.24:80 weight 10 check inter 2881 fall 2 rise 1
-	server 127.0.18.025 127.0.18.25:80 weight 10 check inter 7558 fall 2 rise 1
-	server 127.0.18.026 127.0.18.26:80 weight 10 check inter 3175 fall 2 rise 1
-	server 127.0.18.027 127.0.18.27:80 weight 10 check inter 4120 fall 2 rise 1
-	server 127.0.18.028 127.0.18.28:80 weight 10 check inter 4069 fall 2 rise 1
-	server 127.0.18.029 127.0.18.29:80 weight 10 check inter 9253 fall 2 rise 1
-	server 127.0.18.030 127.0.18.30:80 weight 10 check inter 5817 fall 2 rise 1
-	server 127.0.18.031 127.0.18.31:80 weight 10 check inter 701 fall 2 rise 1
-	server 127.0.18.032 127.0.18.32:80 weight 10 check inter 2702 fall 2 rise 1
-	server 127.0.18.033 127.0.18.33:80 weight 10 check inter 1888 fall 2 rise 1
-	server 127.0.18.034 127.0.18.34:80 weight 10 check inter 3668 fall 2 rise 1
-	server 127.0.18.035 127.0.18.35:80 weight 10 check inter 1535 fall 2 rise 1
-	server 127.0.18.036 127.0.18.36:80 weight 10 check inter 6399 fall 2 rise 1
-	server 127.0.18.037 127.0.18.37:80 weight 10 check inter 5105 fall 2 rise 1
-	server 127.0.18.038 127.0.18.38:80 weight 10 check inter 5038 fall 2 rise 1
-	server 127.0.18.039 127.0.18.39:80 weight 10 check inter 4757 fall 2 rise 1
-	server 127.0.18.040 127.0.18.40:80 weight 10 check inter 8674 fall 2 rise 1
-	server 127.0.18.041 127.0.18.41:80 weight 10 check inter 8118 fall 2 rise 1
-	server 127.0.18.042 127.0.18.42:80 weight 10 check inter 5282 fall 2 rise 1
-	server 127.0.18.043 127.0.18.43:80 weight 10 check inter 9627 fall 2 rise 1
-	server 127.0.18.044 127.0.18.44:80 weight 10 check inter 3296 fall 2 rise 1
-	server 127.0.18.045 127.0.18.45:80 weight 10 check inter 565 fall 2 rise 1
-	server 127.0.18.046 127.0.18.46:80 weight 10 check inter 3444 fall 2 rise 1
-	server 127.0.18.047 127.0.18.47:80 weight 10 check inter 4690 fall 2 rise 1
-	server 127.0.18.048 127.0.18.48:80 weight 10 check inter 4060 fall 2 rise 1
-	server 127.0.18.049 127.0.18.49:80 weight 10 check inter 7236 fall 2 rise 1
-	server 127.0.18.050 127.0.18.50:80 weight 10 check inter 72 fall 2 rise 1
-	server 127.0.18.051 127.0.18.51:80 weight 10 check inter 7814 fall 2 rise 1
-	server 127.0.18.052 127.0.18.52:80 weight 10 check inter 7874 fall 2 rise 1
-	server 127.0.18.053 127.0.18.53:80 weight 10 check inter 5251 fall 2 rise 1
-	server 127.0.18.054 127.0.18.54:80 weight 10 check inter 8705 fall 2 rise 1
-	server 127.0.18.055 127.0.18.55:80 weight 10 check inter 915 fall 2 rise 1
-	server 127.0.18.056 127.0.18.56:80 weight 10 check inter 2051 fall 2 rise 1
-	server 127.0.18.057 127.0.18.57:80 weight 10 check inter 8288 fall 2 rise 1
-	server 127.0.18.058 127.0.18.58:80 weight 10 check inter 1850 fall 2 rise 1
-	server 127.0.18.059 127.0.18.59:80 weight 10 check inter 6983 fall 2 rise 1
-	server 127.0.18.060 127.0.18.60:80 weight 10 check inter 6477 fall 2 rise 1
-	server 127.0.18.061 127.0.18.61:80 weight 10 check inter 1304 fall 2 rise 1
-	server 127.0.18.062 127.0.18.62:80 weight 10 check inter 1974 fall 2 rise 1
-	server 127.0.18.063 127.0.18.63:80 weight 10 check inter 1333 fall 2 rise 1
-	server 127.0.18.064 127.0.18.64:80 weight 10 check inter 7725 fall 2 rise 1
-	server 127.0.18.065 127.0.18.65:80 weight 10 check inter 4846 fall 2 rise 1
-	server 127.0.18.066 127.0.18.66:80 weight 10 check inter 4489 fall 2 rise 1
-	server 127.0.18.067 127.0.18.67:80 weight 10 check inter 3007 fall 2 rise 1
-	server 127.0.18.068 127.0.18.68:80 weight 10 check inter 52 fall 2 rise 1
-	server 127.0.18.069 127.0.18.69:80 weight 10 check inter 6845 fall 2 rise 1
-	server 127.0.18.070 127.0.18.70:80 weight 10 check inter 7987 fall 2 rise 1
-	server 127.0.18.071 127.0.18.71:80 weight 10 check inter 7600 fall 2 rise 1
-	server 127.0.18.072 127.0.18.72:80 weight 10 check inter 1610 fall 2 rise 1
-	server 127.0.18.073 127.0.18.73:80 weight 10 check inter 3757 fall 2 rise 1
-	server 127.0.18.074 127.0.18.74:80 weight 10 check inter 2287 fall 2 rise 1
-	server 127.0.18.075 127.0.18.75:80 weight 10 check inter 8093 fall 2 rise 1
-	server 127.0.18.076 127.0.18.76:80 weight 10 check inter 4196 fall 2 rise 1
-	server 127.0.18.077 127.0.18.77:80 weight 10 check inter 4488 fall 2 rise 1
-	server 127.0.18.078 127.0.18.78:80 weight 10 check inter 8911 fall 2 rise 1
-	server 127.0.18.079 127.0.18.79:80 weight 10 check inter 8778 fall 2 rise 1
-	server 127.0.18.080 127.0.18.80:80 weight 10 check inter 4071 fall 2 rise 1
-	server 127.0.18.081 127.0.18.81:80 weight 10 check inter 5114 fall 2 rise 1
-	server 127.0.18.082 127.0.18.82:80 weight 10 check inter 8389 fall 2 rise 1
-	server 127.0.18.083 127.0.18.83:80 weight 10 check inter 572 fall 2 rise 1
-	server 127.0.18.084 127.0.18.84:80 weight 10 check inter 8506 fall 2 rise 1
-	server 127.0.18.085 127.0.18.85:80 weight 10 check inter 5530 fall 2 rise 1
-	server 127.0.18.086 127.0.18.86:80 weight 10 check inter 2418 fall 2 rise 1
-	server 127.0.18.087 127.0.18.87:80 weight 10 check inter 8338 fall 2 rise 1
-	server 127.0.18.088 127.0.18.88:80 weight 10 check inter 1133 fall 2 rise 1
-	server 127.0.18.089 127.0.18.89:80 weight 10 check inter 42 fall 2 rise 1
-	server 127.0.18.090 127.0.18.90:80 weight 10 check inter 3567 fall 2 rise 1
-	server 127.0.18.091 127.0.18.91:80 weight 10 check inter 9121 fall 2 rise 1
-	server 127.0.18.092 127.0.18.92:80 weight 10 check inter 9500 fall 2 rise 1
-	server 127.0.18.093 127.0.18.93:80 weight 10 check inter 4112 fall 2 rise 1
-	server 127.0.18.094 127.0.18.94:80 weight 10 check inter 3949 fall 2 rise 1
-	server 127.0.18.095 127.0.18.95:80 weight 10 check inter 692 fall 2 rise 1
-	server 127.0.18.096 127.0.18.96:80 weight 10 check inter 5761 fall 2 rise 1
-	server 127.0.18.097 127.0.18.97:80 weight 10 check inter 8018 fall 2 rise 1
-	server 127.0.18.098 127.0.18.98:80 weight 10 check inter 7068 fall 2 rise 1
-	server 127.0.18.099 127.0.18.99:80 weight 10 check inter 1600 fall 2 rise 1
-	server 127.0.18.100 127.0.18.100:80 weight 10 check inter 7309 fall 2 rise 1
-	server 127.0.18.101 127.0.18.101:80 weight 10 check inter 452 fall 2 rise 1
-	server 127.0.18.102 127.0.18.102:80 weight 10 check inter 9982 fall 2 rise 1
-	server 127.0.18.103 127.0.18.103:80 weight 10 check inter 9 fall 2 rise 1
-	server 127.0.18.104 127.0.18.104:80 weight 10 check inter 6565 fall 2 rise 1
-	server 127.0.18.105 127.0.18.105:80 weight 10 check inter 3697 fall 2 rise 1
-	server 127.0.18.106 127.0.18.106:80 weight 10 check inter 5513 fall 2 rise 1
-	server 127.0.18.107 127.0.18.107:80 weight 10 check inter 7 fall 2 rise 1
-	server 127.0.18.108 127.0.18.108:80 weight 10 check inter 3804 fall 2 rise 1
-	server 127.0.18.109 127.0.18.109:80 weight 10 check inter 5739 fall 2 rise 1
-	server 127.0.18.110 127.0.18.110:80 weight 10 check inter 7646 fall 2 rise 1
-	server 127.0.18.111 127.0.18.111:80 weight 10 check inter 5782 fall 2 rise 1
-	server 127.0.18.112 127.0.18.112:80 weight 10 check inter 6420 fall 2 rise 1
-	server 127.0.18.113 127.0.18.113:80 weight 10 check inter 4339 fall 2 rise 1
-	server 127.0.18.114 127.0.18.114:80 weight 10 check inter 8318 fall 2 rise 1
-	server 127.0.18.115 127.0.18.115:80 weight 10 check inter 6032 fall 2 rise 1
-	server 127.0.18.116 127.0.18.116:80 weight 10 check inter 7699 fall 2 rise 1
-	server 127.0.18.117 127.0.18.117:80 weight 10 check inter 3783 fall 2 rise 1
-	server 127.0.18.118 127.0.18.118:80 weight 10 check inter 869 fall 2 rise 1
-	server 127.0.18.119 127.0.18.119:80 weight 10 check inter 3450 fall 2 rise 1
-	server 127.0.18.120 127.0.18.120:80 weight 10 check inter 1911 fall 2 rise 1
-	server 127.0.18.121 127.0.18.121:80 weight 10 check inter 142 fall 2 rise 1
-	server 127.0.18.122 127.0.18.122:80 weight 10 check inter 2861 fall 2 rise 1
-	server 127.0.18.123 127.0.18.123:80 weight 10 check inter 1217 fall 2 rise 1
-	server 127.0.18.124 127.0.18.124:80 weight 10 check inter 7258 fall 2 rise 1
-	server 127.0.18.125 127.0.18.125:80 weight 10 check inter 9412 fall 2 rise 1
-	server 127.0.18.126 127.0.18.126:80 weight 10 check inter 3491 fall 2 rise 1
-	server 127.0.18.127 127.0.18.127:80 weight 10 check inter 4547 fall 2 rise 1
-	server 127.0.18.128 127.0.18.128:80 weight 10 check inter 9300 fall 2 rise 1
-	server 127.0.18.129 127.0.18.129:80 weight 10 check inter 9014 fall 2 rise 1
-	server 127.0.18.130 127.0.18.130:80 weight 10 check inter 5560 fall 2 rise 1
-	server 127.0.18.131 127.0.18.131:80 weight 10 check inter 4317 fall 2 rise 1
-	server 127.0.18.132 127.0.18.132:80 weight 10 check inter 7828 fall 2 rise 1
-	server 127.0.18.133 127.0.18.133:80 weight 10 check inter 237 fall 2 rise 1
-	server 127.0.18.134 127.0.18.134:80 weight 10 check inter 2759 fall 2 rise 1
-	server 127.0.18.135 127.0.18.135:80 weight 10 check inter 4664 fall 2 rise 1
-	server 127.0.18.136 127.0.18.136:80 weight 10 check inter 1308 fall 2 rise 1
-	server 127.0.18.137 127.0.18.137:80 weight 10 check inter 5947 fall 2 rise 1
-	server 127.0.18.138 127.0.18.138:80 weight 10 check inter 2233 fall 2 rise 1
-	server 127.0.18.139 127.0.18.139:80 weight 10 check inter 1570 fall 2 rise 1
-	server 127.0.18.140 127.0.18.140:80 weight 10 check inter 190 fall 2 rise 1
-	server 127.0.18.141 127.0.18.141:80 weight 10 check inter 8550 fall 2 rise 1
-	server 127.0.18.142 127.0.18.142:80 weight 10 check inter 410 fall 2 rise 1
-	server 127.0.18.143 127.0.18.143:80 weight 10 check inter 7102 fall 2 rise 1
-	server 127.0.18.144 127.0.18.144:80 weight 10 check inter 4890 fall 2 rise 1
-	server 127.0.18.145 127.0.18.145:80 weight 10 check inter 9591 fall 2 rise 1
-	server 127.0.18.146 127.0.18.146:80 weight 10 check inter 9289 fall 2 rise 1
-	server 127.0.18.147 127.0.18.147:80 weight 10 check inter 3099 fall 2 rise 1
-	server 127.0.18.148 127.0.18.148:80 weight 10 check inter 6517 fall 2 rise 1
-	server 127.0.18.149 127.0.18.149:80 weight 10 check inter 4898 fall 2 rise 1
-	server 127.0.18.150 127.0.18.150:80 weight 10 check inter 2883 fall 2 rise 1
-	server 127.0.18.151 127.0.18.151:80 weight 10 check inter 5413 fall 2 rise 1
-	server 127.0.18.152 127.0.18.152:80 weight 10 check inter 1529 fall 2 rise 1
-	server 127.0.18.153 127.0.18.153:80 weight 10 check inter 7283 fall 2 rise 1
-	server 127.0.18.154 127.0.18.154:80 weight 10 check inter 6972 fall 2 rise 1
-	server 127.0.18.155 127.0.18.155:80 weight 10 check inter 525 fall 2 rise 1
-	server 127.0.18.156 127.0.18.156:80 weight 10 check inter 7311 fall 2 rise 1
-	server 127.0.18.157 127.0.18.157:80 weight 10 check inter 5628 fall 2 rise 1
-	server 127.0.18.158 127.0.18.158:80 weight 10 check inter 370 fall 2 rise 1
-	server 127.0.18.159 127.0.18.159:80 weight 10 check inter 7161 fall 2 rise 1
-	server 127.0.18.160 127.0.18.160:80 weight 10 check inter 653 fall 2 rise 1
-	server 127.0.18.161 127.0.18.161:80 weight 10 check inter 4049 fall 2 rise 1
-	server 127.0.18.162 127.0.18.162:80 weight 10 check inter 2978 fall 2 rise 1
-	server 127.0.18.163 127.0.18.163:80 weight 10 check inter 8572 fall 2 rise 1
-	server 127.0.18.164 127.0.18.164:80 weight 10 check inter 8543 fall 2 rise 1
-	server 127.0.18.165 127.0.18.165:80 weight 10 check inter 7200 fall 2 rise 1
-	server 127.0.18.166 127.0.18.166:80 weight 10 check inter 3303 fall 2 rise 1
-	server 127.0.18.167 127.0.18.167:80 weight 10 check inter 9972 fall 2 rise 1
-	server 127.0.18.168 127.0.18.168:80 weight 10 check inter 5127 fall 2 rise 1
-	server 127.0.18.169 127.0.18.169:80 weight 10 check inter 6049 fall 2 rise 1
-	server 127.0.18.170 127.0.18.170:80 weight 10 check inter 4118 fall 2 rise 1
-	server 127.0.18.171 127.0.18.171:80 weight 10 check inter 6630 fall 2 rise 1
-	server 127.0.18.172 127.0.18.172:80 weight 10 check inter 1476 fall 2 rise 1
-	server 127.0.18.173 127.0.18.173:80 weight 10 check inter 5538 fall 2 rise 1
-	server 127.0.18.174 127.0.18.174:80 weight 10 check inter 4283 fall 2 rise 1
-	server 127.0.18.175 127.0.18.175:80 weight 10 check inter 9865 fall 2 rise 1
-	server 127.0.18.176 127.0.18.176:80 weight 10 check inter 3091 fall 2 rise 1
-	server 127.0.18.177 127.0.18.177:80 weight 10 check inter 5855 fall 2 rise 1
-	server 127.0.18.178 127.0.18.178:80 weight 10 check inter 6209 fall 2 rise 1
-	server 127.0.18.179 127.0.18.179:80 weight 10 check inter 2164 fall 2 rise 1
-	server 127.0.18.180 127.0.18.180:80 weight 10 check inter 9464 fall 2 rise 1
-	server 127.0.18.181 127.0.18.181:80 weight 10 check inter 5987 fall 2 rise 1
-	server 127.0.18.182 127.0.18.182:80 weight 10 check inter 1907 fall 2 rise 1
-	server 127.0.18.183 127.0.18.183:80 weight 10 check inter 4649 fall 2 rise 1
-	server 127.0.18.184 127.0.18.184:80 weight 10 check inter 8027 fall 2 rise 1
-	server 127.0.18.185 127.0.18.185:80 weight 10 check inter 9393 fall 2 rise 1
-	server 127.0.18.186 127.0.18.186:80 weight 10 check inter 4773 fall 2 rise 1
-	server 127.0.18.187 127.0.18.187:80 weight 10 check inter 1950 fall 2 rise 1
-	server 127.0.18.188 127.0.18.188:80 weight 10 check inter 1731 fall 2 rise 1
-	server 127.0.18.189 127.0.18.189:80 weight 10 check inter 5105 fall 2 rise 1
-	server 127.0.18.190 127.0.18.190:80 weight 10 check inter 674 fall 2 rise 1
-	server 127.0.18.191 127.0.18.191:80 weight 10 check inter 1296 fall 2 rise 1
-	server 127.0.18.192 127.0.18.192:80 weight 10 check inter 260 fall 2 rise 1
-	server 127.0.18.193 127.0.18.193:80 weight 10 check inter 2411 fall 2 rise 1
-	server 127.0.18.194 127.0.18.194:80 weight 10 check inter 7812 fall 2 rise 1
-	server 127.0.18.195 127.0.18.195:80 weight 10 check inter 3894 fall 2 rise 1
-	server 127.0.18.196 127.0.18.196:80 weight 10 check inter 2599 fall 2 rise 1
-	server 127.0.18.197 127.0.18.197:80 weight 10 check inter 9029 fall 2 rise 1
-	server 127.0.18.198 127.0.18.198:80 weight 10 check inter 4917 fall 2 rise 1
-	server 127.0.18.199 127.0.18.199:80 weight 10 check inter 5606 fall 2 rise 1
-	server 127.0.18.200 127.0.18.200:80 weight 10 check inter 3741 fall 2 rise 1
-	server 127.0.18.201 127.0.18.201:80 weight 10 check inter 925 fall 2 rise 1
-	server 127.0.18.202 127.0.18.202:80 weight 10 check inter 9 fall 2 rise 1
-	server 127.0.18.203 127.0.18.203:80 weight 10 check inter 3914 fall 2 rise 1
-	server 127.0.18.204 127.0.18.204:80 weight 10 check inter 8148 fall 2 rise 1
-	server 127.0.18.205 127.0.18.205:80 weight 10 check inter 7077 fall 2 rise 1
-	server 127.0.18.206 127.0.18.206:80 weight 10 check inter 1591 fall 2 rise 1
-	server 127.0.18.207 127.0.18.207:80 weight 10 check inter 5232 fall 2 rise 1
-	server 127.0.18.208 127.0.18.208:80 weight 10 check inter 1062 fall 2 rise 1
-	server 127.0.18.209 127.0.18.209:80 weight 10 check inter 3954 fall 2 rise 1
-	server 127.0.18.210 127.0.18.210:80 weight 10 check inter 2843 fall 2 rise 1
-	server 127.0.18.211 127.0.18.211:80 weight 10 check inter 4661 fall 2 rise 1
-	server 127.0.18.212 127.0.18.212:80 weight 10 check inter 1092 fall 2 rise 1
-	server 127.0.18.213 127.0.18.213:80 weight 10 check inter 850 fall 2 rise 1
-	server 127.0.18.214 127.0.18.214:80 weight 10 check inter 8334 fall 2 rise 1
-	server 127.0.18.215 127.0.18.215:80 weight 10 check inter 5615 fall 2 rise 1
-	server 127.0.18.216 127.0.18.216:80 weight 10 check inter 6501 fall 2 rise 1
-	server 127.0.18.217 127.0.18.217:80 weight 10 check inter 1312 fall 2 rise 1
-	server 127.0.18.218 127.0.18.218:80 weight 10 check inter 5072 fall 2 rise 1
-	server 127.0.18.219 127.0.18.219:80 weight 10 check inter 5276 fall 2 rise 1
-	server 127.0.18.220 127.0.18.220:80 weight 10 check inter 8798 fall 2 rise 1
-	server 127.0.18.221 127.0.18.221:80 weight 10 check inter 7946 fall 2 rise 1
-	server 127.0.18.222 127.0.18.222:80 weight 10 check inter 5738 fall 2 rise 1
-	server 127.0.18.223 127.0.18.223:80 weight 10 check inter 3742 fall 2 rise 1
-	server 127.0.18.224 127.0.18.224:80 weight 10 check inter 6688 fall 2 rise 1
-	server 127.0.18.225 127.0.18.225:80 weight 10 check inter 3693 fall 2 rise 1
-	server 127.0.18.226 127.0.18.226:80 weight 10 check inter 7414 fall 2 rise 1
-	server 127.0.18.227 127.0.18.227:80 weight 10 check inter 227 fall 2 rise 1
-	server 127.0.18.228 127.0.18.228:80 weight 10 check inter 2117 fall 2 rise 1
-	server 127.0.18.229 127.0.18.229:80 weight 10 check inter 8405 fall 2 rise 1
-	server 127.0.18.230 127.0.18.230:80 weight 10 check inter 4458 fall 2 rise 1
-	server 127.0.18.231 127.0.18.231:80 weight 10 check inter 8038 fall 2 rise 1
-	server 127.0.18.232 127.0.18.232:80 weight 10 check inter 7160 fall 2 rise 1
-	server 127.0.18.233 127.0.18.233:80 weight 10 check inter 2262 fall 2 rise 1
-	server 127.0.18.234 127.0.18.234:80 weight 10 check inter 8681 fall 2 rise 1
-	server 127.0.18.235 127.0.18.235:80 weight 10 check inter 4263 fall 2 rise 1
-	server 127.0.18.236 127.0.18.236:80 weight 10 check inter 6279 fall 2 rise 1
-	server 127.0.18.237 127.0.18.237:80 weight 10 check inter 4697 fall 2 rise 1
-	server 127.0.18.238 127.0.18.238:80 weight 10 check inter 5449 fall 2 rise 1
-	server 127.0.18.239 127.0.18.239:80 weight 10 check inter 5627 fall 2 rise 1
-	server 127.0.18.240 127.0.18.240:80 weight 10 check inter 7594 fall 2 rise 1
-	server 127.0.18.241 127.0.18.241:80 weight 10 check inter 2247 fall 2 rise 1
-	server 127.0.18.242 127.0.18.242:80 weight 10 check inter 2898 fall 2 rise 1
-	server 127.0.18.243 127.0.18.243:80 weight 10 check inter 739 fall 2 rise 1
-	server 127.0.18.244 127.0.18.244:80 weight 10 check inter 1089 fall 2 rise 1
-	server 127.0.18.245 127.0.18.245:80 weight 10 check inter 9976 fall 2 rise 1
-	server 127.0.18.246 127.0.18.246:80 weight 10 check inter 7179 fall 2 rise 1
-	server 127.0.18.247 127.0.18.247:80 weight 10 check inter 5726 fall 2 rise 1
-	server 127.0.18.248 127.0.18.248:80 weight 10 check inter 7407 fall 2 rise 1
-	server 127.0.18.249 127.0.18.249:80 weight 10 check inter 9881 fall 2 rise 1
-	server 127.0.18.250 127.0.18.250:80 weight 10 check inter 8308 fall 2 rise 1
-	server 127.0.19.001 127.0.19.1:80 weight 10 check inter 702 fall 2 rise 1
-	server 127.0.19.002 127.0.19.2:80 weight 10 check inter 5768 fall 2 rise 1
-	server 127.0.19.003 127.0.19.3:80 weight 10 check inter 2638 fall 2 rise 1
-	server 127.0.19.004 127.0.19.4:80 weight 10 check inter 3218 fall 2 rise 1
-	server 127.0.19.005 127.0.19.5:80 weight 10 check inter 2555 fall 2 rise 1
-	server 127.0.19.006 127.0.19.6:80 weight 10 check inter 5563 fall 2 rise 1
-	server 127.0.19.007 127.0.19.7:80 weight 10 check inter 557 fall 2 rise 1
-	server 127.0.19.008 127.0.19.8:80 weight 10 check inter 9071 fall 2 rise 1
-	server 127.0.19.009 127.0.19.9:80 weight 10 check inter 1322 fall 2 rise 1
-	server 127.0.19.010 127.0.19.10:80 weight 10 check inter 3727 fall 2 rise 1
-	server 127.0.19.011 127.0.19.11:80 weight 10 check inter 3622 fall 2 rise 1
-	server 127.0.19.012 127.0.19.12:80 weight 10 check inter 4030 fall 2 rise 1
-	server 127.0.19.013 127.0.19.13:80 weight 10 check inter 6699 fall 2 rise 1
-	server 127.0.19.014 127.0.19.14:80 weight 10 check inter 9055 fall 2 rise 1
-	server 127.0.19.015 127.0.19.15:80 weight 10 check inter 356 fall 2 rise 1
-	server 127.0.19.016 127.0.19.16:80 weight 10 check inter 7774 fall 2 rise 1
-	server 127.0.19.017 127.0.19.17:80 weight 10 check inter 8933 fall 2 rise 1
-	server 127.0.19.018 127.0.19.18:80 weight 10 check inter 9846 fall 2 rise 1
-	server 127.0.19.019 127.0.19.19:80 weight 10 check inter 9381 fall 2 rise 1
-	server 127.0.19.020 127.0.19.20:80 weight 10 check inter 2518 fall 2 rise 1
-	server 127.0.19.021 127.0.19.21:80 weight 10 check inter 1969 fall 2 rise 1
-	server 127.0.19.022 127.0.19.22:80 weight 10 check inter 7913 fall 2 rise 1
-	server 127.0.19.023 127.0.19.23:80 weight 10 check inter 473 fall 2 rise 1
-	server 127.0.19.024 127.0.19.24:80 weight 10 check inter 11 fall 2 rise 1
-	server 127.0.19.025 127.0.19.25:80 weight 10 check inter 1593 fall 2 rise 1
-	server 127.0.19.026 127.0.19.26:80 weight 10 check inter 4726 fall 2 rise 1
-	server 127.0.19.027 127.0.19.27:80 weight 10 check inter 539 fall 2 rise 1
-	server 127.0.19.028 127.0.19.28:80 weight 10 check inter 5938 fall 2 rise 1
-	server 127.0.19.029 127.0.19.29:80 weight 10 check inter 1967 fall 2 rise 1
-	server 127.0.19.030 127.0.19.30:80 weight 10 check inter 6560 fall 2 rise 1
-	server 127.0.19.031 127.0.19.31:80 weight 10 check inter 3314 fall 2 rise 1
-	server 127.0.19.032 127.0.19.32:80 weight 10 check inter 393 fall 2 rise 1
-	server 127.0.19.033 127.0.19.33:80 weight 10 check inter 5005 fall 2 rise 1
-	server 127.0.19.034 127.0.19.34:80 weight 10 check inter 4408 fall 2 rise 1
-	server 127.0.19.035 127.0.19.35:80 weight 10 check inter 9895 fall 2 rise 1
-	server 127.0.19.036 127.0.19.36:80 weight 10 check inter 1555 fall 2 rise 1
-	server 127.0.19.037 127.0.19.37:80 weight 10 check inter 8752 fall 2 rise 1
-	server 127.0.19.038 127.0.19.38:80 weight 10 check inter 635 fall 2 rise 1
-	server 127.0.19.039 127.0.19.39:80 weight 10 check inter 1509 fall 2 rise 1
-	server 127.0.19.040 127.0.19.40:80 weight 10 check inter 7239 fall 2 rise 1
-	server 127.0.19.041 127.0.19.41:80 weight 10 check inter 9652 fall 2 rise 1
-	server 127.0.19.042 127.0.19.42:80 weight 10 check inter 1966 fall 2 rise 1
-	server 127.0.19.043 127.0.19.43:80 weight 10 check inter 3506 fall 2 rise 1
-	server 127.0.19.044 127.0.19.44:80 weight 10 check inter 2055 fall 2 rise 1
-	server 127.0.19.045 127.0.19.45:80 weight 10 check inter 5054 fall 2 rise 1
-	server 127.0.19.046 127.0.19.46:80 weight 10 check inter 4618 fall 2 rise 1
-	server 127.0.19.047 127.0.19.47:80 weight 10 check inter 3039 fall 2 rise 1
-	server 127.0.19.048 127.0.19.48:80 weight 10 check inter 7633 fall 2 rise 1
-	server 127.0.19.049 127.0.19.49:80 weight 10 check inter 1291 fall 2 rise 1
-	server 127.0.19.050 127.0.19.50:80 weight 10 check inter 7335 fall 2 rise 1
-	server 127.0.19.051 127.0.19.51:80 weight 10 check inter 6033 fall 2 rise 1
-	server 127.0.19.052 127.0.19.52:80 weight 10 check inter 3016 fall 2 rise 1
-	server 127.0.19.053 127.0.19.53:80 weight 10 check inter 908 fall 2 rise 1
-	server 127.0.19.054 127.0.19.54:80 weight 10 check inter 4297 fall 2 rise 1
-	server 127.0.19.055 127.0.19.55:80 weight 10 check inter 3133 fall 2 rise 1
-	server 127.0.19.056 127.0.19.56:80 weight 10 check inter 3920 fall 2 rise 1
-	server 127.0.19.057 127.0.19.57:80 weight 10 check inter 7133 fall 2 rise 1
-	server 127.0.19.058 127.0.19.58:80 weight 10 check inter 9645 fall 2 rise 1
-	server 127.0.19.059 127.0.19.59:80 weight 10 check inter 4709 fall 2 rise 1
-	server 127.0.19.060 127.0.19.60:80 weight 10 check inter 1196 fall 2 rise 1
-	server 127.0.19.061 127.0.19.61:80 weight 10 check inter 4282 fall 2 rise 1
-	server 127.0.19.062 127.0.19.62:80 weight 10 check inter 2370 fall 2 rise 1
-	server 127.0.19.063 127.0.19.63:80 weight 10 check inter 4597 fall 2 rise 1
-	server 127.0.19.064 127.0.19.64:80 weight 10 check inter 567 fall 2 rise 1
-	server 127.0.19.065 127.0.19.65:80 weight 10 check inter 5377 fall 2 rise 1
-	server 127.0.19.066 127.0.19.66:80 weight 10 check inter 7160 fall 2 rise 1
-	server 127.0.19.067 127.0.19.67:80 weight 10 check inter 4349 fall 2 rise 1
-	server 127.0.19.068 127.0.19.68:80 weight 10 check inter 9972 fall 2 rise 1
-	server 127.0.19.069 127.0.19.69:80 weight 10 check inter 2917 fall 2 rise 1
-	server 127.0.19.070 127.0.19.70:80 weight 10 check inter 8250 fall 2 rise 1
-	server 127.0.19.071 127.0.19.71:80 weight 10 check inter 2588 fall 2 rise 1
-	server 127.0.19.072 127.0.19.72:80 weight 10 check inter 8007 fall 2 rise 1
-	server 127.0.19.073 127.0.19.73:80 weight 10 check inter 4265 fall 2 rise 1
-	server 127.0.19.074 127.0.19.74:80 weight 10 check inter 1418 fall 2 rise 1
-	server 127.0.19.075 127.0.19.75:80 weight 10 check inter 8032 fall 2 rise 1
-	server 127.0.19.076 127.0.19.76:80 weight 10 check inter 4975 fall 2 rise 1
-	server 127.0.19.077 127.0.19.77:80 weight 10 check inter 5062 fall 2 rise 1
-	server 127.0.19.078 127.0.19.78:80 weight 10 check inter 8240 fall 2 rise 1
-	server 127.0.19.079 127.0.19.79:80 weight 10 check inter 6752 fall 2 rise 1
-	server 127.0.19.080 127.0.19.80:80 weight 10 check inter 3002 fall 2 rise 1
-	server 127.0.19.081 127.0.19.81:80 weight 10 check inter 9586 fall 2 rise 1
-	server 127.0.19.082 127.0.19.82:80 weight 10 check inter 6211 fall 2 rise 1
-	server 127.0.19.083 127.0.19.83:80 weight 10 check inter 7317 fall 2 rise 1
-	server 127.0.19.084 127.0.19.84:80 weight 10 check inter 7943 fall 2 rise 1
-	server 127.0.19.085 127.0.19.85:80 weight 10 check inter 1425 fall 2 rise 1
-	server 127.0.19.086 127.0.19.86:80 weight 10 check inter 9924 fall 2 rise 1
-	server 127.0.19.087 127.0.19.87:80 weight 10 check inter 572 fall 2 rise 1
-	server 127.0.19.088 127.0.19.88:80 weight 10 check inter 2601 fall 2 rise 1
-	server 127.0.19.089 127.0.19.89:80 weight 10 check inter 3848 fall 2 rise 1
-	server 127.0.19.090 127.0.19.90:80 weight 10 check inter 6301 fall 2 rise 1
-	server 127.0.19.091 127.0.19.91:80 weight 10 check inter 5805 fall 2 rise 1
-	server 127.0.19.092 127.0.19.92:80 weight 10 check inter 2016 fall 2 rise 1
-	server 127.0.19.093 127.0.19.93:80 weight 10 check inter 6646 fall 2 rise 1
-	server 127.0.19.094 127.0.19.94:80 weight 10 check inter 1372 fall 2 rise 1
-	server 127.0.19.095 127.0.19.95:80 weight 10 check inter 5321 fall 2 rise 1
-	server 127.0.19.096 127.0.19.96:80 weight 10 check inter 1847 fall 2 rise 1
-	server 127.0.19.097 127.0.19.97:80 weight 10 check inter 6658 fall 2 rise 1
-	server 127.0.19.098 127.0.19.98:80 weight 10 check inter 974 fall 2 rise 1
-	server 127.0.19.099 127.0.19.99:80 weight 10 check inter 8390 fall 2 rise 1
-	server 127.0.19.100 127.0.19.100:80 weight 10 check inter 5710 fall 2 rise 1
-	server 127.0.19.101 127.0.19.101:80 weight 10 check inter 8594 fall 2 rise 1
-	server 127.0.19.102 127.0.19.102:80 weight 10 check inter 7342 fall 2 rise 1
-	server 127.0.19.103 127.0.19.103:80 weight 10 check inter 2906 fall 2 rise 1
-	server 127.0.19.104 127.0.19.104:80 weight 10 check inter 166 fall 2 rise 1
-	server 127.0.19.105 127.0.19.105:80 weight 10 check inter 1856 fall 2 rise 1
-	server 127.0.19.106 127.0.19.106:80 weight 10 check inter 7339 fall 2 rise 1
-	server 127.0.19.107 127.0.19.107:80 weight 10 check inter 3864 fall 2 rise 1
-	server 127.0.19.108 127.0.19.108:80 weight 10 check inter 5550 fall 2 rise 1
-	server 127.0.19.109 127.0.19.109:80 weight 10 check inter 7181 fall 2 rise 1
-	server 127.0.19.110 127.0.19.110:80 weight 10 check inter 3067 fall 2 rise 1
-	server 127.0.19.111 127.0.19.111:80 weight 10 check inter 5469 fall 2 rise 1
-	server 127.0.19.112 127.0.19.112:80 weight 10 check inter 5792 fall 2 rise 1
-	server 127.0.19.113 127.0.19.113:80 weight 10 check inter 6946 fall 2 rise 1
-	server 127.0.19.114 127.0.19.114:80 weight 10 check inter 7378 fall 2 rise 1
-	server 127.0.19.115 127.0.19.115:80 weight 10 check inter 4282 fall 2 rise 1
-	server 127.0.19.116 127.0.19.116:80 weight 10 check inter 9082 fall 2 rise 1
-	server 127.0.19.117 127.0.19.117:80 weight 10 check inter 7163 fall 2 rise 1
-	server 127.0.19.118 127.0.19.118:80 weight 10 check inter 2256 fall 2 rise 1
-	server 127.0.19.119 127.0.19.119:80 weight 10 check inter 6207 fall 2 rise 1
-	server 127.0.19.120 127.0.19.120:80 weight 10 check inter 5661 fall 2 rise 1
-	server 127.0.19.121 127.0.19.121:80 weight 10 check inter 8642 fall 2 rise 1
-	server 127.0.19.122 127.0.19.122:80 weight 10 check inter 3053 fall 2 rise 1
-	server 127.0.19.123 127.0.19.123:80 weight 10 check inter 1068 fall 2 rise 1
-	server 127.0.19.124 127.0.19.124:80 weight 10 check inter 9319 fall 2 rise 1
-	server 127.0.19.125 127.0.19.125:80 weight 10 check inter 8765 fall 2 rise 1
-	server 127.0.19.126 127.0.19.126:80 weight 10 check inter 7157 fall 2 rise 1
-	server 127.0.19.127 127.0.19.127:80 weight 10 check inter 151 fall 2 rise 1
-	server 127.0.19.128 127.0.19.128:80 weight 10 check inter 5041 fall 2 rise 1
-	server 127.0.19.129 127.0.19.129:80 weight 10 check inter 5799 fall 2 rise 1
-	server 127.0.19.130 127.0.19.130:80 weight 10 check inter 1780 fall 2 rise 1
-	server 127.0.19.131 127.0.19.131:80 weight 10 check inter 7260 fall 2 rise 1
-	server 127.0.19.132 127.0.19.132:80 weight 10 check inter 5096 fall 2 rise 1
-	server 127.0.19.133 127.0.19.133:80 weight 10 check inter 6127 fall 2 rise 1
-	server 127.0.19.134 127.0.19.134:80 weight 10 check inter 4976 fall 2 rise 1
-	server 127.0.19.135 127.0.19.135:80 weight 10 check inter 2951 fall 2 rise 1
-	server 127.0.19.136 127.0.19.136:80 weight 10 check inter 6908 fall 2 rise 1
-	server 127.0.19.137 127.0.19.137:80 weight 10 check inter 4002 fall 2 rise 1
-	server 127.0.19.138 127.0.19.138:80 weight 10 check inter 2265 fall 2 rise 1
-	server 127.0.19.139 127.0.19.139:80 weight 10 check inter 7123 fall 2 rise 1
-	server 127.0.19.140 127.0.19.140:80 weight 10 check inter 1787 fall 2 rise 1
-	server 127.0.19.141 127.0.19.141:80 weight 10 check inter 8665 fall 2 rise 1
-	server 127.0.19.142 127.0.19.142:80 weight 10 check inter 8674 fall 2 rise 1
-	server 127.0.19.143 127.0.19.143:80 weight 10 check inter 6240 fall 2 rise 1
-	server 127.0.19.144 127.0.19.144:80 weight 10 check inter 5083 fall 2 rise 1
-	server 127.0.19.145 127.0.19.145:80 weight 10 check inter 6914 fall 2 rise 1
-	server 127.0.19.146 127.0.19.146:80 weight 10 check inter 9020 fall 2 rise 1
-	server 127.0.19.147 127.0.19.147:80 weight 10 check inter 7430 fall 2 rise 1
-	server 127.0.19.148 127.0.19.148:80 weight 10 check inter 6233 fall 2 rise 1
-	server 127.0.19.149 127.0.19.149:80 weight 10 check inter 4096 fall 2 rise 1
-	server 127.0.19.150 127.0.19.150:80 weight 10 check inter 9654 fall 2 rise 1
-	server 127.0.19.151 127.0.19.151:80 weight 10 check inter 6525 fall 2 rise 1
-	server 127.0.19.152 127.0.19.152:80 weight 10 check inter 7108 fall 2 rise 1
-	server 127.0.19.153 127.0.19.153:80 weight 10 check inter 7762 fall 2 rise 1
-	server 127.0.19.154 127.0.19.154:80 weight 10 check inter 5543 fall 2 rise 1
-	server 127.0.19.155 127.0.19.155:80 weight 10 check inter 8264 fall 2 rise 1
-	server 127.0.19.156 127.0.19.156:80 weight 10 check inter 6504 fall 2 rise 1
-	server 127.0.19.157 127.0.19.157:80 weight 10 check inter 9909 fall 2 rise 1
-	server 127.0.19.158 127.0.19.158:80 weight 10 check inter 4215 fall 2 rise 1
-	server 127.0.19.159 127.0.19.159:80 weight 10 check inter 1285 fall 2 rise 1
-	server 127.0.19.160 127.0.19.160:80 weight 10 check inter 1964 fall 2 rise 1
-	server 127.0.19.161 127.0.19.161:80 weight 10 check inter 1864 fall 2 rise 1
-	server 127.0.19.162 127.0.19.162:80 weight 10 check inter 1712 fall 2 rise 1
-	server 127.0.19.163 127.0.19.163:80 weight 10 check inter 9493 fall 2 rise 1
-	server 127.0.19.164 127.0.19.164:80 weight 10 check inter 2475 fall 2 rise 1
-	server 127.0.19.165 127.0.19.165:80 weight 10 check inter 1587 fall 2 rise 1
-	server 127.0.19.166 127.0.19.166:80 weight 10 check inter 808 fall 2 rise 1
-	server 127.0.19.167 127.0.19.167:80 weight 10 check inter 7980 fall 2 rise 1
-	server 127.0.19.168 127.0.19.168:80 weight 10 check inter 8595 fall 2 rise 1
-	server 127.0.19.169 127.0.19.169:80 weight 10 check inter 2695 fall 2 rise 1
-	server 127.0.19.170 127.0.19.170:80 weight 10 check inter 9404 fall 2 rise 1
-	server 127.0.19.171 127.0.19.171:80 weight 10 check inter 3383 fall 2 rise 1
-	server 127.0.19.172 127.0.19.172:80 weight 10 check inter 782 fall 2 rise 1
-	server 127.0.19.173 127.0.19.173:80 weight 10 check inter 2499 fall 2 rise 1
-	server 127.0.19.174 127.0.19.174:80 weight 10 check inter 1692 fall 2 rise 1
-	server 127.0.19.175 127.0.19.175:80 weight 10 check inter 4720 fall 2 rise 1
-	server 127.0.19.176 127.0.19.176:80 weight 10 check inter 7124 fall 2 rise 1
-	server 127.0.19.177 127.0.19.177:80 weight 10 check inter 2380 fall 2 rise 1
-	server 127.0.19.178 127.0.19.178:80 weight 10 check inter 9993 fall 2 rise 1
-	server 127.0.19.179 127.0.19.179:80 weight 10 check inter 2259 fall 2 rise 1
-	server 127.0.19.180 127.0.19.180:80 weight 10 check inter 5517 fall 2 rise 1
-	server 127.0.19.181 127.0.19.181:80 weight 10 check inter 6697 fall 2 rise 1
-	server 127.0.19.182 127.0.19.182:80 weight 10 check inter 3070 fall 2 rise 1
-	server 127.0.19.183 127.0.19.183:80 weight 10 check inter 1086 fall 2 rise 1
-	server 127.0.19.184 127.0.19.184:80 weight 10 check inter 887 fall 2 rise 1
-	server 127.0.19.185 127.0.19.185:80 weight 10 check inter 642 fall 2 rise 1
-	server 127.0.19.186 127.0.19.186:80 weight 10 check inter 5617 fall 2 rise 1
-	server 127.0.19.187 127.0.19.187:80 weight 10 check inter 779 fall 2 rise 1
-	server 127.0.19.188 127.0.19.188:80 weight 10 check inter 6060 fall 2 rise 1
-	server 127.0.19.189 127.0.19.189:80 weight 10 check inter 6774 fall 2 rise 1
-	server 127.0.19.190 127.0.19.190:80 weight 10 check inter 9624 fall 2 rise 1
-	server 127.0.19.191 127.0.19.191:80 weight 10 check inter 6765 fall 2 rise 1
-	server 127.0.19.192 127.0.19.192:80 weight 10 check inter 6064 fall 2 rise 1
-	server 127.0.19.193 127.0.19.193:80 weight 10 check inter 4335 fall 2 rise 1
-	server 127.0.19.194 127.0.19.194:80 weight 10 check inter 1884 fall 2 rise 1
-	server 127.0.19.195 127.0.19.195:80 weight 10 check inter 6475 fall 2 rise 1
-	server 127.0.19.196 127.0.19.196:80 weight 10 check inter 206 fall 2 rise 1
-	server 127.0.19.197 127.0.19.197:80 weight 10 check inter 9542 fall 2 rise 1
-	server 127.0.19.198 127.0.19.198:80 weight 10 check inter 4319 fall 2 rise 1
-	server 127.0.19.199 127.0.19.199:80 weight 10 check inter 9087 fall 2 rise 1
-	server 127.0.19.200 127.0.19.200:80 weight 10 check inter 9984 fall 2 rise 1
-	server 127.0.19.201 127.0.19.201:80 weight 10 check inter 6502 fall 2 rise 1
-	server 127.0.19.202 127.0.19.202:80 weight 10 check inter 6476 fall 2 rise 1
-	server 127.0.19.203 127.0.19.203:80 weight 10 check inter 4910 fall 2 rise 1
-	server 127.0.19.204 127.0.19.204:80 weight 10 check inter 4880 fall 2 rise 1
-	server 127.0.19.205 127.0.19.205:80 weight 10 check inter 162 fall 2 rise 1
-	server 127.0.19.206 127.0.19.206:80 weight 10 check inter 4114 fall 2 rise 1
-	server 127.0.19.207 127.0.19.207:80 weight 10 check inter 4101 fall 2 rise 1
-	server 127.0.19.208 127.0.19.208:80 weight 10 check inter 9794 fall 2 rise 1
-	server 127.0.19.209 127.0.19.209:80 weight 10 check inter 1109 fall 2 rise 1
-	server 127.0.19.210 127.0.19.210:80 weight 10 check inter 6432 fall 2 rise 1
-	server 127.0.19.211 127.0.19.211:80 weight 10 check inter 9880 fall 2 rise 1
-	server 127.0.19.212 127.0.19.212:80 weight 10 check inter 3837 fall 2 rise 1
-	server 127.0.19.213 127.0.19.213:80 weight 10 check inter 5166 fall 2 rise 1
-	server 127.0.19.214 127.0.19.214:80 weight 10 check inter 8816 fall 2 rise 1
-	server 127.0.19.215 127.0.19.215:80 weight 10 check inter 9754 fall 2 rise 1
-	server 127.0.19.216 127.0.19.216:80 weight 10 check inter 5341 fall 2 rise 1
-	server 127.0.19.217 127.0.19.217:80 weight 10 check inter 3287 fall 2 rise 1
-	server 127.0.19.218 127.0.19.218:80 weight 10 check inter 4100 fall 2 rise 1
-	server 127.0.19.219 127.0.19.219:80 weight 10 check inter 4220 fall 2 rise 1
-	server 127.0.19.220 127.0.19.220:80 weight 10 check inter 5722 fall 2 rise 1
-	server 127.0.19.221 127.0.19.221:80 weight 10 check inter 1161 fall 2 rise 1
-	server 127.0.19.222 127.0.19.222:80 weight 10 check inter 7522 fall 2 rise 1
-	server 127.0.19.223 127.0.19.223:80 weight 10 check inter 469 fall 2 rise 1
-	server 127.0.19.224 127.0.19.224:80 weight 10 check inter 2422 fall 2 rise 1
-	server 127.0.19.225 127.0.19.225:80 weight 10 check inter 7570 fall 2 rise 1
-	server 127.0.19.226 127.0.19.226:80 weight 10 check inter 7918 fall 2 rise 1
-	server 127.0.19.227 127.0.19.227:80 weight 10 check inter 117 fall 2 rise 1
-	server 127.0.19.228 127.0.19.228:80 weight 10 check inter 6969 fall 2 rise 1
-	server 127.0.19.229 127.0.19.229:80 weight 10 check inter 1362 fall 2 rise 1
-	server 127.0.19.230 127.0.19.230:80 weight 10 check inter 3115 fall 2 rise 1
-	server 127.0.19.231 127.0.19.231:80 weight 10 check inter 4906 fall 2 rise 1
-	server 127.0.19.232 127.0.19.232:80 weight 10 check inter 237 fall 2 rise 1
-	server 127.0.19.233 127.0.19.233:80 weight 10 check inter 4408 fall 2 rise 1
-	server 127.0.19.234 127.0.19.234:80 weight 10 check inter 177 fall 2 rise 1
-	server 127.0.19.235 127.0.19.235:80 weight 10 check inter 655 fall 2 rise 1
-	server 127.0.19.236 127.0.19.236:80 weight 10 check inter 9977 fall 2 rise 1
-	server 127.0.19.237 127.0.19.237:80 weight 10 check inter 7167 fall 2 rise 1
-	server 127.0.19.238 127.0.19.238:80 weight 10 check inter 3293 fall 2 rise 1
-	server 127.0.19.239 127.0.19.239:80 weight 10 check inter 3416 fall 2 rise 1
-	server 127.0.19.240 127.0.19.240:80 weight 10 check inter 909 fall 2 rise 1
-	server 127.0.19.241 127.0.19.241:80 weight 10 check inter 6824 fall 2 rise 1
-	server 127.0.19.242 127.0.19.242:80 weight 10 check inter 683 fall 2 rise 1
-	server 127.0.19.243 127.0.19.243:80 weight 10 check inter 9165 fall 2 rise 1
-	server 127.0.19.244 127.0.19.244:80 weight 10 check inter 1650 fall 2 rise 1
-	server 127.0.19.245 127.0.19.245:80 weight 10 check inter 966 fall 2 rise 1
-	server 127.0.19.246 127.0.19.246:80 weight 10 check inter 3028 fall 2 rise 1
-	server 127.0.19.247 127.0.19.247:80 weight 10 check inter 5466 fall 2 rise 1
-	server 127.0.19.248 127.0.19.248:80 weight 10 check inter 5983 fall 2 rise 1
-	server 127.0.19.249 127.0.19.249:80 weight 10 check inter 4892 fall 2 rise 1
-	server 127.0.19.250 127.0.19.250:80 weight 10 check inter 792 fall 2 rise 1
diff --git a/deps/haproxy-1.4.21/tests/test-sql.cfg b/deps/haproxy-1.4.21/tests/test-sql.cfg
deleted file mode 100644
index c2aebd9..0000000
--- a/deps/haproxy-1.4.21/tests/test-sql.cfg
+++ /dev/null
@@ -1,29 +0,0 @@
-# This is a test configuration.
-# It requires a mysql server running on local port 3306.
-
-global
-	maxconn		500
-
-defaults
-        contimeout      1000
-        clitimeout      5000
-        srvtimeout      5000
-        retries         1
-        option redispatch
-
-listen stats
-	bind :8080
-	mode http
-	stats enable
-	stats uri /stats
-
-listen  mysql_1
-        bind :3307
-        mode tcp
-        balance roundrobin
-        option mysql-check user haproxy
-        server  srv1 127.0.0.1:3306 check port 3306 inter 1000 fall 1
-#        server  srv2 127.0.0.2:3306 check port 3306 inter 1000 fall 1
-#        server  srv3 127.0.0.3:3306 check port 3306 inter 1000 fall 1
-#        server  srv4 127.0.0.4:3306 check port 3306 inter 1000 fall 1
-
diff --git a/deps/haproxy-1.4.21/tests/test-status.cfg b/deps/haproxy-1.4.21/tests/test-status.cfg
deleted file mode 100644
index cfb2294..0000000
--- a/deps/haproxy-1.4.21/tests/test-status.cfg
+++ /dev/null
@@ -1,24 +0,0 @@
-# This is a test configuration.
-# It presents an active, a failed server, and a backup server in the
-# stats page. Connect to port 8000 to consult status.
-
-
-global
-	maxconn		10000
-	#daemon
-	#nbproc		2
-
-listen  to-pcw
-        mode            http
-        bind		:8000
-        clitimeout      15000
-        srvtimeout      15000
-        contimeout      15000
-        maxconn 40000
-	option httpclose
-	balance roundrobin
-	server srv1 127.0.0.1:6000 check inter 1000 maxconn 1000 maxqueue 100
-	server srv2 127.0.0.1:65535 check inter 1000 maxqueue 100
-	server srv3 127.0.0.1:65535 backup
-	stats uri /
-
diff --git a/deps/haproxy-1.4.21/tests/test-time.cfg b/deps/haproxy-1.4.21/tests/test-time.cfg
deleted file mode 100644
index 6999653..0000000
--- a/deps/haproxy-1.4.21/tests/test-time.cfg
+++ /dev/null
@@ -1,24 +0,0 @@
-# This is a test configuration.
-# It is used to check that time units are correctly parsed.
-
-global
-	maxconn    1000
-        stats timeout 3s
-
-listen  sample1
-        mode       http
-        retries    1
-        redispatch
-        contimeout 5s
-        clitimeout 15m
-        srvtimeout 15m
-        maxconn    40000
-        bind       :8080
-        balance    roundrobin
-	option     allbackups
-        server     act1 127.0.0.1:80 weight 10 check port 81 inter 500ms fall 1
-        server     act2 127.0.0.2:80 weight 20 check port 81 inter 500ms fall 1
-        server     act3 127.0.0.3:80 weight 30 check port 81 inter 500ms fall 1
-        option     httpclose
-	stats      uri /stats
-	stats      refresh 5000ms
diff --git a/deps/haproxy-1.4.21/tests/test-timeout.cfg b/deps/haproxy-1.4.21/tests/test-timeout.cfg
deleted file mode 100644
index 1c08425..0000000
--- a/deps/haproxy-1.4.21/tests/test-timeout.cfg
+++ /dev/null
@@ -1,27 +0,0 @@
-# This is a test configuration.
-# It is used to check that time units are correctly parsed.
-
-global
-	maxconn    1000
-        stats timeout 3s
-
-listen  sample1
-        mode       http
-        retries    1
-        redispatch
-        timeout    client  15m
-        timeout    http-request 6s
-        timeout    tarpit  20s
-        timeout    queue   60s
-        timeout    connect 5s
-        timeout    server  15m
-        maxconn    40000
-        bind       :8000
-        balance    roundrobin
-	option     allbackups
-        server     act1 127.0.0.1:80 weight 10 check port 81 inter 500ms fall 1
-        server     act2 127.0.0.2:80 weight 20 check port 81 inter 500ms fall 1
-        server     act3 127.0.0.3:80 weight 30 check port 81 inter 500ms fall 1
-        option     httpclose
-	stats      uri /stats
-	stats      refresh 5000ms
diff --git a/deps/haproxy-1.4.21/tests/test-url-hash.cfg b/deps/haproxy-1.4.21/tests/test-url-hash.cfg
deleted file mode 100644
index 2f384cb..0000000
--- a/deps/haproxy-1.4.21/tests/test-url-hash.cfg
+++ /dev/null
@@ -1,40 +0,0 @@
-# This is a test configuration.
-# It exercises the "url_param" balance algorithm. It looks for
-# an URL parameter named "foo".
-
-global
-	maxconn 100
-	log		127.0.0.1 local0
-
-listen  vip1
-	log		global
-	option		httplog
-        bind		:8000
-        mode		http
-        maxconn		100
-        clitimeout	5000
-	contimeout	5000
-	srvtimeout	5000
-	balance		url_param foo
-	server		srv1 127.0.0.1:80
-	server		srv2 127.0.0.1:80
-
-	# control activity this way
-	stats		uri /stat
-
-listen  vip2
-	log		global
-	option		httplog
-	bind		:8001
-	mode		http
-	maxconn		100
-	clitimeout	5000
-	contimeout	5000
-	srvtimeout	5000
-	balance		url_param foo check_post
-	server		srv1 127.0.0.1:80
-	server		srv2 127.0.0.1:80
-
-	# control activity this way
-	stats		uri /stat
-
diff --git a/deps/haproxy-1.4.21/tests/test-valid-names.cfg b/deps/haproxy-1.4.21/tests/test-valid-names.cfg
deleted file mode 100644
index 1842a78..0000000
--- a/deps/haproxy-1.4.21/tests/test-valid-names.cfg
+++ /dev/null
@@ -1,37 +0,0 @@
-# This is a test configuration.
-# It checks instances, servers and acl names.
-
-listen		valid_listen1
-		bind		:8000
-		clitimeout	5000
-		contimeout	5000
-		srvtimeout	5000
-		balance		roundrobin
-		server		srv1 127.0.0.1:80
-
-frontend	www.valid-frontend.net:80
-		bind		:8001
-		clitimeout	5000
-		acl host_www.valid-frontend.net:80 hdr(host) www.valid-frontend.net
-
-backend		Valid_BK-1
-		contimeout	5000
-		srvtimeout	5000
-		balance		roundrobin
-		server		bk1_srv-1:80 127.0.0.1:80
-
-frontend	www.test-frontend.net:8002/invalid
-		bind		:8002
-		clitimeout	5000
-
-frontend	ft1_acl
-		bind		:8003
-		clitimeout	5000
-		acl invalid!name url /
-
-backend		bk2_srv
-		contimeout	5000
-		srvtimeout	5000
-		balance		roundrobin
-		server		bk2/srv-1 127.0.0.1:80
-
diff --git a/deps/haproxy-1.4.21/tests/test.c b/deps/haproxy-1.4.21/tests/test.c
deleted file mode 100644
index 4595712..0000000
--- a/deps/haproxy-1.4.21/tests/test.c
+++ /dev/null
@@ -1,13 +0,0 @@
-main() {
-  write(1, "HTTP", 4);
-  write(1, "/1.0", 4);
-  write(1, " 200", 4);
-  write(1, " OK\r\n", 5);
-  write(1, "TOTO: 1\r\n", 9);
-  write(1, "Hdr2: 2\r\n", 9);
-  write(1, "Hdr3:", 5);
-  write(1, " 2\r\n", 4);
-  write(1, "\r\n\r\n", 4);
-  write(1, "DATA\r\n", 6);
-}
-
diff --git a/deps/haproxy-1.4.21/tests/test_hashes.c b/deps/haproxy-1.4.21/tests/test_hashes.c
deleted file mode 100644
index 39cb965..0000000
--- a/deps/haproxy-1.4.21/tests/test_hashes.c
+++ /dev/null
@@ -1,559 +0,0 @@
-/*
-  This file only show how many operations a hash is able to handle.
-  It don't show the distribution nor collisions.
-  
-  gcc -Wall -O3 -o test_hashes test_hashes.c
-  ./test_hashes |sort -k 3 -r
- */
-#include <sys/time.h>
-#include <time.h>
-#include <stdlib.h>
-#include <stdbool.h>
-#include <string.h>
-#include <stdio.h>
-//#include <stdint.h>
-
-
-static struct timeval timeval_current(void)
-{
-	struct timeval tv;
-	gettimeofday(&tv, NULL);
-	return tv;
-}
-
-static double timeval_elapsed(struct timeval *tv)
-{
-	struct timeval tv2 = timeval_current();
-	return (tv2.tv_sec - tv->tv_sec) + 
-	       (tv2.tv_usec - tv->tv_usec)*1.0e-6;
-}
-
-#define HAPROXY_BACKENDS 4
-
-unsigned long haproxy_uri_hash(char *uri, int uri_len){
-
-  unsigned long hash = 0;
-  int c;
-
-  while (uri_len--) {
-    c = *uri++;
-    if (c == '?')
-      break;
-    hash = c + (hash << 6) + (hash << 16) - hash;
-  }
-
-  return hash%HAPROXY_BACKENDS; /* I assume 4 active backends */
-} /* end haproxy_hash() */
-
-/*
- * http://eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx
- */
-unsigned sax_hash ( void *key, int len )
-{
-  unsigned char *p = key;
-  unsigned h = 0;
-  int i;
-
-  for ( i = 0; i < len; i++ )
-    h ^= ( h << 5 ) + ( h >> 2 ) + p[i];
-
-  return h;
-}
-
-#include <arpa/inet.h>
-/* len 4 for ipv4 and 16 for ipv6 */
-unsigned int haproxy_server_hash(const char *addr, int len){
-  unsigned int h, l;
-  l = h = 0;
-
-  while ((l + sizeof (int)) <= len) {
-    h ^= ntohl(*(unsigned int *)(&addr[l]));
-    l += sizeof (int);
-  }
-  return h %= HAPROXY_BACKENDS;
-}/* end haproxy_server_hash() */
-
-
-int hashpjw(const void *key) {
-
-  const char         *ptr;
-  unsigned int        val;
-  /*********************************************************************
-   *                                                                    *
-   *  Hash the key by performing a number of bit operations on it.      *
-   *                                                                    *
-   *********************************************************************/
-
-  val = 0;
-  ptr = key;
-  
-  while (*ptr != '\0') {
-
-    int tmp;
-    
-    val = (val << 4) + (*ptr);
-    
-    if((tmp = (val & 0xf0000000))) {
-      val = val ^ (tmp >> 24);
-      val = val ^ tmp;
-    }
-    ptr++;
-  }/* end while */
-
-  return val;
-}/* end hashpjw */
-
-static unsigned long
-hash_djbx33(
-    register unsigned char *key,
-    register size_t len)
-{
-    register unsigned long hash = 5381;
-
-    /* the hash unrolled eight times */
-    for (; len >= 8; len -= 8) {
-        hash = ((hash << 5) + hash) + *key++;
-        hash = ((hash << 5) + hash) + *key++;
-        hash = ((hash << 5) + hash) + *key++;
-        hash = ((hash << 5) + hash) + *key++;
-        hash = ((hash << 5) + hash) + *key++;
-        hash = ((hash << 5) + hash) + *key++;
-        hash = ((hash << 5) + hash) + *key++;
-        hash = ((hash << 5) + hash) + *key++;
-    }
-    switch (len) {
-        case 7: hash = ((hash << 5) + hash) + *key++; /* fallthrough... */
-        case 6: hash = ((hash << 5) + hash) + *key++; /* fallthrough... */
-        case 5: hash = ((hash << 5) + hash) + *key++; /* fallthrough... */
-        case 4: hash = ((hash << 5) + hash) + *key++; /* fallthrough... */
-        case 3: hash = ((hash << 5) + hash) + *key++; /* fallthrough... */
-        case 2: hash = ((hash << 5) + hash) + *key++; /* fallthrough... */
-        case 1: hash = ((hash << 5) + hash) + *key++; break;
-        default: /* case 0: */ break;
-    }
-    return hash;
-}
-
-typedef  unsigned long  int  ub4;   /* unsigned 4-byte quantities */
-typedef  unsigned       char ub1;   /* unsigned 1-byte quantities */
-
-ub4 bernstein(ub1 *key, ub4 len, ub4 level){
-  ub4 hash = level;
-  ub4 i;
-  for (i=0; i<len; ++i) hash = 33*hash + key[i];
-  return hash;
-}
-
-/*
- * http://www.azillionmonkeys.com/qed/hash.html
- */
-#undef get16bits
-#if (defined(__GNUC__) && defined(__i386__)) || defined(__WATCOMC__) \
-  || defined(_MSC_VER) || defined (__BORLANDC__) || defined (__TURBOC__)
-#define get16bits(d) (*((const uint16_t *) (d)))
-#endif
-
-#if !defined (get16bits)
-#define get16bits(d) ((((uint32_t)(((const uint8_t *)(d))[1])) << 8)\
-                       +(uint32_t)(((const uint8_t *)(d))[0]) )
-#endif
-
-uint32_t SuperFastHash (const char * data, int len) {
-uint32_t hash = len, tmp;
-int rem;
-
-    if (len <= 0 || data == NULL) return 0;
-
-    rem = len & 3;
-    len >>= 2;
-
-    /* Main loop */
-    for (;len > 0; len--) {
-        hash  += get16bits (data);
-        tmp    = (get16bits (data+2) << 11) ^ hash;
-        hash   = (hash << 16) ^ tmp;
-        data  += 2*sizeof (uint16_t);
-        hash  += hash >> 11;
-    }
-
-    /* Handle end cases */
-    switch (rem) {
-        case 3: hash += get16bits (data);
-                hash ^= hash << 16;
-                hash ^= data[sizeof (uint16_t)] << 18;
-                hash += hash >> 11;
-                break;
-        case 2: hash += get16bits (data);
-                hash ^= hash << 11;
-                hash += hash >> 17;
-                break;
-        case 1: hash += *data;
-                hash ^= hash << 10;
-                hash += hash >> 1;
-    }
-
-    /* Force "avalanching" of final 127 bits */
-    hash ^= hash << 3;
-    hash += hash >> 5;
-    hash ^= hash << 4;
-    hash += hash >> 17;
-    hash ^= hash << 25;
-    hash += hash >> 6;
-
-    return hash;
-}
-
-/*
- * This variant is about 15% faster.
- */
-uint32_t SuperFastHash2 (const char * data, int len) {
-uint32_t hash = len, tmp;
-int rem;
-
-    if (len <= 0 || data == NULL) return 0;
-
-    rem = len & 3;
-    len >>= 2;
-
-    /* Main loop */
-    for (;len > 0; len--) {
-	register uint32_t next;
-	next   = get16bits(data+2);
-        hash  += get16bits(data);
-        tmp    = (next << 11) ^ hash;
-        hash   = (hash << 16) ^ tmp;
-        data  += 2*sizeof (uint16_t);
-        hash  += hash >> 11;
-    }
-
-    /* Handle end cases */
-    switch (rem) {
-        case 3: hash += get16bits (data);
-                hash ^= hash << 16;
-                hash ^= data[sizeof (uint16_t)] << 18;
-                hash += hash >> 11;
-                break;
-        case 2: hash += get16bits (data);
-                hash ^= hash << 11;
-                hash += hash >> 17;
-                break;
-        case 1: hash += *data;
-                hash ^= hash << 10;
-                hash += hash >> 1;
-    }
-
-    /* Force "avalanching" of final 127 bits */
-    hash ^= hash << 3;
-    hash += hash >> 5;
-    hash ^= hash << 4;
-    hash += hash >> 17;
-    hash ^= hash << 25;
-    hash += hash >> 6;
-
-    return hash;
-}
-
-/*
- * 32 bit FNV-0 hash type
- */
-typedef unsigned long Fnv32_t;
-
-/*
- * fnv_32a_str - perform a 32 bit Fowler/Noll/Vo FNV-1a hash on a string
- *
- * input:
- *	str	- string to hash
- *	hval	- previous hash value or 0 if first call
- *
- * returns:
- *	32 bit hash as a static hash type
- *
- * NOTE: To use the recommended 32 bit FNV-1a hash, use FNV1_32A_INIT as the
- *  	 hval arg on the first call to either fnv_32a_buf() or fnv_32a_str().
- */
-Fnv32_t
-fnv_32a_str(char *str, Fnv32_t hval)
-{
-    unsigned char *s = (unsigned char *)str;	/* unsigned string */
-
-    /*
-     * FNV-1a hash each octet in the buffer
-     */
-    while (*s) {
-
-	/* xor the bottom with the current octet */
-	hval ^= (Fnv32_t)*s++;
-
-/* #define NO_FNV_GCC_OPTIMIZATION */
-	/* multiply by the 32 bit FNV magic prime mod 2^32 */
-#if defined(NO_FNV_GCC_OPTIMIZATION)
-	/*
-	 * 32 bit magic FNV-1a prime
-	 */
-#define FNV_32_PRIME ((Fnv32_t)0x01000193)
-	hval *= FNV_32_PRIME;
-#else
-	hval += (hval<<1) + (hval<<4) + (hval<<7) + (hval<<8) + (hval<<24);
-#endif
-    }
-
-    /* return our new hash value */
-    return hval;
-}
-
-/*
- * from lookup3.c, by Bob Jenkins, May 2006, Public Domain.
- */
-
-#define rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))
-
-/*
--------------------------------------------------------------------------------
-mix -- mix 3 32-bit values reversibly.
-
-This is reversible, so any information in (a,b,c) before mix() is
-still in (a,b,c) after mix().
-
-If four pairs of (a,b,c) inputs are run through mix(), or through
-mix() in reverse, there are at least 32 bits of the output that
-are sometimes the same for one pair and different for another pair.
-This was tested for:
-* pairs that differed by one bit, by two bits, in any combination
-  of top bits of (a,b,c), or in any combination of bottom bits of
-  (a,b,c).
-* "differ" is defined as +, -, ^, or ~^.  For + and -, I transformed
-  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as
-  is commonly produced by subtraction) look like a single 1-bit
-  difference.
-* the base values were pseudorandom, all zero but one bit set, or 
-  all zero plus a counter that starts at zero.
-
-Some k values for my "a-=c; a^=rot(c,k); c+=b;" arrangement that
-satisfy this are
-    4  6  8 16 19  4
-    9 15  3 18 27 15
-   14  9  3  7 17  3
-Well, "9 15 3 18 27 15" didn't quite get 32 bits diffing
-for "differ" defined as + with a one-bit base and a two-bit delta.  I
-used http://burtleburtle.net/bob/hash/avalanche.html to choose 
-the operations, constants, and arrangements of the variables.
-
-This does not achieve avalanche.  There are input bits of (a,b,c)
-that fail to affect some output bits of (a,b,c), especially of a.  The
-most thoroughly mixed value is c, but it doesn't really even achieve
-avalanche in c.
-
-This allows some parallelism.  Read-after-writes are good at doubling
-the number of bits affected, so the goal of mixing pulls in the opposite
-direction as the goal of parallelism.  I did what I could.  Rotates
-seem to cost as much as shifts on every machine I could lay my hands
-on, and rotates are much kinder to the top and bottom bits, so I used
-rotates.
--------------------------------------------------------------------------------
-*/
-#define mix(a,b,c) \
-{ \
-  a -= c;  a ^= rot(c, 4);  c += b; \
-  b -= a;  b ^= rot(a, 6);  a += c; \
-  c -= b;  c ^= rot(b, 8);  b += a; \
-  a -= c;  a ^= rot(c,16);  c += b; \
-  b -= a;  b ^= rot(a,19);  a += c; \
-  c -= b;  c ^= rot(b, 4);  b += a; \
-}
-
-/*
--------------------------------------------------------------------------------
-final -- final mixing of 3 32-bit values (a,b,c) into c
-
-Pairs of (a,b,c) values differing in only a few bits will usually
-produce values of c that look totally different.  This was tested for
-* pairs that differed by one bit, by two bits, in any combination
-  of top bits of (a,b,c), or in any combination of bottom bits of
-  (a,b,c).
-* "differ" is defined as +, -, ^, or ~^.  For + and -, I transformed
-  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as
-  is commonly produced by subtraction) look like a single 1-bit
-  difference.
-* the base values were pseudorandom, all zero but one bit set, or 
-  all zero plus a counter that starts at zero.
-
-These constants passed:
- 14 11 25 16 4 14 24
- 12 14 25 16 4 14 24
-and these came close:
-  4  8 15 26 3 22 24
- 10  8 15 26 3 22 24
- 11  8 15 26 3 22 24
--------------------------------------------------------------------------------
-*/
-#define final(a,b,c) \
-{ \
-  c ^= b; c -= rot(b,14); \
-  a ^= c; a -= rot(c,11); \
-  b ^= a; b -= rot(a,25); \
-  c ^= b; c -= rot(b,16); \
-  a ^= c; a -= rot(c,4);  \
-  b ^= a; b -= rot(a,14); \
-  c ^= b; c -= rot(b,24); \
-}
-
-/*
---------------------------------------------------------------------
- This works on all machines.  To be useful, it requires
- -- that the key be an array of uint32_t's, and
- -- that the length be the number of uint32_t's in the key
-
- The function hashword() is identical to hashlittle() on little-endian
- machines, and identical to hashbig() on big-endian machines,
- except that the length has to be measured in uint32_ts rather than in
- bytes.  hashlittle() is more complicated than hashword() only because
- hashlittle() has to dance around fitting the key bytes into registers.
---------------------------------------------------------------------
-*/
-uint32_t hashword(
-const uint32_t *k,                   /* the key, an array of uint32_t values */
-size_t          length,               /* the length of the key, in uint32_ts */
-uint32_t        initval)         /* the previous hash, or an arbitrary value */
-{
-  uint32_t a,b,c;
-
-  /* Set up the internal state */
-  a = b = c = 0xdeadbeef + (((uint32_t)length)<<2) + initval;
-
-  /*------------------------------------------------- handle most of the key */
-  while (length > 3)
-  {
-    a += k[0];
-    b += k[1];
-    c += k[2];
-    mix(a,b,c);
-    length -= 3;
-    k += 3;
-  }
-
-  /*------------------------------------------- handle the last 3 uint32_t's */
-  switch(length)                     /* all the case statements fall through */
-  { 
-  case 3 : c+=k[2];
-  case 2 : b+=k[1];
-  case 1 : a+=k[0];
-    final(a,b,c);
-  case 0:     /* case 0: nothing left to add */
-    break;
-  }
-  /*------------------------------------------------------ report the result */
-  return c;
-}
-
-/* from K&R book site 139 */
-#define HASHSIZE 101
-
-unsigned kr_hash(char *s){
-  unsigned hashval;
-  
-  for(hashval = 0; *s != '\0';s++)
-    hashval = *s + 31 * hashval;
-
-  return hashval % HASHSIZE;
-    
-} /* end kr_hash() */
-
-unsigned fnv_hash ( void *key, int len )
-{
-  unsigned char *p = key;
-  unsigned h = 2166136261;
-  int i;
-
-  for ( i = 0; i < len; i++ )
-    h = ( h * 16777619 ) ^ p[i];
-
-  return h;
-}
-
-unsigned oat_hash ( void *key, int len )
-{
-  unsigned char *p = key;
-  unsigned h = 0;
-  int i;
-
-  for ( i = 0; i < len; i++ ) {
-    h += p[i];
-    h += ( h << 10 );
-    h ^= ( h >> 6 );
-  }
-
-  h += ( h << 3 );
-  h ^= ( h >> 11 );
-  h += ( h << 15 );
-
-  return h;
-}
-
-unsigned wt_hash ( void *key, int len )
-{
-  unsigned char *p = key;
-  unsigned h = 0x783c965aUL;
-  unsigned step = 16;
-
-  for (; len > 0; len--) {
-      h ^= *p * 9;
-      p++;
-      h = (h << step) | (h >> (32-step));
-      step ^= h;
-      step &= 0x1F;
-  }
-
-  return h;
-}
-
-
-#define run_test(fct, args) {						\
-    unsigned long loop, count;						\
-    volatile unsigned long result;					\
-    double delta;							\
-    struct timeval tv;							\
-    fprintf(stderr, "Starting %s\n", #fct);				\
-    tv = timeval_current();						\
-    count = 0;								\
-    do {								\
-	delta = timeval_elapsed(&tv);					\
-	for (loop = 0; loop < 1000; loop++) {				\
-	    result = fct args;						\
-	    count++;							\
-	}								\
-    } while (delta < 1.0);						\
-    fprintf(stdout, "%-20s : %10.0f run/sec\n", #fct, count/delta);	\
-    fflush(stdout);							\
-}
-
-int main(){
-
-  char **start;
-  int len;
-
-  char *urls[] = {
-    "http://www.microsoft.com/shared/core/1/webservice/navigation.asmx/DisplayDownlevelNavHtml",
-    NULL
-  };
-
-  start = urls;
-  len = strlen(*urls);
-
-  run_test(wt_hash, (*urls, len));
-  run_test(SuperFastHash2, (*urls, len));
-  run_test(SuperFastHash, (*urls, len));
-  run_test(haproxy_uri_hash, (*urls, len));
-  run_test(haproxy_server_hash, (*urls, len));
-  run_test(hashpjw, (*urls));
-  run_test(hash_djbx33, ((unsigned char *)*urls, len));
-  run_test(bernstein, ((unsigned char *)*urls, len, 4));
-  run_test(fnv_32a_str, (*urls, 0));
-  run_test(hashword, ((const uint32_t *)*urls,strlen(*urls),0));
-  run_test(kr_hash, (*urls));
-  run_test(sax_hash, (*urls, len));
-  run_test(fnv_hash, (*urls, len));
-  run_test(oat_hash, (*urls, len));
-
-  return 0;
-  
-}/* end main() */
diff --git a/deps/haproxy-1.4.21/tests/test_pools.c b/deps/haproxy-1.4.21/tests/test_pools.c
deleted file mode 100644
index c8558db..0000000
--- a/deps/haproxy-1.4.21/tests/test_pools.c
+++ /dev/null
@@ -1,207 +0,0 @@
-/*
- * Contribution from Aleksandar Lazic <al-haproxy@none.at>
- *
- * Build with :
- *   gcc -O2 -o test_pools test_pools.c
- * or with dlmalloc too :
- *   gcc -O2 -o test_pools -D USE_DLMALLOC test_pools.c -DUSE_DL_PREFIX dlmalloc.c
- */
-
-#include <sys/time.h>
-#include <time.h>
-#include <stdlib.h>
-#include <stdbool.h>
-#include <string.h>
-#include <stdio.h>
-
-static struct timeval timeval_current(void)
-{
-	struct timeval tv;
-	gettimeofday(&tv, NULL);
-	return tv;
-}
-
-static double timeval_elapsed(struct timeval *tv)
-{
-	struct timeval tv2 = timeval_current();
-	return (tv2.tv_sec - tv->tv_sec) + 
-	       (tv2.tv_usec - tv->tv_usec)*1.0e-6;
-}
-
-#define torture_assert(test, expr, str) if (!(expr)) { \
-	printf("failure: %s [\n%s: Expression %s failed: %s\n]\n", \
-		test, __location__, #expr, str); \
-	return false; \
-}
-
-#define torture_assert_str_equal(test, arg1, arg2, desc) \
-	if (strcmp(arg1, arg2)) { \
-		printf("failure: %s [\n%s: Expected %s, got %s: %s\n]\n", \
-		   test, __location__, arg1, arg2, desc); \
-		return false; \
-	}
-
-/* added pools from haproxy */
-#include <stdlib.h>
-
-/*
- * Returns a pointer to an area of <__len> bytes taken from the pool <pool> or
- * dynamically allocated. In the first case, <__pool> is updated to point to
- * the next element in the list.
- */
-#define pool_alloc_from(__pool, __len)                      \
-({                                                          \
-        void *__p;                                          \
-        if ((__p = (__pool)) == NULL)                       \
-                __p = malloc(((__len) >= sizeof (void *)) ? \
-                      (__len) : sizeof(void *));            \
-        else {                                              \
-                __pool = *(void **)(__pool);                \
-        }                                                   \
-        __p;                                                \
-})
-
-/*
- * Puts a memory area back to the corresponding pool.
- * Items are chained directly through a pointer that
- * is written in the beginning of the memory area, so
- * there's no need for any carrier cell. This implies
- * that each memory area is at least as big as one
- * pointer.
- */
-#define pool_free_to(__pool, __ptr)             \
-({                                              \
-        *(void **)(__ptr) = (void *)(__pool);   \
-        __pool = (void *)(__ptr);               \
-})
-
-/*
- * Returns a pointer to type <type> taken from the
- * pool <pool_type> or dynamically allocated. In the
- * first case, <pool_type> is updated to point to the
- * next element in the list.
- */
-#define pool_alloc(type)                                \
-({                                                      \
-        void *__p;                                      \
-        if ((__p = pool_##type) == NULL)                \
-                __p = malloc(sizeof_##type);            \
-        else {                                          \
-                pool_##type = *(void **)pool_##type;	\
-        }                                               \
-        __p;                                            \
-})
-
-/*
- * Puts a memory area back to the corresponding pool.
- * Items are chained directly through a pointer that
- * is written in the beginning of the memory area, so
- * there's no need for any carrier cell. This implies
- * that each memory area is at least as big as one
- * pointer.
- */
-#define pool_free(type, ptr)                            \
-({                                                      \
-        *(void **)ptr = (void *)pool_##type;            \
-        pool_##type = (void *)ptr;                      \
-})
-
-/*
- * This function destroys a pull by freeing it completely.
- * This should be called only under extreme circumstances.
- */
-static inline void pool_destroy(void **pool)
-{
-	void *temp, *next;
-	next = pool;
-	while (next) {
-		temp = next;
-		next = *(void **)temp;
-		free(temp);
-	}
-}
-
-#define sizeof_talloc   1000
-
-/*
-  measure the speed of hapx versus malloc
-*/
-static bool test_speed1(void)
-{
-        void **pool_talloc = NULL;
-	void *ctx = pool_alloc(talloc);
-	unsigned count;
-	const int loop = 1000;
-	int i;
-	struct timeval tv;
-
-	printf("test: speed [\nhaproxy-pool VS MALLOC SPEED 2\n]\n");
-
-	tv = timeval_current();
-	count = 0;
-	do {
-		void *p1, *p2, *p3;
-		for (i=0;i<loop;i++) {
-			p1 = pool_alloc_from(pool_talloc, 10 + loop % 100);
-			p2 = pool_alloc_from(pool_talloc, strlen("foo bar") + 1);
-			strcpy(p2, "foo bar");
-			p3 = pool_alloc_from(pool_talloc, 300);
-			pool_free_to(pool_talloc,p1);
-			pool_free_to(pool_talloc,p3);
-			pool_free_to(pool_talloc,p2);
-		}
-		count += 3 * loop;
-	} while (timeval_elapsed(&tv) < 5.0);
-
-	fprintf(stderr, "haproxy : %10.0f ops/sec\n", count/timeval_elapsed(&tv));
-
-        pool_destroy(pool_talloc);
-
-	tv = timeval_current();
-	count = 0;
-	do {
-		void *p1, *p2, *p3;
-		for (i=0;i<loop;i++) {
-			p1 = malloc(10 + loop % 100);
-			p2 = malloc(strlen("foo bar") + 1);
-			strcpy(p2, "foo bar");
-			p3 = malloc(300);
-			free(p1);
-			free(p2);
-			free(p3);
-		}
-		count += 3 * loop;
-	} while (timeval_elapsed(&tv) < 5.0);
-	fprintf(stderr, "malloc  : %10.0f ops/sec\n", count/timeval_elapsed(&tv));
-
-#ifdef USE_DLMALLOC
-	tv = timeval_current();
-	count = 0;
-	do {
-		void *p1, *p2, *p3;
-		for (i=0;i<loop;i++) {
-			p1 = dlmalloc(10 + loop % 100);
-			p2 = dlmalloc(strlen("foo bar") + 1);
-			strcpy(p2, "foo bar");
-			p3 = dlmalloc(300);
-			dlfree(p1);
-			dlfree(p2);
-			dlfree(p3);
-		}
-		count += 3 * loop;
-	} while (timeval_elapsed(&tv) < 5.0);
-	fprintf(stderr, "dlmalloc: %10.0f ops/sec\n", count/timeval_elapsed(&tv));
-#endif
-
-	printf("success: speed1\n");
-
-	return true;
-}
-
-int main(void)
-{
-	bool ret = test_speed1();
-	if (!ret)
-		return -1;
-	return 0;
-}
diff --git a/deps/haproxy-1.4.21/tests/testinet.c b/deps/haproxy-1.4.21/tests/testinet.c
deleted file mode 100644
index 2140115..0000000
--- a/deps/haproxy-1.4.21/tests/testinet.c
+++ /dev/null
@@ -1,27 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <string.h>
-#include <ctype.h>
-#include <sys/time.h>
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <netinet/tcp.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include <netdb.h>
-#include <fcntl.h>
-#include <errno.h>
-#include <signal.h>
-#include <stdarg.h>
-#include <sys/resource.h>
-#include <time.h>
-#include <regex.h>
-#include <syslog.h>
-
-
-main() {
-    printf("sizeof sockaddr=%d\n", sizeof(struct sockaddr));
-    printf("sizeof sockaddr_in=%d\n", sizeof(struct sockaddr_in));
-    printf("sizeof sockaddr_in6=%d\n", sizeof(struct sockaddr_in6));
-}
diff --git a/deps/haproxy-1.4.21/tests/uri_hash.c b/deps/haproxy-1.4.21/tests/uri_hash.c
deleted file mode 100644
index 0b5d755..0000000
--- a/deps/haproxy-1.4.21/tests/uri_hash.c
+++ /dev/null
@@ -1,377 +0,0 @@
-#include <stdio.h>
-#include <string.h>
-#include <arpa/inet.h>
-
-#define NSERV   10
-#define MAXLINE 1000
-
-char line[MAXLINE];
-
-int counts_gd1[NSERV][NSERV];
-static unsigned long hash_gd1(char *uri)
-{
-    unsigned long hash = 0;
-    int c;
-
-    while ((c = *uri++))
-        hash = c + (hash << 6) + (hash << 16) - hash;
-
-    return hash;
-}
-
-int counts_gd2[NSERV][NSERV];
-static unsigned long hash_gd2(char *uri)
-{
-    unsigned long hash = 0;
-    int c;
-
-    while ((c = *uri++)) {
-	if (c == '?' || c == '\n')
-	    break;
-        hash = c + (hash << 6) + (hash << 16) - hash;
-    }
-
-    return hash;
-}
-
-
-int counts_gd3[NSERV][NSERV];
-static unsigned long hash_gd3(char *uri)
-{
-    unsigned long hash = 0;
-    int c;
-
-    while ((c = *uri++)) {
-	if (c == '?' || c == '\n')
-	    break;
-        hash = c - (hash << 3) + (hash << 15) - hash;
-    }
-
-    return hash;
-}
-
-
-int counts_gd4[NSERV][NSERV];
-static unsigned long hash_gd4(char *uri)
-{
-    unsigned long hash = 0;
-    int c;
-
-    while ((c = *uri++)) {
-	if (c == '?' || c == '\n')
-	    break;
-        hash = hash + (hash << 6) - (hash << 15) - c;
-    }
-
-    return hash;
-}
-
-
-int counts_gd5[NSERV][NSERV];
-static unsigned long hash_gd5(char *uri)
-{
-    unsigned long hash = 0;
-    int c;
-
-    while ((c = *uri++)) {
-	if (c == '?' || c == '\n')
-	    break;
-        hash = hash + (hash << 2) - (hash << 19) - c;
-    }
-
-    return hash;
-}
-
-
-int counts_gd6[NSERV][NSERV];
-static unsigned long hash_gd6(char *uri)
-{
-    unsigned long hash = 0;
-    int c;
-
-    while ((c = *uri++)) {
-	if (c == '?' || c == '\n')
-	    break;
-        hash = hash + (hash << 2) - (hash << 22) - c;
-    }
-
-    return hash;
-}
-
-
-int counts_wt1[NSERV][NSERV];
-static unsigned long hash_wt1(int hsize, char *string) {
-    int bits;
-    unsigned long data, val;
-
-    bits = val = data = 0;
-    while (*string) {
-	if (*string == '?' || *string == '\n')
-	    break;
-        data |= ((unsigned long)(unsigned char)*string) << bits;
-        bits += 8;
-        while (bits >= hsize) {
-            val ^= data - (val >> hsize);
-            bits -= hsize;
-            data >>= hsize;
-        }
-        string++;
-    }
-    val ^= data;
-    while (val > ((1 << hsize) - 1)) {
-        val = (val & ((1 << hsize) - 1)) ^ (val >> hsize);
-    }
-    return val;
-}
-
-/*
- * efficient hash : no duplicate on the first 65536 values of 2 bytes.
- * less than 0.1% duplicates for the first 1.6 M values of 3 bytes.
- */
-int counts_wt2[NSERV][NSERV];
-typedef unsigned int u_int32_t;
-
-static inline u_int32_t shl32(u_int32_t i, int count) {
-	if (count == 32)
-		return 0;
-	return i << count;
-}
-
-static inline u_int32_t shr32(u_int32_t i, int count) {
-	if (count == 32)
-		return 0;
-	return i >> count;
-}
-
-static unsigned int rev32(unsigned int c) {
-	c = ((c & 0x0000FFFF) << 16)| ((c & 0xFFFF0000) >> 16);
-	c = ((c & 0x00FF00FF) << 8) | ((c & 0xFF00FF00) >> 8);
-	c = ((c & 0x0F0F0F0F) << 4) | ((c & 0xF0F0F0F0) >> 4);
-	c = ((c & 0x33333333) << 2) | ((c & 0xCCCCCCCC) >> 2);
-	c = ((c & 0x55555555) << 1) | ((c & 0xAAAAAAAA) >> 1);
-	return c;
-}
-
-int hash_wt2(const char *src, int len) {
-	unsigned int i = 0x3C964BA5; /* as many ones as zeroes */
-	unsigned int j;
-	unsigned int ih, il;
-	int bit;
-
-	while (len--) {
-		j = (unsigned char)*src++;
-		if (j == '?' || j == '\n')
-		    break;
-		bit = rev32(j - i);
-		bit = bit - (bit >> 3) + (bit >> 16) - j;
-
-		bit &= 0x1f;
-		ih = shr32(i, bit);
-		il = i & (shl32(1, bit) - 1);
-		i = shl32(il, 32-bit) - ih - ~j;
-	}
-	return i;
-}
-
-
-//typedef unsigned int uint32_t;
-//typedef unsigned short uint8_t;
-//typedef unsigned char uint16_t;
-
-/*
- * http://www.azillionmonkeys.com/qed/hash.html
- */
-#undef get16bits
-#if (defined(__GNUC__) && defined(__i386__)) || defined(__WATCOMC__) \
-  || defined(_MSC_VER) || defined (__BORLANDC__) || defined (__TURBOC__)
-#define get16bits(d) (*((const uint16_t *) (d)))
-#endif
-
-#if !defined (get16bits)
-#define get16bits(d) ((((uint32_t)(((const uint8_t *)(d))[1])) << 8)\
-                       +(uint32_t)(((const uint8_t *)(d))[0]) )
-#endif
-
-/*
- * This function has a hole of 11 unused bits in bytes 2 and 3 of each block of
- * 32 bits.
- */
-int counts_SuperFastHash[NSERV][NSERV];
-
-uint32_t SuperFastHash (const char * data, int len) {
-uint32_t hash = len, tmp;
-int rem;
-
-    if (len <= 0 || data == NULL) return 0;
-
-    rem = len & 3;
-    len >>= 2;
-
-    /* Main loop */
-    for (;len > 0; len--) {
-        hash  += get16bits (data);
-        tmp    = (get16bits (data+2) << 11) ^ hash;
-        hash   = (hash << 16) ^ tmp;
-        data  += 2*sizeof (uint16_t);
-        hash  += hash >> 11;
-    }
-
-    /* Handle end cases */
-    switch (rem) {
-        case 3: hash += get16bits (data);
-                hash ^= hash << 16;
-                hash ^= data[sizeof (uint16_t)] << 18;
-                hash += hash >> 11;
-                break;
-        case 2: hash += get16bits (data);
-                hash ^= hash << 11;
-                hash += hash >> 17;
-                break;
-        case 1: hash += *data;
-                hash ^= hash << 10;
-                hash += hash >> 1;
-    }
-
-    /* Force "avalanching" of final 127 bits */
-    hash ^= hash << 3;
-    hash += hash >> 5;
-    hash ^= hash << 4;
-    hash += hash >> 17;
-    hash ^= hash << 25;
-    hash += hash >> 6;
-
-    return hash;
-}
-
-/*
- * This variant uses all bits from the input block, and is about 15% faster.
- */
-int counts_SuperFastHash2[NSERV][NSERV];
-uint32_t SuperFastHash2 (const char * data, int len) {
-uint32_t hash = len, tmp;
-int rem;
-
-    if (len <= 0 || data == NULL) return 0;
-
-    rem = len & 3;
-    len >>= 2;
-
-    /* Main loop */
-    for (;len > 0; len--) {
-	register uint32_t next;
-	next   = get16bits(data+2);
-        hash  += get16bits(data);
-        tmp    = ((next << 11) | (next >> 21)) ^ hash;
-        hash   = (hash << 16) ^ tmp;
-        data  += 2*sizeof (uint16_t);
-        hash  += hash >> 11;
-    }
-
-    /* Handle end cases */
-    switch (rem) {
-        case 3: hash += get16bits (data);
-                hash ^= hash << 16;
-                hash ^= data[sizeof (uint16_t)] << 18;
-                hash += hash >> 11;
-                break;
-        case 2: hash += get16bits (data);
-                hash ^= hash << 11;
-                hash += hash >> 17;
-                break;
-        case 1: hash += *data;
-                hash ^= hash << 10;
-                hash += hash >> 1;
-    }
-
-    /* Force "avalanching" of final 127 bits */
-    hash ^= hash << 3;
-    hash += hash >> 5;
-    hash ^= hash << 4;
-    hash += hash >> 17;
-    hash ^= hash << 25;
-    hash += hash >> 6;
-
-    return hash;
-}
-
-/* len 4 for ipv4 and 16 for ipv6 */
-int counts_srv[NSERV][NSERV];
-unsigned int haproxy_server_hash(const char *addr, int len){
-  unsigned int h, l;
-  l = h = 0;
-
-  while ((l + sizeof (int)) <= len) {
-    h ^= ntohl(*(unsigned int *)(&addr[l]));
-    l += sizeof (int);
-  }
-  return h;
-}/* end haproxy_server_hash() */
-
-
-
-void count_hash_results(unsigned long hash, int counts[NSERV][NSERV]) {
-    int srv, nsrv;
-    
-    for (nsrv = 0; nsrv < NSERV; nsrv++) {
-	srv = hash % (nsrv + 1);
-	counts[nsrv][srv]++;
-    }
-}
-
-void dump_hash_results(char *name, int counts[NSERV][NSERV]) {
-    int srv, nsrv;
-
-    printf("%s:\n", name);
-    for (nsrv = 0; nsrv < NSERV; nsrv++) {
-	printf("%02d srv: ", nsrv+1);
-	for (srv = 0; srv <= nsrv; srv++) {
-	    //printf("%6d ", counts[nsrv][srv]);
-	    //printf("%3.1f ", (100.0*counts[nsrv][srv]) / (double)counts[0][0]);
-	    printf("%3.1f ", 100.0*(counts[nsrv][srv] - (double)counts[0][0]/(nsrv+1)) / (double)counts[0][0]);
-	}
-	printf("\n");
-    }
-    printf("\n");
-}
-
-int main() {
-    memset(counts_gd1, 0, sizeof(counts_gd1));
-    memset(counts_gd2, 0, sizeof(counts_gd2));
-    memset(counts_gd3, 0, sizeof(counts_gd3));
-    memset(counts_gd4, 0, sizeof(counts_gd4));
-    memset(counts_gd5, 0, sizeof(counts_gd5));
-    memset(counts_gd6, 0, sizeof(counts_gd6));
-    memset(counts_wt1, 0, sizeof(counts_wt1));
-    memset(counts_wt2, 0, sizeof(counts_wt2));
-    memset(counts_srv, 0, sizeof(counts_srv));
-    memset(counts_SuperFastHash, 0, sizeof(counts_SuperFastHash));
-    memset(counts_SuperFastHash2, 0, sizeof(counts_SuperFastHash2));
-
-    while (fgets(line, MAXLINE, stdin) != NULL) {
-	count_hash_results(hash_gd1(line), counts_gd1);
-	count_hash_results(hash_gd2(line), counts_gd2);
-	count_hash_results(hash_gd3(line), counts_gd3);
-	count_hash_results(hash_gd4(line), counts_gd4);
-	count_hash_results(hash_gd5(line), counts_gd5);
-	count_hash_results(hash_gd6(line), counts_gd6);
-	count_hash_results(hash_wt1(31, line), counts_wt1);
-	count_hash_results(hash_wt2(line, strlen(line)), counts_wt2);
-	count_hash_results(haproxy_server_hash(line, strlen(line)), counts_srv);
-	count_hash_results(SuperFastHash(line, strlen(line)), counts_SuperFastHash);
-	count_hash_results(SuperFastHash2(line, strlen(line)), counts_SuperFastHash2);
-    }
-
-    dump_hash_results("hash_gd1", counts_gd1);
-    dump_hash_results("hash_gd2", counts_gd2);
-    dump_hash_results("hash_gd3", counts_gd3);
-    dump_hash_results("hash_gd4", counts_gd4);
-    dump_hash_results("hash_gd5", counts_gd5);
-    dump_hash_results("hash_gd6", counts_gd6);
-    dump_hash_results("hash_wt1", counts_wt1);
-    dump_hash_results("hash_wt2", counts_wt2);
-    dump_hash_results("haproxy_server_hash", counts_srv);
-    dump_hash_results("SuperFastHash", counts_SuperFastHash);
-    dump_hash_results("SuperFastHash2", counts_SuperFastHash2);
-
-    return 0;
-}
diff --git a/docs/index.md b/docs/index.md
index e13a2fb..d497992 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -859,6 +859,15 @@ variable or the `--api-version=RANGE` option to each command.
 
 The rest of this section describes API changes in each version.
 
+
+## 8.1.0
+
+- This version should have no visible API changes, but updates a lot of
+  libraries that Cloudapi depends on, as well as the nodejs major version.
+  Visible differences with 8.0.0 are bugs, but it's possible some might have
+  crept through.
+
+
 ## 8.0.0
 
 - Instance/machine objects (from GetMachine, ListMachines) now has a `brand`
@@ -885,6 +894,7 @@ The rest of this section describes API changes in each version.
 - Network fabrics (software-defined networking) support.
   This allows the creation of virtual LANs and layer-three networks.
 
+
 ## 7.2.0
 
 - RBAC v1 has been made available on the CloudAPI interface. Accounts can create
diff --git a/etc/cloudapi.coal.cfg b/etc/cloudapi.coal.cfg
index 7b8968d..1773ada 100644
--- a/etc/cloudapi.coal.cfg
+++ b/etc/cloudapi.coal.cfg
@@ -17,7 +17,7 @@
          "*": true
     },
     "ufds": {
-        "url": "ldaps://10.99.99.18",
+        "url": "ldaps://ufds.coal.joyent.us",
         "bindDN": "cn=root",
         "bindPassword": "secret",
         "cache": {
@@ -45,31 +45,48 @@
         }
     },
     "wfapi": {
-        "url": "http://10.99.99.19"
-    },
-    "cnapi": {
-        "url": "http://10.99.99.22"
+        "url": "http://workflow.coal.joyent.us"
     },
     "vmapi": {
-        "url": "http://10.99.99.27"
+        "url": "http://vmapi.coal.joyent.us"
     },
-    "napi": {
-        "url": "http://10.99.99.10"
+    "cnapi": {
+        "url": "http://cnapi.coal.joyent.us"
     },
-    "imgapi": {
-        "url": "http://10.99.99.21"
+    "napi": {
+        "url": "http://napi.coal.joyent.us"
     },
     "fwapi": {
-        "url": "http://10.99.99.26"
+        "url": "http://fwapi.coal.joyent.us"
+    },
+    "imgapi": {
+        "url": "http://imgapi.coal.joyent.us"
     },
     "papi": {
-        "url": "http://10.99.99.29"
+        "url": "http://papi.coal.joyent.us"
     },
     "ca": {
-        "url": "http://10.99.99.30:23181"
+        "url": "http://ca.coal.joyent.us:23181"
+    },
+    "cueballHttpAgent": {
+        "resolvers": ["binder.coal.joyent.us"],
+        "initialDomains": [
+            "mahi.coal.joyent.us"
+        ],
+        "spares": 4,
+        "maximum": 10,
+        "recovery": {
+            "default": {
+                "timeout": 2000,
+                "maxTimeout": 8000,
+                "retries": 5,
+                "delay": 250,
+                "maxDelay": 1000
+            }
+        }
     },
     "mahi": {
-        "url": "http://10.99.99.33",
+        "url": "http://mahi.coal.joyent.us",
         "maxAuthCacheSize": 1000,
         "maxAuthCacheAgeMs": 300,
         "maxTranslationCacheSize": 1000,
@@ -82,7 +99,7 @@
     },
     "maxHttpSockets": 100,
     "datacenters": {
-        "coal": "http://127.0.0.1"
+        "coal": "https://cloudapi.coal.joyent.us"
     },
     "plugins": [
         {
diff --git a/etc/haproxy.cfg.in b/etc/haproxy.cfg.in
index f1d8156..0abd777 100644
--- a/etc/haproxy.cfg.in
+++ b/etc/haproxy.cfg.in
@@ -14,6 +14,7 @@ defaults
         option  redispatch
         option  abortonclose
         option  forwardfor
+        option  http-tunnel
         retries 1
         timeout queue   0
         timeout connect 2000
diff --git a/lib/app.js b/lib/app.js
index 319c2c4..344f1de 100644
--- a/lib/app.js
+++ b/lib/app.js
@@ -52,6 +52,7 @@ var networks = require('./networks');
 var audit = require('./audit');
 var auditLogger = require('./audit_logger');
 var rules = require('./rules');
+var tests = require('./tests');
 
 // Account users, roles and policies:
 var users = require('./users');
@@ -86,6 +87,7 @@ var sprintf = util.format;
 
 var userThrottle = throttle.getUserThrottle;
 var ipThrottle = throttle.getIpThrottle;
+var emptyThrottle = throttle.getEmptyThrottle;
 
 var MORAY_POLL = 5000; // in ms
 
@@ -353,36 +355,7 @@ module.exports = {
         var machineThrottle;
 
         config.name = 'Joyent Triton ' + version();
-        config.version = ['8.0.0', '7.3.0', '7.2.0', '7.1.0', '7.0.0'];
-        config.formatters = {
-            'text/html': function formatHTML(req, res, body) {
-                if (typeof (body) === 'string') {
-                    return body;
-                }
-
-                var html;
-                if (body instanceof Error) {
-                    html = sprintf(HTML_FMT, body.stack);
-                } else if (Buffer.isBuffer(body)) {
-                    html = sprintf(HTML_FMT, body.toString('base64'));
-                } else {
-                    html = sprintf(HTML_FMT, body.toString());
-                }
-
-                return html;
-            },
-            'text/css': function formatCSS(req, res, body) {
-                if (typeof (body) === 'string') {
-                    return body;
-                }
-
-                return '';
-            },
-
-            'image/png': function formatPNG(req, res, body) {
-                return body;
-            }
-        };
+        config.version = ['8.1.0', '8.0.0', '7.3.0', '7.2.0', '7.1.0', '7.0.0'];
 
         if (config.dc_maint_eta) {
             var d = new Date(config.dc_maint_eta);
@@ -651,10 +624,14 @@ module.exports = {
                 policies.mount(server, userThrottle(config, 'policies'),
                         config);
                 roles.mount(server, userThrottle(config, 'roles'), config);
-                resources.mount(server, userThrottle(config, 'resources'),
-                        config);
                 nics.mount(server, userThrottle(config, 'nics'));
                 mod_config.mount(server, userThrottle(config, 'config'));
+                resources.mount(server, userThrottle(config, 'resources'),
+                        config);
+
+                if (config.test) {
+                    tests.mount(server, emptyThrottle(), config);
+                }
 
                 server.on('after', auditLogger({
                     log: log.child({component: 'audit'})
diff --git a/lib/machines.js b/lib/machines.js
index 2e28682..e33c878 100644
--- a/lib/machines.js
+++ b/lib/machines.js
@@ -305,12 +305,18 @@ function getListOptions(req) {
     // Not implemented right now into VMAPI
     opts.offset = req.params.offset || 0;
 
-    // Copy in any and all tags
-    Object.keys(req.params).forEach(function (k) {
-        if (TAG_RE.test(k)) {
-            opts[k] = req.params[k];
-        }
-    });
+    // Copy in any and all tags.
+    // Beware that tag handling is unstable between restify 2/4/5, due to dot
+    // handling by restify's dependency, qs. If tags start failing on a restify
+    // upgrade, revert this if () to its original code. See ZAPI-744 for more
+    // details.
+    var tags = req.params.tag;
+    if (tags) {
+        Object.keys(tags).forEach(function (tag) {
+            opts['tag.' + tag] = tags[tag];
+        });
+    }
+
     // By default, VMAPI will return everything unless it's told to not
     // retrieve destroyed machines.
     if (!req.params.tombstone && !opts.state) {
@@ -795,17 +801,24 @@ function xorIfPresent(a, b) {
 function loadMachine(req, res, next) {
     var pathname = req.getUrl().pathname;
 
-    if (pathname === '/--ping') {
+    if (pathname === '/--ping' || !(/\/machines/.test(pathname))) {
         return next();
     }
 
     assert.ok(req.sdc);
 
     var customer = req.account.uuid;
-    if (!req.params.machine || !(/\/machines/.test(pathname))) {
+    var name = req.params.machine;
+
+    // set by resources.js, if a PUT with role tags is being done
+    if (req.params.resource_name === 'machines' && req.params.resource_id) {
+        name = name || req.params.resource_id;
+    }
+
+    if (!name) {
         return next();
     }
-    var name = req.params.machine;
+
     var machine;
 
     return vasync.pipeline({
diff --git a/lib/tests.js b/lib/tests.js
new file mode 100644
index 0000000..4bd177e
--- /dev/null
+++ b/lib/tests.js
@@ -0,0 +1,46 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * This file contains functions useful during the testing of Cloudapi. They
+ * are only active when the configuration has Cloudapi in testing mode.
+ */
+
+var assert = require('assert-plus');
+
+
+function throwException(req, res, next) {
+    // non-existent function invocation should throw exception
+    req.asdasdadasdasd();
+    next();
+}
+
+
+function mount(server, before, config) {
+    assert.object(server);
+    assert.ok(before);
+    assert.ok(config);
+
+    if (!config.test) {
+        return server;
+    }
+
+    server.get({
+        path: '/:account/tests/throw_exception',
+        name: 'ThrowException'
+    }, before, throwException);
+
+    return server;
+}
+
+
+module.exports = {
+    mount: mount
+};
diff --git a/lib/throttle.js b/lib/throttle.js
index 3de867e..e15e9a6 100644
--- a/lib/throttle.js
+++ b/lib/throttle.js
@@ -60,5 +60,9 @@ module.exports = {
         assert.string(name);
 
         return getThrottle('userThrottles', config, name);
+    },
+
+    getEmptyThrottle: function () {
+        return emptyThrottle;
     }
 };
diff --git a/package.json b/package.json
index 1d8fc06..0bf14a1 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
     "name": "cloudapi",
     "description": "SmartDataCenter CloudAPI",
-    "version": "8.0.3",
+    "version": "8.1.0",
     "author": "Joyent (joyent.com)",
     "private": true,
     "engines": {
@@ -13,26 +13,26 @@
         "url": "git+ssh://git@github.com:joyent/sdc-cloudapi.git"
     },
     "dependencies": {
-        "vasync": "1.4.3",
+        "vasync": "1.6.4",
         "filed": "0.0.7",
         "http-signature": "1.1.0",
         "mime": "1.2.7",
-        "libuuid": "0.1.2",
+        "libuuid": "0.2.1",
         "nopt": "2.0.0",
-        "restify": "git+https://github.com/mcavage/node-restify.git#0d7b4ba",
-        "bunyan": "0.22.1",
+        "restify": "4.1.1",
+        "bunyan": "1.8.1",
         "cueball": "1.1.2",
         "kang": "1.1.0",
-        "sdc-clients": "9.4.0",
-        "ufds": "1.1.3",
+        "sdc-clients": "10.0.0",
+        "ufds": "1.2.0",
         "semver": "2.2.1",
         "nodemailer": "0.3.29",
         "clone": "0.1.5",
         "assert-plus": "1.0.0",
         "asn1": "0.1.11",
         "ctype": "0.5.2",
-        "keyapi": "git+https://github.com/joyent/keyapi.git#c30dd2710ad2175095dc0e96479686fa774b8063",
-        "aperture": "git+https://github.com/joyent/node-aperture.git#016977",
+        "keyapi": "git+https://github.com/joyent/keyapi.git#e14b3d582e1d9d338b7082d61f34ba8d1bbc540a",
+        "aperture": "git+https://git@github.com:joyent/node-aperture.git#016977",
         "mahi": "2.0.1",
         "aperture-config": "git+https://github.com/joyent/aperture-config.git#master",
         "joyent-schemas": "git+https://github.com/joyent/schemas.git#caf3a226ed0707f5da897e1da151cc6d97fccda2",
@@ -41,7 +41,7 @@
     },
     "devDependencies": {
         "tape": "3.5.0",
-        "smartdc": "git+https://github.com/joyent/node-smartdc.git#adea68"
+        "smartdc": "8.1.0"
     },
     "sdcDependencies": {
         "imgapi": ">=2.1.0",
diff --git a/smf/manifests/haproxy.xml.in b/smf/manifests/haproxy.xml.in
index d2c9fec..ceb8e5d 100644
--- a/smf/manifests/haproxy.xml.in
+++ b/smf/manifests/haproxy.xml.in
@@ -11,7 +11,7 @@
 -->
 
 <service_bundle type="manifest" name="haproxy">
-    <service name="cloudapi/haproxy" type="service" version="1">
+    <service name="pkgsrc/haproxy" type="service" version="1">
 
 	<create_default_instance enabled="false" />
 	<single_instance />
@@ -39,7 +39,7 @@
 
 	<exec_method type="method"
 		     name="start"
-         exec="@@PREFIX@@/haproxy-1.4.21/haproxy -f @@PREFIX@@/etc/haproxy.cfg -D"
+         exec="/opt/local/sbin/haproxy -f @@PREFIX@@/etc/haproxy.cfg -D"
 		     timeout_seconds="30">
 	    <method_context working_directory="@@PREFIX@@">
 		<method_environment>
diff --git a/test/common.js b/test/common.js
index ac59440..9ea766a 100644
--- a/test/common.js
+++ b/test/common.js
@@ -23,7 +23,7 @@ var util = require('util');
 var fs = require('fs');
 var vasync = require('vasync');
 
-var UFDS = require('sdc-clients').UFDS;
+var UFDS = require('ufds');
 var VMAPI = require('sdc-clients').VMAPI;
 var CNAPI = require('sdc-clients').CNAPI;
 var NAPI = require('sdc-clients').NAPI;
diff --git a/test/tests.test.js b/test/tests.test.js
new file mode 100644
index 0000000..13d53e7
--- /dev/null
+++ b/test/tests.test.js
@@ -0,0 +1,64 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+var test = require('tape').test;
+var common = require('./common');
+
+
+// --- Globals
+
+
+var CLIENTS;
+var CLIENT;
+var SERVER;
+var TEST;
+
+
+// --- Tests
+
+
+test('setup', function (t) {
+    common.setup(function (_, clients, server) {
+        CLIENTS = clients;
+        CLIENT  = clients.user;
+        SERVER  = server;
+
+        TEST = common.getCfg().test;
+
+        t.end();
+    });
+});
+
+
+test('uncaughtException handler OK', function (t) {
+    if (!TEST) {
+        return t.end();
+    }
+
+    return CLIENT.get('/my/tests/throw_exception',
+            function (err, req, res, body) {
+        t.ok(err);
+        t.equal(res.statusCode, 500);
+
+        t.deepEqual(body, {
+            code: 'InternalError',
+            message: 'Internal Error'
+        });
+
+        t.end();
+    });
+});
+
+
+test('teardown', function (t) {
+    common.teardown(CLIENTS, SERVER, function () {
+        t.end();
+    });
+});
