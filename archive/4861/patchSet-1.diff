commit d5781a185f1506645584f2b9fde20c5ab66aeec5
Author: Cody Peter Mello <cody.mello@joyent.com>
Date:   2018-09-21T20:30:26+00:00 (1 year, 1 month ago)
    
    OS-7209 Copy minor upstream nawk(1) code changes

diff --git a/usr/src/cmd/awk/Makefile b/usr/src/cmd/awk/Makefile
index 3eb805c71a..8508c9aa21 100644
--- a/usr/src/cmd/awk/Makefile
+++ b/usr/src/cmd/awk/Makefile
@@ -29,8 +29,8 @@
 
 PROG= nawk
 
-OBJ1= b.o lib.o main.o parse.o proctab.o run.o tran.o
-OBJ2= awk.g.o awk.lx.o
+OBJ1= b.o lib.o main.o parse.o proctab.o run.o tran.o lex.o
+OBJ2= awk.g.o
 OBJS= $(OBJ2) $(OBJ1)
 SRCS= $(OBJ1:%.o=%.c)
 
@@ -54,11 +54,11 @@ CPPFLAGS += -D_FILE_OFFSET_BITS=64
 YFLAGS += -d
 LDLIBS += -lm
 LINTFLAGS += -u
-CLEANFILES= maketab proctab.c awk.g.c awk.lx.c y.tab.h
+CLEANFILES= maketab proctab.c awk.g.c y.tab.h
 
 .KEEP_STATE:
 
-all: $(PROG) 
+all: $(PROG)
 
 $(PROG): $(OBJS)
 	$(LINK.c) $(OBJS) -o $@ $(LDLIBS)
@@ -90,8 +90,6 @@ awk.g.c + y.tab.h: awk.g.y
 
 awk.g.o: awk.g.c
 
-awk.lx.c: awk.lx.l
-
 proctab.o: proctab.c
 	$(COMPILE.c) proctab.c
 	$(POST_PROCESS_O)
diff --git a/usr/src/cmd/awk/awk.g.y b/usr/src/cmd/awk/awk.g.y
index 21bc8b6dc8..2659d8d364 100644
--- a/usr/src/cmd/awk/awk.g.y
+++ b/usr/src/cmd/awk/awk.g.y
@@ -24,28 +24,22 @@
 /*
  * Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T. All Rights Reserved.
  */
 
-/*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
-/*	  All Rights Reserved  	*/
-
-%{
-#ident	"%Z%%M%	%I%	%E% SMI"	/* SVr4.0 2.10	*/
-%}
-
 %{
 #include "awk.h"
 int yywrap(void) { return(1); }
-#ifndef	DEBUG
-#	define	PUTS(x)
-#endif
-Node	*beginloc = 0, *endloc = 0;
+
+Node	*beginloc = 0;
+Node	*endloc = 0;
 int	infunc	= 0;	/* = 1 if in arglist or body of func */
-uchar	*curfname = 0;
+char	*curfname = 0;	/* current function name */
 Node	*arglist = 0;	/* list of args for current function */
 static void	setfname(Cell *);
 static int	constnode(Node *);
-static uchar	*strnode(Node *);
+static char	*strnode(Node *);
 static Node	*notnull();
 %}
 
@@ -53,7 +47,7 @@ static Node	*notnull();
 	Node	*p;
 	Cell	*cp;
 	int	i;
-	uchar	*s;
+	char	*s;
 }
 
 %token	<i>	FIRSTTOKEN	/* must be first */
@@ -63,7 +57,7 @@ static Node	*notnull();
 %token	<i>	MATCH NOTMATCH MATCHOP
 %token	<i>	FINAL DOT ALL CCL NCCL CHAR OR STAR QUEST PLUS
 %token	<i>	AND BOR APPEND EQ GE GT LE LT NE IN
-%token	<i>	ARG BLTIN BREAK CLOSE CONTINUE DELETE DO EXIT FOR FUNC 
+%token	<i>	ARG BLTIN BREAK CLOSE CONTINUE DELETE DO EXIT FOR FUNC
 %token	<i>	SUB GSUB IF INDEX LSUBSTR MATCHFCN NEXT
 %token	<i>	ADD MINUS MULT DIVIDE MOD
 %token	<i>	ASSIGN ASGNOP ADDEQ SUBEQ MULTEQ DIVEQ MODEQ POWEQ
@@ -89,7 +83,7 @@ static Node	*notnull();
 %left	AND
 %left	GETLINE
 %nonassoc APPEND EQ GE GT LE LT NE MATCHOP IN '|'
-%left	ARG BLTIN BREAK CALL CLOSE CONTINUE DELETE DO EXIT FOR FIELD FUNC 
+%left	ARG BLTIN BREAK CALL CLOSE CONTINUE DELETE DO EXIT FOR FIELD FUNC
 %left	GSUB IF INDEX LSUBSTR MATCHFCN NEXT NUMBER
 %left	PRINT PRINTF RETURN SPLIT SPRINTF STRING SUB SUBSTR
 %left	REGEXPR VAR VARNF IVAR WHILE '('
@@ -107,7 +101,7 @@ static Node	*notnull();
 program:
 	  pas	{ if (errorflag==0)
 			winner = (Node *)stat3(PROGRAM, beginloc, $1, endloc); }
-	| error	{ yyclearin; bracecheck(); ERROR "bailing out" SYNTAX; }
+	| error	{ yyclearin; bracecheck(); SYNTAX("bailing out"); }
 	;
 
 and:
@@ -202,13 +196,13 @@ pa_stats:
 
 patlist:
 	  pattern
-	| patlist comma pattern	{ $$ = linkum($1, $3); }
+	| patlist comma pattern		{ $$ = linkum($1, $3); }
 	;
 
 ppattern:
 	  var ASGNOP ppattern		{ $$ = op2($2, $1, $3); }
 	| ppattern '?' ppattern ':' ppattern %prec '?'
-	 	{ $$ = op3(CONDEXPR, notnull($1), $3, $5); }
+		{ $$ = op3(CONDEXPR, notnull($1), $3, $5); }
 	| ppattern bor ppattern %prec BOR
 		{ $$ = op2(BOR, notnull($1), notnull($3)); }
 	| ppattern and ppattern %prec AND
@@ -232,13 +226,13 @@ ppattern:
 pattern:
 	  var ASGNOP pattern		{ $$ = op2($2, $1, $3); }
 	| pattern '?' pattern ':' pattern %prec '?'
-	 	{ $$ = op3(CONDEXPR, notnull($1), $3, $5); }
+		{ $$ = op3(CONDEXPR, notnull($1), $3, $5); }
 	| pattern bor pattern %prec BOR
 		{ $$ = op2(BOR, notnull($1), notnull($3)); }
 	| pattern and pattern %prec AND
 		{ $$ = op2(AND, notnull($1), notnull($3)); }
 	| NOT pattern
-		{ $$ = op1(NOT, op2(NE,$2,valtonode(lookup((uchar *)"$zero&null",symtab),CCON))); }
+		{ $$ = op1(NOT, op2(NE,$2,celltonode(lookup("$zero&null",symtab),CCON))); }
 	| pattern EQ pattern		{ $$ = op2($2, $1, $3); }
 	| pattern GE pattern		{ $$ = op2($2, $1, $3); }
 	| pattern GT pattern		{ $$ = op2($2, $1, $3); }
@@ -269,6 +263,7 @@ plist:
 pplist:
 	  ppattern
 	| pplist comma ppattern		{ $$ = linkum($1, $3); }
+	;
 
 prarg:
 	  /* empty */			{ $$ = rectonode(); }
@@ -302,13 +297,14 @@ simple_stmt:
 	| print prarg GT term		{ $$ = stat3($1, $2, (Node *) $3, $4); }
 	| print prarg			{ $$ = stat3($1, $2, NIL, NIL); }
 	| DELETE varname '[' patlist ']' { $$ = stat2(DELETE, makearr($2), $4); }
-	| DELETE varname		{ yyclearin; ERROR "you can only delete array[element]" SYNTAX; $$ = stat1(DELETE, $2); }
+	| DELETE varname		{ yyclearin; SYNTAX("you can only delete array[element]"); $$ = stat1(DELETE, $2); }
 	| pattern			{ $$ = exptostat($1); }
-	| error				{ yyclearin; ERROR "illegal statement" SYNTAX; }
+	| error				{ yyclearin; SYNTAX("illegal statement"); }
 	;
 
 st:
-	  nl | ';' opt_nl
+	  nl
+	| ';' opt_nl
 	;
 
 stmt:
@@ -324,7 +320,7 @@ stmt:
 	| if stmt		{ $$ = stat3(IF, $1, $2, NIL); }
 	| lbrace stmtlist rbrace { $$ = $2; }
 	| NEXT st	{ if (infunc)
-				ERROR "next is illegal inside a function" SYNTAX;
+				SYNTAX("next is illegal inside a function");
 			  $$ = stat1(NEXT, NIL); }
 	| RETURN pattern st	{ $$ = stat1(RETURN, $2); }
 	| RETURN st		{ $$ = stat1(RETURN, NIL); }
@@ -343,7 +339,8 @@ subop:
 	;
 
 term:
-	  term '+' term			{ $$ = op2(ADD, $1, $3); }
+	  term '/' ASGNOP term		{ $$ = op2(DIVEQ, $1, $4); }
+	| term '+' term			{ $$ = op2(ADD, $1, $3); }
 	| term '-' term			{ $$ = op2(MINUS, $1, $3); }
 	| term '*' term			{ $$ = op2(MULT, $1, $3); }
 	| term '/' term			{ $$ = op2(DIVIDE, $1, $3); }
@@ -351,23 +348,23 @@ term:
 	| term POWER term		{ $$ = op2(POWER, $1, $3); }
 	| '-' term %prec UMINUS		{ $$ = op1(UMINUS, $2); }
 	| '+' term %prec UMINUS		{ $$ = $2; }
-	| BLTIN '(' ')'			{ $$ = op2(BLTIN, (Node *) $1, rectonode()); }
-	| BLTIN '(' patlist ')'		{ $$ = op2(BLTIN, (Node *) $1, $3); }
-	| BLTIN				{ $$ = op2(BLTIN, (Node *) $1, rectonode()); }
-	| CALL '(' ')'			{ $$ = op2(CALL, valtonode($1,CVAR), NIL); }
-	| CALL '(' patlist ')'		{ $$ = op2(CALL, valtonode($1,CVAR), $3); }
+	| BLTIN '(' ')'			{ $$ = op2(BLTIN, itonp($1), rectonode()); }
+	| BLTIN '(' patlist ')'		{ $$ = op2(BLTIN, itonp($1), $3); }
+	| BLTIN				{ $$ = op2(BLTIN, itonp($1), rectonode()); }
+	| CALL '(' ')'			{ $$ = op2(CALL, celltonode($1,CVAR), NIL); }
+	| CALL '(' patlist ')'		{ $$ = op2(CALL, celltonode($1,CVAR), $3); }
 	| DECR var			{ $$ = op1(PREDECR, $2); }
 	| INCR var			{ $$ = op1(PREINCR, $2); }
 	| var DECR			{ $$ = op1(POSTDECR, $1); }
 	| var INCR			{ $$ = op1(POSTINCR, $1); }
-	| GETLINE var LT term		{ $$ = op3(GETLINE, $2, (Node *)$3, $4); }
-	| GETLINE LT term		{ $$ = op3(GETLINE, NIL, (Node *)$2, $3); }
+	| GETLINE var LT term		{ $$ = op3(GETLINE, $2, itonp($3), $4); }
+	| GETLINE LT term		{ $$ = op3(GETLINE, NIL, itonp($2), $3); }
 	| GETLINE var			{ $$ = op3(GETLINE, $2, NIL, NIL); }
 	| GETLINE			{ $$ = op3(GETLINE, NIL, NIL, NIL); }
 	| INDEX '(' pattern comma pattern ')'
 		{ $$ = op2(INDEX, $3, $5); }
 	| INDEX '(' pattern comma reg_expr ')'
-		{ ERROR "index() doesn't permit regular expressions" SYNTAX;
+		{ SYNTAX("index() doesn't permit regular expressions");
 		  $$ = op2(INDEX, $3, (Node*)$5); }
 	| '(' pattern ')'		{ $$ = $2; }
 	| MATCHFCN '(' pattern comma reg_expr ')'
@@ -377,7 +374,7 @@ term:
 			$$ = op3(MATCHFCN, NIL, $3, (Node*)makedfa(strnode($5), 1));
 		  else
 			$$ = op3(MATCHFCN, (Node *)1, $3, $5); }
-	| NUMBER			{ $$ = valtonode($1, CCON); }
+	| NUMBER			{ $$ = celltonode($1, CCON); }
 	| SPLIT '(' pattern comma varname comma pattern ')'     /* string */
 		{ $$ = op4(SPLIT, $3, makearr($5), $7, (Node*)STRING); }
 	| SPLIT '(' pattern comma varname comma reg_expr ')'    /* const /regexp/ */
@@ -385,7 +382,7 @@ term:
 	| SPLIT '(' pattern comma varname ')'
 		{ $$ = op4(SPLIT, $3, makearr($5), NIL, (Node*)STRING); }  /* default */
 	| SPRINTF '(' patlist ')'	{ $$ = op1($1, $3); }
-	| STRING	 		{ $$ = valtonode($1, CCON); }
+	| STRING			{ $$ = celltonode($1, CCON); }
 	| subop '(' reg_expr comma pattern ')'
 		{ $$ = op4($1, NIL, (Node*)makedfa($3, 1), $5, rectonode()); }
 	| subop '(' pattern comma pattern ')'
@@ -410,20 +407,20 @@ term:
 var:
 	  varname
 	| varname '[' patlist ']'	{ $$ = op2(ARRAY, makearr($1), $3); }
-	| FIELD				{ $$ = valtonode($1, CFLD); }
-	| IVAR				{ $$ = op1(INDIRECT, valtonode($1, CVAR)); }
-	| INDIRECT term	 		{ $$ = op1(INDIRECT, $2); }
-	;	
+	| FIELD				{ $$ = celltonode($1, CFLD); }
+	| IVAR				{ $$ = op1(INDIRECT, celltonode($1, CVAR)); }
+	| INDIRECT term			{ $$ = op1(INDIRECT, $2); }
+	;
 
 varlist:
 	  /* nothing */		{ arglist = $$ = 0; }
-	| VAR			{ arglist = $$ = valtonode($1,CVAR); }
-	| varlist comma VAR	{ arglist = $$ = linkum($1,valtonode($3,CVAR)); }
+	| VAR			{ arglist = $$ = celltonode($1,CVAR); }
+	| varlist comma VAR	{ arglist = $$ = linkum($1,celltonode($3,CVAR)); }
 	;
 
 varname:
-	  VAR			{ $$ = valtonode($1, CVAR); }
-	| ARG 			{ $$ = op1(ARG, (Node *) $1); }
+	  VAR			{ $$ = celltonode($1, CVAR); }
+	| ARG			{ $$ = op1(ARG, itonp($1)); }
 	| VARNF			{ $$ = op1(VARNF, (Node *) $1); }
 	;
 
@@ -438,20 +435,19 @@ static void
 setfname(Cell *p)
 {
 	if (isarr(p))
-		ERROR "%s is an array, not a function", p->nval SYNTAX;
-	else if (isfunc(p))
-		ERROR "you can't define function %s more than once", p->nval SYNTAX;
+		SYNTAX("%s is an array, not a function", p->nval);
+	else if (isfcn(p))
+		SYNTAX("you can't define function %s more than once", p->nval);
 	curfname = p->nval;
 }
 
-
 static int
 constnode(Node *p)
 {
-	return p->ntype == NVALUE && ((Cell *) (p->narg[0]))->csub == CCON;
+	return isvalue(p) && ((Cell *) (p->narg[0]))->csub == CCON;
 }
 
-static uchar *
+static char *
 strnode(Node *p)
 {
 	return ((Cell *)(p->narg[0]))->sval;
diff --git a/usr/src/cmd/awk/awk.h b/usr/src/cmd/awk/awk.h
index 987028fea2..e9c58f7cb3 100644
--- a/usr/src/cmd/awk/awk.h
+++ b/usr/src/cmd/awk/awk.h
@@ -21,11 +21,9 @@
 
 /*
  * Copyright (c) 1989, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T. All Rights Reserved.
  */
 
-/*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
-/*	  All Rights Reserved  	*/
-
 #ifndef AWK_H
 #define	AWK_H
 
@@ -38,10 +36,16 @@
 #include <limits.h>
 
 typedef double	Awkfloat;
+
+/* unsigned char is more trouble than it's worth */
+
+typedef	unsigned char uschar;
 typedef	unsigned char uchar;
 
-#define	xfree(a)	{ if ((a) != NULL) { free(a); a = NULL; } }
+#define	xfree(a)	{ if ((a) != NULL) { free((void *)(a)); (a) = NULL; } }
 
+/* guaranteed non-null for dprintf */
+#define	NN(p)	((p) ? (p) : "(null)")
 #define	DEBUG
 #ifdef	DEBUG
 			/* uses have to be doubly parenthesized */
@@ -50,18 +54,6 @@ typedef	unsigned char uchar;
 #define	dprintf(x)
 #endif
 
-extern	char	errbuf[200];
-extern	void	error(int, char *);
-#define	ERROR	(void) snprintf(errbuf, sizeof (errbuf),
-/*CSTYLED*/
-#define	FATAL	), error(1, errbuf)
-/*CSTYLED*/
-#define	WARNING	), error(0, errbuf)
-/*CSTYLED*/
-#define	SYNTAX	), yyerror(errbuf)
-/*CSTYLED*/
-#define	CONT	)
-
 extern int	compile_time;	/* 1 if compiling, 0 if running */
 
 #define	FLD_INCR	64
@@ -71,42 +63,42 @@ extern int	compile_time;	/* 1 if compiling, 0 if running */
 #define	expand_buf(p, n, r)	\
 	if (*(n) == 0 || (r) >= (*(n) - 1)) r_expand_buf(p, n, r)
 
-extern uchar	**FS;
-extern uchar	**RS;
-extern uchar	**ORS;
-extern uchar	**OFS;
-extern uchar	**OFMT;
+extern char	**FS;
+extern char	**RS;
+extern char	**ORS;
+extern char	**OFS;
+extern char	**OFMT;
 extern Awkfloat *NR;
 extern Awkfloat *FNR;
 extern Awkfloat *NF;
-extern uchar	**FILENAME;
-extern uchar	**SUBSEP;
+extern char	**FILENAME;
+extern char	**SUBSEP;
 extern Awkfloat *RSTART;
 extern Awkfloat *RLENGTH;
 
-extern uchar	*record;
-extern size_t	record_size;
-extern int	errorflag;
+extern char	*record;	/* points to $0 */
+extern size_t	recsize;
+extern int	errorflag;	/* 1 if error has occurred */
 extern int	donefld;	/* 1 if record broken into fields */
 extern int	donerec;	/* 1 if record is valid (no fld has changed */
 
-extern	uchar	*patbeg;	/* beginning of pattern matched */
-extern	int	patlen;		/* length.  set in b.c */
+extern	char	*patbeg;	/* beginning of pattern matched */
+extern	int	patlen;		/* length of pattern matched. set in b.c */
 
 /* Cell:  all information about a variable or constant */
 
 typedef struct Cell {
-	uchar	ctype;		/* OCELL, OBOOL, OJUMP, etc. */
-	uchar	csub;		/* CCON, CTEMP, CFLD, etc. */
-	uchar	*nval;		/* name, for variables only */
-	uchar	*sval;		/* string value */
+	uschar	ctype;		/* OCELL, OBOOL, OJUMP, etc. */
+	uschar	csub;		/* CCON, CTEMP, CFLD, etc. */
+	char	*nval;		/* name, for variables only */
+	char	*sval;		/* string value */
 	Awkfloat fval;		/* value as number */
 	unsigned tval;
 		/* type info: STR|NUM|ARR|FCN|FLD|CON|DONTFREE */
 	struct Cell *cnext;	/* ptr to next if chained */
 } Cell;
 
-typedef struct {		/* symbol table array */
+typedef struct Array {		/* symbol table array */
 	int	nelem;		/* elements in table right now */
 	int	size;		/* size of tab */
 	Cell	**tab;		/* hash table pointers */
@@ -114,8 +106,9 @@ typedef struct {		/* symbol table array */
 
 #define	NSYMTAB	50	/* initial size of a symbol table */
 extern Array	*symtab, *makesymtab(int);
-extern Cell	*setsymtab(uchar *, uchar *, Awkfloat, unsigned int, Array *);
-extern Cell	*lookup(uchar *, Array *);
+extern Cell	*setsymtab(const char *, const char *, Awkfloat,
+		    unsigned int, Array *);
+extern Cell	*lookup(const char *, Array *);
 
 extern Cell	*recloc;	/* location of input record */
 extern Cell	*nrloc;		/* NR */
@@ -136,9 +129,15 @@ extern Cell	*rlengthloc;	/* RLENGTH */
 
 #define	freeable(p)	(!((p)->tval & DONTFREE))
 
-extern Awkfloat setfval(Cell *, Awkfloat), getfval(Cell *), r_getfval(Cell *);
-extern uchar	*setsval(Cell *, uchar *), *getsval(Cell *), *r_getsval(Cell *);
-extern uchar	*tostring(uchar *), *tokname(int), *qstring(uchar *, int);
+extern Awkfloat	setfval(Cell *, Awkfloat);
+extern Awkfloat	getfval(Cell *);
+extern Awkfloat	r_getfval(Cell *);
+extern char	*setsval(Cell *, const char *);
+extern char	*getsval(Cell *);
+extern char	*r_getsval(Cell *);
+extern char	*tostring(const char *);
+extern char	*tokname(int);
+extern char	*qstring(const char *, int);
 
 #define	getfval(p)	\
 	(((p)->tval & (ARR|FLD|REC|NUM)) == NUM ? (p)->fval : r_getfval(p))
@@ -165,9 +164,9 @@ extern uchar	*tostring(uchar *), *tokname(int), *qstring(uchar *, int);
 typedef struct Node {
 	int	ntype;
 	struct	Node *nnext;
-	off_t lineno;
+	off_t	lineno;
 	int	nobj;
-	struct Node *narg[1];
+	struct	Node *narg[1];
 		/* variable: actual size set by calling malloc */
 } Node;
 
@@ -190,6 +189,7 @@ extern Node	*nullnode;
 #define	CNAME	3
 #define	CVAR	2
 #define	CFLD	1
+#define	CUNK	0
 
 /* bool subtypes */
 #define	BTRUE	11
@@ -210,7 +210,7 @@ extern Node	*nullnode;
 
 extern	Cell	*(*proctab[])(Node **, int);
 extern	Cell	*nullproc(Node **, int);
-extern	int	pairstack[], paircnt;
+extern	int	*pairstack, paircnt;
 
 extern	Node	*stat1(int, Node *), *stat2(int, Node *, Node *);
 extern	Node	*stat3(int, Node *, Node *, Node *);
@@ -219,7 +219,7 @@ extern	Node	*pa2stat(Node *, Node *, Node *);
 extern	Node	*op1(int, Node *), *op2(int, Node *, Node *);
 extern	Node	*op3(int, Node *, Node *, Node *);
 extern	Node	*op4(int, Node *, Node *, Node *, Node *);
-extern	Node	*linkum(Node *, Node *), *valtonode(Cell *, int);
+extern	Node	*linkum(Node *, Node *), *celltonode(Cell *, int);
 extern	Node	*rectonode(void), *exptostat(Node *);
 extern	Node	*makearr(Node *);
 
@@ -233,10 +233,12 @@ extern	Node	*makearr(Node *);
 #define	iscont(n)	((n)->csub == JCONT)
 #define	isnext(n)	((n)->csub == JNEXT)
 #define	isret(n)	((n)->csub == JRET)
+#define	isrec(n)	((n)->tval & REC)
+#define	isfld(n)	((n)->tval & FLD)
 #define	isstr(n)	((n)->tval & STR)
 #define	isnum(n)	((n)->tval & NUM)
 #define	isarr(n)	((n)->tval & ARR)
-#define	isfunc(n)	((n)->tval & FCN)
+#define	isfcn(n)	((n)->tval & FCN)
 #define	istrue(n)	((n)->csub == BTRUE)
 #define	istemp(n)	((n)->csub == CTEMP)
 
@@ -250,70 +252,90 @@ typedef struct rrow {
 } rrow;
 
 typedef struct fa {
-	uchar	*restr;
+	uschar	gototab[NSTATES][NCHARS];
+	uschar	out[NSTATES];
+	uschar	*restr;
+	int	*posns[NSTATES];
 	int	anchor;
 	int	use;
-	uchar	gototab[NSTATES][NCHARS];
-	int	*posns[NSTATES];
-	uchar	out[NSTATES];
 	int	initstat;
 	int	curstat;
 	int	accept;
 	int	reset;
+	/* re is variable: actual size set by calling malloc */
 	struct	rrow re[1];
 } fa;
 
+/* lex.c */
+extern	int	yylex(void);
+extern	void	startreg(void);
+extern	int	input(void);
+extern	void	unput(int);
+extern	void	unputstr(const char *);
+extern	int	yylook(void);
+extern	int	yyback(int *, int);
+extern	int	yyinput(void);
+
+/* parse.c */
+extern	int	ptoi(void *);
+extern	Node	*itonp(int);
+extern	int	isarg(const char *);
+
 /* b.c */
-extern	fa	*makedfa(uchar *, int);
-extern	int	nematch(fa *, uchar *);
-extern	int	match(fa *, uchar *);
-extern	int	pmatch(fa *, uchar *);
+extern	fa	*makedfa(const char *, int);
+extern	int	nematch(fa *, const char *);
+extern	int	match(fa *, const char *);
+extern	int	pmatch(fa *, const char *);
 
 /* lib.c */
-extern	int	isclvar(uchar *);
-extern	int	is_number(uchar *);
-extern	void	setclvar(uchar *);
-extern	int	readrec(uchar **, size_t *, FILE *);
+
+extern	void	SYNTAX(const char *, ...);
+extern	void	FATAL(const char *, ...) __attribute__((__noreturn__));
+extern	void	WARNING(const char *, ...);
+extern	void	error(void);
+
+extern	int	isclvar(const char *);
+extern	int	is_number(const char *);
+extern	void	setclvar(char *);
+extern	int	readrec(char **, size_t *, FILE *);
 extern	void	bracecheck(void);
 extern	void	syminit(void);
-extern	void	yyerror(char *);
+extern	void	yyerror(const char *);
 extern	void	fldbld(void);
 extern	void	recbld(void);
-extern	int	getrec(uchar **, size_t *);
+extern	int	getrec(char **, size_t *);
 extern	Cell	*fieldadr(int);
 extern	void	newfld(int);
 extern	Cell	*getfld(int);
 extern	int	fldidx(Cell *);
-extern	double	errcheck(double, char *);
+extern	double	errcheck(double, const char *);
 extern	void	fpecatch(int);
-extern	void	init_buf(uchar **, size_t *, size_t);
-extern	void	adjust_buf(uchar **, size_t);
-extern	void	r_expand_buf(uchar **, size_t *, size_t);
-
-extern	int	donefld;
-extern	int	donerec;
-extern	uchar	*record;
-extern	size_t	record_size;
+extern	void	init_buf(char **, size_t *, size_t);
+extern	void	adjust_buf(char **, size_t);
+extern	void	r_expand_buf(char **, size_t *, size_t);
 
 /* main.c */
 extern	int	dbg;
-extern	uchar	*cmdname;
-extern	uchar	*lexprog;
+extern	char	*lexprog;
 extern	int	compile_time;
 extern	char	radixpoint;
+extern	char	*cursource(void);
+extern	int	pgetc(void);
 
 /* tran.c */
 extern	void	syminit(void);
-extern	void	arginit(int, uchar **);
-extern	void	envinit(uchar **);
+extern	void	arginit(int, char **);
+extern	void	envinit(char **);
 extern	void	freesymtab(Cell *);
-extern	void	freeelem(Cell *, uchar *);
-extern	void	funnyvar(Cell *, char *);
-extern	int	hash(uchar *, int);
+extern	void	freeelem(Cell *, const char *);
+extern	void	funnyvar(Cell *, const char *);
+extern	int	hash(const char *, int);
 extern	Awkfloat *ARGC;
 
 /* run.c */
-extern	void	run(Node *);
+extern	void		run(Node *);
+extern	int		adjbuf(char **pb, size_t *sz, size_t min, size_t q,
+			    char **pbp, const char *what);
 
 extern	int	paircnt;
 extern	Node	*winner;
@@ -336,7 +358,7 @@ extern Cell *substr(Node **, int);
 extern Cell *sub(Node **, int);
 extern Cell *gsub(Node **, int);
 extern Cell *sindex(Node **, int);
-extern Cell *a_sprintf(Node **, int);
+extern Cell *awksprintf(Node **, int);
 extern Cell *arith(Node **, int);
 extern Cell *incrdecr(Node **, int);
 extern Cell *cat(Node **, int);
@@ -344,10 +366,10 @@ extern Cell *pastat(Node **, int);
 extern Cell *dopa2(Node **, int);
 extern Cell *matchop(Node **, int);
 extern Cell *intest(Node **, int);
-extern Cell *aprintf(Node **, int);
-extern Cell *print(Node **, int);
+extern Cell *awkprintf(Node **, int);
+extern Cell *printstat(Node **, int);
 extern Cell *closefile(Node **, int);
-extern Cell *delete(Node **, int);
+extern Cell *awkdelete(Node **, int);
 extern Cell *split(Node **, int);
 extern Cell *assign(Node **, int);
 extern Cell *condexpr(Node **, int);
@@ -361,6 +383,6 @@ extern Cell *bltin(Node **, int);
 extern Cell *call(Node **, int);
 extern Cell *arg(Node **, int);
 extern Cell *getnf(Node **, int);
-extern Cell *getaline(Node **, int);
+extern Cell *awkgetline(Node **, int);
 
 #endif /* AWK_H */
diff --git a/usr/src/cmd/awk/awk.lx.l b/usr/src/cmd/awk/awk.lx.l
deleted file mode 100644
index a7e8185832..0000000000
--- a/usr/src/cmd/awk/awk.lx.l
+++ /dev/null
@@ -1,306 +0,0 @@
-%{
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License, Version 1.0 only
- * (the "License").  You may not use this file except in compliance
- * with the License.
- *
- * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
- * or http://www.opensolaris.org/os/licensing.
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- */
-
-/*
- * Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
- * Use is subject to license terms.
- */
-
-/*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
-/*	  All Rights Reserved  	*/
-%}
-
-%{
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-%}
-
-%Start A str sc reg comment
-
-%{
-
-#include	<sys/types.h>
-#include	"awk.h"
-#include	"y.tab.h"
-
-#undef	input	/* defeat lex */
-#undef	unput
-
-static void unput(int);
-static void unputstr(char *);
-
-extern YYSTYPE	yylval;
-extern int	infunc;
-
-off_t	lineno	= 1;
-int	bracecnt = 0;
-int	brackcnt  = 0;
-int	parencnt = 0;
-#define DEBUG
-#ifdef	DEBUG
-#	define	RET(x)	{if(dbg)printf("lex %s [%s]\n", tokname(x), yytext); return(x); }
-#else
-#	define	RET(x)	return(x)
-#endif
-
-/*
- * The standards (SUSV2) requires that Record size be atleast LINE_MAX.
- * LINE_MAX is a standard variable defined in limits.h.
- * Though nawk is not standards compliant, we let RECSIZE
- * grow with LINE_MAX instead of the magic number 1024.
- */
-#define	CBUFLEN	(3 * LINE_MAX)
-
-#define	CADD	cbuf[clen++] = yytext[0]; \
-		if (clen >= CBUFLEN-1) { \
-			ERROR "string/reg expr %.10s... too long", cbuf SYNTAX; \
-			BEGIN A; \
-		}
-
-static uchar	cbuf[CBUFLEN];
-static uchar	*s;
-static int	clen, cflag;
-%}
-
-A	[a-zA-Z_]
-B	[a-zA-Z0-9_]
-D	[0-9]
-O	[0-7]
-H	[0-9a-fA-F]
-WS	[ \t]
-
-%%
-	switch (yybgin-yysvec-1) {	/* witchcraft */
-	case 0:
-		BEGIN A;
-		break;
-	case sc:
-		BEGIN A;
-		RET('}');
-	}
-
-<A>\n		{ lineno++; RET(NL); }
-<A>#.*		{ ; }	/* strip comments */
-<A>{WS}+	{ ; }
-<A>;		{ RET(';'); }
-
-<A>"\\"\n	{ lineno++; }
-<A>BEGIN	{ RET(XBEGIN); }
-<A>END		{ RET(XEND); }
-<A>func(tion)?	{ if (infunc) ERROR "illegal nested function" SYNTAX; RET(FUNC); }
-<A>return	{ if (!infunc) ERROR "return not in function" SYNTAX; RET(RETURN); }
-<A>"&&"		{ RET(AND); }
-<A>"||"		{ RET(BOR); }
-<A>"!"		{ RET(NOT); }
-<A>"!="		{ yylval.i = NE; RET(NE); }
-<A>"~"		{ yylval.i = MATCH; RET(MATCHOP); }
-<A>"!~"		{ yylval.i = NOTMATCH; RET(MATCHOP); }
-<A>"<"		{ yylval.i = LT; RET(LT); }
-<A>"<="		{ yylval.i = LE; RET(LE); }
-<A>"=="		{ yylval.i = EQ; RET(EQ); }
-<A>">="		{ yylval.i = GE; RET(GE); }
-<A>">"		{ yylval.i = GT; RET(GT); }
-<A>">>"		{ yylval.i = APPEND; RET(APPEND); }
-<A>"++"		{ yylval.i = INCR; RET(INCR); }
-<A>"--"		{ yylval.i = DECR; RET(DECR); }
-<A>"+="		{ yylval.i = ADDEQ; RET(ASGNOP); }
-<A>"-="		{ yylval.i = SUBEQ; RET(ASGNOP); }
-<A>"*="		{ yylval.i = MULTEQ; RET(ASGNOP); }
-<A>"/="		{ yylval.i = DIVEQ; RET(ASGNOP); }
-<A>"%="		{ yylval.i = MODEQ; RET(ASGNOP); }
-<A>"^="		{ yylval.i = POWEQ; RET(ASGNOP); }
-<A>"**="	{ yylval.i = POWEQ; RET(ASGNOP); }
-<A>"="		{ yylval.i = ASSIGN; RET(ASGNOP); }
-<A>"**"		{ RET(POWER); }
-<A>"^"		{ RET(POWER); }
-
-<A>"$"{D}+	{ yylval.cp = fieldadr(atoi(yytext+1)); RET(FIELD); }
-<A>"$NF"	{ unputstr("(NF)"); return(INDIRECT); }
-<A>"$"{A}{B}*	{ int c, n;
-		  c = input(); unput(c);
-		  if (c == '(' || c == '[' || infunc && (n=isarg(yytext+1)) >= 0) {
-			unputstr(yytext+1);
-			return(INDIRECT);
-		  } else {
-			yylval.cp = setsymtab((uchar *)yytext+1,
-				(uchar *)"",0.0,STR|NUM,symtab);
-			RET(IVAR);
-		  }
-		}
-<A>"$"		{ RET(INDIRECT); }
-<A>NF		{ yylval.cp = setsymtab((uchar *)yytext, (uchar *)"", 0.0, NUM, symtab); RET(VARNF); }
-
-<A>({D}+("."?){D}*|"."{D}+)((e|E)("+"|-)?{D}+)?	{
-		  yylval.cp = setsymtab((uchar *)yytext, tostring((uchar *)yytext), atof(yytext), CON|NUM, symtab);
-		  RET(NUMBER); }
-
-<A>while	{ RET(WHILE); }
-<A>for		{ RET(FOR); }
-<A>do		{ RET(DO); }
-<A>if		{ RET(IF); }
-<A>else		{ RET(ELSE); }
-<A>next		{ RET(NEXT); }
-<A>exit		{ RET(EXIT); }
-<A>break	{ RET(BREAK); }
-<A>continue	{ RET(CONTINUE); }
-<A>print	{ yylval.i = PRINT; RET(PRINT); }
-<A>printf	{ yylval.i = PRINTF; RET(PRINTF); }
-<A>sprintf	{ yylval.i = SPRINTF; RET(SPRINTF); }
-<A>split	{ yylval.i = SPLIT; RET(SPLIT); }
-<A>substr	{ RET(SUBSTR); }
-<A>sub		{ yylval.i = SUB; RET(SUB); }
-<A>gsub		{ yylval.i = GSUB; RET(GSUB); }
-<A>index	{ RET(INDEX); }
-<A>match	{ RET(MATCHFCN); }
-<A>in		{ RET(IN); }
-<A>getline	{ RET(GETLINE); }
-<A>close	{ RET(CLOSE); }
-<A>delete	{ RET(DELETE); }
-<A>length	{ yylval.i = FLENGTH; RET(BLTIN); }
-<A>log		{ yylval.i = FLOG; RET(BLTIN); }
-<A>int		{ yylval.i = FINT; RET(BLTIN); }
-<A>exp		{ yylval.i = FEXP; RET(BLTIN); }
-<A>sqrt		{ yylval.i = FSQRT; RET(BLTIN); }
-<A>sin		{ yylval.i = FSIN; RET(BLTIN); }
-<A>cos		{ yylval.i = FCOS; RET(BLTIN); }
-<A>atan2	{ yylval.i = FATAN; RET(BLTIN); }
-<A>system	{ yylval.i = FSYSTEM; RET(BLTIN); }
-<A>rand		{ yylval.i = FRAND; RET(BLTIN); }
-<A>srand	{ yylval.i = FSRAND; RET(BLTIN); }
-<A>toupper	{ yylval.i = FTOUPPER; RET(BLTIN); }
-<A>tolower	{ yylval.i = FTOLOWER; RET(BLTIN); }
-
-<A>{A}{B}*	{ int n, c;
-		  c = input(); unput(c);	/* look for '(' */
-		  if (c != '(' && infunc && (n=isarg(yytext)) >= 0) {
-			yylval.i = n;
-			RET(ARG);
-		  } else {
-			yylval.cp = setsymtab((uchar *)yytext,
-				(uchar *)"",0.0,STR|NUM,symtab);
-			if (c == '(') {
-				RET(CALL);
-			} else {
-				RET(VAR);
-			}
-		  }
-		}
-<A>\"		{ BEGIN str; clen = 0; }
-
-<A>"}"		{ if (--bracecnt < 0) ERROR "extra }" SYNTAX; BEGIN sc; RET(';'); }
-<A>"]"		{ if (--brackcnt < 0) ERROR "extra ]" SYNTAX; RET(']'); }
-<A>")"		{ if (--parencnt < 0) ERROR "extra )" SYNTAX; RET(')'); }
-
-<A>.		{ if (yytext[0] == '{') bracecnt++;
-		  else if (yytext[0] == '[') brackcnt++;
-		  else if (yytext[0] == '(') parencnt++;
-		  RET(yylval.i = yytext[0]); /* everything else */ }
-
-<reg>\\.	{ cbuf[clen++] = '\\'; cbuf[clen++] = yytext[1]; }
-<reg>\n		{ ERROR "newline in regular expression %.10s...", cbuf SYNTAX; lineno++; BEGIN A; }
-<reg>"/"	{ BEGIN A;
-		  cbuf[clen] = 0;
-		  yylval.s = tostring(cbuf);
-		  unput('/');
-		  RET(REGEXPR); }
-<reg>.		{ CADD; }
-
-<str>\"		{ BEGIN A;
-		  cbuf[clen] = 0; s = tostring(cbuf);
-		  cbuf[clen] = ' '; cbuf[++clen] = 0;
-		  yylval.cp = setsymtab(cbuf, s, 0.0, CON|STR, symtab);
-		  RET(STRING); }
-<str>\n		{ ERROR "newline in string %.10s...", cbuf SYNTAX; lineno++; BEGIN A; }
-<str>"\\\""	{ cbuf[clen++] = '"'; }
-<str>"\\"n	{ cbuf[clen++] = '\n'; }
-<str>"\\"t	{ cbuf[clen++] = '\t'; }
-<str>"\\"f	{ cbuf[clen++] = '\f'; }
-<str>"\\"r	{ cbuf[clen++] = '\r'; }
-<str>"\\"b	{ cbuf[clen++] = '\b'; }
-<str>"\\"v	{ cbuf[clen++] = '\v'; }	/* these ANSIisms may not be known by */
-<str>"\\"a	{ cbuf[clen++] = '\007'; }	/* your compiler. hence 007 for bell */
-<str>"\\\\"	{ cbuf[clen++] = '\\'; }
-<str>"\\"({O}{O}{O}|{O}{O}|{O}) { int n;
-		  sscanf(yytext+1, "%o", &n); cbuf[clen++] = n; }
-<str>"\\"x({H}+) { int n;	/* ANSI permits any number! */
-		  sscanf(yytext+2, "%x", &n); cbuf[clen++] = n; }
-<str>"\\".	{ cbuf[clen++] = yytext[1]; }
-<str>.		{ CADD; }
-
-%%
-
-void
-startreg()
-{
-	BEGIN reg;
-	clen = 0;
-}
-
-/* input() and unput() are transcriptions of the standard lex
-   macros for input and output with additions for error message
-   printing.  God help us all if someone changes how lex works.
-*/
-
-uchar	ebuf[300];
-uchar	*ep = ebuf;
-
-int
-input(void)
-{
-	register int c;
-	extern uchar *lexprog;
-
-	if (yysptr > yysbuf)
-		c = U(*--yysptr);
-	else if (lexprog != NULL)	/* awk '...' */
-		c = *lexprog++;
-	else				/* awk -f ... */
-		c = pgetc();
-	if (c == '\n')
-		yylineno++;
-	else if (c == EOF)
-		c = 0;
-	if (ep >= ebuf + sizeof ebuf)
-		ep = ebuf;
-	return *ep++ = c;
-}
-
-static void
-unput(int c)
-{
-	yytchar = c;
-	if (yytchar == '\n')
-		yylineno--;
-	*yysptr++ = yytchar;
-	if (--ep < ebuf)
-		ep = ebuf + sizeof(ebuf) - 1;
-}
-
-
-static void
-unputstr(char *s)
-{
-	int i;
-
-	for (i = strlen(s)-1; i >= 0; i--)
-		unput(s[i]);
-}
diff --git a/usr/src/cmd/awk/b.c b/usr/src/cmd/awk/b.c
index 9caee4e9d3..e6dbc35f17 100644
--- a/usr/src/cmd/awk/b.c
+++ b/usr/src/cmd/awk/b.c
@@ -23,10 +23,12 @@
 /*
  * Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T. All Rights Reserved.
+ * Copyright (C) Lucent Technologies 1997. All Rights Reserved.
  */
 
-/*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
-/*	  All Rights Reserved  	*/
+/* lasciate ogne speranza, voi ch'intrate. */
 
 #define	DEBUG
 
@@ -37,7 +39,7 @@
 				/* NCHARS is 2**n */
 #define	MAXLIN (3 * LINE_MAX)
 
-#define	type(v)		(v)->nobj
+#define	type(v)		(v)->nobj	/* badly overloaded here */
 #define	left(v)		(v)->narg[0]
 #define	right(v)	(v)->narg[1]
 #define	parent(v)	(v)->nnext
@@ -60,34 +62,34 @@ Node	*point[MAXLIN];
 
 int	rtok;		/* next token in current re */
 int	rlxval;
-uchar	*rlxstr;
-uchar	*prestr;	/* current position in current re */
-uchar	*lastre;	/* origin of last re */
+static uschar	*rlxstr;
+static uschar	*prestr;	/* current position in current re */
+static uschar	*lastre;	/* origin of last re */
 
 static	int setcnt;
 static	int poscnt;
 
-uchar	*patbeg;
+char	*patbeg;
 int	patlen;
 
 #define	NFA	20	/* cache this many dynamic fa's */
 fa	*fatab[NFA];
 int	nfatab	= 0;	/* entries in fatab */
 
-static fa	*mkdfa(uchar *, int);
+static fa	*mkdfa(const char *, int);
 static int	makeinit(fa *, int);
 static void	penter(Node *);
 static void	freetr(Node *);
 static void	overflo(char *);
 static void	cfoll(fa *, Node *);
 static void	follow(Node *);
-static Node	*reparse(uchar *);
+static Node	*reparse(const char *);
 static int	relex(void);
 static void	freefa(fa *);
 static int	cgoto(fa *, int, int);
 
 fa *
-makedfa(uchar *s, int anchor)	/* returns dfa for reg expr s */
+makedfa(const char *s, int anchor)	/* returns dfa for reg expr s */
 {
 	int i, use, nuse;
 	fa *pfa;
@@ -96,7 +98,7 @@ makedfa(uchar *s, int anchor)	/* returns dfa for reg expr s */
 		return (mkdfa(s, anchor));
 	for (i = 0; i < nfatab; i++) {	/* is it there already? */
 		if (fatab[i]->anchor == anchor &&
-		    strcmp((char *)fatab[i]->restr, (char *)s) == 0) {
+		    strcmp((const char *)fatab[i]->restr, s) == 0) {
 			fatab[i]->use++;
 			return (fatab[i]);
 		}
@@ -121,9 +123,12 @@ makedfa(uchar *s, int anchor)	/* returns dfa for reg expr s */
 	return (pfa);
 }
 
+/*
+ * does the real work of making a dfa
+ * anchor = 1 for anchored matches, else 0
+ */
 fa *
-mkdfa(uchar *s, int anchor)	/* does the real work of making a dfa */
-	/* anchor = 1 for anchored matches, else 0 */
+mkdfa(const char *s, int anchor)
 {
 	Node *p, *p1;
 	fa *f;
@@ -137,7 +142,7 @@ mkdfa(uchar *s, int anchor)	/* does the real work of making a dfa */
 	poscnt = 0;
 	penter(p1);	/* enter parent pointers and leaf indices */
 	if ((f = (fa *)calloc(1, sizeof (fa) + poscnt * sizeof (rrow))) == NULL)
-		overflo("no room for fa");
+		overflo("out of space for fa");
 	/* penter has computed number of positions in re */
 	f->accept = poscnt-1;
 	cfoll(f, p1);	/* set up follow sets */
@@ -151,14 +156,14 @@ mkdfa(uchar *s, int anchor)	/* does the real work of making a dfa */
 	*f->posns[1] = 0;
 	f->initstat = makeinit(f, anchor);
 	f->anchor = anchor;
-	f->restr = tostring(s);
+	f->restr = (uschar *)tostring(s);
 	return (f);
 }
 
 static int
 makeinit(fa *f, int anchor)
 {
-	register int i, k;
+	int i, k;
 
 	f->curstat = 2;
 	f->out[2] = 0;
@@ -207,8 +212,8 @@ penter(Node *p)	/* set up parent pointers and leaf indices */
 		parent(left(p)) = p;
 		parent(right(p)) = p;
 		break;
-	default:
-		ERROR "unknown type %d in penter", type(p) FATAL;
+	default:	/* can't happen */
+		FATAL("can't happen: unknown type %d in penter", type(p));
 		break;
 	}
 }
@@ -230,80 +235,112 @@ freetr(Node *p)	/* free parse tree */
 		freetr(right(p));
 		xfree(p);
 		break;
-	default:
-		ERROR "unknown type %d in freetr", type(p) FATAL;
+	default:	/* can't happen */
+		FATAL("can't happen: unknown type %d in freetr", type(p));
 		break;
 	}
 }
 
-uchar *
-cclenter(uchar *p)
+#define	isoctdigit(c) ((c) >= '0' && (c) <= '7')
+
+/* pick up next thing after a \\ and increment *pp */
+int
+quoted(uschar **pp)
+{
+	uschar *p = *pp;
+	int c;
+
+	if ((c = *p++) == 't')
+		c = '\t';
+	else if (c == 'n')
+		c = '\n';
+	else if (c == 'f')
+		c = '\f';
+	else if (c == 'r')
+		c = '\r';
+	else if (c == 'b')
+		c = '\b';
+	else if (c == '\\')
+		c = '\\';
+	else if (isoctdigit(c)) {	/* \d \dd \ddd */
+		int n = c - '0';
+		if (isoctdigit(*p)) {
+			n = 8 * n + *p++ - '0';
+			if (isoctdigit(*p))
+				n = 8 * n + *p++ - '0';
+		}
+		c = n;
+	} /* else */
+		/* c = c; */
+	*pp = p;
+	return (c);
+}
+
+char *
+cclenter(const char *argp)	/* add a character class */
 {
-	register int i, c;
-	uchar *op, *chars, *ret;
-	size_t	bsize;
+	int i, c, c2;
+	uschar *p = (uschar *)argp;
+	uschar *op, *bp;
+	static uschar *buf = NULL;
+	static size_t bufsz = 100;
 
-	init_buf(&chars, &bsize, LINE_INCR);
 	op = p;
-	i = 0;
-	while ((c = *p++) != 0) {
+	if (buf == NULL && (buf = (uschar *)malloc(bufsz)) == NULL)
+		FATAL("out of space for character class [%.10s...] 1", p);
+	bp = buf;
+	for (i = 0; (c = *p++) != 0; ) {
 		if (c == '\\') {
-			if ((c = *p++) == 't')
-				c = '\t';
-			else if (c == 'n')
-				c = '\n';
-			else if (c == 'f')
-				c = '\f';
-			else if (c == 'r')
-				c = '\r';
-			else if (c == 'b')
-				c = '\b';
-			else if (c == '\\')
-				c = '\\';
-			else if (isdigit(c)) {
-				int n = c - '0';
-				if (isdigit(*p)) {
-					n = 8 * n + *p++ - '0';
-					if (isdigit(*p))
-						n = 8 * n + *p++ - '0';
-				}
-				c = n;
-			} /* else */
-				/* c = c; */
-		} else if (c == '-' && i > 0 && chars[i-1] != 0) {
+			c = quoted(&p);
+		} else if (c == '-' && i > 0 && bp[-1] != 0) {
 			if (*p != 0) {
-				c = chars[i-1];
-				while ((uchar)c < *p) {	/* fails if *p is \\ */
-					expand_buf(&chars, &bsize, i);
-					chars[i++] = ++c;
+				c = bp[-1];
+				c2 = *p++;
+				if (c2 == '\\')
+					c2 = quoted(&p);
+				if (c > c2) {	/* empty; ignore */
+					bp--;
+					i--;
+					continue;
+				}
+				while (c < c2) {
+					if (!adjbuf((char **)&buf, &bufsz,
+					    bp-buf+2, 100, (char **)&bp,
+					    "cclenter1")) {
+						FATAL(
+			"out of space for character class [%.10s...] 2", p);
+					}
+					*bp++ = ++c;
+					i++;
 				}
-				p++;
 				continue;
 			}
 		}
-		expand_buf(&chars, &bsize, i);
-		chars[i++] = c;
+		if (!adjbuf((char **)&buf, &bufsz, bp-buf+2, 100, (char **)&bp,
+		    "cclenter2"))
+			FATAL(
+			    "out of space for character class [%.10s...] 3", p);
+		*bp++ = c;
+		i++;
 	}
-	chars[i++] = '\0';
-	dprintf(("cclenter: in = |%s|, out = |%s|\n", op, chars));
+	*bp = '\0';
+	dprintf(("cclenter: in = |%s|, out = |%s|\n", op, buf));
 	xfree(op);
-	ret = tostring(chars);
-	free(chars);
-	return (ret);
+	return (char *)tostring((char *)buf);
 }
 
 static void
 overflo(char *s)
 {
-	ERROR "regular expression too big: %s", gettext((char *)s) FATAL;
+	FATAL("regular expression too big: %s", gettext((char *)s));
 }
 
 /* enter follow set of each leaf of vertex v into lfollow[leaf] */
 static void
 cfoll(fa *f, Node *v)
 {
-	register int i;
-	register int *p;
+	int i;
+	int *p;
 
 	switch (type(v)) {
 	LEAF
@@ -330,8 +367,8 @@ cfoll(fa *f, Node *v)
 		cfoll(f, left(v));
 		cfoll(f, right(v));
 		break;
-	default:
-		ERROR "unknown type %d in cfoll", type(v) FATAL;
+	default:	/* can't happen */
+		FATAL("can't happen: unknown type %d in cfoll", type(v));
 	}
 }
 
@@ -342,7 +379,7 @@ cfoll(fa *f, Node *v)
 static int
 first(Node *p)
 {
-	register int b;
+	int b;
 
 	switch (type(p)) {
 	LEAF
@@ -372,8 +409,7 @@ first(Node *p)
 			return (0);
 		return (1);
 	}
-	ERROR "unknown type %d in first", type(p) FATAL;
-	return (-1);
+	FATAL("can't happen: unknown type %d in first", type(p));
 }
 
 /* collects leaves that can follow v into setvec */
@@ -407,14 +443,16 @@ follow(Node *v)
 			follow(p);
 		return;
 	default:
-		ERROR "unknown type %d in follow", type(p) FATAL;
+		FATAL("unknown type %d in follow", type(p));
 		break;
 	}
 }
 
 static int
-member(uchar c, uchar *s)	/* is c in s? */
+member(int c, const char *sarg)	/* is c in s? */
 {
+	uschar *s = (uschar *)sarg;
+
 	while (*s)
 		if (c == *s++)
 			return (1);
@@ -423,9 +461,10 @@ member(uchar c, uchar *s)	/* is c in s? */
 
 
 int
-match(fa *f, uchar *p)
+match(fa *f, const char *p0)	/* shortest match ? */
 {
-	register int s, ns;
+	int s, ns;
+	uschar *p = (uschar *)p0;
 
 	s = f->reset ? makeinit(f, 0) : f->initstat;
 	if (f->out[s])
@@ -442,10 +481,11 @@ match(fa *f, uchar *p)
 }
 
 int
-pmatch(fa *f, uchar *p)
+pmatch(fa *f, const char *p0)	/* longest match, for sub */
 {
-	register int s, ns;
-	register uchar *q;
+	int s, ns;
+	uschar *p = (uschar *)p0;
+	uschar *q;
 	int i, k;
 
 	if (f->reset) {
@@ -453,7 +493,7 @@ pmatch(fa *f, uchar *p)
 	} else {
 		s = f->initstat;
 	}
-	patbeg = p;
+	patbeg = (char *)p;
 	patlen = -1;
 	do {
 		q = p;
@@ -466,16 +506,17 @@ pmatch(fa *f, uchar *p)
 				s = cgoto(f, s, *q);
 			if (s == 1) {	/* no transition */
 				if (patlen >= 0) {
-					patbeg = p;
+					patbeg = (char *)p;
 					return (1);
-				} else
+				} else {
 					goto nextin;	/* no match */
+				}
 			}
 		} while (*q++ != 0);
 		if (f->out[s])
 			patlen = q - p - 1;	/* don't count $ */
 		if (patlen >= 0) {
-			patbeg = p;
+			patbeg = (char *)p;
 			return (1);
 		}
 	nextin:
@@ -500,10 +541,11 @@ pmatch(fa *f, uchar *p)
 }
 
 int
-nematch(fa *f, uchar *p)
+nematch(fa *f, const char *p0)	/* non-empty match, for sub */
 {
-	register int s, ns;
-	register uchar *q;
+	int s, ns;
+	uschar *p = (uschar *)p0;
+	uschar *q;
 	int i, k;
 
 	if (f->reset) {
@@ -523,7 +565,7 @@ nematch(fa *f, uchar *p)
 				s = cgoto(f, s, *q);
 			if (s == 1) {	/* no transition */
 				if (patlen > 0) {
-					patbeg = p;
+					patbeg = (char *)p;
 					return (1);
 				} else
 					goto nnextin;	/* no nonempty match */
@@ -532,7 +574,7 @@ nematch(fa *f, uchar *p)
 		if (f->out[s])
 			patlen = q - p - 1;	/* don't count $ */
 		if (patlen > 0) {
-			patbeg = p;
+			patbeg = (char *)p;
 			return (1);
 		}
 	nnextin:
@@ -561,30 +603,29 @@ static Node *regexp(void), *primary(void), *concat(Node *);
 static Node *alt(Node *), *unary(Node *);
 
 static Node *
-reparse(uchar *p)
+reparse(const char *p)
 {
 	/* parses regular expression pointed to by p */
 	/* uses relex() to scan regular expression */
 	Node *np;
 
 	dprintf(("reparse <%s>\n", p));
-	lastre = prestr = p;	/* prestr points to string to be parsed */
+
+	/* prestr points to string to be parsed */
+	lastre = prestr = (uschar *)p;
 	rtok = relex();
-	if (rtok == '\0')
-		ERROR "empty regular expression" FATAL;
-	np = regexp();
 	if (rtok == '\0') {
-		return (np);
-	} else {
-		ERROR "syntax error in regular expression %s at %s",
-		    lastre, prestr FATAL;
+		FATAL("empty regular expression");
 	}
-	/*NOTREACHED*/
-	return (NULL);
+	np = regexp();
+	if (rtok != '\0')
+		FATAL("syntax error in regular expression %s at %s",
+		    lastre, prestr);
+	return (np);
 }
 
 static Node *
-regexp(void)
+regexp(void)	/* top-level parse of reg expr */
 {
 	return (alt(concat(primary())));
 }
@@ -596,7 +637,7 @@ primary(void)
 
 	switch (rtok) {
 	case CHAR:
-		np = op2(CHAR, NIL, (Node *)rlxval);
+		np = op2(CHAR, NIL, itonp(rlxval));
 		rtok = relex();
 		return (unary(np));
 	case ALL:
@@ -607,17 +648,17 @@ primary(void)
 		return (unary(op2(DOT, NIL, NIL)));
 	case CCL:
 		/*LINTED align*/
-		np = op2(CCL, NIL, (Node *)cclenter(rlxstr));
+		np = op2(CCL, NIL, (Node *)cclenter((char *)rlxstr));
 		rtok = relex();
 		return (unary(np));
 	case NCCL:
 		/*LINTED align*/
-		np = op2(NCCL, NIL, (Node *)cclenter(rlxstr));
+		np = op2(NCCL, NIL, (Node *)cclenter((char *)rlxstr));
 		rtok = relex();
 		return (unary(np));
 	case '^':
 		rtok = relex();
-		return (unary(op2(CHAR, NIL, (Node *)HAT)));
+		return (unary(op2(CHAR, NIL, itonp(HAT))));
 	case '$':
 		rtok = relex();
 		return (unary(op2(CHAR, NIL, NIL)));
@@ -627,20 +668,20 @@ primary(void)
 			rtok = relex();
 			return (unary(op2(CCL, NIL,
 			    /*LINTED align*/
-			    (Node *)tostring((uchar *)""))));
+			    (Node *)tostring(""))));
 		}
 		np = regexp();
 		if (rtok == ')') {
 			rtok = relex();
 			return (unary(np));
 		} else {
-			ERROR "syntax error in regular expression %s at %s",
-			    lastre, prestr FATAL;
+			FATAL("syntax error in regular expression %s at %s",
+			    lastre, prestr);
 		}
 		/* FALLTHROUGH */
 	default:
-		ERROR "illegal primary in regular expression %s at %s",
-		    lastre, prestr FATAL;
+		FATAL("illegal primary in regular expression %s at %s",
+		    lastre, prestr);
 	}
 	/*NOTREACHED*/
 	return (NULL);
@@ -688,7 +729,7 @@ unary(Node *np)
 static int
 relex(void)		/* lexical analyzer for reparse */
 {
-	register int c;
+	int c;
 	uchar *cbuf;
 	int clen, cflag;
 
@@ -705,28 +746,7 @@ relex(void)		/* lexical analyzer for reparse */
 	case ')':
 		return (c);
 	case '\\':
-		if ((c = *prestr++) == 't')
-			c = '\t';
-		else if (c == 'n')
-			c = '\n';
-		else if (c == 'f')
-			c = '\f';
-		else if (c == 'r')
-			c = '\r';
-		else if (c == 'b')
-			c = '\b';
-		else if (c == '\\')
-			c = '\\';
-		else if (isdigit(c)) {
-			int n = c - '0';
-			if (isdigit(*prestr)) {
-				n = 8 * n + *prestr++ - '0';
-				if (isdigit(*prestr))
-					n = 8 * n + *prestr++ - '0';
-			}
-			c = n;
-		} /* else it's now in c */
-		rlxval = c;
+		rlxval = quoted(&prestr);
 		return (CHAR);
 	default:
 		rlxval = c;
@@ -738,29 +758,31 @@ relex(void)		/* lexical analyzer for reparse */
 			prestr++;
 		} else
 			cflag = 0;
-		init_buf(&cbuf, NULL, strlen((char *)prestr) * 2 + 1);
+		init_buf((char **)&cbuf, NULL, strlen((char *)prestr) * 2 + 1);
 		for (;;) {
 			if ((c = *prestr++) == '\\') {
 				cbuf[clen++] = '\\';
 				if ((c = *prestr++) == '\0') {
-					ERROR
-			"nonterminated character class %s", lastre FATAL;
+					FATAL("nonterminated character class "
+					    "%.20s...", lastre);
 				}
 				cbuf[clen++] = c;
+			} else if (clen == 0) {
+				cbuf[clen++] = c;
 			} else if (c == ']') {
 				cbuf[clen] = 0;
-				rlxstr = tostring(cbuf);
+				rlxstr = (uschar *)tostring((char *)cbuf);
 				free(cbuf);
 				if (cflag == 0)
 					return (CCL);
 				else
 					return (NCCL);
 			} else if (c == '\n') {
-				ERROR "newline in character class %s...",
-				    lastre FATAL;
+				FATAL("newline in character class %s...",
+				    lastre);
 			} else if (c == '\0') {
-				ERROR "nonterminated character class %s",
-				    lastre FATAL;
+				FATAL("nonterminated character class %s",
+				    lastre);
 			} else
 				cbuf[clen++] = c;
 		}
@@ -772,8 +794,8 @@ relex(void)		/* lexical analyzer for reparse */
 static int
 cgoto(fa *f, int s, int c)
 {
-	register int i, j, k;
-	register int *p, *q;
+	int i, j, k;
+	int *p, *q;
 
 	for (i = 0; i <= f->accept; i++)
 		setvec[i] = 0;
@@ -786,9 +808,9 @@ cgoto(fa *f, int s, int c)
 			    k == DOT && c != 0 && c != HAT ||
 			    k == ALL && c != 0 ||
 			    k == CCL &&
-			    member(c, (uchar *)f->re[p[i]].lval) ||
+			    member(c, (char *)f->re[p[i]].lval) ||
 			    k == NCCL &&
-			    !member(c, (uchar *)f->re[p[i]].lval) &&
+			    !member(c, (char *)f->re[p[i]].lval) &&
 			    c != 0 && c != HAT) {
 				q = f->re[p[i]].lfollow;
 				for (j = 1; j <= *q; j++) {
@@ -847,10 +869,9 @@ cgoto(fa *f, int s, int c)
 }
 
 static void
-freefa(fa *f)
+freefa(fa *f)	/* free a finite automaton */
 {
-
-	register int i;
+	int i;
 
 	if (f == NULL)
 		return;
diff --git a/usr/src/cmd/awk/lex.c b/usr/src/cmd/awk/lex.c
new file mode 100644
index 0000000000..7eef2eaf44
--- /dev/null
+++ b/usr/src/cmd/awk/lex.c
@@ -0,0 +1,633 @@
+/*
+ * Copyright (C) Lucent Technologies 1997
+ * All Rights Reserved
+ *
+ * Permission to use, copy, modify, and distribute this software and
+ * its documentation for any purpose and without fee is hereby
+ * granted, provided that the above copyright notice appear in all
+ * copies and that both that the copyright notice and this
+ * permission notice and warranty disclaimer appear in supporting
+ * documentation, and that the name Lucent Technologies or any of
+ * its entities not be used in advertising or publicity pertaining
+ * to distribution of the software without specific, written prior
+ * permission.
+ *
+ * LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
+ * IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+ * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
+ * THIS SOFTWARE.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include "awk.h"
+#include "y.tab.h"
+
+extern YYSTYPE	yylval;
+extern int	infunc;
+
+off_t	lineno	= 1;
+int	bracecnt = 0;
+int	brackcnt  = 0;
+int	parencnt = 0;
+
+typedef struct Keyword {
+	const char *word;
+	int	sub;
+	int	type;
+} Keyword;
+
+Keyword keywords[] = {	/* keep sorted: binary searched */
+	{ "BEGIN",	XBEGIN,		XBEGIN },
+	{ "END",	XEND,		XEND },
+	{ "NF",		VARNF,		VARNF },
+	{ "atan2",	FATAN,		BLTIN },
+	{ "break",	BREAK,		BREAK },
+	{ "close",	CLOSE,		CLOSE },
+	{ "continue",	CONTINUE,	CONTINUE },
+	{ "cos",	FCOS,		BLTIN },
+	{ "delete",	DELETE,		DELETE },
+	{ "do",		DO,		DO },
+	{ "else",	ELSE,		ELSE },
+	{ "exit",	EXIT,		EXIT },
+	{ "exp",	FEXP,		BLTIN },
+	{ "for",	FOR,		FOR },
+	{ "func",	FUNC,		FUNC },
+	{ "function",	FUNC,		FUNC },
+	{ "getline",	GETLINE,	GETLINE },
+	{ "gsub",	GSUB,		GSUB },
+	{ "if",		IF,		IF },
+	{ "in",		IN,		IN },
+	{ "index",	INDEX,		INDEX },
+	{ "int",	FINT,		BLTIN },
+	{ "length",	FLENGTH,	BLTIN },
+	{ "log",	FLOG,		BLTIN },
+	{ "match",	MATCHFCN,	MATCHFCN },
+	{ "next",	NEXT,		NEXT },
+	{ "print",	PRINT,		PRINT },
+	{ "printf",	PRINTF,		PRINTF },
+	{ "rand",	FRAND,		BLTIN },
+	{ "return",	RETURN,		RETURN },
+	{ "sin",	FSIN,		BLTIN },
+	{ "split",	SPLIT,		SPLIT },
+	{ "sprintf",	SPRINTF,	SPRINTF },
+	{ "sqrt",	FSQRT,		BLTIN },
+	{ "srand",	FSRAND,		BLTIN },
+	{ "sub",	SUB,		SUB },
+	{ "substr",	SUBSTR,		SUBSTR },
+	{ "system",	FSYSTEM,	BLTIN },
+	{ "tolower",	FTOLOWER,	BLTIN },
+	{ "toupper",	FTOUPPER,	BLTIN },
+	{ "while",	WHILE,		WHILE },
+};
+
+#define	RET(x)	{ if (dbg) (void) printf("lex %s\n", tokname(x)); return (x); }
+
+int
+peek(void)
+{
+	int c = input();
+	unput(c);
+	return (c);
+}
+
+int
+gettok(char **pbuf, size_t *psz)	/* get next input token */
+{
+	int c, retc;
+	char *buf = *pbuf;
+	size_t sz = *psz;
+	char *bp = buf;
+
+	c = input();
+	if (c == 0)
+		return (0);
+	buf[0] = c;
+	buf[1] = 0;
+	if (!isalnum(c) && c != '.' && c != '_')
+		return (c);
+
+	*bp++ = c;
+	if (isalpha(c) || c == '_') {	/* it's a varname */
+		for (; (c = input()) != 0; ) {
+			if (bp-buf >= sz &&
+			    !adjbuf(&buf, &sz, bp-buf+2, 100, &bp, "gettok"))
+				FATAL("out of space for name %.10s...", buf);
+			if (isalnum(c) || c == '_')
+				*bp++ = c;
+			else {
+				*bp = 0;
+				unput(c);
+				break;
+			}
+		}
+		*bp = 0;
+		retc = 'a';	/* alphanumeric */
+	} else {	/* maybe it's a number, but could be . */
+		char *rem;
+		/* read input until can't be a number */
+		for (; (c = input()) != 0; ) {
+			if (bp-buf >= sz &&
+			    !adjbuf(&buf, &sz, bp-buf+2, 100, &bp, "gettok"))
+				FATAL("out of space for number %.10s...", buf);
+			if (isdigit(c) || c == 'e' || c == 'E' ||
+			    c == '.' || c == '+' || c == '-')
+				*bp++ = c;
+			else {
+				unput(c);
+				break;
+			}
+		}
+		*bp = 0;
+		strtod(buf, &rem);	/* parse the number */
+		if (rem == buf) {	/* it wasn't a valid number at all */
+			buf[1] = 0;	/* return one character as token */
+			retc = buf[0];	/* character is its own type */
+			unputstr(rem+1); /* put rest back for later */
+		} else {	/* some prefix was a number */
+			unputstr(rem);	/* put rest back for later */
+			rem[0] = 0;	/* truncate buf after number part */
+			retc = '0';	/* type is number */
+		}
+	}
+	*pbuf = buf;
+	*psz = sz;
+	return (retc);
+}
+
+int	word(char *);
+int	string(void);
+int	regexpr(void);
+int	sc	= 0;	/* 1 => return a } right now */
+int	reg	= 0;	/* 1 => return a REGEXPR now */
+
+int
+yylex(void)
+{
+	int c;
+	static char *buf = 0;
+	/* BUG: setting this small causes core dump! */
+	static size_t bufsize = 5;
+
+	if (buf == 0 && (buf = (char *) malloc(bufsize)) == NULL)
+		FATAL("out of space in yylex");
+	if (sc) {
+		sc = 0;
+		RET('}');
+	}
+	if (reg) {
+		reg = 0;
+		return (regexpr());
+	}
+	for (;;) {
+		c = gettok(&buf, &bufsize);
+		if (c == 0)
+			return (0);
+		if (isalpha(c) || c == '_')
+			return (word(buf));
+		if (isdigit(c)) {
+			yylval.cp = setsymtab(
+			    buf, tostring(buf), atof(buf), CON|NUM, symtab);
+			/* should this also have STR set? */
+			RET(NUMBER);
+		}
+
+		yylval.i = c;
+		switch (c) {
+		case '\n':	/* {EOL} */
+			lineno++;
+			RET(NL);
+		case '\r':	/* assume \n is coming */
+		case ' ':	/* {WS}+ */
+		case '\t':
+			break;
+		case '#':	/* #.* strip comments */
+			while ((c = input()) != '\n' && c != 0)
+				;
+			unput(c);
+			break;
+		case ';':
+			RET(';');
+		case '\\':
+			if (peek() == '\n') {
+				(void) input();
+				lineno++;
+			} else if (peek() == '\r') {
+				(void) input();
+				(void) input();	/* BUG: check for \n */
+				lineno++;
+			} else {
+				RET(c);
+			}
+			break;
+		case '&':
+			if (peek() == '&') {
+				(void) input();
+				RET(AND);
+			} else
+				RET('&');
+		case '|':
+			if (peek() == '|') {
+				(void) input();
+				RET(BOR);
+			} else
+				RET('|');
+		case '!':
+			if (peek() == '=') {
+				(void) input();
+				yylval.i = NE;
+				RET(NE);
+			} else if (peek() == '~') {
+				(void) input();
+				yylval.i = NOTMATCH;
+				RET(MATCHOP);
+			} else
+				RET(NOT);
+		case '~':
+			yylval.i = MATCH;
+			RET(MATCHOP);
+		case '<':
+			if (peek() == '=') {
+				(void) input();
+				yylval.i = LE;
+				RET(LE);
+			} else {
+				yylval.i = LT;
+				RET(LT);
+			}
+		case '=':
+			if (peek() == '=') {
+				(void) input();
+				yylval.i = EQ;
+				RET(EQ);
+			} else {
+				yylval.i = ASSIGN;
+				RET(ASGNOP);
+			}
+		case '>':
+			if (peek() == '=') {
+				(void) input();
+				yylval.i = GE;
+				RET(GE);
+			} else if (peek() == '>') {
+				(void) input();
+				yylval.i = APPEND;
+				RET(APPEND);
+			} else {
+				yylval.i = GT;
+				RET(GT);
+			}
+		case '+':
+			if (peek() == '+') {
+				(void) input();
+				yylval.i = INCR;
+				RET(INCR);
+			} else if (peek() == '=') {
+				(void) input();
+				yylval.i = ADDEQ;
+				RET(ASGNOP);
+			} else
+				RET('+');
+		case '-':
+			if (peek() == '-') {
+				(void) input();
+				yylval.i = DECR;
+				RET(DECR);
+			} else if (peek() == '=') {
+				(void) input();
+				yylval.i = SUBEQ;
+				RET(ASGNOP);
+			} else
+				RET('-');
+		case '*':
+			if (peek() == '=') {	/* *= */
+				(void) input();
+				yylval.i = MULTEQ;
+				RET(ASGNOP);
+			} else if (peek() == '*') {	/* ** or **= */
+				(void) input();	/* eat 2nd * */
+				if (peek() == '=') {
+					(void) input();
+					yylval.i = POWEQ;
+					RET(ASGNOP);
+				} else {
+					RET(POWER);
+				}
+			} else
+				RET('*');
+		case '/':
+			RET('/');
+		case '%':
+			if (peek() == '=') {
+				(void) input();
+				yylval.i = MODEQ;
+				RET(ASGNOP);
+			} else
+				RET('%');
+		case '^':
+			if (peek() == '=') {
+				(void) input();
+				yylval.i = POWEQ;
+				RET(ASGNOP);
+			} else
+				RET(POWER);
+
+		case '$':
+			/* BUG: awkward, if not wrong */
+			c = gettok(&buf, &bufsize);
+			if (isalpha(c)) {
+				if (strcmp(buf, "NF") == 0) {
+					/* very special */
+					unputstr("(NF)");
+					RET(INDIRECT);
+				}
+				c = peek();
+				if (c == '(' || c == '[' ||
+				    (infunc && isarg(buf) >= 0)) {
+					unputstr(buf);
+					RET(INDIRECT);
+				}
+				yylval.cp = setsymtab(
+				    buf, "", 0.0, STR|NUM, symtab);
+				RET(IVAR);
+			} else if (c == 0) {	/*  */
+				SYNTAX("unexpected end of input after $");
+				RET(';');
+			} else {
+				unputstr(buf);
+				RET(INDIRECT);
+			}
+
+		case '}':
+			if (--bracecnt < 0)
+				SYNTAX("extra }");
+			sc = 1;
+			RET(';');
+		case ']':
+			if (--brackcnt < 0)
+				SYNTAX("extra ]");
+			RET(']');
+		case ')':
+			if (--parencnt < 0)
+				SYNTAX("extra )");
+			RET(')');
+		case '{':
+			bracecnt++;
+			RET('{');
+		case '[':
+			brackcnt++;
+			RET('[');
+		case '(':
+			parencnt++;
+			RET('(');
+
+		case '"':
+			/* BUG: should be like tran.c ? */
+			return (string());
+
+		default:
+			RET(c);
+		}
+	}
+}
+
+int
+string(void)
+{
+	int c, n;
+	char *s, *bp;
+	static char *buf = 0;
+	static size_t bufsz = 500;
+
+	if (buf == 0 && (buf = (char *) malloc(bufsz)) == NULL)
+		FATAL("out of space for strings");
+	for (bp = buf; (c = input()) != '"'; ) {
+		if (!adjbuf(&buf, &bufsz, bp-buf+2, 500, &bp, "string"))
+			FATAL("out of space for string %.10s...", buf);
+		switch (c) {
+		case '\n':
+		case '\r':
+		case 0:
+			*bp = '\0';
+			SYNTAX("non-terminated string %.10s...", buf);
+			if (c == 0)	/* hopeless */
+				FATAL("giving up");
+			lineno++;
+			break;
+		case '\\':
+			c = input();
+			switch (c) {
+			case '"': *bp++ = '"'; break;
+			case 'n': *bp++ = '\n'; break;
+			case 't': *bp++ = '\t'; break;
+			case 'f': *bp++ = '\f'; break;
+			case 'r': *bp++ = '\r'; break;
+			case 'b': *bp++ = '\b'; break;
+			case 'v': *bp++ = '\v'; break;
+			case 'a': *bp++ = '\007'; break;
+			case '\\': *bp++ = '\\'; break;
+
+			case '0': case '1': case '2': /* octal: \d \dd \ddd */
+			case '3': case '4': case '5': case '6': case '7':
+				n = c - '0';
+				if ((c = peek()) >= '0' && c < '8') {
+					n = 8 * n + input() - '0';
+					if ((c = peek()) >= '0' && c < '8')
+						n = 8 * n + input() - '0';
+				}
+				*bp++ = n;
+				break;
+
+			case 'x':	/* hex  \x0-9a-fA-F + */
+			    {	char xbuf[100], *px;
+				px = xbuf;
+				while ((c = input()) != 0 && px-xbuf < 100-2) {
+					if (isdigit(c) ||
+					    (c >= 'a' && c <= 'f') ||
+					    (c >= 'A' && c <= 'F'))
+						*px++ = c;
+					else
+						break;
+				}
+				*px = 0;
+				unput(c);
+				sscanf(xbuf, "%x", (unsigned int *) &n);
+				*bp++ = n;
+				break;
+			    }
+
+			default:
+				*bp++ = c;
+				break;
+			}
+			break;
+		default:
+			*bp++ = c;
+			break;
+		}
+	}
+	*bp = 0;
+	s = tostring(buf);
+	*bp++ = ' '; *bp++ = 0;
+	yylval.cp = setsymtab(buf, s, 0.0, CON|STR|DONTFREE, symtab);
+	RET(STRING);
+}
+
+
+int
+binsearch(char *w, Keyword *kp, int n)
+{
+	int cond, low, mid, high;
+
+	low = 0;
+	high = n - 1;
+	while (low <= high) {
+		mid = (low + high) / 2;
+		if ((cond = strcmp(w, kp[mid].word)) < 0)
+			high = mid - 1;
+		else if (cond > 0)
+			low = mid + 1;
+		else
+			return (mid);
+	}
+	return (-1);
+}
+
+int
+word(char *w)
+{
+	Keyword *kp;
+	int c, n;
+
+	n = binsearch(w, keywords, sizeof (keywords) / sizeof (keywords[0]));
+	if (n != -1) {	/* found in table */
+		kp = keywords + n;
+		yylval.i = kp->sub;
+		switch (kp->type) {	/* special handling */
+		case BLTIN:
+			RET(kp->type);
+		case FUNC:
+			if (infunc)
+				SYNTAX("illegal nested function");
+			RET(kp->type);
+		case RETURN:
+			if (!infunc)
+				SYNTAX("return not in function");
+			RET(kp->type);
+		case VARNF:
+			yylval.cp = setsymtab("NF", "", 0.0, NUM, symtab);
+			RET(VARNF);
+		default:
+			RET(kp->type);
+		}
+	}
+	c = peek();	/* look for '(' */
+	if (c != '(' && infunc && (n = isarg(w)) >= 0) {
+		yylval.i = n;
+		RET(ARG);
+	} else {
+		yylval.cp = setsymtab(w, "", 0.0, STR|NUM|DONTFREE, symtab);
+		if (c == '(') {
+			RET(CALL);
+		} else {
+			RET(VAR);
+		}
+	}
+}
+
+void
+startreg(void)	/* next call to yylex will return a regular expression */
+{
+	reg = 1;
+}
+
+int
+regexpr(void)
+{
+	int c;
+	static char *buf = 0;
+	static size_t bufsz = 500;
+	char *bp;
+
+	if (buf == 0 && (buf = (char *) malloc(bufsz)) == NULL)
+		FATAL("out of space for rex expr");
+	bp = buf;
+	for (; (c = input()) != '/' && c != 0; ) {
+		if (!adjbuf(&buf, &bufsz, bp-buf+3, 500, &bp, "regexpr"))
+			FATAL("out of space for reg expr %.10s...", buf);
+		if (c == '\n') {
+			*bp = '\0';
+			SYNTAX("newline in regular expression %.10s...", buf);
+			unput('\n');
+			break;
+		} else if (c == '\\') {
+			*bp++ = '\\';
+			*bp++ = input();
+		} else {
+			*bp++ = c;
+		}
+	}
+	*bp = 0;
+	if (c == 0)
+		SYNTAX("non-terminated regular expression %.10s...", buf);
+	yylval.s = tostring(buf);
+	unput('/');
+	RET(REGEXPR);
+}
+
+/* low-level lexical stuff, sort of inherited from lex */
+
+char	ebuf[300];
+char	*ep = ebuf;
+char	yysbuf[100];	/* pushback buffer */
+char	*yysptr = yysbuf;
+FILE	*yyin = 0;
+
+int
+input(void)	/* get next lexical input character */
+{
+	int c;
+	extern char *lexprog;
+
+	if (yysptr > yysbuf)
+		c = (uschar)*--yysptr;
+	else if (lexprog != NULL) {	/* awk '...' */
+		if ((c = (uschar)*lexprog) != 0)
+			lexprog++;
+	} else				/* awk -f ... */
+		c = pgetc();
+	if (c == EOF)
+		c = 0;
+	if (ep >= ebuf + sizeof (ebuf))
+		ep = ebuf;
+	*ep = c;
+	if (c != 0) {
+		ep++;
+	}
+	return (c);
+}
+
+void
+unput(int c)	/* put lexical character back on input */
+{
+	if (yysptr >= yysbuf + sizeof (yysbuf))
+		FATAL("pushed back too much: %.20s...", yysbuf);
+	*yysptr++ = c;
+	if (--ep < ebuf)
+		ep = ebuf + sizeof (ebuf) - 1;
+}
+
+void
+unputstr(const char *s)	/* put a string back on input */
+{
+	int i;
+
+	for (i = strlen(s)-1; i >= 0; i--)
+		unput(s[i]);
+}
diff --git a/usr/src/cmd/awk/lib.c b/usr/src/cmd/awk/lib.c
index ded064c6c3..144106aa61 100644
--- a/usr/src/cmd/awk/lib.c
+++ b/usr/src/cmd/awk/lib.c
@@ -22,19 +22,26 @@
 /*
  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T. All Rights Reserved.
  */
 
-/*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
-/*	  All Rights Reserved  	*/
-
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
 
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
 #include <errno.h>
+#include <stdlib.h>
+#include <stdarg.h>
 #include "awk.h"
 #include "y.tab.h"
 
-uchar	*record;
-size_t	record_size;
+static FILE	*infile	= NULL;
+static char	*file	= "";
+char	*record;
+size_t	recsize;
+static char	*fields;
+static size_t	fieldssize = LINE_INCR;
 
 int	donefld;	/* 1 = implies rec broken into fields */
 int	donerec;	/* 1 = record is valid (no flds have changed) */
@@ -46,17 +53,13 @@ static struct fldtab_chunk {
 
 static	size_t	fldtab_maxidx;
 
-static FILE	*infile	= NULL;
-static uchar	*file	= (uchar*) "";
-static uchar	*fields;
-static size_t	fields_size = LINE_INCR;
 
 static int	maxfld	= 0;	/* last used field */
 static int	argno	= 1;	/* current input argument number */
 
-static	uchar	*getargv(int);
+static	char	*getargv(int);
 static	void	cleanfld(int, int);
-static	int	refldbld(uchar *, uchar *);
+static	int	refldbld(const char *, const char *);
 static	void	bcheck2(int, int, int);
 static	void	eprint(void);
 static	void	bclass(int);
@@ -65,7 +68,7 @@ static void
 initgetrec(void)
 {
 	int i;
-	uchar *p;
+	char *p;
 
 	for (i = 1; i < *ARGC; i++) {
 		if (!isclvar(p = getargv(i)))	/* find 1st real filename */
@@ -74,15 +77,14 @@ initgetrec(void)
 		argno++;
 	}
 	infile = stdin;		/* no filenames, so use stdin */
-	/* *FILENAME = file = (uchar*) "-"; */
 }
 
 int
-getrec(uchar **bufp, size_t *bufsizep)
+getrec(char **bufp, size_t *bufsizep)
 {
 	int c;
 	static int firsttime = 1;
-	uchar_t	*buf, *nbuf;
+	char	*buf, *nbuf;
 	size_t	len;
 
 	if (firsttime) {
@@ -110,8 +112,8 @@ getrec(uchar **bufp, size_t *bufsizep)
 			dprintf(("opening file %s\n", file));
 			if (*file == '-' && *(file+1) == '\0')
 				infile = stdin;
-			else if ((infile = fopen((char *)file, "r")) == NULL)
-				ERROR "can't open file %s", file FATAL;
+			else if ((infile = fopen(file, "r")) == NULL)
+				FATAL("can't open file %s", file);
 			(void) setfval(fnrloc, 0.0);
 		}
 		c = readrec(&nbuf, &len, infile);
@@ -123,13 +125,13 @@ getrec(uchar **bufp, size_t *bufsizep)
 
 		if (c != 0 || buf[0] != '\0') {	/* normal record */
 			if (bufp == &record) {
-				if (!(recloc->tval & DONTFREE))
+				if (freeable(recloc))
 					xfree(recloc->sval);
 				recloc->sval = record;
 				recloc->tval = REC | STR | DONTFREE;
 				if (is_number(recloc->sval)) {
 					recloc->fval =
-					    atof((const char *)recloc->sval);
+					    atof(recloc->sval);
 					recloc->tval |= NUM;
 				}
 			}
@@ -147,10 +149,10 @@ getrec(uchar **bufp, size_t *bufsizep)
 }
 
 int
-readrec(uchar **bufp, size_t *sizep, FILE *inf)	/* read one record into buf */
+readrec(char **bufp, size_t *sizep, FILE *inf)	/* read one record into buf */
 {
 	int sep, c;
-	uchar	*buf;
+	char	*buf;
 	int	count;
 	size_t	bufsize;
 
@@ -186,24 +188,24 @@ readrec(uchar **bufp, size_t *sizep, FILE *inf)	/* read one record into buf */
 }
 
 /* get ARGV[n] */
-static uchar *
+static char *
 getargv(int n)
 {
 	Cell *x;
-	uchar *s, temp[11];
+	char *s, temp[50];
 	extern Array *ARGVtab;
 
-	(void) sprintf((char *)temp, "%d", n);
-	x = setsymtab(temp, (uchar *)"", 0.0, STR, ARGVtab);
+	(void) sprintf(temp, "%d", n);
+	x = setsymtab(temp, "", 0.0, STR, ARGVtab);
 	s = getsval(x);
 	dprintf(("getargv(%d) returns |%s|\n", n, s));
 	return (s);
 }
 
 void
-setclvar(uchar *s)	/* set var=value from s */
+setclvar(char *s)	/* set var=value from s */
 {
-	uchar *p;
+	char *p;
 	Cell *q;
 
 	for (p = s; *p != '='; p++)
@@ -213,7 +215,7 @@ setclvar(uchar *s)	/* set var=value from s */
 	q = setsymtab(s, p, 0.0, STR, symtab);
 	(void) setsval(q, p);
 	if (is_number(q->sval)) {
-		q->fval = atof((const char *)q->sval);
+		q->fval = atof(q->sval);
 		q->tval |= NUM;
 	}
 	dprintf(("command line set %s to |%s|\n", s, p));
@@ -221,33 +223,33 @@ setclvar(uchar *s)	/* set var=value from s */
 }
 
 void
-fldbld(void)
+fldbld(void)	/* create fields from current record */
 {
-	uchar *r, *fr, sep;
+	char *r, *fr, sep;
 	Cell *p;
 	int i;
 	size_t	len;
 
 	if (donefld)
 		return;
-	if (!(recloc->tval & STR))
+	if (!isstr(recloc))
 		(void) getsval(recloc);
 	r = recloc->sval;	/* was record! */
 
 	/* make sure fields is always allocated */
-	adjust_buf(&fields, fields_size);
+	adjust_buf(&fields, fieldssize);
 
 	/*
 	 * make sure fields has enough size. We don't expand the buffer
 	 * in the middle of the loop, since p->sval has already pointed
 	 * the address in the fields.
 	 */
-	len = strlen((char *)r) + 1;
-	expand_buf(&fields, &fields_size, len);
+	len = strlen(r) + 1;
+	expand_buf(&fields, &fieldssize, len);
 	fr = fields;
 
 	i = 0;	/* number of fields accumulated here */
-	if (strlen((char *)*FS) > 1) {	/* it's a regular expression */
+	if (strlen(*FS) > 1) {	/* it's a regular expression */
 		i = refldbld(r, *FS);
 	} else if ((sep = **FS) == ' ') {
 		for (i = 0; ; ) {
@@ -257,7 +259,7 @@ fldbld(void)
 				break;
 			i++;
 			p = getfld(i);
-			if (!(p->tval & DONTFREE))
+			if (freeable(p))
 				xfree(p->sval);
 			p->sval = fr;
 			p->tval = FLD | STR | DONTFREE;
@@ -273,11 +275,11 @@ fldbld(void)
 		for (;;) {
 			i++;
 			p = getfld(i);
-			if (!(p->tval & DONTFREE))
+			if (freeable(p))
 				xfree(p->sval);
 			p->sval = fr;
 			p->tval = FLD | STR | DONTFREE;
-			/* \n always a separator */
+			/* \n is always a separator */
 			while (*r != sep && *r != '\n' && *r != '\0')
 				*fr++ = *r++;
 			*fr++ = 0;
@@ -293,7 +295,7 @@ fldbld(void)
 	for (i = 1; i <= maxfld; i++) {
 		p = getfld(i);
 		if (is_number(p->sval)) {
-			p->fval = atof((const char *)p->sval);
+			p->fval = atof(p->sval);
 			p->tval |= NUM;
 		}
 	}
@@ -310,16 +312,15 @@ fldbld(void)
 static void
 cleanfld(int n1, int n2)	/* clean out fields n1..n2 inclusive */
 {
-	static uchar *nullstat = (uchar *) "";
 	Cell *p;
-	int	i;
+	int i;
 
 	for (i = n2; i > n1; i--) {
 		p = getfld(i);
-		if (!(p->tval & DONTFREE))
+		if (freeable(p))
 			xfree(p->sval);
+		p->sval = "";
 		p->tval = FLD | STR | DONTFREE;
-		p->sval = nullstat;
 	}
 }
 
@@ -327,11 +328,11 @@ void
 newfld(int n)	/* add field n (after end) */
 {
 	if (n < 0)
-		ERROR "accessing invalid field", record FATAL;
+		FATAL("accessing invalid field", record);
 	(void) getfld(n);
 	cleanfld(maxfld, n);
 	maxfld = n;
-	(void) setfval(nfloc, (Awkfloat) n);
+	(void) setfval(nfloc, (Awkfloat)n);
 }
 
 /*
@@ -346,14 +347,14 @@ morefld(void)
 	Cell	*newfld;
 
 	if ((fldcp = calloc(sizeof (struct fldtab_chunk), 1)) == NULL)
-		ERROR "out of space in morefld" FATAL;
+		FATAL("out of space in morefld");
 
 	newfld = &fldcp->fields[0];
 	for (i = 0; i < FLD_INCR; i++) {
 		newfld[i].ctype = OCELL;
 		newfld[i].csub = CFLD;
 		newfld[i].nval = NULL;
-		newfld[i].sval = (uchar *)"";
+		newfld[i].sval = "";
 		newfld[i].fval = 0.0;
 		newfld[i].tval = FLD|STR|DONTFREE;
 		newfld[i].cnext = NULL;
@@ -378,7 +379,7 @@ getfld(int idx)
 	int	cbase;
 
 	if (idx < 0)
-		ERROR "trying to access field %d", idx FATAL;
+		FATAL("trying to access field %d", idx);
 	while (idx >= fldtab_maxidx)
 		morefld();
 	cbase = 0;
@@ -388,8 +389,7 @@ getfld(int idx)
 		cbase += FLD_INCR;
 	}
 	/* should never happen */
-	ERROR "trying to access invalid field %d", idx FATAL;
-	return (NULL);
+	FATAL("trying to access invalid field %d", idx);
 }
 
 int
@@ -407,28 +407,28 @@ fldidx(Cell *vp)
 		cbase += FLD_INCR;
 	}
 	/* should never happen */
-	ERROR "trying to access unknown field" FATAL;
-	return (0);
+	FATAL("trying to access unknown field");
 }
 
+/* build fields from reg expr in FS */
 static int
-refldbld(uchar *rec, uchar *fs)	/* build fields from reg expr in FS */
+refldbld(const char *rec, const char *fs)
 {
-	uchar *fr;
+	char *fr;
 	int i, tempstat;
 	fa *pfa;
 	Cell	*p;
 	size_t	len;
 
 	/* make sure fields is allocated */
-	adjust_buf(&fields, fields_size);
+	adjust_buf(&fields, fieldssize);
 	fr = fields;
 	*fr = '\0';
 	if (*rec == '\0')
 		return (0);
 
-	len = strlen((char *)rec) + 1;
-	expand_buf(&fields, &fields_size, len);
+	len = strlen(rec) + 1;
+	expand_buf(&fields, &fieldssize, len);
 	fr = fields;
 
 	pfa = makedfa(fs, 1);
@@ -436,21 +436,21 @@ refldbld(uchar *rec, uchar *fs)	/* build fields from reg expr in FS */
 	tempstat = pfa->initstat;
 	for (i = 1; ; i++) {
 		p = getfld(i);
-		if (!(p->tval & DONTFREE))
+		if (freeable(p))
 			xfree(p->sval);
 		p->tval = FLD | STR | DONTFREE;
 		p->sval = fr;
 		dprintf(("refldbld: i=%d\n", i));
 		if (nematch(pfa, rec)) {
-			pfa->initstat = 2;
+			pfa->initstat = 2;	/* horrible coupling to b.c */
 			dprintf(("match %s (%d chars)\n", patbeg, patlen));
-			(void) strncpy((char *)fr, (char *)rec, patbeg-rec);
+			(void) strncpy(fr, rec, patbeg-rec);
 			fr += patbeg - rec + 1;
 			*(fr-1) = '\0';
 			rec = patbeg + patlen;
 		} else {
 			dprintf(("no match %s\n", rec));
-			(void) strcpy((char *)fr, (char *)rec);
+			(void) strcpy(fr, rec);
 			pfa->initstat = tempstat;
 			break;
 		}
@@ -459,20 +459,20 @@ refldbld(uchar *rec, uchar *fs)	/* build fields from reg expr in FS */
 }
 
 void
-recbld(void)
+recbld(void)	/* create $0 from $1..$NF if necessary */
 {
 	int i;
-	uchar *p;
+	char *p;
 	size_t cnt, len, olen;
 
 	if (donerec == 1)
 		return;
 	cnt = 0;
-	olen = strlen((char *)*OFS);
+	olen = strlen(*OFS);
 	for (i = 1; i <= *NF; i++) {
 		p = getsval(getfld(i));
-		len = strlen((char *)p);
-		expand_buf(&record, &record_size, cnt + len + olen);
+		len = strlen(p);
+		expand_buf(&record, &recsize, cnt + len + olen);
 		(void) memcpy(&record[cnt], p, len);
 		cnt += len;
 		if (i < *NF) {
@@ -482,7 +482,7 @@ recbld(void)
 	}
 	record[cnt] = '\0';
 	dprintf(("in recbld FS=%o, recloc=%p\n", **FS, (void *)recloc));
-	if (!(recloc->tval & DONTFREE))
+	if (freeable(recloc))
 		xfree(recloc->sval);
 	recloc->tval = REC | STR | DONTFREE;
 	recloc->sval = record;
@@ -495,35 +495,45 @@ Cell *
 fieldadr(int n)
 {
 	if (n < 0)
-		ERROR "trying to access field %d", n FATAL;
+		FATAL("trying to access field %d", n);
 	return (getfld(n));
 }
 
 int	errorflag	= 0;
-char	errbuf[200];
 
 void
-yyerror(char *s)
+yyerror(const char *s)
+{
+	SYNTAX("%s", s);
+}
+
+void
+SYNTAX(const char *fmt, ...)
 {
-	extern uchar *cmdname, *curfname;
+	extern char *cmdname, *curfname;
 	static int been_here = 0;
+	va_list varg;
 
 	if (been_here++ > 2)
 		return;
-	(void) fprintf(stderr, "%s: %s", cmdname, s);
-	(void) fprintf(stderr, gettext(" at source line %lld"), lineno);
+	(void) fprintf(stderr, "%s: ", cmdname);
+	va_start(varg, fmt);
+	(void) vfprintf(stderr, fmt, varg);
+	va_end(varg);
+	(void) fprintf(stderr, " at source line %lld", lineno);
 	if (curfname != NULL)
-		(void) fprintf(stderr, gettext(" in function %s"), curfname);
+		(void) fprintf(stderr, " in function %s", curfname);
+	if (compile_time == 1 && cursource() != NULL)
+		(void) fprintf(stderr, " source file %s", cursource());
 	(void) fprintf(stderr, "\n");
 	errorflag = 2;
 	eprint();
 }
 
-/*ARGSUSED*/
 void
-fpecatch(int sig)
+fpecatch(int n)
 {
-	ERROR "floating point exception" FATAL;
+	FATAL("floating point exception %d", n);
 }
 
 extern int bracecnt, brackcnt, parencnt;
@@ -558,47 +568,74 @@ bcheck2(int n, int c1, int c2)
 }
 
 void
-error(int f, char *s)
+FATAL(const char *fmt, ...)
 {
-	extern Node *curnode;
-	extern uchar *cmdname;
+	extern char *cmdname;
+	va_list varg;
 
 	(void) fflush(stdout);
 	(void) fprintf(stderr, "%s: ", cmdname);
-	(void) fprintf(stderr, "%s", s);
+	va_start(varg, fmt);
+	(void) vfprintf(stderr, fmt, varg);
+	va_end(varg);
+	error();
+	if (dbg > 1)		/* core dump if serious debugging on */
+		abort();
+	exit(2);
+}
+
+void
+WARNING(const char *fmt, ...)
+{
+	extern char *cmdname;
+	va_list varg;
+
+	(void) fflush(stdout);
+	(void) fprintf(stderr, "%s: ", cmdname);
+	va_start(varg, fmt);
+	(void) vfprintf(stderr, fmt, varg);
+	va_end(varg);
+	error();
+}
+
+void
+error(void)
+{
+	extern Node *curnode;
+
 	(void) fprintf(stderr, "\n");
 	if (compile_time != 2 && NR && *NR > 0) {
 		(void) fprintf(stderr,
 		    gettext(" input record number %g"), *FNR);
-		if (strcmp((char *)*FILENAME, "-") != 0)
+		if (strcmp(*FILENAME, "-") != 0)
 			(void) fprintf(stderr, gettext(", file %s"), *FILENAME);
 		(void) fprintf(stderr, "\n");
 	}
 	if (compile_time != 2 && curnode)
-		(void) fprintf(stderr, gettext(" source line number %lld\n"),
+		(void) fprintf(stderr, gettext(" source line number %lld"),
 		    curnode->lineno);
 	else if (compile_time != 2 && lineno) {
 		(void) fprintf(stderr,
-		    gettext(" source line number %lld\n"), lineno);
+		    gettext(" source line number %lld"), lineno);
 	}
+	if (compile_time == 1 && cursource() != NULL)
+		(void) fprintf(stderr, gettext(" source file %s"), cursource());
+	(void) fprintf(stderr, "\n");
 	eprint();
-	if (f) {
-		if (dbg)
-			abort();
-		exit(2);
-	}
 }
 
 static void
 eprint(void)	/* try to print context around error */
 {
-	uchar *p, *q;
+	char *p, *q;
 	int c;
 	static int been_here = 0;
-	extern uchar ebuf[300], *ep;
+	extern char ebuf[], *ep;
 
 	if (compile_time == 2 || compile_time == 0 || been_here++ > 0)
 		return;
+	if (ebuf == ep)
+		return;
 	p = ep - 1;
 	if (p > ebuf && *p == '\n')
 		p--;
@@ -640,30 +677,22 @@ bclass(int c)
 }
 
 double
-errcheck(double x, char *s)
+errcheck(double x, const char *s)
 {
-	extern int errno;
-
 	if (errno == EDOM) {
 		errno = 0;
-		ERROR "%s argument out of domain", s WARNING;
+		WARNING("%s argument out of domain", s);
 		x = 1;
 	} else if (errno == ERANGE) {
 		errno = 0;
-		ERROR "%s result out of range", s WARNING;
+		WARNING("%s result out of range", s);
 		x = 1;
 	}
 	return (x);
 }
 
-void
-PUTS(uchar *s)
-{
-	dprintf(("%s\n", s));
-}
-
 int
-isclvar(uchar *s)	/* is s of form var=something? */
+isclvar(const char *s)	/* is s of form var=something ? */
 {
 	if (s != NULL) {
 
@@ -689,11 +718,11 @@ isclvar(uchar *s)	/* is s of form var=something? */
 #define	MAXEXPON	38	/* maximum exponent for fp number */
 
 int
-is_number(uchar *s)
+is_number(const char *s)
 {
 	int d1, d2;
 	int point;
-	uchar *es;
+	const char *es;
 	extern char	radixpoint;
 
 	d1 = d2 = point = 0;
@@ -751,12 +780,12 @@ is_number(uchar *s)
 }
 
 void
-init_buf(uchar **optr, size_t *sizep, size_t amt)
+init_buf(char **optr, size_t *sizep, size_t amt)
 {
-	uchar	*nptr = NULL;
+	char	*nptr = NULL;
 
 	if ((nptr = malloc(amt)) == NULL)
-		ERROR "out of space in init_buf" FATAL;
+		FATAL("out of space in init_buf");
 	/* initial buffer should have NULL terminated */
 	*nptr = '\0';
 	if (sizep != NULL)
@@ -765,9 +794,9 @@ init_buf(uchar **optr, size_t *sizep, size_t amt)
 }
 
 void
-r_expand_buf(uchar **optr, size_t *sizep, size_t req)
+r_expand_buf(char **optr, size_t *sizep, size_t req)
 {
-	uchar	*nptr;
+	char	*nptr;
 	size_t	amt, size = *sizep;
 
 	if (size != 0 && req < (size - 1))
@@ -776,7 +805,7 @@ r_expand_buf(uchar **optr, size_t *sizep, size_t req)
 	amt = (amt / LINE_INCR + 1) * LINE_INCR;
 
 	if ((nptr = realloc(*optr, size + amt)) == NULL)
-		ERROR "out of space in expand_buf" FATAL;
+		FATAL("out of space in expand_buf");
 	/* initial buffer should have NULL terminated */
 	if (size == 0)
 		*nptr = '\0';
@@ -785,11 +814,11 @@ r_expand_buf(uchar **optr, size_t *sizep, size_t req)
 }
 
 void
-adjust_buf(uchar **optr, size_t size)
+adjust_buf(char **optr, size_t size)
 {
-	uchar	*nptr;
+	char	*nptr;
 
 	if ((nptr = realloc(*optr, size)) == NULL)
-		ERROR "out of space in adjust_buf" FATAL;
+		FATAL("out of space in adjust_buf");
 	*optr = nptr;
 }
diff --git a/usr/src/cmd/awk/main.c b/usr/src/cmd/awk/main.c
index b0c9d5ae98..2bff4d7ddd 100644
--- a/usr/src/cmd/awk/main.c
+++ b/usr/src/cmd/awk/main.c
@@ -22,10 +22,10 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T. All Rights Reserved.
  */
 
-/*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
-/*	  All Rights Reserved  	*/
 
 #include <stdio.h>
 #include <ctype.h>
@@ -42,20 +42,20 @@
 char	*version = "version Oct 11, 1989";
 
 int	dbg	= 0;
-uchar	*cmdname;	/* gets argv[0] for error messages */
-uchar	*lexprog;	/* points to program argument if it exists */
+char	*cmdname;	/* gets argv[0] for error messages */
+char	*lexprog;	/* points to program argument if it exists */
 int	compile_time = 2;	/* for error printing: */
 				/* 2 = cmdline, 1 = compile, 0 = running */
 char	radixpoint = '.';
 
-static uchar	**pfile = NULL;	/* program filenames from -f's */
+static char	**pfile = NULL;	/* program filenames from -f's */
 static int	npfile = 0;	/* number of filenames */
 static int	curpfile = 0;	/* current filename */
 
 int
 main(int argc, char *argv[], char *envp[])
 {
-	uchar *fs = NULL;
+	const char *fs = NULL;
 	char	*nl_radix;
 	/*
 	 * At this point, numbers are still scanned as in
@@ -68,7 +68,7 @@ main(int argc, char *argv[], char *envp[])
 #define	TEXT_DOMAIN	"SYS_TEST"	/* Use this only if it weren't */
 #endif
 	(void) textdomain(TEXT_DOMAIN);
-	cmdname = (uchar *)argv[0];
+	cmdname = argv[0];
 	if (argc == 1) {
 		(void) fprintf(stderr, gettext(
 		    "Usage: %s [-f programfile | 'program'] [-Ffieldsep] "
@@ -79,7 +79,7 @@ main(int argc, char *argv[], char *envp[])
 	yyin = NULL;
 	syminit();
 	while (argc > 1 && argv[1][0] == '-' && argv[1][1] != '\0') {
-		if (strcmp(argv[1], "--") == 0) {
+		if (strncmp(argv[1], "--", 2) == 0) {
 			/* explicit end of args */
 			argc--;
 			argv++;
@@ -90,37 +90,37 @@ main(int argc, char *argv[], char *envp[])
 			argc--;
 			argv++;
 			if (argc <= 1)
-				ERROR "no program filename" FATAL;
-			pfile = realloc(pfile, sizeof (uchar *) * (npfile + 1));
+				FATAL("no program filename");
+			pfile = realloc(pfile, sizeof (char *) * (npfile + 1));
 			if (pfile == NULL)
-				ERROR "out of space in main" FATAL;
-			pfile[npfile++] = (uchar *)argv[1];
+				FATAL("out of space in main");
+			pfile[npfile++] = argv[1];
 			break;
 		case 'F':	/* set field separator */
 			if (argv[1][2] != 0) {	/* arg is -Fsomething */
 				/* wart: t=>\t */
 				if (argv[1][2] == 't' && argv[1][3] == 0)
-					fs = (uchar *) "\t";
+					fs = "\t";
 				else if (argv[1][2] != 0)
-					fs = (uchar *)&argv[1][2];
+					fs = &argv[1][2];
 			} else {		/* arg is -F something */
 				argc--; argv++;
 				if (argc > 1) {
 					/* wart: t=>\t */
 					if (argv[1][0] == 't' &&
 					    argv[1][1] == 0)
-						fs = (uchar *) "\t";
+						fs = "\t";
 					else if (argv[1][0] != 0)
-						fs = (uchar *)&argv[1][0];
+						fs = &argv[1][0];
 				}
 			}
 			if (fs == NULL || *fs == '\0')
-				ERROR "field separator FS is empty" WARNING;
+				WARNING("field separator FS is empty");
 			break;
 		case 'v':	/* -v a=1 to be done NOW.  one -v for each */
 			if (argv[1][2] == '\0' && --argc > 1 &&
-			    isclvar((uchar *)(++argv)[1]))
-				setclvar((uchar *)argv[1]);
+			    isclvar((++argv)[1]))
+				setclvar(argv[1]);
 			break;
 		case 'd':
 			dbg = atoi(&argv[1][2]);
@@ -129,7 +129,7 @@ main(int argc, char *argv[], char *envp[])
 			(void) printf("awk %s\n", version);
 			break;
 		default:
-			ERROR "unknown option %s ignored", argv[1] WARNING;
+			WARNING("unknown option %s ignored", argv[1]);
 			break;
 		}
 		argc--;
@@ -140,18 +140,18 @@ main(int argc, char *argv[], char *envp[])
 		if (argc <= 1) {
 			if (dbg)
 				exit(0);
-			ERROR "no program given" FATAL;
+			FATAL("no program given");
 		}
 		dprintf(("program = |%s|\n", argv[1]));
-		lexprog = (uchar *)argv[1];
+		lexprog = argv[1];
 		argc--;
 		argv++;
 	}
 	compile_time = 1;
-	argv[0] = (char *)cmdname;	/* put prog name at front of arglist */
+	argv[0] = cmdname;	/* put prog name at front of arglist */
 	dprintf(("argc=%d, argv[0]=%s\n", argc, argv[0]));
-	arginit(argc, (uchar **)argv);
-	envinit((uchar **)envp);
+	arginit(argc, argv);
+	envinit(envp);
 	(void) yyparse();
 	if (fs)
 		*FS = qstring(fs, '\0');
@@ -173,7 +173,7 @@ main(int argc, char *argv[], char *envp[])
 }
 
 int
-pgetc(void)		/* get program character */
+pgetc(void)		/* get 1 character from awk program */
 {
 	int c;
 
@@ -181,12 +181,12 @@ pgetc(void)		/* get program character */
 		if (yyin == NULL) {
 			if (curpfile >= npfile)
 				return (EOF);
-			yyin = (strcmp((char *)pfile[curpfile], "-") == 0) ?
-			    stdin : fopen((char *)pfile[curpfile], "r");
+			yyin = (strcmp(pfile[curpfile], "-") == 0) ?
+			    stdin : fopen(pfile[curpfile], "r");
 			if (yyin == NULL) {
-				ERROR "can't open file %s",
-				    pfile[curpfile] FATAL;
+				FATAL("can't open file %s", pfile[curpfile]);
 			}
+			lineno = 1;
 		}
 		if ((c = getc(yyin)) != EOF)
 			return (c);
@@ -195,3 +195,12 @@ pgetc(void)		/* get program character */
 		curpfile++;
 	}
 }
+
+char *
+cursource(void)	/* current source file name */
+{
+	if (npfile > 0)
+		return (pfile[curpfile]);
+	else
+		return (NULL);
+}
diff --git a/usr/src/cmd/awk/maketab.c b/usr/src/cmd/awk/maketab.c
index 5c7d8601ea..6f7738cfb8 100644
--- a/usr/src/cmd/awk/maketab.c
+++ b/usr/src/cmd/awk/maketab.c
@@ -21,10 +21,15 @@
 
 /*
  * Copyright (c) 1989, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T. All Rights Reserved.
+ * Copyright (c) Lucent Technologies 1997. All Rights Reserved.
  */
 
-/*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
-/*	  All Rights Reserved  	*/
+/*
+ * this program makes the table to link function names
+ * and type indices that is used by execute() in run.c.
+ * it finds the indices in ytab.h, produced by yacc.
+ */
 
 #include <stdio.h>
 #include <string.h>
@@ -35,8 +40,8 @@
 
 struct xx {
 	int token;
-	char *name;
-	char *pname;
+	const char *name;
+	const char *pname;
 } proc[] = {
 	{ PROGRAM, "program", NULL },
 	{ BOR, "boolop", " || " },
@@ -54,7 +59,7 @@ struct xx {
 	{ SUB, "sub", "sub" },
 	{ GSUB, "gsub", "gsub" },
 	{ INDEX, "sindex", "sindex" },
-	{ SPRINTF, "a_sprintf", "sprintf " },
+	{ SPRINTF, "awksprintf", "sprintf " },
 	{ ADD, "arith", " + " },
 	{ MINUS, "arith", " - " },
 	{ MULT, "arith", " * " },
@@ -73,10 +78,10 @@ struct xx {
 	{ NOTMATCH, "matchop", " !~ " },
 	{ MATCHFCN, "matchop", "matchop" },
 	{ INTEST, "intest", "intest" },
-	{ PRINTF, "aprintf", "printf" },
-	{ PRINT, "print", "print" },
+	{ PRINTF, "awkprintf", "printf" },
+	{ PRINT, "printstat", "print" },
 	{ CLOSE, "closefile", "closefile" },
-	{ DELETE, "delete", "delete" },
+	{ DELETE, "awkdelete", "awkdelete" },
 	{ SPLIT, "split", "split" },
 	{ ASSIGN, "assign", " = " },
 	{ ADDEQ, "assign", " += " },
@@ -100,23 +105,24 @@ struct xx {
 	{ CALL, "call", "call" },
 	{ ARG, "arg", "arg" },
 	{ VARNF, "getnf", "NF" },
-	{ GETLINE, "getaline", "getline" },
+	{ GETLINE, "awkgetline", "getline" },
 	{ 0, "", "" },
 };
 
-#define	SIZE	LASTTOKEN - FIRSTTOKEN + 1
-char *table[SIZE];
+#define	SIZE	(LASTTOKEN - FIRSTTOKEN + 1)
+const char *table[SIZE];
 char *names[SIZE];
 
 int
-main()
+main(int argc, char *argv[])
 {
-	struct xx *p;
+	const struct xx *p;
 	int i, n, tok;
 	char c;
 	FILE *fp;
-	char buf[100], name[100], def[100];
+	char buf[200], name[200], def[200];
 
+	printf("#include <stdio.h>\n");
 	printf("#include \"awk.h\"\n");
 	printf("#include \"y.tab.h\"\n\n");
 
@@ -124,28 +130,28 @@ main()
 		fprintf(stderr, gettext("maketab can't open y.tab.h!\n"));
 		exit(1);
 	}
-	printf("static uchar *printname[%d] = {\n", SIZE);
+	printf("static char *printname[%d] = {\n", SIZE);
 	i = 0;
 	while (fgets(buf, sizeof (buf), fp) != NULL) {
 		n = sscanf(buf, "%1c %s %s %d", &c, def, name, &tok);
-		/* not a valid #define? */
-		if (c != '#' || n != 4 && strcmp(def, "define") != 0)
+		/* not a valid #define */
+		if (c != '#' || (n != 4 && strcmp(def, "define") != 0))
 			continue;
 		if (tok < FIRSTTOKEN || tok > LASTTOKEN) {
 			fprintf(stderr, gettext("maketab funny token %d %s\n"),
 			    tok, buf);
 			exit(1);
 		}
-		names[tok-FIRSTTOKEN] = malloc(strlen(name)+1);
+		names[tok-FIRSTTOKEN] = (char *)malloc(strlen(name)+1);
 		strcpy(names[tok-FIRSTTOKEN], name);
-		printf("\t(uchar *) \"%s\",\t/* %d */\n", name, tok);
+		printf("\t(char *) \"%s\",\t/* %d */\n", name, tok);
 		i++;
 	}
 	printf("};\n\n");
 
 	for (p = proc; p->token != 0; p++)
 		table[p->token-FIRSTTOKEN] = p->name;
-	printf("\nCell *(*proctab[%d])() = {\n", SIZE);
+	printf("\nCell *(*proctab[%d])(Node **, int) = {\n", SIZE);
 	for (i = 0; i < SIZE; i++)
 		if (table[i] == 0)
 			printf("\tnullproc,\t/* %s */\n", names[i]);
@@ -153,14 +159,14 @@ main()
 			printf("\t%s,\t/* %s */\n", table[i], names[i]);
 	printf("};\n\n");
 
-	printf("uchar *\ntokname(int n)\n");	/* print a tokname() function */
+	printf("char *\ntokname(int n)\n");	/* print a tokname() function */
 	printf("{\n");
 	printf("	static char buf[100];\n\n");
 	printf("	if (n < FIRSTTOKEN || n > LASTTOKEN) {\n");
 	printf("		(void) sprintf(buf, \"token %%d\", n);\n");
-	printf("		return ((uchar *)buf);\n");
+	printf("		return (buf);\n");
 	printf("	}\n");
-	printf("	return printname[n-257];\n");
+	printf("	return printname[n-FIRSTTOKEN];\n");
 	printf("}\n");
-	exit(0);
+	return (0);
 }
diff --git a/usr/src/cmd/awk/parse.c b/usr/src/cmd/awk/parse.c
index 909977f10f..91fc30c33c 100644
--- a/usr/src/cmd/awk/parse.c
+++ b/usr/src/cmd/awk/parse.c
@@ -23,13 +23,12 @@
 /*
  * Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T. All Rights Reserved.
+ *
+ * Copyright (C) Lucent Technologies 1997. All Rights Reserved.
  */
 
-/*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
-/*	  All Rights Reserved  	*/
-
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #define	DEBUG
 #include "awk.h"
 #include "y.tab.h"
@@ -37,11 +36,11 @@
 Node *
 nodealloc(int n)
 {
-	register Node *x;
+	Node *x;
 
 	x = (Node *)malloc(sizeof (Node) + (n - 1) * sizeof (Node *));
 	if (x == NULL)
-		ERROR "out of space in nodealloc" FATAL;
+		FATAL("out of space in nodealloc");
 	x->nnext = NULL;
 	x->lineno = lineno;
 	return (x);
@@ -57,7 +56,7 @@ exptostat(Node *a)
 Node *
 node1(int a, Node *b)
 {
-	register Node *x;
+	Node *x;
 
 	x = nodealloc(1);
 	x->nobj = a;
@@ -68,7 +67,7 @@ node1(int a, Node *b)
 Node *
 node2(int a, Node *b, Node *c)
 {
-	register Node *x;
+	Node *x;
 
 	x = nodealloc(2);
 	x->nobj = a;
@@ -80,7 +79,7 @@ node2(int a, Node *b, Node *c)
 Node *
 node3(int a, Node *b, Node *c, Node *d)
 {
-	register Node *x;
+	Node *x;
 
 	x = nodealloc(3);
 	x->nobj = a;
@@ -93,7 +92,8 @@ node3(int a, Node *b, Node *c, Node *d)
 Node *
 node4(int a, Node *b, Node *c, Node *d, Node *e)
 {
-	register Node *x;
+	Node *x;
+
 	x = nodealloc(4);
 	x->nobj = a;
 	x->narg[0] = b;
@@ -104,89 +104,89 @@ node4(int a, Node *b, Node *c, Node *d, Node *e)
 }
 
 Node *
-stat3(int a, Node *b, Node *c, Node *d)
+stat1(int a, Node *b)
 {
-	register Node *x;
+	Node *x;
 
-	x = node3(a, b, c, d);
+	x = node1(a, b);
 	x->ntype = NSTAT;
 	return (x);
 }
 
 Node *
-op2(int a, Node *b, Node *c)
+stat2(int a, Node *b, Node *c)
 {
-	register Node *x;
+	Node *x;
 
 	x = node2(a, b, c);
-	x->ntype = NEXPR;
+	x->ntype = NSTAT;
 	return (x);
 }
 
 Node *
-op1(int a, Node *b)
+stat3(int a, Node *b, Node *c, Node *d)
 {
-	register Node *x;
+	Node *x;
 
-	x = node1(a, b);
-	x->ntype = NEXPR;
+	x = node3(a, b, c, d);
+	x->ntype = NSTAT;
 	return (x);
 }
 
 Node *
-stat1(int a, Node *b)
+stat4(int a, Node *b, Node *c, Node *d, Node *e)
 {
-	register Node *x;
+	Node *x;
 
-	x = node1(a, b);
+	x = node4(a, b, c, d, e);
 	x->ntype = NSTAT;
 	return (x);
 }
 
 Node *
-op3(int a, Node *b, Node *c, Node *d)
+op1(int a, Node *b)
 {
-	register Node *x;
+	Node *x;
 
-	x = node3(a, b, c, d);
+	x = node1(a, b);
 	x->ntype = NEXPR;
 	return (x);
 }
 
 Node *
-op4(int a, Node *b, Node *c, Node *d, Node *e)
+op2(int a, Node *b, Node *c)
 {
-	register Node *x;
+	Node *x;
 
-	x = node4(a, b, c, d, e);
+	x = node2(a, b, c);
 	x->ntype = NEXPR;
 	return (x);
 }
 
 Node *
-stat2(int a, Node *b, Node *c)
+op3(int a, Node *b, Node *c, Node *d)
 {
-	register Node *x;
+	Node *x;
 
-	x = node2(a, b, c);
-	x->ntype = NSTAT;
+	x = node3(a, b, c, d);
+	x->ntype = NEXPR;
 	return (x);
 }
 
 Node *
-stat4(int a, Node *b, Node *c, Node *d, Node *e)
+op4(int a, Node *b, Node *c, Node *d, Node *e)
 {
-	register Node *x;
+	Node *x;
 
 	x = node4(a, b, c, d, e);
-	x->ntype = NSTAT;
+	x->ntype = NEXPR;
 	return (x);
 }
 
 Node *
-valtonode(Cell *a, int b)
+celltonode(Cell *a, int b)
 {
-	register Node *x;
+	Node *x;
 
 	a->ctype = OCELL;
 	a->csub = b;
@@ -196,10 +196,9 @@ valtonode(Cell *a, int b)
 }
 
 Node *
-rectonode(void)
+rectonode(void)	/* make $0 into a Node */
 {
-	/* return valtonode(lookup("$0", symtab), CFLD); */
-	return (valtonode(recloc, CFLD));
+	return (celltonode(recloc, CFLD));
 }
 
 Node *
@@ -209,23 +208,26 @@ makearr(Node *p)
 
 	if (isvalue(p)) {
 		cp = (Cell *)(p->narg[0]);
-		if (isfunc(cp))
-			ERROR "%s is a function, not an array", cp->nval SYNTAX;
+		if (isfcn(cp))
+			SYNTAX("%s is a function, not an array", cp->nval);
 		else if (!isarr(cp)) {
 			xfree(cp->sval);
-			cp->sval = (uchar *)makesymtab(NSYMTAB);
+			cp->sval = (char *)makesymtab(NSYMTAB);
 			cp->tval = ARR;
 		}
 	}
 	return (p);
 }
 
+int	paircnt;	/* number of them in use */
+int	*pairstack;	/* state of each pat,pat */
+
 Node *
-pa2stat(Node *a, Node *b, Node *c)
+pa2stat(Node *a, Node *b, Node *c)	/* pat, pat {...} */
 {
-	register Node *x;
+	Node *x;
 
-	x = node4(PASTAT2, a, b, c, (Node *)paircnt);
+	x = node4(PASTAT2, a, b, c, itonp(paircnt));
 	paircnt++;
 	x->ntype = NSTAT;
 	return (x);
@@ -234,7 +236,7 @@ pa2stat(Node *a, Node *b, Node *c)
 Node *
 linkum(Node *a, Node *b)
 {
-	register Node *c;
+	Node *c;
 
 	if (errorflag)	/* don't link things that are wrong */
 		return (a);
@@ -248,19 +250,21 @@ linkum(Node *a, Node *b)
 	return (a);
 }
 
+/* turn on FCN bit in definition, */
+/* body of function, arglist */
 void
-defn(Cell *v, Node *vl, Node *st)	/* turn on FCN bit in definition */
+defn(Cell *v, Node *vl, Node *st)
 {
 	Node *p;
 	int n;
 
 	if (isarr(v)) {
-		ERROR "`%s' is an array name and a function name",
-		    v->nval SYNTAX;
+		SYNTAX("`%s' is an array name and a function name", v->nval);
 		return;
 	}
+
 	v->tval = FCN;
-	v->sval = (uchar *)st;
+	v->sval = (char *)st;
 	n = 0;	/* count arguments */
 	for (p = vl; p; p = p->nnext)
 		n++;
@@ -268,18 +272,29 @@ defn(Cell *v, Node *vl, Node *st)	/* turn on FCN bit in definition */
 	dprintf(("defining func %s (%d args)\n", v->nval, n));
 }
 
+/* is s in argument list for current function? */
+/* return -1 if not, otherwise arg # */
 int
-isarg(uchar *s)	/* is s in argument list for current function? */
+isarg(const char *s)
 {
 	extern Node *arglist;
 	Node *p = arglist;
 	int n;
 
-	for (n = 0; p != 0; p = p->nnext, n++) {
-		if (strcmp((char *)((Cell *)(p->narg[0]))->nval,
-		    (char *)s) == 0) {
+	for (n = 0; p != 0; p = p->nnext, n++)
+		if (strcmp(((Cell *)(p->narg[0]))->nval, s) == 0)
 			return (n);
-		}
-	}
 	return (-1);
 }
+
+int
+ptoi(void *p)	/* convert pointer to integer */
+{
+	return ((int)(long)p);	/* swearing that p fits, of course */
+}
+
+Node *
+itonp(int i)	/* and vice versa */
+{
+	return ((Node *)(long)i);
+}
diff --git a/usr/src/cmd/awk/run.c b/usr/src/cmd/awk/run.c
index 3cc8341d84..887f37caf8 100644
--- a/usr/src/cmd/awk/run.c
+++ b/usr/src/cmd/awk/run.c
@@ -21,23 +21,21 @@
 
 /*
  * Copyright (c) 1989, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) Lucent Technologies 1997. All Rights Reserved.
+ * Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T. All Rights Reserved.
  */
 
-/*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
-/*	  All Rights Reserved  	*/
-
-#define	tempfree(x, s)	if (istemp(x)) tfree(x, s)
-
-#define	execute(p) r_execute(p)
 
 #define	DEBUG
-#include	"awk.h"
-#include	<math.h>
-#include	"y.tab.h"
 #include	<stdio.h>
 #include	<ctype.h>
 #include	<setjmp.h>
+#include	<math.h>
 #include	<time.h>
+#include	"awk.h"
+#include	"y.tab.h"
+
+#define	tempfree(x)	if (istemp(x)) tfree(x)
 
 #ifndef	FOPEN_MAX
 #define	FOPEN_MAX	15	/* max number of open files, from ANSI std. */
@@ -46,19 +44,19 @@
 
 static jmp_buf env;
 
-static	Cell	*r_execute(Node *);
-static	Cell	*gettemp(char *), *copycell(Cell *);
-static	FILE	*openfile(int, uchar *), *redirect(int, Node *);
+static	Cell	*execute(Node *);
+static	Cell	*gettemp(void), *copycell(Cell *);
+static	FILE	*openfile(int, const char *), *redirect(int, Node *);
 
 int	paircnt;
-Node	*winner = NULL;
+Node	*winner = NULL;		/* root of parse tree */
 
-static Cell	*tmps;
+static Cell	*tmps;		/* free temporary cells for execution */
 
 static Cell	truecell	= { OBOOL, BTRUE, 0, 0, 1.0, NUM };
-Cell	*true	= &truecell;
+Cell	*True	= &truecell;
 static Cell	falsecell	= { OBOOL, BFALSE, 0, 0, 0.0, NUM };
-Cell	*false	= &falsecell;
+Cell	*False	= &falsecell;
 static Cell	breakcell	= { OJUMP, JBREAK, 0, 0, 0.0, NUM };
 Cell	*jbreak	= &breakcell;
 static Cell	contcell	= { OJUMP, JCONT, 0, 0, 0.0, NUM };
@@ -73,44 +71,83 @@ static Cell	tempcell	= { OCELL, CTEMP, 0, 0, 0.0, NUM };
 
 Node	*curnode = NULL;	/* the node being executed, for debugging */
 
-static	void	tfree(Cell *, char *);
+static	void	tfree(Cell *);
 static	void	closeall(void);
 static	double	ipow(double, int);
 
+/*
+ * buffer memory management
+ *
+ * pbuf:    address of pointer to buffer being managed
+ * psiz:    address of buffer size variable
+ * minlen:  minimum length of buffer needed
+ * quantum: buffer size quantum
+ * pbptr:   address of movable pointer into buffer, or 0 if none
+ * whatrtn: name of the calling routine if failure should cause fatal error
+ *
+ * return   0 for realloc failure, !=0 for success
+ */
+int
+adjbuf(char **pbuf, size_t *psiz, size_t minlen, size_t quantum, char **pbptr,
+    const char *whatrtn)
+{
+	if (minlen > *psiz) {
+		char *tbuf;
+		int rminlen = quantum ? minlen % quantum : 0;
+		int boff = pbptr ? *pbptr - *pbuf : 0;
+		/* round up to next multiple of quantum */
+		if (rminlen)
+			minlen += quantum - rminlen;
+		tbuf = (char *)realloc(*pbuf, minlen);
+		dprintf(("adjbuf %s: %d %d (pbuf=%p, tbuf=%p)\n", whatrtn,
+		    *psiz, minlen, (void *)*pbuf, (void *)tbuf));
+		if (tbuf == NULL) {
+			if (whatrtn)
+				FATAL("out of memory in %s", whatrtn);
+			return (0);
+		}
+		*pbuf = tbuf;
+		*psiz = minlen;
+		if (pbptr)
+			*pbptr = tbuf + boff;
+	}
+	return (1);
+}
+
 void
-run(Node *a)
+run(Node *a)	/* execution of parse tree starts here */
 {
 	(void) execute(a);
 	closeall();
 }
 
 static Cell *
-r_execute(Node *u)
+execute(Node *u)	/* execute a node of the parse tree */
 {
-	register Cell *(*proc)();
-	register Cell *x;
-	register Node *a;
+	Cell *(*proc)(Node **, int);
+	Cell *x;
+	Node *a;
 
 	if (u == NULL)
-		return (true);
+		return (True);
 	for (a = u; ; a = a->nnext) {
 		curnode = a;
 		if (isvalue(a)) {
 			x = (Cell *) (a->narg[0]);
-			if ((x->tval & FLD) && !donefld)
+			if (isfld(x) && !donefld)
 				fldbld();
-			else if ((x->tval & REC) && !donerec)
+			else if (isrec(x) && !donerec)
 				recbld();
 			return (x);
 		}
 		/* probably a Cell* but too risky to print */
 		if (notlegal(a->nobj))
-			ERROR "illegal statement" FATAL;
+			FATAL("illegal statement");
 		proc = proctab[a->nobj-FIRSTTOKEN];
 		x = (*proc)(a->narg, a->nobj);
-		if ((x->tval & FLD) && !donefld)
+		if (isfld(x) && !donefld)
 			fldbld();
-		else if ((x->tval & REC) && !donerec)
+		else if (isrec(x) && !donerec)
 			recbld();
 		if (isexpr(a))
 			return (x);
@@ -119,85 +156,88 @@ r_execute(Node *u)
 			return (x);
 		if (a->nnext == (Node *)NULL)
 			return (x);
-		tempfree(x, "execute");
+		tempfree(x);
 	}
 }
 
+/* execute an awk program */
+/* a[0] = BEGIN, a[1] = body, a[2] = END */
 /*ARGSUSED*/
 Cell *
 program(Node **a, int n)
 {
-	register Cell *x;
+	Cell *x;
 
 	if (setjmp(env) != 0)
 		goto ex;
 	if (a[0]) {		/* BEGIN */
 		x = execute(a[0]);
 		if (isexit(x))
-			return (true);
+			return (True);
 		if (isjump(x)) {
-			ERROR "illegal break, continue or next from BEGIN"
-			    FATAL;
+			FATAL("illegal break, continue, or next from BEGIN");
 		}
-		tempfree(x, "");
+		tempfree(x);
 	}
 loop:
 	if (a[1] || a[2])
-		while (getrec(&record, &record_size) > 0) {
+		while (getrec(&record, &recsize) > 0) {
 			x = execute(a[1]);
 			if (isexit(x))
 				break;
-			tempfree(x, "");
+			tempfree(x);
 		}
 ex:
-	if (setjmp(env) != 0)
+	if (setjmp(env) != 0)	/* handles exit within END */
 		goto ex1;
 	if (a[2]) {		/* END */
 		x = execute(a[2]);
 		if (iscont(x))	/* read some more */
 			goto loop;
 		if (isbreak(x) || isnext(x))
-			ERROR "illegal break or next from END" FATAL;
-		tempfree(x, "");
+			FATAL("illegal break or next from END");
+		tempfree(x);
 	}
 ex1:
-	return (true);
+	return (True);
 }
 
-struct Frame {
+struct Frame {	/* stack frame for awk function calls */
 	int nargs;	/* number of arguments in this call */
 	Cell *fcncell;	/* pointer to Cell for function */
 	Cell **args;	/* pointer to array of arguments after execute */
 	Cell *retval;	/* return value */
 };
 
-#define	NARGS	30
+#define	NARGS	30	/* max args in a call */
 
-struct Frame *frame = NULL; /* base of stack frames; dynamically allocated */
+struct Frame *frame = NULL;	/* base of stack frames; dynamically alloc'd */
 int	nframe = 0;		/* number of frames allocated */
 struct Frame *fp = NULL;	/* frame pointer. bottom level unused */
 
 /*ARGSUSED*/
 Cell *
-call(Node **a, int n)
+call(Node **a, int n)	/* function call.  very kludgy and fragile */
 {
 	static Cell newcopycell =
-		{ OCELL, CCOPY, 0, (uchar *) "", 0.0, NUM|STR|DONTFREE };
-	int i, ncall, ndef, freed = 0;
+		{ OCELL, CCOPY, 0, "", 0.0, NUM|STR|DONTFREE };
+	int i, ncall, ndef;
+	/* handles potential double freeing when fcn & param share a tempcell */
+	int freed = 0;
 	Node *x;
-	Cell *args[NARGS], *oargs[NARGS], *y, *z, *fcn;
-	uchar *s;
+	Cell *args[NARGS], *oargs[NARGS];	/* BUG: fixed size arrays */
+	Cell *y, *z, *fcn;
+	char *s;
 
 	fcn = execute(a[0]);	/* the function itself */
 	s = fcn->nval;
-	if (!isfunc(fcn))
-		ERROR "calling undefined function %s", s FATAL;
+	if (!isfcn(fcn))
+		FATAL("calling undefined function %s", s);
 	if (frame == NULL) {
 		fp = frame = (struct Frame *)calloc(nframe += 100,
 		    sizeof (struct Frame));
 		if (frame == NULL) {
-			ERROR "out of space for stack frames calling %s",
-			    s FATAL;
+			FATAL("out of space for stack frames calling %s", s);
 		}
 	}
 	for (ncall = 0, x = a[1]; x != NULL; x = x->nnext) /* args in call */
@@ -206,12 +246,12 @@ call(Node **a, int n)
 	dprintf(("calling %s, %d args (%d in defn), fp=%d\n",
 	    s, ncall, ndef, fp-frame));
 	if (ncall > ndef) {
-		ERROR "function %s called with %d args, uses only %d",
-		    s, ncall, ndef WARNING;
+		WARNING("function %s called with %d args, uses only %d",
+		    s, ncall, ndef);
 	}
 	if (ncall + ndef > NARGS) {
-		ERROR "function %s has %d arguments, limit %d",
-		    s, ncall+ndef, NARGS FATAL;
+		FATAL("function %s has %d arguments, limit %d",
+		    s, ncall+ndef, NARGS);
 	}
 	for (i = 0, x = a[1]; x != NULL; i++, x = x->nnext) {
 		/* get call args */
@@ -219,20 +259,20 @@ call(Node **a, int n)
 		y = execute(x);
 		oargs[i] = y;
 		dprintf(("args[%d]: %s %f <%s>, t=%o\n",
-		    i, y->nval, y->fval,
-		    isarr(y) ? "(array)" : (char *)y->sval, y->tval));
-		if (isfunc(y)) {
-			ERROR "can't use function %s as argument in %s",
-			    y->nval, s FATAL;
+		    i, NN(y->nval), y->fval,
+		    isarr(y) ? "(array)" : NN(y->sval), y->tval));
+		if (isfcn(y)) {
+			FATAL("can't use function %s as argument in %s",
+			    y->nval, s);
 		}
 		if (isarr(y))
 			args[i] = y;	/* arrays by ref */
 		else
 			args[i] = copycell(y);
-		tempfree(y, "callargs");
+		tempfree(y);
 	}
-	for (; i < ndef; i++) { /* add null args for ones not provided */
-		args[i] = gettemp("nullargs");
+	for (; i < ndef; i++) {	/* add null args for ones not provided */
+		args[i] = gettemp();
 		*args[i] = newcopycell;
 	}
 	fp++;	/* now ok to up frame */
@@ -241,13 +281,13 @@ call(Node **a, int n)
 		frame = (struct Frame *)
 		    realloc(frame, (nframe += 100) * sizeof (struct Frame));
 		if (frame == NULL)
-			ERROR "out of space for stack frames in %s", s FATAL;
+			FATAL("out of space for stack frames in %s", s);
 		fp = frame + dfp;
 	}
 	fp->fcncell = fcn;
 	fp->args = args;
 	fp->nargs = ndef;	/* number defined with (excess are locals) */
-	fp->retval = gettemp("retval");
+	fp->retval = gettemp();
 
 	dprintf(("start exec of %s, fp=%d\n", s, fp-frame));
 	/*LINTED align*/
@@ -265,20 +305,21 @@ call(Node **a, int n)
 					oargs[i]->tval = t->tval;
 					oargs[i]->tval &= ~(STR|NUM|DONTFREE);
 					oargs[i]->sval = t->sval;
-					tempfree(t, "oargsarr");
+					tempfree(t);
 				}
 			}
 		} else {
 			t->csub = CTEMP;
-			tempfree(t, "fp->args");
+			tempfree(t);
 			if (t == y) freed = 1;
 		}
 	}
-	tempfree(fcn, "call.fcn");
+	tempfree(fcn);
 	if (isexit(y) || isnext(y))
 		return (y);
-	if (!freed)
-		tempfree(y, "fcn ret"); /* this can free twice! */
+	if (freed == 0) {
+		tempfree(y);	/* don't free twice! */
+	}
 	z = fp->retval;			/* return value */
 	dprintf(("%s returns %g |%s| %o\n",
 	    s, getfval(z), getsval(z), z->tval));
@@ -291,7 +332,7 @@ copycell(Cell *x)	/* make a copy of a cell in a temp */
 {
 	Cell *y;
 
-	y = gettemp("copycell");
+	y = gettemp();
 	y->csub = CCOPY;	/* prevents freeing until call is over */
 	y->nval = x->nval;
 	y->sval = x->sval ? tostring(x->sval) : NULL;
@@ -303,30 +344,30 @@ copycell(Cell *x)	/* make a copy of a cell in a temp */
 
 /*ARGSUSED*/
 Cell *
-arg(Node **a, int nnn)
+arg(Node **a, int nnn)	/* nth argument of a function */
 {
 	int n;
 
-	n = (int)a[0];	/* argument number, counting from 0 */
+	n = ptoi(a[0]);	/* argument number, counting from 0 */
 	dprintf(("arg(%d), fp->nargs=%d\n", n, fp->nargs));
 	if (n+1 > fp->nargs) {
-		ERROR "argument #%d of function %s was not supplied",
-		    n+1, fp->fcncell->nval FATAL;
+		FATAL("argument #%d of function %s was not supplied",
+		    n+1, fp->fcncell->nval);
 	}
 	return (fp->args[n]);
 }
 
 Cell *
-jump(Node **a, int n)
+jump(Node **a, int n)	/* break, continue, next, nextfile, return */
 {
-	register Cell *y;
+	Cell *y;
 
 	switch (n) {
 	case EXIT:
 		if (a[0] != NULL) {
 			y = execute(a[0]);
 			errorflag = (int)getfval(y);
-			tempfree(y, "");
+			tempfree(y);
 		}
 		longjmp(env, 1);
 		/*NOTREACHED*/
@@ -341,7 +382,9 @@ jump(Node **a, int n)
 				(void) setsval(fp->retval, getsval(y));
 			else if (y->tval & NUM)
 				(void) setfval(fp->retval, getfval(y));
-			tempfree(y, "");
+			else		/* can't happen */
+				FATAL("bad type variable %d", y->tval);
+			tempfree(y);
 		}
 		return (jret);
 	case NEXT:
@@ -351,29 +394,31 @@ jump(Node **a, int n)
 	case CONTINUE:
 		return (jcont);
 	default:	/* can't happen */
-		ERROR "illegal jump type %d", n FATAL;
+		FATAL("illegal jump type %d", n);
 	}
 	/*NOTREACHED*/
 	return (NULL);
 }
 
 Cell *
-getaline(Node **a, int n)
+awkgetline(Node **a, int n)	/* get next line from specific input */
 {
 	/* a[0] is variable, a[1] is operator, a[2] is filename */
-	register Cell *r, *x;
-	uchar *buf;
+	Cell *r, *x;
+	char *buf;
 	FILE *fp;
 	size_t len;
+	int mode;
 
 	(void) fflush(stdout);	/* in case someone is waiting for a prompt */
-	r = gettemp("");
+	r = gettemp();
 	if (a[1] != NULL) {		/* getline < file */
 		x = execute(a[2]);		/* filename */
-		if ((int)a[1] == '|')	/* input pipe */
-			a[1] = (Node *)LE;	/* arbitrary flag */
-		fp = openfile((int)a[1], getsval(x));
-		tempfree(x, "");
+		mode = ptoi(a[1]);
+		if (mode == '|')	/* input pipe */
+			mode = LE;	/* arbitrary flag */
+		fp = openfile(mode, getsval(x));
+		tempfree(x);
 		buf = NULL;
 		if (fp == NULL)
 			n = -1;
@@ -385,7 +430,7 @@ getaline(Node **a, int n)
 			} else {			/* getline <file */
 				if (!(recloc->tval & DONTFREE))
 					xfree(recloc->sval);
-				expand_buf(&record, &record_size, len);
+				expand_buf(&record, &recsize, len);
 				(void) memcpy(record, buf, len);
 				record[len] = '\0';
 				recloc->sval = record;
@@ -397,7 +442,7 @@ getaline(Node **a, int n)
 			free(buf);
 	} else {			/* bare getline; use current input */
 		if (a[0] == NULL)	/* getline */
-			n = getrec(&record, &record_size);
+			n = getrec(&record, &recsize);
 		else {			/* getline var */
 			init_buf(&buf, &len, LINE_INCR);
 			n = getrec(&buf, &len);
@@ -411,7 +456,7 @@ getaline(Node **a, int n)
 
 /*ARGSUSED*/
 Cell *
-getnf(Node **a, int n)
+getnf(Node **a, int n)	/* get NF */
 {
 	if (donefld == 0)
 		fldbld();
@@ -420,23 +465,23 @@ getnf(Node **a, int n)
 
 /*ARGSUSED*/
 Cell *
-array(Node **a, int n)
+array(Node **a, int n)	/* a[0] is symtab, a[1] is list of subscripts */
 {
-	register Cell *x, *y, *z;
-	register uchar *s;
-	register Node *np;
-	uchar	*buf;
+	Cell *x, *y, *z;
+	char *s;
+	Node *np;
+	char *buf;
 	size_t	bsize, tlen, len, slen;
 
 	x = execute(a[0]);	/* Cell* for symbol table */
 	init_buf(&buf, &bsize, LINE_INCR);
 	buf[0] = '\0';
 	tlen = 0;
-	slen = strlen((char *)*SUBSEP);
+	slen = strlen(*SUBSEP);
 	for (np = a[1]; np; np = np->nnext) {
 		y = execute(np);	/* subscript */
 		s = getsval(y);
-		len = strlen((char *)s);
+		len = strlen(s);
 		expand_buf(&buf, &bsize, tlen + len + slen);
 		(void) memcpy(&buf[tlen], s, len);
 		tlen += len;
@@ -445,45 +490,45 @@ array(Node **a, int n)
 			tlen += slen;
 		}
 		buf[tlen] = '\0';
-		tempfree(y, "");
+		tempfree(y);
 	}
 	if (!isarr(x)) {
-		dprintf(("making %s into an array\n", x->nval));
+		dprintf(("making %s into an array\n", NN(x->nval)));
 		if (freeable(x))
 			xfree(x->sval);
 		x->tval &= ~(STR|NUM|DONTFREE);
 		x->tval |= ARR;
-		x->sval = (uchar *) makesymtab(NSYMTAB);
+		x->sval = (char *)makesymtab(NSYMTAB);
 	}
 	/*LINTED align*/
-	z = setsymtab(buf, (uchar *)"", 0.0, STR|NUM, (Array *)x->sval);
+	z = setsymtab(buf, "", 0.0, STR|NUM, (Array *)x->sval);
 	z->ctype = OCELL;
 	z->csub = CVAR;
-	tempfree(x, "");
+	tempfree(x);
 	free(buf);
 	return (z);
 }
 
 /*ARGSUSED*/
 Cell *
-delete(Node **a, int n)
+awkdelete(Node **a, int n)	/* a[0] is symtab, a[1] is list of subscripts */
 {
 	Cell *x, *y;
 	Node *np;
-	uchar *buf, *s;
+	char *buf, *s;
 	size_t bsize, tlen, slen, len;
 
 	x = execute(a[0]);	/* Cell* for symbol table */
 	if (!isarr(x))
-		return (true);
+		return (True);
 	init_buf(&buf, &bsize, LINE_INCR);
 	buf[0] = '\0';
 	tlen = 0;
-	slen = strlen((char *)*SUBSEP);
+	slen = strlen(*SUBSEP);
 	for (np = a[1]; np; np = np->nnext) {
 		y = execute(np);	/* subscript */
 		s = getsval(y);
-		len = strlen((char *)s);
+		len = strlen(s);
 		expand_buf(&buf, &bsize, tlen + len + slen);
 		(void) memcpy(&buf[tlen], s, len);
 		tlen += len;
@@ -492,39 +537,39 @@ delete(Node **a, int n)
 			tlen += slen;
 		}
 		buf[tlen] = '\0';
-		tempfree(y, "");
+		tempfree(y);
 	}
 	freeelem(x, buf);
-	tempfree(x, "");
+	tempfree(x);
 	free(buf);
-	return (true);
+	return (True);
 }
 
 /*ARGSUSED*/
 Cell *
-intest(Node **a, int n)
+intest(Node **a, int n)	/* a[0] is index (list), a[1] is symtab */
 {
-	register Cell *x, *ap, *k;
+	Cell *x, *ap, *k;
 	Node *p;
-	uchar *buf;
-	uchar *s;
+	char *buf;
+	char *s;
 	size_t bsize, tlen, slen, len;
 
 	ap = execute(a[1]);	/* array name */
 	if (!isarr(ap))
-		ERROR "%s is not an array", ap->nval FATAL;
+		FATAL("%s is not an array", ap->nval);
 	init_buf(&buf, &bsize, LINE_INCR);
 	buf[0] = 0;
 	tlen = 0;
-	slen = strlen((char *)*SUBSEP);
+	slen = strlen(*SUBSEP);
 	for (p = a[0]; p; p = p->nnext) {
 		x = execute(p);	/* expr */
 		s = getsval(x);
-		len = strlen((char *)s);
+		len = strlen(s);
 		expand_buf(&buf, &bsize, tlen + len + slen);
 		(void) memcpy(&buf[tlen], s, len);
 		tlen += len;
-		tempfree(x, "");
+		tempfree(x);
 		if (p->nnext) {
 			(void) memcpy(&buf[tlen], *SUBSEP, slen);
 			tlen += slen;
@@ -533,95 +578,95 @@ intest(Node **a, int n)
 	}
 	/*LINTED align*/
 	k = lookup(buf, (Array *)ap->sval);
-	tempfree(ap, "");
+	tempfree(ap);
 	free(buf);
 	if (k == NULL)
-		return (false);
+		return (False);
 	else
-		return (true);
+		return (True);
 }
 
 
 Cell *
-matchop(Node **a, int n)
+matchop(Node **a, int n)	/* ~ and match() */
 {
-	register Cell *x, *y;
-	register uchar *s, *t;
-	register int i;
+	Cell *x, *y;
+	char *s, *t;
+	int i;
 	fa *pfa;
-	int (*mf)() = match, mode = 0;
+	int (*mf)(fa *, const char *) = match, mode = 0;
 
 	if (n == MATCHFCN) {
 		mf = pmatch;
 		mode = 1;
 	}
-	x = execute(a[1]);
+	x = execute(a[1]);	/* a[1] = target text */
 	s = getsval(x);
-	if (a[0] == 0)
-		i = (*mf)(a[2], s);
+	if (a[0] == 0)		/* a[1] == 0: already-compiled reg expr */
+		i = (*mf)((fa *)a[2], s);
 	else {
-		y = execute(a[2]);
+		y = execute(a[2]);	/* a[2] = regular expr */
 		t = getsval(y);
 		pfa = makedfa(t, mode);
 		i = (*mf)(pfa, s);
-		tempfree(y, "");
+		tempfree(y);
 	}
-	tempfree(x, "");
+	tempfree(x);
 	if (n == MATCHFCN) {
 		int start = patbeg - s + 1;
 		if (patlen < 0)
 			start = 0;
 		(void) setfval(rstartloc, (Awkfloat)start);
 		(void) setfval(rlengthloc, (Awkfloat)patlen);
-		x = gettemp("");
+		x = gettemp();
 		x->tval = NUM;
 		x->fval = start;
 		return (x);
-	} else if (n == MATCH && i == 1 || n == NOTMATCH && i == 0)
-		return (true);
+	} else if ((n == MATCH && i == 1) || (n == NOTMATCH && i == 0))
+		return (True);
 	else
-		return (false);
+		return (False);
 }
 
 
 Cell *
-boolop(Node **a, int n)
+boolop(Node **a, int n)	/* a[0] || a[1], a[0] && a[1], !a[0] */
 {
-	register Cell *x, *y;
-	register int i;
+	Cell *x, *y;
+	int i;
 
 	x = execute(a[0]);
 	i = istrue(x);
-	tempfree(x, "");
+	tempfree(x);
 	switch (n) {
 	case BOR:
 		if (i)
-			return (true);
+			return (True);
 		y = execute(a[1]);
 		i = istrue(y);
-		tempfree(y, "");
-		return (i ? true : false);
+		tempfree(y);
+		return (i ? True : False);
 	case AND:
 		if (!i)
-			return (false);
+			return (False);
 		y = execute(a[1]);
 		i = istrue(y);
-		tempfree(y, "");
-		return (i ? true : false);
+		tempfree(y);
+		return (i ? True : False);
 	case NOT:
-		return (i ? false : true);
+		return (i ? False : True);
 	default:	/* can't happen */
-		ERROR "unknown boolean operator %d", n FATAL;
+		FATAL("unknown boolean operator %d", n);
 	}
 	/*NOTREACHED*/
 	return (NULL);
 }
 
 Cell *
-relop(Node **a, int n)
+relop(Node **a, int n)	/* a[0] < a[1], etc. */
 {
-	register int i;
-	register Cell *x, *y;
+	int i;
+	Cell *x, *y;
 	Awkfloat j;
 
 	x = execute(a[0]);
@@ -630,49 +675,48 @@ relop(Node **a, int n)
 		j = x->fval - y->fval;
 		i = j < 0 ? -1: (j > 0 ? 1: 0);
 	} else {
-		i = strcmp((char *)getsval(x), (char *)getsval(y));
+		i = strcmp(getsval(x), getsval(y));
 	}
-	tempfree(x, "");
-	tempfree(y, "");
+	tempfree(x);
+	tempfree(y);
 	switch (n) {
-	case LT:	return (i < 0 ? true : false);
-	case LE:	return (i <= 0 ? true : false);
-	case NE:	return (i != 0 ? true : false);
-	case EQ:	return (i == 0 ? true : false);
-	case GE:	return (i >= 0 ? true : false);
-	case GT:	return (i > 0 ? true : false);
+	case LT:	return (i < 0 ? True : False);
+	case LE:	return (i <= 0 ? True : False);
+	case NE:	return (i != 0 ? True : False);
+	case EQ:	return (i == 0 ? True : False);
+	case GE:	return (i >= 0 ? True : False);
+	case GT:	return (i > 0 ? True : False);
 	default:	/* can't happen */
-		ERROR "unknown relational operator %d", n FATAL;
+		FATAL("unknown relational operator %d", n);
 	}
 	/*NOTREACHED*/
-	return (false);
+	return (False);
 }
 
 static void
-tfree(Cell *a, char *s)
+tfree(Cell *a)	/* free a tempcell */
 {
-	if (dbg > 1) {
-		(void) printf("## tfree %.8s %06lo %s\n",
-		    s, (ulong_t)a, a->sval ? a->sval : (uchar *)"");
-	}
-	if (freeable(a))
+	if (freeable(a)) {
+		dprintf(("freeing %s %s %o\n",
+		    NN(a->nval), NN(a->sval), a->tval));
 		xfree(a->sval);
+	}
 	if (a == tmps)
-		ERROR "tempcell list is curdled" FATAL;
+		FATAL("tempcell list is curdled");
 	a->cnext = tmps;
 	tmps = a;
 }
 
 static Cell *
-gettemp(char *s)
+gettemp(void)	/* get a tempcell */
 {
 	int i;
-	register Cell *x;
+	Cell *x;
 
 	if (!tmps) {
 		tmps = (Cell *)calloc(100, sizeof (Cell));
 		if (!tmps)
-			ERROR "no space for temporaries" FATAL;
+			FATAL("out of space for temporaries");
 		for (i = 1; i < 100; i++)
 			tmps[i-1].cnext = &tmps[i];
 		tmps[i-1].cnext = 0;
@@ -680,52 +724,52 @@ gettemp(char *s)
 	x = tmps;
 	tmps = x->cnext;
 	*x = tempcell;
-	if (dbg > 1)
-		(void) printf("## gtemp %.8s %06lo\n", s, (ulong_t)x);
+	dprintf(("gtemp %.8s %06lo\n", NN(x->nval), (ulong_t)x));
 	return (x);
 }
 
 /*ARGSUSED*/
 Cell *
-indirect(Node **a, int n)
+indirect(Node **a, int n)	/* $( a[0] ) */
 {
-	register Cell *x;
-	register int m;
-	register uchar *s;
+	Cell *x;
+	int m;
+	char *s;
 
 	x = execute(a[0]);
 	m = (int)getfval(x);
 	if (m == 0 && !is_number(s = getsval(x)))	/* suspicion! */
-		ERROR "illegal field $(%s)", s FATAL;
-	tempfree(x, "");
+		FATAL("illegal field $(%s)", s);
+	tempfree(x);
 	x = fieldadr(m);
-	x->ctype = OCELL;
+	x->ctype = OCELL;	/* BUG?  why are these needed? */
 	x->csub = CFLD;
 	return (x);
 }
 
 /*ARGSUSED*/
 Cell *
-substr(Node **a, int nnn)
+substr(Node **a, int nnn)		/* substr(a[0], a[1], a[2]) */
 {
-	register int k, m, n;
-	register uchar *s;
+	int k, m, n;
+	char *s;
 	int temp;
-	register Cell *x, *y, *z;
+	Cell *x, *y, *z = NULL;
 
 	x = execute(a[0]);
 	y = execute(a[1]);
 	if (a[2] != 0)
 		z = execute(a[2]);
 	s = getsval(x);
-	k = strlen((char *)s) + 1;
+	k = strlen(s) + 1;
 	if (k <= 1) {
-		tempfree(x, "");
-		tempfree(y, "");
-		if (a[2] != 0)
-			tempfree(z, "");
-		x = gettemp("");
-		(void) setsval(x, (uchar *)"");
+		tempfree(x);
+		tempfree(y);
+		if (a[2] != 0) {
+			tempfree(z);
+		}
+		x = gettemp();
+		(void) setsval(x, "");
 		return (x);
 	}
 	m = (int)getfval(y);
@@ -733,10 +777,10 @@ substr(Node **a, int nnn)
 		m = 1;
 	else if (m > k)
 		m = k;
-	tempfree(y, "");
+	tempfree(y);
 	if (a[2] != 0) {
 		n = (int)getfval(z);
-		tempfree(z, "");
+		tempfree(z);
 	} else
 		n = k - 1;
 	if (n < 0)
@@ -744,21 +788,21 @@ substr(Node **a, int nnn)
 	else if (n > k - m)
 		n = k - m;
 	dprintf(("substr: m=%d, n=%d, s=%s\n", m, n, s));
-	y = gettemp("");
+	y = gettemp();
 	temp = s[n + m - 1];	/* with thanks to John Linderman */
 	s[n + m - 1] = '\0';
 	(void) setsval(y, s + m - 1);
 	s[n + m - 1] = temp;
-	tempfree(x, "");
+	tempfree(x);
 	return (y);
 }
 
 /*ARGSUSED*/
 Cell *
-sindex(Node **a, int nnn)
+sindex(Node **a, int nnn)		/* index(a[0], a[1]) */
 {
-	register Cell *x, *y, *z;
-	register uchar *s1, *s2, *p1, *p2, *q;
+	Cell *x, *y, *z;
+	char *s1, *s2, *p1, *p2, *q;
 	Awkfloat v = 0.0;
 
 	x = execute(a[0]);
@@ -766,7 +810,7 @@ sindex(Node **a, int nnn)
 	y = execute(a[1]);
 	s2 = getsval(y);
 
-	z = gettemp("");
+	z = gettemp();
 	for (p1 = s1; *p1 != '\0'; p1++) {
 		for (q = p1, p2 = s2; *p2 != '\0' && *q == *p2; q++, p2++)
 			;
@@ -775,20 +819,20 @@ sindex(Node **a, int nnn)
 			break;
 		}
 	}
-	tempfree(x, "");
-	tempfree(y, "");
+	tempfree(x);
+	tempfree(y);
 	(void) setfval(z, v);
 	return (z);
 }
 
 void
-format(uchar **bufp, uchar *s, Node *a)
+format(char **bufp, char *s, Node *a)
 {
-	uchar *fmt;
-	register uchar *os;
-	register Cell *x;
+	char *fmt;
+	const char *os;
+	Cell *x;
 	int flag = 0, len;
-	uchar_t	*buf;
+	char *buf;
 	size_t bufsize, fmtsize, cnt, tcnt, ret;
 
 	init_buf(&buf, &bufsize, LINE_INCR);
@@ -816,17 +860,17 @@ format(uchar **bufp, uchar *s, Node *a)
 				break;	/* the ansi panoply */
 			if (*s == '*') {
 				if (a == NULL) {
-					ERROR
-		"not enough args in printf(%s) or sprintf(%s)", os, os FATAL;
+					FATAL("not enough args in printf(%s) "
+					    "or sprintf(%s)", os, os);
 				}
 				x = execute(a);
 				a = a->nnext;
 				tcnt--;
 				expand_buf(&fmt, &fmtsize, tcnt + 12);
-				ret = sprintf((char *)&fmt[tcnt], "%d",
+				ret = sprintf(&fmt[tcnt], "%d",
 				    (int)getfval(x));
 				tcnt += ret;
-				tempfree(x, "");
+				tempfree(x);
 			}
 		}
 		fmt[tcnt] = '\0';
@@ -858,7 +902,7 @@ format(uchar **bufp, uchar *s, Node *a)
 			break;
 		}
 		if (flag == 0) {
-			len = strlen((char *)fmt);
+			len = strlen(fmt);
 			expand_buf(&buf, &bufsize, cnt + len);
 			(void) memcpy(&buf[cnt], fmt, len);
 			cnt += len;
@@ -866,8 +910,8 @@ format(uchar **bufp, uchar *s, Node *a)
 			continue;
 		}
 		if (a == NULL) {
-			ERROR
-	"not enough args in printf(%s) or sprintf(%s)", os, os FATAL;
+			FATAL("not enough args in printf(%s) "
+			    "or sprintf(%s)", os, os);
 		}
 		x = execute(a);
 		a = a->nnext;
@@ -878,33 +922,33 @@ format(uchar **bufp, uchar *s, Node *a)
 			switch (flag) {
 			case 1:
 				/*LINTED*/
-				ret = snprintf((char *)&buf[cnt], len,
-				    (char *)fmt, getfval(x));
+				ret = snprintf(&buf[cnt], len,
+				    fmt, getfval(x));
 				break;
 			case 2:
 				/*LINTED*/
-				ret = snprintf((char *)&buf[cnt], len,
-				    (char *)fmt, (long)getfval(x));
+				ret = snprintf(&buf[cnt], len,
+				    fmt, (long)getfval(x));
 				break;
 			case 3:
 				/*LINTED*/
-				ret = snprintf((char *)&buf[cnt], len,
-				    (char *)fmt, (int)getfval(x));
+				ret = snprintf(&buf[cnt], len,
+				    fmt, (int)getfval(x));
 				break;
 			case 4:
 				/*LINTED*/
-				ret = snprintf((char *)&buf[cnt], len,
-				    (char *)fmt, getsval(x));
+				ret = snprintf(&buf[cnt], len,
+				    fmt, getsval(x));
 				break;
 			case 5:
 				if (isnum(x)) {
 					/*LINTED*/
-					ret = snprintf((char *)&buf[cnt], len,
-					    (char *)fmt, (int)getfval(x));
+					ret = snprintf(&buf[cnt], len,
+					    fmt, (int)getfval(x));
 				} else {
 					/*LINTED*/
-					ret = snprintf((char *)&buf[cnt], len,
-					    (char *)fmt, getsval(x)[0]);
+					ret = snprintf(&buf[cnt], len,
+					    fmt, getsval(x)[0]);
 				}
 				break;
 			default:
@@ -914,7 +958,7 @@ format(uchar **bufp, uchar *s, Node *a)
 				break;
 			expand_buf(&buf, &bufsize, cnt + ret);
 		}
-		tempfree(x, "");
+		tempfree(x);
 		cnt += ret;
 		s++;
 	}
@@ -928,17 +972,17 @@ format(uchar **bufp, uchar *s, Node *a)
 
 /*ARGSUSED*/
 Cell *
-a_sprintf(Node **a, int n)
+awksprintf(Node **a, int n)		/* sprintf(a[0]) */
 {
-	register Cell *x;
-	register Node *y;
-	uchar *buf;
+	Cell *x;
+	Node *y;
+	char *buf;
 
 	y = a[0]->nnext;
 	x = execute(a[0]);
 	format(&buf, getsval(x), y);
-	tempfree(x, "");
-	x = gettemp("");
+	tempfree(x);
+	x = gettemp();
 	x->sval = buf;
 	x->tval = STR;
 	return (x);
@@ -946,44 +990,46 @@ a_sprintf(Node **a, int n)
 
 /*ARGSUSED*/
 Cell *
-aprintf(Node **a, int n)
+awkprintf(Node **a, int n)		/* printf */
 {
+	/* a[0] is list of args, starting with format string */
+	/* a[1] is redirection operator, a[2] is redirection file */
 	FILE *fp;
-	register Cell *x;
-	register Node *y;
-	uchar *buf;
+	Cell *x;
+	Node *y;
+	char *buf;
 
 	y = a[0]->nnext;
 	x = execute(a[0]);
 	format(&buf, getsval(x), y);
-	tempfree(x, "");
-	if (a[1] == NULL)
-		(void) fputs((char *)buf, stdout);
-	else {
-		fp = redirect((int)a[1], a[2]);
-		(void) fputs((char *)buf, fp);
+	tempfree(x);
+	if (a[1] == NULL) {
+		(void) fputs(buf, stdout);
+	} else {
+		fp = redirect(ptoi(a[1]), a[2]);
+		(void) fputs(buf, fp);
 		(void) fflush(fp);
 	}
 	free(buf);
-	return (true);
+	return (True);
 }
 
 Cell *
-arith(Node **a, int n)
+arith(Node **a, int n)	/* a[0] + a[1], etc.  also -a[0] */
 {
-	Awkfloat i, j;
+	Awkfloat i, j = 0;
 	double v;
-	register Cell *x, *y, *z;
+	Cell *x, *y, *z;
 
 	x = execute(a[0]);
 	i = getfval(x);
-	tempfree(x, "");
+	tempfree(x);
 	if (n != UMINUS) {
 		y = execute(a[1]);
 		j = getfval(y);
-		tempfree(y, "");
+		tempfree(y);
 	}
-	z = gettemp("");
+	z = gettemp();
 	switch (n) {
 	case ADD:
 		i += j;
@@ -996,12 +1042,12 @@ arith(Node **a, int n)
 		break;
 	case DIVIDE:
 		if (j == 0)
-			ERROR "division by zero" FATAL;
+			FATAL("division by zero");
 		i /= j;
 		break;
 	case MOD:
 		if (j == 0)
-			ERROR "division by zero in mod" FATAL;
+			FATAL("division by zero in mod");
 		(void) modf(i/j, &v);
 		i = i - j * v;
 		break;
@@ -1015,14 +1061,14 @@ arith(Node **a, int n)
 			i = errcheck(pow(i, j), "pow");
 		break;
 	default:	/* can't happen */
-		ERROR "illegal arithmetic operator %d", n FATAL;
+		FATAL("illegal arithmetic operator %d", n);
 	}
 	(void) setfval(z, i);
 	return (z);
 }
 
 static double
-ipow(double x, int n)
+ipow(double x, int n)	/* x**n.  ought to be done by pow, but isn't always */
 {
 	double v;
 
@@ -1036,10 +1082,10 @@ ipow(double x, int n)
 }
 
 Cell *
-incrdecr(Node **a, int n)
+incrdecr(Node **a, int n)		/* a[0]++, etc. */
 {
-	register Cell *x, *z;
-	register int k;
+	Cell *x, *z;
+	int k;
 	Awkfloat xf;
 
 	x = execute(a[0]);
@@ -1049,17 +1095,19 @@ incrdecr(Node **a, int n)
 		(void) setfval(x, xf + k);
 		return (x);
 	}
-	z = gettemp("");
+	z = gettemp();
 	(void) setfval(z, xf);
 	(void) setfval(x, xf + k);
-	tempfree(x, "");
+	tempfree(x);
 	return (z);
 }
 
+/* a[0] = a[1], a[0] += a[1], etc. */
+/* this is subtle; don't muck with it. */
 Cell *
 assign(Node **a, int n)
 {
-	register Cell *x, *y;
+	Cell *x, *y;
 	Awkfloat xf, yf;
 	double v;
 
@@ -1070,13 +1118,13 @@ assign(Node **a, int n)
 			(void) setsval(x, getsval(y));
 			x->fval = getfval(y);
 			x->tval |= NUM;
-		} else if (y->tval & STR)
+		} else if (isstr(y))
 			(void) setsval(x, getsval(y));
-		else if (y->tval & NUM)
+		else if (isnum(y))
 			(void) setfval(x, getfval(y));
 		else
 			funnyvar(y, "read value of");
-		tempfree(y, "");
+		tempfree(y);
 		return (x);
 	}
 	xf = getfval(x);
@@ -1093,12 +1141,12 @@ assign(Node **a, int n)
 		break;
 	case DIVEQ:
 		if (yf == 0)
-			ERROR "division by zero in /=" FATAL;
+			FATAL("division by zero in /=");
 		xf /= yf;
 		break;
 	case MODEQ:
 		if (yf == 0)
-			ERROR "division by zero in %%=" FATAL;
+			FATAL("division by zero in %%=");
 		(void) modf(xf/yf, &v);
 		xf = xf - yf * v;
 		break;
@@ -1109,55 +1157,55 @@ assign(Node **a, int n)
 			xf = errcheck(pow(xf, yf), "pow");
 		break;
 	default:
-		ERROR "illegal assignment operator %d", n FATAL;
+		FATAL("illegal assignment operator %d", n);
 		break;
 	}
-	tempfree(y, "");
+	tempfree(y);
 	(void) setfval(x, xf);
 	return (x);
 }
 
 /*ARGSUSED*/
 Cell *
-cat(Node **a, int q)
+cat(Node **a, int q)	/* a[0] cat a[1] */
 {
-	register Cell *x, *y, *z;
-	register int n1, n2;
-	register uchar *s;
+	Cell *x, *y, *z;
+	int n1, n2;
+	char *s;
 
 	x = execute(a[0]);
 	y = execute(a[1]);
 	(void) getsval(x);
 	(void) getsval(y);
-	n1 = strlen((char *)x->sval);
-	n2 = strlen((char *)y->sval);
-	s = (uchar *)malloc(n1 + n2 + 1);
+	n1 = strlen(x->sval);
+	n2 = strlen(y->sval);
+	s = (char *)malloc(n1 + n2 + 1);
 	if (s == NULL) {
-		ERROR "out of space concatenating %.15s and %.15s",
-		    x->sval, y->sval FATAL;
+		FATAL("out of space concatenating %.15s... and %.15s...",
+		    x->sval, y->sval);
 	}
-	(void) strcpy((char *)s, (char *)x->sval);
-	(void) strcpy((char *)s + n1, (char *)y->sval);
-	tempfree(y, "");
-	z = gettemp("");
+	(void) strcpy(s, x->sval);
+	(void) strcpy(s + n1, y->sval);
+	tempfree(x);
+	tempfree(y);
+	z = gettemp();
 	z->sval = s;
 	z->tval = STR;
-	tempfree(x, "");
 	return (z);
 }
 
 /*ARGSUSED*/
 Cell *
-pastat(Node **a, int n)
+pastat(Node **a, int n)	/* a[0] { a[1] } */
 {
-	register Cell *x;
+	Cell *x;
 
 	if (a[0] == 0)
 		x = execute(a[1]);
 	else {
 		x = execute(a[0]);
 		if (istrue(x)) {
-			tempfree(x, "");
+			tempfree(x);
 			x = execute(a[1]);
 		}
 	}
@@ -1166,73 +1214,72 @@ pastat(Node **a, int n)
 
 /*ARGSUSED*/
 Cell *
-dopa2(Node **a, int n)
+dopa2(Node **a, int n)	/* a[0], a[1] { a[2] } */
 {
 	Cell	*x;
 	int	pair;
-	static int	*pairstack = NULL;
 
 	if (!pairstack) {
 		/* first time */
 		dprintf(("paircnt: %d\n", paircnt));
-		pairstack = (int *)malloc(sizeof (int) * paircnt);
-		if (!pairstack)
-			ERROR "out of space in dopa2" FATAL;
-		(void) memset(pairstack, 0, sizeof (int) * paircnt);
+		pairstack = (int *)calloc(paircnt, sizeof (int));
+		if (pairstack == NULL)
+			FATAL("out of space in dopa2");
 	}
 
-	pair = (int)a[3];
+	pair = ptoi(a[3]);
 	if (pairstack[pair] == 0) {
 		x = execute(a[0]);
 		if (istrue(x))
 			pairstack[pair] = 1;
-		tempfree(x, "");
+		tempfree(x);
 	}
 	if (pairstack[pair] == 1) {
 		x = execute(a[1]);
 		if (istrue(x))
 			pairstack[pair] = 0;
-		tempfree(x, "");
+		tempfree(x);
 		x = execute(a[2]);
 		return (x);
 	}
-	return (false);
+	return (False);
 }
 
 /*ARGSUSED*/
 Cell *
-split(Node **a, int nnn)
+split(Node **a, int nnn)	/* split(a[0], a[1], a[2]); a[3] is type */
 {
 	Cell *x, *y, *ap;
-	register uchar *s;
-	register int sep;
-	uchar *t, temp, num[11], *fs;
-	int n, tempstat;
+	char *s;
+	int sep;
+	char *t, temp, num[50], *fs = NULL;
+	int n, tempstat, arg3type;
 
 	y = execute(a[0]);	/* source string */
 	s = getsval(y);
+	arg3type = ptoi(a[3]);
 	if (a[2] == 0)		/* fs string */
 		fs = *FS;
-	else if ((int)a[3] == STRING) {	/* split(str,arr,"string") */
+	else if (arg3type == STRING) {	/* split(str,arr,"string") */
 		x = execute(a[2]);
 		fs = getsval(x);
-	} else if ((int)a[3] == REGEXPR)
-		fs = (uchar *)"(regexpr)";	/* split(str,arr,/regexpr/) */
+	} else if (arg3type == REGEXPR)
+		fs = "(regexpr)";	/* split(str,arr,/regexpr/) */
 	else
-		ERROR "illegal type of split()" FATAL;
+		FATAL("illegal type of split");
 	sep = *fs;
 	ap = execute(a[1]);	/* array name */
 	freesymtab(ap);
-	dprintf(("split: s=|%s|, a=%s, sep=|%s|\n", s, ap->nval, fs));
+	dprintf(("split: s=|%s|, a=%s, sep=|%s|\n", s, NN(ap->nval), fs));
 	ap->tval &= ~STR;
 	ap->tval |= ARR;
-	ap->sval = (uchar *)makesymtab(NSYMTAB);
+	ap->sval = (char *)makesymtab(NSYMTAB);
 
 	n = 0;
-	if (*s != '\0' && strlen((char *)fs) > 1 || (int)a[3] == REGEXPR) {
+	if (*s != '\0' && (strlen(fs) > 1 || arg3type == REGEXPR)) {
 		/* reg expr */
 		fa *pfa;
-		if ((int)a[3] == REGEXPR) {	/* it's ready already */
+		if (arg3type == REGEXPR) {	/* it's ready already */
 			pfa = (fa *)a[2];
 		} else {
 			pfa = makedfa(fs, 1);
@@ -1242,12 +1289,12 @@ split(Node **a, int nnn)
 			pfa->initstat = 2;
 			do {
 				n++;
-				(void) sprintf((char *)num, "%d", n);
+				(void) sprintf(num, "%d", n);
 				temp = *patbeg;
 				*patbeg = '\0';
 				if (is_number(s)) {
 					(void) setsymtab(num, s,
-					    atof((char *)s),
+					    atof(s),
 					    /*LINTED align*/
 					    STR|NUM, (Array *)ap->sval);
 				} else {
@@ -1259,8 +1306,8 @@ split(Node **a, int nnn)
 				s = patbeg + patlen;
 				if (*(patbeg+patlen-1) == 0 || *s == 0) {
 					n++;
-					(void) sprintf((char *)num, "%d", n);
-					(void) setsymtab(num, (uchar *)"", 0.0,
+					(void) sprintf(num, "%d", n);
+					(void) setsymtab(num, "", 0.0,
 					    /*LINTED align*/
 					    STR, (Array *)ap->sval);
 					pfa->initstat = tempstat;
@@ -1269,9 +1316,9 @@ split(Node **a, int nnn)
 			} while (nematch(pfa, s));
 		}
 		n++;
-		(void) sprintf((char *)num, "%d", n);
+		(void) sprintf(num, "%d", n);
 		if (is_number(s)) {
-			(void) setsymtab(num, s, atof((char *)s),
+			(void) setsymtab(num, s, atof(s),
 			    /*LINTED align*/
 			    STR|NUM, (Array *)ap->sval);
 		} else {
@@ -1295,9 +1342,9 @@ spdone:
 				;
 			temp = *s;
 			*s = '\0';
-			(void) sprintf((char *)num, "%d", n);
+			(void) sprintf(num, "%d", n);
 			if (is_number(t)) {
-				(void) setsymtab(num, t, atof((char *)t),
+				(void) setsymtab(num, t, atof(t),
 				    /*LINTED align*/
 				    STR|NUM, (Array *)ap->sval);
 			} else {
@@ -1317,9 +1364,9 @@ spdone:
 				s++;
 			temp = *s;
 			*s = '\0';
-			(void) sprintf((char *)num, "%d", n);
+			(void) sprintf(num, "%d", n);
 			if (is_number(t)) {
-				(void) setsymtab(num, t, atof((char *)t),
+				(void) setsymtab(num, t, atof(t),
 				    /*LINTED align*/
 				    STR|NUM, (Array *)ap->sval);
 			} else {
@@ -1332,11 +1379,12 @@ spdone:
 				break;
 		}
 	}
-	tempfree(ap, "");
-	tempfree(y, "");
-	if (a[2] != 0 && (int)a[3] == STRING)
-		tempfree(x, "");
-	x = gettemp("");
+	tempfree(ap);
+	tempfree(y);
+	if (a[2] != 0 && arg3type == STRING) {
+		tempfree(x);
+	}
+	x = gettemp();
 	x->tval = NUM;
 	x->fval = n;
 	return (x);
@@ -1344,16 +1392,16 @@ spdone:
 
 /*ARGSUSED*/
 Cell *
-condexpr(Node **a, int n)
+condexpr(Node **a, int n)	/* a[0] ? a[1] : a[2] */
 {
-	register Cell *x;
+	Cell *x;
 
 	x = execute(a[0]);
 	if (istrue(x)) {
-		tempfree(x, "");
+		tempfree(x);
 		x = execute(a[1]);
 	} else {
-		tempfree(x, "");
+		tempfree(x);
 		x = execute(a[2]);
 	}
 	return (x);
@@ -1361,16 +1409,16 @@ condexpr(Node **a, int n)
 
 /*ARGSUSED*/
 Cell *
-ifstat(Node **a, int n)
+ifstat(Node **a, int n)	/* if (a[0]) a[1]; else a[2] */
 {
-	register Cell *x;
+	Cell *x;
 
 	x = execute(a[0]);
 	if (istrue(x)) {
-		tempfree(x, "");
+		tempfree(x);
 		x = execute(a[1]);
 	} else if (a[2] != 0) {
-		tempfree(x, "");
+		tempfree(x);
 		x = execute(a[2]);
 	}
 	return (x);
@@ -1378,123 +1426,124 @@ ifstat(Node **a, int n)
 
 /*ARGSUSED*/
 Cell *
-whilestat(Node **a, int n)
+whilestat(Node **a, int n)	/* while (a[0]) a[1] */
 {
-	register Cell *x;
+	Cell *x;
 
 	for (;;) {
 		x = execute(a[0]);
 		if (!istrue(x))
 			return (x);
-		tempfree(x, "");
+		tempfree(x);
 		x = execute(a[1]);
 		if (isbreak(x)) {
-			x = true;
+			x = True;
 			return (x);
 		}
 		if (isnext(x) || isexit(x) || isret(x))
 			return (x);
-		tempfree(x, "");
+		tempfree(x);
 	}
 }
 
 /*ARGSUSED*/
 Cell *
-dostat(Node **a, int n)
+dostat(Node **a, int n)	/* do a[0]; while(a[1]) */
 {
-	register Cell *x;
+	Cell *x;
 
 	for (;;) {
 		x = execute(a[0]);
 		if (isbreak(x))
-			return (true);
+			return (True);
 		if (isnext(x) || isexit(x) || isret(x))
 			return (x);
-		tempfree(x, "");
+		tempfree(x);
 		x = execute(a[1]);
 		if (!istrue(x))
 			return (x);
-		tempfree(x, "");
+		tempfree(x);
 	}
 }
 
 /*ARGSUSED*/
 Cell *
-forstat(Node **a, int n)
+forstat(Node **a, int n)	/* for (a[0]; a[1]; a[2]) a[3] */
 {
-	register Cell *x;
+	Cell *x;
 
 	x = execute(a[0]);
-	tempfree(x, "");
+	tempfree(x);
 	for (;;) {
 		if (a[1] != 0) {
 			x = execute(a[1]);
 			if (!istrue(x))
 				return (x);
 			else
-				tempfree(x, "");
+				tempfree(x);
 		}
 		x = execute(a[3]);
 		if (isbreak(x))		/* turn off break */
-			return (true);
+			return (True);
 		if (isnext(x) || isexit(x) || isret(x))
 			return (x);
-		tempfree(x, "");
+		tempfree(x);
 		x = execute(a[2]);
-		tempfree(x, "");
+		tempfree(x);
 	}
 }
 
 /*ARGSUSED*/
 Cell *
-instat(Node **a, int n)
+instat(Node **a, int n)	/* for (a[0] in a[1]) a[2] */
 {
-	register Cell *x, *vp, *arrayp, *cp, *ncp;
+	Cell *x, *vp, *arrayp, *cp, *ncp;
 	Array *tp;
 	int i;
 
 	vp = execute(a[0]);
 	arrayp = execute(a[1]);
-	if (!isarr(arrayp))
-		ERROR "%s is not an array", arrayp->nval FATAL;
+	if (!isarr(arrayp)) {
+		FATAL("%s is not an array", arrayp->nval);
+	}
 	/*LINTED align*/
 	tp = (Array *)arrayp->sval;
-	tempfree(arrayp, "");
+	tempfree(arrayp);
 	for (i = 0; i < tp->size; i++) { /* this routine knows too much */
 		for (cp = tp->tab[i]; cp != NULL; cp = ncp) {
 			(void) setsval(vp, cp->nval);
 			ncp = cp->cnext;
 			x = execute(a[2]);
 			if (isbreak(x)) {
-				tempfree(vp, "");
-				return (true);
+				tempfree(vp);
+				return (True);
 			}
 			if (isnext(x) || isexit(x) || isret(x)) {
-				tempfree(vp, "");
+				tempfree(vp);
 				return (x);
 			}
-			tempfree(x, "");
+			tempfree(x);
 		}
 	}
-	return (true);
+	return (True);
 }
 
 /*ARGSUSED*/
 Cell *
-bltin(Node **a, int n)
+bltin(Node **a, int n)	/* builtin functions. a[0] is type, a[1] is arg list */
 {
-	register Cell *x, *y;
+	Cell *x, *y;
 	Awkfloat u;
-	register int t;
-	uchar *p, *buf;
+	int t;
+	char *p, *buf;
 	Node *nextarg;
 
-	t = (int)a[0];
+	t = ptoi(a[0]);
 	x = execute(a[1]);
 	nextarg = a[1]->nnext;
 	switch (t) {
 	case FLENGTH:
-		u = (Awkfloat)strlen((char *)getsval(x)); break;
+		u = (Awkfloat)strlen(getsval(x)); break;
 	case FLOG:
 		u = errcheck(log(getfval(x)), "log"); break;
 	case FINT:
@@ -1509,13 +1558,12 @@ bltin(Node **a, int n)
 		u = cos(getfval(x)); break;
 	case FATAN:
 		if (nextarg == 0) {
-			ERROR "atan2 requires two arguments; returning 1.0"
-			    WARNING;
+			WARNING("atan2 requires two arguments; returning 1.0");
 			u = 1.0;
 		} else {
 			y = execute(a[1]->nnext);
 			u = atan2(getfval(x), getfval(y));
-			tempfree(y, "");
+			tempfree(y);
 			nextarg = nextarg->nnext;
 		}
 		break;
@@ -1523,13 +1571,14 @@ bltin(Node **a, int n)
 		/* in case something is buffered already */
 		(void) fflush(stdout);
 		/* 256 is unix-dep */
-		u = (Awkfloat)system((char *)getsval(x)) / 256;
+		u = (Awkfloat)system(getsval(x)) / 256;
 		break;
 	case FRAND:
-		u = (Awkfloat)(rand() % 32767) / 32767.0;
+		/* in principle, rand() returns something in 0..RAND_MAX */
+		u = (Awkfloat) (rand() % RAND_MAX) / RAND_MAX;
 		break;
 	case FSRAND:
-		if (x->tval & REC)	/* no argument provided */
+		if (isrec(x))	/* no argument provided */
 			u = time((time_t *)0);
 		else
 			u = getfval(x);
@@ -1540,27 +1589,27 @@ bltin(Node **a, int n)
 		buf = tostring(getsval(x));
 		if (t == FTOUPPER) {
 			for (p = buf; *p; p++)
-				if (islower(*p))
-					*p = toupper(*p);
+				if (islower((uschar)*p))
+					*p = toupper((uschar)*p);
 		} else {
 			for (p = buf; *p; p++)
-				if (isupper(*p))
-					*p = tolower(*p);
+				if (isupper((uschar)*p))
+					*p = tolower((uschar)*p);
 		}
-		tempfree(x, "");
-		x = gettemp("");
+		tempfree(x);
+		x = gettemp();
 		(void) setsval(x, buf);
 		free(buf);
 		return (x);
 	default:	/* can't happen */
-		ERROR "illegal function type %d", t FATAL;
+		FATAL("illegal function type %d", t);
 		break;
 	}
-	tempfree(x, "");
-	x = gettemp("");
+	tempfree(x);
+	x = gettemp();
 	(void) setfval(x, u);
 	if (nextarg != 0) {
-		ERROR "warning: function has too many arguments" WARNING;
+		WARNING("warning: function has too many arguments");
 		for (; nextarg; nextarg = nextarg->nnext)
 			(void) execute(nextarg);
 	}
@@ -1569,28 +1618,28 @@ bltin(Node **a, int n)
 
 /*ARGSUSED*/
 Cell *
-print(Node **a, int n)
+printstat(Node **a, int n)	/* print a[0] */
 {
-	register Node *x;
-	register Cell *y;
+	Node *x;
+	Cell *y;
 	FILE *fp;
 
-	if (a[1] == 0)
+	if (a[1] == 0)	/* a[1] is redirection operator, a[2] is file */
 		fp = stdout;
 	else
-		fp = redirect((int)a[1], a[2]);
+		fp = redirect(ptoi(a[1]), a[2]);
 	for (x = a[0]; x != NULL; x = x->nnext) {
 		y = execute(x);
-		(void) fputs((char *)getsval(y), fp);
-		tempfree(y, "");
+		(void) fputs(getsval(y), fp);
+		tempfree(y);
 		if (x->nnext == NULL)
-			(void) fputs((char *)*ORS, fp);
+			(void) fputs(*ORS, fp);
 		else
-			(void) fputs((char *)*OFS, fp);
+			(void) fputs(*OFS, fp);
 	}
 	if (a[1] != 0)
 		(void) fflush(fp);
-	return (true);
+	return (True);
 }
 
 /*ARGSUSED*/
@@ -1602,39 +1651,38 @@ nullproc(Node **a, int n)
 
 struct {
 	FILE	*fp;
-	uchar	*fname;
+	char	*fname;
 	int	mode;	/* '|', 'a', 'w' */
 } files[FOPEN_MAX];
 
 static FILE *
-redirect(int a, Node *b)
+redirect(int a, Node *b)	/* set up all i/o redirections */
 {
 	FILE *fp;
 	Cell *x;
-	uchar *fname;
+	char *fname;
 
 	x = execute(b);
 	fname = getsval(x);
 	fp = openfile(a, fname);
 	if (fp == NULL)
-		ERROR "can't open file %s", fname FATAL;
-	tempfree(x, "");
+		FATAL("can't open file %s", fname);
+	tempfree(x);
 	return (fp);
 }
 
 static FILE *
-openfile(int a, uchar *s)
+openfile(int a, const char *s)
 {
-	register int i, m;
-	register FILE *fp;
+	int i, m;
+	FILE *fp = NULL;
 
 	if (*s == '\0')
-		ERROR "null file name in print or getline" FATAL;
+		FATAL("null file name in print or getline");
 	for (i = 0; i < FOPEN_MAX; i++) {
-		if (files[i].fname &&
-		    strcmp((char *)s, (char *)files[i].fname) == 0) {
+		if (files[i].fname && strcmp(s, files[i].fname) == 0) {
 			if (a == files[i].mode ||
-			    a == APPEND && files[i].mode == GT) {
+			    (a == APPEND && files[i].mode == GT)) {
 				return (files[i].fp);
 			}
 		}
@@ -1644,23 +1692,23 @@ openfile(int a, uchar *s)
 			break;
 	}
 	if (i >= FOPEN_MAX)
-		ERROR "%s makes too many open files", s FATAL;
+		FATAL("%s makes too many open files", s);
 	(void) fflush(stdout);	/* force a semblance of order */
 	m = a;
 	if (a == GT) {
-		fp = fopen((char *)s, "w");
+		fp = fopen(s, "w");
 	} else if (a == APPEND) {
-		fp = fopen((char *)s, "a");
+		fp = fopen(s, "a");
 		m = GT;	/* so can mix > and >> */
 	} else if (a == '|') {	/* output pipe */
-		fp = popen((char *)s, "w");
+		fp = popen(s, "w");
 	} else if (a == LE) {	/* input pipe */
-		fp = popen((char *)s, "r");
+		fp = popen(s, "r");
 	} else if (a == LT) {	/* getline <file */
-		fp = strcmp((char *)s, "-") == 0 ?
-		    stdin : fopen((char *)s, "r");	/* "-" is stdin */
+		fp = strcmp(s, "-") == 0 ?
+		    stdin : fopen(s, "r");	/* "-" is stdin */
 	} else	/* can't happen */
-		ERROR "illegal redirection" FATAL;
+		FATAL("illegal redirection %d", a);
 	if (fp != NULL) {
 		files[i].fname = tostring(s);
 		files[i].fp = fp;
@@ -1673,25 +1721,24 @@ openfile(int a, uchar *s)
 Cell *
 closefile(Node **a, int n)
 {
-	register Cell *x;
+	Cell *x;
 	int i, stat;
 
 	x = execute(a[0]);
 	(void) getsval(x);
 	for (i = 0; i < FOPEN_MAX; i++) {
-		if (files[i].fname &&
-		    strcmp((char *)x->sval, (char *)files[i].fname) == 0) {
+		if (files[i].fname && strcmp(x->sval, files[i].fname) == 0) {
 			if (ferror(files[i].fp)) {
-				ERROR "i/o error occurred on %s",
-				    files[i].fname WARNING;
+				WARNING("i/o error occurred on %s",
+				    files[i].fname);
 			}
 			if (files[i].mode == '|' || files[i].mode == LE)
 				stat = pclose(files[i].fp);
 			else
 				stat = fclose(files[i].fp);
 			if (stat == EOF) {
-				ERROR "i/o error occurred closing %s",
-				    files[i].fname WARNING;
+				WARNING("i/o error occurred closing %s",
+				    files[i].fname);
 			}
 			xfree(files[i].fname);
 			/* watch out for ref thru this */
@@ -1699,8 +1746,8 @@ closefile(Node **a, int n)
 			files[i].fp = NULL;
 		}
 	}
-	tempfree(x, "close");
-	return (true);
+	tempfree(x);
+	return (True);
 }
 
 static void
@@ -1711,16 +1758,16 @@ closeall(void)
 	for (i = 0; i < FOPEN_MAX; i++) {
 		if (files[i].fp) {
 			if (ferror(files[i].fp)) {
-				ERROR "i/o error occurred on %s",
-				    files[i].fname WARNING;
+				WARNING("i/o error occurred on %s",
+				    files[i].fname);
 			}
 			if (files[i].mode == '|' || files[i].mode == LE)
 				stat = pclose(files[i].fp);
 			else
 				stat = fclose(files[i].fp);
 			if (stat == EOF) {
-				ERROR "i/o error occurred while closing %s",
-				    files[i].fname WARNING;
+				WARNING("i/o error occurred while closing %s",
+				    files[i].fname);
 			}
 		}
 	}
@@ -1728,25 +1775,25 @@ closeall(void)
 
 /*ARGSUSED*/
 Cell *
-sub(Node **a, int nnn)
+sub(Node **a, int nnn)	/* substitute command */
 {
-	register uchar *sptr;
-	register Cell *x, *y, *result;
-	uchar *buf, *t;
+	char *sptr;
+	Cell *x, *y, *result;
+	char *t, *buf;
 	fa *pfa;
 	size_t	bsize, cnt, len;
 
 	x = execute(a[3]);	/* target string */
 	t = getsval(x);
-	if (a[0] == 0)
+	if (a[0] == 0)		/* 0 => a[1] is already-compiled regexpr */
 		pfa = (fa *)a[1];	/* regular expression */
 	else {
 		y = execute(a[1]);
 		pfa = makedfa(getsval(y), 1);
-		tempfree(y, "");
+		tempfree(y);
 	}
 	y = execute(a[2]);	/* replacement string */
-	result = false;
+	result = False;
 	if (pmatch(pfa, t)) {
 		init_buf(&buf, &bsize, LINE_INCR);
 		cnt = 0;
@@ -1775,29 +1822,29 @@ sub(Node **a, int nnn)
 		}
 		sptr = patbeg + patlen;
 		if ((patlen == 0 && *patbeg) || (patlen && *(sptr-1))) {
-			len = strlen((char *)sptr);
+			len = strlen(sptr);
 			expand_buf(&buf, &bsize, cnt + len);
 			(void) memcpy(&buf[cnt], sptr, len);
 			cnt += len;
 		}
 		buf[cnt] = '\0';
-		(void) setsval(x, buf);
+		(void) setsval(x, buf);	/* BUG: should be able to avoid copy */
 		free(buf);
-		result = true;
+		result = True;
 	}
-	tempfree(x, "");
-	tempfree(y, "");
+	tempfree(x);
+	tempfree(y);
 	return (result);
 }
 
 /*ARGSUSED*/
 Cell *
-gsub(Node **a, int nnn)
+gsub(Node **a, int nnn)	/* global substitute */
 {
-	register Cell *x, *y;
-	register uchar *rptr, *sptr, *t;
-	uchar *buf;
-	register fa *pfa;
+	Cell *x, *y;
+	char *rptr, *sptr, *t;
+	char *buf;
+	fa *pfa;
 	int mflag, tempstat, num;
 	size_t	bsize, cnt, len;
 
@@ -1805,12 +1852,12 @@ gsub(Node **a, int nnn)
 	num = 0;
 	x = execute(a[3]);	/* target string */
 	t = getsval(x);
-	if (a[0] == 0)
+	if (a[0] == 0)		/* 0 => a[1] is already-compiled regexpr */
 		pfa = (fa *) a[1];	/* regular expression */
 	else {
 		y = execute(a[1]);
 		pfa = makedfa(getsval(y), 1);
-		tempfree(y, "");
+		tempfree(y);
 	}
 	y = execute(a[2]);	/* replacement string */
 	if (pmatch(pfa, t)) {
@@ -1885,7 +1932,7 @@ gsub(Node **a, int nnn)
 			}
 		} while (pmatch(pfa, t));
 		sptr = t;
-		len = strlen((char *)sptr);
+		len = strlen(sptr);
 		expand_buf(&buf, &bsize, len + cnt);
 		(void) memcpy(&buf[cnt], sptr, len);
 		cnt += len;
@@ -1895,9 +1942,9 @@ gsub(Node **a, int nnn)
 		free(buf);
 		pfa->initstat = tempstat;
 	}
-	tempfree(x, "");
-	tempfree(y, "");
-	x = gettemp("");
+	tempfree(x);
+	tempfree(y);
+	x = gettemp();
 	x->tval = NUM;
 	x->fval = num;
 	return (x);
diff --git a/usr/src/cmd/awk/tran.c b/usr/src/cmd/awk/tran.c
index e8e42d780e..7672884ffb 100644
--- a/usr/src/cmd/awk/tran.c
+++ b/usr/src/cmd/awk/tran.c
@@ -22,18 +22,18 @@
 /*
  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T. All Rights Reserved.
+ * Copyright (c) Lucent Technologies 1997. All Rights Reserved
  */
 
-/*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
-/*	  All Rights Reserved  	*/
-
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
 
 #define	DEBUG
 #include <stdio.h>
-#include <stdlib.h>
+#include <math.h>
 #include <ctype.h>
 #include <string.h>
+#include <stdlib.h>
 #include "awk.h"
 #include "y.tab.h"
 
@@ -42,17 +42,17 @@
 
 Array	*symtab;	/* main symbol table */
 
-uchar	**FS;		/* initial field sep */
-uchar	**RS;		/* initial record sep */
-uchar	**OFS;		/* output field sep */
-uchar	**ORS;		/* output record sep */
-uchar	**OFMT;		/* output format for numbers */
+char	**FS;		/* initial field sep */
+char	**RS;		/* initial record sep */
+char	**OFS;		/* output field sep */
+char	**ORS;		/* output record sep */
+char	**OFMT;		/* output format for numbers */
 Awkfloat *NF;		/* number of fields in current record */
 Awkfloat *NR;		/* number of current record */
 Awkfloat *FNR;		/* number of current record in current file */
-uchar	**FILENAME;	/* current filename argument */
+char	**FILENAME;	/* current filename argument */
 Awkfloat *ARGC;		/* number of arguments from command line */
-uchar	**SUBSEP;	/* subscript separator for a[i,j,k]; default \034 */
+char	**SUBSEP;	/* subscript separator for a[i,j,k]; default \034 */
 Awkfloat *RSTART;	/* start of re matched with ~; origin 1 (!) */
 Awkfloat *RLENGTH;	/* length of same */
 
@@ -66,83 +66,80 @@ Cell	*rstartloc;	/* RSTART */
 Cell	*rlengthloc;	/* RLENGTH */
 Cell	*symtabloc;	/* SYMTAB */
 
-Cell	*nullloc;
+Cell	*nullloc;	/* a guaranteed empty cell */
 Node	*nullnode;	/* zero&null, converted into a node for comparisons */
 
 static	void	rehash(Array *);
 
 void
-syminit(void)
+syminit(void)	/* initialize symbol table with builtin vars */
 {
-	init_buf(&record, &record_size, LINE_INCR);
+	init_buf(&record, &recsize, LINE_INCR);
 
 	/* initialize $0 */
 	recloc = getfld(0);
-	recloc->nval = (uchar *)"$0";
+	recloc->nval = "$0";
 	recloc->sval = record;
 	recloc->tval = REC|STR|DONTFREE;
 
 	symtab = makesymtab(NSYMTAB);
-	(void) setsymtab((uchar *)"0", (uchar *)"0", 0.0,
+	(void) setsymtab("0", "0", 0.0,
 	    NUM|STR|CON|DONTFREE, symtab);
 	/* this is used for if(x)... tests: */
-	nullloc = setsymtab((uchar *)"$zero&null", (uchar *)"", 0.0,
+	nullloc = setsymtab("$zero&null", "", 0.0,
 	    NUM|STR|CON|DONTFREE, symtab);
-	nullnode = valtonode(nullloc, CCON);
-	FS = &setsymtab((uchar *)"FS", (uchar *)" ", 0.0,
-	    STR|DONTFREE, symtab)->sval;
-	RS = &setsymtab((uchar *)"RS", (uchar *)"\n", 0.0,
+	nullnode = celltonode(nullloc, CCON);
+
+	FS = &setsymtab("FS", " ", 0.0,
 	    STR|DONTFREE, symtab)->sval;
-	OFS = &setsymtab((uchar *)"OFS", (uchar *)" ", 0.0,
+	RS = &setsymtab("RS", "\n", 0.0,
 	    STR|DONTFREE, symtab)->sval;
-	ORS = &setsymtab((uchar *)"ORS", (uchar *)"\n", 0.0,
+	OFS = &setsymtab("OFS", " ", 0.0, STR|DONTFREE, symtab)->sval;
+	ORS = &setsymtab("ORS", "\n", 0.0,
 	    STR|DONTFREE, symtab)->sval;
-	OFMT = &setsymtab((uchar *)"OFMT", (uchar *)"%.6g", 0.0,
+	OFMT = &setsymtab("OFMT", "%.6g", 0.0,
 	    STR|DONTFREE, symtab)->sval;
-	FILENAME = &setsymtab((uchar *)"FILENAME", (uchar *)"-", 0.0,
+	FILENAME = &setsymtab("FILENAME", "-", 0.0,
 	    STR|DONTFREE, symtab)->sval;
-	nfloc = setsymtab((uchar *)"NF", (uchar *)"", 0.0, NUM, symtab);
+	nfloc = setsymtab("NF", "", 0.0, NUM, symtab);
 	NF = &nfloc->fval;
-	nrloc = setsymtab((uchar *)"NR", (uchar *)"", 0.0, NUM, symtab);
+	nrloc = setsymtab("NR", "", 0.0, NUM, symtab);
 	NR = &nrloc->fval;
-	fnrloc = setsymtab((uchar *)"FNR", (uchar *)"", 0.0, NUM, symtab);
+	fnrloc = setsymtab("FNR", "", 0.0, NUM, symtab);
 	FNR = &fnrloc->fval;
-	SUBSEP = &setsymtab((uchar *)"SUBSEP", (uchar *)"\034", 0.0,
+	SUBSEP = &setsymtab("SUBSEP", "\034", 0.0,
 	    STR|DONTFREE, symtab)->sval;
-	rstartloc = setsymtab((uchar *)"RSTART", (uchar *)"", 0.0,
-	    NUM, symtab);
+	rstartloc = setsymtab("RSTART", "", 0.0, NUM, symtab);
 	RSTART = &rstartloc->fval;
-	rlengthloc = setsymtab((uchar *)"RLENGTH", (uchar *)"", 0.0,
-	    NUM, symtab);
+	rlengthloc = setsymtab("RLENGTH", "", 0.0, NUM, symtab);
 	RLENGTH = &rlengthloc->fval;
-	symtabloc = setsymtab((uchar *)"SYMTAB", (uchar *)"", 0.0, ARR, symtab);
-	symtabloc->sval = (uchar *)symtab;
+	symtabloc = setsymtab("SYMTAB", "", 0.0, ARR, symtab);
+	symtabloc->sval = (char *)symtab;
 }
 
 void
-arginit(int ac, uchar *av[])
+arginit(int ac, char **av)	/* set up ARGV and ARGC */
 {
 	Cell *cp;
 	int i;
-	uchar temp[11];
+	char temp[50];
 
 	/* first make FILENAME first real argument */
 	for (i = 1; i < ac; i++) {
 		if (!isclvar(av[i])) {
-			(void) setsval(lookup((uchar *)"FILENAME", symtab),
+			(void) setsval(lookup("FILENAME", symtab),
 			    av[i]);
 			break;
 		}
 	}
-	ARGC = &setsymtab((uchar *)"ARGC", (uchar *)"", (Awkfloat)ac,
-	    NUM, symtab)->fval;
-	cp = setsymtab((uchar *)"ARGV", (uchar *)"", 0.0, ARR, symtab);
+	ARGC = &setsymtab("ARGC", "", (Awkfloat)ac, NUM, symtab)->fval;
+	cp = setsymtab("ARGV", "", 0.0, ARR, symtab);
 	ARGVtab = makesymtab(NSYMTAB);	/* could be (int) ARGC as well */
-	cp->sval = (uchar *) ARGVtab;
+	cp->sval = (char *)ARGVtab;
 	for (i = 0; i < ac; i++) {
-		(void) sprintf((char *)temp, "%d", i);
+		(void) sprintf(temp, "%d", i);
 		if (is_number(*av)) {
-			(void) setsymtab(temp, *av, atof((const char *)*av),
+			(void) setsymtab(temp, *av, atof(*av),
 			    STR|NUM, ARGVtab);
 		} else {
 			(void) setsymtab(temp, *av, 0.0, STR, ARGVtab);
@@ -152,20 +149,20 @@ arginit(int ac, uchar *av[])
 }
 
 void
-envinit(uchar *envp[])
+envinit(char **envp)	/* set up ENVIRON variable */
 {
 	Cell *cp;
-	uchar *p;
+	char *p;
 
-	cp = setsymtab((uchar *)"ENVIRON", (uchar *)"", 0.0, ARR, symtab);
+	cp = setsymtab("ENVIRON", "", 0.0, ARR, symtab);
 	ENVtab = makesymtab(NSYMTAB);
-	cp->sval = (uchar *) ENVtab;
+	cp->sval = (char *)ENVtab;
 	for (; *envp; envp++) {
-		if ((p = (uchar *)strchr((char *)*envp, '=')) == NULL)
+		if ((p = strchr(*envp, '=')) == NULL)
 			continue;
 		*p++ = 0;	/* split into two strings at = */
 		if (is_number(p)) {
-			(void) setsymtab(*envp, p, atof((const char *)p),
+			(void) setsymtab(*envp, p, atof(p),
 			    STR|NUM, ENVtab);
 		} else {
 			(void) setsymtab(*envp, p, 0.0, STR, ENVtab);
@@ -176,7 +173,7 @@ envinit(uchar *envp[])
 }
 
 Array *
-makesymtab(int n)
+makesymtab(int n)	/* make a new symbol table */
 {
 	Array *ap;
 	Cell **tp;
@@ -184,7 +181,7 @@ makesymtab(int n)
 	ap = (Array *)malloc(sizeof (Array));
 	tp = (Cell **)calloc(n, sizeof (Cell *));
 	if (ap == NULL || tp == NULL)
-		ERROR "out of space in makesymtab" FATAL;
+		FATAL("out of space in makesymtab");
 	ap->nelem = 0;
 	ap->size = n;
 	ap->tab = tp;
@@ -192,9 +189,9 @@ makesymtab(int n)
 }
 
 void
-freesymtab(Cell *ap)	/* free symbol table */
+freesymtab(Cell *ap)	/* free a symbol table */
 {
-	Cell *cp, *next;
+	Cell *cp, *temp;
 	Array *tp;
 	int i;
 
@@ -205,20 +202,26 @@ freesymtab(Cell *ap)	/* free symbol table */
 	if (tp == NULL)
 		return;
 	for (i = 0; i < tp->size; i++) {
-		for (cp = tp->tab[i]; cp != NULL; cp = next) {
-			next = cp->cnext;
+		for (cp = tp->tab[i]; cp != NULL; cp = temp) {
 			xfree(cp->nval);
 			if (freeable(cp))
 				xfree(cp->sval);
+			temp = cp->cnext;	/* avoids freeing then using */
 			free(cp);
+			tp->nelem--;
 		}
+		tp->tab[i] = 0;
+	}
+	if (tp->nelem != 0) {
+		WARNING("can't happen: inconsistent element count freeing %s",
+		    ap->nval);
 	}
 	free(tp->tab);
 	free(tp);
 }
 
 void
-freeelem(Cell *ap, uchar *s)		/* free elem s from ap (i.e., ap["s"] */
+freeelem(Cell *ap, const char *s)	/* free elem s from ap (i.e., ap["s"] */
 {
 	Array *tp;
 	Cell *p, *prev = NULL;
@@ -228,7 +231,7 @@ freeelem(Cell *ap, uchar *s)		/* free elem s from ap (i.e., ap["s"] */
 	tp = (Array *)ap->sval;
 	h = hash(s, tp->size);
 	for (p = tp->tab[h]; p != NULL; prev = p, p = p->cnext)
-		if (strcmp((char *)s, (char *)p->nval) == 0) {
+		if (strcmp(s, p->nval) == 0) {
 			if (prev == NULL)	/* 1st one */
 				tp->tab[h] = p->cnext;
 			else			/* middle somewhere */
@@ -243,25 +246,24 @@ freeelem(Cell *ap, uchar *s)		/* free elem s from ap (i.e., ap["s"] */
 }
 
 Cell *
-setsymtab(uchar *n, uchar *s, Awkfloat f, unsigned int t, Array *tp)
+setsymtab(const char *n, const char *s, Awkfloat f, unsigned int t, Array *tp)
 {
-	register int h;
-	register Cell *p;
+	int h;
+	Cell *p;
 
 	if (n != NULL && (p = lookup(n, tp)) != NULL) {
-		dprintf(("setsymtab found %p: n=%s", (void *)p, p->nval));
-		dprintf((" s=\"%s\" f=%g t=%p\n",
-		    p->sval, p->fval, (void *)p->tval));
+		dprintf(("setsymtab found %p: n=%s s=\"%s\" f=%g t=%o\n",
+		    (void *)p, NN(p->nval), NN(p->sval), p->fval, p->tval));
 		return (p);
 	}
 	p = (Cell *)malloc(sizeof (Cell));
 	if (p == NULL)
-		ERROR "symbol table overflow at %s", n FATAL;
+		FATAL("out of space for symbol table at %s", n);
 	p->nval = tostring(n);
-	p->sval = s ? tostring(s) : tostring((uchar *)"");
+	p->sval = s ? tostring(s) : tostring("");
 	p->fval = f;
 	p->tval = t;
-	p->csub = 0;
+	p->csub = CUNK;
 
 	tp->nelem++;
 	if (tp->nelem > FULLTAB * tp->size)
@@ -269,15 +271,15 @@ setsymtab(uchar *n, uchar *s, Awkfloat f, unsigned int t, Array *tp)
 	h = hash(n, tp->size);
 	p->cnext = tp->tab[h];
 	tp->tab[h] = p;
-	dprintf(("setsymtab set %p: n=%s", (void *)p, p->nval));
-	dprintf((" s=\"%s\" f=%g t=%p\n", p->sval, p->fval, (void *)p->tval));
+	dprintf(("setsymtab set %p: n=%s s=\"%s\" f=%g t=%o\n",
+	    (void *)p, p->nval, p->sval, p->fval, p->tval));
 	return (p);
 }
 
 int
-hash(uchar *s, int n)	/* form hash value for string s */
+hash(const char *s, int n)	/* form hash value for string s */
 {
-	register unsigned hashval;
+	unsigned int hashval;
 
 	for (hashval = 0; *s != '\0'; s++)
 		hashval = (*s + 31 * hashval);
@@ -292,8 +294,8 @@ rehash(Array *tp)	/* rehash items in small table into big one */
 
 	nsz = GROWTAB * tp->size;
 	np = (Cell **)calloc(nsz, sizeof (Cell *));
-	if (np == NULL)
-		ERROR "out of space in rehash" FATAL;
+	if (np == NULL)		/* can't do it, but can keep running. */
+		return;		/* someone else will run out later. */
 	for (i = 0; i < tp->size; i++) {
 		for (cp = tp->tab[i]; cp; cp = op) {
 			op = cp->cnext;
@@ -308,69 +310,70 @@ rehash(Array *tp)	/* rehash items in small table into big one */
 }
 
 Cell *
-lookup(uchar *s, Array *tp)	/* look for s in tp */
+lookup(const char *s, Array *tp)	/* look for s in tp */
 {
-	register Cell *p;
+	Cell *p;
 	int h;
 
 	h = hash(s, tp->size);
 	for (p = tp->tab[h]; p != NULL; p = p->cnext) {
-		if (strcmp((char *)s, (char *)p->nval) == 0)
+		if (strcmp(s, p->nval) == 0)
 			return (p);	/* found it */
 	}
 	return (NULL);			/* not found */
 }
 
 Awkfloat
-setfval(Cell *vp, Awkfloat f)
+setfval(Cell *vp, Awkfloat f)	/* set float val of a Cell */
 {
 	int	i;
 
 	if ((vp->tval & (NUM | STR)) == 0)
 		funnyvar(vp, "assign to");
-	if (vp->tval & FLD) {
+	if (isfld(vp)) {
 		donerec = 0;	/* mark $0 invalid */
 		i = fldidx(vp);
 		if (i > *NF)
 			newfld(i);
 		dprintf(("setting field %d to %g\n", i, f));
-	} else if (vp->tval & REC) {
+	} else if (isrec(vp)) {
 		donefld = 0;	/* mark $1... invalid */
 		donerec = 1;
 	}
 	vp->tval &= ~STR;	/* mark string invalid */
 	vp->tval |= NUM;	/* mark number ok */
-	dprintf(("setfval %p: %s = %g, t=%p\n", (void *)vp,
-	    vp->nval ? vp->nval : (unsigned char *)"NULL",
-	    f, (void *)vp->tval));
+	dprintf(("setfval %p: %s = %g, t=%o\n", (void *)vp,
+	    NN(vp->nval), f, vp->tval));
 	return (vp->fval = f);
 }
 
 void
-funnyvar(Cell *vp, char *rw)
+funnyvar(Cell *vp, const char *rw)
 {
-	if (vp->tval & ARR)
-		ERROR "can't %s %s; it's an array name.", rw, vp->nval FATAL;
-	if (vp->tval & FCN)
-		ERROR "can't %s %s; it's a function.", rw, vp->nval FATAL;
-	ERROR "funny variable %o: n=%s s=\"%s\" f=%g t=%o",
-	    vp, vp->nval, vp->sval, vp->fval, vp->tval CONT;
+	if (isarr(vp))
+		FATAL("can't %s %s; it's an array name.", rw, vp->nval);
+	if (isfcn(vp))
+		FATAL("can't %s %s; it's a function.", rw, vp->nval);
+	WARNING("funny variable %p: n=%s s=\"%s\" f=%g t=%o",
+	    vp, vp->nval, vp->sval, vp->fval, vp->tval);
 }
 
-uchar *
-setsval(Cell *vp, uchar *s)
+char *
+setsval(Cell *vp, const char *s)	/* set string val of a Cell */
 {
 	int	i;
 
+	dprintf(("starting setsval %p: %s = \"%s\", t=%o, r,f=%d,%d\n",
+	    (void*)vp, NN(vp->nval), s, vp->tval, donerec, donefld));
 	if ((vp->tval & (NUM | STR)) == 0)
 		funnyvar(vp, "assign to");
-	if (vp->tval & FLD) {
+	if (isfld(vp)) {
 		donerec = 0;	/* mark $0 invalid */
 		i = fldidx(vp);
 		if (i > *NF)
 			newfld(i);
 		dprintf(("setting field %d to %s\n", i, s));
-	} else if (vp->tval & REC) {
+	} else if (isrec(vp)) {
 		donefld = 0;	/* mark $1... invalid */
 		donerec = 1;
 	}
@@ -388,74 +391,71 @@ setsval(Cell *vp, uchar *s)
 }
 
 Awkfloat
-r_getfval(Cell *vp)
+r_getfval(Cell *vp)	/* get float val of a Cell */
 {
 	if ((vp->tval & (NUM | STR)) == 0)
 		funnyvar(vp, "read value of");
-	if ((vp->tval & FLD) && donefld == 0)
+	if (isfld(vp) && donefld == 0)
 		fldbld();
-	else if ((vp->tval & REC) && donerec == 0)
+	else if (isrec(vp) && donerec == 0)
 		recbld();
 	if (!isnum(vp)) {	/* not a number */
-		vp->fval = atof((const char *)vp->sval);	/* best guess */
+		vp->fval = atof(vp->sval);	/* best guess */
 		if (is_number(vp->sval) && !(vp->tval&CON))
 			vp->tval |= NUM;	/* make NUM only sparingly */
 	}
 	dprintf(("getfval %p: %s = %g, t=%p\n",
-	    (void *)vp, vp->nval, vp->fval, (void *)vp->tval));
+	    (void *)vp, NN(vp->nval), vp->fval, (void *)vp->tval));
 	return (vp->fval);
 }
 
-uchar *
+char *
 r_getsval(Cell *vp)
 {
-	uchar s[256];
+	char s[256];
 
 	if ((vp->tval & (NUM | STR)) == 0)
 		funnyvar(vp, "read value of");
-	if ((vp->tval & FLD) && donefld == 0)
+	if (isfld(vp) && donefld == 0)
 		fldbld();
-	else if ((vp->tval & REC) && donerec == 0)
+	else if (isrec(vp) && donerec == 0)
 		recbld();
-	if ((vp->tval & STR) == 0) {
-		if (!(vp->tval&DONTFREE))
+	if (isstr(vp) == 0) {
+		if (freeable(vp))
 			xfree(vp->sval);
 		if ((long long)vp->fval == vp->fval) {
-			(void) snprintf((char *)s, sizeof (s),
+			(void) snprintf(s, sizeof (s),
 			    "%.20g", vp->fval);
 		} else {
 			/*LINTED*/
-			(void) snprintf((char *)s, sizeof (s),
+			(void) snprintf(s, sizeof (s),
 			    (char *)*OFMT, vp->fval);
 		}
 		vp->sval = tostring(s);
 		vp->tval &= ~DONTFREE;
 		vp->tval |= STR;
 	}
-	dprintf(("getsval %p: %s = \"%s\", t=%p\n",
-	    (void *)vp,
-	    vp->nval ? (char *)vp->nval : "",
-	    vp->sval ? (char *)vp->sval : "",
-	    (void *)vp->tval));
+	dprintf(("getsval %p: %s = \"%s (%p)\", t=%o\n",
+	    (void *)vp, NN(vp->nval), vp->sval, (void *)vp->sval, vp->tval));
 	return (vp->sval);
 }
 
-uchar *
-tostring(uchar *s)
+char *
+tostring(const char *s)	/* make a copy of string s */
 {
-	register uchar *p;
+	char *p;
 
-	p = (uchar *)malloc(strlen((char *)s)+1);
+	p = (char *)malloc(strlen(s)+1);
 	if (p == NULL)
-		ERROR "out of space in tostring on %s", s FATAL;
-	(void) strcpy((char *)p, (char *)s);
+		FATAL("out of space in tostring on %s", s);
+	(void) strcpy(p, s);
 	return (p);
 }
 
-uchar *
-qstring(uchar *s, int delim)	/* collect string up to delim */
+char *
+qstring(const char *s, int delim)	/* collect string up to delim */
 {
-	uchar *cbuf, *ret;
+	char *cbuf, *ret;
 	int c, n;
 	size_t	cbufsz, cnt;
 
@@ -463,7 +463,7 @@ qstring(uchar *s, int delim)	/* collect string up to delim */
 
 	for (cnt = 0; (c = *s) != delim; s++) {
 		if (c == '\n') {
-			ERROR "newline in string %.10s...", cbuf SYNTAX;
+			SYNTAX("newline in string %.10s...", cbuf);
 		} else if (c != '\\') {
 			expand_buf(&cbuf, &cbufsz, cnt);
 			cbuf[cnt++] = c;
diff --git a/usr/src/test/util-tests/tests/awk/examples/awk/t.crlf b/usr/src/test/util-tests/tests/awk/examples/awk/t.crlf
new file mode 100644
index 0000000000..c5f51ae0fc
--- /dev/null
+++ b/usr/src/test/util-tests/tests/awk/examples/awk/t.crlf
@@ -0,0 +1,4 @@
+# checks whether lines with crlf are parsed ok
+
+{print  \
+ }
diff --git a/usr/src/test/util-tests/tests/awk/examples/out/t.crlf b/usr/src/test/util-tests/tests/awk/examples/out/t.crlf
new file mode 100644
index 0000000000..be3dbf6155
--- /dev/null
+++ b/usr/src/test/util-tests/tests/awk/examples/out/t.crlf
@@ -0,0 +1,199 @@
+/dev/rrp3:
+
+17379	mel
+16693	bwk	me
+16116	ken	him	someone else
+15713	srb
+11895	lem
+10409	scj
+10252	rhm
+ 9853	shen
+ 9748	a68
+ 9492	sif
+ 9190	pjw
+ 8912	nls
+ 8895	dmr
+ 8491	cda
+ 8372	bs
+ 8252	llc
+ 7450	mb
+ 7360	ava
+ 7273	jrv
+ 7080	bin
+ 7063	greg
+ 6567	dict
+ 6462	lck
+ 6291	rje
+ 6211	lwf
+ 5671	dave
+ 5373	jhc
+ 5220	agf
+ 5167	doug
+ 5007	valerie
+ 3963	jca
+ 3895	bbs
+ 3796	moh
+ 3481	xchar
+ 3200	tbl
+ 2845	s
+ 2774	tgs
+ 2641	met
+ 2566	jck
+ 2511	port
+ 2479	sue
+ 2127	root
+ 1989	bsb
+ 1989	jeg
+ 1933	eag
+ 1801	pdj
+ 1590	tpc
+ 1385	cvw
+ 1370	rwm
+ 1316	avg
+ 1205	eg
+ 1194	jam
+ 1153	dl
+ 1150	lgm
+ 1031	cmb
+ 1018	jwr
+  950	gdb
+  931	marc
+  898	usg
+  865	ggr
+  822	daemon
+  803	mihalis
+  700	honey
+  624	tad
+  559	acs
+  541	uucp
+  523	raf
+  495	adh
+  456	kec
+  414	craig
+  386	donmac
+  375	jj
+  348	ravi
+  344	drw
+  327	stars
+  288	mrg
+  272	jcb
+  263	ralph
+  253	tom
+  251	sjb
+  248	haight
+  224	sharon
+  222	chuck
+  213	dsj
+  201	bill
+  184	god
+  176	sys
+  166	meh
+  163	jon
+  144	dan
+  143	fox
+  123	dale
+  116	kab
+   95	buz
+   80	asc
+   79	jas
+   79	trt
+   64	wsb
+   62	dwh
+   56	ktf
+   54	lr
+   47	dlc
+   45	dls
+   45	jwf
+   44	mash
+   43	ars
+   43	vgl
+   37	jfo
+   32	rab
+   31	pd
+   29	jns
+   25	spm
+   22	rob
+   15	egb
+   10	hm
+   10	mhb
+    6	aed
+    6	cpb
+    5	evp
+    4	ber
+    4	men
+    4	mitch
+    3	ast
+    3	jfr
+    3	lax
+    3	nel
+    2	blue
+    2	jfk
+    2	njas
+    1	122sec
+    1	ddwar
+    1	gopi
+    1	jk
+    1	learn
+    1	low
+    1	nac
+    1	sidor
+1root:EMpNB8Zp56:0:0:Super-User,,,,,,,:/:/bin/sh
+2roottcsh:*:0:0:Super-User running tcsh [cbm]:/:/bin/tcsh
+3sysadm:*:0:0:System V Administration:/usr/admin:/bin/sh
+4diag:*:0:996:Hardware Diagnostics:/usr/diags:/bin/csh
+5daemon:*:1:1:daemons:/:/bin/sh
+6bin:*:2:2:System Tools Owner:/bin:/dev/null
+7nuucp:BJnuQbAo:6:10:UUCP.Admin:/usr/spool/uucppublic:/usr/lib/uucp/uucico
+8uucp:*:3:5:UUCP.Admin:/usr/lib/uucp:
+9sys:*:4:0:System Activity Owner:/usr/adm:/bin/sh
+10adm:*:5:3:Accounting Files Owner:/usr/adm:/bin/sh
+11lp:*:9:9:Print Spooler Owner:/var/spool/lp:/bin/sh
+12auditor:*:11:0:Audit Activity Owner:/auditor:/bin/sh
+13dbadmin:*:12:0:Security Database Owner:/dbadmin:/bin/sh
+14bootes:dcon:50:1:Tom Killian (DO NOT REMOVE):/tmp:
+15cdjuke:dcon:51:1:Tom Killian (DO NOT REMOVE):/tmp:
+16rfindd:*:66:1:Rfind Daemon and Fsdump:/var/rfindd:/bin/sh
+17EZsetup:*:992:998:System Setup:/var/sysadmdesktop/EZsetup:/bin/csh
+18demos:*:993:997:Demonstration User:/usr/demos:/bin/csh
+19tutor:*:994:997:Tutorial User:/usr/tutor:/bin/csh
+20tour:*:995:997:IRIS Space Tour:/usr/people/tour:/bin/csh
+21guest:nfP4/Wpvio/Rw:998:998:Guest Account:/usr/people/guest:/bin/csh
+224Dgifts:0nWRTZsOMt.:999:998:4Dgifts Account:/usr/people/4Dgifts:/bin/csh
+23nobody:*:60001:60001:SVR4 nobody uid:/dev/null:/dev/null
+24noaccess:*:60002:60002:uid no access:/dev/null:/dev/null
+25nobody:*:-2:-2:original nobody uid:/dev/null:/dev/null
+26rje:*:8:8:RJE Owner:/usr/spool/rje:
+27changes:*:11:11:system change log:/:
+28dist:sorry:9999:4:file distributions:/v/adm/dist:/v/bin/sh
+29man:*:99:995:On-line Manual Owner:/:
+30phoneca:*:991:991:phone call log [tom]:/v/adm/log:/v/bin/sh
+1r oot EMpNB8Zp56 0 0 Super-User,,,,,,, / /bin/sh
+2r oottcsh * 0 0 Super-User running tcsh [cbm] / /bin/tcsh
+3s ysadm * 0 0 System V Administration /usr/admin /bin/sh
+4d iag * 0 996 Hardware Diagnostics /usr/diags /bin/csh
+5d aemon * 1 1 daemons / /bin/sh
+6b in * 2 2 System Tools Owner /bin /dev/null
+7n uucp BJnuQbAo 6 10 UUCP.Admin /usr/spool/uucppublic /usr/lib/uucp/uucico
+8u ucp * 3 5 UUCP.Admin /usr/lib/uucp 
+9s ys * 4 0 System Activity Owner /usr/adm /bin/sh
+10 adm * 5 3 Accounting Files Owner /usr/adm /bin/sh
+11 lp * 9 9 Print Spooler Owner /var/spool/lp /bin/sh
+12 auditor * 11 0 Audit Activity Owner /auditor /bin/sh
+13 dbadmin * 12 0 Security Database Owner /dbadmin /bin/sh
+14 bootes dcon 50 1 Tom Killian (DO NOT REMOVE) /tmp 
+15 cdjuke dcon 51 1 Tom Killian (DO NOT REMOVE) /tmp 
+16 rfindd * 66 1 Rfind Daemon and Fsdump /var/rfindd /bin/sh
+17 EZsetup * 992 998 System Setup /var/sysadmdesktop/EZsetup /bin/csh
+18 demos * 993 997 Demonstration User /usr/demos /bin/csh
+19 tutor * 994 997 Tutorial User /usr/tutor /bin/csh
+20 tour * 995 997 IRIS Space Tour /usr/people/tour /bin/csh
+21 guest nfP4/Wpvio/Rw 998 998 Guest Account /usr/people/guest /bin/csh
+22 4Dgifts 0nWRTZsOMt. 999 998 4Dgifts Account /usr/people/4Dgifts /bin/csh
+23 nobody * 60001 60001 SVR4 nobody uid /dev/null /dev/null
+24 noaccess * 60002 60002 uid no access /dev/null /dev/null
+25 nobody * -2 -2 original nobody uid /dev/null /dev/null
+26 rje * 8 8 RJE Owner /usr/spool/rje 
+27 changes * 11 11 system change log / 
+28 dist sorry 9999 4 file distributions /v/adm/dist /v/bin/sh
+29 man * 99 995 On-line Manual Owner / 
+30 phoneca * 991 991 phone call log [tom] /v/adm/log /v/bin/sh
diff --git a/usr/src/test/util-tests/tests/awk/gnu/regeq.awk b/usr/src/test/util-tests/tests/awk/gnu/regeq.awk
new file mode 100644
index 0000000000..0208eb24cf
--- /dev/null
+++ b/usr/src/test/util-tests/tests/awk/gnu/regeq.awk
@@ -0,0 +1,29 @@
+#Date: Sat, 8 May 1999 17:42:20 +0200
+#From: Iva Cabric <ivac@fly.srk.fer.hr>
+#To: bug-gnu-utils@gnu.org
+#Cc: arnold@gnu.org
+#Subject: Problem in gawk with match
+#
+#Hello,
+#
+#gawk reports fatal error in match when first character in regexp is "=" :
+#
+#$ gawk '{ where = match($0, /=a/); print where}' 
+#gawk: cmd. line:1: { where = match($0, /=a/); print where}
+#gawk: cmd. line:1:                     ^ parse error
+#gawk: cmd. line:1: fatal: match() cannot have 0 arguments
+#
+#Using "\=" instead "=" works without problems :
+#
+#$ gawk '{ where = match($0, /\=a/); print where}'
+#sdgfa
+#0
+#asdfds=a
+#7
+#
+#Other versions of awk have no problems with "/=/" (except oawk on SunOS).
+#
+#-- 
+#     	 		 	 @
+#
+{ where = match($0, /=a/); print where}
diff --git a/usr/src/test/util-tests/tests/awk/gnu/regeq.in b/usr/src/test/util-tests/tests/awk/gnu/regeq.in
new file mode 100644
index 0000000000..2428df3aa7
--- /dev/null
+++ b/usr/src/test/util-tests/tests/awk/gnu/regeq.in
@@ -0,0 +1,2 @@
+sdgfa
+asdfds=a
diff --git a/usr/src/test/util-tests/tests/awk/gnu/regeq.ok b/usr/src/test/util-tests/tests/awk/gnu/regeq.ok
new file mode 100644
index 0000000000..4596f886c3
--- /dev/null
+++ b/usr/src/test/util-tests/tests/awk/gnu/regeq.ok
@@ -0,0 +1,2 @@
+0
+7
diff --git a/usr/src/test/util-tests/tests/awk/syn/aryprm2.ok b/usr/src/test/util-tests/tests/awk/syn/aryprm2.ok
index e1974ff31d..bc4268be76 100644
--- a/usr/src/test/util-tests/tests/awk/syn/aryprm2.ok
+++ b/usr/src/test/util-tests/tests/awk/syn/aryprm2.ok
@@ -1,6 +1,6 @@
-$AWK: you can only delete array[element] at source line 3 in function f
+$AWK: you can only delete array[element] at source line 3 in function f source file aryprm2.awk
  context is
 		delete a >>> 
  <<< 
-$AWK: syntax error at source line 3 in function f
-$AWK: illegal statement at source line 3 in function f
+$AWK: syntax error at source line 3 in function f source file aryprm2.awk
+$AWK: illegal statement at source line 3 in function f source file aryprm2.awk
diff --git a/usr/src/test/util-tests/tests/awk/syn/badassign1.ok b/usr/src/test/util-tests/tests/awk/syn/badassign1.ok
index 63195088bc..43494bce4b 100644
--- a/usr/src/test/util-tests/tests/awk/syn/badassign1.ok
+++ b/usr/src/test/util-tests/tests/awk/syn/badassign1.ok
@@ -1,4 +1,4 @@
-$AWK: syntax error at source line 1
+$AWK: syntax error at source line 1 source file badassign1.awk
  context is
 	BEGIN { $i++ >>>  = <<<  3 ; print i }
-$AWK: illegal statement at source line 1
+$AWK: illegal statement at source line 1 source file badassign1.awk
diff --git a/usr/src/test/util-tests/tests/awk/syn/badbuild.ok b/usr/src/test/util-tests/tests/awk/syn/badbuild.ok
index bebca97297..230134520d 100644
--- a/usr/src/test/util-tests/tests/awk/syn/badbuild.ok
+++ b/usr/src/test/util-tests/tests/awk/syn/badbuild.ok
@@ -1,4 +1,4 @@
-$AWK: syntax error at source line 1
+$AWK: syntax error at source line 1 source file badbuild.awk
  context is
 	$1 == $2 >>>  == <<< 
 $AWK: bailing out at source line 1
diff --git a/usr/src/test/util-tests/tests/awk/syn/delfunc.ok b/usr/src/test/util-tests/tests/awk/syn/delfunc.ok
index 52bdbc462d..9f9e74f6ae 100644
--- a/usr/src/test/util-tests/tests/awk/syn/delfunc.ok
+++ b/usr/src/test/util-tests/tests/awk/syn/delfunc.ok
@@ -1,4 +1,4 @@
-$AWK: you can only delete array[element] at source line 5 in function f
+$AWK: you can only delete array[element] at source line 5 in function f source file delfunc.awk
  context is
 		delete f >>> 
  <<< 
diff --git a/usr/src/test/util-tests/tests/awk/syn/fnarray.ok b/usr/src/test/util-tests/tests/awk/syn/fnarray.ok
index 2575d2591f..aec63d5d7a 100644
--- a/usr/src/test/util-tests/tests/awk/syn/fnarray.ok
+++ b/usr/src/test/util-tests/tests/awk/syn/fnarray.ok
@@ -1,3 +1,3 @@
-$AWK: foo is a function, not an array at source line 5
+$AWK: foo is a function, not an array at source line 5 source file fnarray.awk
  context is
 	  Num = >>>  foo[c] <<< 
diff --git a/usr/src/test/util-tests/tests/awk/syn/fnmisc.ok b/usr/src/test/util-tests/tests/awk/syn/fnmisc.ok
index 7f9d5e7e6d..906113aaa7 100644
--- a/usr/src/test/util-tests/tests/awk/syn/fnmisc.ok
+++ b/usr/src/test/util-tests/tests/awk/syn/fnmisc.ok
@@ -1,4 +1,4 @@
-$AWK: syntax error at source line 11
+$AWK: syntax error at source line 11 source file fnmisc.awk
  context is
 	function >>>  split <<< (x) { return x }
 $AWK: bailing out at source line 11
diff --git a/usr/src/test/util-tests/tests/awk/syn/noparms.ok b/usr/src/test/util-tests/tests/awk/syn/noparms.ok
index 6d523bf86e..ca7fa3085f 100644
--- a/usr/src/test/util-tests/tests/awk/syn/noparms.ok
+++ b/usr/src/test/util-tests/tests/awk/syn/noparms.ok
@@ -1,4 +1,4 @@
-$AWK: syntax error at source line 1 in function x
+$AWK: syntax error at source line 1 in function x source file noparms.awk
  context is
 	function x(a, b, c , >>>  , <<< 
 $AWK: bailing out at source line 1 in function x
diff --git a/usr/src/test/util-tests/tests/awk/syn/nulinsrc.ok b/usr/src/test/util-tests/tests/awk/syn/nulinsrc.ok
index d0b7cb139a..605a39fc6b 100644
--- a/usr/src/test/util-tests/tests/awk/syn/nulinsrc.ok
+++ b/usr/src/test/util-tests/tests/awk/syn/nulinsrc.ok
@@ -1,4 +1,3 @@
-$AWK: syntax error at source line 1
+$AWK: non-terminated regular expression \... at source line 1
  context is
 	 >>> /\ <<< 
-$AWK: bailing out at source line 1
diff --git a/usr/src/test/util-tests/tests/awk/syn/parseme.ok b/usr/src/test/util-tests/tests/awk/syn/parseme.ok
index 1b517e1eca..00fc855b10 100644
--- a/usr/src/test/util-tests/tests/awk/syn/parseme.ok
+++ b/usr/src/test/util-tests/tests/awk/syn/parseme.ok
@@ -1,5 +1,5 @@
-$AWK: syntax error at source line 1
+$AWK: syntax error at source line 1 source file parseme.awk
  context is
 	BEGIN { >>>  toupper(substr* <<< line,1,12)) }
-$AWK: illegal statement at source line 1
+$AWK: illegal statement at source line 1 source file parseme.awk
 	extra )
diff --git a/usr/src/test/util-tests/tests/awk/syn/synerr1.ok b/usr/src/test/util-tests/tests/awk/syn/synerr1.ok
index ef8e46dac5..9201971c04 100644
--- a/usr/src/test/util-tests/tests/awk/syn/synerr1.ok
+++ b/usr/src/test/util-tests/tests/awk/syn/synerr1.ok
@@ -1,4 +1,4 @@
-$AWK: syntax error at source line 4
+$AWK: syntax error at source line 4 source file synerr1.awk
  context is
 	 >>> print <<<  "hi"
 $AWK: bailing out at source line 4
diff --git a/usr/src/test/util-tests/tests/awk/syn/synerr2.ok b/usr/src/test/util-tests/tests/awk/syn/synerr2.ok
index 7b778e2e5b..1eb51dd0ac 100644
--- a/usr/src/test/util-tests/tests/awk/syn/synerr2.ok
+++ b/usr/src/test/util-tests/tests/awk/syn/synerr2.ok
@@ -1,4 +1,4 @@
-$AWK: syntax error at source line 47
+$AWK: syntax error at source line 47 source file synerr2.awk
  context is
 	BEGIN { sprintf("%s", >>>  $) <<<  }
-$AWK: illegal statement at source line 47
+$AWK: illegal statement at source line 47 source file synerr2.awk
diff --git a/usr/src/test/util-tests/tests/awk/syn/tradanch1.ok b/usr/src/test/util-tests/tests/awk/syn/tradanch1.ok
index 8d07ab4dfb..194330a35e 100644
--- a/usr/src/test/util-tests/tests/awk/syn/tradanch1.ok
+++ b/usr/src/test/util-tests/tests/awk/syn/tradanch1.ok
@@ -1,4 +1,4 @@
 $AWK: syntax error in regular expression foo^bar at bar
- source line number 1
+ source line number 1 source file tradanch1.awk
  context is
 	 >>> /foo^bar/ <<< 
diff --git a/usr/src/test/util-tests/tests/awk/syn/unterm.ok b/usr/src/test/util-tests/tests/awk/syn/unterm.ok
index 4c32fcf95b..393b31b74a 100644
--- a/usr/src/test/util-tests/tests/awk/syn/unterm.ok
+++ b/usr/src/test/util-tests/tests/awk/syn/unterm.ok
@@ -1,5 +1,5 @@
-$AWK: syntax error at source line 1
+$AWK: non-terminated string ............. at source line 1
  context is
 	 >>> BEGIN{x=".........................................................................................................................................................................................................................................................} <<< 
-$AWK: illegal statement at source line 1
-	missing }
+$AWK: giving up
+ source line number 1
diff --git a/usr/src/test/util-tests/tests/awk/tests/T.-f-f b/usr/src/test/util-tests/tests/awk/tests/T.-f-f
index 57679a6f8b..73f0bcdcb1 100755
--- a/usr/src/test/util-tests/tests/awk/tests/T.-f-f
+++ b/usr/src/test/util-tests/tests/awk/tests/T.-f-f
@@ -20,6 +20,7 @@ TEMP2=$WORKDIR/test.temp.2
 TEMP3=$WORKDIR/test.temp.3
 TEMP4=$WORKDIR/test.temp.4
 TEMP5=$WORKDIR/test.temp.5
+TEMP6=$WORKDIR/test.temp.6
 
 echo 'begin
 end' > $TEMP0
@@ -41,4 +42,15 @@ echo '}' > $TEMP4
 $AWK -f $TEMP2 -f $TEMP3 -f $TEMP4 /etc/passwd > $TEMP5
 diff $TEMP1 $TEMP5 || fail 'BAD: T.-f-f 3 files'
 
+
+echo '/./ {' > $TEMP2
+echo 'print' > $TEMP3
+echo '
+
+
+
+]' > $TEMP4
+$AWK -f $TEMP2 -f $TEMP3 -f $TEMP4 /etc/passwd > $TEMP5 2> $TEMP6
+grep "syntax error.*file $TEMP4" $TEMP6 >/dev/null 2>&1 || fail 'BAD: T.-f-f source file name'
+
 exit $RESULT
diff --git a/usr/src/test/util-tests/tests/awk/tests/T.errmsg b/usr/src/test/util-tests/tests/awk/tests/T.errmsg
index 7bcae73d51..3c0d43fd4f 100755
--- a/usr/src/test/util-tests/tests/awk/tests/T.errmsg
+++ b/usr/src/test/util-tests/tests/awk/tests/T.errmsg
@@ -42,6 +42,12 @@ illegal primary in regular expression
 nonterminated character class
 /[[/
 
+nonterminated character class
+/[]/
+
+nonterminated character class
+/[\
+
 nonterminated character class
 BEGIN { s = "[x"; if (1 ~ s) print "foo"}
 
@@ -95,6 +101,10 @@ function x() { function g() {} }
 return not in function
 { return }
 
+non-terminated string
+{ print "abc
+}
+
 illegal field $(foo)
 BEGIN { print $"foo" }
 
diff --git a/usr/src/test/util-tests/tests/awk/tests/T.latin1 b/usr/src/test/util-tests/tests/awk/tests/T.latin1
index 792578212c..84f87e8ad0 100755
--- a/usr/src/test/util-tests/tests/awk/tests/T.latin1
+++ b/usr/src/test/util-tests/tests/awk/tests/T.latin1
@@ -32,6 +32,10 @@ $AWK '{ gsub(/\351/, "\370"); print }' latin1 > $TEMP0
 $AWK '{ gsub(//, ""); print }' latin1 > $TEMP1
 diff $TEMP0 $TEMP1 || fail 'BAD: T.latin1 3'
 
+$AWK '{ gsub(/[^\300-\370]/, ""); print }' latin1 > $TEMP0
+$AWK '{ gsub(/[^-]/, ""); print } ' latin1 > $TEMP1
+diff $TEMP0 $TEMP1 || fail 'BAD: T.latin1 4'
+
 echo  '//' > $TEMP1
 $AWK -f $TEMP1 $TEMP1 > $TEMP2
 diff $TEMP1 $TEMP2 || fail 'BAD: T.latin1 5'
diff --git a/usr/src/test/util-tests/tests/awk/tests/T.misc b/usr/src/test/util-tests/tests/awk/tests/T.misc
index 748705c60d..6909f4155e 100755
--- a/usr/src/test/util-tests/tests/awk/tests/T.misc
+++ b/usr/src/test/util-tests/tests/awk/tests/T.misc
@@ -401,6 +401,23 @@ $AWK .++. 2> $TEMP0
 grep "syntax error" $TEMP0 >/dev/null || fail "BAD: T.misc syntax error .++. fails"
 
 
+
+# These should be syntax errors
+$AWK '$' 2> $TEMP0
+grep "unexpected" $TEMP0 >/dev/null || fail "BAD: T.misc syntax error $ fails"
+
+$AWK '{print $' 2> $TEMP0
+grep "unexpected" $TEMP0 >/dev/null || fail "BAD: T.misc syntax error \$2 fails"
+
+$AWK '"' 2> $TEMP0
+grep "non-terminated" $TEMP0 >/dev/null || fail "BAD: T.misc bare quote fails"
+
+
+# non-terminated RE
+
+$AWK /xyz > $TEMP0 2>&1
+grep "non-terminated" $TEMP0 >/dev/null || fail "BAD: T.misc non-terminated RE"
+
 # next several were infinite loops, found by brian tsang.
 # this is his example:
 
diff --git a/usr/src/test/util-tests/tests/awk/tests/T.re b/usr/src/test/util-tests/tests/awk/tests/T.re
index 54b5a60ac3..8bf704d9bf 100755
--- a/usr/src/test/util-tests/tests/awk/tests/T.re
+++ b/usr/src/test/util-tests/tests/awk/tests/T.re
@@ -55,6 +55,12 @@ a	~	a
 	!~	""
 		x
 		xxxxx
+=	~	=
+		b=
+		b=b
+	!~	""
+		x
+		xxxxx
 .	~	x
 		xxx
 	!~	""			
