From b0f853325c617f7bb6d81e64575f9e4baccb0b1b Mon Sep 17 00:00:00 2001
From: Cody Peter Mello <cody.mello@joyent.com>
Date: Wed, 12 Oct 2016 06:34:08 +0000
Subject: [PATCH] FWAPI-260 Tag names and values in rules need to be unescaped
 for comparisons FWAPI-259 Moray queries need to be escaped FWAPI-270 Use
 Moray client v2 Reviewed by: Chris Burroughs <chris.burroughs@joyent.com>

---
 .gitignore                               |   1 +
 Makefile                                 |  33 +-
 deps/jsstyle                             |   2 +-
 lib/app.js                               |  85 ++-
 lib/cli.js                               |  17 +-
 lib/endpoints/common.js                  |  10 +-
 lib/endpoints/firewalls/vms.js           |  21 +-
 lib/endpoints/index.js                   |   2 +
 lib/endpoints/ping.js                    |   2 +
 lib/endpoints/resolve.js                 |  32 +-
 lib/endpoints/rules/index.js             |  41 +-
 lib/endpoints/rules/vms.js               |   5 +-
 lib/endpoints/updates.js                 |  15 +-
 lib/errors.js                            |   2 +
 lib/fwapi-cli.js                         |  20 +-
 lib/moray-migration.js                   |  38 +-
 lib/moray.js                             | 531 +++++++++++++--
 lib/persist.js                           | 128 ++--
 lib/rule.js                              | 170 +++--
 lib/ufds/filter.js                       | 242 ++++---
 lib/ufds/model.js                        | 200 +-----
 lib/update.js                            | 141 ++--
 lib/util/array.js                        |   2 +
 lib/util/constants.js                    |   8 +-
 lib/util/ip.js                           |  38 +-
 lib/util/obj.js                          |  40 --
 lib/util/validate.js                     |   2 +
 package.json                             |  20 +-
 server.js                                |   8 +-
 test/integration/get.test.js             |   8 +-
 test/integration/global.test.js          |  17 +-
 test/integration/helpers.js              |   2 +
 test/integration/list.test.js            |  15 +-
 test/integration/provision.multi-test.js |  17 +-
 test/integration/resolve.test.js         | 422 ++++++++++--
 test/integration/update.test.js          |  28 +-
 test/integration/vm-update.multi-test.js |   6 +-
 test/lib/client.js                       |   3 +
 test/lib/cn.js                           |  27 +-
 test/lib/common.js                       |   2 +
 test/lib/config.js                       |  31 +-
 test/lib/log.js                          | 109 +++-
 test/lib/mock-moray.js                   | 431 -------------
 test/lib/rule.js                         |  71 ++-
 test/lib/trunc.js                        | 137 ++++
 test/lib/vm.js                           |  19 +-
 test/unit/data/migration.js              | 781 +++++++++++++++++++++++
 test/unit/helpers.js                     | 218 +++++--
 test/unit/mocks.js                       |  63 +-
 test/unit/moray.test.js                  | 281 ++++++++
 test/unit/rule.test.js                   |  28 +-
 test/unit/run.js                         |  42 ++
 test/unit/ufds-smoke-test.test.js        | 396 ++++++++++++
 test/unit/ufds-to-moray.test.js          | 281 ++++++++
 test/unit/update.test.js                 | 138 ++--
 test/unit/v1-to-latest.test.js           | 287 +++++++++
 test/unit/wrap-integration.test.js       |  50 ++
 tools/eslint.node.conf                   |  21 +
 tools/jsl.node.conf                      |   7 +-
 59 files changed, 4336 insertions(+), 1458 deletions(-)
 delete mode 100644 lib/util/obj.js
 delete mode 100644 test/lib/mock-moray.js
 create mode 100644 test/lib/trunc.js
 create mode 100644 test/unit/data/migration.js
 create mode 100644 test/unit/moray.test.js
 create mode 100644 test/unit/run.js
 create mode 100644 test/unit/ufds-smoke-test.test.js
 create mode 100644 test/unit/ufds-to-moray.test.js
 create mode 100644 test/unit/v1-to-latest.test.js
 create mode 100644 test/unit/wrap-integration.test.js
 create mode 100644 tools/eslint.node.conf

diff --git a/.gitignore b/.gitignore
index 3591a94..8ee8698 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,3 +1,4 @@
+/coverage
 /node_modules
 /tmp
 build
diff --git a/Makefile b/Makefile
index d0edd30..96444b1 100644
--- a/Makefile
+++ b/Makefile
@@ -5,7 +5,7 @@
 #
 
 #
-# Copyright (c) 2014, Joyent, Inc.
+# Copyright 2016, Joyent, Inc.
 #
 
 #
@@ -16,7 +16,9 @@
 #
 # Tools
 #
-NODEUNIT		:= ./node_modules/.bin/nodeunit
+ISTANBUL	:= node_modules/.bin/istanbul
+FAUCET		:= node_modules/.bin/faucet
+TAPE		:= ./node_modules/.bin/tape
 
 
 #
@@ -29,6 +31,9 @@ EXTRA_DOC_DEPS	= deps/restdown-brand-remora/.git
 JS_FILES	:= $(shell ls *.js) $(shell find lib test -name '*.js')
 JSL_CONF_NODE	 = tools/jsl.node.conf
 JSL_FILES_NODE   = $(JS_FILES)
+ESLINT		= ./node_modules/.bin/eslint
+ESLINT_CONF	= tools/eslint.node.conf
+ESLINT_FILES	= $(JS_FILES)
 JSON_FILES	:= config.json.sample package.json
 JSSTYLE_FILES	 = $(JS_FILES)
 JSSTYLE_FLAGS    = -o indent=4,doxygen,unparenthesized-return=0
@@ -59,21 +64,30 @@ INSTDIR         := $(PKGDIR)/root/opt/smartdc/fwapi
 # Repo-specific targets
 #
 .PHONY: all
-all: $(SMF_MANIFESTS) | $(NODEUNIT) $(REPO_DEPS) sdc-scripts
+all: $(SMF_MANIFESTS) | $(NPM_EXEC) $(REPO_DEPS) sdc-scripts
+	$(NPM) install --production
+
+$(ESLINT): | $(NPM_EXEC)
+	$(NPM) install
+
+$(TAPE): | $(NPM_EXEC)
 	$(NPM) install
 
-$(NODEUNIT): | $(NPM_EXEC)
+$(ISTANBUL): | $(NPM_EXEC)
+	$(NPM) install
+
+$(FAUCET): | $(NPM_EXEC)
 	$(NPM) install
 
 .PHONY: test
-test: $(NODEUNIT)
-	$(NODEUNIT) --reporter=tap test/unit/*.test.js
+test: $(ISTANBUL) $(FAUCET)
+	@$(ISTANBUL) cover --print none test/unit/run.js | $(FAUCET)
 
 .PHONY: teststop
 teststop:
 	@(for F in test/unit/*.test.js; do \
 		echo "# $$F" ;\
-		$(NODEUNIT) --reporter tap $$F ;\
+		$(TAPE) $$F ;\
 		[[ $$? == "0" ]] || exit 1; \
 	done)
 
@@ -150,6 +164,11 @@ publish: release
 	cp $(TOP)/$(RELEASE_TARBALL) $(BITS_DIR)/fwapi/$(RELEASE_TARBALL)
 
 
+.PHONY: check
+check:: $(ESLINT)
+	$(ESLINT) -c $(ESLINT_CONF) $(ESLINT_FILES)
+
+
 #
 # Includes
 #
diff --git a/deps/jsstyle b/deps/jsstyle
index da42b50..9600c7e 160000
--- a/deps/jsstyle
+++ b/deps/jsstyle
@@ -1 +1 @@
-Subproject commit da42b50ceb12d431437b32efd4c411a8e2fac0c8
+Subproject commit 9600c7e56c84f3a74d6e3d70c336e86f7a3e3769
diff --git a/lib/app.js b/lib/app.js
index a744872..957493a 100644
--- a/lib/app.js
+++ b/lib/app.js
@@ -12,6 +12,8 @@
  * Firewall API server application
  */
 
+'use strict';
+
 var assert = require('assert-plus');
 var clone = require('clone');
 var endpoints = require('./endpoints');
@@ -29,7 +31,6 @@ var path = require('path');
 var restify = require('restify');
 var trace_event = require('trace-event');
 var UFDS = require('ufds');
-var verror = require('verror');
 var VMAPI = require('sdc-clients').VMAPI;
 
 
@@ -101,7 +102,7 @@ function FWAPI(opts) {
 
         if (errs.length !== 0) {
             var err = new restify.ServiceUnavailableError(
-                errs.length == 1 ? errs[0].message : 'Services unavailable');
+                errs.length === 1 ? errs[0].message : 'Services unavailable');
             err.errors = errs;
             return next(err);
         }
@@ -134,7 +135,7 @@ function FWAPI(opts) {
         }
         next();
     });
-    server.on('after', function (req, res, route, err) {
+    server.on('after', function (req, res, route, _err) {
         if (route && !EVT_SKIP_ROUTES[route.name]) {
             req.trace.end({name: route.name, req_seq: req.trace.seq_id});
         }
@@ -156,7 +157,7 @@ function FWAPI(opts) {
 
     server.on('after', function _filteredAuditLog(req, res, route, err) {
         // Don't log ping requests, to avoid filling up the log
-        if (route && (route.name == 'getping' || route.name == 'headping')) {
+        if (route && (route.name === 'getping' || route.name === 'headping')) {
             return;
         }
 
@@ -167,7 +168,7 @@ function FWAPI(opts) {
             }, true),
             // Successful GET res bodies are uninteresting and *big*.
             body: !((req.method === 'GET') &&
-                Math.floor(res.statusCode/100) === 2)
+                Math.floor(res.statusCode / 100) === 2)
         })(req, res, route, err);
     });
 
@@ -196,8 +197,13 @@ function FWAPI(opts) {
 FWAPI.prototype.close = function close(callback) {
     var self = this;
     this.server.on('close', function () {
+        if (self.moray) {
+            self.moray.close();
+        }
+
         if (!self.ufds) {
-            return callback();
+            callback();
+            return;
         }
 
         self.ufds.close(function (err) {
@@ -213,24 +219,30 @@ FWAPI.prototype.close = function close(callback) {
     this.updater.close();
 };
 
-FWAPI.prototype.initializeClients = function initializeClients() {
+FWAPI.prototype.initializeClients = function initializeClients(callback) {
     var self = this;
     mod_vasync.parallel({
         'funcs': [
             function initUFDS(cb) {
                 if (self.ufds === null) {
                     self.ufdsClientInit(cb);
-                } else return cb();
+                } else {
+                    cb();
+                }
             },
             function initVMAPI(cb) {
                 if (self.vmapi === null) {
                     self.vmapiClientInit(cb);
-                } else return cb();
+                } else {
+                    cb();
+                }
             },
             function initMoray(cb) {
                 if (self.moray === null) {
                     self.morayClientInit(cb);
-                } else return cb();
+                } else {
+                    cb();
+                }
             }
         ]
     }, function (err) {
@@ -241,13 +253,27 @@ FWAPI.prototype.initializeClients = function initializeClients() {
             return;
         }
 
-        mod_migrate.migrate(self, self.log, function (err2) {
+        mod_moray.initialize({
+            app: self,
+            log: self.log,
+            moray: self.moray,
+            buckets: [ mod_rule.BUCKET, mod_update.BUCKET ]
+        }, function (err2) {
             if (err2) {
-                self.log.error(err2, 'Failed to finish migration cleanly');
+                self.log.error(err2, 'Failed to initialize buckets cleanly');
+                callback(err2);
                 return;
             }
 
-            self.updater.init(self.moray);
+            mod_migrate.migrate(self, self.log, function (err3) {
+                if (err3) {
+                    self.log.error(err3, 'Failed to finish migration cleanly');
+                    callback(err3);
+                    return;
+                }
+
+                self.updater.init(self.moray, callback);
+            });
         });
     });
 };
@@ -256,8 +282,15 @@ FWAPI.prototype.initializeClients = function initializeClients() {
  * Starts the server
  */
 FWAPI.prototype.listen = function listen(callback) {
-    this.server.listen(this.config.port, callback);
-    this.initializeClients();
+    var self = this;
+    mod_vasync.parallel({ funcs: [
+        function (cb) {
+            self.server.listen(self.config.port, cb);
+        },
+        function (cb) {
+            self.initializeClients(cb);
+        }
+    ] }, callback);
 };
 
 
@@ -317,21 +350,15 @@ FWAPI.prototype.morayClientInit = function morayClientInit(cb) {
     var conf = clone(self.config.moray);
 
     mod_moray.create(conf, self.log, function (err, client) {
-        if (err) {
-            // We've already logged in the moray module - nothing to do
-            return cb(err);
+        if (client) {
+            self.moray = client;
         }
 
-        self.moray = client;
-
-        mod_moray.initBucket(client, mod_rule.BUCKET, function (err2) {
-            if (err2) {
-                self.log.error(err2, 'Error initializing buckets');
-                return;
-            }
-
-            return cb();
-        });
+        /*
+         * If there was an error, we've already logged it
+         * in the moray module.
+         */
+        cb(err);
     });
 };
 
@@ -365,7 +392,7 @@ function addFluentdHost(log, host) {
  * - `log` {Object}: bunyan logger (required)
  * @param callback {Function} `function (err, app) {...}`.
  */
-function createApp(opts, callback) {
+function createApp(opts) {
     assert.object(opts, 'opts');
     assert.object(opts.config, 'opts.config');
     assert.object(opts.config.ufds, 'opts.config.ufds');
diff --git a/lib/cli.js b/lib/cli.js
index a0e36f3..fc2e5c0 100644
--- a/lib/cli.js
+++ b/lib/cli.js
@@ -25,6 +25,8 @@
  * fwadm: CLI shared logic
  */
 
+'use strict';
+
 var fs = require('fs');
 var tty = require('tty');
 var util = require('util');
@@ -50,11 +52,13 @@ var UUID_REGEX =
  */
 function displayRules(err, res, opts) {
     if (err) {
-        return outputError(err, opts);
+        outputError(err, opts);
+        return;
     }
 
     if (opts.json) {
-        return console.log(json(res));
+        console.log(json(res));
+        return;
     }
 
     console.log('UUID                                 ENABLED RULE');
@@ -102,7 +106,8 @@ function getPayload(opts, args, callback) {
             }
         });
 
-        return callback(null, payload);
+        callback(null, payload);
+        return;
     }
 
     if (!file && !tty.isatty(0)) {
@@ -110,7 +115,8 @@ function getPayload(opts, args, callback) {
     }
 
     if (!file) {
-        return callback(new verror.VError('Must supply file!'));
+        callback(new verror.VError('Must supply file!'));
+        return;
     }
 
     if (file === '-') {
@@ -156,7 +162,8 @@ function json(obj) {
  */
 function outputError(err, opts) {
     if (opts && opts.json) {
-        return console.error(json(err));
+        console.error(json(err));
+        return;
     }
 
     var code = '';
diff --git a/lib/endpoints/common.js b/lib/endpoints/common.js
index cdca006..c8b1a47 100644
--- a/lib/endpoints/common.js
+++ b/lib/endpoints/common.js
@@ -12,12 +12,14 @@
  * Shared code between restify endpoints
  */
 
-var fw = require('../rule');
+'use strict';
+
 var mod_err = require('../errors');
-var mod_filter = require('../ufds/filter');
 var mod_persist = require('../persist');
 
 
+var hasKey = require('jsprim').hasKey;
+
 
 // --- Exports
 
@@ -33,8 +35,8 @@ function ruleBefore(req, res, next) {
             return next(err);
         }
 
-        if (req.params.hasOwnProperty('owner_uuid') &&
-            rule.hasOwnProperty('owner_uuid') &&
+        if (hasKey(req.params, 'owner_uuid') &&
+            hasKey(rule, 'owner_uuid') &&
             req.params.owner_uuid !== rule.owner_uuid) {
             return next(new mod_err.PermissionDeniedError(
                 'owner does not match', [
diff --git a/lib/endpoints/firewalls/vms.js b/lib/endpoints/firewalls/vms.js
index b5be7d9..454a336 100644
--- a/lib/endpoints/firewalls/vms.js
+++ b/lib/endpoints/firewalls/vms.js
@@ -12,10 +12,11 @@
  * Restify handlers for listing rules applied to vms
  */
 
+'use strict';
+
+var hasKey = require('jsprim').hasKey;
 var mod_err = require('../../errors');
 var mod_persist = require('../../persist');
-var restify = require('restify');
-var util = require('util');
 var validators = require('fwrule/lib/validators');
 
 
@@ -30,17 +31,19 @@ var validators = require('fwrule/lib/validators');
  */
 function validateParams(req, res, next) {
     if (!validators.validateUUID(req.params.uuid)) {
-        return next(new mod_err.InvalidParamsError(mod_err.INVALID_MSG,
+        next(new mod_err.InvalidParamsError(mod_err.INVALID_MSG,
             [ mod_err.invalidParam('uuid', 'Invalid UUID') ]));
+        return;
     }
 
-    if (req.params.hasOwnProperty('owner_uuid') &&
-            !validators.validateUUID(req.params.owner_uuid)) {
-        return next(new mod_err.InvalidParamsError(mod_err.INVALID_MSG,
+    if (hasKey(req.params, 'owner_uuid') &&
+        !validators.validateUUID(req.params.owner_uuid)) {
+        next(new mod_err.InvalidParamsError(mod_err.INVALID_MSG,
             [ mod_err.invalidParam('owner_uuid', 'Invalid UUID') ]));
+        return;
     }
 
-    return next();
+    next();
 }
 
 
@@ -55,8 +58,10 @@ function validateParams(req, res, next) {
 function getVMrules(req, res, next) {
     req._vmapi.getVm(req.params, function (err, vm) {
         if (err) {
-            return next(err);
+            next(err);
+            return;
         }
+
         var filter = {
             owner_uuid: vm.owner_uuid,
             tags: vm.tags,
diff --git a/lib/endpoints/index.js b/lib/endpoints/index.js
index 81926be..e34ef17 100644
--- a/lib/endpoints/index.js
+++ b/lib/endpoints/index.js
@@ -13,6 +13,8 @@
  */
 
 
+'use strict';
+
 
 /*
  * Endpoints are in their own individual files, in a directory structure
diff --git a/lib/endpoints/ping.js b/lib/endpoints/ping.js
index b7a6ec2..b34ab50 100644
--- a/lib/endpoints/ping.js
+++ b/lib/endpoints/ping.js
@@ -13,6 +13,8 @@
  */
 
 
+'use strict';
+
 
 // --- Endpoints
 
diff --git a/lib/endpoints/resolve.js b/lib/endpoints/resolve.js
index b81d105..bb45d3d 100644
--- a/lib/endpoints/resolve.js
+++ b/lib/endpoints/resolve.js
@@ -12,12 +12,16 @@
  * Restify handlers for retrieving VM rules
  */
 
+'use strict';
+
 var fw = require('../rule');
 var mod_persist = require('../persist');
 var restify = require('restify');
 var util = require('util');
 
 
+var hasKey = require('jsprim').hasKey;
+
 
 // --- Internal helpers
 
@@ -46,7 +50,7 @@ function resolveTargets(rules, params, log, callback) {
         tags: {},
         vms: {}
     };
-    if (params.hasOwnProperty('vms')) {
+    if (hasKey(params, 'vms')) {
         params.vms = params.vms.reduce(function (acc, vm) {
             acc[vm] = 1;
             return acc;
@@ -62,7 +66,7 @@ function resolveTargets(rules, params, log, callback) {
             return;
         }
 
-        var otherSide = d == 'from' ? 'to' : 'from';
+        var otherSide = (d === 'from' ? 'to' : 'from');
 
         if (rule[otherSide].wildcards.indexOf('vmall') !== -1) {
             allVMs = true;
@@ -73,7 +77,7 @@ function resolveTargets(rules, params, log, callback) {
                 sideData.tags[tag] = true;
             } else {
                 if (sideData.tags[tag[0]] !== true) {
-                    if (!sideData.tags.hasOwnProperty(tag[0])) {
+                    if (!hasKey(sideData.tags, tag[0])) {
                         sideData.tags[tag[0]] = [];
                     }
 
@@ -97,10 +101,11 @@ function resolveTargets(rules, params, log, callback) {
                 log.debug('resolveTargets: matched rule=%s, dir=%s, allVMs',
                     rule.uuid, dir);
                 matched = true;
-                return addOtherSideData(rule, dir);
+                addOtherSideData(rule, dir);
+                return;
             }
 
-            if (params.hasOwnProperty('tags')) {
+            if (hasKey(params, 'tags')) {
                 rule[dir].tags.forEach(function (tag) {
                     var tagKey = tag;
                     var tagVal = true;
@@ -113,18 +118,18 @@ function resolveTargets(rules, params, log, callback) {
                         matched = true;
                         log.debug('resolveTargets: matched rule=%s, dir=%s, '
                             + 'tag=%s', rule.uuid, dir, tag);
-                        return addOtherSideData(rule, dir);
+                        addOtherSideData(rule, dir);
                     }
                 });
             }
 
-            if (params.hasOwnProperty('vms')) {
+            if (hasKey(params, 'vms')) {
                 rule[dir].vms.forEach(function (vm) {
-                    if (params.vms.hasOwnProperty(vm)) {
+                    if (hasKey(params.vms, vm)) {
                         matched = true;
                         log.debug('resolveTargets: matched rule=%s, dir=%s, '
                             + 'vm=%s', rule.uuid, dir, vm);
-                        return addOtherSideData(rule, dir);
+                        addOtherSideData(rule, dir);
                     }
                 });
             }
@@ -144,7 +149,7 @@ function resolveTargets(rules, params, log, callback) {
     }
 
     sideData.allVMs = allVMs;
-    if (params.hasOwnProperty('owner_uuid')) {
+    if (hasKey(params, 'owner_uuid')) {
         sideData.owner_uuid = params.owner_uuid;
     }
 
@@ -161,7 +166,7 @@ function resolveTargets(rules, params, log, callback) {
  *     no value)
  */
 function tagMatches(key, val, tagsWanted) {
-    if (!tagsWanted.hasOwnProperty(key)) {
+    if (!hasKey(tagsWanted, key)) {
         return false;
     }
 
@@ -183,7 +188,7 @@ function tagMatches(key, val, tagsWanted) {
     }
 
     for (var v in wantedVals) {
-        if (wantedVals[v] == val) {
+        if (wantedVals[v] === val) {
             return true;
         }
     }
@@ -213,7 +218,8 @@ function resolve(req, res, next) {
     mod_persist.vmRules(req._app, req.log, req.params,
         function (err, rules) {
         if (err) {
-            return next(err);
+            next(err);
+            return;
         }
 
         resolveTargets(rules, req.params, req.log, function (err2, sideData) {
diff --git a/lib/endpoints/rules/index.js b/lib/endpoints/rules/index.js
index 1d1729c..2855e4a 100644
--- a/lib/endpoints/rules/index.js
+++ b/lib/endpoints/rules/index.js
@@ -12,17 +12,19 @@
  * Restify handlers for firewall rules
  */
 
+'use strict';
+
 var clone = require('clone');
 var common = require('../common');
-var filter = require('../../ufds/filter');
 var mod_err = require('../../errors');
 var mod_persist = require('../../persist');
 var restify = require('restify');
 var Rule = require('../../rule').Rule;
-var util = require('util');
 var util_validate = require('../../util/validate');
 
 
+var hasKey = require('jsprim').hasKey;
+
 
 // --- Internal
 
@@ -32,11 +34,11 @@ var util_validate = require('../../util/validate');
  * Turns a fwrule error into an InvalidParamsError
  */
 function createParamErr(err) {
-    if (!err.hasOwnProperty('ase_errors') && !err.hasOwnProperty('field')) {
+    if (!hasKey(err, 'ase_errors') && !hasKey(err, 'field')) {
         return err;
     }
 
-    var errs = err.hasOwnProperty('ase_errors') ? err.ase_errors : [ err ];
+    var errs = hasKey(err, 'ase_errors') ? err.ase_errors : [ err ];
     return new mod_err.InvalidParamsError(mod_err.INVALID_MSG,
         errs.map(function (e) {
             return mod_err.invalidParam(e.field, e.message);
@@ -51,18 +53,18 @@ function createParamErr(err) {
  */
 function disallowOwnerForGlobal(req, res, next) {
     var rule = req._rule;
-    if (!rule.hasOwnProperty('global') || !rule.global) {
-        return next();
+    if (!hasKey(rule, 'global') || !rule.global) {
+        next();
+        return;
     }
 
-    if (!req.params.hasOwnProperty('owner_uuid')) {
-        return next();
+    if (!hasKey(req.params, 'owner_uuid')) {
+        next();
+        return;
     }
 
-    return next(new mod_err.PermissionDeniedError(
-        'owner does not match', [
-        mod_err.invalidParam('owner_uuid',
-            'owner_uuid does not match') ]));
+    next(new mod_err.PermissionDeniedError('owner does not match',
+        [ mod_err.invalidParam('owner_uuid', 'owner_uuid does not match') ]));
 }
 
 
@@ -121,14 +123,16 @@ function getRule(req, res, next) {
  */
 function createRule(req, res, next) {
     if (!req.params.rule) {
-        return next(new restify.MissingParameterError(
+        next(new restify.MissingParameterError(
             '"rule" parameter required'));
+        return;
     }
 
     mod_persist.createRule(req._app, req.log, req.params,
         function (err, rule) {
         if (err) {
-            return next(createParamErr(err));
+            next(createParamErr(err));
+            return;
         }
 
         req._update.queue('fw.add_rule', rule.serialize(),
@@ -164,7 +168,8 @@ function updateRule(req, res, next) {
     try {
         newRule = new Rule(updateParams, req._app);
     } catch (e) {
-        return next(createParamErr(e));
+        next(createParamErr(e));
+        return;
     }
 
     newRule.incrementVersion();
@@ -172,7 +177,8 @@ function updateRule(req, res, next) {
     mod_persist.updateRule(req._app, req.log, newRule, req._rule,
         function (err, rule) {
         if (err) {
-            return next(err);
+            next(err);
+            return;
         }
 
         req._update.queue('fw.update_rule', rule.serialize(),
@@ -195,7 +201,8 @@ function updateRule(req, res, next) {
 function deleteRule(req, res, next) {
     mod_persist.deleteRule(req._app, req.log, req.params.uuid, function (err) {
         if (err) {
-            return next(err);
+            next(err);
+            return;
         }
 
         req._update.queue('fw.del_rule', req._rule.serialize(),
diff --git a/lib/endpoints/rules/vms.js b/lib/endpoints/rules/vms.js
index c00894f..3a34d39 100644
--- a/lib/endpoints/rules/vms.js
+++ b/lib/endpoints/rules/vms.js
@@ -12,6 +12,8 @@
  * Restify handlers for vms affected by firewall rules
  */
 
+'use strict';
+
 var common = require('../common');
 var restify = require('restify');
 var util = require('util');
@@ -27,8 +29,9 @@ var util = require('util');
  */
 function getRuleVMs(req, res, next) {
     if (!req.params.owner_uuid) {
-        return next(new restify.MissingParameterError(
+        next(new restify.MissingParameterError(
             '"owner_uuid" parameter required'));
+        return;
     }
 
     var filter = [];
diff --git a/lib/endpoints/updates.js b/lib/endpoints/updates.js
index d16f896..e24ecfd 100644
--- a/lib/endpoints/updates.js
+++ b/lib/endpoints/updates.js
@@ -12,8 +12,10 @@
  * Restify handlers for firewall data updates
  */
 
+'use strict';
+
+var hasKey = require('jsprim').hasKey;
 var restify = require('restify');
-var util = require('util');
 
 
 
@@ -68,19 +70,22 @@ function createUpdate(req, res, next) {
     var updateParams;
 
     if (!req.params.type) {
-        return next(new restify.MissingParameterError(
+        next(new restify.MissingParameterError(
             '"type" parameter required'));
+        return;
     }
 
-    if (!UPDATES.hasOwnProperty(req.params.type)) {
-        return next(new restify.MissingParameterError(
+    if (!hasKey(UPDATES, req.params.type)) {
+        next(new restify.MissingParameterError(
             'Unknown update type'));
+        return;
     }
 
     try {
         updateParams = UPDATES[req.params.type](req.params);
     } catch (validationErr) {
-        return next(validationErr);
+        next(validationErr);
+        return;
     }
 
     req._update.queue(req.params.type, updateParams, function (err, res2) {
diff --git a/lib/errors.js b/lib/errors.js
index 7308105..7d6a317 100644
--- a/lib/errors.js
+++ b/lib/errors.js
@@ -12,6 +12,8 @@
  * Error classes and helpers
  */
 
+'use strict';
+
 var assert = require('assert-plus');
 var restify = require('restify');
 var util = require('util');
diff --git a/lib/fwapi-cli.js b/lib/fwapi-cli.js
index b6711d5..0833ecc 100644
--- a/lib/fwapi-cli.js
+++ b/lib/fwapi-cli.js
@@ -12,6 +12,10 @@
  * The Firewall API control application
  */
 
+/* eslint-disable no-unused-vars */
+
+'use strict';
+
 var assert = require('assert-plus');
 var cli = require('./cli');
 var cmdln = require('cmdln');
@@ -89,16 +93,16 @@ function getKeyValParams(args, idx) {
 
     for (var i = idx; i < args.length; i++) {
         var split = args[i].split('=');
-        if (split.length != 2) {
+        if (split.length !== 2) {
             errs.push(args[i]);
             continue;
         }
         params[split[0]] = split[1];
     }
 
-    if (errs.length != 0) {
+    if (errs.length !== 0) {
         exit('Invalid parameter%s: %s',
-                (errs.length == 1 ? '' : 's'), errs.join(', '));
+            (errs.length === 1 ? '' : 's'), errs.join(', '));
     }
 
     return params;
@@ -242,6 +246,7 @@ function enableDisable(subcmd, opts, args, callback) {
         return callback(new Error('Error: must supply rule UUID!'));
     }
 
+    // eslint-disable-next-line no-invalid-this
     return this.fwapi.updateRule(args[0], { enabled: subcmd === 'enable' },
         standardHandler.bind(null, opts));
 }
@@ -327,7 +332,8 @@ FwapiCLI.prototype.do_rules.help = 'List the rules affecting a VM.';
  */
 FwapiCLI.prototype['do_start'] = function (subcmd, opts, args, callback) {
     if (!args[0]) {
-        return callback(new Error('Must specify VM UUID'));
+        callback(new Error('Must specify VM UUID'));
+        return;
     }
 
     CONFIG.vmapi.agent = false;
@@ -344,7 +350,8 @@ FwapiCLI.prototype['do_start'].help = 'Start a VM\'s firewall';
  */
 FwapiCLI.prototype['do_stop'] = function (subcmd, opts, args, callback) {
     if (!args[0]) {
-        return callback(new Error('Must specify VM UUID'));
+        callback(new Error('Must specify VM UUID'));
+        return;
     }
 
     CONFIG.vmapi.agent = false;
@@ -413,7 +420,8 @@ FwapiCLI.prototype['do_update-post'].help = 'Post a raw VM update';
 FwapiCLI.prototype['do_update-vm'] = function (subcmd, opts, args, callback) {
     var self = this;
     if (!args[0]) {
-        return callback(new Error('Must specify VM UUID'));
+        callback(new Error('Must specify VM UUID'));
+        return;
     }
 
     CONFIG.vmapi.agent = false;
diff --git a/lib/moray-migration.js b/lib/moray-migration.js
index 4c621fe..0c3bcd4 100644
--- a/lib/moray-migration.js
+++ b/lib/moray-migration.js
@@ -12,6 +12,8 @@
  * These functions are for migrating firewall rules out of UFDS and into Moray
  */
 
+'use strict';
+
 var fw = require('./rule');
 
 var fmt = require('util').format;
@@ -38,20 +40,19 @@ function cleanupObject(obj) {
 /*
  * Create a batch of rules all at once
  */
-function createRules(app, log, rules, callback) {
+function createRules(app, rules, callback) {
+    var batch;
+
     try {
-        var batch = rules.map(function (rule) {
-            var raw = new fw.Rule(rule, app).raw();
-            return {
-                bucket: fw.BUCKET.name,
-                key: raw.uuid,
-                value: raw
-            };
+        batch = rules.map(function (rule) {
+            return (new fw.Rule(rule, app)).batch();
         });
-        app.moray.batch(batch, {}, callback);
     } catch (e) {
         callback(e);
+        return;
     }
+
+    app.moray.batch(batch, {}, callback);
 }
 
 
@@ -83,16 +84,19 @@ function migrateBatch(app, log, marker, callback) {
     });
     req.on('end', function () {
         if (count === 0) {
-            return callback();
+            callback();
+            return;
         }
 
-        createRules(app, log, rules, function (err) {
+        createRules(app, rules, function (err) {
             if (err) {
                 log.error(err, info, 'Batch failed');
-                return callback(err);
+                callback(err);
+                return;
             }
 
-            log.info(info, 'Batch succeeded; migrated %d rules.', count);
+            log.info(info,
+                'Batch succeeded; migrated %d rules from UFDS.', count);
             migrateBatch(app, log, marker, callback);
         });
     });
@@ -100,13 +104,15 @@ function migrateBatch(app, log, marker, callback) {
 
 function migrate(app, log, callback) {
     if (app.config.fwrule_version <= 2) {
-        return callback();
+        callback();
+        return;
     }
 
-    log.info('Starting migration');
+    log.info('Starting migration from UFDS');
     migrateBatch(app, log, null, function (err) {
         if (err) {
-            return callback(err);
+            callback(err);
+            return;
         }
 
         log.info('Migration completed successfully; deleting rules in UFDS');
diff --git a/lib/moray.js b/lib/moray.js
index bfa7ab0..36ac4e7 100644
--- a/lib/moray.js
+++ b/lib/moray.js
@@ -5,15 +5,384 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2016, Joyent, Inc.
  */
 
 /*
- * Moray convenience functions
+ * Moray convenience and initialization functions
+ *
+ *
+ * Migration of old records is performed by constructing the corresponding
+ * model using the existing parameters stored in moray, then calling `raw()` to
+ * get the new record to put into moray. Since migration only uses the new model
+ * to construct new instances, you must be able to create new, valid records
+ * from the parameters in the old records.
+ *
+ *
+ * Migrating a bucket involves the following steps:
+ * 1. Check and update bucket schema and version, if needed.
+ * 2. Re-index objects. This needs to be done before re-putting objects,
+ *    otherwise when new indexes are added, any existing values will be
+ *    nullified when we get them from Moray.
+ * 3. Re-put objects.
+ *
+ * Every step happens for each bucket every time FWAPI starts. Since FWAPI could
+ * have crashed during re-indexing or re-putting, we run both each time to check
+ * for any records that still need to be processed.
+ */
+
+'use strict';
+
+var assert = require('assert-plus');
+var async = require('async');
+var clone = require('clone');
+var constants = require('./util/constants');
+var mod_moray = require('moray');
+var util = require('util');
+var vasync = require('vasync');
+var VError = require('verror');
+
+
+// --- Internal
+
+
+function assertCommonOpts(opts) {
+    assert.object(opts, 'opts');
+    assert.object(opts.app, 'opts.app');
+    assert.object(opts.log, 'opts.log');
+    assert.object(opts.moray, 'opts.moray');
+    assert.optionalObject(opts.extra, 'opts.extra');
+}
+
+
+function assertBucket(bucket) {
+    assert.object(bucket, 'opts.bucket');
+    assert.func(bucket.constructor, 'opts.bucket.constructor');
+    assert.string(bucket.name, 'opts.bucket.name');
+    assert.number(bucket.version, 'opts.bucket.version');
+    assert.number(bucket.morayVersion, 'opts.bucket.morayVersion');
+    assert.object(bucket.schema, 'opts.bucket.schema');
+    assert.object(bucket.schema.index, 'opts.bucket.schema.index');
+    assert.object(bucket.schema.index._v, 'opts.bucket.schema.index._v');
+}
+
+
+function batchAll(recs) {
+    var batch = [];
+    recs.forEach(function (r) {
+        var b = r.batch({ migration: true });
+        if (Array.isArray(b)) {
+            batch = batch.concat(b);
+        } else {
+            batch.push(b);
+        }
+    });
+
+    return batch;
+}
+
+
+/**
+ * Initialize a bucket in Moray if it doesn't exist yet. If the bucket already
+ * exists and is an older version of the schema, update the schema. If the
+ * schema is newer that what we have, log and do nothing.
+ */
+function putBucket(opts, callback) {
+    var moray = opts.moray;
+    var bucket = opts.bucket;
+    var log = opts.log;
+
+    var schema = clone(bucket.schema);
+    schema.options = schema.options || {};
+    schema.options.version = bucket.version;
+
+    function retry(err, msg) {
+        var info = {
+            err: err,
+            retries: opts.retries,
+            delay: constants.RETRY_DELAY,
+            bucket: bucket.name
+        };
+
+        if (opts.retries >= constants.MAX_RETRIES) {
+            log.error(info, 'putBucket: %s', msg);
+            callback(err);
+        } else {
+            opts.retries += 1;
+            log.error(info, 'putBucket: %s; will retry', msg);
+            setTimeout(putBucket, constants.RETRY_DELAY, opts, callback);
+        }
+    }
+
+    moray.getBucket(bucket.name, function (gErr, bucketObj) {
+        if (gErr) {
+            if (!VError.hasCauseWithName(gErr, 'BucketNotFoundError')) {
+                retry(gErr, 'error getting bucket');
+                return;
+            }
+
+            moray.createBucket(bucket.name, schema, function (cErr) {
+                if (cErr) {
+                    retry(cErr, 'error creating bucket');
+                } else {
+                    log.info({ schema: schema, bucket: bucket.name },
+                        'putBucket: created bucket');
+                    callback();
+                }
+            });
+            return;
+        }
+
+        var version =
+            (bucketObj.options ? bucketObj.options.version : 0) || 0;
+
+        if (bucket.version <= version) {
+            var msg = bucket.version < version ?
+                'bucket has a newer schema; not updating' :
+                'bucket up to date';
+
+            log.info({
+                bucket: bucket.name,
+                existing: version,
+                current: bucket.version
+            }, 'putBucket: %s', msg);
+
+            callback();
+            return;
+        }
+
+        log.info({ existing: bucketObj, current: bucket },
+            'putBucket: updating bucket');
+
+        moray.updateBucket(bucket.name, schema, function (uErr) {
+            if (uErr) {
+                retry(uErr, 'error updating bucket');
+                return;
+            }
+
+            log.info({
+                bucket: bucket.name,
+                old: version,
+                current: bucket.version
+            }, 'putBucket: bucket updated');
+
+            callback();
+        });
+    });
+}
+
+
+/**
+ * Reindex all of the objects within a bucket.
+ */
+function reindex(opts, callback) {
+    var bucket = opts.bucket;
+    var log = opts.log;
+    var moray = opts.moray;
+
+    var processed = 0;
+    var count = 100;
+
+    var options = {
+        noBucketCache: true
+    };
+
+    function retry(err, msg) {
+        var info = {
+            err: err,
+            retries: opts.retries,
+            delay: constants.RETRY_DELAY,
+            bucket: bucket.name
+        };
+
+        if (opts.retries >= constants.MAX_RETRIES) {
+            log.error(info, 'reindex: %s', msg);
+            callback(err);
+        } else {
+            opts.retries += 1;
+            log.error(info, 'reindex: %s; will retry', msg);
+            setTimeout(_reindex, constants.RETRY_DELAY);
+        }
+    }
+
+    function processResults(rErr, res) {
+        if (rErr) {
+            retry(rErr, 'error reindexing objects');
+            return;
+        }
+
+        if (res.processed > 0) {
+            log.info({
+                bucket: bucket.name,
+                processed: processed,
+                cur: res.processed
+            }, 'reindex: records reindexed');
+
+            processed += res.processed;
+            setImmediate(_reindex);
+            return;
+        }
+
+        var msg = (processed === 0 ?
+            'reindex: records already reindexed' :
+            'reindex: all records reindexed');
+        log.info({ bucket: bucket.name }, msg);
+
+        callback();
+    }
+
+    function _reindex() {
+        moray.reindexObjects(bucket.name, count, options, processResults);
+    }
+
+    _reindex();
+}
+
+
+/**
+ * Find all old records in a bucket and upgrade them to the latest version of
+ * the object.
  */
+function updateRecords(opts, callback) {
+    var bucket = opts.bucket;
+    var app = opts.app;
+    var log = opts.log;
+    var moray = opts.moray;
+    var extra = opts.extra;
+
+    var processed = 0;
+
+    function retry(err, msg) {
+        var info = {
+            err: err,
+            retries: opts.retries,
+            delay: constants.RETRY_DELAY,
+            bucket: bucket.name
+        };
+
+        if (opts.retries >= constants.MAX_RETRIES) {
+            log.error(info, 'updateRecords: %s', msg);
+            callback(err);
+        } else {
+            opts.retries += 1;
+            log.error(info, 'updateRecords: %s; will retry', msg);
+            setTimeout(_updateRecords, constants.RETRY_DELAY);
+        }
+    }
+
+    function processResults(listErr, recs) {
+        if (listErr) {
+            retry(listErr, 'failed to list records');
+            return;
+        }
+
+        if (recs.length === 0) {
+            // No more unmigrated records
+            var msg = (processed === 0 ?
+                'updateRecords: records already migrated' :
+                'updateRecords: all records migrated');
+            log.info({
+                bucket: bucket.name,
+                version: bucket.version,
+                processed: processed
+            }, msg);
+            callback();
+            return;
+        }
+
+        var batch = batchAll(recs);
+
+        log.debug({
+            batch: batch,
+            bucket: bucket.name
+        }, 'updateRecords: batch');
+
+        moray.batch(batch, function (batchErr) {
+            if (batchErr) {
+                if (VError.hasCauseWithName(batchErr, 'EtagConflictError')) {
+                    // One of the batch objects has been updated from
+                    // underneath us: try it again next time.
+                    setImmediate(_updateRecords);
+                    return;
+                }
+
+                retry(batchErr, 'failed to commit batch');
+                return;
+            }
+
+            // Migration succeeded - keep going
+            processed += batch.length;
+            log.info({
+                bucket: bucket.name,
+                processed: processed,
+                cur: batch.length
+            }, 'updateRecords: records migrated');
+            setImmediate(_updateRecords);
+        });
+    }
+
+    function _updateRecords() {
+        listObjs({
+            app: app,
+            extra: extra,
+            filter: util.format('(|(!(_v=*))(_v<=%d))', bucket.version - 1),
+            log: log,
+            bucket: bucket,
+            model: bucket.constructor,
+            moray: moray,
+            noBucketCache: true
+        }, processResults);
+    }
+
+    _updateRecords();
+}
+
+
+/**
+ * Ensures a bucket has been created, and takes care of updating it and its
+ * contents if it already exists.
+ *
+ * @param opts {Object]:
+ * - `moray`: {Moray Client}
+ * - `bucket` {Object}: bucket definition
+ * - `log` {Bunyan logger}
+ * - `extra` {Object} (optional): extra parameters to pass to constructor
+ * @param callback {Function} `function (err)`
+ */
+function initializeBucket(opts, callback) {
+    assertCommonOpts(opts);
+    assertBucket(opts.bucket);
+    assert.func(callback, 'callback');
+
+    var bucket = opts.bucket;
+    var log = opts.log;
+
+    log.info('begin migration for bucket %s', bucket.name);
+    vasync.pipeline({
+        funcs: [ putBucket, reindex, updateRecords ],
+        arg: {
+            app: opts.app,
+            bucket: bucket,
+            extra: opts.extra || {},
+            log: log,
+            moray: opts.moray,
+            retries: 0
+        }
+    }, function (err, res) {
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        log.trace({ bucket: bucket.name, res: res }, 'migration complete');
+        log.info('end migration for bucket %s', bucket.name);
+        callback();
+    });
+}
+
+
+// --- Exports
 
-var moray = require('moray');
-var VError = require('verror').VError;
 
 /**
  * Creates a new moray client, setting up reconnection logic in the
@@ -24,6 +393,7 @@ var VError = require('verror').VError;
  * @param callback {Function} `function (err, client)`
  */
 function createClient(config, parentLog, callback) {
+    // XXX: Determine & enforce a minimum required Moray version.
     var conf = {
         connectTimeout: 1000,
         host: config.host,
@@ -31,7 +401,6 @@ function createClient(config, parentLog, callback) {
         port: config.port,
         reconnect: true,
         retry: {
-            retries: Infinity,
             maxTimeout: 6000,
             minTimeout: 100
         }
@@ -42,8 +411,15 @@ function createClient(config, parentLog, callback) {
         level: config.logLevel || parentLog.level()
     });
     conf.log.debug(conf, 'Creating moray client');
-    var client = moray.createClient(conf);
+    waitForConnect(mod_moray.createClient(conf), callback);
+}
+
 
+/**
+ * Wait for a Moray client to issue a 'connect' or 'error' event. Log a message
+ * every time a connection attempt is made.
+ */
+function waitForConnect(client, callback) {
     function onMorayConnect() {
         client.removeListener('error', onMorayError);
         client.log.info('moray: connected');
@@ -52,13 +428,13 @@ function createClient(config, parentLog, callback) {
             // care of reconnecting, etc.
             client.log.error(err, 'moray client error');
         });
-        return callback(null, client);
+        callback(null, client);
     }
 
     function onMorayError(err) {
         client.removeListener('connect', onMorayConnect);
         client.log.error(err, 'moray: connection failed');
-        return callback(err);
+        callback(err);
     }
 
     function onMorayConnectAttempt(number, delay) {
@@ -83,55 +459,122 @@ function createClient(config, parentLog, callback) {
 
 
 /**
- * Initializes a moray bucket
+ * Lists objects in moray
  *
- * @param client {MorayClient}
- * @param bucket {Object} : Bucket schema object, as required by
- *     createBucket()
- * @param callback {Function} `function (err)`
+ * @param opts {Object}
+ * - `bucket` {Bucket schema object}
+ * - `filter` {String}
+ * - `limit` {Integer}
+ * - `log` {Bunyan Logger}
+ * - `offset` {Integer}
+ * - `moray` {MorayClient}
+ * - `sort` {Object} (optional)
+ * - `model` {Object} (optional)
+ * - `noBucketCache` {Boolean} (optional)
+ * - `extra` {Object} (optional) extra params to pass to constructor
+ * @param callback {Function} `function (err, netObj)`
  */
-function initBucket(client, bucket, callback) {
-    var att = 1;
-    var timeout = null;
-
-    function initRetry() {
-        client.putBucket(bucket.name, bucket.schema, function (err) {
-            if (timeout) {
-                clearTimeout(timeout);
-            }
+function listObjs(opts, callback) {
+    assertCommonOpts(opts);
+    assert.object(opts.bucket, 'opts.bucket');
+    assert.string(opts.filter, 'opts.filter');
+    assert.optionalFunc(opts.model, 'opts.model');
+    assert.optionalObject(opts.sort, 'opts.sort');
+    assert.optionalNumber(opts.limit, 'opts.limit');
+    assert.optionalNumber(opts.offset, 'opts.offset');
+    assert.optionalBool(opts.noBucketCache, 'opts.noBucketCache');
+    assert.func(callback, 'callback');
 
-            if (!err) {
-                return callback();
-            }
+    var results = [];
+    var listOpts = {};
 
-            client.log.error(err, 'Error initializing buckets (attempt=%d)',
-                att);
-            att++;
-            timeout = setTimeout(initRetry, 10000);
-        });
+    if (opts.sort) {
+        listOpts.sort = opts.sort;
     }
 
-    function versionCheck() {
-        client.version({ log: client.log }, function (v) {
-            if (bucket.hasOwnProperty('morayVersion') &&
-                bucket.morayVersion > v) {
-                client.log.error('Moray is at version %d but bucket ' +
-                    '"%s" requires Moray version %d; will check again in ' +
-                    '10 seconds', v, bucket.name, bucket.morayVersion);
-                setTimeout(versionCheck, 10000);
-                return;
-            }
+    if (opts.limit) {
+        listOpts.limit = opts.limit;
+    } else {
+        listOpts.limit = constants.DEFAULT_LIMIT;
+    }
 
-            initRetry();
-        });
+    if (opts.offset) {
+        listOpts.offset = opts.offset;
     }
 
-    versionCheck();
+    if (opts.noBucketCache) {
+        listOpts.noBucketCache = true;
+    }
+
+    opts.log.debug({ filter: opts.filter }, 'listObjs: Querying Moray');
+
+    var req = opts.moray.findObjects(opts.bucket.name, opts.filter, listOpts);
+
+    req.on('error', callback);
+
+    req.on('record', function _onListRec(rec) {
+        opts.log.trace({ record: rec }, 'record from Moray');
+        if (opts.extra) {
+            Object.keys(opts.extra).forEach(function (k) {
+                rec.value[k] = opts.extra[k];
+            });
+        }
+        results.push(rec);
+    });
+
+    req.on('end', function _endList() {
+        if (opts.model) {
+            async.map(results, function (rec, cb) {
+                try {
+                    cb(null, new opts.model(rec, opts.app));
+                } catch (e) {
+                    cb(e);
+                }
+            }, callback);
+        } else {
+            callback(null, results);
+        }
+    });
 }
 
 
+/**
+ * Migrates records in the buckets for each of the provided models.
+ *
+ * @param opts {Object}:
+ * - `moray` {Moray Client}
+ * - `log` {Bunyan logger}
+ * - `buckets` {Array}: array of bucket objects for each model
+ *  e.g. [ { constructor: mod_rule.Rule, name: 'fwapi_rules', ... } ]
+ * - `extra` {Object} (optional): extra params to pass to constructors
+ * @param callback {Function} `function (err)`
+ */
+function initializeBuckets(opts, callback) {
+    assertCommonOpts(opts);
+    assert.arrayOfObject(opts.buckets, 'opts.buckets');
+    assert.func(callback, 'callback');
+
+    vasync.forEachPipeline({
+        func: function migrateOne(bucket, cb) {
+            initializeBucket({
+                app: opts.app,
+                log: opts.log,
+                extra: opts.extra,
+                moray: opts.moray,
+                bucket: bucket
+            }, cb);
+        },
+        inputs: opts.buckets
+    }, function (err, res) {
+        opts.log.debug({ err: err, res: res }, 'migration results');
+        callback(err);
+    });
+}
+
 
 module.exports = {
     create: createClient,
-    initBucket: initBucket
+    initialize: initializeBuckets,
+    listObjs: listObjs,
+    waitForConnect: waitForConnect
 };
diff --git a/lib/persist.js b/lib/persist.js
index 7149a15..73b2857 100644
--- a/lib/persist.js
+++ b/lib/persist.js
@@ -8,17 +8,23 @@
  * Copyright (c) 2016, Joyent, Inc.
  */
 
-var async = require('async');
+'use strict';
+
 var fw = require('./rule');
 var mod_err = require('./errors');
 var mod_filter = require('./ufds/filter');
+var mod_jsprim = require('jsprim');
+var mod_moray = require('./moray');
 var restify = require('restify');
 var ufdsmodel = require('./ufds/model');
-var util_obj = require('./util/obj');
 var util_validate = require('./util/validate');
+var VError = require('verror');
+
 
+var hasKey = mod_jsprim.hasKey;
 var Rule = fw.Rule;
 
+
 /*
  * Returns a nicely formatted error, rather than the generic UFDS or Moray not
  * found error.
@@ -47,14 +53,16 @@ function checkNotFound(app, uuid, callback) {
     if (app.config.fwrule_version > 2) {
         return function (err, val) {
             if (err) {
-                if (err.name === 'ObjectNotFoundError') {
-                    return callback(notFoundErr(Rule, uuid));
+                if (VError.hasCauseWithName(err, 'ObjectNotFoundError')) {
+                    callback(notFoundErr(Rule, uuid));
+                    return;
                 }
 
-                return callback(err);
+                callback(err);
+                return;
             }
 
-            return callback(null, val);
+            callback(null, val);
         };
     } else {
         return function (err, val) {
@@ -79,9 +87,16 @@ function createRule(app, log, params, callback) {
 
     if (app.config.fwrule_version > 2) {
         try {
-            raw = new Rule(params, app).raw();
-            app.moray.putObject(fw.BUCKET.name, raw.uuid, raw,
-                function (err) { callback(err, new Rule(raw, app)); });
+            raw = (new Rule(params, app)).rawMoray();
+            app.moray.putObject(fw.BUCKET.name, raw.uuid, raw, {
+                etag: null
+            }, function (err) {
+                if (err && VError.hasCauseWithName(err, 'EtagConflictError')) {
+                    callback(mod_err.createExistsErr('Rule', 'uuid'));
+                } else {
+                    callback(err, new Rule({ value: raw }, app));
+                }
+            });
         } catch (e) {
             callback(e);
         }
@@ -92,23 +107,21 @@ function createRule(app, log, params, callback) {
 
 function updateRuleUFDS(app, log, newRule, oldRule, callback) {
     var change;
-    var oldRaw = oldRule.raw();
-    var newRaw = newRule.raw();
+    var oldRaw = oldRule.rawUFDS();
+    var newRaw = newRule.rawUFDS();
     var dn = Rule.dn(newRule.uuid);
 
     for (var r in newRaw) {
         // If the old raw object has the item, we only need to do a 'replace'
-        if (oldRaw.hasOwnProperty(r)) {
+        if (hasKey(oldRaw, r)) {
             delete oldRaw[r];
         }
     }
 
-    if (log.debug()) {
-        log.debug({ oldRaw: oldRaw, newRaw: newRaw },
-            'Updating rule %s', oldRule.uuid);
-    }
+    log.debug({ oldRaw: oldRaw, newRaw: newRaw },
+        'Updating rule %s', oldRule.uuid);
 
-    if (util_obj.isEmpty(oldRaw)) {
+    if (mod_jsprim.isEmpty(oldRaw)) {
         change = {
             operation: 'replace',
             modification: newRaw
@@ -132,17 +145,18 @@ function updateRuleUFDS(app, log, newRule, oldRule, callback) {
 function updateRule(app, log, newRule, oldRule, callback) {
     callback = checkNotFound(app, newRule.uuid, callback);
     if (app.config.fwrule_version > 2) {
-        app.moray.putObject(fw.BUCKET.name, newRule.uuid, newRule.raw(),
+        app.moray.putObject(fw.BUCKET.name, newRule.uuid, newRule.rawMoray(),
             function (err) { callback(err, newRule); });
     } else {
-        return updateRuleUFDS(app, log, newRule, oldRule, callback);
+        updateRuleUFDS(app, log, newRule, oldRule, callback);
     }
 }
 
 function deleteRule(app, log, uuid, callback) {
     if (!util_validate.uuid(uuid)) {
-        return callback(new mod_err.InvalidParamsError(mod_err.INVALID_MSG,
+        callback(new mod_err.InvalidParamsError(mod_err.INVALID_MSG,
             [ mod_err.invalidParam('uuid', 'Invalid UUID') ]));
+        return;
     }
 
     callback = checkNotFound(app, uuid, callback);
@@ -156,23 +170,25 @@ function deleteRule(app, log, uuid, callback) {
 
 function getRule(app, log, uuid, callback) {
     if (!util_validate.uuid(uuid)) {
-        return callback(new mod_err.InvalidParamsError(mod_err.INVALID_MSG,
+        callback(new mod_err.InvalidParamsError(mod_err.INVALID_MSG,
             [ mod_err.invalidParam('uuid', 'Invalid UUID') ]));
+        return;
     }
 
     callback = checkNotFound(app, uuid, callback);
 
     if (app.config.fwrule_version > 2) {
-        return app.moray.getObject(fw.BUCKET.name, uuid, function (err, obj) {
+        app.moray.getObject(fw.BUCKET.name, uuid, function (err, obj) {
             if (err) {
                 log.error(err, 'Error getting rule from Moray');
-                return callback(err);
+                callback(err);
+                return;
             }
 
-            mkRule(obj.value, app, callback);
+            mkRule(obj, app, callback);
         });
     } else {
-        return ufdsmodel.modelGet(app, Rule, Rule.dn(uuid), log, callback);
+        ufdsmodel.modelGet(app, Rule, Rule.dn(uuid), log, callback);
     }
 }
 
@@ -206,15 +222,15 @@ function vmRules(app, log, params, callback) {
     };
     var ruleFilter;
 
-    if (params.hasOwnProperty('vms')) {
+    if (hasKey(params, 'vms')) {
         filter.params.vm = params.vms;
     }
 
-    if (params.hasOwnProperty('tags')) {
+    if (hasKey(params, 'tags')) {
         filter.params.tag = params.tags;
     }
 
-    if (params.hasOwnProperty('owner_uuid')) {
+    if (hasKey(params, 'owner_uuid')) {
         filter.params.owner_uuid = params.owner_uuid;
     }
 
@@ -222,33 +238,32 @@ function vmRules(app, log, params, callback) {
         try {
             ruleFilter = mod_filter.morayRules(filter);
         } catch (err) {
-            return callback(err);
+            callback(err);
+            return;
         }
 
         log.debug('vmRules (Moray): filter=%s', ruleFilter);
 
-        var rules = [];
-        var req = app.moray.findObjects(fw.BUCKET.name, ruleFilter, {});
-        req.once('error', callback);
-        req.on('record', function (obj) {
-            rules.push(obj.value);
-        });
-        req.on('end', function () {
-            async.map(rules, function (rule, cb) {
-                mkRule(rule, app, cb);
-            }, callback);
-        });
+        mod_moray.listObjs({
+            app: app,
+            bucket: fw.BUCKET,
+            filter: ruleFilter,
+            log: log,
+            moray: app.moray,
+            model: Rule
+        }, callback);
     } else {
         try {
             ruleFilter = mod_filter.ufdsRules(filter);
         } catch (err) {
-            return callback(err);
+            callback(err);
+            return;
         }
 
         var parentDn = Rule.parentDn();
         log.debug('vmRules (UFDS): parentDn=%s, filter=%s',
             parentDn, ruleFilter);
-        return ufdsmodel.modelListFiltered(app, fw.Rule, parentDn, ruleFilter,
+        ufdsmodel.modelListFiltered(app, Rule, parentDn, ruleFilter,
             log, callback);
     }
 }
@@ -264,33 +279,32 @@ function findRules(app, log, params, callback) {
         try {
             ruleFilter = mod_filter.morayRules(filter);
         } catch (err) {
-            return callback(err);
+            callback(err);
+            return;
         }
 
         log.debug('findRules (Moray): filter=%s', ruleFilter);
 
-        var rules = [];
-        var req = app.moray.findObjects(fw.BUCKET.name, ruleFilter, {});
-        req.once('error', callback);
-        req.on('record', function (obj) {
-            rules.push(obj.value);
-        });
-        req.on('end', function () {
-            async.map(rules, function (rule, cb) {
-                mkRule(rule, app, cb);
-            }, callback);
-        });
+        mod_moray.listObjs({
+            app: app,
+            bucket: fw.BUCKET,
+            filter: ruleFilter,
+            log: log,
+            moray: app.moray,
+            model: Rule
+        }, callback);
     } else {
         try {
             ruleFilter = mod_filter.ufdsRules(filter);
         } catch (err) {
-            return callback(err);
+            callback(err);
+            return;
         }
 
         var parentDn = Rule.parentDn();
-        log.debug('vmRules (UFDS): parentDn=%s, filter=%s',
+        log.debug('findRules (UFDS): parentDn=%s, filter=%s',
             parentDn, ruleFilter);
-        return ufdsmodel.modelListFiltered(app, fw.Rule, parentDn, ruleFilter,
+        ufdsmodel.modelListFiltered(app, Rule, parentDn, ruleFilter,
             log, callback);
     }
 }
diff --git a/lib/rule.js b/lib/rule.js
index 00d261a..0d90593 100644
--- a/lib/rule.js
+++ b/lib/rule.js
@@ -12,32 +12,38 @@
  * Firewall rule model
  */
 
+'use strict';
+
 var assert = require('assert-plus');
-var clone = require('clone');
 var mod_err = require('./errors');
 var mod_rule = require('fwrule');
-var restify = require('restify');
 var util = require('util');
 var util_ip = require('./util/ip');
 var util_validate = require('./util/validate');
 
 var fmt = util.format;
+var hasKey = require('jsprim').hasKey;
+
+var tagEscape = require('fwrule/lib/rule').tagEscape;
+var tagUnescape = require('fwrule/lib/rule').tagUnescape;
 
 // --- Globals
 
 /*
- * When storing the raw Rule form in Moray, give it a version number, so that
+ * When storing the raw Rule form in Moray, we give it a version number so that
  * older versions can be found and upgraded in the future.
+ *
+ * 1 - Initial version.
+ * 2 - Save tag names/values unescaped, and index on "description".
  */
-var MORAY_RAW_VERSION = 1;
+var MORAY_RAW_VERSION = 2;
 
 var BUCKET = {
     desc: 'fwrules',
     name: 'fwapi_rules',
+    constructor: Rule,
+    version: MORAY_RAW_VERSION,
     schema: {
-        options: {
-            version: MORAY_RAW_VERSION
-        },
         index: {
             'uuid': {
                 'type': 'string',
@@ -45,6 +51,7 @@ var BUCKET = {
             },
             '_v': { 'type': 'number' },
             'version': { 'type': 'string' },
+            'description': { 'type': 'string' },
             'owner': { 'type': 'string' },
             'action': { 'type': 'string' },
             'protocol': { 'type': 'string' },
@@ -97,23 +104,6 @@ var BUCKET = {
 
 
 
-/**
- * Calls callback for all of the firewall target types
- */
-function forEachTarget(obj, callback) {
-    for (var i in mod_rule.DIRECTIONS) {
-        var dir = mod_rule.DIRECTIONS[i];
-        for (var j in mod_rule.TARGET_TYPES) {
-            var type = mod_rule.TARGET_TYPES[j];
-            var targetName = dir + type;
-            if (!obj.hasOwnProperty(targetName)) {
-                continue;
-            }
-            callback(dir, type, targetName, obj[targetName]);
-        }
-    }
-}
-
 /**
  * Converts a rule from Moray to raw format
  */
@@ -134,12 +124,12 @@ function ruleFromMoray(raw) {
         version: raw.version
     };
 
-    if (raw.hasOwnProperty('ports')) {
+    if (hasKey(raw, 'ports')) {
         // See "Port storage in Moray" for how ports get represented
         data.parsed.protocol.targets = raw.ports.map(function (port) {
-            /*JSSTYLED*/
+            /* JSSTYLED */
             var matched = /^\[(\d+),(\d+)\]$/.exec(port);
-            if (matched != null) {
+            if (matched !== null) {
                 var start = Number(matched[1]);
                 var end = Number(matched[2]);
 
@@ -160,11 +150,11 @@ function ruleFromMoray(raw) {
 
     }
 
-    if (raw.hasOwnProperty('types')) {
+    if (hasKey(raw, 'types')) {
         data.parsed.protocol.targets = raw.types;
     }
 
-    if (raw.hasOwnProperty('description')) {
+    if (hasKey(raw, 'description')) {
         data.description = raw.description;
     }
 
@@ -172,14 +162,14 @@ function ruleFromMoray(raw) {
         data.enabled = raw.enabled;
     }
 
-    if (raw.hasOwnProperty('owner')) {
+    if (hasKey(raw, 'owner')) {
         data.owner_uuid = raw.owner;
     }
 
     mod_rule.DIRECTIONS.forEach(function (dir) {
         mod_rule.TARGET_TYPES.forEach(function (type) {
             var key = dir + type + 's';
-            if (!raw.hasOwnProperty(key)) {
+            if (!hasKey(raw, key)) {
                 return;
             }
             var targets = raw[key];
@@ -191,6 +181,14 @@ function ruleFromMoray(raw) {
                         var dividerIdx = Number(t.substring(lastEqIdx + 1));
                         var tagKey = t.substring(0, dividerIdx);
                         var tagVal = t.substring(dividerIdx + 1, lastEqIdx);
+
+                        // Version 1 objects didn't save values unescaped, so
+                        // we take care of that when we load them.
+                        if (raw._v === 1) {
+                            tagKey = tagUnescape(tagKey);
+                            tagVal = tagUnescape(tagVal);
+                        }
+
                         if (tagVal.length !== 0) {
                             t = [tagKey, tagVal];
                         } else {
@@ -227,12 +225,12 @@ function ruleFromUFDS(raw) {
         version: raw.version
     };
 
-    if (raw.hasOwnProperty('ports')) {
+    if (hasKey(raw, 'ports')) {
         data.parsed.protocol.targets =
             (typeof (raw.ports) === 'object' ?  raw.ports  : [ raw.ports ])
             .map(function (port) {
                 var matched = /^(\d+)-(\d+)$/.exec(port);
-                if (matched != null) {
+                if (matched !== null) {
                     return {
                         start: Number(matched[1]),
                         end: Number(matched[2])
@@ -243,12 +241,12 @@ function ruleFromUFDS(raw) {
             });
     }
 
-    if (raw.hasOwnProperty('types')) {
+    if (hasKey(raw, 'types')) {
         data.parsed.protocol.targets = typeof (raw.types) === 'object' ?
             raw.types : [ raw.types ];
     }
 
-    if (raw.hasOwnProperty('description')) {
+    if (hasKey(raw, 'description')) {
         data.description = raw.description;
     }
 
@@ -256,14 +254,14 @@ function ruleFromUFDS(raw) {
         data.enabled = raw.enabled;
     }
 
-    if (raw.hasOwnProperty('owner')) {
+    if (hasKey(raw, 'owner')) {
         data.owner_uuid = raw.owner;
     }
 
     mod_rule.DIRECTIONS.forEach(function (dir) {
         mod_rule.TARGET_TYPES.forEach(function (type) {
             var key = dir + type;
-            if (!raw.hasOwnProperty(key)) {
+            if (!hasKey(raw, key)) {
                 return;
             }
             var targets =
@@ -282,8 +280,9 @@ function ruleFromUFDS(raw) {
                     var lastEqIdx = t.lastIndexOf('=');
                     if (lastEqIdx !== -1) {
                         var dividerIdx = Number(t.substring(lastEqIdx + 1));
-                        var tagKey = t.substring(0, dividerIdx);
-                        var tagVal = t.substring(dividerIdx + 1, lastEqIdx);
+                        var tagKey = tagUnescape(t.substring(0, dividerIdx));
+                        var tagVal = tagUnescape(
+                            t.substring(dividerIdx + 1, lastEqIdx));
                         if (tagVal.length !== 0) {
                             t = [tagKey, tagVal];
                         } else {
@@ -338,20 +337,26 @@ function tagObj(inputList) {
  * @param data {Object} data for instantiating the firewall rule. This can
  * either be:
  * - the public representation
+ * - the raw response from Moray (determined to be this if data.value is
+ *   present)
  * - the raw response from UFDS (determined to be this if data.objectclass is
  *   present)
  * @throws {restify.RESTError} if the given data is invalid.
  */
 function Rule(data, app) {
     assert.object(data, 'fwrule data');
+    assert.object(app, 'app');
 
-    if (data._v) {
+    if (data.value) {
         // Data is from Moray:
-        mod_rule.FwRule.call(this, ruleFromMoray(data));
+        mod_rule.FwRule.call(this, ruleFromMoray(data.value));
+        if (data._etag) {
+            this.etag = data._etag;
+        }
     } else if (data.objectclass) {
         // Data is from UFDS:
         assert.equal(data.objectclass, Rule.objectclass,
-                'Incorrect objectclass returned from UFDS');
+            'Incorrect objectclass returned from UFDS');
         mod_rule.FwRule.call(this, ruleFromUFDS(data));
     } else {
         // Only require the global flag when coming in via the API:
@@ -387,11 +392,11 @@ Rule.prototype.rawMoray = function _ruleRawMoray() {
         _v: MORAY_RAW_VERSION
     };
 
-    if (this.hasOwnProperty('description')) {
+    if (hasKey(this, 'description')) {
         raw.description = this.description;
     }
 
-    if (this.hasOwnProperty('owner_uuid')) {
+    if (hasKey(this, 'owner_uuid')) {
         raw.owner = this.owner_uuid;
     }
 
@@ -405,10 +410,10 @@ Rule.prototype.rawMoray = function _ruleRawMoray() {
      * that uses the range 20-30. Because of this, we store 'PORT ALL' as the
      * full range of possible port numbers.
      */
-    if (this.hasOwnProperty('ports')) {
+    if (hasKey(this, 'ports')) {
         raw.ports = this.ports.map(function (port) {
-            if (port.hasOwnProperty('start') &&
-                port.hasOwnProperty('end')) {
+            if (hasKey(port, 'start') &&
+                hasKey(port, 'end')) {
                 if (port.start === 1 && port.end === 65535)
                     allPorts = true;
                 return fmt('[%s,%s]', port.start, port.end);
@@ -423,7 +428,7 @@ Rule.prototype.rawMoray = function _ruleRawMoray() {
         raw.ports = ['[1,65535]'];
     }
 
-    if (this.hasOwnProperty('types')) {
+    if (hasKey(this, 'types')) {
         raw.types = this.types;
     }
 
@@ -433,7 +438,7 @@ Rule.prototype.rawMoray = function _ruleRawMoray() {
             var keys = {};
             var val;
 
-            if (self[dir].hasOwnProperty(name) &&
+            if (hasKey(self[dir], name) &&
                 self[dir][name].length !== 0) {
                 if (type === 'tag') {
                     /*
@@ -478,6 +483,7 @@ Rule.prototype.rawMoray = function _ruleRawMoray() {
  */
 Rule.prototype.rawUFDS = function _ruleRawUFDS() {
     var self = this;
+    var allPorts = false;
     var raw = {
         action: this.action,
         enabled: this.enabled,
@@ -487,24 +493,33 @@ Rule.prototype.rawUFDS = function _ruleRawUFDS() {
         version: this.version
     };
 
-    if (this.hasOwnProperty('description')) {
+    if (hasKey(this, 'description')) {
         raw.description = this.description;
     }
 
-    if (this.hasOwnProperty('owner_uuid')) {
+    if (hasKey(this, 'owner_uuid')) {
         raw.owner = this.owner_uuid;
     }
 
-    if (this.hasOwnProperty('ports')) {
+    if (hasKey(this, 'ports')) {
         raw.ports = this.ports.map(function (port) {
-            if (port.hasOwnProperty('start') &&
-                port.hasOwnProperty('end')) {
+            if (hasKey(port, 'start') &&
+                hasKey(port, 'end')) {
+                if (port.start === 1 && port.end === 65535)
+                    allPorts = true;
                 return port.start + '-' + port.end;
+            } else if (port === 'all') {
+                allPorts = true;
+                return 'all';
             } else return port;
         });
     }
 
-    if (this.hasOwnProperty('types')) {
+    if (allPorts) {
+        raw.ports = ['all'];
+    }
+
+    if (hasKey(this, 'types')) {
         raw.types = this.types;
     }
 
@@ -513,7 +528,7 @@ Rule.prototype.rawUFDS = function _ruleRawUFDS() {
             var name = type + 's';
             var val;
 
-            if (self[dir].hasOwnProperty(name) &&
+            if (hasKey(self[dir], name) &&
                 self[dir][name].length !== 0) {
                 if (type === 'ip') {
                     val = self[dir][name].map(function (ip) {
@@ -527,13 +542,19 @@ Rule.prototype.rawUFDS = function _ruleRawUFDS() {
                     // Tag storage in UFDS:
                     //
                     // Tags are stored in the format "key=val=n", where
-                    // n is the length of key
+                    // n is the length of key.
+                    //
+                    // For backwards compatibility reasons, they are stored
+                    // in their escaped form. To support firewall rules that
+                    // use escape sequences in tags, migrate to Moray.
                     val = self[dir][name].map(function (tag) {
-                        var tagKey = tag;
-                        var tagVal = '';
+                        var tagKey, tagVal;
                         if (typeof (tag) === 'object') {
-                            tagKey = tag[0];
-                            tagVal = tag[1];
+                            tagKey = tagEscape(tag[0]);
+                            tagVal = tagEscape(tag[1]);
+                        } else {
+                            tagKey = tagEscape(tag);
+                            tagVal = '';
                         }
 
                         return fmt('%s=%s=%d', tagKey, tagVal, tagKey.length);
@@ -542,7 +563,7 @@ Rule.prototype.rawUFDS = function _ruleRawUFDS() {
                     val = self[dir][name];
                 }
 
-                raw [dir + type] = val;
+                raw[dir + type] = val;
             }
         });
     });
@@ -550,10 +571,27 @@ Rule.prototype.rawUFDS = function _ruleRawUFDS() {
     return raw;
 };
 
+
 Rule.prototype.raw = function _ruleRaw() {
-    return this.app.config.fwrule_version > 2 ?
-        this.rawMoray() :
-        this.rawUFDS();
+    throw new Error(
+        '.rawMoray() or .rawUFDS() should be used in place of .raw()');
+};
+
+
+/**
+ * Generate a value suitable for using in a Moray .batch() operation.
+ */
+Rule.prototype.batch = function () {
+    var raw = this.rawMoray();
+    return {
+        bucket: BUCKET.name,
+        key: raw.uuid,
+        operation: 'put',
+        value: raw,
+        options: {
+            etag: this.etag
+        }
+    };
 };
 
 /**
@@ -568,7 +606,7 @@ Rule.prototype.serialize = function _ruleSerialize(opts) {
     }
 
     function addParsed() {
-        if (!ser.hasOwnProperty('parsed')) {
+        if (!hasKey(ser, 'parsed')) {
             ser.parsed = {};
         }
     }
diff --git a/lib/ufds/filter.js b/lib/ufds/filter.js
index 0b8fbc9..09172e9 100644
--- a/lib/ufds/filter.js
+++ b/lib/ufds/filter.js
@@ -12,78 +12,121 @@
  * Helpers for filtering UFDS data
  */
 
+'use strict';
+
 var fw = require('../rule');
-var isEmpty = require('../util/obj').isEmpty;
 var mod_err = require('../errors');
+var mod_filter = require('moray-filter');
+var mod_jsprim = require('jsprim');
 var mod_rule = require('../rule');
 var restify = require('restify');
 var util = require('util');
 var validators = require('fwrule').validators;
 
 var fmt = util.format;
+var hasKey = mod_jsprim.hasKey;
+var isEmpty = mod_jsprim.isEmpty;
+
+var AndFilter = mod_filter.AndFilter;
+var EqualityFilter = mod_filter.EqualityFilter;
+var OrFilter = mod_filter.OrFilter;
+var SubstringFilter = mod_filter.SubstringFilter;
+var OwnerlessFilter = mod_filter.parse('(!(owner=*))');
 
 
 // --- Internal helpers
 
 
+function eq(attribute, val) {
+    return new EqualityFilter({
+        attribute: attribute,
+        value: val
+    });
+}
+
+
+function and(filters) {
+    return new AndFilter({ filters: filters });
+}
+
+
+function or(filters) {
+    return new OrFilter({ filters: filters });
+}
+
+
+function substring(attribute, substrs) {
+    return new SubstringFilter({
+        attribute: attribute,
+        initial: '',
+        any: substrs,
+        final: ''
+    });
+}
+
 
 /**
- * Turn a value into an array, unless it is one already.
+ * Turn a value into an array, unless it is one already,
+ * or is an object.
  */
 function arrayify(obj) {
     if (typeof (obj) === 'object') {
         return obj;
     }
 
-    return obj.split(',');
+    return [ obj ];
 }
 
-function ruleCommonFilter(opts, filter) {
+
+function ruleCommonFilter(opts) {
     var params = opts.params;
+    var filter = [];
 
-    if (opts.hasOwnProperty('operation') && (opts.operation !== 'OR')) {
+    if (hasKey(opts, 'operation') && (opts.operation !== 'OR')) {
         throw new restify.InvalidArgumentError(
             'Invalid operation "%s" for filter', opts.operation);
     }
 
-    if (params.hasOwnProperty('enabled')) {
-        if ((params.enabled != 'true') && (params.enabled != 'false')) {
+    if (hasKey(params, 'enabled')) {
+        if ((params.enabled !== 'true') && (params.enabled !== 'false')) {
             throw new restify.InvalidArgumentError(
                 'Invalid value for enabled: must be true or false');
         }
-        filter.push(fmt('(enabled=%s)', params.enabled));
+        filter.push(eq('enabled', params.enabled));
     }
 
-    if (params.hasOwnProperty('port')) {
+    if (hasKey(params, 'port')) {
         if (!validators.validatePortOrAll(params.port)) {
             throw new restify.InvalidArgumentError(
                 'port is invalid');
         }
-        filter.push(fmt('(port=%s)', params.port.toLowerCase()));
+        filter.push(eq('port', params.port.toLowerCase()));
     }
 
-    if (params.hasOwnProperty('protocol')) {
+    if (hasKey(params, 'protocol')) {
         if (!validators.validateProtocol(params.protocol)) {
             throw new restify.InvalidArgumentError(
                 fmt('Invalid value for protocol: must be one of: %s',
                     fw.PROTOCOLS.join(', ')));
         }
-        filter.push(fmt('(protocol=%s)', params.protocol));
+        filter.push(eq('protocol', params.protocol));
     }
 
-    if (params.hasOwnProperty('action')) {
+    if (hasKey(params, 'action')) {
         if (!validators.validateAction(params.action)) {
             throw new restify.InvalidArgumentError(
                 fmt('Invalid value for action: must be one of: %s',
-                fw.ACTIONS.join(', ')));
+                    fw.ACTIONS.join(', ')));
         }
-        filter.push(fmt('(action=%s)', params.action));
+        filter.push(eq('action', params.action));
     }
 
     // Allow passing in "global" to include global rules in our query
     if (params.global) {
-        filter.push('(!(owner=*))');
+        filter.push(OwnerlessFilter);
     }
+
+    return filter;
 }
 
 
@@ -116,33 +159,17 @@ function ruleCommonFilter(opts, filter) {
  *     - tag {String or Array}
  */
 function ruleMorayFilter(opts) {
-    var filter = [];
     var log = opts.log;
     var params = opts.params;
 
-    ruleCommonFilter(opts, filter);
-
-    function beginOR() {
-        if (opts.operation !== 'OR') {
-            filter.push('(|');
-        }
-    }
-
-    // As in "forest moon of"
-    function endOR() {
-        if (opts.operation !== 'OR') {
-            filter.push(')');
-        }
-    }
+    var filter = ruleCommonFilter(opts);
 
     // tags are a special case: we can filter on tag key alone, or both
     // key and value
-    if (params.hasOwnProperty('tag')) {
-        if (typeof (params.tag === 'string')) {
-            params.tag = arrayify(params.tag);
-        }
+    if (hasKey(params, 'tag')) {
+        params.tag = arrayify(params.tag);
 
-        if (util.isArray(params.tag)) {
+        if (Array.isArray(params.tag)) {
             params.tag = params.tag.reduce(function (acc, arrTag) {
                 acc[arrTag] = true;
                 return acc;
@@ -150,7 +177,7 @@ function ruleMorayFilter(opts) {
         }
 
         if (!isEmpty(params.tag)) {
-            beginOR();
+            var tagFilter = [];
 
             for (var t in params.tag) {
                 // See "Tag storage in Moray" in lib/rule.js for
@@ -159,51 +186,47 @@ function ruleMorayFilter(opts) {
                 if (params.tag[t] === true) {
                     // Looking for all tags with a given key (don't care
                     // about values)
-                    filter.push(fmt('(fromtagkeys=%s)', t));
-                    filter.push(fmt('(totagkeys=%s)', t));
+                    tagFilter.push(eq('fromtagkeys', t));
+                    tagFilter.push(eq('totagkeys', t));
                 } else {
                     // Looking for key=value, though we still want to get
                     // rules that refer only to the key name
 
                     // This gets tags that just have the key, no value
                     // (eg "FROM tag foo TO ...), since these apply too.
-                    filter.push(fmt('(fromtags=%s==%d)', t, t.length));
-                    filter.push(fmt('(totags=%s==%d)', t, t.length));
+                    var emptyVal = fmt('%s==%d', t, t.length);
+                    tagFilter.push(eq('fromtags', emptyVal));
+                    tagFilter.push(eq('totags', emptyVal));
 
                     var tagVals = util.isArray(params.tag[t]) ?
                         params.tag[t] : [ params.tag[t] ];
 
                     for (var v in tagVals) {
-                        filter.push(fmt('(fromtags=%s=%s=%d)',
-                            t, tagVals[v], t.length));
-                        filter.push(fmt('(totags=%s=%s=%d)',
-                            t, tagVals[v], t.length));
+                        var tagVal = fmt('%s=%s=%d', t, tagVals[v], t.length);
+                        tagFilter.push(eq('fromtags', tagVal));
+                        tagFilter.push(eq('totags', tagVal));
                     }
                 }
             }
 
-            endOR();
+            filter.push(or(tagFilter));
         }
     }
 
     // Other non-tag rule target types
     fw.TARGET_TYPES.forEach(function (type) {
-        var name = type + 's';
         if (type === 'tag') {
             return;
         }
 
-        if (params.hasOwnProperty(type)) {
+        if (hasKey(params, type)) {
             var types = arrayify(params[type]);
             if (types.length !== 0) {
-                beginOR();
-
-                types.forEach(function (val) {
-                    filter.push(fmt('(from%s=%s)', name, val));
-                    filter.push(fmt('(to%s=%s)', name, val));
-                });
-
-                endOR();
+                filter.push(or(types.reduce(function (arr, val) {
+                    arr.push(eq('from' + type + 's', val));
+                    arr.push(eq('to' + type + 's', val));
+                    return arr;
+                }, [])));
             }
         }
     });
@@ -217,25 +240,21 @@ function ruleMorayFilter(opts) {
      *     '(fromvms=X)', '(tovms=X)', '(fromtags=Y)', '(totags=Y)'
      */
     var needsAND = false;
-    if (params.hasOwnProperty('owner_uuid')) {
-        var ownerFilter = [ fmt('(owner=%s)', params.owner_uuid) ];
+    if (hasKey(params, 'owner_uuid')) {
+        var ownerFilter = eq('owner', params.owner_uuid);
 
         if (opts.ownerlessRules) {
-            ownerFilter.unshift('(|');
-            ownerFilter.push('(!(owner=*))');
-            ownerFilter.push(')');
+            ownerFilter = or([ ownerFilter, OwnerlessFilter ]);
         }
 
         if (opts.operation !== 'OR') {
             // This is just another condition to add to the list of things
             // to AND
-            filter = ownerFilter.concat(filter);
+            filter.push(ownerFilter);
         } else {
             // The owner filter is ANDed with the rest of the filter, so stick
             // an OR in front of them
-            filter.unshift('(|');
-            filter.push(')');
-            filter = ownerFilter.concat(filter);
+            filter = [ ownerFilter, or(filter) ];
             needsAND = true;
         }
     }
@@ -245,16 +264,13 @@ function ruleMorayFilter(opts) {
         return '(uuid=*)';
     }
 
+    var filterTxt;
     if (opts.operation !== 'OR' || needsAND) {
-        filter.unshift('(&');
-        filter.push(')');
+        filterTxt = and(filter).toString();
     } else {
-        filter.unshift('(|');
-        filter.push(')');
+        filterTxt = or(filter).toString();
     }
 
-    var filterTxt = filter.join('');
-
     log.debug('ruleMorayFilter: filter=%s', filterTxt);
     return filterTxt;
 }
@@ -286,31 +302,15 @@ function ruleMorayFilter(opts) {
  *     - tag {String or Array}
  */
 function ruleUFDSFilter(opts) {
-    var filter = [];
     var log = opts.log;
     var params = opts.params;
 
-    function beginOR() {
-        if (opts.operation !== 'OR') {
-            filter.push('(|');
-        }
-    }
-
-    // As in "forest moon of"
-    function endOR() {
-        if (opts.operation !== 'OR') {
-            filter.push(')');
-        }
-    }
-
-    ruleCommonFilter(opts, filter);
+    var filter = ruleCommonFilter(opts);
 
     // tags are a special case: we can filter on tag key alone, or both
     // key and value
-    if (params.hasOwnProperty('tag')) {
-        if (typeof (params.tag === 'string')) {
-            params.tag = arrayify(params.tag);
-        }
+    if (hasKey(params, 'tag')) {
+        params.tag = arrayify(params.tag);
 
         if (util.isArray(params.tag)) {
             params.tag = params.tag.reduce(function (acc, arrTag) {
@@ -320,7 +320,7 @@ function ruleUFDSFilter(opts) {
         }
 
         if (!isEmpty(params.tag)) {
-            beginOR();
+            var tagFilter = [];
 
             for (var t in params.tag) {
                 // See "Tag storage in UFDS" in lib/rule.js for
@@ -329,8 +329,9 @@ function ruleUFDSFilter(opts) {
                 if (params.tag[t] === true) {
                     // Looking for all tags with a given key (don't care
                     // about values)
-                    filter.push(fmt('(fromtag=*%s=*=%d*)', t, t.length));
-                    filter.push(fmt('(totag=*%s=*=%d*)', t, t.length));
+                    var tagName = [ t + '=', '=' + t.length ];
+                    tagFilter.push(substring('fromtag', tagName));
+                    tagFilter.push(substring('totag', tagName));
 
                 } else {
                     // Looking for key=value, though we still want to get
@@ -338,20 +339,23 @@ function ruleUFDSFilter(opts) {
 
                     // This gets tags that just have the key, no value
                     // (eg "FROM tag foo TO ...), since these apply too.
-                    filter.push(fmt('(fromtag=*%s==%d*)', t, t.length));
-                    filter.push(fmt('(totag=*%s==%d*)', t, t.length));
+                    var emptyVal = [ fmt('%s==%d', t, t.length) ];
+                    tagFilter.push(substring('fromtag', emptyVal));
+                    tagFilter.push(substring('totag', emptyVal));
 
                     var tagVals = util.isArray(params.tag[t]) ?
                         params.tag[t] : [ params.tag[t] ];
 
                     for (var v in tagVals) {
-                        filter.push(fmt('(fromtag=*%s=%s=*)', t, tagVals[v]));
-                        filter.push(fmt('(totag=*%s=%s=*)', t, tagVals[v]));
+                        var tagVal =
+                            [ fmt('%s=%s=%d', t, tagVals[v], t.length) ];
+                        tagFilter.push(substring('fromtag', tagVal));
+                        tagFilter.push(substring('totag', tagVal));
                     }
                 }
             }
 
-            endOR();
+            filter.push(or(tagFilter));
         }
     }
 
@@ -361,17 +365,15 @@ function ruleUFDSFilter(opts) {
             return;
         }
 
-        if (params.hasOwnProperty(type)) {
+        if (hasKey(params, type)) {
             var types = arrayify(params[type]);
             if (types.length !== 0) {
-                beginOR();
-
-                types.forEach(function (val) {
-                    if (type == 'ip') {
+                filter.push(or(types.reduce(function (arr, val) {
+                    if (type === 'ip') {
                         val = mod_rule.raw.ip(val);
                     }
 
-                    if (type == 'subnet') {
+                    if (type === 'subnet') {
                         if (!validators.validateIPv4subnet(val)) {
                             throw mod_err.invalidParamErr('subnet');
                         }
@@ -379,11 +381,10 @@ function ruleUFDSFilter(opts) {
                         val = mod_rule.raw.subnet(val);
                     }
 
-                    filter.push(fmt('(from%s=*%s*)', type, val));
-                    filter.push(fmt('(to%s=*%s*)', type, val));
-                });
-
-                endOR();
+                    arr.push(substring('from' + type, [ val ]));
+                    arr.push(substring('to' + type, [ val ]));
+                    return arr;
+                }, [])));
             }
         }
     });
@@ -396,25 +397,21 @@ function ruleUFDSFilter(opts) {
     //     '(fromvm=X)', '(tovm=X)', '(fromtag=Y)', '(totag=Y)'
 
     var needsAND = false;
-    if (params.hasOwnProperty('owner_uuid')) {
-        var ownerFilter = [ fmt('(owner=%s)', params.owner_uuid) ];
+    if (hasKey(params, 'owner_uuid')) {
+        var ownerFilter = eq('owner', params.owner_uuid);
 
         if (opts.ownerlessRules) {
-            ownerFilter.unshift('(|');
-            ownerFilter.push('(!(owner=*))');
-            ownerFilter.push(')');
+            ownerFilter = or([ ownerFilter, OwnerlessFilter ]);
         }
 
         if (opts.operation !== 'OR') {
             // This is just another condition to add to the list of things
             // to AND
-            filter = ownerFilter.concat(filter);
+            filter.push(ownerFilter);
         } else {
             // The owner filter is ANDed with the rest of the filter, so stick
             // an OR in front of them
-            filter.unshift('(|');
-            filter.push(')');
-            filter = ownerFilter.concat(filter);
+            filter = [ ownerFilter, or(filter) ];
             needsAND = true;
         }
     }
@@ -423,16 +420,13 @@ function ruleUFDSFilter(opts) {
         return '';
     }
 
+    var filterTxt;
     if (opts.operation !== 'OR' || needsAND) {
-        filter.unshift('(&');
-        filter.push(')');
+        filterTxt = and(filter).toString();
     } else {
-        filter.unshift('(|');
-        filter.push(')');
+        filterTxt = or(filter).toString();
     }
 
-    var filterTxt = filter.join('');
-
     log.debug('ruleUFDSFilter: filter=%s', filterTxt);
     return filterTxt;
 }
diff --git a/lib/ufds/model.js b/lib/ufds/model.js
index 9526ad3..373579c 100644
--- a/lib/ufds/model.js
+++ b/lib/ufds/model.js
@@ -21,14 +21,14 @@
  *     Foo.parentDnFromRequest = function (req) {...}
  *     Foo.prototype.serialize = function serialize() {...}  # output for API
  *                                                             responses
- *     <instance>.raw     = function raw() {...}  # the raw UFDS data
+ *     <instance>.rawUFDS = function raw() {...}  # the raw UFDS data
  *     <instance>.dn      s# the UFDS DN for this object
  */
 
-var clone = require('clone');
+'use strict';
+
 var mod_err = require('../errors');
 var restify = require('restify');
-var RestCodes = restify.RestCodes;
 
 
 
@@ -118,28 +118,31 @@ function modelPost(app, Model, data, log, callback) {
         item = new Model(data, app);
     } catch (e) {
         log.error(e, 'modelPost: <%s> constructor error', Model.name);
-        return callback(e);
+        callback(e);
+        return;
     }
 
     var dn = item.dn;
-    app.ufds.add(dn, item.raw(), function (err) {
+    app.ufds.add(dn, item.rawUFDS(), function (err) {
         if (err) {
-            log.error({ err: err, raw: item.raw() },
+            log.error({ err: err, raw: item.rawUFDS() },
                 'modelPost: Error saving dn=%s', dn);
 
             // XXX: should change sdc-clients to use WError instead
-            if (err.name == 'InvalidArgumentError' &&
+            if (err.name === 'InvalidArgumentError' &&
                 err.message.indexOf('already exists') !== -1) {
-                err = new mod_err.createExistsErr(Model.name, item.idName);
+                err = mod_err.createExistsErr(Model.name, item.idName);
             }
 
-            return callback(err);
+            callback(err);
+            return;
         }
 
         if (log.trace()) {
             log.trace(item.serialize(), 'modelPost: <%s> create', Model.name);
         }
-        return callback(null, item);
+
+        callback(null, new Model(item.rawUFDS(), app));
     });
 }
 
@@ -159,7 +162,7 @@ function modelPut(app, Model, dn, data, log, callback) {
 
     var change = {
         operation: 'replace',
-        modification: item.raw()
+        modification: item.rawUFDS()
     };
 
     return modify(app, Model, dn, change, log, callback);
@@ -171,7 +174,8 @@ function modify(app, Model, dn, change, log, callback) {
         if (err) {
             log.error({ err: err, change: change },
                 'modify: Error updating <%s> (dn=%s)', Model.name, dn);
-            return callback(err);
+            callback(err);
+            return;
         }
 
         if (log.debug()) {
@@ -229,174 +233,12 @@ function modelGet(app, Model, dn, log, callback) {
 }
 
 
-function modelDelete(app, Model, dn, log, callback) {
+function modelDelete(app, _Model, dn, _log, callback) {
     // TODO: could validate the 'dn'
     app.ufds.del(dn, callback);
 }
 
 
-
-// --- request/response wrappers around the above helpers
-
-
-
-function requestList(req, res, next, Model) {
-    req.log.trace('<%s> list entered: params=%o, uriParams=%o',
-        Model.name, req.params, req.uriParams);
-
-    var parentDn;
-    try {
-        parentDn = Model.parentDnFromRequest(req);
-    } catch (err) {
-        req.log.error({ err: err, params: req.params},
-                'requestList: <%s>: error getting parent DN', Model.name);
-        return next(err);
-    }
-
-    modelList(req._app, Model, parentDn, req.log, function (err, items) {
-        if (err) {
-            return next(err);
-        }
-
-        var serialized = [];
-        for (var i in items) {
-            serialized.push(items[i].serialize());
-        }
-        res.send(200, serialized);
-        return next();
-    });
-}
-
-
-function requestListFiltered(opts, next) {
-    var req = opts.req;
-    var res = opts.res;
-    var Model = opts.model;
-    var filter = opts.filter;
-    var serializeOpts = opts.serializeOpts;
-
-    req.log.trace({
-        filter: filter,
-        params: req.params,
-        uriParams: req.uriParams
-    }, '<%s> list filtered entered', Model.name);
-
-    var parentDn;
-    try {
-        parentDn = Model.parentDnFromRequest(req);
-    } catch (err) {
-        req.log.error({ err: err, params: req.params},
-            'requestListFiltered: <%s>: error getting parent DN', Model.name);
-        return next(err);
-    }
-
-    modelListFiltered(req._app, Model, parentDn, filter, req.log,
-        function (err, items) {
-        if (err) {
-            return next(err);
-        }
-
-        res.send(200, items.map(function (it) {
-            if (serializeOpts) {
-                return it.serialize(serializeOpts);
-            }
-
-            return it.serialize();
-        }));
-
-        return next();
-    });
-}
-
-
-function requestPost(req, res, next, Model, populateCallback) {
-    req.log.trace('<%s> create entered: params=%o, uriParams=%o',
-        Model.name, req.params, req.uriParams);
-
-    // Note this means that the *route variable names* need to match the
-    // expected `data` key names in the models (e.g. `monitors.Monitor`).
-    var data = clone(req.params);
-    if (populateCallback) {
-        populateCallback(req, data);
-    }
-
-    modelPost(req._app, Model, data, req.log, function (err, item) {
-        if (err) {
-            return next(err);
-        }
-
-        res.send(200, item.serialize());
-        return next();
-    });
-}
-
-
-function requestPut(req, res, next, Model, populateCallback) {
-    req.log.trace(req.params, 'requestPut: <%s> update entered', Model.name);
-
-    // Note this means that the *route variable names* need to match the
-    // expected `data` key names in the models (e.g. `monitors.Monitor`).
-    var data = clone(req.params);
-    if (populateCallback) {
-        populateCallback(req, data);
-    }
-
-    var dn;
-    try {
-        dn = Model.dnFromRequest(req);
-    } catch (err) {
-        return next(err);
-    }
-
-    modelPut(req._app, Model, dn, data, req.log, function (err, item) {
-        if (err) {
-            return next(err);
-        }
-
-        res.send(200, item.serialize());
-        return next();
-    });
-}
-
-
-function requestGet(req, res, next, Model) {
-    req.log.trace(req.params, '<%s> get entered', Model.name);
-
-    var dn;
-    try {
-        dn = Model.dnFromRequest(req);
-    } catch (err) {
-        return next(err);
-    }
-
-    modelGet(req._app, Model, dn, req.log, function (err, item) {
-        if (err) {
-            return next(err);
-        }
-
-        res.send(200, item.serialize());
-        return next();
-    });
-}
-
-
-function requestDelete(req, res, next, Model) {
-    req.log.trace('<%s> delete entered: params=%o, uriParams=%o',
-        Model.name, req.params, req.uriParams);
-
-    var dn = Model.dnFromRequest(req);
-    modelDelete(req._app, Model, dn, req.log, function (err) {
-        if (err) {
-            return next(err);
-        }
-
-        res.send(204);
-        return next();
-    });
-}
-
-
-
 module.exports = {
     modelDelete: modelDelete,
     modelGet: modelGet,
@@ -404,11 +246,5 @@ module.exports = {
     modelListFiltered: modelListFiltered,
     modelPost: modelPost,
     modelPut: modelPut,
-    modify: modify,
-    requestDelete: requestDelete,
-    requestGet: requestGet,
-    requestList: requestList,
-    requestListFiltered: requestListFiltered,
-    requestPost: requestPost,
-    requestPut: requestPut
+    modify: modify
 };
diff --git a/lib/update.js b/lib/update.js
index 56e81fe..9b16d83 100644
--- a/lib/update.js
+++ b/lib/update.js
@@ -12,29 +12,43 @@
  * Server for queuing updates and streaming them to clients
  */
 
+'use strict';
+
 var assert = require('assert-plus');
-var mod_moray = require('./moray');
 var stream = require('fast-stream');
 var util = require('util');
 var uuid = require('node-uuid');
 
 
+var hasKey = require('jsprim').hasKey;
+
 
 // --- Globals
 
 
+/*
+ * We assign a version number to objects so that older versions can be found
+ * and upgraded in the future.
+ *
+ * 1 - Initial version.
+ * 2 - Index on "name"
+ */
+var UPDATE_RAW_VERSION = 1;
 
 var BUCKET = {
     name: 'fwapi_updates',
+    constructor: UpdateMsg,
+    version: UPDATE_RAW_VERSION,
     schema: {
         index: {
-            host: { type: 'string' },
             uuid: { type: 'string', unique: true },
+            host: { type: 'string' },
+            name: { type: 'string' },
             _v: { type: 'number' }
         }
-    }
+    },
+    morayVersion: 1
 };
-var UPDATE_VERSION = 1;
 
 
 
@@ -48,8 +62,6 @@ var UPDATE_VERSION = 1;
  * @param opts {Object} : configuration properties
  */
 function UpdateServer(opts) {
-    var self = this;
-
     assert.object(opts, 'opts');
     assert.object(opts.log, 'opts.log');
     assert.object(opts.config, 'opts.config');
@@ -64,8 +76,6 @@ function UpdateServer(opts) {
     assert.number(opts.config.fast.port, 'opts.config.fast.port');
 
     this.config = opts.config;
-    // XXX: get the servers from SAPI
-    this.hosts = [ opts.config.host ];
     this.log = opts.log.child({ component: 'updater' });
     this.stream = stream.createServer({
         log: this.log,
@@ -76,13 +86,14 @@ function UpdateServer(opts) {
     this.morayConnected = false;
     this.listening = false;
     this.initialized = false;
-
-    this.__defineGetter__('clients', function () {
-        return self.stream.state.clients;
-    });
 }
 
 
+Object.defineProperty(UpdateServer.prototype, 'clients', {
+    get: function () { return this.stream.state.clients; }
+});
+
+
 /**
  * Closes the fast server
  */
@@ -91,7 +102,10 @@ UpdateServer.prototype.close = function close() {
         clearTimeout(this.timeout);
     }
 
-    this.stream.close();
+    if (this.initialized) {
+        this.initialized = false;
+        this.stream.close();
+    }
 };
 
 
@@ -99,7 +113,7 @@ UpdateServer.prototype.close = function close() {
  * Starts the fast server, initializes the moray updates bucket, and starts
  * polling moray for updates
  */
-UpdateServer.prototype.init = function init(client) {
+UpdateServer.prototype.init = function init(client, callback) {
     var self = this;
     self.moray = client;
     self.morayConnected = true;
@@ -108,17 +122,9 @@ UpdateServer.prototype.init = function init(client) {
         self.log.info('fast-stream server listening on port %d',
             self.config.fast.port);
         self.listening = true;
-    });
-
-    // Moray's up, so we can now make sure all buckets are created
-    mod_moray.initBucket(client, BUCKET, function (err) {
-        if (err) {
-            self.log.error(err, 'Error initializing buckets');
-            return;
-        }
-
         self.initialized = true;
         self.poll();
+        callback();
     });
 };
 
@@ -145,15 +151,16 @@ UpdateServer.prototype.ping = function ping() {
  */
 UpdateServer.prototype.poll = function poll() {
     var self = this;
+
+    if (!self.initialized) {
+        self.log.warn('poll: not initialized, skipping poll');
+        return;
+    }
+
     self.log.debug('poll: begin');
 
-    var filter = '(&'
-            + util.format('(host=%s)', self.config.host)
-            + '(|'
-                + '(!(_v=*))'
-                + util.format('(_v=%d)', UPDATE_VERSION)
-            + ')'
-        + ')';
+    var filter = util.format('(&(host=%s)(|(!(_v=*))(_v=%d)))',
+        self.config.host, UPDATE_RAW_VERSION);
 
     var keys = [];
     var listOpts = {
@@ -193,7 +200,7 @@ UpdateServer.prototype.poll = function poll() {
         };
 
         // For backwards compat
-        if (rec.value.hasOwnProperty('payload')) {
+        if (hasKey(rec.value, 'payload')) {
             toSend.value = rec.value.payload;
         }
 
@@ -238,28 +245,23 @@ UpdateServer.prototype.poll = function poll() {
  * @param callback {Function} `function (err)`
  */
 UpdateServer.prototype.queue = function queueUpdate(name, value, callback) {
-    var self = this;
     var updateUUID = uuid.v4();
-    var batch = this.hosts.map(function (h) {
-        return {
-            bucket: BUCKET.name,
-            key: updateUUID,
-            operation: 'put',
-            value: {
-                _v: UPDATE_VERSION,
-                host: self.config.host,
-                name: name,
-                value: value
-            }
-        };
+    var update = new UpdateMsg({
+        key: updateUUID,
+        value: {
+            host: this.config.host,
+            name: name,
+            value: value
+        }
     });
 
-    this.moray.batch(batch, function (err, res) {
+    this.moray.batch([ update.batch() ], function (err, res) {
         if (err) {
-            return callback(err);
+            callback(err);
+            return;
         }
 
-        return callback(null, { uuid: updateUUID, batch: res });
+        callback(null, { uuid: updateUUID });
     });
 };
 
@@ -279,7 +281,50 @@ function createServer(opts) {
 }
 
 
+function UpdateMsg(record, app) {
+    assert.object(record, 'record');
+    assert.uuid(record.key, 'record.key');
+    assert.object(record.value, 'record.value');
+    assert.string(record.value.name, 'record.value.name');
+    assert.object(record.value.value, 'record.value.name');
+    assert.optionalString(record.etag, 'record.key');
+
+    this.uuid = record.key;
+    this.data = record.value;
+    this.etag = record.etag || null;
+    this.app = app;
+
+    Object.seal(this);
+}
+
+
+UpdateMsg.prototype.rawMoray = function () {
+    return {
+        uuid: this.uuid,
+        host: this.data.host,
+        name: this.data.name,
+        value: this.data.value,
+        _v: UPDATE_RAW_VERSION
+    };
+};
+
+
+UpdateMsg.prototype.batch = function () {
+    var raw = this.rawMoray();
+    return {
+        bucket: BUCKET.name,
+        key: raw.uuid,
+        operation: 'put',
+        value: raw,
+        options: {
+            etag: this.etag
+        }
+    };
+};
+
 
 module.exports = {
-    createServer: createServer
+    BUCKET: BUCKET,
+    createServer: createServer,
+    UpdateMsg: UpdateMsg
 };
diff --git a/lib/util/array.js b/lib/util/array.js
index b0e9c27..d030374 100644
--- a/lib/util/array.js
+++ b/lib/util/array.js
@@ -12,6 +12,8 @@
  * Array utilities
  */
 
+'use strict';
+
 var util = require('util');
 
 
diff --git a/lib/util/constants.js b/lib/util/constants.js
index 6d5d903..bc853a7 100644
--- a/lib/util/constants.js
+++ b/lib/util/constants.js
@@ -13,10 +13,10 @@
  */
 
 
-
-// --- Globals
+'use strict';
 
 
+// --- Globals
 
 var PARSED_FIELDS = [
     'parsed.action',
@@ -29,6 +29,10 @@ var UUID_REGEX =
     /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
 
 module.exports = {
+    DEFAULT_LIMIT: 1000,
+    MAX_RETRIES: 5,
+    RETRY_DELAY: 5000,
+
     UUID_REGEX: UUID_REGEX,
     PARSED_FIELDS: PARSED_FIELDS
 };
diff --git a/lib/util/ip.js b/lib/util/ip.js
index a8e2e81..4a6e752 100644
--- a/lib/util/ip.js
+++ b/lib/util/ip.js
@@ -12,10 +12,9 @@
  * IP-related utilities
  */
 
-var net = require('net');
-
+'use strict';
 
-var MAX_IP = 4294967295;
+var net = require('net');
 
 
 /*
@@ -53,40 +52,7 @@ function numberToAddress(num) {
 }
 
 
-/*
- * Converts CIDR (/xx) bits to netmask
- */
-function bitsToNetmask(bits) {
-    var n = 0;
-
-    for (var i = 0; i < (32 - bits); i++) {
-        n |= 1 << i;
-    }
-    return numberToAddress(MAX_IP - n);
-}
-
-
-/*
- * Converts netmask to CIDR (/xx) bits
- */
-function netmaskToBits(netmask) {
-    var num = ~addressToNumber(netmask);
-    var b = 0;
-    for (b = 0; b < 32; b++) {
-        if (num === 0) {
-            break;
-        }
-        num = num >>> 1;
-    }
-    return 32 - b;
-}
-
-
 module.exports = {
-    addressToNumber: addressToNumber,
     aton: addressToNumber,
-    bitsToNetmask: bitsToNetmask,
-    netmaskToBits: netmaskToBits,
-    numberToAddress: numberToAddress,
     ntoa: numberToAddress
 };
diff --git a/lib/util/obj.js b/lib/util/obj.js
deleted file mode 100644
index 4f6882b..0000000
--- a/lib/util/obj.js
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2014, Joyent, Inc.
- */
-
-/*
- * Object utilities
- */
-
-
-
-// --- Exports
-
-
-
-/**
- * Returns true if the object has no keys
- */
-function isEmpty(obj) {
-    /* JSSTYLED */
-    /*jsl:ignore*/
-    for (var k in obj) {
-        return false;
-    }
-    /* JSSTYLED */
-    /*jsl:end*/
-
-    return true;
-}
-
-
-
-module.exports = {
-    isEmpty: isEmpty
-};
diff --git a/lib/util/validate.js b/lib/util/validate.js
index d7a04c7..be7b4da 100644
--- a/lib/util/validate.js
+++ b/lib/util/validate.js
@@ -12,6 +12,8 @@
  * Validation functions
  */
 
+'use strict';
+
 var assert = require('assert-plus');
 var constants = require('./constants');
 var mod_arr = require('./array');
diff --git a/package.json b/package.json
index d05cf32..4abc2b1 100644
--- a/package.json
+++ b/package.json
@@ -5,7 +5,11 @@
   "author": "Joyent",
   "private": true,
   "devDependencies": {
-    "ldapjs": "0.6.3",
+    "moray-sandbox": "git+https://github.com/joyent/node-moray-sandbox.git#master",
+    "faucet": "0.0.1",
+    "istanbul": "^0.4.0",
+    "eslint": "2.13.1",
+    "eslint-plugin-joyent": "1.0.1",
     "mockery": "1.4.0"
   },
   "dependencies": {
@@ -17,16 +21,18 @@
     "effluent-logger": "git+https://github.com/joshwilsdon/effluent-logger.git#d662f161a07f94045ad2afb45442931511c40e51",
     "extsprintf": "1.0.2",
     "fast-stream": "git+https://github.com/joyent/sdc-fast-stream.git#893d59d",
-    "fwrule": "git+https://github.com/joyent/sdc-fwrule.git#d1174be",
-    "moray": "git+https://github.com/joyent/node-moray.git#b84ef0e",
+    "fwrule": "1.3.1",
+    "jsprim": "1.3.1",
+    "moray": "^2.0.0",
+    "moray-filter": "1.0.0",
     "tape": "4.2.2",
     "node-uuid": "1.2.0",
-    "sdc-clients": "git+https://github.com/joyent/node-sdc-clients.git#5b10072",
-    "ufds": "git+https://github.com/joyent/node-ufds.git#a7c674b76696fe7ab0fff1e2486f20d3af6a0d1a",
+    "sdc-clients": "9.5.0",
+    "ufds": "1.2.0",
     "restify": "git+https://github.com/mcavage/node-restify.git#0d7b4ba",
     "trace-event": "1.3.0",
-    "vasync": "1.3",
-    "verror": "1.3",
+    "vasync": "1.6.4",
+    "verror": "^1.9.0",
     "xtend": "4.0"
   },
   "license": "MPL-2.0"
diff --git a/server.js b/server.js
index dcc76fb..954f379 100644
--- a/server.js
+++ b/server.js
@@ -12,6 +12,8 @@
  * Main entry-point for the firewall API.
  */
 
+'use strict';
+
 var fwapi = require('./lib/app');
 var assert = require('assert-plus');
 var bunyan = require('bunyan');
@@ -80,7 +82,11 @@ function main() {
         process.exit(1);
     }
 
-    server.listen(function () {
+    server.listen(function (lErr) {
+        if (lErr) {
+            throw lErr;
+        }
+
         var addr = server.info();
         log.info('%s listening on <http://%s:%s>',
             addr.name, addr.address, addr.port);
diff --git a/test/integration/get.test.js b/test/integration/get.test.js
index 3a7a084..8f1b07f 100644
--- a/test/integration/get.test.js
+++ b/test/integration/get.test.js
@@ -12,6 +12,8 @@
  * Integration tests for getting rules
  */
 
+'use strict';
+
 var test = require('tape');
 var mod_rule = require('../lib/rule');
 var mod_uuid = require('node-uuid');
@@ -35,13 +37,13 @@ var RULES = [
     {
         enabled: true,
         owner_uuid: OWNERS[1],
-        rule: 'FROM (tag foo = bar OR tag foo = baz) '
-            + 'TO tag side = two ALLOW tcp (PORT 5003 AND PORT 5004)'
+        rule: 'FROM (tag "foo" = "bar" OR tag "foo" = "baz") '
+            + 'TO tag "side" = "two" ALLOW tcp (PORT 5003 AND PORT 5004)'
     },
     {
         enabled: true,
         global: true,
-        rule: 'FROM any TO tag foo = baz ALLOW tcp PORT 5010'
+        rule: 'FROM any TO tag "foo" = "baz" ALLOW tcp PORT 5010'
     }
 ];
 
diff --git a/test/integration/global.test.js b/test/integration/global.test.js
index ddc021f..18cc44b 100644
--- a/test/integration/global.test.js
+++ b/test/integration/global.test.js
@@ -12,12 +12,11 @@
  * Integration tests for global rules
  */
 
+'use strict';
+
 var test = require('tape');
-var async = require('async');
-var h = require('./helpers');
 var mod_rule = require('../lib/rule');
 var mod_uuid = require('node-uuid');
-var util = require('util');
 
 
 
@@ -26,12 +25,12 @@ var util = require('util');
 
 
 var FORBIDDEN_BODY = {
-    code : 'Forbidden',
-    message : 'owner does not match',
-    errors : [ {
-        'field' : 'owner_uuid',
-        'code' : 'InvalidParameter',
-        'message' : 'owner_uuid does not match'
+    code: 'Forbidden',
+    message: 'owner does not match',
+    errors: [ {
+        'field': 'owner_uuid',
+        'code': 'InvalidParameter',
+        'message': 'owner_uuid does not match'
     } ]
 };
 var OWNERS = [ mod_uuid.v4() ];
diff --git a/test/integration/helpers.js b/test/integration/helpers.js
index 1167407..c67161b 100644
--- a/test/integration/helpers.js
+++ b/test/integration/helpers.js
@@ -12,6 +12,8 @@
  * Test helpers for FWAPI integration tests
  */
 
+'use strict';
+
 var common = require('../lib/common');
 
 
diff --git a/test/integration/list.test.js b/test/integration/list.test.js
index 0968f52..03ece44 100644
--- a/test/integration/list.test.js
+++ b/test/integration/list.test.js
@@ -12,14 +12,13 @@
  * Integration tests for listing rules
  */
 
+'use strict';
+
 var test = require('tape');
-var async = require('async');
 var constants = require('../../lib/util/constants');
 var extend = require('xtend');
-var h = require('./helpers');
 var mod_rule = require('../lib/rule');
 var mod_uuid = require('node-uuid');
-var util = require('util');
 
 
 
@@ -65,13 +64,13 @@ var RULES = [
     {
         enabled: true,
         owner_uuid: OWNERS[1],
-        rule: 'FROM tag foo TO all vms BLOCK udp PORT all'
+        rule: 'FROM tag "foo" TO all vms BLOCK udp PORT all'
     },
     {
         enabled: true,
         owner_uuid: OWNERS[1],
-        rule: 'FROM (tag foo = bar OR tag foo = baz) '
-            + 'TO tag side = two ALLOW tcp (PORT 5003 AND PORT 5004)'
+        rule: 'FROM (tag "foo" = "bar" OR tag "foo" = "baz") '
+            + 'TO tag "side" = "two" ALLOW tcp (PORT 5003 AND PORT 5004)'
     }
 ];
 
@@ -120,12 +119,12 @@ test('list: all ports', function (t) {
         rule: {
             enabled: true,
             owner_uuid: OWNERS[2],
-            rule: 'FROM tag foo TO all vms BLOCK udp PORTS 1 - 200, 1 - 65535'
+            rule: 'FROM tag "foo" TO all vms BLOCK udp PORTS 1 - 200, 1 - 65535'
         },
         exp: {
             enabled: true,
             owner_uuid: OWNERS[2],
-            rule: 'FROM tag foo TO all vms BLOCK udp PORT all'
+            rule: 'FROM tag "foo" TO all vms BLOCK udp PORT all'
         }
     }, function (err) {
         t.ifError(err, 'creating range of all ports should be successful');
diff --git a/test/integration/provision.multi-test.js b/test/integration/provision.multi-test.js
index 4093e92..f4c7658 100644
--- a/test/integration/provision.multi-test.js
+++ b/test/integration/provision.multi-test.js
@@ -12,14 +12,12 @@
  * Provision workflow and FWAPI integration tests
  */
 
+'use strict';
+
 var test = require('tape');
-var async = require('async');
 var config = require('../lib/config');
-var fmt = require('util').format;
-var log = require('../lib/log');
 var mod_cn = require('../lib/cn');
 var mod_rule = require('../lib/rule');
-var mod_uuid = require('node-uuid');
 var mod_vm = require('../lib/vm');
 var util = require('util');
 
@@ -80,7 +78,7 @@ test('Add rules', function (t) {
             description: 'allow SSH',
             enabled: true,
             owner_uuid: OWNERS[0],
-            rule: util.format('FROM any TO tag %s ALLOW tcp PORT 22',
+            rule: util.format('FROM any TO tag "%s" ALLOW tcp PORT 22',
                 TAGS.ssh)
         };
 
@@ -95,7 +93,7 @@ test('Add rules', function (t) {
             description: 'allow DNS',
             enabled: true,
             owner_uuid: OWNERS[0],
-            rule: util.format('FROM any TO tag %s ALLOW udp PORT 53',
+            rule: util.format('FROM any TO tag "%s" ALLOW udp PORT 53',
                 TAGS.dns)
         };
 
@@ -146,7 +144,8 @@ test('Provision VMs', function (t) {
             VMS = res;
         }
 
-        return t.end();
+        t.ifError(err, 'Provisioning VMs should succeed');
+        t.end();
     });
 });
 
@@ -225,8 +224,8 @@ test('Add disabled rule', function (t) {
             description: 'allow DB',
             enabled: false,
             owner_uuid: OWNERS[0],
-            rule: util.format('FROM (tag %s = 1 OR tag %s = 2) TO ' +
-                '(tag %s = 1 OR tag %s = 2) ALLOW tcp PORT 5432',
+            rule: util.format('FROM (tag "%s" = "1" OR tag "%s" = "2") TO ' +
+                '(tag "%s" = "1" OR tag "%s" = "2") ALLOW tcp PORT 5432',
                 TAGS.db, TAGS.db, TAGS.db, TAGS.db)
         };
 
diff --git a/test/integration/resolve.test.js b/test/integration/resolve.test.js
index f0721bb..17801ef 100644
--- a/test/integration/resolve.test.js
+++ b/test/integration/resolve.test.js
@@ -12,14 +12,14 @@
  * Unit tests for /resolve endpoint
  */
 
+'use strict';
+
 var test = require('tape');
 var assert = require('assert-plus');
-var async = require('async');
 var fmt = require('util').format;
-var helpers = require('./helpers');
 var mod_rule = require('../lib/rule');
 var mod_uuid = require('node-uuid');
-var util = require('util');
+var vasync = require('vasync');
 
 
 
@@ -80,27 +80,82 @@ test('setup', function (t) {
     var rules = [];
     RULES = {
         o0: {
+            unicodeRole: {
+                rule: 'FROM (tag "" = "" OR tag "" = "") '
+                    + 'TO ip 8.8.8.8 BLOCK udp PORT 53'
+            },
+            escapedTag1: {
+                rule: 'FROM (tag "[" = "*" OR tag "]" = "=") '
+                    + 'TO ip 8.8.8.8 BLOCK tcp PORT 80'
+            },
+            escapedTag2: {
+                rule: 'FROM (tag "*" = "=" OR tag "\\\\") '
+                    + 'TO ip 8.8.8.8 BLOCK tcp PORT 80'
+            },
+            escapedTag3: {
+                rule: 'FROM (tag "\\"" = "*" OR tag "=" = "a") '
+                    + 'TO ip 8.8.8.8 BLOCK tcp PORT 80'
+            },
+            escapedTag4: {
+                rule: 'FROM tag "=" = "*" '
+                    + 'TO ip 8.8.8.8 BLOCK tcp PORT 80'
+            },
+            escapedTag5: {
+                rule: 'FROM tag "<=" = "*" '
+                    + 'TO ip 8.8.8.8 BLOCK tcp PORT 80'
+            },
+            escapedTag6: {
+                rule: 'FROM tag "<=" = "\\)" '
+                    + 'TO ip 8.8.8.8 BLOCK tcp PORT 80'
+            },
+            escapedTag7: {
+                rule: 'FROM tag "\\(" = "\\(" '
+                    + 'TO ip 8.8.8.8 BLOCK tcp PORT 80'
+            },
+            commaTag: {
+                rule: 'FROM tag "foo,other" TO ip 8.8.8.8 BLOCK tcp PORT 80'
+            },
+            ampersandTag: {
+                rule: 'FROM tag "foo&other" TO ip 8.8.8.8 BLOCK tcp PORT 80'
+            },
+            dotTag: {
+                rule: 'FROM tag "foo.other" TO ip 8.8.8.8 BLOCK tcp PORT 80'
+            },
+            pipeTag: {
+                rule: 'FROM tag "foo|other" TO ip 8.8.8.8 BLOCK tcp PORT 80'
+            },
+            hopTag1: {
+                rule: 'FROM tag "hasOwnProperty" TO ip 8.8.8.8 BLOCK '
+                    + 'tcp PORT 80'
+            },
+            hopTag2: {
+                rule: 'FROM tag "quux" = "hasOwnProperty" TO ip 8.8.8.8 BLOCK '
+                    + 'tcp PORT 80'
+            },
             otherToRole: {
-                rule: 'FROM tag other TO tag role ALLOW tcp PORT 5432'
+                rule: 'FROM tag "other" TO tag "role" ALLOW tcp PORT 5432'
             },
             vm0ToRoleWeb: {
                 rule: fmt(
-                    'FROM vm %s TO tag role = web ALLOW tcp PORT 80', VMS[0])
+                    'FROM vm %s TO tag "role" = "web" ALLOW tcp PORT 80',
+                    VMS[0])
             },
             fooToRoleWeb: {
-                rule: 'FROM (tag foo = bar OR tag foo = baz) TO tag role = web '
-                    + 'ALLOW tcp PORT 5433'
+                rule: 'FROM (tag "foo" = "bar" OR tag "foo" = "baz") '
+                    + 'TO tag "role" = "web" ALLOW tcp PORT 5433'
             },
             vm1ToRoleOther: {
                 rule: fmt(
-                    'FROM vm %s TO tag role = other ALLOW tcp PORT 81', VMS[1])
+                    'FROM vm %s TO tag "role" = "other" ALLOW tcp PORT 81',
+                    VMS[1])
             },
             nowThenToRoleOther: {
-                rule:
-                    'FROM tag now = then TO tag role = other ALLOW tcp PORT 82'
+                rule: 'FROM tag "now" = "then" TO tag "role" = "other" ALLOW '
+                    + 'tcp PORT 82'
             },
             numOneToNumTwo: {
-                rule: 'FROM tag num = one TO tag num = two ALLOW tcp PORT 55'
+                rule: 'FROM tag "num" = "one" TO tag "num" = "two" ALLOW '
+                    + 'tcp PORT 55'
             }
         },
 
@@ -116,7 +171,7 @@ test('setup', function (t) {
         o2: {
             oneToAll: {
                 owner_uuid: OWNERS[2],
-                rule: 'FROM tag one TO all vms BLOCK udp PORT 55',
+                rule: 'FROM tag "one" TO all vms BLOCK udp PORT 55',
                 enabled: true
             }
         },
@@ -124,7 +179,7 @@ test('setup', function (t) {
         o3: {
             oneToAll: {
                 owner_uuid: OWNERS[3],
-                rule: 'FROM tag one TO all vms ALLOW udp PORT 56',
+                rule: 'FROM tag "one" TO all vms ALLOW udp PORT 56',
                 enabled: true
             }
         },
@@ -132,7 +187,7 @@ test('setup', function (t) {
         o4: {
             allToOne: {
                 owner_uuid: OWNERS[4],
-                rule: 'FROM all vms TO tag one BLOCK udp PORT 57',
+                rule: 'FROM all vms TO tag "one" BLOCK udp PORT 57',
                 enabled: true
             }
         },
@@ -140,7 +195,7 @@ test('setup', function (t) {
         o5: {
             allToOne: {
                 owner_uuid: OWNERS[5],
-                rule: 'FROM all vms TO tag one ALLOW udp PORT 58',
+                rule: 'FROM all vms TO tag "one" ALLOW udp PORT 58',
                 enabled: true
             }
         },
@@ -148,26 +203,27 @@ test('setup', function (t) {
         o6: {
             vmToOne: {
                 owner_uuid: OWNERS[6],
-                rule: fmt('FROM vm %s TO tag one ALLOW udp PORT 59', VMS[4]),
+                rule: fmt('FROM vm %s TO tag "one" ALLOW udp PORT 59', VMS[4]),
                 enabled: true
             },
 
             vmToOneTwo: {
                 owner_uuid: OWNERS[6],
-                rule: fmt('FROM vm %s TO tag one = two ALLOW udp PORT 59',
+                rule: fmt('FROM vm %s TO tag "one" = "two" ALLOW udp PORT 59',
                     VMS[4]),
                 enabled: true
             },
 
             vmToOneThree: {
                 owner_uuid: OWNERS[6],
-                rule: 'FROM any TO tag one = three ALLOW udp PORT 59',
+                rule: 'FROM any TO tag "one" = "three" ALLOW udp PORT 59',
                 enabled: true
             },
 
             vmToMultiTags: {
                 owner_uuid: OWNERS[6],
-                rule: fmt('FROM vm %s TO (tag five = six OR tag three = four) '
+                rule: fmt('FROM vm %s TO '
+                    + '(tag "five" = "six" OR tag "three" = "four") '
                     + 'ALLOW udp PORT 58', VMS[3]),
                 enabled: true
             },
@@ -210,13 +266,17 @@ test('setup', function (t) {
         }
     }
 
-    async.forEachSeries(rules, function (rule, cb) {
-        mod_rule.createAndGet(t, {
-            rule: rule,
-            exp: rule
-        }, cb);
+    vasync.forEachPipeline({
+        inputs: rules,
+        func: function (rule, cb) {
+            mod_rule.createAndGet(t, {
+                rule: rule,
+                exp: rule
+            }, cb);
+        }
     }, function (err) {
-        return t.end();
+        t.ifError(err, 'All creates and gets should succeed');
+        t.end();
     });
 });
 
@@ -499,6 +559,189 @@ test('resolve', function (t) {
             vms: [ VMS[3] ]
         } ],
 
+    [   O_STR[0] + 'escaped tags 1',
+        {
+            owner_uuid: OWNERS[0],
+            tags: { '[': true }
+        },
+        {
+            allVMs: false,
+            owner_uuid: OWNERS[0],
+            rules: [ RULES.o0.escapedTag1 ],
+            tags: { },
+            vms: []
+        } ],
+
+    [   O_STR[0] + 'escaped tags 2',
+        {
+            owner_uuid: OWNERS[0],
+            tags: { '*': true }
+        },
+        {
+            allVMs: false,
+            owner_uuid: OWNERS[0],
+            rules: [ RULES.o0.escapedTag2 ],
+            tags: { },
+            vms: []
+        } ],
+
+    [   O_STR[0] + 'escaped tags 3 (fails on UFDS: quote not stored unescaped)',
+        {
+            owner_uuid: OWNERS[0],
+            tags: { '"': true }
+        },
+        {
+            allVMs: false,
+            owner_uuid: OWNERS[0],
+            rules: [ RULES.o0.escapedTag3 ],
+            tags: { },
+            vms: []
+        } ],
+
+    [   O_STR[0] + 'escaped tags 3 & 4 (fails on UFDS: query finds extra rule)',
+        {
+            owner_uuid: OWNERS[0],
+            tags: { '=': true }
+        },
+        {
+            allVMs: false,
+            owner_uuid: OWNERS[0],
+            rules: oRules(0, [ 'escapedTag3', 'escapedTag4' ]),
+            tags: { },
+            vms: []
+        } ],
+
+
+    [   O_STR[0] + 'escaped tags 4 (fails on UFDS: query finds 2 extra rules)',
+        {
+            owner_uuid: OWNERS[0],
+            tags: { '=': [ '*' ] }
+        },
+        {
+            allVMs: false,
+            owner_uuid: OWNERS[0],
+            rules: oRules(0, [ 'escapedTag4' ]),
+            tags: { },
+            vms: []
+        } ],
+
+    [   O_STR[0] + 'escaped tags 5',
+        {
+            owner_uuid: OWNERS[0],
+            tags: { '<=': [ '*' ] }
+        },
+        {
+            allVMs: false,
+            owner_uuid: OWNERS[0],
+            rules: oRules(0, [ 'escapedTag5' ]),
+            tags: { },
+            vms: []
+        } ],
+
+    [   O_STR[0] + 'escaped tags 6 (fails on UFDS: paren not stored unescaped)',
+        {
+            owner_uuid: OWNERS[0],
+            tags: { '<=': [ ')' ] }
+        },
+        {
+            allVMs: false,
+            owner_uuid: OWNERS[0],
+            rules: oRules(0, [ 'escapedTag6' ]),
+            tags: { },
+            vms: []
+        } ],
+
+    [   O_STR[0] + 'escaped tags 7 (fails on UFDS: paren not stored unescaped)',
+        {
+            owner_uuid: OWNERS[0],
+            tags: { '(': [ '(' ] }
+        },
+        {
+            allVMs: false,
+            owner_uuid: OWNERS[0],
+            rules: oRules(0, [ 'escapedTag7' ]),
+            tags: { },
+            vms: []
+        } ],
+
+    [   O_STR[0] + 'tag with comma',
+        {
+            owner_uuid: OWNERS[0],
+            tags: { 'foo,other': true }
+        },
+        {
+            allVMs: false,
+            owner_uuid: OWNERS[0],
+            rules: oRules(0, [ 'commaTag' ]),
+            tags: { },
+            vms: []
+        } ],
+
+    [   O_STR[0] + 'tag with ampersand',
+        {
+            owner_uuid: OWNERS[0],
+            tags: { 'foo&other': true }
+        },
+        {
+            allVMs: false,
+            owner_uuid: OWNERS[0],
+            rules: oRules(0, [ 'ampersandTag' ]),
+            tags: { },
+            vms: []
+        } ],
+
+    [   O_STR[0] + 'tag with dot',
+        {
+            owner_uuid: OWNERS[0],
+            tags: { 'foo.other': true }
+        },
+        {
+            allVMs: false,
+            owner_uuid: OWNERS[0],
+            rules: oRules(0, [ 'dotTag' ]),
+            tags: { },
+            vms: []
+        } ],
+
+    [   O_STR[0] + 'tag with pipe',
+        {
+            owner_uuid: OWNERS[0],
+            tags: { 'foo|other': true }
+        },
+        {
+            allVMs: false,
+            owner_uuid: OWNERS[0],
+            rules: oRules(0, [ 'pipeTag' ]),
+            tags: { },
+            vms: []
+        } ],
+
+    [   O_STR[0] + 'tag name "hasOwnProperty"',
+        {
+            owner_uuid: OWNERS[0],
+            tags: { 'hasOwnProperty': true }
+        },
+        {
+            allVMs: false,
+            owner_uuid: OWNERS[0],
+            rules: oRules(0, [ 'hopTag1' ]),
+            tags: { },
+            vms: []
+        } ],
+
+    [   O_STR[0] + 'tag value "hasOwnProperty"',
+        {
+            owner_uuid: OWNERS[0],
+            tags: { 'quux': 'hasOwnProperty' }
+        },
+        {
+            allVMs: false,
+            owner_uuid: OWNERS[0],
+            rules: oRules(0, [ 'hopTag2' ]),
+            tags: { },
+            vms: []
+        } ],
+
     [   fmt('%sVM 5 (%s)', O_STR[0], VMS[5]),
         {
             owner_uuid: OWNERS[6],
@@ -526,21 +769,85 @@ test('resolve', function (t) {
         } ]
     ];
 
-    async.forEachSeries(exp, function (data, cb) {
-        mod_rule.resolve(t, {
-            desc: ': ' + data[0],
-            params: data[1],
-            exp: data[2]
-        }, cb);
+    vasync.forEachPipeline({
+        inputs: exp,
+        func: function (data, cb) {
+            mod_rule.resolve(t, {
+                desc: ': ' + data[0],
+                params: data[1],
+                exp: data[2]
+            }, cb);
 
+        }
     }, function (err) {
-        return t.end();
+        t.ifError(err, 'All queries should resolve');
+        t.end();
     });
 });
 
 
 test('list', function (t) {
     var exp = [
+    [   { owner_uuid: OWNERS[0], tag: 'other' },
+        oRules(0, [ 'otherToRole' ])
+    ],
+
+    [   { owner_uuid: OWNERS[0], tag: '[' },
+        oRules(0, [ 'escapedTag1' ])
+    ],
+
+    [   { owner_uuid: OWNERS[0], tag: ']' },
+        oRules(0, [ 'escapedTag1' ])
+    ],
+
+    [   { owner_uuid: OWNERS[0], tag: ')' },
+        oRules(0, [])
+    ],
+
+    [   { owner_uuid: OWNERS[0], tag: '(((' },
+        oRules(0, [])
+    ],
+
+    [   { owner_uuid: OWNERS[0], tag: ')))' },
+        oRules(0, [])
+    ],
+
+    [   { owner_uuid: OWNERS[0], tag: '*' },
+        oRules(0, [ 'escapedTag2' ])
+    ],
+
+    [   { owner_uuid: OWNERS[0], tag: '<=' },
+        oRules(0, [ 'escapedTag5', 'escapedTag6' ])
+    ],
+
+    [   { owner_uuid: OWNERS[0], tag: 'foo,other' },
+        oRules(0, [ 'commaTag' ])
+    ],
+
+    [   { owner_uuid: OWNERS[0], tag: 'foo&other' },
+        oRules(0, [ 'ampersandTag' ])
+    ],
+
+    [   { owner_uuid: OWNERS[0], tag: 'foo.other' },
+        oRules(0, [ 'dotTag' ])
+    ],
+
+    [   { owner_uuid: OWNERS[0], tag: 'foo|other' },
+        oRules(0, [ 'pipeTag' ])
+    ],
+
+    [   { owner_uuid: OWNERS[0], tag: 'hasOwnProperty' },
+        oRules(0, [ 'hopTag1' ])
+    ],
+
+    [   { owner_uuid: OWNERS[0], tag: '' },
+        oRules(0, [ 'unicodeRole' ])
+    ],
+
+    [   { owner_uuid: OWNERS[0], tag: '' },
+        oRules(0, [ 'unicodeRole' ])
+    ],
+
     [   { owner_uuid: OWNERS[0], tag: 'role' },
         oRules(0, [ 'otherToRole', 'vm0ToRoleWeb', 'fooToRoleWeb',
             'vm1ToRoleOther', 'nowThenToRoleOther' ])
@@ -572,14 +879,53 @@ test('list', function (t) {
 
     ];
 
-    async.forEachSeries(exp, function (data, cb) {
-        mod_rule.list(t, {
-            params: data[0],
-            exp: data[1]
-        }, cb);
+    vasync.forEachPipeline({
+        inputs: exp,
+        func: function (data, cb) {
+            mod_rule.list(t, {
+                params: data[0],
+                exp: data[1]
+            }, cb);
+
+        }
+    }, function (err) {
+        t.ifError(err, 'Querying rules should succeed');
+        t.end();
+    });
+});
+
 
+test('list (these fail with UFDS)', function (t) {
+    var exp = [
+    [   { owner_uuid: OWNERS[0], tag: '\\' },
+        oRules(0, [ 'escapedTag2' ])
+    ],
+
+    [   { owner_uuid: OWNERS[0], tag: '"' },
+        oRules(0, [ 'escapedTag3' ])
+    ],
+
+    [   { owner_uuid: OWNERS[0], tag: '=' },
+        oRules(0, [ 'escapedTag3', 'escapedTag4' ])
+    ],
+
+    [   { owner_uuid: OWNERS[0], tag: '(' },
+        oRules(0, [ 'escapedTag7' ])
+    ]
+
+    ];
+
+    vasync.forEachPipeline({
+        inputs: exp,
+        func: function (data, cb) {
+            mod_rule.list(t, {
+                params: data[0],
+                exp: data[1]
+            }, cb);
+        }
     }, function (err) {
-        return t.end();
+        t.ifError(err, 'Querying rules should succeed');
+        t.end();
     });
 });
 
diff --git a/test/integration/update.test.js b/test/integration/update.test.js
index 4bbf13d..ea8f33d 100644
--- a/test/integration/update.test.js
+++ b/test/integration/update.test.js
@@ -12,11 +12,12 @@
  * Update tests for /rules endpoints
  */
 
+'use strict';
+
 var test = require('tape');
 var async = require('async');
 var mod_rule = require('../lib/rule');
 var mod_uuid = require('node-uuid');
-var util = require('util');
 
 
 
@@ -39,7 +40,7 @@ test('Add rule', function (t) {
     RULES.push({
         enabled: true,
         owner_uuid: OWNERS[0],
-        rule: 'FROM all vms TO tag test BLOCK tcp PORT 8000'
+        rule: 'FROM all vms TO tag "test" BLOCK tcp PORT 8000'
     });
 
     mod_rule.create(t, {
@@ -49,12 +50,21 @@ test('Add rule', function (t) {
 });
 
 
+test('Adding same rule again fails', function (t) {
+    mod_rule.create(t, {
+        rule: RULES[0],
+        expCode: 422,
+        expErr: mod_rule.alreadyExistsErr
+    });
+});
+
+
 test('Update rule', function (t) {
     var exp = [
     [
         'remove all vms',
         {
-            rule: 'FROM ip 10.0.0.1 TO tag test BLOCK '
+            rule: 'FROM ip 10.0.0.1 TO tag "test" BLOCK '
                 + 'tcp PORT 8000'
         }
 
@@ -62,35 +72,35 @@ test('Update rule', function (t) {
         'add 2 IPs',
         {
             rule: 'FROM (ip 10.0.0.1 OR ip 10.0.0.2 OR ip 10.0.0.3) TO '
-                + 'tag test BLOCK tcp PORT 8000'
+                + 'tag "test" BLOCK tcp PORT 8000'
         }
 
     ], [
         'remove 1 IP',
         {
             rule: 'FROM (ip 10.0.0.1 OR ip 10.0.0.3) TO '
-                + 'tag test BLOCK tcp PORT 8000'
+                + 'tag "test" BLOCK tcp PORT 8000'
         }
 
     ], [
         'add a tag',
         {
             rule: 'FROM (ip 10.0.0.1 OR ip 10.0.0.3) TO '
-                + '(tag test OR tag test2) BLOCK tcp PORT 8000'
+                + '(tag "test" OR tag "test2") BLOCK tcp PORT 8000'
         }
 
     ], [
         'add a value to a tag',
         {
             rule: 'FROM (ip 10.0.0.1 OR ip 10.0.0.3) TO '
-                + '(tag test OR tag test2 = foo) BLOCK tcp PORT 8000'
+                + '(tag "test" OR tag "test2" = "foo") BLOCK tcp PORT 8000'
         }
 
     ], [
         'add another value to a tag',
         {
             rule: 'FROM (ip 10.0.0.1 OR ip 10.0.0.3) TO '
-                + '(tag test OR tag test2 = foo OR tag test2 = foo2) '
+                + '(tag "test" OR tag "test2" = "foo" OR tag "test2" = "foo2") '
                 + 'BLOCK tcp PORT 8000'
         }
 
@@ -98,7 +108,7 @@ test('Update rule', function (t) {
         'remove a tag and value',
         {
             rule: 'FROM (ip 10.0.0.1 OR ip 10.0.0.3) TO '
-                + 'tag test BLOCK tcp PORT 8000'
+                + 'tag "test" BLOCK tcp PORT 8000'
         }
 
     ], [
diff --git a/test/integration/vm-update.multi-test.js b/test/integration/vm-update.multi-test.js
index 5b8ca88..5741018 100644
--- a/test/integration/vm-update.multi-test.js
+++ b/test/integration/vm-update.multi-test.js
@@ -12,6 +12,8 @@
  * Provision workflow and FWAPI integration tests
  */
 
+'use strict';
+
 var test = require('tape');
 var config = require('../lib/config');
 var mod_cn = require('../lib/cn');
@@ -75,7 +77,7 @@ test('Add rules', function (t) {
             enabled: true,
             owner_uuid: OWNERS[0],
             rule: util.format(
-                'FROM tag %s = one TO tag %s = two ALLOW tcp PORT 22',
+                'FROM tag "%s" = "one" TO tag "%s" = "two" ALLOW tcp PORT 22',
                 TAGS.role, TAGS.role)
         };
 
@@ -91,7 +93,7 @@ test('Add rules', function (t) {
             enabled: true,
             owner_uuid: OWNERS[0],
             rule: util.format(
-                'FROM tag %s TO tag %s ALLOW tcp PORT 5432',
+                'FROM tag "%s" TO tag "%s" ALLOW tcp PORT 5432',
                 TAGS.web, TAGS.db)
         };
 
diff --git a/test/lib/client.js b/test/lib/client.js
index 1790d19..052465b 100644
--- a/test/lib/client.js
+++ b/test/lib/client.js
@@ -12,6 +12,8 @@
  * Test helpers for dealing with SDC clients
  */
 
+'use strict';
+
 var config = require('./config');
 var RestifyClient = require('sdc-clients/lib/restifyclient');
 var FWAPI = require('sdc-clients/lib/fwapi');
@@ -62,5 +64,6 @@ function getClient(type) {
 
 
 module.exports = {
+    CLIENTS: CLIENTS,
     get: getClient
 };
diff --git a/test/lib/cn.js b/test/lib/cn.js
index 4ad7091..edf7df2 100644
--- a/test/lib/cn.js
+++ b/test/lib/cn.js
@@ -12,6 +12,8 @@
  * CN interaction helpers
  */
 
+'use strict';
+
 var assert = require('assert-plus');
 var clone = require('clone');
 var common = require('./common');
@@ -20,8 +22,8 @@ var done = common.done;
 var ifErr = common.ifErr;
 var fmt = require('util').format;
 var mod_client = require('./client');
+var mod_jsprim = require('jsprim');
 var mod_log = require('./log');
-var mod_obj = require('../../lib/util/obj.js');
 var restify = require('restify');
 var vasync = require('vasync');
 var VError = require('verror').VError;
@@ -33,7 +35,7 @@ var VError = require('verror').VError;
 
 
 var ADMIN_IPS = {};
-var LOG = mod_log.child({ component: 'cn' });
+var LOG = mod_log.get().child({ component: 'cn' });
 var NOT_FOUND_ERR = {
     code: 'ResourceNotFound',
     message: 'rule not found'
@@ -67,36 +69,34 @@ function checkUrl(t, opts, callback) {
 
     getClient(t, opts.server_uuid, function (err, client) {
         if (err) {
-            return callback(err);
+            callback(err);
+            return;
         }
 
         var start = Date.now();
-        /*jsl:ignore*/
-        var timeout;
-        /*jsl:end*/
 
         function checkIt() {
             client.get(opts.url, function (err2, req, res, obj) {
                 var elapsed = Date.now() - start;
 
-                if (err2 && err2.body && err2.body.code == opts.errCode &&
+                if (err2 && err2.body && err2.body.code === opts.errCode &&
                     (elapsed < POLL_TIMEOUT)) {
 
                     // We haven't hit our timeout yet, so keep trying
                     LOG.trace({ start: start.toString(), elapsed: elapsed },
                         'timeout not hit: retrying' + opts.desc);
-                    timeout = setTimeout(checkIt, POLL_INTERVAL);
+                    setTimeout(checkIt, POLL_INTERVAL);
                     return;
                 }
 
                 LOG.debug({ start: start.toString(), elapsed: elapsed },
                     'poll timeout exceeded' + opts.desc);
 
-                return callback(err2, req, res, obj);
+                callback(err2, req, res, obj);
             });
         }
 
-        timeout = setTimeout(checkIt, POLL_INTERVAL);
+        setTimeout(checkIt, POLL_INTERVAL);
     });
 }
 
@@ -132,7 +132,7 @@ function createRemoteVM(vm) {
         });
     }
 
-    if (mod_obj.isEmpty(ips)) {
+    if (mod_jsprim.isEmpty(ips)) {
         err = new VError(
             'Remote VM "%s": missing IPs', uuid);
         err.details = vm;
@@ -141,7 +141,7 @@ function createRemoteVM(vm) {
 
     rvm.ips = Object.keys(ips).sort();
 
-    if (vm.hasOwnProperty('tags') && !mod_obj.isEmpty(vm.tags)) {
+    if (mod_jsprim.hasKey(vm, 'tags') && !mod_jsprim.isEmpty(vm.tags)) {
         rvm.tags = {};
         for (var t in vm.tags) {
             rvm.tags[t] = vm.tags[t];
@@ -162,7 +162,8 @@ function createRemoteVM(vm) {
  */
 function getAdminIP(t, uuid, callback) {
     if (ADMIN_IPS.hasOwnProperty(uuid)) {
-        return callback(null, ADMIN_IPS[uuid]);
+        callback(null, ADMIN_IPS[uuid]);
+        return;
     }
 
     var napi = mod_client.get('napi');
diff --git a/test/lib/common.js b/test/lib/common.js
index d58b2b6..35d74fd 100644
--- a/test/lib/common.js
+++ b/test/lib/common.js
@@ -13,6 +13,8 @@
  */
 
 
+'use strict';
+
 
 // --- Exports
 
diff --git a/test/lib/config.js b/test/lib/config.js
index c617dba..4b99e57 100644
--- a/test/lib/config.js
+++ b/test/lib/config.js
@@ -12,15 +12,30 @@
  * Test helpers for dealing with the NAPI client
  */
 
+'use strict';
 
 var fs = require('fs');
 var path = require('path');
 var VError = require('verror').VError;
 
 
+// --- Globals
 
-// --- Internal
 
+var CFG_ERR;
+var testFile = path.join(path.resolve(__dirname, '..'), 'config.json');
+var config = {};
+var HAVE_VARS;
+
+try {
+    config.test = JSON.parse(fs.readFileSync(testFile).toString());
+} catch (err) {
+    console.error('# Error loading test config %s: %s', testFile, err.message);
+    config.test = {};
+}
+
+
+// --- Internal
 
 
 function apiConfig(apiName) {
@@ -31,23 +46,9 @@ function apiConfig(apiName) {
 }
 
 
-
 // --- Exports
 
 
-
-var CFG_ERR;
-var testFile = path.join(path.resolve(__dirname, '..'), 'config.json');
-var config = {};
-var HAVE_VARS;
-
-try {
-    config.test = JSON.parse(fs.readFileSync(testFile).toString());
-} catch (err) {
-    console.error('# Error loading test config %s: %s', testFile, err.message);
-    config.test = {};
-}
-
 config.fwapi = apiConfig('fwapi');
 config.napi = apiConfig('napi');
 config.vmapi = apiConfig('vmapi');
diff --git a/test/lib/log.js b/test/lib/log.js
index 6436794..79c9672 100644
--- a/test/lib/log.js
+++ b/test/lib/log.js
@@ -12,19 +12,100 @@
  * bunyan logger for tests
  */
 
+'use strict';
+
 var bunyan = require('bunyan');
+var restify = require('restify');
+
+
+var LOG = process.env.LOG || false; // Set to log messages to stderr
+var LOGGER = null;
+
+
+function mkFileLogger() {
+    return bunyan.createLogger({
+        name: 'fwtest',
+        serializers: bunyan.stdSerializers,
+        streams: [
+            {
+                level: process.env.LOG_LEVEL || 'info',
+                stream: process.stderr
+            },
+            {
+                level: 'debug' || process.env.LOG_FILE_LEVEL,
+                path: '/var/log/fwtest.log'
+            }
+        ]
+    });
+}
+
+
+function mkMockLogger() {
+    var log = {
+        child: function () { return log; },
+        debug: function () { return false; },
+        error: function () { return false; },
+        info: function () { return false; },
+        level: function () { return (process.env.LOG_LEVEL || 'warn'); },
+        trace: function () { return false; },
+        warn: function () { return false; }
+    };
+
+    return log;
+}
+
+
+function mkStdoutLogger() {
+    return bunyan.createLogger({
+        level: (process.env.LOG_LEVEL || 'warn'),
+        name: process.argv[1],
+        stream: process.stderr,
+        serializers: restify.bunyan.serializers,
+        src: true
+    });
+}
+
+
+/**
+ * Select a logger suitable for use while running unit tests.
+ */
+function selectUnitLogger() {
+    if (LOG) {
+        return mkStdoutLogger();
+    } else {
+        return mkMockLogger();
+    }
+}
+
+
+/**
+ * Get a predetermined logger, or select a file-based one if nothing else has
+ * been selected.
+ */
+function get() {
+    if (LOGGER !== null) {
+        return LOGGER;
+    }
+
+    LOGGER = mkFileLogger();
+
+    return LOGGER;
+}
+
+
+/**
+ * Set a logger for tests to use.
+ */
+function set(logger) {
+    LOGGER = logger;
+}
+
 
-module.exports = bunyan.createLogger({
-    name: 'fwtest',
-    serializers: bunyan.stdSerializers,
-    streams: [
-        {
-            level: process.env.LOG_LEVEL || 'info',
-            stream: process.stderr
-        },
-        {
-            level: 'debug' || process.env.LOG_FILE_LEVEL,
-            path: '/var/log/fwtest.log'
-        }
-    ]
-});
+module.exports = {
+    mkFileLogger: mkFileLogger,
+    mkMockLogger: mkMockLogger,
+    mkStdoutLogger: mkStdoutLogger,
+    selectUnitLogger: selectUnitLogger,
+    get: get,
+    set: set
+};
diff --git a/test/lib/mock-moray.js b/test/lib/mock-moray.js
deleted file mode 100644
index c6156f6..0000000
--- a/test/lib/mock-moray.js
+++ /dev/null
@@ -1,431 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2016, Joyent, Inc.
- */
-
-/*
- * Mock moray object for unit tests
- */
-
-var assert = require('assert-plus');
-var clone = require('clone');
-var EventEmitter = require('events').EventEmitter;
-var ldapjs = require('ldapjs');
-var util = require('util');
-var verror = require('verror');
-
-
-
-// --- Globals
-
-
-var MORAY_VERSION = 2;
-
-var BUCKETS = {};
-var MORAY_ERRORS = {};
-
-
-
-// --- Internal
-
-
-
-/**
- * If there's an error in MORAY_ERRORS for the given operation, return it.
- */
-function getNextMorayError(op) {
-    if (!MORAY_ERRORS.hasOwnProperty(op) ||
-        typeof (MORAY_ERRORS[op]) !== 'object' ||
-        MORAY_ERRORS.length === 0) {
-        return;
-    }
-
-    return MORAY_ERRORS[op].shift();
-}
-
-
-/**
- * Returns a not found error for the bucket
- */
-function bucketNotFoundErr(bucket) {
-    var err = new verror.VError('bucket "%s" does not exist', bucket);
-    err.name = 'BucketNotFoundError';
-    return err;
-}
-
-
-/**
- * Returns an object not found error
- */
-function objectNotFoundErr(key) {
-    var err = new verror.VError('key "%s" does not exist', key);
-    err.name = 'ObjectNotFoundError';
-    return err;
-}
-
-
-
-// --- Fake moray object
-
-
-
-function FakeMoray(opts) {
-    assert.object(opts, 'opts');
-    assert.object(opts.log, 'opts.log');
-
-    this.log = opts.log;
-    BUCKETS = {
-        'ufds_o_smartdc': {}
-    };
-    EventEmitter.call(this);
-}
-
-util.inherits(FakeMoray, EventEmitter);
-
-
-FakeMoray.prototype._put = function _store(bucket, key, val) {
-    BUCKETS[bucket][key] = clone(val);
-};
-
-
-FakeMoray.prototype._del = function _del(bucket, key) {
-    var err = getNextMorayError('delObject');
-    if (err) {
-        throw err;
-    }
-
-    if (!BUCKETS.hasOwnProperty(bucket)) {
-        throw bucketNotFoundErr(bucket);
-    }
-
-    if (!BUCKETS[bucket].hasOwnProperty(key)) {
-        throw objectNotFoundErr(key);
-    }
-
-    delete BUCKETS[bucket][key];
-};
-
-
-FakeMoray.prototype.batch = function batch(data, callback) {
-    assert.arrayOfObject(data, 'data');
-
-    var err = getNextMorayError('batch');
-    if (err) {
-        return callback(err);
-    }
-
-    for (var b in data) {
-        var item = data[b];
-        assert.string(item.bucket, 'item.bucket');
-        assert.string(item.key, 'item.key');
-        assert.string(item.operation, 'item.operation');
-
-        if (item.operation === 'put') {
-            assert.object(item.value, 'item.value');
-            if (!BUCKETS.hasOwnProperty(item.bucket)) {
-                return callback(bucketNotFoundErr(item.bucket));
-            }
-
-            this._put(item.bucket, item.key, item.value);
-        }
-
-        if (item.operation === 'delete') {
-            try {
-                this._del(item.bucket, item.key);
-            } catch (err2) {
-                return callback(err2);
-            }
-        }
-    }
-
-    return callback();
-};
-
-
-FakeMoray.prototype.createBucket =
-    function createBucket(bucket, schema, callback) {
-
-    var err = getNextMorayError('createBucket');
-    if (err) {
-        return callback(err);
-    }
-
-    BUCKETS[bucket] = {};
-    return callback();
-};
-
-
-FakeMoray.prototype.delBucket = function delBucket(bucket, callback) {
-    var err = getNextMorayError('delBucket');
-    if (err) {
-        return callback(err);
-    }
-
-    if (!BUCKETS.hasOwnProperty(bucket)) {
-        return callback(bucketNotFoundErr(bucket));
-    }
-
-    delete BUCKETS[bucket];
-    return callback();
-};
-
-
-FakeMoray.prototype.delObject = function delObject(bucket, key, callback) {
-    try {
-        this._del(bucket, key);
-        return callback();
-    } catch (err) {
-        return callback(err);
-    }
-};
-
-
-FakeMoray.prototype.findObjects = function findObjects(bucket, filter, opts) {
-    var res = new EventEmitter;
-    var filterObj = ldapjs.parseFilter(filter);
-
-    process.nextTick(function () {
-        var err = getNextMorayError('findObjects');
-        if (err) {
-            res.emit('error', err);
-            return;
-        }
-
-        if (!BUCKETS.hasOwnProperty(bucket)) {
-            res.emit('error', bucketNotFoundErr(bucket));
-            return;
-        }
-
-        for (var r in BUCKETS[bucket]) {
-            // The LDAP matching function .matches() assumes that the
-            // values are strings, so stringify properties so that matches
-            // work correctly
-            var obj = {};
-            for (var k in BUCKETS[bucket][r]) {
-                obj[k] = BUCKETS[bucket][r][k].toString();
-            }
-
-            if (filterObj.matches(obj)) {
-                res.emit('record', {
-                    bucket: bucket,
-                    value: clone(BUCKETS[bucket][r])
-                });
-            }
-        }
-
-        res.emit('end');
-    });
-
-    return res;
-};
-
-
-FakeMoray.prototype.deleteMany =
-    function deleteMany(bucket, filter, opts, callback) {
-    var filterObj = ldapjs.parseFilter(filter);
-
-    if (callback === undefined) {
-        callback = opts;
-    }
-
-    var err = getNextMorayError('findObjects');
-    if (err) {
-        return callback(err);
-    }
-
-    if (!BUCKETS.hasOwnProperty(bucket)) {
-        return callback(bucketNotFoundErr(bucket));
-    }
-
-    for (var r in BUCKETS[bucket]) {
-        // The LDAP matching function .matches() assumes that the
-        // values are strings, so stringify properties so that matches
-        // work correctly
-        var obj = {};
-        for (var k in BUCKETS[bucket][r]) {
-            obj[k] = BUCKETS[bucket][r][k].toString();
-        }
-
-        if (filterObj.matches(obj)) {
-            delete BUCKETS[bucket][r];
-        }
-    }
-
-    return callback();
-};
-
-FakeMoray.prototype.getBucket = function getBucket(bucket, callback) {
-    var err = getNextMorayError('getBucket');
-    if (err) {
-        return callback(err);
-    }
-
-    if (!BUCKETS.hasOwnProperty(bucket)) {
-        return callback(bucketNotFoundErr(bucket));
-    }
-
-    // The real moray returns the bucket schema here, but NAPI only
-    // uses this for an existence check, so this suffices
-    return callback(null, BUCKETS[bucket]);
-};
-
-
-FakeMoray.prototype.getObject = function getObject(bucket, key, callback) {
-    var err = getNextMorayError('getObject');
-    if (err) {
-        return callback(err);
-    }
-
-    if (!BUCKETS.hasOwnProperty(bucket)) {
-        return callback(bucketNotFoundErr(bucket));
-    }
-
-    if (!BUCKETS[bucket].hasOwnProperty(key)) {
-        return callback(objectNotFoundErr(key));
-    }
-
-    return callback(null, {
-        bucket: bucket,
-        value: clone(BUCKETS[bucket][key])
-    });
-};
-
-
-FakeMoray.prototype.putObject =
-    function putObject(bucket, key, value, opts, callback) {
-    if (typeof (opts) === 'function') {
-        callback = opts;
-        opts = {};
-    }
-
-    var err = getNextMorayError('putObject');
-    if (err) {
-        return callback(err);
-    }
-
-    if (!BUCKETS.hasOwnProperty(bucket)) {
-        return callback(bucketNotFoundErr(bucket));
-    }
-
-    this._put(bucket, key, value);
-    return callback();
-};
-
-
-FakeMoray.prototype.sql = function sql(str) {
-    // Mock out PG's gap detection
-
-    /* JSSTYLED */
-    var bucket = str.match(/from ([a-z0-9_]+)/)[1];
-    /* JSSTYLED */
-    var gt = Number(str.match(/>= (\d+)/)[1]);
-    /* JSSTYLED */
-    var lt = Number(str.match(/<= (\d+)/)[1]);
-    var res = new EventEmitter;
-
-    assert.string(bucket, 'bucket');
-    assert.number(gt, 'gt');
-    assert.number(lt, 'lt');
-
-    process.nextTick(function () {
-        var err = getNextMorayError('sql');
-        if (err) {
-            res.emit('error', err);
-            return;
-        }
-
-        if (!BUCKETS.hasOwnProperty(bucket)) {
-            res.emit('error', bucketNotFoundErr(bucket));
-            return;
-        }
-
-        var bucketKeys = Object.keys(BUCKETS[bucket]).map(function (k) {
-            return Number(k); }).sort();
-        var last = bucketKeys[0];
-
-        for (var i in bucketKeys) {
-            var ip = bucketKeys[i];
-            if ((ip - last) > 1 && (last + 1) <= lt && (last + 1) >= gt) {
-                res.emit('record', { gap_start: last + 1 });
-                break;
-            }
-            last = ip;
-        }
-
-        res.emit('end');
-    });
-
-    return res;
-};
-
-
-FakeMoray.prototype.updateBucket =
-    function updateBucket(bucket, schema, callback) {
-
-    return callback(new Error('FakeMoray: not implemented'));
-};
-
-
-FakeMoray.prototype.putBucket = function putBucket(b, schema, callback) {
-    var self = this;
-    var err = getNextMorayError('putBucket');
-    if (err) {
-        return callback(err);
-    }
-
-    self.getBucket(b, function (err2, bucket) {
-        if (err2) {
-            if (err2.name === 'BucketNotFoundError') {
-                return self.createBucket(b, schema, callback);
-            } else {
-                return callback(err2);
-            }
-        }
-
-        var v = bucket.options.version;
-        var v2 = (schema.options || {}).version || 0;
-        if (v !== 0 && v === v2) {
-            return callback();
-        } else {
-            return self.updateBucket(b, schema, callback);
-        }
-    });
-};
-
-
-FakeMoray.prototype.version = function morayVersion(bucket, callback) {
-    return callback(MORAY_VERSION);
-};
-
-
-
-// --- Exports
-
-
-
-function createClient(opts) {
-    var client = new FakeMoray(opts);
-    process.nextTick(function () {
-        client.emit('connect');
-    });
-
-    return client;
-}
-
-
-
-module.exports = {
-    get _buckets() {
-        return BUCKETS;
-    },
-    set _errors(obj) {
-        MORAY_ERRORS = obj;
-    },
-    FakeMoray: FakeMoray,
-    createClient: createClient
-};
diff --git a/test/lib/rule.js b/test/lib/rule.js
index 90803ee..9036cc1 100644
--- a/test/lib/rule.js
+++ b/test/lib/rule.js
@@ -12,6 +12,8 @@
  * Helpers for manipulating FWAPI rules
  */
 
+'use strict';
+
 var assert = require('assert-plus');
 var async = require('async');
 var clone = require('clone');
@@ -20,6 +22,8 @@ var done = common.done;
 var fmt = require('util').format;
 var ifErr = common.ifErr;
 var mod_client = require('./client');
+var mod_err = require('../../lib/errors');
+var mod_trunc = require('./trunc');
 var mod_uuid = require('node-uuid');
 var mod_log = require('./log');
 var mod_vasync = require('vasync');
@@ -30,11 +34,15 @@ var mod_vasync = require('vasync');
 
 
 
-var GLOBAL_RULES = [];
-var GLOBAL_RULES_RETRIEVED = false;
-var LOG = mod_log.child({ component: 'rule' });
+var COLUMNS = mod_trunc.COLUMNS;
+var LOG = mod_log.get().child({ component: 'rule' });
 var RULES = {};
 
+var ALREADY_EXISTS_ERR = {
+    code: 'RuleExistsError',
+    message: 'rule already exists',
+    errors: [ mod_err.duplicateParam('uuid') ]
+};
 
 
 // --- Internal
@@ -42,16 +50,11 @@ var RULES = {};
 
 
 function getGlobalRules(t, client, callback) {
-    if (GLOBAL_RULES_RETRIEVED) {
-        return callback(null, clone(GLOBAL_RULES));
-    }
-
     client.listRules({ global: true }, function (err, rules) {
         if (ifErr(t, err, 'listing global rules')) {
             return callback(err);
         }
 
-        GLOBAL_RULES = clone(rules);
         return callback(null, rules);
     });
 }
@@ -76,7 +79,12 @@ function create(t, opts, callback) {
     assert.optionalObject(opts.partialExp, 'opts.partialExp');
 
     var client = opts.client || mod_client.get('fwapi');
-    var desc = fmt(' (creating rule=%s)', opts.rule.rule);
+
+    var descFmt = ' (creating rule=%s)';
+    var descLen = descFmt.length - 2;
+    var desc = (opts.rule.rule.length + descLen > COLUMNS) ?
+        fmt(descFmt, opts.rule.rule.slice(0, COLUMNS - descLen - 3) + '...') :
+        fmt(descFmt, opts.rule.rule);
 
     LOG.debug({ rule: opts.rule }, 'creating rule');
     client.createRule(opts.rule, function (err, obj, req, res) {
@@ -210,7 +218,7 @@ function del(t, opts, callback) {
         t.ok(updateID, 'x-update-id: ' + updateID + desc);
 
         t.equal(res.statusCode, 204, 'status code' + desc);
-        delete RULES[obj.uuid];
+        delete RULES[opts.uuid];
 
         return done(null, obj, t, callback);
     });
@@ -223,7 +231,8 @@ function del(t, opts, callback) {
 function delAllCreated(t, callback) {
     var toDel = Object.keys(RULES);
     if (toDel.length === 0) {
-        return done(null, toDel, t, callback);
+        done(null, toDel, t, callback);
+        return;
     }
 
     LOG.debug({ toDel: toDel }, 'deleting all created rules');
@@ -246,13 +255,18 @@ function delAllCreated(t, callback) {
  */
 function delAndGet(t, opts, callback) {
     del(t, opts, function (err, res) {
+        if (ifErr(t, err, 'Failed to delete rule')) {
+            callback(err);
+            return;
+        }
+
         opts.expErr = {
             code: 'ResourceNotFound',
             message: 'Rule not found'
         };
         opts.expCode = 404;
 
-        return get(t, opts, callback);
+        get(t, opts, callback);
     });
 }
 
@@ -349,7 +363,9 @@ function listRules(t, opts, callback) {
 
     var client = opts.client || mod_client.get('fwapi');
     var params = opts.params || {};
-    var desc = fmt(' (params=%s)', JSON.stringify(params));
+    var descFmt = ' (params=%s)';
+    var descLen = descFmt.length - 2;
+    var desc = fmt(descFmt, mod_trunc.obj(params, COLUMNS - descLen));
 
     client.listRules(params, function (err, obj, req, res) {
         if (opts.expErr) {
@@ -391,12 +407,15 @@ function resolve(t, opts, callback) {
     assert.optionalObject(opts.expErr, 'opts.expErr');
 
     var client = opts.client || mod_client.get('fwapi');
+    var descFmt = ' (resolve: params=%s)';
+    var descLen = descFmt.length - 2;
     var desc = opts.desc ||
-        fmt(' (resolve: params=%s)', JSON.stringify(opts.params));
+        fmt(descFmt, mod_trunc.obj(opts.params, COLUMNS - descLen));
 
     getGlobalRules(t, client, function (gErr, globalRules) {
         if (gErr) {
-            return done(gErr, null, t, callback);
+            done(gErr, null, t, callback);
+            return;
         }
 
         var postParams = {
@@ -450,15 +469,25 @@ function update(t, opts, callback) {
     assert.optionalFunc(callback, 'callback');
 
     assert.object(opts.params, 'opts.params');
-    assert.string(opts.uuid, 'opts.uuid');
+    assert.uuid(opts.uuid, 'opts.uuid');
     assert.optionalObject(opts.exp, 'opts.exp');
     assert.optionalObject(opts.expErr, 'opts.expErr');
     assert.optionalObject(opts.partialExp, 'opts.partialExp');
     assert.optionalObject(opts.rule, 'opts.rule');
 
     var client = opts.client || mod_client.get('fwapi');
-    var desc = fmt(' (params=%s, uuid=%s)', JSON.stringify(opts.params),
-        opts.uuid);
+
+    var descFmt = ' (params=%s, uuid=%s)';
+    var descLen = descFmt.length - 4;
+    var tparams = JSON.stringify(opts.params);
+    var tuuid = opts.uuid;
+
+    if (tparams.length + tuuid.length + descLen > COLUMNS) {
+        tuuid = mod_trunc.uuid(tuuid);
+        tparams = mod_trunc.obj(opts.params, COLUMNS - descLen - tuuid.length);
+    }
+
+    var desc = fmt(descFmt, tparams, tuuid);
 
     t.ok(opts.uuid, 'update' + desc);
     LOG.debug({ opts: opts }, 'updating rule');
@@ -551,7 +580,8 @@ function vmRules(t, opts, callback) {
 
     getGlobalRules(t, client, function (gErr, globalRules) {
         if (gErr) {
-            return done(gErr, null, t, callback);
+            done(gErr, null, t, callback);
+            return;
         }
 
         client.getVMrules(opts.uuid, {}, function (err, obj, req, res) {
@@ -586,6 +616,9 @@ function vmRules(t, opts, callback) {
 
 
 module.exports = {
+    get alreadyExistsErr() {
+        return clone(ALREADY_EXISTS_ERR);
+    },
     get _rules() {
         return RULES;
     },
diff --git a/test/lib/trunc.js b/test/lib/trunc.js
new file mode 100644
index 0000000..b00aa38
--- /dev/null
+++ b/test/lib/trunc.js
@@ -0,0 +1,137 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016, Joyent, Inc.
+ */
+
+/*
+ * Helpers for truncating test description output
+ */
+
+'use strict';
+
+var clone = require('clone');
+
+
+// --- Exports
+
+/**
+ * When adding potentially long text to a description, we truncate it so that
+ * it can fit into the width of the screen without wrapping, which breaks up
+ * the faucet output. Things usually fit, but rules containing VM UUIDs end
+ * up being particularly long. We subtract 65 characters to allow for prefixes
+ * to the generated description text, and the test number that faucet prints.
+ *
+ * If it doesn't look like we're using faucet (i.e., a test is being run
+ * directly, or we're running integration tests), then we print everything.
+ */
+var USING_FAUCET = (!process.stdout.isTTY && process.stderr.isTTY);
+var COLUMNS = USING_FAUCET ?
+    (process.stderr.columns || 80) - 65 : Infinity;
+
+
+/**
+ * Sort the text 'rule' last, since it usually has the most useful
+ * information in a description of parameters. UUIDs are randomly
+ * generated, so the full string is usually not particularly useful
+ * in test description messages, so we sort them to the beginning.
+ */
+function sortRuleLast(a, b) {
+    if (a === 'rule') {
+        return 1;
+    }
+
+    if (b === 'rule') {
+        return -1;
+    }
+
+    var aIsUUID = (a.indexOf('uuid') !== -1);
+    var bIsUUID = (b.indexOf('uuid') !== -1);
+
+    if (aIsUUID && !bIsUUID) {
+        return -1;
+    }
+
+    if (!aIsUUID && bIsUUID) {
+        return 1;
+    }
+
+    return (a < b) ? -1 : 1;
+}
+
+
+/**
+ * If needed, truncate the string fields of an object to fit within width,
+ * and return a string representation of the object with the truncated
+ * fields.
+ *
+ * This function isn't perfect: it's just an attempt to help produce
+ * more reasonable descriptions in test output, and not break faucet.
+ */
+function truncateObject(orig, width) {
+    var key, str;
+    var obj = clone(orig);
+
+    var keys = Object.keys(obj).sort(sortRuleLast);
+
+    // width - curlies - commas
+    var fitWithin = width - 2 - (keys.length - 1);
+
+    // 4 quotes + colon
+    var overhead = 5;
+
+    // average length given to each key
+    var avgLen = Math.floor(fitWithin / keys.length);
+
+    function next() {
+        str = JSON.stringify(obj);
+        key = keys.shift();
+        return key !== undefined;
+    }
+
+    while (next()) {
+        if (str.length <= width) {
+            return str;
+        }
+
+        if (typeof (obj[key]) !== 'string') {
+            continue;
+        }
+
+        var escStrLen = JSON.stringify(obj[key]).length - 2;
+        var okStrLen = avgLen - key.length - overhead;
+
+        if (okStrLen <= 3) {
+            obj[key] = '...';
+            continue;
+        } else if (escStrLen <= okStrLen) {
+            continue;
+        }
+
+        var lopOff = escStrLen - okStrLen;
+
+        obj[key] = obj[key].slice(0, obj[key].length - lopOff - 3) + '...';
+    }
+
+    return str;
+}
+
+
+/**
+ * Truncate enough of a UUID to make it significantly shorter, but leave
+ * enough so that it should still be distinguishable.
+ */
+function truncateUUID(uuid) {
+    return uuid.slice(0, 15) + '...';
+}
+
+
+module.exports = {
+    COLUMNS: COLUMNS,
+    obj: truncateObject,
+    uuid: truncateUUID
+};
diff --git a/test/lib/vm.js b/test/lib/vm.js
index 0fa6685..0554ac8 100644
--- a/test/lib/vm.js
+++ b/test/lib/vm.js
@@ -12,6 +12,8 @@
  * Helpers for manipulating VMs
  */
 
+'use strict';
+
 var assert = require('assert-plus');
 var async = require('async');
 var clone = require('clone');
@@ -38,7 +40,7 @@ var VM_PARAMS = {
     billing_id: config.test.billing_id
 };
 var VM_NUM = 0;
-var LOG = mod_log.child({ component: 'vm' });
+var LOG = mod_log.get().child({ component: 'vm' });
 var POLL_INTERVAL = config.test.api_poll_interval;
 var PROV_TIMEOUT = config.test.provision_timeout;
 var VMS = {};
@@ -73,7 +75,8 @@ function provisionOne(t, opts, callback) {
         if (ifErr(t, err, 'provision VM' + desc)) {
             t.deepEqual(vmParams, {}, 'VM params');
             LOG.error({ params: vmParams }, 'failed to create VM');
-            return callback(err);
+            callback(err);
+            return;
         }
 
         LOG.info({ vm: opts.vm, vm_uuid: job.vm_uuid, job_uuid: job.job_uuid },
@@ -83,14 +86,16 @@ function provisionOne(t, opts, callback) {
         function checkState() {
             client.getVm({ uuid: job.vm_uuid }, function (err2, res) {
                 if (err2) {
-                    return callback(err2);
+                    callback(err2);
+                    return;
                 }
 
                 if (res.state === 'running') {
                     VMS[res.uuid] = clone(res);
                     LOG.debug({ vm_uuid: job.vm_uuid, vm: res },
                         'successfully provisioned VM');
-                    return callback(null, res);
+                    callback(null, res);
+                    return;
                 }
 
                 if (res.state === 'failed') {
@@ -100,9 +105,10 @@ function provisionOne(t, opts, callback) {
                         vm_uuid: job.vm_uuid
                     }, 'failed to provision VM');
 
-                    return callback(new VError(
+                    callback(new VError(
                         'failed to provision VM %s (job %s)',
                         job.vm_uuid, job.job_uuid));
+                    return;
                 }
 
                 if (Date.now() - startTime > PROV_TIMEOUT) {
@@ -112,9 +118,10 @@ function provisionOne(t, opts, callback) {
                         vm_uuid: job.vm_uuid
                     }, 'timeout provisioning VM');
 
-                    return callback(new VError(
+                    callback(new VError(
                         'provision of VM %s (job %s) timed out',
                         job.vm_uuid, job.job_uuid));
+                    return;
                 }
 
                 setTimeout(checkState, POLL_INTERVAL);
diff --git a/test/unit/data/migration.js b/test/unit/data/migration.js
new file mode 100644
index 0000000..a3b6a68
--- /dev/null
+++ b/test/unit/data/migration.js
@@ -0,0 +1,781 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016, Joyent, Inc.
+ */
+
+/*
+ * Data for testing migrating rules
+ */
+
+'use strict';
+
+var assert = require('assert-plus');
+var fwrule = require('fwrule');
+var mod_uuid = require('node-uuid');
+
+var fmt = require('util').format;
+
+
+// --- Globals
+
+var UFDS_FWRULE_PARENT = [ 'ou=fwrules, o=smartdc' ];
+var UFDS_FWRULE_CLASS = [ 'fwrule' ];
+
+var GENERIC_COUNT = 10000;
+var GENERIC_DESC = 'Allow VM %s to access ports %d to %d on "foo" VMs.';
+var GENERIC_RULE = 'FROM vm %s TO tag "role" = "foo" ALLOW tcp PORTS %d - %d';
+
+var UPDATE_HOST = require('os').hostname();
+var UPDATE_VM = mod_uuid.v4();
+var UPDATE_CN = mod_uuid.v4();
+
+
+// --- Internals
+
+function getRandomInt(min, max) {
+    return Math.floor(Math.random() * (max - min)) + min;
+}
+
+
+// --- Rule-related Exports
+
+
+var RULES_SCHEMA_V1 = {
+    options: {
+        'version': 1
+    },
+    index: {
+        'uuid': {
+            'type': 'string',
+            'unique': true
+        },
+        '_v': { 'type': 'number' },
+        'version': { 'type': 'string' },
+        'owner': { 'type': 'string' },
+        'action': { 'type': 'string' },
+        'protocol': { 'type': 'string' },
+        'enabled': { 'type': 'boolean' },
+        'fromwildcards': {
+            'type': '[string]'
+        },
+        'towildcards': {
+            'type': '[string]'
+        },
+        'fromips': {
+            'type': '[ip]'
+        },
+        'toips': {
+            'type': '[ip]'
+        },
+        'fromsubnets': {
+            'type': '[subnet]'
+        },
+        'tosubnets': {
+            'type': '[subnet]'
+        },
+        'fromtagkeys': {
+            'type': '[string]'
+        },
+        'totagkeys': {
+            'type': '[string]'
+        },
+        'fromtags': {
+            'type': '[string]'
+        },
+        'totags': {
+            'type': '[string]'
+        },
+        'fromvms': {
+            'type': '[string]'
+        },
+        'tovms': {
+            'type': '[string]'
+        }
+    }
+};
+
+
+
+var OWNER_1 = mod_uuid.v4();
+var OWNER_2 = mod_uuid.v4();
+var OWNER_3 = mod_uuid.v4();
+var OWNER_4 = mod_uuid.v4();
+
+var RULE_1_UUID = mod_uuid.v4();
+var RULE_2_UUID = mod_uuid.v4();
+var RULE_3_UUID = mod_uuid.v4();
+var RULE_4_UUID = mod_uuid.v4();
+var RULE_5_UUID = mod_uuid.v4();
+var RULE_6_UUID = mod_uuid.v4();
+var RULE_7_UUID = mod_uuid.v4();
+var RULE_8_UUID = mod_uuid.v4();
+var RULE_9_UUID = mod_uuid.v4();
+var RULE_10_UUID = mod_uuid.v4();
+var RULE_11_UUID = mod_uuid.v4();
+var RULE_12_UUID = mod_uuid.v4();
+
+var RULE_1_VERSION = fwrule.generateVersion();
+var RULE_2_VERSION = fwrule.generateVersion();
+var RULE_3_VERSION = fwrule.generateVersion();
+var RULE_4_VERSION = fwrule.generateVersion();
+var RULE_5_VERSION = fwrule.generateVersion();
+var RULE_6_VERSION = fwrule.generateVersion();
+var RULE_7_VERSION = fwrule.generateVersion();
+var RULE_8_VERSION = fwrule.generateVersion();
+var RULE_9_VERSION = fwrule.generateVersion();
+var RULE_10_VERSION = fwrule.generateVersion();
+var RULE_11_VERSION = fwrule.generateVersion();
+var RULE_12_VERSION = fwrule.generateVersion();
+
+var rules = {};
+
+// A blocking rule
+rules[RULE_1_UUID] = {
+    'ufds': {
+        'action': [ 'block' ],
+        'enabled': [ 'true' ],
+        'fromwildcard': [ 'vmall' ],
+        'objectclass': UFDS_FWRULE_CLASS,
+        'owner': [ OWNER_1 ],
+        'ports': [ '22' ],
+        'protocol': [ 'tcp' ],
+        'towildcard': [ 'any' ],
+        'uuid': [ RULE_1_UUID ],
+        'version': [ RULE_1_VERSION ],
+        '_parent': UFDS_FWRULE_PARENT
+    },
+    'v1': {
+        '_v': 1,
+        'action': 'block',
+        'enabled': true,
+        'fromwildcards': [ 'vmall' ],
+        'owner': OWNER_1,
+        'ports': [ '[22,22]' ],
+        'protocol': 'tcp',
+        'towildcards': [ 'any' ],
+        'uuid': RULE_1_UUID,
+        'version': RULE_1_VERSION
+    },
+    'fwapi': {
+        'rule': 'FROM all vms TO any BLOCK tcp PORT 22',
+        'uuid': RULE_1_UUID,
+        'version': RULE_1_VERSION,
+        'owner_uuid': OWNER_1,
+        'enabled': true
+    }
+};
+
+
+// Rule with a bad subnet in UFDS that needs to be fixed up
+rules[RULE_2_UUID] = {
+    'ufds': {
+        'action': [ 'allow' ],
+        'enabled': [ 'true' ],
+        'fromsubnet': [
+          '167804930/21',
+          '168427523/18'
+        ],
+        'objectclass': UFDS_FWRULE_CLASS,
+        'owner': [ OWNER_1 ],
+        'ports': [ 'all' ],
+        'protocol': [ 'udp' ],
+        'totag': [ 'manta_role=loadbalancer=10' ],
+        'uuid': [ RULE_2_UUID ],
+        'version': [ RULE_2_VERSION ],
+        '_parent': UFDS_FWRULE_PARENT
+    },
+    'v1': {
+        '_v': 1,
+        'action': 'allow',
+        'enabled': true,
+        'fromsubnets': [ '10.0.128.0/21', '10.10.0.0/18' ],
+        'owner': OWNER_1,
+        'ports': [ '[1,65535]' ],
+        'protocol': 'udp',
+        'totags': [ 'manta_role=loadbalancer=10' ],
+        'totagkeys': [ 'manta_role' ],
+        'uuid': RULE_2_UUID,
+        'version': RULE_2_VERSION
+    },
+    'fwapi': {
+        'rule': 'FROM (subnet 10.0.128.0/21 OR subnet 10.10.0.0/18) TO '
+            + 'tag "manta_role" = "loadbalancer" ALLOW udp PORT all',
+        'uuid': RULE_2_UUID,
+        'version': RULE_2_VERSION,
+        'owner_uuid': OWNER_1,
+        'enabled': true
+    }
+};
+
+
+// Rule with a port range
+rules[RULE_3_UUID] = {
+    'ufds': {
+        'action': [ 'allow' ],
+        'description': [ 'this is a rule with port ranges' ],
+        'enabled': [ 'false' ],
+        'fromsubnet': [ '167772160/24' ],
+        'objectclass': UFDS_FWRULE_CLASS,
+        'owner': [ OWNER_2 ],
+        'ports': [ '53', '8300-8302', '8400', '8500', '8600' ],
+        'protocol': [ 'tcp' ],
+        'totag': [ 'role=etcd=4' ],
+        'uuid': [ RULE_3_UUID ],
+        'version': [ RULE_3_VERSION ],
+        '_parent': UFDS_FWRULE_PARENT
+    },
+    'v1': {
+        '_v': 1,
+        'action': 'allow',
+        'description': 'this is a rule with port ranges',
+        'enabled': false,
+        'fromsubnets': [ '10.0.0.0/24' ],
+        'owner': OWNER_2,
+        'ports': [
+            '[53,53]', '[8300,8302]', '[8400,8400]',
+            '[8500,8500]', '[8600,8600]'
+        ],
+        'protocol': 'tcp',
+        'totags': [ 'role=etcd=4' ],
+        'totagkeys': [ 'role' ],
+        'uuid': RULE_3_UUID,
+        'version': RULE_3_VERSION
+    },
+    'fwapi': {
+        'rule': 'FROM subnet 10.0.0.0/24 TO tag "role" = "etcd" ALLOW '
+            + 'tcp PORTS 53, 8300 - 8302, 8400, 8500, 8600',
+        'description': 'this is a rule with port ranges',
+        'uuid': RULE_3_UUID,
+        'version': RULE_3_VERSION,
+        'owner_uuid': OWNER_2,
+        'enabled': false
+    }
+};
+
+
+// Rule with multiple tags
+rules[RULE_4_UUID] = {
+    'ufds': {
+        'action': [ 'allow' ],
+        'enabled': [ 'false' ],
+        'fromsubnet': [ '167772160/24' ],
+        'objectclass': UFDS_FWRULE_CLASS,
+        'owner': [ OWNER_2 ],
+        'ports': [ '80', '443' ],
+        'protocol': [ 'tcp' ],
+        'totag': [ 'web==3', 'role=http=4' ],
+        'uuid': [ RULE_4_UUID ],
+        'version': [ RULE_4_VERSION ],
+        '_parent': UFDS_FWRULE_PARENT
+    },
+    'v1': {
+        '_v': 1,
+        'action': 'allow',
+        'enabled': false,
+        'fromsubnets': [ '10.0.0.0/24' ],
+        'owner': OWNER_2,
+        'ports': [ '[80,80]', '[443,443]' ],
+        'protocol': 'tcp',
+        'totags': [ 'role=http=4', 'web==3' ],
+        'totagkeys': [ 'role', 'web' ],
+        'uuid': RULE_4_UUID,
+        'version': RULE_4_VERSION
+    },
+    'fwapi': {
+        'rule': 'FROM subnet 10.0.0.0/24 TO '
+            + '(tag "role" = "http" OR tag "web") ALLOW '
+            + 'tcp (PORT 80 AND PORT 443)',
+        'uuid': RULE_4_UUID,
+        'version': RULE_4_VERSION,
+        'owner_uuid': OWNER_2,
+        'enabled': false
+    }
+};
+
+
+// A global rule
+rules[RULE_5_UUID] = {
+    'ufds': {
+        'action': [ 'allow' ],
+        'description': [ 'allow pings to all VMs' ],
+        'enabled': [ 'true' ],
+        'fromwildcard': [ 'any' ],
+        'objectclass': UFDS_FWRULE_CLASS,
+        'protocol': [ 'icmp' ],
+        'towildcard': [ 'vmall' ],
+        'types': [ '8:0' ],
+        'uuid': [ RULE_5_UUID ],
+        'version': [ RULE_5_VERSION ],
+        '_parent': UFDS_FWRULE_PARENT
+    },
+    'v1': {
+        '_v': 1,
+        'action': 'allow',
+        'description': 'allow pings to all VMs',
+        'enabled': true,
+        'fromwildcards': [ 'any' ],
+        'protocol': 'icmp',
+        'towildcards': [ 'vmall' ],
+        'types': [ '8:0' ],
+        'uuid': RULE_5_UUID,
+        'version': RULE_5_VERSION
+    },
+    'fwapi': {
+        'rule': 'FROM any TO all vms ALLOW icmp TYPE 8 CODE 0',
+        'description': 'allow pings to all VMs',
+        'uuid': RULE_5_UUID,
+        'version': RULE_5_VERSION,
+        'enabled': true,
+        'global': true
+    }
+};
+
+
+// A rule with escaped characters
+rules[RULE_6_UUID] = {
+    'ufds': {
+        'action': [ 'allow' ],
+        'description': [ 'this rule has escaped characters in tags' ],
+        'enabled': [ 'true' ],
+        'fromtag': [ '\\u2603=\\u0631\\u062c\\u0644 '
+            + '\\u0627\\u0644\\u062b\\u0644\\u062c=6' ],
+        'objectclass': UFDS_FWRULE_CLASS,
+        'owner': [ OWNER_3 ],
+        'protocol': [ 'tcp' ],
+        'totag': [  '\\u26C4==6' ],
+        'ports': [ '22' ],
+        'uuid': [ RULE_6_UUID ],
+        'version': [ RULE_6_VERSION ],
+        '_parent': UFDS_FWRULE_PARENT
+    },
+    'v1': {
+        '_v': 1,
+        'action': 'allow',
+        'description': 'this rule has escaped characters in tags',
+        'enabled': true,
+        'fromtagkeys': [ '\\u2603' ],
+        'fromtags': [ '\\u2603=\\u0631\\u062c\\u0644 '
+            + '\\u0627\\u0644\\u062b\\u0644\\u062c=6' ],
+        'owner': OWNER_3,
+        'protocol': 'tcp',
+        'totagkeys': [  '\\u26C4' ],
+        'totags': [  '\\u26C4==6' ],
+        'ports': [ '[22,22]' ],
+        'uuid': RULE_6_UUID,
+        'version': RULE_6_VERSION
+    },
+    'fwapi': {
+        'rule': 'FROM tag "" = " " TO tag "" ALLOW tcp PORT 22',
+        'description': 'this rule has escaped characters in tags',
+        'uuid': RULE_6_UUID,
+        'version': RULE_6_VERSION,
+        'owner_uuid': OWNER_3,
+        'enabled': true
+    }
+};
+
+
+// TCP rule created for accounts that use sdc-docker
+rules[RULE_7_UUID] = {
+    'ufds': {
+        'action': [ 'allow' ],
+        'enabled': [ 'true' ],
+        'fromtag': [ 'sdc_docker==10' ],
+        'objectclass': UFDS_FWRULE_CLASS,
+        'owner': [ OWNER_4 ],
+        'ports': [ 'all' ],
+        'protocol': [ 'tcp' ],
+        'totag': [ 'sdc_docker==10' ],
+        'uuid': [ RULE_7_UUID ],
+        'version': [ RULE_7_VERSION ],
+        '_parent': UFDS_FWRULE_PARENT
+    },
+    'v1': {
+        '_v': 1,
+        'action': 'allow',
+        'enabled': true,
+        'fromtagkeys': [ 'sdc_docker' ],
+        'fromtags': [ 'sdc_docker==10' ],
+        'owner': OWNER_4,
+        'protocol': 'tcp',
+        'totagkeys': [  'sdc_docker' ],
+        'totags': [  'sdc_docker==10' ],
+        'ports': [ '[1,65535]' ],
+        'uuid': RULE_7_UUID,
+        'version': RULE_7_VERSION
+    },
+    'fwapi': {
+        'rule': 'FROM tag "sdc_docker" TO tag "sdc_docker" ALLOW tcp PORT all',
+        'uuid': RULE_7_UUID,
+        'version': RULE_7_VERSION,
+        'owner_uuid': OWNER_4,
+        'enabled': true
+    }
+};
+
+
+// UDP rule created for accounts that use sdc-docker
+rules[RULE_8_UUID] = {
+    'ufds': {
+        'action': [ 'allow' ],
+        'enabled': [ 'true' ],
+        'fromtag': [ 'sdc_docker==10' ],
+        'objectclass': UFDS_FWRULE_CLASS,
+        'owner': [ OWNER_4 ],
+        'ports': [ 'all' ],
+        'protocol': [ 'udp' ],
+        'totag': [ 'sdc_docker==10' ],
+        'uuid': [ RULE_8_UUID ],
+        'version': [ RULE_8_VERSION ],
+        '_parent': UFDS_FWRULE_PARENT
+    },
+    'v1': {
+        '_v': 1,
+        'action': 'allow',
+        'enabled': true,
+        'fromtagkeys': [ 'sdc_docker' ],
+        'fromtags': [ 'sdc_docker==10' ],
+        'owner': OWNER_4,
+        'protocol': 'udp',
+        'totagkeys': [  'sdc_docker' ],
+        'totags': [  'sdc_docker==10' ],
+        'ports': [ '[1,65535]' ],
+        'uuid': RULE_8_UUID,
+        'version': RULE_8_VERSION
+    },
+    'fwapi': {
+        'rule': 'FROM tag "sdc_docker" TO tag "sdc_docker" ALLOW udp PORT all',
+        'uuid': RULE_8_UUID,
+        'version': RULE_8_VERSION,
+        'owner_uuid': OWNER_4,
+        'enabled': true
+    }
+};
+
+
+// TCP exposed port rule created for a Docker container
+rules[RULE_9_UUID] = {
+    'ufds': {
+        'action': [ 'allow' ],
+        'enabled': [ 'true' ],
+        'fromwildcard': [ 'any' ],
+        'objectclass': UFDS_FWRULE_CLASS,
+        'owner': [ OWNER_4 ],
+        'ports': [ '80' ],
+        'protocol': [ 'tcp' ],
+        'tovm': [ 'ba62757f-fa18-4993-9f9d-0700391d660a' ],
+        'uuid': [ RULE_9_UUID ],
+        'version': [ RULE_9_VERSION ],
+        '_parent': UFDS_FWRULE_PARENT
+    },
+    'v1': {
+        '_v': 1,
+        'action': 'allow',
+        'enabled': true,
+        'fromwildcards': [ 'any' ],
+        'owner': OWNER_4,
+        'ports': [ '[80,80]' ],
+        'protocol': 'tcp',
+        'tovms': [ 'ba62757f-fa18-4993-9f9d-0700391d660a' ],
+        'uuid': RULE_9_UUID,
+        'version': RULE_9_VERSION
+    },
+    'fwapi': {
+        'rule': 'FROM any TO vm ba62757f-fa18-4993-9f9d-0700391d660a ALLOW '
+            + 'tcp PORT 80',
+        'uuid': RULE_9_UUID,
+        'version': RULE_9_VERSION,
+        'owner_uuid': OWNER_4,
+        'enabled': true
+    }
+};
+
+
+// ICMPv6 rule
+rules[RULE_10_UUID] = {
+    'v1': {
+        '_v': 1,
+        'action': 'allow',
+        'description': 'allow all ICMPv6 types',
+        'enabled': true,
+        'fromwildcards': [ 'any' ],
+        'protocol': 'icmp6',
+        'towildcards': [ 'vmall' ],
+        'types': [ 'all' ],
+        'uuid': RULE_10_UUID,
+        'version': RULE_10_VERSION
+    },
+    'fwapi': {
+        'rule': 'FROM any TO all vms ALLOW icmp6 TYPE all',
+        'description': 'allow all ICMPv6 types',
+        'uuid': RULE_10_UUID,
+        'version': RULE_10_VERSION,
+        'enabled': true,
+        'global': true
+    }
+};
+
+
+// IPv6 address rule
+rules[RULE_11_UUID] = {
+    'v1': {
+        '_v': 1,
+        'action': 'allow',
+        'enabled': true,
+        'fromips': [ 'fd00::5' ],
+        'owner': OWNER_4,
+        'protocol': 'tcp',
+        'towildcards': [ 'vmall' ],
+        'ports': [ '[1,65535]' ],
+        'uuid': RULE_11_UUID,
+        'version': RULE_11_VERSION
+    },
+    'fwapi': {
+        'rule': 'FROM ip fd00::5 TO all vms ALLOW tcp PORT all',
+        'uuid': RULE_11_UUID,
+        'owner_uuid': OWNER_4,
+        'version': RULE_11_VERSION,
+        'enabled': true
+    }
+};
+
+
+// IPv6 subnet rule
+rules[RULE_12_UUID] = {
+    'v1': {
+        '_v': 1,
+        'action': 'allow',
+        'enabled': true,
+        'fromsubnets': [ 'fc00::/7' ],
+        'owner': OWNER_4,
+        'protocol': 'udp',
+        'towildcards': [ 'vmall' ],
+        'ports': [ '[22,22]', '[80,80]' ],
+        'uuid': RULE_12_UUID,
+        'version': RULE_12_VERSION
+    },
+    'fwapi': {
+        'rule': 'FROM subnet fc00::/7 TO all vms ALLOW '
+            + 'udp (PORT 22 AND PORT 80)',
+        'uuid': RULE_12_UUID,
+        'owner_uuid': OWNER_4,
+        'version': RULE_12_VERSION,
+        'enabled': true
+    }
+};
+
+
+function generateRule() {
+    var rule_uuid = mod_uuid.v4();
+    var owner_uuid = mod_uuid.v4();
+    var vm_uuid = mod_uuid.v4();
+
+    assert.ok(!rules.hasOwnProperty(rule_uuid), 'unused uuid');
+
+    var offset = getRandomInt(10, 5000);
+    var start = getRandomInt(1, 60000);
+    var end = start + offset;
+    var version = fwrule.generateVersion();
+    var desc = fmt(GENERIC_DESC, vm_uuid, start, end);
+
+    rules[rule_uuid] = {
+        'ufds': {
+            'action': [ 'allow' ],
+            'description': [ desc ],
+            'enabled': [ 'true' ],
+            'fromvm': [ vm_uuid ],
+            'objectclass': UFDS_FWRULE_CLASS,
+            'owner': [ owner_uuid ],
+            'ports': [ fmt('%d-%d', start, end) ],
+            'protocol': [ 'tcp' ],
+            'totag': [ 'role=foo=4' ],
+            'uuid': [ rule_uuid ],
+            'version': version,
+            '_parent': UFDS_FWRULE_PARENT
+        },
+        'v1': {
+            '_v': 1,
+            'action': 'allow',
+            'description': desc,
+            'enabled': true,
+            'fromvms': [ vm_uuid ],
+            'owner': owner_uuid,
+            'ports': [ fmt('[%d,%d]', start, end) ],
+            'protocol': 'tcp',
+            'totags': [ 'role=foo=4' ],
+            'totagkeys': [ 'role' ],
+            'uuid': rule_uuid,
+            'version': version
+        },
+        'fwapi': {
+            'rule': fmt(GENERIC_RULE, vm_uuid, start, end),
+            'description': desc,
+            'uuid': rule_uuid,
+            'version': version,
+            'owner_uuid': owner_uuid,
+            'enabled': true
+        }
+    };
+}
+
+
+/**
+ * Generate a large number of generic rules to force multiple rounds
+ * of reindexing/migration/etc.
+ */
+for (var i = 0; i < GENERIC_COUNT; i++) {
+    generateRule();
+}
+
+
+// --- Updates-related exports
+
+
+var ORIG_UPDATE_SCHEMA = {
+    index: {
+        host: { type: 'string' },
+        uuid: { type: 'string', unique: true },
+        _v: { type: 'number' }
+    }
+};
+
+
+var UPDATE_1_UUID = mod_uuid.v1();
+var UPDATE_2_UUID = mod_uuid.v1();
+var UPDATE_3_UUID = mod_uuid.v1();
+var UPDATE_4_UUID = mod_uuid.v1();
+var UPDATE_5_UUID = mod_uuid.v1();
+
+
+var updates = {};
+
+
+updates[UPDATE_1_UUID] = {
+    'orig': {
+        '_v': 1,
+        'host': UPDATE_HOST,
+        'name': 'fw.del_rule',
+        'value': {
+            'owner_uuid': OWNER_1,
+            'enabled': true,
+            'rule': 'FROM tag a TO tag b BLOCK tcp PORT 80',
+            'uuid': mod_uuid.v4(),
+            'version': fwrule.generateVersion()
+        }
+    }
+};
+
+
+updates[UPDATE_2_UUID] = {
+    'orig': {
+        '_v': 1,
+        'host': UPDATE_HOST,
+        'name': 'sync',
+        'value': {
+            'type': 'sync',
+            'req_id': mod_uuid.v4()
+        }
+    }
+};
+
+
+updates[UPDATE_3_UUID] = {
+    'orig': {
+        '_v': 1,
+        'host': UPDATE_HOST,
+        'name': 'vm.add',
+        'value': {
+            'type': 'vm.add',
+            'owner_uuid': OWNER_1,
+            'uuid': UPDATE_VM,
+            'firewall_enabled': true,
+            'nics': [
+              {
+                'belongs_to_type': 'zone',
+                'belongs_to_uuid': UPDATE_VM,
+                'mac': '90:b8:d0:fb:67:b6',
+                'owner_uuid': OWNER_1,
+                'primary': true,
+                'state': 'provisioning',
+                'ip': '10.0.0.93',
+                'gateway': '10.0.0.1',
+                'mtu': 1500,
+                'netmask': '255.255.255.0',
+                'nic_tag': 'external',
+                'resolvers': [
+                  '8.8.8.8',
+                  '8.8.4.4'
+                ],
+                'vlan_id': 5,
+                'network_uuid': mod_uuid.v4(),
+                'cn_uuid': UPDATE_CN
+              }
+            ],
+            'tags': {
+              'sdc_docker': true
+            }
+        }
+    }
+};
+
+
+updates[UPDATE_4_UUID] = {
+    'orig': {
+        '_v': 1,
+        'host': UPDATE_HOST,
+        'name': 'vm.update',
+        'value': {
+            'type': 'vm.update',
+            'uuid': UPDATE_VM,
+            'set_tags': {
+                'triton.cns.disable': false,
+                'triton.cns.services': 'foo,bar'
+            }
+        }
+    }
+};
+
+
+updates[UPDATE_5_UUID] = {
+    'orig': {
+        '_v': 1,
+        'host': UPDATE_HOST,
+        'name': 'vm.delete',
+        'value': {
+            'type': 'vm.delete',
+            'owner_uuid': OWNER_1,
+            'server_uuid': UPDATE_CN,
+            'uuid': UPDATE_VM
+        }
+    }
+};
+
+
+module.exports = {
+    OWNER_1: OWNER_1,
+    OWNER_2: OWNER_2,
+    OWNER_3: OWNER_3,
+    OWNER_4: OWNER_4,
+
+    RULES_SCHEMA_V1: RULES_SCHEMA_V1,
+    RULE_1_UUID: RULE_1_UUID,
+    RULE_2_UUID: RULE_2_UUID,
+    RULE_3_UUID: RULE_3_UUID,
+    RULE_4_UUID: RULE_4_UUID,
+    RULE_5_UUID: RULE_5_UUID,
+    RULE_6_UUID: RULE_6_UUID,
+    RULE_7_UUID: RULE_7_UUID,
+    RULE_8_UUID: RULE_8_UUID,
+    RULE_9_UUID: RULE_9_UUID,
+    RULE_10_UUID: RULE_10_UUID,
+    GENERIC_COUNT: GENERIC_COUNT,
+    rules: rules,
+
+    ORIG_UPDATE_SCHEMA: ORIG_UPDATE_SCHEMA,
+    updates: updates
+};
diff --git a/test/unit/helpers.js b/test/unit/helpers.js
index 8359552..4d98ebc 100644
--- a/test/unit/helpers.js
+++ b/test/unit/helpers.js
@@ -5,72 +5,112 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2016, Joyent, Inc.
  */
 
 /*
  * Test helpers for FWAPI unit tests
  */
 
-var assert = require('assert-plus');
-var async = require('async');
+'use strict';
+
 var app;
-var clone = require('clone');
+var assert = require('assert-plus');
 var fwapiClient = require('sdc-clients/lib/fwapi');
 var mockery = require('mockery');
 var mocks = require('./mocks');
+var mod_common = require('../lib/common');
+var mod_log = require('../lib/log');
+var mod_moray = require('../../lib/moray');
+var mod_update = require('../../lib/update');
 var mod_uuid = require('node-uuid');
+var moray_sandbox = require('moray-sandbox');
 var os = require('os');
-var restify = require('restify');
-var util = require('util');
-var verror = require('verror');
 
 
 // --- Globals
 
 
 
-var BUCKETS = {};
 var CUR_IP = 1;
 var FWRULE_VERSION = process.env.FWRULE_VERSION || 3;
-// Set to log messages to stderr
-var LOG = process.env.LOG || false;
+var MOCKS_ENABLED = false;
+var MULTI_SUITE_RUN = false;
 var OWNER_UUID = mod_uuid.v4();
-var SERVER;
+var PGHANDLE = null;
+var SERVER = null;
 var SERVER_UUID = mod_uuid.v4();
 
 
+function getPG(log, callback) {
+    if (PGHANDLE !== null) {
+        callback(null, PGHANDLE);
+    } else {
+        moray_sandbox.createPG(log, function (err, pg) {
+            if (pg) {
+                PGHANDLE = pg;
+            }
+            callback(err, pg);
+        });
+    }
+}
+
 
 // --- Exports
 
 
-
 /**
- * Creates a test NAPI server, and returns a client for accessing it
+ * Create a new Moray instance, wait until the client is connected, and then
+ * initialize the UFDS bucket. Once finished, return the Moray client to the
+ * callback.
  */
-function createClientAndServer(callback) {
-    var log;
-    if (LOG) {
-        log = require('bunyan').createLogger({
-            level: (process.env.LOG_LEVEL || 'warn'),
-            name: process.argv[1],
-            stream: process.stderr,
-            serializers: restify.bunyan.serializers,
-            src: true
+function setupMoray(log, callback) {
+    getPG(log, function (pgErr, pg) {
+        if (pgErr) {
+            callback(pgErr);
+            return;
+        }
+
+        pg.spawnMoray(function (mErr, moray) {
+            if (mErr) {
+                callback(mErr);
+                return;
+            }
+
+            mod_moray.waitForConnect(moray, function (wErr) {
+                if (wErr) {
+                    callback(wErr);
+                    return;
+                }
+
+                /* Create a basic ufds bucket to test migrations from UFDS */
+                moray.createBucket('ufds_o_smartdc', {
+                    index: {
+                        'uuid': { type: 'string' },
+                        'objectclass': { type: '[string]' }
+                    }
+                }, function (cErr) {
+                    callback(cErr, moray);
+                });
+            });
         });
+    });
+}
 
-    } else {
-        log = {
-            child: function () { return log; },
-            debug: function () { return false; },
-            error: function () { return false; },
-            info: function () { return false; },
-            level: function () { return (process.env.LOG_LEVEL || 'warn'); },
-            trace: function () { return false; },
-            warn: function () { return false; }
-        };
+
+/**
+ * Creates a test FWAPI server, and returns a client for accessing it
+ */
+function createClientAndServer(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.func(callback, 'callback');
+
+    if (SERVER !== null) {
+        throw new Error('Cannot run multiple FWAPI servers at once!');
     }
 
+    var log = opts.log || mod_log.selectUnitLogger();
+
     setupMocks();
     app = require('../../lib/app');
     var server = app.create({
@@ -83,26 +123,40 @@ function createClientAndServer(callback) {
                 host: 'unused',
                 port: 2020
             },
-            fwrule_version: FWRULE_VERSION,
+            fwrule_version: opts.fwrule_version || FWRULE_VERSION,
             pollInterval: 3000,
             port: 0,
             ufds: { }
         },
         log: log
     });
-    mocks._LOGGER = log;
 
     // XXX: replace with a real mock
     server.vmapi = {};
 
-    server.listen(function () {
-        SERVER = server;
+    function startServerWithMoray(err, moray) {
+        if (err) {
+            moray.close();
+            callback(err);
+            return;
+        }
 
-        return callback(null, new fwapiClient({
-            agent: false,
-            url: server.info().url
-        }));
-    });
+        server.moray = moray;
+        server.listen(function (lErr) {
+            SERVER = server;
+
+            callback(lErr, new fwapiClient({
+                agent: false,
+                url: server.info().url
+            }), moray);
+        });
+    }
+
+    if (opts.moray) {
+        startServerWithMoray(null, opts.moray);
+    } else {
+        setupMoray(log, startServerWithMoray);
+    }
 }
 
 
@@ -135,16 +189,29 @@ function generateVM(override) {
  * Gets update records from the fwapi_updates moray bucket (and deletes them
  * after, since we don't care about actually applying them)
  */
-function getMorayUpdates() {
-    var buckets = mocks._BUCKETS;
+function getMorayUpdates(moray, callback) {
     var updates = [];
-
-    for (var k in buckets.fwapi_updates) {
-        updates.push(buckets.fwapi_updates[k]);
-        delete buckets.fwapi_updates[k];
-    }
-
-    return updates;
+    var req = moray.findObjects(mod_update.BUCKET.name, '(uuid=*)',
+        { sort: { attribute: '_id', order: 'ASC' } });
+    req.on('record', function (rec) {
+        updates.push(rec.value);
+    });
+    req.on('error', callback);
+    req.on('end', function () {
+        var delBatch = updates.map(function (update) {
+            return {
+                bucket: mod_update.BUCKET.name,
+                key: update.uuid,
+                operation: 'delete'
+            };
+        });
+        updates.forEach(function (update) {
+            delete update.uuid;
+        });
+        moray.batch(delBatch, function (err) {
+            callback(err, updates);
+        });
+    });
 }
 
 
@@ -153,7 +220,7 @@ function getMorayUpdates() {
  */
 function morayUpdate(name, val) {
     return {
-        _v: 1,
+        _v: mod_update.BUCKET.version,
         host: os.hostname(),
         name: name,
         value: val
@@ -162,24 +229,48 @@ function morayUpdate(name, val) {
 
 
 function setupMocks() {
-    mockery.enable({ warnOnUnregistered: false });
-    for (var m in mocks) {
-        if (m.indexOf('_') !== 0) {
-            mockery.registerMock(m, mocks[m]);
+    if (!MOCKS_ENABLED) {
+        mockery.enable({ warnOnUnregistered: false });
+        for (var m in mocks) {
+            if (m.indexOf('_') !== 0) {
+                mockery.registerMock(m, mocks[m]);
+            }
         }
+
+        MOCKS_ENABLED = true;
     }
 }
 
 
 /**
- * Stops the test NAPI server
+ * Stops the Postgres server so that it can be cleaned up
  */
-function stopServer(callback) {
+function stopPG() {
+    if (PGHANDLE !== null) {
+        PGHANDLE.stop();
+        PGHANDLE = null;
+    }
+}
+
+
+/**
+ * Stops the test FWAPI server
+ */
+function stopServer(t) {
+    if (!MULTI_SUITE_RUN) {
+        stopPG();
+    }
+
     if (!SERVER) {
-        return callback();
+        t.end();
+        return;
     }
 
-    return SERVER.close(callback);
+    SERVER.close(function (err) {
+        t.ifError(err, 'Server stop');
+        t.end();
+    });
+    SERVER = null;
 }
 
 
@@ -193,10 +284,19 @@ function uuidSort(a, b) {
 
 
 module.exports = {
+    set MULTI_SUITE_RUN(val) {
+        MULTI_SUITE_RUN = val;
+    },
+    get MULTI_SUITE_RUN() {
+        return MULTI_SUITE_RUN;
+    },
     createClientAndServer: createClientAndServer,
+    ifErr: mod_common.ifErr,
     generateVM: generateVM,
     getMorayUpdates: getMorayUpdates,
     morayUpdate: morayUpdate,
+    setupMoray: setupMoray,
+    stopPG: stopPG,
     stopServer: stopServer,
     uuidSort: uuidSort
 };
diff --git a/test/unit/mocks.js b/test/unit/mocks.js
index 5898d62..192f202 100644
--- a/test/unit/mocks.js
+++ b/test/unit/mocks.js
@@ -12,9 +12,10 @@
  * Mock objects for FWAPI unit tests
  */
 
+'use strict';
+
 var EventEmitter = require('events').EventEmitter;
-var mockMoray = require('../lib/mock-moray');
-var mod_uuid = require('node-uuid');
+var mod_filter = require('moray-filter');
 var util = require('util');
 var VError = require('verror').VError;
 
@@ -22,26 +23,27 @@ var VError = require('verror').VError;
 
 // --- Globals
 
-
-
-var LOG;
+var UFDS_CONNECTED = true;
 var UFDS_RULES = {};
 
 
-
 // --- sdc-clients: UFDS
 
 
 
-function fakeUFDSclient() {
+function FakeUFDSclient() {
     var self = this;
     EventEmitter.call(this);
     process.nextTick(function () {
         self.emit('connect');
     });
 }
+util.inherits(FakeUFDSclient, EventEmitter);
+
 
-util.inherits(fakeUFDSclient, EventEmitter);
+Object.defineProperty(FakeUFDSclient.prototype, 'connected', {
+    get: function () { return UFDS_CONNECTED; }
+});
 
 
 function ruleUUIDfromDN(dn) {
@@ -51,7 +53,7 @@ function ruleUUIDfromDN(dn) {
 }
 
 
-fakeUFDSclient.prototype.add = function (dn, raw, callback) {
+FakeUFDSclient.prototype.add = function (dn, raw, callback) {
     var ruleUUID = ruleUUIDfromDN(dn);
     if (ruleUUID) {
         UFDS_RULES[ruleUUID] = raw;
@@ -61,7 +63,7 @@ fakeUFDSclient.prototype.add = function (dn, raw, callback) {
 };
 
 
-fakeUFDSclient.prototype.del = function (dn, callback) {
+FakeUFDSclient.prototype.del = function (dn, callback) {
     var ruleUUID = ruleUUIDfromDN(dn);
     if (ruleUUID) {
         if (!UFDS_RULES.hasOwnProperty(ruleUUID)) {
@@ -75,12 +77,12 @@ fakeUFDSclient.prototype.del = function (dn, callback) {
 };
 
 
-fakeUFDSclient.prototype.close = function (callback) {
+FakeUFDSclient.prototype.close = function (callback) {
     return callback();
 };
 
 
-fakeUFDSclient.prototype.modify = function (dn, change, callback) {
+FakeUFDSclient.prototype.modify = function (dn, change, callback) {
     var ruleUUID = ruleUUIDfromDN(dn);
     if (ruleUUID) {
         UFDS_RULES[ruleUUID] = change.modification;
@@ -90,17 +92,31 @@ fakeUFDSclient.prototype.modify = function (dn, change, callback) {
 };
 
 
-fakeUFDSclient.prototype.search = function (dn, opts, callback) {
+FakeUFDSclient.prototype.search = function (dn, opts, callback) {
+    var rule;
+
     if (opts.scope === 'base') {
         var ruleUUID = ruleUUIDfromDN(dn);
-        var rule = UFDS_RULES[ruleUUIDfromDN(dn)];
+        rule = UFDS_RULES[ruleUUID];
         if (!ruleUUID || !rule) {
-            return callback(null, []);
+            callback(null, []);
+            return;
+        }
+        callback(null, [ rule ]);
+        return;
+    } else if (opts.scope === 'sub') {
+        var results = [];
+        var filter = mod_filter.parse(opts.filter);
+        for (rule in UFDS_RULES) {
+            if (filter.matches(UFDS_RULES[rule])) {
+                results.push(UFDS_RULES[rule]);
+            }
         }
-        return callback(null, [ rule ]);
+        callback(null, results);
+        return;
     }
 
-    return callback(new Error('xxxx'));
+    callback(new Error('xxxx'));
 };
 
 
@@ -118,20 +134,13 @@ function fakeVMAPIclient() {
 module.exports = {
     // -- mocks
 
-    moray: mockMoray,
-
     'sdc-clients': {
         VMAPI: fakeVMAPIclient
     },
 
-    ufds: fakeUFDSclient,
-
-    // -- mock data
-    set _LOGGER(val) {
-        LOG = val;
-    },
+    ufds: FakeUFDSclient,
 
-    get _BUCKETS() {
-        return mockMoray._buckets;
+    set ufdsConnected(val) {
+        UFDS_CONNECTED = val;
     }
 };
diff --git a/test/unit/moray.test.js b/test/unit/moray.test.js
new file mode 100644
index 0000000..232b907
--- /dev/null
+++ b/test/unit/moray.test.js
@@ -0,0 +1,281 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016, Joyent, Inc.
+ */
+
+/*
+ * Moray bucket setup tests
+ */
+
+'use strict';
+
+var constants = require('../../lib/util/constants');
+var h = require('./helpers');
+var migr_data = require('./data/migration');
+var mod_log = require('../lib/log');
+var mod_moray = require('../../lib/moray');
+var mod_rule = require('../../lib/rule');
+var test = require('tape');
+
+// --- Globals
+
+var MORAY = null;
+var MUST_STOP = false;
+
+var ERROR_COUNT = constants.MAX_RETRIES + 1;
+var LOG = mod_log.selectUnitLogger();
+
+var originalDelay = constants.RETRY_DELAY;
+
+var timeError = new Error('Query timed out');
+timeError.name = 'QueryTimeoutError';
+
+var etagError = new Error('Already exists');
+etagError.name = 'EtagConflictError';
+
+
+// --- Helpers
+
+function startupFailure(t, mockFailures) {
+    mod_moray.waitForConnect(MORAY.clone(), function (wErr, moray) {
+        if (h.ifErr(t, wErr, 'waitForConnect() error')) {
+            t.end();
+            return;
+        }
+
+        moray.setMockErrors(mockFailures);
+
+        h.createClientAndServer({
+            log: LOG,
+            moray: moray
+        }, function (cErr) {
+            t.ok(cErr, 'FWAPI startup error');
+
+            h.stopServer(t);
+        });
+    });
+}
+
+
+function startupSuccess(t, mockFailures) {
+    mod_moray.waitForConnect(MORAY.clone(), function (wErr, moray) {
+        if (h.ifErr(t, wErr, 'waitForConnect() error')) {
+            t.end();
+            return;
+        }
+
+        if (mockFailures) {
+            moray.setMockErrors(mockFailures);
+        } else {
+            moray.setMockErrors({});
+        }
+
+        h.createClientAndServer({
+            log: LOG,
+            moray: moray
+        }, function (cErr, res) {
+            t.ok(res, 'client');
+            if (h.ifErr(t, cErr, 'FWAPI startup error')) {
+                t.end();
+                return;
+            }
+
+            h.stopServer(t);
+        });
+    });
+}
+
+
+function loadData(t2) {
+    var key = migr_data.RULE_1_UUID;
+    var obj = migr_data.rules[key].v1;
+    var opts = { etag: null };
+    MORAY.createBucket(mod_rule.BUCKET.name, migr_data.RULES_SCHEMA_V1,
+        function (cErr) {
+        if (h.ifErr(t2, cErr, 'createBucket() error')) {
+            t2.end();
+            return;
+        }
+
+        MORAY.putObject(mod_rule.BUCKET.name, key, obj, opts,
+            function (pErr) {
+            t2.ifErr(pErr, 'putObject() error');
+            t2.end();
+        });
+    });
+}
+
+
+function createClient(t) {
+    h.setupMoray(LOG, function (err, moray) {
+        t.ifErr(err, 'Moray setup error');
+        t.ok(moray, 'moray');
+
+        MORAY = moray;
+        t.end();
+    });
+}
+
+
+function closeClient(t) {
+    MORAY.close();
+    MORAY = null;
+    t.end();
+}
+
+
+function fillArray(item, count) {
+    var arr = [];
+    for (var i = 0; i < count; i++) {
+        arr.push(item);
+    }
+    return arr;
+}
+
+
+// --- Setup
+
+if (!h.MULTI_SUITE_RUN) {
+    h.MULTI_SUITE_RUN = true;
+    MUST_STOP = true;
+}
+
+
+test('Setup', function (t) {
+    // Lower retry delay so that tests don't take forever.
+    constants.RETRY_DELAY = 500;
+    t.end();
+});
+
+
+// --- Tests
+
+test('putBucket() failures and rollbacks', function (t) {
+    t.plan(9);
+
+    t.test('Start Moray server', createClient);
+
+    t.test('Fail to start FWAPI (getBucket() failures)', function (t2) {
+        startupFailure(t2, {
+            getBucket: fillArray(timeError, ERROR_COUNT)
+        });
+    });
+
+    t.test('Fail to start FWAPI (createBucket() failures)', function (t2) {
+        startupFailure(t2, {
+            createBucket: fillArray(timeError, ERROR_COUNT)
+        });
+    });
+
+    t.test('Start FWAPI (creates bucket)', startupSuccess);
+
+    t.test('Start FWAPI (no bucket changes)', startupSuccess);
+
+    t.test('Fail to start FWAPI (updateBucket() failures)', function (t2) {
+        // Roll version forward and restart
+        mod_rule.BUCKET.version += 1;
+        startupFailure(t2, {
+            updateBucket: fillArray(timeError, ERROR_COUNT)
+        });
+    });
+
+    t.test('Start FWAPI (updates bucket)', startupSuccess);
+
+    t.test('Start FWAPI (rollback)', function (t2) {
+        // Roll back version and restart
+        mod_rule.BUCKET.version -= 1;
+        startupSuccess(t2);
+    });
+
+    t.test('Close Moray client', closeClient);
+});
+
+
+test('reindex() failures', function (t) {
+    t.plan(4);
+
+    t.test('Start Moray server', createClient);
+
+    t.test('Fail to start FWAPI (reindexObjects() failures)', function (t2) {
+        startupFailure(t2, {
+            reindexObjects: fillArray(timeError, ERROR_COUNT)
+        });
+    });
+
+    t.test('Start FWAPI (success after several failures)', function (t2) {
+        startupSuccess(t2, {
+            reindexObjects: fillArray(timeError, constants.MAX_RETRIES)
+        });
+    });
+
+    t.test('Close Moray client', closeClient);
+});
+
+
+test('updateRecords() failures', function (t) {
+    t.plan(6);
+
+    t.test('Start Moray server', createClient);
+
+    t.test('Load rule to migrate', loadData);
+
+    t.test('Fail to start FWAPI (findObjects() failures)', function (t2) {
+        startupFailure(t2, {
+            findObjects: fillArray(timeError, ERROR_COUNT)
+        });
+    });
+
+    t.test('Fail to start FWAPI (batch() failures)', function (t2) {
+        startupFailure(t2, {
+            batch: fillArray(timeError, ERROR_COUNT)
+        });
+    });
+
+    t.test('Start FWAPI (success after several failures)', function (t2) {
+        startupSuccess(t2, {
+            batch: fillArray(timeError, constants.MAX_RETRIES)
+        });
+    });
+
+    t.test('Close Moray client', closeClient);
+});
+
+
+test('updateRecords() success after many EtagConflictErrors', function (t) {
+    t.plan(4);
+
+    t.test('Start Moray server', createClient);
+
+    t.test('Load rule to migrate', loadData);
+
+    t.test('Start FWAPI (w/ MAX_RETRIES*2 EtagConflictErrors)', function (t2) {
+        startupSuccess(t2, {
+            batch: fillArray(etagError, constants.MAX_RETRIES * 2)
+        });
+    });
+
+    t.test('Close Moray client', closeClient);
+});
+
+
+// --- Teardown
+
+
+test('Cleanup', function (t) {
+    // Lower retry delay so that tests don't take forever.
+    constants.RETRY_DELAY = originalDelay;
+    t.end();
+});
+
+
+if (MUST_STOP) {
+    test('Stop PG', function (t) {
+        h.stopPG();
+        t.end();
+    });
+}
diff --git a/test/unit/rule.test.js b/test/unit/rule.test.js
index 11a5dc9..cebd86d 100644
--- a/test/unit/rule.test.js
+++ b/test/unit/rule.test.js
@@ -12,6 +12,8 @@
  * Unit tests for the firewall rule object
  */
 
+'use strict';
+
 var test = require('tape');
 var mod_rule = require('../../lib/rule');
 var mod_uuid = require('node-uuid');
@@ -59,9 +61,9 @@ test('all target types', function (t) {
     var subnets = ['192.168.2.0/24', '10.2.1.0/24'];
 
     var inRule = {
-        rule: util.format('FROM (ip %s OR subnet %s OR tag %s OR vm %s) ',
+        rule: util.format('FROM (ip %s OR subnet %s OR tag "%s" OR vm %s) ',
             ips[0], subnets[0], tags[0], vms[0])
-            + util.format('TO (ip %s OR subnet %s OR tag %s OR vm %s)',
+            + util.format('TO (ip %s OR subnet %s OR tag "%s" OR vm %s)',
             ips[1], subnets[1], tags[1], vms[1])
             + ' ALLOW tcp (PORT 80 AND PORT 81)',
         enabled: true,
@@ -92,14 +94,14 @@ test('all target types', function (t) {
     inRule.uuid = rule.uuid;
     inRule.version = rule.version;
 
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
+    t.deepEqual(rule.rawUFDS(), raw, 'rule.rawUFDS()');
     t.deepEqual(rule.serialize(), inRule, 'rule.serialize()');
     t.equal(rule.dn, util.format('uuid=%s, ou=fwrules, o=smartdc', rule.uuid),
         'rule.dn');
 
     // Now recreate the rule from the raw UFDS data
-    var rule2 = mod_rule.create(rule.raw(), app);
-    t.deepEqual(rule2.raw(), raw, 'rule2.raw()');
+    var rule2 = mod_rule.create(rule.rawUFDS(), app);
+    t.deepEqual(rule2.rawUFDS(), raw, 'rule2.rawUFDS()');
     t.deepEqual(rule2.serialize(), inRule, 'rule2.serialize()');
     t.equal(rule2.dn, util.format('uuid=%s, ou=fwrules, o=smartdc', rule.uuid),
         'rule2.dn');
@@ -135,14 +137,14 @@ test('owner_uuid', function (t) {
     inRule.uuid = rule.uuid;
     inRule.version = rule.version;
 
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
+    t.deepEqual(rule.rawUFDS(), raw, 'rule.rawUFDS()');
     t.deepEqual(rule.serialize(), inRule, 'rule.serialize()');
     t.equal(rule.dn, util.format('uuid=%s, ou=fwrules, o=smartdc', rule.uuid),
         'rule.dn');
 
     // Now recreate the rule from the raw UFDS data
-    var rule2 = mod_rule.create(rule.raw(), app);
-    t.deepEqual(rule2.raw(), raw, 'rule2.raw()');
+    var rule2 = mod_rule.create(rule.rawUFDS(), app);
+    t.deepEqual(rule2.rawUFDS(), raw, 'rule2.rawUFDS()');
     t.deepEqual(rule2.serialize(), inRule, 'rule2.serialize()');
     t.equal(rule2.dn, util.format('uuid=%s, ou=fwrules, o=smartdc', rule.uuid),
         'rule2.dn');
@@ -175,14 +177,14 @@ test('multiple tags with multiple quoted values', function (t) {
         uuid: rule.uuid,
         version: rule.version
     };
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
+    t.deepEqual(rule.rawUFDS(), raw, 'rule.rawUFDS()');
 
     var serialized = {
         enabled: false,
         owner_uuid: owner,
         rule: 'FROM (tag "" = "" '
             + 'OR tag "" = "") TO '
-            + '(tag "some tag" = value OR tag some-tag = "another value") '
+            + '(tag "some tag" = "value" OR tag "some-tag" = "another value") '
             + 'ALLOW tcp PORT 80',
         uuid: rule.uuid,
         version: rule.version
@@ -201,8 +203,8 @@ test('multiple tags with multiple quoted values', function (t) {
 
     // Now check that we can reconstruct this data from UFDS
     rule = mod_rule.create(raw, app);
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
+    t.deepEqual(rule.rawUFDS(), raw, 'rule.rawUFDS()');
+    t.deepEqual(rule.rawUFDS(), raw, 'rule.rawUFDS()');
     t.ok(!rule.allVMs, 'rule.allVMs');
     t.deepEqual(rule.tags, ruleTags, 'rule.tags');
 
@@ -220,7 +222,7 @@ test('global', function (t) {
             owner_uuid: mod_uuid.v4(),
             global: true
         });
-    } catch (pErr) {
+    } catch (_) {
         caught = true;
     }
 
diff --git a/test/unit/run.js b/test/unit/run.js
new file mode 100644
index 0000000..56eccba
--- /dev/null
+++ b/test/unit/run.js
@@ -0,0 +1,42 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016, Joyent, Inc.
+ * Copyright 2014, Patrick Mooney.
+ */
+
+'use strict';
+
+var assert = require('assert');
+var fs = require('fs');
+var h = require('./helpers');
+var path = require('path');
+var test = require('tape');
+
+function runTests(directory) {
+    h.MULTI_SUITE_RUN = true;
+
+    fs.readdir(directory, function (err, files) {
+        assert.ifError(err);
+        files.filter(function (f) {
+            return (/\.test\.js$/.test(f));
+        }).map(function (f) {
+            return (path.join(directory, f));
+        }).forEach(require);
+
+        test('Shutdown Postgres', function (t) {
+            h.stopPG();
+            t.end();
+        });
+    });
+}
+
+// --- Run All Tests
+
+(function main() {
+    runTests(__dirname);
+})();
diff --git a/test/unit/ufds-smoke-test.test.js b/test/unit/ufds-smoke-test.test.js
new file mode 100644
index 0000000..e92553d
--- /dev/null
+++ b/test/unit/ufds-smoke-test.test.js
@@ -0,0 +1,396 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * Some simple unit tests that hit /rules endpoints while using a mock
+ * UFDS backend.
+ *
+ * To do a real test of the UFDS code, run the integration tests while
+ * FWRULE_VERSION is set to 2. (Note that some will fail due to issues
+ * with using UFDS as a backend. These tests have been called out in
+ * their test descriptions.)
+ */
+
+'use strict';
+
+var test = require('tape');
+var h = require('./helpers');
+var mocks = require('./mocks');
+var util = require('util');
+
+
+// --- Globals
+
+
+var FWAPI;
+var MORAY;
+var RULES = [];
+var VMS = [ h.generateVM(), h.generateVM() ];
+
+
+// --- Setup
+
+
+test('setup', function (t) {
+    h.createClientAndServer({ fwrule_version: 2 }, function (err, res, moray) {
+        t.ifError(err, 'server creation');
+        t.ok(res, 'client');
+        t.ok(moray, 'moray');
+        FWAPI = res;
+        MORAY = moray;
+        t.end();
+    });
+});
+
+
+// --- Ping tests
+
+
+test('Ping FWAPI', function (t) {
+    t.plan(3);
+
+    t.test('UFDS online', function (t2) {
+        mocks.ufdsConnected = true;
+        FWAPI.ping({}, function (err, stats) {
+            if (h.ifErr(t2, err, 'ping error')) {
+                t2.end();
+                return;
+            }
+
+            t2.deepEqual(stats, {
+                healthy: true,
+                services: {
+                    fast: 'online',
+                    moray: 'online',
+                    ufds: 'online'
+                },
+                status: 'OK'
+            }, 'correct status');
+            t2.end();
+        });
+    });
+
+    t.test('UFDS offline', function (t2) {
+        mocks.ufdsConnected = false;
+        FWAPI.ping({}, function (err, stats) {
+            if (h.ifErr(t2, err, 'ping error')) {
+                t2.end();
+                return;
+            }
+
+            t2.deepEqual(stats, {
+                healthy: false,
+                services: {
+                    fast: 'online',
+                    moray: 'online',
+                    ufds: 'offline'
+                },
+                status: 'offline'
+            }, 'correct status');
+            t2.end();
+        });
+    });
+
+    t.test('UFDS online (w/ "agents")', function (t2) {
+        mocks.ufdsConnected = true;
+        FWAPI.ping({ agents: true }, function (err, stats) {
+            if (h.ifErr(t2, err, 'ping error')) {
+                t2.end();
+                return;
+            }
+
+            t2.deepEqual(stats, {
+                healthy: true,
+                services: {
+                    fast: 'online',
+                    moray: 'online',
+                    ufds: 'online'
+                },
+                status: 'OK',
+                agents: {
+                    connected: [],
+                    ping_id: stats.agents.ping_id
+                }
+            }, 'correct status');
+            t2.end();
+        });
+    });
+});
+
+
+// --- Create tests
+
+
+test('Add rule 1', function (t) {
+    RULES.push({
+        enabled: true,
+        owner_uuid: VMS[0].owner_uuid,
+        rule: util.format('FROM vm %s TO vm %s ALLOW tcp PORT 80',
+            VMS[0].uuid, VMS[1].uuid)
+    });
+
+    FWAPI.createRule(RULES[0], function (err, obj, req, res) {
+        if (h.ifErr(t, err, 'rule create')) {
+            t.end();
+            return;
+        }
+
+        t.equal(res.statusCode, 202, 'status code');
+        t.ok(obj.uuid, 'rule has uuid');
+        t.ok(obj.version, 'rule has version');
+        RULES[0].uuid = obj.uuid;
+        RULES[0].version = obj.version;
+
+        t.deepEqual(obj, RULES[0], 'response');
+        h.getMorayUpdates(MORAY, function (err2, updates) {
+            if (h.ifErr(t, err2, 'getMorayUpdates() error')) {
+                t.end();
+                return;
+            }
+
+            t.deepEqual(updates, [
+                h.morayUpdate('fw.add_rule', RULES[0])
+            ], 'moray updates');
+
+            FWAPI.getRule(RULES[0].uuid, function (err3, res2) {
+                if (h.ifErr(t, err3, 'getRule() error')) {
+                    t.end();
+                    return;
+                }
+
+                t.deepEqual(res2, RULES[0], 'getRule');
+                t.end();
+            });
+        });
+    });
+});
+
+
+test('Add rule 2', function (t) {
+    RULES.push({
+        enabled: true,
+        owner_uuid: VMS[0].owner_uuid,
+        rule: 'FROM tag "foo" TO tag "bar" = "\\)" ALLOW tcp PORT 80'
+    });
+
+    FWAPI.createRule(RULES[1], function (err, obj, req, res) {
+        if (h.ifErr(t, err, 'rule create')) {
+            t.end();
+            return;
+        }
+
+        t.equal(res.statusCode, 202, 'status code');
+        t.ok(obj.uuid, 'rule has uuid');
+        t.ok(obj.version, 'rule has version');
+        RULES[1].uuid = obj.uuid;
+        RULES[1].version = obj.version;
+
+        t.deepEqual(obj, RULES[1], 'response');
+        h.getMorayUpdates(MORAY, function (err2, updates) {
+            if (h.ifErr(t, err2, 'getMorayUpdates() error')) {
+                t.end();
+                return;
+            }
+
+            t.deepEqual(updates, [
+                h.morayUpdate('fw.add_rule', RULES[1])
+            ], 'moray updates');
+
+            FWAPI.getRule(RULES[1].uuid, function (err3, res2) {
+                if (h.ifErr(t, err3, 'getRule() error')) {
+                    t.end();
+                    return;
+                }
+
+                t.deepEqual(res2, RULES[1], 'getRule');
+                t.end();
+            });
+        });
+    });
+});
+
+
+test('Update rule 1', function (t) {
+    var payload = {
+        rule: util.format('FROM vm %s TO vm %s ALLOW tcp (PORT 80 AND PORT 81)',
+            VMS[0].uuid, VMS[1].uuid)
+    };
+    RULES[0].rule = payload.rule;
+
+    FWAPI.updateRule(RULES[0].uuid, payload, function (err, obj, req, res) {
+        if (h.ifErr(t, err, 'rule update')) {
+            t.end();
+            return;
+        }
+
+        t.equal(res.statusCode, 202, 'status code');
+        t.ok(obj.version !== RULES[0].version, 'version updated');
+        RULES[0].version = obj.version;
+
+        t.deepEqual(obj, RULES[0], 'response');
+        h.getMorayUpdates(MORAY, function (err2, updates) {
+            if (h.ifErr(t, err2, 'getMorayUpdates() error')) {
+                t.end();
+                return;
+            }
+
+            t.deepEqual(updates, [
+                h.morayUpdate('fw.update_rule', RULES[0])
+            ], 'moray updates');
+
+            FWAPI.getRule(RULES[0].uuid, function (err3, res2) {
+                if (h.ifErr(t, err3, 'getRule() error')) {
+                    t.end();
+                    return;
+                }
+
+                t.deepEqual(res2, RULES[0], 'getRule');
+                t.end();
+            });
+        });
+    });
+});
+
+
+// --- List tests
+
+
+test('Search for all rules', function (t) {
+    FWAPI.listRules({}, function (err, rules, req, res) {
+        if (h.ifErr(t, err, 'listRules() error')) {
+            t.end();
+            return;
+        }
+
+        t.equal(res.statusCode, 200, 'status code');
+        t.deepEqual(rules, RULES, 'all rules returned');
+        t.end();
+    });
+});
+
+
+test('Search for rule 1', function (t) {
+    function checkResult(t2) {
+        return function (err, rules, req, res) {
+            if (h.ifErr(t2, err, 'listRules() error')) {
+                t2.end();
+                return;
+            }
+
+            t2.equal(res.statusCode, 200, 'status code');
+            t2.deepEqual(rules, [ RULES[0] ], 'all rules returned');
+            t2.end();
+        };
+    }
+
+    t.plan(3);
+
+    t.test('Search for VMS[0]', function (t2) {
+        FWAPI.listRules({ vm: VMS[0] }, checkResult(t2));
+    });
+
+    t.test('Search for VMS[1]', function (t2) {
+        FWAPI.listRules({ vm: VMS[1] }, checkResult(t2));
+    });
+
+    t.test('Search for VMS', function (t2) {
+        FWAPI.listRules({ vm: VMS }, checkResult(t2));
+    });
+});
+
+
+test('Search for rule 2', function (t) {
+    function checkResult(t2) {
+        return function (err, rules, req, res) {
+            if (h.ifErr(t2, err, 'listRules() error')) {
+                t2.end();
+                return;
+            }
+
+            t2.equal(res.statusCode, 200, 'status code');
+            t2.deepEqual(rules, [ RULES[1] ], 'all rules returned');
+            t2.end();
+        };
+    }
+
+    t.plan(3);
+
+    t.test('Search for VMS[0]', function (t2) {
+        FWAPI.listRules({ tag: 'foo' }, checkResult(t2));
+    });
+
+    t.test('Search for VMS[1]', function (t2) {
+        FWAPI.listRules({ tag: 'bar' }, checkResult(t2));
+    });
+
+    t.test('Search for VMS', function (t2) {
+        FWAPI.listRules({ tag: [ 'foo', 'bar' ] }, checkResult(t2));
+    });
+});
+
+
+// --- Delete tests
+
+
+test('Delete rule', function (t) {
+    FWAPI.deleteRule(RULES[0].uuid, function (err, _, req, res) {
+        if (h.ifErr(t, err, 'rule delete')) {
+            t.end();
+            return;
+        }
+
+        t.equal(res.statusCode, 204, 'status code');
+
+        h.getMorayUpdates(MORAY, function (err2, updates) {
+            if (h.ifErr(t, err2, 'getMorayUpdates() error')) {
+                t.end();
+                return;
+            }
+
+            t.deepEqual(updates, [
+                h.morayUpdate('fw.del_rule', RULES[0])
+            ], 'moray updates');
+
+            FWAPI.getRule(RULES[0].uuid, function (err3, res2) {
+                t.ok(err3, 'getRule error');
+                if (!err3) {
+                    t.end();
+                    return;
+                }
+
+                t.deepEqual(err3.body, {
+                    code: 'ResourceNotFound',
+                    message: 'Rule not found'
+                }, 'error body');
+
+                FWAPI.deleteRule(RULES[0].uuid, function (err4, res3) {
+                    t.ok(err4, 'deleteRule error');
+                    if (!err4) {
+                        t.end();
+                        return;
+                    }
+
+                    t.deepEqual(err4.body, {
+                        code: 'ResourceNotFound',
+                        message: 'Rule not found'
+                    }, 'error body');
+
+                    t.end();
+                });
+            });
+        });
+    });
+});
+
+
+// --- Teardown
+
+
+test('Stop server', h.stopServer);
diff --git a/test/unit/ufds-to-moray.test.js b/test/unit/ufds-to-moray.test.js
new file mode 100644
index 0000000..609f27a
--- /dev/null
+++ b/test/unit/ufds-to-moray.test.js
@@ -0,0 +1,281 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016, Joyent, Inc.
+ */
+
+/*
+ * UFDS to Moray migration tests
+ */
+
+'use strict';
+
+var constants = require('../../lib/util/constants');
+var h = require('./helpers');
+var migr_data = require('./data/migration');
+var mod_log = require('../lib/log');
+var mod_rule = require('../../lib/rule');
+var mod_update = require('../../lib/update');
+var mod_vasync = require('vasync');
+var test = require('tape');
+
+// --- Globals
+
+var MORAY;
+var FWAPI;
+var RULE_COUNT = 9 + migr_data.GENERIC_COUNT;
+var UFDS_BUCKET = 'ufds_o_smartdc';
+
+// A limit higher than the rules we have.
+var ADJ_LIMIT = RULE_COUNT + 100;
+
+var rules = migr_data.rules;
+var updates = migr_data.updates;
+
+
+// --- Helpers
+
+
+function zeroUFDSrules(t) {
+    var res = MORAY.findObjects(UFDS_BUCKET, '(objectclass=fwrule)');
+    var count = 0;
+
+    res.on('error', function (err) {
+        h.ifErr(err, 'Listing rules from bucket failed');
+        t.end();
+    });
+
+    res.on('record', function (rec) {
+        t.deepEqual(rec, undefined, 'Firewall rule in UFDS bucket');
+        count += 1;
+    });
+
+    res.on('end', function () {
+        t.equal(count, 0, 'No more rules in UFDS bucket');
+        t.end();
+    });
+}
+
+
+// --- Setup
+
+
+test('Initial setup', function (t) {
+    var log;
+
+    t.plan(5);
+
+    t.test('Start Moray server', function (t2) {
+        log = mod_log.selectUnitLogger();
+        h.setupMoray(log, function (err, moray) {
+            t2.ifErr(err, 'Moray setup error');
+            t2.ok(moray, 'moray');
+
+            MORAY = moray;
+            t2.end();
+        });
+    });
+
+    t.test('Load rules into UFDS bucket', function (t2) {
+        var batch = [];
+        Object.keys(rules).forEach(function (key) {
+            var value = rules[key];
+            if (!value.hasOwnProperty('ufds')) {
+                return;
+            }
+
+            batch.push({
+                bucket: UFDS_BUCKET,
+                operation: 'put',
+                key: key,
+                value: value.ufds,
+                options: { etag: null }
+            });
+        });
+        MORAY.batch(batch, function (err) {
+            t2.ifErr(err, 'Load error');
+            t2.end();
+        });
+    });
+
+    t.test('Create old version of "fwapi_updates"', function (t2) {
+        MORAY.createBucket(mod_update.BUCKET.name,
+            migr_data.ORIG_UPDATE_SCHEMA, function (cErr) {
+            h.ifErr(t2, cErr, 'createBucket() error');
+            t2.end();
+        });
+    });
+
+    t.test('Load pending updates into "fwapi_updates"', function (t2) {
+        mod_vasync.forEachParallel({
+            inputs: Object.keys(updates),
+            func: function (key, cb) {
+                MORAY.putObject(mod_update.BUCKET.name,
+                    key, updates[key].orig, { etag: null }, cb);
+            }
+        }, function (err) {
+            t2.ifErr(err, 'Load error');
+            t2.end();
+        });
+    });
+
+    t.test('Start FWAPI', function (t2) {
+        h.createClientAndServer({
+            log: log,
+            moray: MORAY
+        }, function (err, res) {
+            t2.ifError(err, 'FWAPI startup error');
+            t2.ok(res, 'client');
+
+            FWAPI = res;
+            t2.end();
+        });
+    });
+});
+
+
+// --- Tests
+
+
+test('UFDS bucket no longer contains firewall rules', zeroUFDSrules);
+
+
+test('Check that rules have migrated successfully', function (t) {
+    var originalLimit = constants.DEFAULT_LIMIT;
+    constants.DEFAULT_LIMIT = ADJ_LIMIT;
+
+    FWAPI.listRules({}, {}, function (lErr, fwrules) {
+        constants.DEFAULT_LIMIT = originalLimit;
+
+        if (h.ifErr(t, lErr, 'Error listing rules')) {
+            t.end();
+            return;
+        }
+
+        t.ok(fwrules, 'Rules returned');
+        t.equal(fwrules.length, RULE_COUNT, 'Correct number of rules');
+
+        fwrules.forEach(function (fwrule) {
+            t.ok(rules[fwrule.uuid],
+                fwrule.uuid + ' is one of the original rules');
+            t.deepEqual(fwrule, rules[fwrule.uuid].fwapi,
+                fwrule.uuid + ' matches expected return value');
+        });
+        t.end();
+    });
+});
+
+
+test('"fwapi_rules" bucket contains migrated rules', function (t) {
+    var res = MORAY.findObjects(mod_rule.BUCKET.name, '(uuid=*)',
+        { limit: ADJ_LIMIT });
+    var count = 0;
+
+    res.on('error', function (err) {
+        h.ifErr(err, 'listing rules from bucket failed');
+        t.end();
+    });
+
+    res.on('record', function (rec) {
+        count += 1;
+
+        t.ok(rec, 'Found record');
+        t.ok(rules[rec.value.uuid],
+            rec.value.uuid + ' is one of the original rules');
+        t.deepEqual((new mod_rule.Rule(rec, {})).serialize(),
+            rules[rec.value.uuid].fwapi, 'Correct contents in Moray');
+    });
+
+    res.on('end', function () {
+        t.equal(count, RULE_COUNT, 'All rules are in Moray bucket');
+        t.end();
+    });
+});
+
+
+test('Search for rule that previously had escaped characters', function (t) {
+    t.plan(2);
+
+    t.test('Searching for ""', function (t2) {
+        FWAPI.listRules({ tag: '' }, function (err, fwrules) {
+            if (h.ifErr(t2, err, 'listRules() error')) {
+                t2.end();
+                return;
+            }
+
+            t2.deepEqual(fwrules, [ rules[migr_data.RULE_6_UUID].fwapi ],
+                'Correct rule returned');
+            t2.end();
+        });
+    });
+
+    t.test('Searching for ""', function (t2) {
+        FWAPI.listRules({ tag: '' }, function (err, fwrules) {
+            if (h.ifErr(t2, err, 'listRules() error')) {
+                t2.end();
+                return;
+            }
+
+            t2.deepEqual(fwrules, [ rules[migr_data.RULE_6_UUID].fwapi ],
+                'Correct rule returned');
+            t2.end();
+        });
+    });
+});
+
+
+test('New rule goes to Moray bucket', function (t) {
+    var rule = {
+        rule: 'FROM tag "foo" = "hello-world" TO tag "bar" ALLOW tcp PORT 22',
+        description: 'Rule added after migration',
+        enabled: true,
+        owner_uuid: migr_data.OWNER_4
+    };
+
+    t.plan(3);
+
+    t.test('Add rule to FWAPI', function (t2) {
+        FWAPI.createRule(rule, function (err, obj, req, res) {
+            if (h.ifErr(t2, err, 'createRule() error')) {
+                t.end();
+                return;
+            }
+
+            t2.deepEqual(res.statusCode, 202, 'Status code');
+
+            t2.ok(obj.uuid, 'Rule has UUID');
+            t2.ok(obj.version, 'Rule has version');
+
+            rule.uuid = obj.uuid;
+            rule.version = obj.version;
+
+            t2.deepEqual(obj, rule, 'Returned submitted rule');
+            t2.end();
+        });
+    });
+
+    t.test('Get rule from FWAPI', function (t2) {
+        FWAPI.getRule(rule.uuid, function (err, obj, req, res) {
+            if (h.ifErr(t2, err, 'getRule() error')) {
+                t.end();
+                return;
+            }
+
+            t2.deepEqual(res.statusCode, 200, 'Status code');
+            t2.deepEqual(obj, rule, 'Returned submitted rule');
+            t2.end();
+        });
+    });
+
+    t.test('Nothing added to UFDS bucket', zeroUFDSrules);
+});
+
+
+// --- Teardown
+
+
+test('Stop server', h.stopServer);
diff --git a/test/unit/update.test.js b/test/unit/update.test.js
index 6948b3d..44079ef 100644
--- a/test/unit/update.test.js
+++ b/test/unit/update.test.js
@@ -12,9 +12,10 @@
  * Unit tests for /rules endpoints
  */
 
+'use strict';
+
 var test = require('tape');
 var h = require('./helpers');
-var mocks = require('./mocks');
 var util = require('util');
 
 
@@ -23,10 +24,8 @@ var util = require('util');
 
 
 
-// Set this to any of the exports in this file to only run that test,
-// plus setup and teardown
-var runOne;
 var FWAPI;
+var MORAY;
 var RULES = [];
 var VMS = [ h.generateVM(), h.generateVM() ];
 
@@ -37,10 +36,12 @@ var VMS = [ h.generateVM(), h.generateVM() ];
 
 
 test('setup', function (t) {
-    h.createClientAndServer(function (err, res) {
+    h.createClientAndServer({}, function (err, res, moray) {
         t.ifError(err, 'server creation');
         t.ok(res, 'client');
+        t.ok(moray, 'moray');
         FWAPI = res;
+        MORAY = moray;
         t.end();
     });
 });
@@ -60,9 +61,9 @@ test('Add rule', function (t) {
     });
 
     FWAPI.createRule(RULES[0], function (err, obj, req, res) {
-        t.ifError(err, 'rule create');
-        if (err) {
-            return t.end();
+        if (h.ifErr(t, err, 'rule create')) {
+            t.end();
+            return;
         }
 
         t.equal(res.statusCode, 202, 'status code');
@@ -72,18 +73,25 @@ test('Add rule', function (t) {
         RULES[0].version = obj.version;
 
         t.deepEqual(obj, RULES[0], 'response');
-        t.deepEqual(h.getMorayUpdates(), [
-            h.morayUpdate('fw.add_rule', RULES[0])
-        ], 'moray updates');
-
-        FWAPI.getRule(RULES[0].uuid, function (err2, res2) {
-            t.ifError(err2, 'getRule error');
-            if (err2) {
-                return t.end();
+        h.getMorayUpdates(MORAY, function (err2, updates) {
+            if (h.ifErr(t, err2, 'getMorayUpdates() error')) {
+                t.end();
+                return;
             }
 
-            t.deepEqual(res2, RULES[0], 'getRule');
-            return t.end();
+            t.deepEqual(updates, [
+                h.morayUpdate('fw.add_rule', RULES[0])
+            ], 'moray updates');
+
+            FWAPI.getRule(RULES[0].uuid, function (err3, res2) {
+                if (h.ifErr(t, err3, 'getRule() error')) {
+                    t.end();
+                    return;
+                }
+
+                t.deepEqual(res2, RULES[0], 'getRule');
+                t.end();
+            });
         });
     });
 });
@@ -97,9 +105,9 @@ test('Update rule', function (t) {
     RULES[0].rule = payload.rule;
 
     FWAPI.updateRule(RULES[0].uuid, payload, function (err, obj, req, res) {
-        t.ifError(err, 'rule update');
-        if (err) {
-            return t.end();
+        if (h.ifErr(t, err, 'rule update')) {
+            t.end();
+            return;
         }
 
         t.equal(res.statusCode, 202, 'status code');
@@ -107,74 +115,82 @@ test('Update rule', function (t) {
         RULES[0].version = obj.version;
 
         t.deepEqual(obj, RULES[0], 'response');
-        t.deepEqual(h.getMorayUpdates(), [
-            h.morayUpdate('fw.update_rule', RULES[0])
-        ], 'moray updates');
-
-        FWAPI.getRule(RULES[0].uuid, function (err2, res2) {
-            t.ifError(err2, 'getRule error');
-            if (err2) {
-                return t.end();
+        h.getMorayUpdates(MORAY, function (err2, updates) {
+            if (h.ifErr(t, err2, 'getMorayUpdates() error')) {
+                t.end();
+                return;
             }
 
-            t.deepEqual(res2, RULES[0], 'getRule');
-            return t.end();
+            t.deepEqual(updates, [
+                h.morayUpdate('fw.update_rule', RULES[0])
+            ], 'moray updates');
+
+            FWAPI.getRule(RULES[0].uuid, function (err3, res2) {
+                if (h.ifErr(t, err3, 'getRule() error')) {
+                    t.end();
+                    return;
+                }
+
+                t.deepEqual(res2, RULES[0], 'getRule');
+                t.end();
+            });
         });
     });
 });
 
 
 test('Delete rule', function (t) {
-    FWAPI.deleteRule(RULES[0].uuid, function (err, obj, req, res) {
-        t.ifError(err, 'rule delete');
-        if (err) {
-            return t.end();
+    FWAPI.deleteRule(RULES[0].uuid, function (err, _, req, res) {
+        if (h.ifErr(t, err, 'rule delete')) {
+            t.end();
+            return;
         }
 
         t.equal(res.statusCode, 204, 'status code');
 
-        t.deepEqual(h.getMorayUpdates(), [
-            h.morayUpdate('fw.del_rule', RULES[0])
-        ], 'moray updates');
-
-        FWAPI.getRule(RULES[0].uuid, function (err2, res2) {
-            t.ok(err2, 'getRule error');
-            if (!err2) {
-                return t.end();
+        h.getMorayUpdates(MORAY, function (err2, updates) {
+            if (h.ifErr(t, err2, 'getMorayUpdates() error')) {
+                t.end();
+                return;
             }
 
-            t.deepEqual(err2.body, {
-                code: 'ResourceNotFound',
-                message: 'Rule not found'
-            }, 'error body');
+            t.deepEqual(updates, [
+                h.morayUpdate('fw.del_rule', RULES[0])
+            ], 'moray updates');
 
-            FWAPI.deleteRule(RULES[0].uuid, function (err3, res3) {
-                t.ok(err3, 'deleteRule error');
+            FWAPI.getRule(RULES[0].uuid, function (err3, res2) {
+                t.ok(err3, 'getRule error');
                 if (!err3) {
-                    return t.end();
+                    t.end();
+                    return;
                 }
 
                 t.deepEqual(err3.body, {
+                    code: 'ResourceNotFound',
+                    message: 'Rule not found'
+                }, 'error body');
+
+                FWAPI.deleteRule(RULES[0].uuid, function (err4, res3) {
+                    t.ok(err4, 'deleteRule error');
+                    if (!err4) {
+                        t.end();
+                        return;
+                    }
+
+                    t.deepEqual(err4.body, {
                         code: 'ResourceNotFound',
                         message: 'Rule not found'
-                }, 'error body');
+                    }, 'error body');
 
-                return t.end();
+                    t.end();
+                });
             });
-
         });
     });
 });
 
 
-
 // --- Teardown
 
 
-
-test('Stop server', function (t) {
-    h.stopServer(function (err) {
-        t.ifError(err, 'server stop');
-        t.end();
-    });
-});
+test('Stop server', h.stopServer);
diff --git a/test/unit/v1-to-latest.test.js b/test/unit/v1-to-latest.test.js
new file mode 100644
index 0000000..9eb0825
--- /dev/null
+++ b/test/unit/v1-to-latest.test.js
@@ -0,0 +1,287 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016, Joyent, Inc.
+ */
+
+/*
+ * Rule Moray format migration tests: v1 to latest
+ */
+
+'use strict';
+
+var constants = require('../../lib/util/constants');
+var h = require('./helpers');
+var migr_data = require('./data/migration');
+var mod_log = require('../lib/log');
+var mod_rule = require('../../lib/rule');
+var mod_update = require('../../lib/update');
+var mod_vasync = require('vasync');
+var test = require('tape');
+
+// --- Globals
+
+var MORAY;
+var FWAPI;
+var RULE_COUNT = 12 + migr_data.GENERIC_COUNT;
+
+// A limit higher than the rules we have.
+var ADJ_LIMIT = RULE_COUNT + 100;
+
+var rules = migr_data.rules;
+var updates = migr_data.updates;
+
+// --- Helpers
+
+
+function zeroV1rules(t) {
+    var res = MORAY.findObjects(mod_rule.BUCKET.name, '(_v=1)');
+    var count = 0;
+
+    res.on('error', function (err) {
+        h.ifErr(err, 'Listing rules from bucket failed');
+        t.end();
+    });
+
+    res.on('record', function (rec) {
+        t.deepEqual(rec, undefined, 'v1 firewall rule in rules bucket');
+        count += 1;
+    });
+
+    res.on('end', function () {
+        t.equal(count, 0, 'No more v1 rules in rules bucket');
+        t.end();
+    });
+}
+
+
+// --- Setup
+
+
+test('Initial setup', function (t) {
+    var log;
+
+    t.plan(6);
+
+    t.test('Start Moray server', function (t2) {
+        log = mod_log.selectUnitLogger();
+        h.setupMoray(log, function (err, moray) {
+            t2.ifErr(err, 'Moray setup error');
+            t2.ok(moray, 'moray');
+
+            MORAY = moray;
+            t2.end();
+        });
+    });
+
+    t.test('Create old version of rules bucket', function (t2) {
+        MORAY.createBucket(mod_rule.BUCKET.name,
+            migr_data.RULES_SCHEMA_V1, function (cErr) {
+            h.ifErr(t2, cErr, 'createBucket() error');
+            t2.end();
+        });
+    });
+
+    t.test('Load rules into rules bucket', function (t2) {
+        var batch = [];
+        Object.keys(rules).forEach(function (key) {
+            var value = rules[key];
+            if (!value.hasOwnProperty('v1')) {
+                return;
+            }
+
+            batch.push({
+                bucket: mod_rule.BUCKET.name,
+                operation: 'put',
+                key: key,
+                value: value.v1,
+                options: { etag: null }
+            });
+        });
+        MORAY.batch(batch, function (err) {
+            t2.ifErr(err, 'Load error');
+            t2.end();
+        });
+    });
+
+    t.test('Create old version of "fwapi_updates"', function (t2) {
+        MORAY.createBucket(mod_update.BUCKET.name,
+            migr_data.ORIG_UPDATE_SCHEMA, function (cErr) {
+            h.ifErr(t2, cErr, 'createBucket() error');
+            t2.end();
+        });
+    });
+
+    t.test('Load pending updates into "fwapi_updates"', function (t2) {
+        mod_vasync.forEachParallel({
+            inputs: Object.keys(updates),
+            func: function (key, cb) {
+                MORAY.putObject(mod_update.BUCKET.name,
+                    key, updates[key].orig, { etag: null }, cb);
+            }
+        }, function (err) {
+            t2.ifErr(err, 'Load error');
+            t2.end();
+        });
+    });
+
+    t.test('Start FWAPI', function (t2) {
+        h.createClientAndServer({
+            log: log,
+            moray: MORAY
+        }, function (err, res) {
+            t2.ifError(err, 'FWAPI startup error');
+            t2.ok(res, 'client');
+
+            FWAPI = res;
+            t2.end();
+        });
+    });
+});
+
+
+// --- Tests
+
+
+test('Rules bucket no longer contains v1 firewall rules', zeroV1rules);
+
+
+test('Check that rules have migrated successfully', function (t) {
+    var originalLimit = constants.DEFAULT_LIMIT;
+    constants.DEFAULT_LIMIT = ADJ_LIMIT;
+
+    FWAPI.listRules({}, {}, function (lErr, fwrules) {
+        constants.DEFAULT_LIMIT = originalLimit;
+
+        if (h.ifErr(t, lErr, 'Error listing rules')) {
+            t.end();
+            return;
+        }
+
+        t.ok(fwrules, 'Rules returned');
+        t.equal(fwrules.length, RULE_COUNT, 'Correct number of rules');
+
+        fwrules.forEach(function (fwrule) {
+            t.ok(rules[fwrule.uuid],
+                fwrule.uuid + ' is one of the original rules');
+            t.deepEqual(fwrule, rules[fwrule.uuid].fwapi,
+                fwrule.uuid + ' matches expected return value');
+        });
+        t.end();
+    });
+});
+
+
+test('"fwapi_rules" bucket still contains all rules', function (t) {
+    var res = MORAY.findObjects(mod_rule.BUCKET.name, '(uuid=*)',
+        { limit: ADJ_LIMIT });
+    var count = 0;
+
+    res.on('error', function (err) {
+        h.ifErr(err, 'listing rules from bucket failed');
+        t.end();
+    });
+
+    res.on('record', function (rec) {
+        count += 1;
+
+        t.ok(rec, 'Found record');
+        t.ok(rules[rec.value.uuid],
+            rec.value.uuid + ' is one of the original rules');
+        t.deepEqual((new mod_rule.Rule(rec, {})).serialize(),
+            rules[rec.value.uuid].fwapi, 'Correct contents in Moray');
+    });
+
+    res.on('end', function () {
+        t.equal(count, RULE_COUNT, 'All rules are in Moray bucket');
+        t.end();
+    });
+});
+
+
+test('Search for rule that previously had escaped characters', function (t) {
+    t.plan(2);
+
+    t.test('Searching for ""', function (t2) {
+        FWAPI.listRules({ tag: '' }, function (err, fwrules) {
+            if (h.ifErr(t2, err, 'listRules() error')) {
+                t2.end();
+                return;
+            }
+
+            t2.deepEqual(fwrules, [ rules[migr_data.RULE_6_UUID].fwapi ],
+                'Correct rule returned');
+            t2.end();
+        });
+    });
+
+    t.test('Searching for ""', function (t2) {
+        FWAPI.listRules({ tag: '' }, function (err, fwrules) {
+            if (h.ifErr(t2, err, 'listRules() error')) {
+                t2.end();
+                return;
+            }
+
+            t2.deepEqual(fwrules, [ rules[migr_data.RULE_6_UUID].fwapi ],
+                'Correct rule returned');
+            t2.end();
+        });
+    });
+});
+
+test('No new v1 rules created', function (t) {
+    var rule = {
+        rule: 'FROM tag "foo" = "hello-world" TO tag "bar" ALLOW tcp PORT 22',
+        description: 'Rule added after migration',
+        enabled: true,
+        owner_uuid: migr_data.OWNER_4
+    };
+
+    t.plan(3);
+
+    t.test('Add rule to FWAPI', function (t2) {
+        FWAPI.createRule(rule, function (err, obj, req, res) {
+            if (h.ifErr(t2, err, 'createRule() error')) {
+                t2.end();
+                return;
+            }
+
+            t2.deepEqual(res.statusCode, 202, 'Status code');
+
+            t2.ok(obj.uuid, 'Rule has UUID');
+            t2.ok(obj.version, 'Rule has version');
+
+            rule.uuid = obj.uuid;
+            rule.version = obj.version;
+
+            t2.deepEqual(obj, rule, 'Returned submitted rule');
+            t2.end();
+        });
+    });
+
+    t.test('Get rule from FWAPI', function (t2) {
+        FWAPI.getRule(rule.uuid, function (err, obj, req, res) {
+            if (h.ifErr(t2, err, 'getRule() error')) {
+                t2.end();
+                return;
+            }
+
+            t2.deepEqual(res.statusCode, 200, 'Status code');
+            t2.deepEqual(obj, rule, 'Returned submitted rule');
+            t2.end();
+        });
+    });
+
+    t.test('No v1 rules created', zeroV1rules);
+});
+
+
+// --- Teardown
+
+
+
+test('Stop server', h.stopServer);
diff --git a/test/unit/wrap-integration.test.js b/test/unit/wrap-integration.test.js
new file mode 100644
index 0000000..bbe1b63
--- /dev/null
+++ b/test/unit/wrap-integration.test.js
@@ -0,0 +1,50 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016, Joyent, Inc.
+ */
+
+/*
+ * Unit tests for /rules endpoints
+ */
+
+'use strict';
+
+var test = require('tape');
+var h = require('./helpers');
+var mod_client = require('../lib/client');
+var mod_log = require('../lib/log');
+
+
+
+// --- Setup
+
+mod_log.set(mod_log.selectUnitLogger());
+
+test('setup', function (t) {
+    h.createClientAndServer({}, function (err, res, moray) {
+        t.ifError(err, 'server creation');
+        t.ok(res, 'client');
+        t.ok(moray, 'moray');
+        mod_client.CLIENTS['fwapi'] = res;
+        t.end();
+    });
+});
+
+
+// --- Simple integration tests
+
+require('../integration/get.test.js');
+require('../integration/global.test.js');
+require('../integration/list.test.js');
+require('../integration/resolve.test.js');
+require('../integration/update.test.js');
+
+
+// --- Teardown
+
+test('Stop server', h.stopServer);
diff --git a/tools/eslint.node.conf b/tools/eslint.node.conf
new file mode 100644
index 0000000..95fcdd8
--- /dev/null
+++ b/tools/eslint.node.conf
@@ -0,0 +1,21 @@
+{
+    "plugins": [ "joyent" ],
+    "extends": [
+        "eslint:recommended",
+        "plugin:joyent/style",
+        "plugin:joyent/lint"
+    ],
+    "parserOptions": {
+        "ecmaVersion": 5,
+        "sourceType": "script",
+        "ecmaFeatures": {
+        }
+    },
+    "env": {
+        "node": true
+    },
+    "rules": {
+        "strict": [ "error", "global" ],
+        "object-curly-newline": "off"
+    }
+}
diff --git a/tools/jsl.node.conf b/tools/jsl.node.conf
index c7eed92..b8354e4 100644
--- a/tools/jsl.node.conf
+++ b/tools/jsl.node.conf
@@ -32,7 +32,7 @@
 +legacy_cc_not_understood     # couldn't understand control comment using /*@keyword@*/ syntax
 +meaningless_block            # meaningless block; curly braces have no impact
 +mismatch_ctrl_comments       # mismatched control comment; "ignore" and "end" control comments must have a one-to-one correspondence
-+misplaced_regex              # regular expressions should be preceded by a left parenthesis, assignment, colon, or comma
+-misplaced_regex              # regular expressions should be preceded by a left parenthesis, assignment, colon, or comma
 +missing_break                # missing break statement
 +missing_break_for_last_case  # missing break statement for last case in switch
 +missing_default_case         # missing default case in switch statement
@@ -52,7 +52,7 @@
 +unreachable_code             # unreachable code
 -unreferenced_argument        # argument declared but never referenced: {name}
 -unreferenced_function        # function is declared but never referenced: {name}
-+unreferenced_variable        # variable is declared but never referenced: {name}
+-unreferenced_variable        # variable is declared but never referenced: {name}
 +unsupported_version          # JavaScript {version} is not supported
 +use_of_label                 # use of label
 +useless_assign               # useless assignment
@@ -60,7 +60,7 @@
 -useless_quotes               # the quotation marks are unnecessary
 +useless_void                 # use of the void type may be unnecessary (void is always undefined)
 +var_hides_arg                # variable {name} hides argument
-+want_assign_or_call          # expected an assignment or function call
+-want_assign_or_call          # expected an assignment or function call
 +with_statement               # with statement hides undeclared variables; use temporary variable instead
 
 
@@ -118,6 +118,7 @@
 +define module
 +define process
 +define require
++define setImmediate
 +define setInterval
 +define setTimeout
 +define Buffer
-- 
2.21.0

